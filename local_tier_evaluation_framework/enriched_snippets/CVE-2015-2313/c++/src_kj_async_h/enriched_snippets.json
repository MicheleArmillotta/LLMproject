[
  {
    "function_name": "WaitScope",
    "container": "WaitScope",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
    "lines": "657-657",
    "snippet": "inline explicit WaitScope(EventLoop& loop): loop(loop) { loop.enterScope(); }",
    "includes": [
      "#include \"async-inl.h\"",
      "#include \"tuple.h\"",
      "#include \"refcount.h\"",
      "#include \"exception.h\"",
      "#include \"async-prelude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loop.enterScope",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nWaitScope {\n  inline explicit WaitScope(EventLoop& loop): loop(loop) { loop.enterScope(); }\n}"
  },
  {
    "function_name": "mvCapture",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
    "lines": "383-395",
    "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
    "includes": [
      "#include \"async-inl.h\"",
      "#include \"tuple.h\"",
      "#include \"refcount.h\"",
      "#include \"exception.h\"",
      "#include \"async-prelude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CaptureByMove<Func, Decay<MovedParam>>",
          "args": [
            "kj::fwd<Func>(func)",
            "kj::mv(param)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "param"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Func>",
          "args": [
            "func"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
  },
  {
    "function_name": "CaptureByMove",
    "container": "CaptureByMove",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
    "lines": "368-369",
    "snippet": "inline CaptureByMove(Func&& func, MovedParam&& param)\n      : func(kj::mv(func)), param(kj::mv(param)) {}",
    "includes": [
      "#include \"async-inl.h\"",
      "#include \"tuple.h\"",
      "#include \"refcount.h\"",
      "#include \"exception.h\"",
      "#include \"async-prelude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "param"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "func"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nCaptureByMove {\n  inline CaptureByMove(Func&& func, MovedParam&& param)\n        : func(kj::mv(func)), param(kj::mv(param)) {}\n}"
  },
  {
    "function_name": "ForkedPromise",
    "container": "ForkedPromise",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
    "lines": "319-319",
    "snippet": "inline ForkedPromise(bool, Own<_::ForkHub<_::FixVoid<T>>>&& hub): hub(kj::mv(hub)) {}",
    "includes": [
      "#include \"async-inl.h\"",
      "#include \"tuple.h\"",
      "#include \"refcount.h\"",
      "#include \"exception.h\"",
      "#include \"async-prelude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "hub"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nForkedPromise {\n  inline ForkedPromise(bool, Own<_::ForkHub<_::FixVoid<T>>>&& hub): hub(kj::mv(hub)) {}\n}"
  },
  {
    "function_name": "ForkedPromise",
    "container": "ForkedPromise",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
    "lines": "311-311",
    "snippet": "inline ForkedPromise(decltype(nullptr)) {}",
    "includes": [
      "#include \"async-inl.h\"",
      "#include \"tuple.h\"",
      "#include \"refcount.h\"",
      "#include \"exception.h\"",
      "#include \"async-prelude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nForkedPromise {\n  inline ForkedPromise(decltype(nullptr)) {}\n}"
  },
  {
    "function_name": "Promise",
    "container": "Promise",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
    "lines": "285-285",
    "snippet": "Promise(bool, Own<_::PromiseNode>&& node): PromiseBase(kj::mv(node)) {}",
    "includes": [
      "#include \"async-inl.h\"",
      "#include \"tuple.h\"",
      "#include \"refcount.h\"",
      "#include \"exception.h\"",
      "#include \"async-prelude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nPromise {\n  Promise(bool, Own<_::PromiseNode>&& node): PromiseBase(kj::mv(node)) {}\n}"
  },
  {
    "function_name": "Promise",
    "container": "Promise",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
    "lines": "138-138",
    "snippet": "inline Promise(decltype(nullptr)) {}",
    "includes": [
      "#include \"async-inl.h\"",
      "#include \"tuple.h\"",
      "#include \"refcount.h\"",
      "#include \"exception.h\"",
      "#include \"async-prelude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nPromise {\n  inline Promise(decltype(nullptr)) {}\n}"
  }
]