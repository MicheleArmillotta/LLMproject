[
  {
    "function_name": "setCapacity",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "112-119",
    "snippet": "void setCapacity(size_t newSize) {\n    ArrayBuilder<T> newBuilder = heapArrayBuilder<T>(newSize);\n    size_t moveCount = kj::min(newSize, builder.size());\n    for (size_t i = 0; i < moveCount; i++) {\n      newBuilder.add(kj::mv(builder[i]));\n    }\n    builder = kj::mv(newBuilder);\n  }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newBuilder"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBuilder.add",
          "args": [
            "kj::mv(builder[i])"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "builder[i]"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "newSize",
            "builder.size()"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.size",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "52-52",
          "snippet": "inline size_t size() const { return builder.size(); }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t size() const { return builder.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<T>",
          "args": [
            "newSize"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  void setCapacity(size_t newSize) {\n      ArrayBuilder<T> newBuilder = heapArrayBuilder<T>(newSize);\n      size_t moveCount = kj::min(newSize, builder.size());\n      for (size_t i = 0; i < moveCount; i++) {\n        newBuilder.add(kj::mv(builder[i]));\n      }\n      builder = kj::mv(newBuilder);\n    }\n}"
  },
  {
    "function_name": "grow",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "109-111",
    "snippet": "void grow(size_t minCapacity = 0) {\n    setCapacity(kj::max(minCapacity, capacity() == 0 ? 4 : capacity() * 2));\n  }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setCapacity",
          "args": [
            "kj::max(minCapacity, capacity() == 0 ? 4 : capacity() * 2)"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "setCapacity",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "112-119",
          "snippet": "void setCapacity(size_t newSize) {\n    ArrayBuilder<T> newBuilder = heapArrayBuilder<T>(newSize);\n    size_t moveCount = kj::min(newSize, builder.size());\n    for (size_t i = 0; i < moveCount; i++) {\n      newBuilder.add(kj::mv(builder[i]));\n    }\n    builder = kj::mv(newBuilder);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  void setCapacity(size_t newSize) {\n      ArrayBuilder<T> newBuilder = heapArrayBuilder<T>(newSize);\n      size_t moveCount = kj::min(newSize, builder.size());\n      for (size_t i = 0; i < moveCount; i++) {\n        newBuilder.add(kj::mv(builder[i]));\n      }\n      builder = kj::mv(newBuilder);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "minCapacity",
            "capacity() == 0 ? 4 : capacity() * 2"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capacity",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "capacity",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "54-54",
          "snippet": "inline size_t capacity() const { return builder.capacity(); }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t capacity() const { return builder.capacity(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  void grow(size_t minCapacity = 0) {\n      setCapacity(kj::max(minCapacity, capacity() == 0 ? 4 : capacity() * 2));\n    }\n}"
  },
  {
    "function_name": "resize",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "96-104",
    "snippet": "inline void resize(size_t size) {\n    if (size > builder.capacity()) grow(size);\n    while (builder.size() < size) {\n      builder.add(T());\n    }\n    while (builder.size() > size) {\n      builder.removeLast();\n    }\n  }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.removeLast",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "removeLast",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "92-94",
          "snippet": "inline void removeLast() {\n    builder.removeLast();\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void removeLast() {\n      builder.removeLast();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.size",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "52-52",
          "snippet": "inline size_t size() const { return builder.size(); }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t size() const { return builder.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.add",
          "args": [
            "T()"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "T",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "TestNoexceptObject",
          "container": "TestNoexceptObject",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
          "lines": "64-67",
          "snippet": "TestNoexceptObject() noexcept {\n    index = count;\n    ++count;\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <list>",
            "#include <string>",
            "#include \"debug.h\"",
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTestNoexceptObject {\n  TestNoexceptObject() noexcept {\n      index = count;\n      ++count;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "grow",
          "args": [
            "size"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.capacity",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "capacity",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "54-54",
          "snippet": "inline size_t capacity() const { return builder.capacity(); }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t capacity() const { return builder.capacity(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void resize(size_t size) {\n      if (size > builder.capacity()) grow(size);\n      while (builder.size() < size) {\n        builder.add(T());\n      }\n      while (builder.size() > size) {\n        builder.removeLast();\n      }\n    }\n}"
  },
  {
    "function_name": "removeLast",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "92-94",
    "snippet": "inline void removeLast() {\n    builder.removeLast();\n  }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void removeLast() {\n      builder.removeLast();\n    }\n}"
  },
  {
    "function_name": "addAll",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "88-90",
    "snippet": "inline void addAll(Container&& container) {\n    addAll(container.begin(), container.end());\n  }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.end",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "container.begin",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Container&& container) {\n      addAll(container.begin(), container.end());\n    }\n}"
  },
  {
    "function_name": "addAll",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "81-85",
    "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "grow",
          "args": [
            "needed"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.capacity",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "capacity",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "54-54",
          "snippet": "inline size_t capacity() const { return builder.capacity(); }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t capacity() const { return builder.capacity(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.size",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "52-52",
          "snippet": "inline size_t size() const { return builder.size(); }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t size() const { return builder.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
  },
  {
    "function_name": "releaseAsArray",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "66-72",
    "snippet": "inline Array<T> releaseAsArray() {\n    // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n    if (!builder.isFull()) {\n      setCapacity(size());\n    }\n    return builder.finish();\n  }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setCapacity",
          "args": [
            "size()"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "setCapacity",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "112-119",
          "snippet": "void setCapacity(size_t newSize) {\n    ArrayBuilder<T> newBuilder = heapArrayBuilder<T>(newSize);\n    size_t moveCount = kj::min(newSize, builder.size());\n    for (size_t i = 0; i < moveCount; i++) {\n      newBuilder.add(kj::mv(builder[i]));\n    }\n    builder = kj::mv(newBuilder);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  void setCapacity(size_t newSize) {\n      ArrayBuilder<T> newBuilder = heapArrayBuilder<T>(newSize);\n      size_t moveCount = kj::min(newSize, builder.size());\n      for (size_t i = 0; i < moveCount; i++) {\n        newBuilder.add(kj::mv(builder[i]));\n      }\n      builder = kj::mv(newBuilder);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "size",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "52-52",
          "snippet": "inline size_t size() const { return builder.size(); }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t size() const { return builder.size(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.isFull",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "isFull",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "384-386",
          "snippet": "inline bool isFull() const {\n    return pos == endPtr;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  inline bool isFull() const {\n      return pos == endPtr;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline Array<T> releaseAsArray() {\n      // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n      if (!builder.isFull()) {\n        setCapacity(size());\n      }\n      return builder.finish();\n    }\n}"
  },
  {
    "function_name": "capacity",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "54-54",
    "snippet": "inline size_t capacity() const { return builder.capacity(); }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t capacity() const { return builder.capacity(); }\n}"
  },
  {
    "function_name": "empty",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "53-53",
    "snippet": "inline bool empty() const { return size() == 0; }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "size",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "52-52",
          "snippet": "inline size_t size() const { return builder.size(); }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t size() const { return builder.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline bool empty() const { return size() == 0; }\n}"
  },
  {
    "function_name": "size",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "52-52",
    "snippet": "inline size_t size() const { return builder.size(); }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline size_t size() const { return builder.size(); }\n}"
  },
  {
    "function_name": "asPtr",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "50-50",
    "snippet": "inline ArrayPtr<const T> asPtr() const { return builder.asPtr(); }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline ArrayPtr<const T> asPtr() const { return builder.asPtr(); }\n}"
  },
  {
    "function_name": "asPtr",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "49-49",
    "snippet": "inline ArrayPtr<T> asPtr() { return builder.asPtr(); }",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline ArrayPtr<T> asPtr() { return builder.asPtr(); }\n}"
  },
  {
    "function_name": "Vector",
    "container": "Vector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
    "lines": "45-45",
    "snippet": "inline explicit Vector(size_t capacity): builder(heapArrayBuilder<T>(capacity)) {}",
    "includes": [
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heapArrayBuilder<T>",
          "args": [
            "capacity"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline explicit Vector(size_t capacity): builder(heapArrayBuilder<T>(capacity)) {}\n}"
  }
]