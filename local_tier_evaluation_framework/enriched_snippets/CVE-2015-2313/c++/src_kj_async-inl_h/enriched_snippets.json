[
  {
    "function_name": "newPromiseAndFulfiller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "946-955",
    "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "wrapper"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::maybeChain",
          "args": [
            "kj::mv(intermediate)",
            "implicitCast<T*>(nullptr)"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "maybeChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "444-446",
          "snippet": "Own<PromiseNode> maybeChain(Own<PromiseNode>&& node, Promise<T>*) {\n  return heap<ChainPromiseNode>(kj::mv(node));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Own<PromiseNode> maybeChain(Own<PromiseNode>&& node, Promise<T>*) {\n  return heap<ChainPromiseNode>(kj::mv(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "implicitCast<T*>",
          "args": [
            "nullptr"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "implicitCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1203-1207",
          "snippet": "To implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nTo implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "intermediate"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>",
          "args": [
            "*wrapper"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::WeakFulfiller<T>::make",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "make",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "842-845",
          "snippet": "static kj::Own<WeakFulfiller> make() {\n    WeakFulfiller* ptr = new WeakFulfiller;\n    return Own<WeakFulfiller>(ptr, *ptr);\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  static kj::Own<WeakFulfiller> make() {\n      WeakFulfiller* ptr = new WeakFulfiller;\n      return Own<WeakFulfiller>(ptr, *ptr);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
  },
  {
    "function_name": "newAdaptedPromise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "940-943",
    "snippet": "Promise<T> newAdaptedPromise(Params&&... adapterConstructorParams) {\n  return Promise<T>(false, heap<_::AdapterPromiseNode<_::FixVoid<T>, Adapter>>(\n      kj::fwd<Params>(adapterConstructorParams)...));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise<T>",
          "args": [
            "false",
            "heap<_::AdapterPromiseNode<_::FixVoid<T>, Adapter>>(\n      kj::fwd<Params>(adapterConstructorParams)...)"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "PromiseAndFulfillerAdapter",
          "container": "PromiseAndFulfillerAdapter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "901-905",
          "snippet": "PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                             WeakFulfiller<T>& wrapper)\n      : fulfiller(fulfiller), wrapper(wrapper) {\n    wrapper.attach(fulfiller);\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseAndFulfillerAdapter {\n  PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                               WeakFulfiller<T>& wrapper)\n        : fulfiller(fulfiller), wrapper(wrapper) {\n      wrapper.attach(fulfiller);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap<_::AdapterPromiseNode<_::FixVoid<T>, Adapter>>",
          "args": [
            "kj::fwd<Params>(adapterConstructorParams)..."
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "adapterConstructorParams"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<T> newAdaptedPromise(Params&&... adapterConstructorParams) {\n  return Promise<T>(false, heap<_::AdapterPromiseNode<_::FixVoid<T>, Adapter>>(\n      kj::fwd<Params>(adapterConstructorParams)...));\n}"
  },
  {
    "function_name": "PromiseFulfiller<void>::rejectIfThrows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "930-937",
    "snippet": "bool PromiseFulfiller<void>::rejectIfThrows(Func&& func) {\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions(kj::mv(func))) {\n    reject(kj::mv(*exception));\n    return false;\n  } else {\n    return true;\n  }\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reject",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "reject",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "853-857",
          "snippet": "void reject(Exception&& exception) override {\n    if (inner != nullptr) {\n      inner->reject(kj::mv(exception));\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void reject(Exception&& exception) override {\n      if (inner != nullptr) {\n        inner->reject(kj::mv(exception));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "bool PromiseFulfiller<void>::rejectIfThrows(Func&& func) {\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions(kj::mv(func))) {\n    reject(kj::mv(*exception));\n    return false;\n  } else {\n    return true;\n  }\n}"
  },
  {
    "function_name": "PromiseFulfiller<T>::rejectIfThrows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "920-927",
    "snippet": "bool PromiseFulfiller<T>::rejectIfThrows(Func&& func) {\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions(kj::mv(func))) {\n    reject(kj::mv(*exception));\n    return false;\n  } else {\n    return true;\n  }\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reject",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "reject",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "853-857",
          "snippet": "void reject(Exception&& exception) override {\n    if (inner != nullptr) {\n      inner->reject(kj::mv(exception));\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void reject(Exception&& exception) override {\n      if (inner != nullptr) {\n        inner->reject(kj::mv(exception));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "bool PromiseFulfiller<T>::rejectIfThrows(Func&& func) {\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions(kj::mv(func))) {\n    reject(kj::mv(*exception));\n    return false;\n  } else {\n    return true;\n  }\n}"
  },
  {
    "function_name": "PromiseAndFulfillerAdapter",
    "container": "PromiseAndFulfillerAdapter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "901-905",
    "snippet": "PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                             WeakFulfiller<T>& wrapper)\n      : fulfiller(fulfiller), wrapper(wrapper) {\n    wrapper.attach(fulfiller);\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wrapper.attach",
          "args": [
            "fulfiller"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "attach",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "863-865",
          "snippet": "void attach(PromiseFulfiller<T>& newInner) {\n    inner = &newInner;\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void attach(PromiseFulfiller<T>& newInner) {\n      inner = &newInner;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "PromiseAndFulfillerAdapter {\n  PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                               WeakFulfiller<T>& wrapper)\n        : fulfiller(fulfiller), wrapper(wrapper) {\n      wrapper.attach(fulfiller);\n    }\n}"
  },
  {
    "function_name": "disposeImpl",
    "container": "WeakFulfiller",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "882-895",
    "snippet": "void disposeImpl(void* pointer) const override {\n    // TODO(perf): Factor some of this out so it isn't regenerated for every fulfiller type?\n\n    if (inner == nullptr) {\n      // Already detached.\n      delete this;\n    } else {\n      if (inner->isWaiting()) {\n        inner->reject(kj::Exception(kj::Exception::Type::FAILED, __FILE__, __LINE__,\n            kj::heapString(\"PromiseFulfiller was destroyed without fulfilling the promise.\")));\n      }\n      inner = nullptr;\n    }\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner->reject",
          "args": [
            "kj::Exception(kj::Exception::Type::FAILED, __FILE__, __LINE__,\n            kj::heapString(\"PromiseFulfiller was destroyed without fulfilling the promise.\"))"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "reject",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "853-857",
          "snippet": "void reject(Exception&& exception) override {\n    if (inner != nullptr) {\n      inner->reject(kj::mv(exception));\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void reject(Exception&& exception) override {\n      if (inner != nullptr) {\n        inner->reject(kj::mv(exception));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::Exception",
          "args": [
            "kj::Exception::Type::FAILED",
            "__FILE__",
            "__LINE__",
            "kj::heapString(\"PromiseFulfiller was destroyed without fulfilling the promise.\")"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"PromiseFulfiller was destroyed without fulfilling the promise.\""
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inner->isWaiting",
          "args": [],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "isWaiting",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "859-861",
          "snippet": "bool isWaiting() override {\n    return inner != nullptr && inner->isWaiting();\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  bool isWaiting() override {\n      return inner != nullptr && inner->isWaiting();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "WeakFulfiller {\n  void disposeImpl(void* pointer) const override {\n      // TODO(perf): Factor some of this out so it isn't regenerated for every fulfiller type?\n  \n      if (inner == nullptr) {\n        // Already detached.\n        delete this;\n      } else {\n        if (inner->isWaiting()) {\n          inner->reject(kj::Exception(kj::Exception::Type::FAILED, __FILE__, __LINE__,\n              kj::heapString(\"PromiseFulfiller was destroyed without fulfilling the promise.\")));\n        }\n        inner = nullptr;\n      }\n    }\n}"
  },
  {
    "function_name": "WeakFulfiller",
    "container": "WeakFulfiller",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "880-880",
    "snippet": "WeakFulfiller(): inner(nullptr) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "WeakFulfiller {\n  WeakFulfiller(): inner(nullptr) {}\n}"
  },
  {
    "function_name": "detach",
    "container": "WeakFulfiller",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "867-875",
    "snippet": "void detach(PromiseFulfiller<T>& from) {\n    if (inner == nullptr) {\n      // Already disposed.\n      delete this;\n    } else {\n      KJ_IREQUIRE(inner == &from);\n      inner = nullptr;\n    }\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "inner == &from"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "WeakFulfiller {\n  void detach(PromiseFulfiller<T>& from) {\n      if (inner == nullptr) {\n        // Already disposed.\n        delete this;\n      } else {\n        KJ_IREQUIRE(inner == &from);\n        inner = nullptr;\n      }\n    }\n}"
  },
  {
    "function_name": "attach",
    "container": "WeakFulfiller",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "863-865",
    "snippet": "void attach(PromiseFulfiller<T>& newInner) {\n    inner = &newInner;\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "WeakFulfiller {\n  void attach(PromiseFulfiller<T>& newInner) {\n      inner = &newInner;\n    }\n}"
  },
  {
    "function_name": "isWaiting",
    "container": "WeakFulfiller",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "859-861",
    "snippet": "bool isWaiting() override {\n    return inner != nullptr && inner->isWaiting();\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "WeakFulfiller {\n  bool isWaiting() override {\n      return inner != nullptr && inner->isWaiting();\n    }\n}"
  },
  {
    "function_name": "reject",
    "container": "WeakFulfiller",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "853-857",
    "snippet": "void reject(Exception&& exception) override {\n    if (inner != nullptr) {\n      inner->reject(kj::mv(exception));\n    }\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "WeakFulfiller {\n  void reject(Exception&& exception) override {\n      if (inner != nullptr) {\n        inner->reject(kj::mv(exception));\n      }\n    }\n}"
  },
  {
    "function_name": "fulfill",
    "container": "WeakFulfiller",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "847-851",
    "snippet": "void fulfill(FixVoid<T>&& value) override {\n    if (inner != nullptr) {\n      inner->fulfill(kj::mv(value));\n    }\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "WeakFulfiller {\n  void fulfill(FixVoid<T>&& value) override {\n      if (inner != nullptr) {\n        inner->fulfill(kj::mv(value));\n      }\n    }\n}"
  },
  {
    "function_name": "make",
    "container": "WeakFulfiller",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "842-845",
    "snippet": "static kj::Own<WeakFulfiller> make() {\n    WeakFulfiller* ptr = new WeakFulfiller;\n    return Own<WeakFulfiller>(ptr, *ptr);\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Own<WeakFulfiller>",
          "args": [
            "ptr",
            "*ptr"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "OwnedFileDescriptor",
          "container": "OwnedFileDescriptor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "78-93",
          "snippet": "OwnedFileDescriptor(int fd, uint flags): fd(fd), flags(flags) {\n    if (flags & LowLevelAsyncIoProvider::ALREADY_NONBLOCK) {\n      KJ_DREQUIRE(fcntl(fd, F_GETFL) & O_NONBLOCK, \"You claimed you set NONBLOCK, but you didn't.\");\n    } else {\n      setNonblocking(fd);\n    }\n\n    if (flags & LowLevelAsyncIoProvider::TAKE_OWNERSHIP) {\n      if (flags & LowLevelAsyncIoProvider::ALREADY_CLOEXEC) {\n        KJ_DREQUIRE(fcntl(fd, F_GETFD) & FD_CLOEXEC,\n                    \"You claimed you set CLOEXEC, but you didn't.\");\n      } else {\n        setCloseOnExec(fd);\n      }\n    }\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nOwnedFileDescriptor {\n  OwnedFileDescriptor(int fd, uint flags): fd(fd), flags(flags) {\n      if (flags & LowLevelAsyncIoProvider::ALREADY_NONBLOCK) {\n        KJ_DREQUIRE(fcntl(fd, F_GETFL) & O_NONBLOCK, \"You claimed you set NONBLOCK, but you didn't.\");\n      } else {\n        setNonblocking(fd);\n      }\n  \n      if (flags & LowLevelAsyncIoProvider::TAKE_OWNERSHIP) {\n        if (flags & LowLevelAsyncIoProvider::ALREADY_CLOEXEC) {\n          KJ_DREQUIRE(fcntl(fd, F_GETFD) & FD_CLOEXEC,\n                      \"You claimed you set CLOEXEC, but you didn't.\");\n        } else {\n          setCloseOnExec(fd);\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "WeakFulfiller {\n  static kj::Own<WeakFulfiller> make() {\n      WeakFulfiller* ptr = new WeakFulfiller;\n      return Own<WeakFulfiller>(ptr, *ptr);\n    }\n}"
  },
  {
    "function_name": "joinPromises",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "814-818",
    "snippet": "Promise<Array<T>> joinPromises(Array<Promise<T>>&& promises) {\n  return Promise<Array<T>>(false, kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size())));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise<Array<T>>",
          "args": [
            "false",
            "kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size()))"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<_::ArrayJoinPromiseNode<T>>",
          "args": [
            "KJ_MAP(p, promises){ return kj::mv(p.node); }",
            "heapArray<_::ExceptionOr<T>>(promises.size())"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapArray<_::ExceptionOr<T>>",
          "args": [
            "promises.size()"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promises.size",
          "args": [],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "p.node"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "p",
            "promises"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<Array<T>> joinPromises(Array<Promise<T>>&& promises) {\n  return Promise<Array<T>>(false, kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size())));\n}"
  },
  {
    "function_name": "Promise<void>::detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "809-811",
    "snippet": "void Promise<void>::detach(ErrorFunc&& errorHandler) {\n  return _::detach(then([]() {}, kj::fwd<ErrorFunc>(errorHandler)));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::detach",
          "args": [
            "then([]() {}, kj::fwd<ErrorFunc>(errorHandler))"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "detach",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "867-875",
          "snippet": "void detach(PromiseFulfiller<T>& from) {\n    if (inner == nullptr) {\n      // Already disposed.\n      delete this;\n    } else {\n      KJ_IREQUIRE(inner == &from);\n      inner = nullptr;\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void detach(PromiseFulfiller<T>& from) {\n      if (inner == nullptr) {\n        // Already disposed.\n        delete this;\n      } else {\n        KJ_IREQUIRE(inner == &from);\n        inner = nullptr;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "then",
          "args": [
            "[]() {}",
            "kj::fwd<ErrorFunc>(errorHandler)"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<T>::then",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "676-684",
          "snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<ErrorFunc>",
          "args": [
            "errorHandler"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "void Promise<void>::detach(ErrorFunc&& errorHandler) {\n  return _::detach(then([]() {}, kj::fwd<ErrorFunc>(errorHandler)));\n}"
  },
  {
    "function_name": "Promise<T>::detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "803-805",
    "snippet": "void Promise<T>::detach(ErrorFunc&& errorHandler) {\n  return _::detach(then([](T&&) {}, kj::fwd<ErrorFunc>(errorHandler)));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::detach",
          "args": [
            "then([](T&&) {}, kj::fwd<ErrorFunc>(errorHandler))"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "detach",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "867-875",
          "snippet": "void detach(PromiseFulfiller<T>& from) {\n    if (inner == nullptr) {\n      // Already disposed.\n      delete this;\n    } else {\n      KJ_IREQUIRE(inner == &from);\n      inner = nullptr;\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void detach(PromiseFulfiller<T>& from) {\n      if (inner == nullptr) {\n        // Already disposed.\n        delete this;\n      } else {\n        KJ_IREQUIRE(inner == &from);\n        inner = nullptr;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "then",
          "args": [
            "[](T&&) {}",
            "kj::fwd<ErrorFunc>(errorHandler)"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<T>::then",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "676-684",
          "snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<ErrorFunc>",
          "args": [
            "errorHandler"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "void Promise<T>::detach(ErrorFunc&& errorHandler) {\n  return _::detach(then([](T&&) {}, kj::fwd<ErrorFunc>(errorHandler)));\n}"
  },
  {
    "function_name": "evalNow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "791-799",
    "snippet": "inline PromiseForResult<Func, void> evalNow(Func&& func) {\n  PromiseForResult<Func, void> result = nullptr;\n  KJ_IF_MAYBE(e, kj::runCatchingExceptions([&]() {\n    result = func();\n  })) {\n    result = kj::mv(*e);\n  }\n  return result;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "e",
            "kj::runCatchingExceptions([&]() {\n    result = func();\n  })"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    result = func();\n  }"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "inline PromiseForResult<Func, void> evalNow(Func&& func) {\n  PromiseForResult<Func, void> result = nullptr;\n  KJ_IF_MAYBE(e, kj::runCatchingExceptions([&]() {\n    result = func();\n  })) {\n    result = kj::mv(*e);\n  }\n  return result;\n}"
  },
  {
    "function_name": "evalLater",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "786-788",
    "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::yield",
          "args": [
            "kj::fwd<Func>(func)",
            "_::PropagateException()"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::PropagateException",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Func>",
          "args": [
            "func"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::yield",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "yield",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "342-344",
          "snippet": "Promise<void> yield() {\n  return Promise<void>(false, kj::heap<YieldPromiseNode>());\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nPromise<void> yield() {\n  return Promise<void>(false, kj::heap<YieldPromiseNode>());\n}"
        }
      }
    ],
    "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
  },
  {
    "function_name": "Promise<T>::trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "781-783",
    "snippet": "kj::String Promise<T>::trace() {\n  return PromiseBase::trace();\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PromiseBase::trace",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "PromiseBase::trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "489-491",
          "snippet": "kj::String PromiseBase::trace() {\n  return traceImpl(nullptr, node);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nkj::String PromiseBase::trace() {\n  return traceImpl(nullptr, node);\n}"
        }
      }
    ],
    "contextual_snippet": "kj::String Promise<T>::trace() {\n  return PromiseBase::trace();\n}"
  },
  {
    "function_name": "Promise<T>::eagerlyEvaluate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "776-778",
    "snippet": "Promise<T> Promise<T>::eagerlyEvaluate(decltype(nullptr)) {\n  return Promise(false, _::spark<_::FixVoid<T>>(kj::mv(node)));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise",
          "args": [
            "false",
            "_::spark<_::FixVoid<T>>(kj::mv(node))"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "PromiseAndFulfillerAdapter",
          "container": "PromiseAndFulfillerAdapter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "901-905",
          "snippet": "PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                             WeakFulfiller<T>& wrapper)\n      : fulfiller(fulfiller), wrapper(wrapper) {\n    wrapper.attach(fulfiller);\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseAndFulfillerAdapter {\n  PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                               WeakFulfiller<T>& wrapper)\n        : fulfiller(fulfiller), wrapper(wrapper) {\n      wrapper.attach(fulfiller);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::spark<_::FixVoid<T>>",
          "args": [
            "kj::mv(node)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<T> Promise<T>::eagerlyEvaluate(decltype(nullptr)) {\n  return Promise(false, _::spark<_::FixVoid<T>>(kj::mv(node)));\n}"
  },
  {
    "function_name": "Promise<T>::eagerlyEvaluate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "768-773",
    "snippet": "Promise<T> Promise<T>::eagerlyEvaluate(ErrorFunc&& errorHandler) {\n  // See catch_() for commentary.\n  return Promise(false, _::spark<_::FixVoid<T>>(then(\n      _::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>(),\n      kj::fwd<ErrorFunc>(errorHandler)).node));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise",
          "args": [
            "false",
            "_::spark<_::FixVoid<T>>(then(\n      _::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>(),\n      kj::fwd<ErrorFunc>(errorHandler)).node)"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "PromiseAndFulfillerAdapter",
          "container": "PromiseAndFulfillerAdapter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "901-905",
          "snippet": "PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                             WeakFulfiller<T>& wrapper)\n      : fulfiller(fulfiller), wrapper(wrapper) {\n    wrapper.attach(fulfiller);\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseAndFulfillerAdapter {\n  PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                               WeakFulfiller<T>& wrapper)\n        : fulfiller(fulfiller), wrapper(wrapper) {\n      wrapper.attach(fulfiller);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::spark<_::FixVoid<T>>",
          "args": [
            "then(\n      _::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>(),\n      kj::fwd<ErrorFunc>(errorHandler)).node"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "then",
          "args": [
            "_::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>()",
            "kj::fwd<ErrorFunc>(errorHandler)"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<T>::then",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "676-684",
          "snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<ErrorFunc>",
          "args": [
            "errorHandler"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorHandler",
          "args": [
            "instance<Exception&&>()"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance<Exception&&>",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<T> Promise<T>::eagerlyEvaluate(ErrorFunc&& errorHandler) {\n  // See catch_() for commentary.\n  return Promise(false, _::spark<_::FixVoid<T>>(then(\n      _::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>(),\n      kj::fwd<ErrorFunc>(errorHandler)).node));\n}"
  },
  {
    "function_name": "Promise<T>::attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "761-764",
    "snippet": "Promise<T> Promise<T>::attach(Attachments&&... attachments) {\n  return Promise(false, kj::heap<_::AttachmentPromiseNode<Tuple<Attachments...>>>(\n      kj::mv(node), kj::tuple(kj::fwd<Attachments>(attachments)...)));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise",
          "args": [
            "false",
            "kj::heap<_::AttachmentPromiseNode<Tuple<Attachments...>>>(\n      kj::mv(node), kj::tuple(kj::fwd<Attachments>(attachments)...))"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "PromiseAndFulfillerAdapter",
          "container": "PromiseAndFulfillerAdapter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "901-905",
          "snippet": "PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                             WeakFulfiller<T>& wrapper)\n      : fulfiller(fulfiller), wrapper(wrapper) {\n    wrapper.attach(fulfiller);\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseAndFulfillerAdapter {\n  PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                               WeakFulfiller<T>& wrapper)\n        : fulfiller(fulfiller), wrapper(wrapper) {\n      wrapper.attach(fulfiller);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<_::AttachmentPromiseNode<Tuple<Attachments...>>>",
          "args": [
            "kj::mv(node)",
            "kj::tuple(kj::fwd<Attachments>(attachments)...)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::tuple",
          "args": [
            "kj::fwd<Attachments>(attachments)..."
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Attachments>",
          "args": [
            "attachments"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<T> Promise<T>::attach(Attachments&&... attachments) {\n  return Promise(false, kj::heap<_::AttachmentPromiseNode<Tuple<Attachments...>>>(\n      kj::mv(node), kj::tuple(kj::fwd<Attachments>(attachments)...)));\n}"
  },
  {
    "function_name": "Promise<T>::exclusiveJoin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "755-757",
    "snippet": "Promise<T> Promise<T>::exclusiveJoin(Promise<T>&& other) {\n  return Promise(false, heap<_::ExclusiveJoinPromiseNode>(kj::mv(node), kj::mv(other.node)));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise",
          "args": [
            "false",
            "heap<_::ExclusiveJoinPromiseNode>(kj::mv(node), kj::mv(other.node))"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "PromiseAndFulfillerAdapter",
          "container": "PromiseAndFulfillerAdapter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "901-905",
          "snippet": "PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                             WeakFulfiller<T>& wrapper)\n      : fulfiller(fulfiller), wrapper(wrapper) {\n    wrapper.attach(fulfiller);\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseAndFulfillerAdapter {\n  PromiseAndFulfillerAdapter(PromiseFulfiller<T>& fulfiller,\n                               WeakFulfiller<T>& wrapper)\n        : fulfiller(fulfiller), wrapper(wrapper) {\n      wrapper.attach(fulfiller);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap<_::ExclusiveJoinPromiseNode>",
          "args": [
            "kj::mv(node)",
            "kj::mv(other.node)"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "other.node"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<T> Promise<T>::exclusiveJoin(Promise<T>&& other) {\n  return Promise(false, heap<_::ExclusiveJoinPromiseNode>(kj::mv(node), kj::mv(other.node)));\n}"
  },
  {
    "function_name": "ForkedPromise<T>::addBranch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "750-752",
    "snippet": "Promise<T> ForkedPromise<T>::addBranch() {\n  return hub->addBranch();\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hub->addBranch",
          "args": [],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "Promise<T> ForkedPromise<T>::addBranch() {\n  return hub->addBranch();\n}"
  },
  {
    "function_name": "Promise<T>::fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "745-747",
    "snippet": "ForkedPromise<T> Promise<T>::fork() {\n  return ForkedPromise<T>(false, refcounted<_::ForkHub<_::FixVoid<T>>>(kj::mv(node)));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ForkedPromise<T>",
          "args": [
            "false",
            "refcounted<_::ForkHub<_::FixVoid<T>>>(kj::mv(node))"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "ForkedPromise",
          "container": "ForkedPromise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "319-319",
          "snippet": "inline ForkedPromise(bool, Own<_::ForkHub<_::FixVoid<T>>>&& hub): hub(kj::mv(hub)) {}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nForkedPromise {\n  inline ForkedPromise(bool, Own<_::ForkHub<_::FixVoid<T>>>&& hub): hub(kj::mv(hub)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcounted<_::ForkHub<_::FixVoid<T>>>",
          "args": [
            "kj::mv(node)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ForkedPromise<T> Promise<T>::fork() {\n  return ForkedPromise<T>(false, refcounted<_::ForkHub<_::FixVoid<T>>>(kj::mv(node)));\n}"
  },
  {
    "function_name": "Promise<T>::wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "726-741",
    "snippet": "T Promise<T>::wait(WaitScope& waitScope) {\n  _::ExceptionOr<_::FixVoid<T>> result;\n\n  waitImpl(kj::mv(node), result, waitScope);\n\n  KJ_IF_MAYBE(value, result.value) {\n    KJ_IF_MAYBE(exception, result.exception) {\n      throwRecoverableException(kj::mv(*exception));\n    }\n    return _::returnMaybeVoid(kj::mv(*value));\n  } else KJ_IF_MAYBE(exception, result.exception) {\n    throwFatalException(kj::mv(*exception));\n  } else {\n    // Result contained neither a value nor an exception?\n    KJ_UNREACHABLE;\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "throwFatalException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "throwFatalException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "348-351",
          "snippet": "void throwFatalException(kj::Exception&& exception) {\n  getExceptionCallback().onFatalException(kj::mv(exception));\n  abort();\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwFatalException(kj::Exception&& exception) {\n  getExceptionCallback().onFatalException(kj::mv(exception));\n  abort();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::returnMaybeVoid",
          "args": [
            "kj::mv(*value)"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "returnMaybeVoid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-prelude.h",
          "lines": "155-155",
          "snippet": "inline void returnMaybeVoid(Void&& v) {}",
          "includes": [
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n\ninline void returnMaybeVoid(Void&& v) {}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*value"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "throwRecoverableException",
          "args": [
            "kj::mv(*exception)"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "throwRecoverableException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "353-355",
          "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "result.exception"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "waitImpl",
          "args": [
            "kj::mv(node)",
            "result",
            "waitScope"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "waitImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "313-340",
          "snippet": "void waitImpl(Own<_::PromiseNode>&& node, _::ExceptionOrValue& result, WaitScope& waitScope) {\n  EventLoop& loop = waitScope.loop;\n  KJ_REQUIRE(&loop == threadLocalEventLoop, \"WaitScope not valid for this thread.\");\n  KJ_REQUIRE(!loop.running, \"wait() is not allowed from within event callbacks.\");\n\n  BoolEvent doneEvent;\n  node->setSelfPointer(&node);\n  node->onReady(doneEvent);\n\n  loop.running = true;\n  KJ_DEFER(loop.running = false);\n\n  while (!doneEvent.fired) {\n    if (!loop.turn()) {\n      // No events in the queue.  Wait for callback.\n      loop.port.wait();\n    }\n  }\n\n  loop.setRunnable(loop.head != nullptr);\n\n  node->get(result);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    node = nullptr;\n  })) {\n    result.addException(kj::mv(*exception));\n  }\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid waitImpl(Own<_::PromiseNode>&& node, _::ExceptionOrValue& result, WaitScope& waitScope) {\n  EventLoop& loop = waitScope.loop;\n  KJ_REQUIRE(&loop == threadLocalEventLoop, \"WaitScope not valid for this thread.\");\n  KJ_REQUIRE(!loop.running, \"wait() is not allowed from within event callbacks.\");\n\n  BoolEvent doneEvent;\n  node->setSelfPointer(&node);\n  node->onReady(doneEvent);\n\n  loop.running = true;\n  KJ_DEFER(loop.running = false);\n\n  while (!doneEvent.fired) {\n    if (!loop.turn()) {\n      // No events in the queue.  Wait for callback.\n      loop.port.wait();\n    }\n  }\n\n  loop.setRunnable(loop.head != nullptr);\n\n  node->get(result);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    node = nullptr;\n  })) {\n    result.addException(kj::mv(*exception));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "T Promise<T>::wait(WaitScope& waitScope) {\n  _::ExceptionOr<_::FixVoid<T>> result;\n\n  waitImpl(kj::mv(node), result, waitScope);\n\n  KJ_IF_MAYBE(value, result.value) {\n    KJ_IF_MAYBE(exception, result.exception) {\n      throwRecoverableException(kj::mv(*exception));\n    }\n    return _::returnMaybeVoid(kj::mv(*value));\n  } else KJ_IF_MAYBE(exception, result.exception) {\n    throwFatalException(kj::mv(*exception));\n  } else {\n    // Result contained neither a value nor an exception?\n    KJ_UNREACHABLE;\n  }"
  },
  {
    "function_name": "Promise<T>::catch_",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "716-723",
    "snippet": "Promise<T> Promise<T>::catch_(ErrorFunc&& errorHandler) {\n  // then()'s ErrorFunc can only return a Promise if Func also returns a Promise. In this case,\n  // Func is being filled in automatically. We want to make sure ErrorFunc can return a Promise,\n  // but we don't want the extra overhead of promise chaining if ErrorFunc doesn't actually\n  // return a promise. So we make our Func return match ErrorFunc.\n  return then(_::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>(),\n              kj::fwd<ErrorFunc>(errorHandler));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "then",
          "args": [
            "_::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>()",
            "kj::fwd<ErrorFunc>(errorHandler)"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "Promise<T>::then",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "676-684",
          "snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<ErrorFunc>",
          "args": [
            "errorHandler"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorHandler",
          "args": [
            "instance<Exception&&>()"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance<Exception&&>",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<T> Promise<T>::catch_(ErrorFunc&& errorHandler) {\n  // then()'s ErrorFunc can only return a Promise if Func also returns a Promise. In this case,\n  // Func is being filled in automatically. We want to make sure ErrorFunc can return a Promise,\n  // but we don't want the extra overhead of promise chaining if ErrorFunc doesn't actually\n  // return a promise. So we make our Func return match ErrorFunc.\n  return then(_::IdentityFunc<decltype(errorHandler(instance<Exception&&>()))>(),\n              kj::fwd<ErrorFunc>(errorHandler));\n}"
  },
  {
    "function_name": "Promise<T>::then",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "676-684",
    "snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PromiseForResult<Func, T>",
          "args": [
            "false",
            "_::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr))"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::maybeChain",
          "args": [
            "kj::mv(intermediate)",
            "implicitCast<ResultT*>(nullptr)"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "maybeChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "444-446",
          "snippet": "Own<PromiseNode> maybeChain(Own<PromiseNode>&& node, Promise<T>*) {\n  return heap<ChainPromiseNode>(kj::mv(node));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Own<PromiseNode> maybeChain(Own<PromiseNode>&& node, Promise<T>*) {\n  return heap<ChainPromiseNode>(kj::mv(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "implicitCast<ResultT*>",
          "args": [
            "nullptr"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "implicitCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1203-1207",
          "snippet": "To implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nTo implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "intermediate"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>",
          "args": [
            "kj::mv(node)",
            "kj::fwd<Func>(func)",
            "kj::fwd<ErrorFunc>(errorHandler)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<ErrorFunc>",
          "args": [
            "errorHandler"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Func>",
          "args": [
            "func"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "PromiseForResult<Func, T> Promise<T>::then(Func&& func, ErrorFunc&& errorHandler) {\n  typedef _::FixVoid<_::ReturnType<Func, T>> ResultT;\n\n  Own<_::PromiseNode> intermediate =\n      heap<_::TransformPromiseNode<ResultT, _::FixVoid<T>, Func, ErrorFunc>>(\n          kj::mv(node), kj::fwd<Func>(func), kj::fwd<ErrorFunc>(errorHandler));\n  return PromiseForResult<Func, T>(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<ResultT*>(nullptr)));\n}"
  },
  {
    "function_name": "Promise<T>::Promise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "671-672",
    "snippet": "Promise<T>::Promise(kj::Exception&& exception)\n    : PromiseBase(heap<_::ImmediateBrokenPromiseNode>(kj::mv(exception))) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<_::ImmediateBrokenPromiseNode>",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<T>::Promise(kj::Exception&& exception)\n    : PromiseBase(heap<_::ImmediateBrokenPromiseNode>(kj::mv(exception))) {}"
  },
  {
    "function_name": "Promise<T>::Promise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "667-668",
    "snippet": "Promise<T>::Promise(_::FixVoid<T> value)\n    : PromiseBase(heap<_::ImmediatePromiseNode<_::FixVoid<T>>>(kj::mv(value))) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<_::ImmediatePromiseNode<_::FixVoid<T>>>",
          "args": [
            "kj::mv(value)"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Promise<T>::Promise(_::FixVoid<T> value)\n    : PromiseBase(heap<_::ImmediatePromiseNode<_::FixVoid<T>>>(kj::mv(value))) {}"
  },
  {
    "function_name": "isWaiting",
    "container": "AdapterPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "657-659",
    "snippet": "bool isWaiting() override {\n    return waiting;\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "AdapterPromiseNode {\n  bool isWaiting() override {\n      return waiting;\n    }\n}"
  },
  {
    "function_name": "reject",
    "container": "AdapterPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "649-655",
    "snippet": "void reject(Exception&& exception) override {\n    if (waiting) {\n      waiting = false;\n      result = ExceptionOr<T>(false, kj::mv(exception));\n      setReady();\n    }\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setReady",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "setReady",
          "container": "AdapterPromiseNodeBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "613-615",
          "snippet": "inline void setReady() {\n    onReadyEvent.arm();\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "AdapterPromiseNodeBase {\n  inline void setReady() {\n      onReadyEvent.arm();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExceptionOr<T>",
          "args": [
            "false",
            "kj::mv(exception)"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ExceptionOr",
          "container": "ExceptionOr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "74-74",
          "snippet": "ExceptionOr(bool, Exception&& exception): ExceptionOrValue(false, kj::mv(exception)) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOr {\n  ExceptionOr(bool, Exception&& exception): ExceptionOrValue(false, kj::mv(exception)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "AdapterPromiseNode {\n  void reject(Exception&& exception) override {\n      if (waiting) {\n        waiting = false;\n        result = ExceptionOr<T>(false, kj::mv(exception));\n        setReady();\n      }\n    }\n}"
  },
  {
    "function_name": "fulfill",
    "container": "AdapterPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "641-647",
    "snippet": "void fulfill(T&& value) override {\n    if (waiting) {\n      waiting = false;\n      result = ExceptionOr<T>(kj::mv(value));\n      setReady();\n    }\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setReady",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "setReady",
          "container": "AdapterPromiseNodeBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "613-615",
          "snippet": "inline void setReady() {\n    onReadyEvent.arm();\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "AdapterPromiseNodeBase {\n  inline void setReady() {\n      onReadyEvent.arm();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExceptionOr<T>",
          "args": [
            "kj::mv(value)"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "ExceptionOr",
          "container": "ExceptionOr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "73-73",
          "snippet": "ExceptionOr(T&& value): value(kj::mv(value)) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOr {\n  ExceptionOr(T&& value): value(kj::mv(value)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "AdapterPromiseNode {\n  void fulfill(T&& value) override {\n      if (waiting) {\n        waiting = false;\n        result = ExceptionOr<T>(kj::mv(value));\n        setReady();\n      }\n    }\n}"
  },
  {
    "function_name": "get",
    "container": "AdapterPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "631-634",
    "snippet": "void get(ExceptionOrValue& output) noexcept override {\n    KJ_IREQUIRE(!isWaiting());\n    output.as<T>() = kj::mv(result);\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.as<T>",
          "args": [],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "!isWaiting()"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isWaiting",
          "args": [],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "isWaiting",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "859-861",
          "snippet": "bool isWaiting() override {\n    return inner != nullptr && inner->isWaiting();\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  bool isWaiting() override {\n      return inner != nullptr && inner->isWaiting();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "AdapterPromiseNode {\n  void get(ExceptionOrValue& output) noexcept override {\n      KJ_IREQUIRE(!isWaiting());\n      output.as<T>() = kj::mv(result);\n    }\n}"
  },
  {
    "function_name": "AdapterPromiseNode",
    "container": "AdapterPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "628-629",
    "snippet": "AdapterPromiseNode(Params&&... params)\n      : adapter(static_cast<PromiseFulfiller<UnfixVoid<T>>&>(*this), kj::fwd<Params>(params)...) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<PromiseFulfiller<UnfixVoid<T>>&>",
          "args": [
            "*this"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "AdapterPromiseNode {\n  AdapterPromiseNode(Params&&... params)\n        : adapter(static_cast<PromiseFulfiller<UnfixVoid<T>>&>(*this), kj::fwd<Params>(params)...) {}\n}"
  },
  {
    "function_name": "setReady",
    "container": "AdapterPromiseNodeBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "613-615",
    "snippet": "inline void setReady() {\n    onReadyEvent.arm();\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onReadyEvent.arm",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "AdapterPromiseNodeBase {\n  inline void setReady() {\n      onReadyEvent.arm();\n    }\n}"
  },
  {
    "function_name": "spark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "600-604",
    "snippet": "Own<PromiseNode> spark(Own<PromiseNode>&& node) {\n  // Forces evaluation of the given node to begin as soon as possible, even if no one is waiting\n  // on it.\n  return heap<EagerPromiseNode<T>>(kj::mv(node));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<EagerPromiseNode<T>>",
          "args": [
            "kj::mv(node)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Own<PromiseNode> spark(Own<PromiseNode>&& node) {\n  // Forces evaluation of the given node to begin as soon as possible, even if no one is waiting\n  // on it.\n  return heap<EagerPromiseNode<T>>(kj::mv(node));\n}"
  },
  {
    "function_name": "get",
    "container": "EagerPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "591-593",
    "snippet": "void get(ExceptionOrValue& output) noexcept override {\n    output.as<T>() = kj::mv(result);\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.as<T>",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      }
    ],
    "contextual_snippet": "EagerPromiseNode {\n  void get(ExceptionOrValue& output) noexcept override {\n      output.as<T>() = kj::mv(result);\n    }\n}"
  },
  {
    "function_name": "EagerPromiseNode",
    "container": "EagerPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "588-589",
    "snippet": "EagerPromiseNode(Own<PromiseNode>&& dependency)\n      : EagerPromiseNodeBase(kj::mv(dependency), result) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dependency"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "EagerPromiseNode {\n  EagerPromiseNode(Own<PromiseNode>&& dependency)\n        : EagerPromiseNodeBase(kj::mv(dependency), result) {}\n}"
  },
  {
    "function_name": "getNoError",
    "container": "ArrayJoinPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "536-544",
    "snippet": "void getNoError(ExceptionOrValue& output) noexcept override {\n    auto builder = heapArrayBuilder<T>(resultParts.size());\n    for (auto& part: resultParts) {\n      KJ_IASSERT(part.value != nullptr,\n                 \"Bug in KJ promise framework:  Promise result had neither value no exception.\");\n      builder.add(kj::mv(*_::readMaybe(part.value)));\n    }\n    output.as<Array<T>>() = builder.finish();\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "output.as<Array<T>>",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.add",
          "args": [
            "kj::mv(*_::readMaybe(part.value))"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*_::readMaybe(part.value)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::readMaybe",
          "args": [
            "part.value"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "readMaybe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "228-228",
          "snippet": "OwnOwn<T> readMaybe(Maybe<Own<T>>&& maybe) { return OwnOwn<T>(kj::mv(maybe.ptr)); }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwnOwn<T> readMaybe(Maybe<Own<T>>&& maybe) { return OwnOwn<T>(kj::mv(maybe.ptr)); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IASSERT",
          "args": [
            "part.value != nullptr",
            "\"Bug in KJ promise framework:  Promise result had neither value no exception.\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<T>",
          "args": [
            "resultParts.size()"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resultParts.size",
          "args": [],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      }
    ],
    "contextual_snippet": "ArrayJoinPromiseNode {\n  void getNoError(ExceptionOrValue& output) noexcept override {\n      auto builder = heapArrayBuilder<T>(resultParts.size());\n      for (auto& part: resultParts) {\n        KJ_IASSERT(part.value != nullptr,\n                   \"Bug in KJ promise framework:  Promise result had neither value no exception.\");\n        builder.add(kj::mv(*_::readMaybe(part.value)));\n      }\n      output.as<Array<T>>() = builder.finish();\n    }\n}"
  },
  {
    "function_name": "ArrayJoinPromiseNode",
    "container": "ArrayJoinPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "530-533",
    "snippet": "ArrayJoinPromiseNode(Array<Own<PromiseNode>> promises,\n                       Array<ExceptionOr<T>> resultParts)\n      : ArrayJoinPromiseNodeBase(kj::mv(promises), resultParts.begin(), sizeof(ExceptionOr<T>)),\n        resultParts(kj::mv(resultParts)) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "resultParts"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resultParts.begin",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promises"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ArrayJoinPromiseNode {\n  ArrayJoinPromiseNode(Array<Own<PromiseNode>> promises,\n                         Array<ExceptionOr<T>> resultParts)\n        : ArrayJoinPromiseNodeBase(kj::mv(promises), resultParts.begin(), sizeof(ExceptionOr<T>)),\n          resultParts(kj::mv(resultParts)) {}\n}"
  },
  {
    "function_name": "maybeChain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "444-446",
    "snippet": "Own<PromiseNode> maybeChain(Own<PromiseNode>&& node, Promise<T>*) {\n  return heap<ChainPromiseNode>(kj::mv(node));\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<ChainPromiseNode>",
          "args": [
            "kj::mv(node)"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "node"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "Own<PromiseNode> maybeChain(Own<PromiseNode>&& node, Promise<T>*) {\n  return heap<ChainPromiseNode>(kj::mv(node));\n}"
  },
  {
    "function_name": "addBranch",
    "container": "ForkHub",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "396-398",
    "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Promise<_::UnfixVoid<T>>",
          "args": [
            "false",
            "kj::heap<ForkBranch<T>>(addRef(*this))"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<ForkBranch<T>>",
          "args": [
            "addRef(*this)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addRef",
          "args": [
            "*this"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
  },
  {
    "function_name": "ForkHub",
    "container": "ForkHub",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "394-394",
    "snippet": "ForkHub(Own<PromiseNode>&& inner): ForkHubBase(kj::mv(inner), result) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inner"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ForkHub {\n  ForkHub(Own<PromiseNode>&& inner): ForkHubBase(kj::mv(inner), result) {}\n}"
  },
  {
    "function_name": "get",
    "container": "ForkBranch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "353-359",
    "snippet": "void get(ExceptionOrValue& output) noexcept override {\n    ExceptionOr<T>& hubResult = getHubResultRef().template as<T>();\n    KJ_IF_MAYBE(value, hubResult.value) {\n      output.as<T>().value = copyOrAddRef(*value);\n    } else {\n      output.as<T>().value = nullptr;\n    }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "output.as<T>",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "copyOrAddRef",
          "args": [
            "*value"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "copyOrAddRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "343-343",
          "snippet": "Own<T> copyOrAddRef(Own<T>& t) { return t->addRef(); }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Own<T> copyOrAddRef(Own<T>& t) { return t->addRef(); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "value",
            "hubResult.value"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "getHubResultRef",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getHubResultRef",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ForkBranch {\n  void get(ExceptionOrValue& output) noexcept override {\n      ExceptionOr<T>& hubResult = getHubResultRef().template as<T>();\n      KJ_IF_MAYBE(value, hubResult.value) {\n        output.as<T>().value = copyOrAddRef(*value);\n      } else {\n        output.as<T>().value = nullptr;\n      }\n}"
  },
  {
    "function_name": "ForkBranch",
    "container": "ForkBranch",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "351-351",
    "snippet": "ForkBranch(Own<ForkHubBase>&& hub): ForkBranchBase(kj::mv(hub)) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "hub"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ForkBranch {\n  ForkBranch(Own<ForkHubBase>&& hub): ForkBranchBase(kj::mv(hub)) {}\n}"
  },
  {
    "function_name": "copyOrAddRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "343-343",
    "snippet": "Own<T> copyOrAddRef(Own<T>& t) { return t->addRef(); }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t->addRef",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "RefcountedInt",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "443-443",
          "snippet": "Own<RefcountedInt> addRef() { return kj::addRef(*this); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nRefcountedInt {\n  Own<RefcountedInt> addRef() { return kj::addRef(*this); }\n}"
        }
      }
    ],
    "contextual_snippet": "Own<T> copyOrAddRef(Own<T>& t) { return t->addRef(); }"
  },
  {
    "function_name": "copyOrAddRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "342-342",
    "snippet": "T copyOrAddRef(T& t) { return t; }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "T copyOrAddRef(T& t) { return t; }"
  },
  {
    "function_name": "handle",
    "container": "TransformPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "305-307",
    "snippet": "ExceptionOr<T> handle(PropagateException::Bottom&& value) {\n    return ExceptionOr<T>(false, value.asException());\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExceptionOr<T>",
          "args": [
            "false",
            "value.asException()"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ExceptionOr",
          "container": "ExceptionOr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "74-74",
          "snippet": "ExceptionOr(bool, Exception&& exception): ExceptionOrValue(false, kj::mv(exception)) {}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ExceptionOr {\n  ExceptionOr(bool, Exception&& exception): ExceptionOrValue(false, kj::mv(exception)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.asException",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "asException",
          "container": "PropagateException::Bottom",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-prelude.h",
          "lines": "65-65",
          "snippet": "Exception asException() { return kj::mv(exception); }",
          "includes": [
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n\nPropagateException {\n  Bottom {\n    Exception asException() { return kj::mv(exception); }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "TransformPromiseNode {\n  ExceptionOr<T> handle(PropagateException::Bottom&& value) {\n      return ExceptionOr<T>(false, value.asException());\n    }\n}"
  },
  {
    "function_name": "handle",
    "container": "TransformPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "302-304",
    "snippet": "ExceptionOr<T> handle(T&& value) {\n    return kj::mv(value);\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "TransformPromiseNode {\n  ExceptionOr<T> handle(T&& value) {\n      return kj::mv(value);\n    }\n}"
  },
  {
    "function_name": "getImpl",
    "container": "TransformPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "290-300",
    "snippet": "void getImpl(ExceptionOrValue& output) override {\n    ExceptionOr<DepT> depResult;\n    getDepResult(depResult);\n    KJ_IF_MAYBE(depException, depResult.exception) {\n      output.as<T>() = handle(\n          MaybeVoidCaller<Exception, FixVoid<ReturnType<ErrorFunc, Exception>>>::apply(\n              errorHandler, kj::mv(*depException)));\n    } else KJ_IF_MAYBE(depValue, depResult.value) {\n      output.as<T>() = handle(MaybeVoidCaller<DepT, T>::apply(func, kj::mv(*depValue)));\n    }\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle",
          "args": [
            "MaybeVoidCaller<DepT, T>::apply(func, kj::mv(*depValue))"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "handle",
          "container": "TransformPromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "305-307",
          "snippet": "ExceptionOr<T> handle(PropagateException::Bottom&& value) {\n    return ExceptionOr<T>(false, value.asException());\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "TransformPromiseNode {\n  ExceptionOr<T> handle(PropagateException::Bottom&& value) {\n      return ExceptionOr<T>(false, value.asException());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaybeVoidCaller<DepT, T>::apply",
          "args": [
            "func",
            "kj::mv(*depValue)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "apply",
          "container": "MaybeVoidCaller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-prelude.h",
          "lines": "108-110",
          "snippet": "static inline Out apply(Func& func, In&& in) {\n    return func(kj::mv(in));\n  }",
          "includes": [
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n\nMaybeVoidCaller {\n  static inline Out apply(Func& func, In&& in) {\n      return func(kj::mv(in));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*depValue"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.as<T>",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*depException"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "depException",
            "depResult.exception"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common-test.c++",
          "lines": "188-190",
          "snippet": "KJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <inttypes.h>",
            "#include \"test.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const Maybe<const int&> cmci2 = cmci;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <inttypes.h>\n#include \"test.h\"\n#include \"common.h\"\n\nconst Maybe<const int&> cmci2 = cmci;\n\nKJ_IF_MAYBE(i2, cmci2) {\n    EXPECT_EQ(&i, i2);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "getDepResult",
          "args": [
            "depResult"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "TransformPromiseNodeBase::getDepResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "586-593",
          "snippet": "void TransformPromiseNodeBase::getDepResult(ExceptionOrValue& output) {\n  dependency->get(output);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    dependency = nullptr;\n  })) {\n    output.addException(kj::mv(*exception));\n  }\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nvoid TransformPromiseNodeBase::getDepResult(ExceptionOrValue& output) {\n  dependency->get(output);\n  KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n    dependency = nullptr;\n  })) {\n    output.addException(kj::mv(*exception));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "TransformPromiseNode {\n  void getImpl(ExceptionOrValue& output) override {\n      ExceptionOr<DepT> depResult;\n      getDepResult(depResult);\n      KJ_IF_MAYBE(depException, depResult.exception) {\n        output.as<T>() = handle(\n            MaybeVoidCaller<Exception, FixVoid<ReturnType<ErrorFunc, Exception>>>::apply(\n                errorHandler, kj::mv(*depException)));\n      } else KJ_IF_MAYBE(depValue, depResult.value) {\n        output.as<T>() = handle(MaybeVoidCaller<DepT, T>::apply(func, kj::mv(*depValue)));\n      }\n    }\n}"
  },
  {
    "function_name": "TransformPromiseNode",
    "container": "TransformPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "275-277",
    "snippet": "TransformPromiseNode(Own<PromiseNode>&& dependency, Func&& func, ErrorFunc&& errorHandler)\n      : TransformPromiseNodeBase(kj::mv(dependency)),\n        func(kj::fwd<Func>(func)), errorHandler(kj::fwd<ErrorFunc>(errorHandler)) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<ErrorFunc>",
          "args": [
            "errorHandler"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Func>",
          "args": [
            "func"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dependency"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "TransformPromiseNode {\n  TransformPromiseNode(Own<PromiseNode>&& dependency, Func&& func, ErrorFunc&& errorHandler)\n        : TransformPromiseNodeBase(kj::mv(dependency)),\n          func(kj::fwd<Func>(func)), errorHandler(kj::fwd<ErrorFunc>(errorHandler)) {}\n}"
  },
  {
    "function_name": "AttachmentPromiseNode",
    "container": "AttachmentPromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "233-235",
    "snippet": "AttachmentPromiseNode(Own<PromiseNode>&& dependency, Attachment&& attachment)\n      : AttachmentPromiseNodeBase(kj::mv(dependency)),\n        attachment(kj::mv<Attachment>(attachment)) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv<Attachment>",
          "args": [
            "attachment"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "dependency"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "AttachmentPromiseNode {\n  AttachmentPromiseNode(Own<PromiseNode>&& dependency, Attachment&& attachment)\n        : AttachmentPromiseNodeBase(kj::mv(dependency)),\n          attachment(kj::mv<Attachment>(attachment)) {}\n}"
  },
  {
    "function_name": "get",
    "container": "ImmediatePromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "190-192",
    "snippet": "void get(ExceptionOrValue& output) noexcept override {\n    output.as<T>() = kj::mv(result);\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.as<T>",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      }
    ],
    "contextual_snippet": "ImmediatePromiseNode {\n  void get(ExceptionOrValue& output) noexcept override {\n      output.as<T>() = kj::mv(result);\n    }\n}"
  },
  {
    "function_name": "ImmediatePromiseNode",
    "container": "ImmediatePromiseNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "188-188",
    "snippet": "ImmediatePromiseNode(ExceptionOr<T>&& result): result(kj::mv(result)) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ImmediatePromiseNode {\n  ImmediatePromiseNode(ExceptionOr<T>&& result): result(kj::mv(result)) {}\n}"
  },
  {
    "function_name": "ExceptionOr",
    "container": "ExceptionOr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "74-74",
    "snippet": "ExceptionOr(bool, Exception&& exception): ExceptionOrValue(false, kj::mv(exception)) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ExceptionOr {\n  ExceptionOr(bool, Exception&& exception): ExceptionOrValue(false, kj::mv(exception)) {}\n}"
  },
  {
    "function_name": "ExceptionOr",
    "container": "ExceptionOr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "73-73",
    "snippet": "ExceptionOr(T&& value): value(kj::mv(value)) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ExceptionOr {\n  ExceptionOr(T&& value): value(kj::mv(value)) {}\n}"
  },
  {
    "function_name": "addException",
    "container": "ExceptionOrValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "49-53",
    "snippet": "void addException(Exception&& exception) {\n    if (this->exception == nullptr) {\n      this->exception = kj::mv(exception);\n    }\n  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ExceptionOrValue {\n  void addException(Exception&& exception) {\n      if (this->exception == nullptr) {\n        this->exception = kj::mv(exception);\n      }\n    }\n}"
  },
  {
    "function_name": "ExceptionOrValue",
    "container": "ExceptionOrValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
    "lines": "46-46",
    "snippet": "ExceptionOrValue(bool, Exception&& exception): exception(kj::mv(exception)) {}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ExceptionOrValue {\n  ExceptionOrValue(bool, Exception&& exception): exception(kj::mv(exception)) {}\n}"
  }
]