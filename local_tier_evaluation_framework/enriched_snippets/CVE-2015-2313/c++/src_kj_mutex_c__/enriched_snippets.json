[
  {
    "function_name": "Once::reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "378-384",
    "snippet": "void Once::reset() {\n  State oldState = INITIALIZED;\n  if (!__atomic_compare_exchange_n(&state, &oldState, UNINITIALIZED,\n                                   false, __ATOMIC_RELEASE, __ATOMIC_RELAXED)) {\n    KJ_FAIL_REQUIRE(\"reset() called while not initialized.\");\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"reset() called while not initialized.\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&state",
            "&oldState",
            "UNINITIALIZED",
            "false",
            "__ATOMIC_RELEASE",
            "__ATOMIC_RELAXED"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nvoid Once::reset() {\n  State oldState = INITIALIZED;\n  if (!__atomic_compare_exchange_n(&state, &oldState, UNINITIALIZED,\n                                   false, __ATOMIC_RELEASE, __ATOMIC_RELAXED)) {\n    KJ_FAIL_REQUIRE(\"reset() called while not initialized.\");\n  }\n}"
  },
  {
    "function_name": "Once::runOnce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "365-376",
    "snippet": "void Once::runOnce(Initializer& init) {\n  KJ_PTHREAD_CALL(pthread_mutex_lock(&mutex));\n  KJ_DEFER(KJ_PTHREAD_CALL(pthread_mutex_unlock(&mutex)));\n\n  if (state != UNINITIALIZED) {\n    return;\n  }\n\n  init.run();\n\n  __atomic_store_n(&state, INITIALIZED, __ATOMIC_RELEASE);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_store_n",
          "args": [
            "&state",
            "INITIALIZED",
            "__ATOMIC_RELEASE"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init.run",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
          "lines": "338-340",
          "snippet": "void run() override {\n    lazy.value = func(lazy.space);\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <inttypes.h>",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nvoid run() override {\n    lazy.value = func(lazy.space);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "KJ_PTHREAD_CALL(pthread_mutex_unlock(&mutex))"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CALL",
          "args": [
            "pthread_mutex_unlock(&mutex)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&mutex"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CALL",
          "args": [
            "pthread_mutex_lock(&mutex)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&mutex"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nvoid Once::runOnce(Initializer& init) {\n  KJ_PTHREAD_CALL(pthread_mutex_lock(&mutex));\n  KJ_DEFER(KJ_PTHREAD_CALL(pthread_mutex_unlock(&mutex)));\n\n  if (state != UNINITIALIZED) {\n    return;\n  }\n\n  init.run();\n\n  __atomic_store_n(&state, INITIALIZED, __ATOMIC_RELEASE);\n}"
  },
  {
    "function_name": "Once::~Once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "361-363",
    "snippet": "Once::~Once() {\n  KJ_PTHREAD_CLEANUP(pthread_mutex_destroy(&mutex));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CLEANUP",
          "args": [
            "pthread_mutex_destroy(&mutex)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_destroy",
          "args": [
            "&mutex"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nOnce::~Once() {\n  KJ_PTHREAD_CLEANUP(pthread_mutex_destroy(&mutex));\n}"
  },
  {
    "function_name": "Once::Once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "358-360",
    "snippet": "Once::Once(bool startInitialized): state(startInitialized ? INITIALIZED : UNINITIALIZED) {\n  KJ_PTHREAD_CALL(pthread_mutex_init(&mutex, nullptr));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CALL",
          "args": [
            "pthread_mutex_init(&mutex, nullptr)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_init",
          "args": [
            "&mutex",
            "nullptr"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nOnce::Once(bool startInitialized): state(startInitialized ? INITIALIZED : UNINITIALIZED) {\n  KJ_PTHREAD_CALL(pthread_mutex_init(&mutex, nullptr));\n}"
  },
  {
    "function_name": "Mutex::assertLockedByCaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "338-356",
    "snippet": "void Mutex::assertLockedByCaller(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      // A read lock should fail if the mutex is already held for writing.\n      if (pthread_rwlock_tryrdlock(&mutex) == 0) {\n        pthread_rwlock_unlock(&mutex);\n        KJ_FAIL_ASSERT(\"Tried to call getAlreadyLocked*() but lock is not held.\");\n      }\n      break;\n    case SHARED:\n      // A write lock should fail if the mutex is already held for reading or writing.  We don't\n      // have any way to prove that the lock is held only for reading.\n      if (pthread_rwlock_trywrlock(&mutex) == 0) {\n        pthread_rwlock_unlock(&mutex);\n        KJ_FAIL_ASSERT(\"Tried to call getAlreadyLocked*() but lock is not held.\");\n      }\n      break;\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Tried to call getAlreadyLocked*() but lock is not held.\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_unlock",
          "args": [
            "&mutex"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_trywrlock",
          "args": [
            "&mutex"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Tried to call getAlreadyLocked*() but lock is not held.\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_unlock",
          "args": [
            "&mutex"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_tryrdlock",
          "args": [
            "&mutex"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nvoid Mutex::assertLockedByCaller(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      // A read lock should fail if the mutex is already held for writing.\n      if (pthread_rwlock_tryrdlock(&mutex) == 0) {\n        pthread_rwlock_unlock(&mutex);\n        KJ_FAIL_ASSERT(\"Tried to call getAlreadyLocked*() but lock is not held.\");\n      }\n      break;\n    case SHARED:\n      // A write lock should fail if the mutex is already held for reading or writing.  We don't\n      // have any way to prove that the lock is held only for reading.\n      if (pthread_rwlock_trywrlock(&mutex) == 0) {\n        pthread_rwlock_unlock(&mutex);\n        KJ_FAIL_ASSERT(\"Tried to call getAlreadyLocked*() but lock is not held.\");\n      }\n      break;\n  }\n}"
  },
  {
    "function_name": "Mutex::unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "334-336",
    "snippet": "void Mutex::unlock(Exclusivity exclusivity) {\n  KJ_PTHREAD_CALL(pthread_rwlock_unlock(&mutex));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CALL",
          "args": [
            "pthread_rwlock_unlock(&mutex)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_unlock",
          "args": [
            "&mutex"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nvoid Mutex::unlock(Exclusivity exclusivity) {\n  KJ_PTHREAD_CALL(pthread_rwlock_unlock(&mutex));\n}"
  },
  {
    "function_name": "Mutex::lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "323-332",
    "snippet": "void Mutex::lock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      KJ_PTHREAD_CALL(pthread_rwlock_wrlock(&mutex));\n      break;\n    case SHARED:\n      KJ_PTHREAD_CALL(pthread_rwlock_rdlock(&mutex));\n      break;\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CALL",
          "args": [
            "pthread_rwlock_rdlock(&mutex)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_rdlock",
          "args": [
            "&mutex"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CALL",
          "args": [
            "pthread_rwlock_wrlock(&mutex)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_wrlock",
          "args": [
            "&mutex"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nvoid Mutex::lock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      KJ_PTHREAD_CALL(pthread_rwlock_wrlock(&mutex));\n      break;\n    case SHARED:\n      KJ_PTHREAD_CALL(pthread_rwlock_rdlock(&mutex));\n      break;\n  }\n}"
  },
  {
    "function_name": "Mutex::~Mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "319-321",
    "snippet": "Mutex::~Mutex() {\n  KJ_PTHREAD_CLEANUP(pthread_rwlock_destroy(&mutex));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CLEANUP",
          "args": [
            "pthread_rwlock_destroy(&mutex)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_destroy",
          "args": [
            "&mutex"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nMutex::~Mutex() {\n  KJ_PTHREAD_CLEANUP(pthread_rwlock_destroy(&mutex));\n}"
  },
  {
    "function_name": "Mutex::Mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "316-318",
    "snippet": "Mutex::Mutex() {\n  KJ_PTHREAD_CALL(pthread_rwlock_init(&mutex, nullptr));\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_PTHREAD_CALL",
          "args": [
            "pthread_rwlock_init(&mutex, nullptr)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_init",
          "args": [
            "&mutex",
            "nullptr"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nMutex::Mutex() {\n  KJ_PTHREAD_CALL(pthread_rwlock_init(&mutex, nullptr));\n}"
  },
  {
    "function_name": "Once::reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "292-294",
    "snippet": "void Once::reset() {\n  InitOnceInitialize(&coercedInitOnce);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define coercedInitOnce (*reinterpret_cast<INIT_ONCE*>(&initOnce))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitOnceInitialize",
          "args": [
            "&coercedInitOnce"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define coercedInitOnce (*reinterpret_cast<INIT_ONCE*>(&initOnce))\n\nvoid Once::reset() {\n  InitOnceInitialize(&coercedInitOnce);\n}"
  },
  {
    "function_name": "Once::isInitialized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "287-290",
    "snippet": "bool Once::isInitialized() noexcept {\n  BOOL junk;\n  return InitOnceBeginInitialize(&coercedInitOnce, INIT_ONCE_CHECK_ONLY, &junk, nullptr);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define coercedInitOnce (*reinterpret_cast<INIT_ONCE*>(&initOnce))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitOnceBeginInitialize",
          "args": [
            "&coercedInitOnce",
            "INIT_ONCE_CHECK_ONLY",
            "&junk",
            "nullptr"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define coercedInitOnce (*reinterpret_cast<INIT_ONCE*>(&initOnce))\n\nbool Once::isInitialized() noexcept {\n  BOOL junk;\n  return InitOnceBeginInitialize(&coercedInitOnce, INIT_ONCE_CHECK_ONLY, &junk, nullptr);\n}"
  },
  {
    "function_name": "Once::runOnce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "271-285",
    "snippet": "void Once::runOnce(Initializer& init) {\n  BOOL needInit;\n  while (!InitOnceBeginInitialize(&coercedInitOnce, 0, &needInit, nullptr)) {\n    // Init was occurring in another thread, but then failed with an exception. Retry.\n  }\n\n  if (needInit) {\n    {\n      KJ_ON_SCOPE_FAILURE(InitOnceComplete(&coercedInitOnce, INIT_ONCE_INIT_FAILED, nullptr));\n      init.run();\n    }\n\n    KJ_ASSERT(InitOnceComplete(&coercedInitOnce, 0, nullptr));\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define coercedInitOnce (*reinterpret_cast<INIT_ONCE*>(&initOnce))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "InitOnceComplete(&coercedInitOnce, 0, nullptr)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitOnceComplete",
          "args": [
            "&coercedInitOnce",
            "0",
            "nullptr"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init.run",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
          "lines": "338-340",
          "snippet": "void run() override {\n    lazy.value = func(lazy.space);\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <inttypes.h>",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nvoid run() override {\n    lazy.value = func(lazy.space);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ON_SCOPE_FAILURE",
          "args": [
            "InitOnceComplete(&coercedInitOnce, INIT_ONCE_INIT_FAILED, nullptr)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitOnceComplete",
          "args": [
            "&coercedInitOnce",
            "INIT_ONCE_INIT_FAILED",
            "nullptr"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitOnceBeginInitialize",
          "args": [
            "&coercedInitOnce",
            "0",
            "&needInit",
            "nullptr"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define coercedInitOnce (*reinterpret_cast<INIT_ONCE*>(&initOnce))\n\nvoid Once::runOnce(Initializer& init) {\n  BOOL needInit;\n  while (!InitOnceBeginInitialize(&coercedInitOnce, 0, &needInit, nullptr)) {\n    // Init was occurring in another thread, but then failed with an exception. Retry.\n  }\n\n  if (needInit) {\n    {\n      KJ_ON_SCOPE_FAILURE(InitOnceComplete(&coercedInitOnce, INIT_ONCE_INIT_FAILED, nullptr));\n      init.run();\n    }\n\n    KJ_ASSERT(InitOnceComplete(&coercedInitOnce, 0, nullptr));\n  }\n}"
  },
  {
    "function_name": "Once::~Once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "269-269",
    "snippet": "Once::~Once() {}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nOnce::~Once() {}"
  },
  {
    "function_name": "Once::Once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "262-268",
    "snippet": "Once::Once(bool startInitialized) {\n  static_assert(sizeof(INIT_ONCE) == sizeof(initOnce), \"INIT_ONCE is not a pointer?\");\n  InitOnceInitialize(&coercedInitOnce);\n  if (startInitialized) {\n    InitOnceExecuteOnce(&coercedInitOnce, &nullInitializer, nullptr, nullptr);\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define coercedInitOnce (*reinterpret_cast<INIT_ONCE*>(&initOnce))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitOnceExecuteOnce",
          "args": [
            "&coercedInitOnce",
            "&nullInitializer",
            "nullptr",
            "nullptr"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitOnceInitialize",
          "args": [
            "&coercedInitOnce"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define coercedInitOnce (*reinterpret_cast<INIT_ONCE*>(&initOnce))\n\nOnce::Once(bool startInitialized) {\n  static_assert(sizeof(INIT_ONCE) == sizeof(initOnce), \"INIT_ONCE is not a pointer?\");\n  InitOnceInitialize(&coercedInitOnce);\n  if (startInitialized) {\n    InitOnceExecuteOnce(&coercedInitOnce, &nullInitializer, nullptr, nullptr);\n  }\n}"
  },
  {
    "function_name": "nullInitializer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "258-260",
    "snippet": "static BOOL WINAPI nullInitializer(PINIT_ONCE initOnce, PVOID parameter, PVOID* context) {\n  return true;\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nstatic BOOL WINAPI nullInitializer(PINIT_ONCE initOnce, PVOID parameter, PVOID* context) {\n  return true;\n}"
  },
  {
    "function_name": "Mutex::assertLockedByCaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "251-256",
    "snippet": "void Mutex::assertLockedByCaller(Exclusivity exclusivity) {\n  // We could use TryAcquireSRWLock*() here like we do with the pthread version. However, as of\n  // this writing, my version of Wine (1.6.2) doesn't implement these functions and will abort if\n  // they are called. Since we were only going to use them as a hacky way to check if the lock is\n  // held for debug purposes anyway, we just don't bother.\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nvoid Mutex::assertLockedByCaller(Exclusivity exclusivity) {\n  // We could use TryAcquireSRWLock*() here like we do with the pthread version. However, as of\n  // this writing, my version of Wine (1.6.2) doesn't implement these functions and will abort if\n  // they are called. Since we were only going to use them as a hacky way to check if the lock is\n  // held for debug purposes anyway, we just don't bother.\n}"
  },
  {
    "function_name": "Mutex::unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "240-249",
    "snippet": "void Mutex::unlock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      ReleaseSRWLockExclusive(&coercedSrwLock);\n      break;\n    case SHARED:\n      ReleaseSRWLockShared(&coercedSrwLock);\n      break;\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define coercedSrwLock (*reinterpret_cast<SRWLOCK*>(&srwLock))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSRWLockShared",
          "args": [
            "&coercedSrwLock"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSRWLockExclusive",
          "args": [
            "&coercedSrwLock"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define coercedSrwLock (*reinterpret_cast<SRWLOCK*>(&srwLock))\n\nvoid Mutex::unlock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      ReleaseSRWLockExclusive(&coercedSrwLock);\n      break;\n    case SHARED:\n      ReleaseSRWLockShared(&coercedSrwLock);\n      break;\n  }\n}"
  },
  {
    "function_name": "Mutex::lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "229-238",
    "snippet": "void Mutex::lock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      AcquireSRWLockExclusive(&coercedSrwLock);\n      break;\n    case SHARED:\n      AcquireSRWLockShared(&coercedSrwLock);\n      break;\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define coercedSrwLock (*reinterpret_cast<SRWLOCK*>(&srwLock))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AcquireSRWLockShared",
          "args": [
            "&coercedSrwLock"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AcquireSRWLockExclusive",
          "args": [
            "&coercedSrwLock"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define coercedSrwLock (*reinterpret_cast<SRWLOCK*>(&srwLock))\n\nvoid Mutex::lock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      AcquireSRWLockExclusive(&coercedSrwLock);\n      break;\n    case SHARED:\n      AcquireSRWLockShared(&coercedSrwLock);\n      break;\n  }\n}"
  },
  {
    "function_name": "Mutex::~Mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "227-227",
    "snippet": "Mutex::~Mutex() {}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nMutex::~Mutex() {}"
  },
  {
    "function_name": "Mutex::Mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "223-226",
    "snippet": "Mutex::Mutex() {\n  static_assert(sizeof(SRWLOCK) == sizeof(srwLock), \"SRWLOCK is not a pointer?\");\n  InitializeSRWLock(&coercedSrwLock);\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define coercedSrwLock (*reinterpret_cast<SRWLOCK*>(&srwLock))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitializeSRWLock",
          "args": [
            "&coercedSrwLock"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define coercedSrwLock (*reinterpret_cast<SRWLOCK*>(&srwLock))\n\nMutex::Mutex() {\n  static_assert(sizeof(SRWLOCK) == sizeof(srwLock), \"SRWLOCK is not a pointer?\");\n  InitializeSRWLock(&coercedSrwLock);\n}"
  },
  {
    "function_name": "Once::reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "208-214",
    "snippet": "void Once::reset() {\n  uint state = INITIALIZED;\n  if (!__atomic_compare_exchange_n(&futex, &state, UNINITIALIZED,\n                                   false, __ATOMIC_RELEASE, __ATOMIC_RELAXED)) {\n    KJ_FAIL_REQUIRE(\"reset() called while not initialized.\");\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"reset() called while not initialized.\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&futex",
            "&state",
            "UNINITIALIZED",
            "false",
            "__ATOMIC_RELEASE",
            "__ATOMIC_RELAXED"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nvoid Once::reset() {\n  uint state = INITIALIZED;\n  if (!__atomic_compare_exchange_n(&futex, &state, UNINITIALIZED,\n                                   false, __ATOMIC_RELEASE, __ATOMIC_RELAXED)) {\n    KJ_FAIL_REQUIRE(\"reset() called while not initialized.\");\n  }\n}"
  },
  {
    "function_name": "Once::runOnce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "157-206",
    "snippet": "void Once::runOnce(Initializer& init) {\nstartOver:\n  uint state = UNINITIALIZED;\n  if (__atomic_compare_exchange_n(&futex, &state, INITIALIZING, false,\n                                  __ATOMIC_RELAXED, __ATOMIC_RELAXED)) {\n    // It's our job to initialize!\n    {\n      KJ_ON_SCOPE_FAILURE({\n        // An exception was thrown by the initializer.  We have to revert.\n        if (__atomic_exchange_n(&futex, UNINITIALIZED, __ATOMIC_RELEASE) ==\n            INITIALIZING_WITH_WAITERS) {\n          // Someone was waiting for us to finish.\n          syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n        }\n      });\n\n      init.run();\n    }\n    if (__atomic_exchange_n(&futex, INITIALIZED, __ATOMIC_RELEASE) ==\n        INITIALIZING_WITH_WAITERS) {\n      // Someone was waiting for us to finish.\n      syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n    }\n  } else {\n    for (;;) {\n      if (state == INITIALIZED) {\n        break;\n      } else if (state == INITIALIZING) {\n        // Initialization is taking place in another thread.  Indicate that we're waiting.\n        if (!__atomic_compare_exchange_n(&futex, &state, INITIALIZING_WITH_WAITERS, true,\n                                         __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE)) {\n          // State changed, retry.\n          continue;\n        }\n      } else {\n        KJ_DASSERT(state == INITIALIZING_WITH_WAITERS);\n      }\n\n      // Wait for initialization.\n      syscall(SYS_futex, &futex, FUTEX_WAIT_PRIVATE, INITIALIZING_WITH_WAITERS, NULL, NULL, 0);\n      state = __atomic_load_n(&futex, __ATOMIC_ACQUIRE);\n\n      if (state == UNINITIALIZED) {\n        // Oh hey, apparently whoever was trying to initialize gave up.  Let's take it from the\n        // top.\n        goto startOver;\n      }\n    }\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define FUTEX_WAKE_PRIVATE FUTEX_WAKE",
      "#define FUTEX_WAIT_PRIVATE FUTEX_WAIT",
      "#define SYS_futex __NR_futex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_load_n",
          "args": [
            "&futex",
            "__ATOMIC_ACQUIRE"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_futex",
            "&futex",
            "FUTEX_WAIT_PRIVATE",
            "INITIALIZING_WITH_WAITERS",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "state == INITIALIZING_WITH_WAITERS"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&futex",
            "&state",
            "INITIALIZING_WITH_WAITERS",
            "true",
            "__ATOMIC_ACQUIRE",
            "__ATOMIC_ACQUIRE"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_futex",
            "&futex",
            "FUTEX_WAKE_PRIVATE",
            "INT_MAX",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_exchange_n",
          "args": [
            "&futex",
            "INITIALIZED",
            "__ATOMIC_RELEASE"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init.run",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
          "lines": "338-340",
          "snippet": "void run() override {\n    lazy.value = func(lazy.space);\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <inttypes.h>",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nvoid run() override {\n    lazy.value = func(lazy.space);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ON_SCOPE_FAILURE",
          "args": [
            "{\n        // An exception was thrown by the initializer.  We have to revert.\n        if (__atomic_exchange_n(&futex, UNINITIALIZED, __ATOMIC_RELEASE) ==\n            INITIALIZING_WITH_WAITERS) {\n          // Someone was waiting for us to finish.\n          syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n        }\n      }"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_futex",
            "&futex",
            "FUTEX_WAKE_PRIVATE",
            "INT_MAX",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_exchange_n",
          "args": [
            "&futex",
            "UNINITIALIZED",
            "__ATOMIC_RELEASE"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&futex",
            "&state",
            "INITIALIZING",
            "false",
            "__ATOMIC_RELAXED",
            "__ATOMIC_RELAXED"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define FUTEX_WAKE_PRIVATE FUTEX_WAKE\n#define FUTEX_WAIT_PRIVATE FUTEX_WAIT\n#define SYS_futex __NR_futex\n\nvoid Once::runOnce(Initializer& init) {\nstartOver:\n  uint state = UNINITIALIZED;\n  if (__atomic_compare_exchange_n(&futex, &state, INITIALIZING, false,\n                                  __ATOMIC_RELAXED, __ATOMIC_RELAXED)) {\n    // It's our job to initialize!\n    {\n      KJ_ON_SCOPE_FAILURE({\n        // An exception was thrown by the initializer.  We have to revert.\n        if (__atomic_exchange_n(&futex, UNINITIALIZED, __ATOMIC_RELEASE) ==\n            INITIALIZING_WITH_WAITERS) {\n          // Someone was waiting for us to finish.\n          syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n        }\n      });\n\n      init.run();\n    }\n    if (__atomic_exchange_n(&futex, INITIALIZED, __ATOMIC_RELEASE) ==\n        INITIALIZING_WITH_WAITERS) {\n      // Someone was waiting for us to finish.\n      syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n    }\n  } else {\n    for (;;) {\n      if (state == INITIALIZED) {\n        break;\n      } else if (state == INITIALIZING) {\n        // Initialization is taking place in another thread.  Indicate that we're waiting.\n        if (!__atomic_compare_exchange_n(&futex, &state, INITIALIZING_WITH_WAITERS, true,\n                                         __ATOMIC_ACQUIRE, __ATOMIC_ACQUIRE)) {\n          // State changed, retry.\n          continue;\n        }\n      } else {\n        KJ_DASSERT(state == INITIALIZING_WITH_WAITERS);\n      }\n\n      // Wait for initialization.\n      syscall(SYS_futex, &futex, FUTEX_WAIT_PRIVATE, INITIALIZING_WITH_WAITERS, NULL, NULL, 0);\n      state = __atomic_load_n(&futex, __ATOMIC_ACQUIRE);\n\n      if (state == UNINITIALIZED) {\n        // Oh hey, apparently whoever was trying to initialize gave up.  Let's take it from the\n        // top.\n        goto startOver;\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "Mutex::assertLockedByCaller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "144-155",
    "snippet": "void Mutex::assertLockedByCaller(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      KJ_ASSERT(futex & EXCLUSIVE_HELD,\n                \"Tried to call getAlreadyLocked*() but lock is not held.\");\n      break;\n    case SHARED:\n      KJ_ASSERT(futex & SHARED_COUNT_MASK,\n                \"Tried to call getAlreadyLocked*() but lock is not held.\");\n      break;\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "futex & SHARED_COUNT_MASK",
            "\"Tried to call getAlreadyLocked*() but lock is not held.\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "futex & EXCLUSIVE_HELD",
            "\"Tried to call getAlreadyLocked*() but lock is not held.\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nvoid Mutex::assertLockedByCaller(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      KJ_ASSERT(futex & EXCLUSIVE_HELD,\n                \"Tried to call getAlreadyLocked*() but lock is not held.\");\n      break;\n    case SHARED:\n      KJ_ASSERT(futex & SHARED_COUNT_MASK,\n                \"Tried to call getAlreadyLocked*() but lock is not held.\");\n      break;\n  }\n}"
  },
  {
    "function_name": "Mutex::unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "108-142",
    "snippet": "void Mutex::unlock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE: {\n      KJ_DASSERT(futex & EXCLUSIVE_HELD, \"Unlocked a mutex that wasn't locked.\");\n      uint oldState = __atomic_fetch_and(\n          &futex, ~(EXCLUSIVE_HELD | EXCLUSIVE_REQUESTED), __ATOMIC_RELEASE);\n\n      if (KJ_UNLIKELY(oldState & ~EXCLUSIVE_HELD)) {\n        // Other threads are waiting.  If there are any shared waiters, they now collectively hold\n        // the lock, and we must wake them up.  If there are any exclusive waiters, we must wake\n        // them up even if readers are waiting so that at the very least they may re-establish the\n        // EXCLUSIVE_REQUESTED bit that we just removed.\n        syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n      }\n      break;\n    }\n\n    case SHARED: {\n      KJ_DASSERT(futex & SHARED_COUNT_MASK, \"Unshared a mutex that wasn't shared.\");\n      uint state = __atomic_sub_fetch(&futex, 1, __ATOMIC_RELEASE);\n\n      // The only case where anyone is waiting is if EXCLUSIVE_REQUESTED is set, and the only time\n      // it makes sense to wake up that waiter is if the shared count has reached zero.\n      if (KJ_UNLIKELY(state == EXCLUSIVE_REQUESTED)) {\n        if (__atomic_compare_exchange_n(\n            &futex, &state, 0, false, __ATOMIC_RELAXED, __ATOMIC_RELAXED)) {\n          // Wake all exclusive waiters.  We have to wake all of them because one of them will\n          // grab the lock while the others will re-establish the exclusive-requested bit.\n          syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n        }\n      }\n      break;\n    }\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define FUTEX_WAKE_PRIVATE FUTEX_WAKE",
      "#define SYS_futex __NR_futex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_futex",
            "&futex",
            "FUTEX_WAKE_PRIVATE",
            "INT_MAX",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&futex",
            "&state",
            "0",
            "false",
            "__ATOMIC_RELAXED",
            "__ATOMIC_RELAXED"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "state == EXCLUSIVE_REQUESTED"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_sub_fetch",
          "args": [
            "&futex",
            "1",
            "__ATOMIC_RELEASE"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "futex & SHARED_COUNT_MASK",
            "\"Unshared a mutex that wasn't shared.\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_futex",
            "&futex",
            "FUTEX_WAKE_PRIVATE",
            "INT_MAX",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "oldState & ~EXCLUSIVE_HELD"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_fetch_and",
          "args": [
            "&futex",
            "~(EXCLUSIVE_HELD | EXCLUSIVE_REQUESTED)",
            "__ATOMIC_RELEASE"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "futex & EXCLUSIVE_HELD",
            "\"Unlocked a mutex that wasn't locked.\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define FUTEX_WAKE_PRIVATE FUTEX_WAKE\n#define SYS_futex __NR_futex\n\nvoid Mutex::unlock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE: {\n      KJ_DASSERT(futex & EXCLUSIVE_HELD, \"Unlocked a mutex that wasn't locked.\");\n      uint oldState = __atomic_fetch_and(\n          &futex, ~(EXCLUSIVE_HELD | EXCLUSIVE_REQUESTED), __ATOMIC_RELEASE);\n\n      if (KJ_UNLIKELY(oldState & ~EXCLUSIVE_HELD)) {\n        // Other threads are waiting.  If there are any shared waiters, they now collectively hold\n        // the lock, and we must wake them up.  If there are any exclusive waiters, we must wake\n        // them up even if readers are waiting so that at the very least they may re-establish the\n        // EXCLUSIVE_REQUESTED bit that we just removed.\n        syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n      }\n      break;\n    }\n\n    case SHARED: {\n      KJ_DASSERT(futex & SHARED_COUNT_MASK, \"Unshared a mutex that wasn't shared.\");\n      uint state = __atomic_sub_fetch(&futex, 1, __ATOMIC_RELEASE);\n\n      // The only case where anyone is waiting is if EXCLUSIVE_REQUESTED is set, and the only time\n      // it makes sense to wake up that waiter is if the shared count has reached zero.\n      if (KJ_UNLIKELY(state == EXCLUSIVE_REQUESTED)) {\n        if (__atomic_compare_exchange_n(\n            &futex, &state, 0, false, __ATOMIC_RELAXED, __ATOMIC_RELAXED)) {\n          // Wake all exclusive waiters.  We have to wake all of them because one of them will\n          // grab the lock while the others will re-establish the exclusive-requested bit.\n          syscall(SYS_futex, &futex, FUTEX_WAKE_PRIVATE, INT_MAX, NULL, NULL, 0);\n        }\n      }\n      break;\n    }\n  }\n}"
  },
  {
    "function_name": "Mutex::lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "65-106",
    "snippet": "void Mutex::lock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      for (;;) {\n        uint state = 0;\n        if (KJ_LIKELY(__atomic_compare_exchange_n(&futex, &state, EXCLUSIVE_HELD, false,\n                                                  __ATOMIC_ACQUIRE, __ATOMIC_RELAXED))) {\n          // Acquired.\n          break;\n        }\n\n        // The mutex is contended.  Set the exclusive-requested bit and wait.\n        if ((state & EXCLUSIVE_REQUESTED) == 0) {\n          if (!__atomic_compare_exchange_n(&futex, &state, state | EXCLUSIVE_REQUESTED, false,\n                                           __ATOMIC_RELAXED, __ATOMIC_RELAXED)) {\n            // Oops, the state changed before we could set the request bit.  Start over.\n            continue;\n          }\n\n          state |= EXCLUSIVE_REQUESTED;\n        }\n\n        syscall(SYS_futex, &futex, FUTEX_WAIT_PRIVATE, state, NULL, NULL, 0);\n      }\n      break;\n    case SHARED: {\n      uint state = __atomic_add_fetch(&futex, 1, __ATOMIC_ACQUIRE);\n      for (;;) {\n        if (KJ_LIKELY((state & EXCLUSIVE_HELD) == 0)) {\n          // Acquired.\n          break;\n        }\n\n        // The mutex is exclusively locked by another thread.  Since we incremented the counter\n        // already, we just have to wait for it to be unlocked.\n        syscall(SYS_futex, &futex, FUTEX_WAIT_PRIVATE, state, NULL, NULL, 0);\n        state = __atomic_load_n(&futex, __ATOMIC_ACQUIRE);\n      }\n      break;\n    }\n  }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define FUTEX_WAIT_PRIVATE FUTEX_WAIT",
      "#define SYS_futex __NR_futex"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_load_n",
          "args": [
            "&futex",
            "__ATOMIC_ACQUIRE"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_futex",
            "&futex",
            "FUTEX_WAIT_PRIVATE",
            "state",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LIKELY",
          "args": [
            "(state & EXCLUSIVE_HELD) == 0"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_add_fetch",
          "args": [
            "&futex",
            "1",
            "__ATOMIC_ACQUIRE"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_futex",
            "&futex",
            "FUTEX_WAIT_PRIVATE",
            "state",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&futex",
            "&state",
            "state | EXCLUSIVE_REQUESTED",
            "false",
            "__ATOMIC_RELAXED",
            "__ATOMIC_RELAXED"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_LIKELY",
          "args": [
            "__atomic_compare_exchange_n(&futex, &state, EXCLUSIVE_HELD, false,\n                                                  __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_compare_exchange_n",
          "args": [
            "&futex",
            "&state",
            "EXCLUSIVE_HELD",
            "false",
            "__ATOMIC_ACQUIRE",
            "__ATOMIC_RELAXED"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define FUTEX_WAIT_PRIVATE FUTEX_WAIT\n#define SYS_futex __NR_futex\n\nvoid Mutex::lock(Exclusivity exclusivity) {\n  switch (exclusivity) {\n    case EXCLUSIVE:\n      for (;;) {\n        uint state = 0;\n        if (KJ_LIKELY(__atomic_compare_exchange_n(&futex, &state, EXCLUSIVE_HELD, false,\n                                                  __ATOMIC_ACQUIRE, __ATOMIC_RELAXED))) {\n          // Acquired.\n          break;\n        }\n\n        // The mutex is contended.  Set the exclusive-requested bit and wait.\n        if ((state & EXCLUSIVE_REQUESTED) == 0) {\n          if (!__atomic_compare_exchange_n(&futex, &state, state | EXCLUSIVE_REQUESTED, false,\n                                           __ATOMIC_RELAXED, __ATOMIC_RELAXED)) {\n            // Oops, the state changed before we could set the request bit.  Start over.\n            continue;\n          }\n\n          state |= EXCLUSIVE_REQUESTED;\n        }\n\n        syscall(SYS_futex, &futex, FUTEX_WAIT_PRIVATE, state, NULL, NULL, 0);\n      }\n      break;\n    case SHARED: {\n      uint state = __atomic_add_fetch(&futex, 1, __ATOMIC_ACQUIRE);\n      for (;;) {\n        if (KJ_LIKELY((state & EXCLUSIVE_HELD) == 0)) {\n          // Acquired.\n          break;\n        }\n\n        // The mutex is exclusively locked by another thread.  Since we incremented the counter\n        // already, we just have to wait for it to be unlocked.\n        syscall(SYS_futex, &futex, FUTEX_WAIT_PRIVATE, state, NULL, NULL, 0);\n        state = __atomic_load_n(&futex, __ATOMIC_ACQUIRE);\n      }\n      break;\n    }\n  }\n}"
  },
  {
    "function_name": "Mutex::~Mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "60-63",
    "snippet": "Mutex::~Mutex() {\n  // This will crash anyway, might as well crash with a nice error message.\n  KJ_ASSERT(futex == 0, \"Mutex destroyed while locked.\") { break; }\n}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "futex == 0",
            "\"Mutex destroyed while locked.\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nMutex::~Mutex() {\n  // This will crash anyway, might as well crash with a nice error message.\n  KJ_ASSERT(futex == 0, \"Mutex destroyed while locked.\") { break; }\n}"
  },
  {
    "function_name": "Mutex::Mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.c++",
    "lines": "59-59",
    "snippet": "Mutex::Mutex(): futex(0) {}",
    "includes": [
      "#include <windows.h>",
      "#include <limits.h>",
      "#include <linux/futex.h>",
      "#include <sys/syscall.h>",
      "#include <unistd.h>",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <windows.h>\n#include <limits.h>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"debug.h\"\n#include \"mutex.h\"\n\nMutex::Mutex(): futex(0) {}"
  }
]