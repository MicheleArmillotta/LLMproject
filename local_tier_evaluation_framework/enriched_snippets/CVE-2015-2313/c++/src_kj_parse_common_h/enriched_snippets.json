[
  {
    "function_name": "notLookingAt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "753-757",
    "snippet": "constexpr NotLookingAt_<SubParser> notLookingAt(SubParser&& subParser) {\n  // Constructs a parser which fails at any position where the given parser succeeds.  Otherwise,\n  // it succeeds without consuming any input and returns an empty tuple.\n  return NotLookingAt_<SubParser>(kj::fwd<SubParser>(subParser));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NotLookingAt_<SubParser>",
          "args": [
            "kj::fwd<SubParser>(subParser)"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "NotLookingAt_",
          "container": "NotLookingAt_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "734-735",
          "snippet": "explicit constexpr NotLookingAt_(SubParser&& subParser)\n      : subParser(kj::fwd<SubParser>(subParser)) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nNotLookingAt_ {\n  explicit constexpr NotLookingAt_(SubParser&& subParser)\n        : subParser(kj::fwd<SubParser>(subParser)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr NotLookingAt_<SubParser> notLookingAt(SubParser&& subParser) {\n  // Constructs a parser which fails at any position where the given parser succeeds.  Otherwise,\n  // it succeeds without consuming any input and returns an empty tuple.\n  return NotLookingAt_<SubParser>(kj::fwd<SubParser>(subParser));\n}"
  },
  {
    "function_name": "NotLookingAt_",
    "container": "NotLookingAt_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "734-735",
    "snippet": "explicit constexpr NotLookingAt_(SubParser&& subParser)\n      : subParser(kj::fwd<SubParser>(subParser)) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nNotLookingAt_ {\n  explicit constexpr NotLookingAt_(SubParser&& subParser)\n        : subParser(kj::fwd<SubParser>(subParser)) {}\n}"
  },
  {
    "function_name": "transformWithLocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "718-725",
    "snippet": "constexpr TransformWithLocation_<SubParser, TransformFunc> transformWithLocation(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform` except that `functor` also takes a `Span` as its first parameter specifying\n  // the location of the parsed content.  The span's position type is whatever the parser input's\n  // getPosition() returns.\n  return TransformWithLocation_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransformWithLocation_<SubParser, TransformFunc>",
          "args": [
            "kj::fwd<SubParser>(subParser)",
            "kj::fwd<TransformFunc>(functor)"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "TransformWithLocation_",
          "container": "TransformWithLocation_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "676-677",
          "snippet": "explicit constexpr TransformWithLocation_(SubParser&& subParser, TransformFunc&& transform)\n      : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nTransformWithLocation_ {\n  explicit constexpr TransformWithLocation_(SubParser&& subParser, TransformFunc&& transform)\n        : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<TransformFunc>",
          "args": [
            "functor"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr TransformWithLocation_<SubParser, TransformFunc> transformWithLocation(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform` except that `functor` also takes a `Span` as its first parameter specifying\n  // the location of the parsed content.  The span's position type is whatever the parser input's\n  // getPosition() returns.\n  return TransformWithLocation_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
  },
  {
    "function_name": "transformOrReject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "709-715",
    "snippet": "constexpr TransformOrReject_<SubParser, TransformFunc> transformOrReject(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform()` except that `functor` returns a `Maybe`.  If it returns null, parsing fails,\n  // otherwise the parser's result is the content of the `Maybe`.\n  return TransformOrReject_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransformOrReject_<SubParser, TransformFunc>",
          "args": [
            "kj::fwd<SubParser>(subParser)",
            "kj::fwd<TransformFunc>(functor)"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "TransformOrReject_",
          "container": "TransformOrReject_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "655-656",
          "snippet": "explicit constexpr TransformOrReject_(SubParser&& subParser, TransformFunc&& transform)\n      : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nTransformOrReject_ {\n  explicit constexpr TransformOrReject_(SubParser&& subParser, TransformFunc&& transform)\n        : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<TransformFunc>",
          "args": [
            "functor"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr TransformOrReject_<SubParser, TransformFunc> transformOrReject(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Like `transform()` except that `functor` returns a `Maybe`.  If it returns null, parsing fails,\n  // otherwise the parser's result is the content of the `Maybe`.\n  return TransformOrReject_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
  },
  {
    "function_name": "transform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "699-706",
    "snippet": "constexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Transform_<SubParser, TransformFunc>",
          "args": [
            "kj::fwd<SubParser>(subParser)",
            "kj::fwd<TransformFunc>(functor)"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "Transform_",
          "container": "Transform_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "633-634",
          "snippet": "explicit constexpr Transform_(SubParser&& subParser, TransformFunc&& transform)\n      : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nTransform_ {\n  explicit constexpr Transform_(SubParser&& subParser, TransformFunc&& transform)\n        : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<TransformFunc>",
          "args": [
            "functor"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Transform_<SubParser, TransformFunc> transform(\n    SubParser&& subParser, TransformFunc&& functor) {\n  // Constructs a parser which executes some other parser and then transforms the result by invoking\n  // `functor` on it.  Typically `functor` is a lambda.  It is invoked using `kj::apply`,\n  // meaning tuples will be unpacked as arguments.\n  return Transform_<SubParser, TransformFunc>(\n      kj::fwd<SubParser>(subParser), kj::fwd<TransformFunc>(functor));\n}"
  },
  {
    "function_name": "TransformWithLocation_",
    "container": "TransformWithLocation_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "676-677",
    "snippet": "explicit constexpr TransformWithLocation_(SubParser&& subParser, TransformFunc&& transform)\n      : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<TransformFunc>",
          "args": [
            "transform"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nTransformWithLocation_ {\n  explicit constexpr TransformWithLocation_(SubParser&& subParser, TransformFunc&& transform)\n        : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}\n}"
  },
  {
    "function_name": "TransformOrReject_",
    "container": "TransformOrReject_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "655-656",
    "snippet": "explicit constexpr TransformOrReject_(SubParser&& subParser, TransformFunc&& transform)\n      : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<TransformFunc>",
          "args": [
            "transform"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nTransformOrReject_ {\n  explicit constexpr TransformOrReject_(SubParser&& subParser, TransformFunc&& transform)\n        : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}\n}"
  },
  {
    "function_name": "Transform_",
    "container": "Transform_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "633-634",
    "snippet": "explicit constexpr Transform_(SubParser&& subParser, TransformFunc&& transform)\n      : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<TransformFunc>",
          "args": [
            "transform"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nTransform_ {\n  explicit constexpr Transform_(SubParser&& subParser, TransformFunc&& transform)\n        : subParser(kj::fwd<SubParser>(subParser)), transform(kj::fwd<TransformFunc>(transform)) {}\n}"
  },
  {
    "function_name": "span",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "626-628",
    "snippet": "constexpr Span<Decay<Position>> span(Position&& start, Position&& end) {\n  return Span<Decay<Position>>(kj::fwd<Position>(start), kj::fwd<Position>(end));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Span<Decay<Position>>",
          "args": [
            "kj::fwd<Position>(start)",
            "kj::fwd<Position>(end)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Position>",
          "args": [
            "end"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Position>",
          "args": [
            "start"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Span<Decay<Position>> span(Position&& start, Position&& end) {\n  return Span<Decay<Position>>(kj::fwd<Position>(start), kj::fwd<Position>(end));\n}"
  },
  {
    "function_name": "Span",
    "container": "Span",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "618-618",
    "snippet": "inline constexpr Span(Position&& begin, Position&& end): begin_(mv(begin)), end_(mv(end)) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "end"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "begin"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nSpan {\n  inline constexpr Span(Position&& begin, Position&& end): begin_(mv(begin)), end_(mv(end)) {}\n}"
  },
  {
    "function_name": "oneOf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "599-604",
    "snippet": "constexpr OneOf_<SubParsers...> oneOf(SubParsers&&... parsers) {\n  // Constructs a parser that accepts one of a set of options.  The parser behaves as the first\n  // sub-parser in the list which returns successfully.  All of the sub-parsers must return the\n  // same type.\n  return OneOf_<SubParsers...>(kj::fwd<SubParsers>(parsers)...);\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OneOf_<SubParsers...>",
          "args": [
            "kj::fwd<SubParsers>(parsers)..."
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "OneOf_",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "565-566",
          "snippet": "explicit constexpr OneOf_(FirstSubParser&& firstSubParser, SubParsers&&... rest)\n      : first(kj::fwd<FirstSubParser>(firstSubParser)), rest(kj::fwd<SubParsers>(rest)...) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nexplicit constexpr OneOf_(FirstSubParser&& firstSubParser, SubParsers&&... rest)\n      : first(kj::fwd<FirstSubParser>(firstSubParser)), rest(kj::fwd<SubParsers>(rest)...) {}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParsers>",
          "args": [
            "parsers"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr OneOf_<SubParsers...> oneOf(SubParsers&&... parsers) {\n  // Constructs a parser that accepts one of a set of options.  The parser behaves as the first\n  // sub-parser in the list which returns successfully.  All of the sub-parsers must return the\n  // same type.\n  return OneOf_<SubParsers...>(kj::fwd<SubParsers>(parsers)...);\n}"
  },
  {
    "function_name": "OneOf_",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "565-566",
    "snippet": "explicit constexpr OneOf_(FirstSubParser&& firstSubParser, SubParsers&&... rest)\n      : first(kj::fwd<FirstSubParser>(firstSubParser)), rest(kj::fwd<SubParsers>(rest)...) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<SubParsers>",
          "args": [
            "rest"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<FirstSubParser>",
          "args": [
            "firstSubParser"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nexplicit constexpr OneOf_(FirstSubParser&& firstSubParser, SubParsers&&... rest)\n      : first(kj::fwd<FirstSubParser>(firstSubParser)), rest(kj::fwd<SubParsers>(rest)...) {}"
  },
  {
    "function_name": "optional",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "548-552",
    "snippet": "constexpr Optional_<SubParser> optional(SubParser&& subParser) {\n  // Constructs a parser that accepts zero or one of the given sub-parser, returning a Maybe\n  // of the sub-parser's result.\n  return Optional_<SubParser>(kj::fwd<SubParser>(subParser));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Optional_<SubParser>",
          "args": [
            "kj::fwd<SubParser>(subParser)"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "Optional_",
          "container": "Optional_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "527-528",
          "snippet": "explicit constexpr Optional_(SubParser&& subParser)\n      : subParser(kj::fwd<SubParser>(subParser)) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nOptional_ {\n  explicit constexpr Optional_(SubParser&& subParser)\n        : subParser(kj::fwd<SubParser>(subParser)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Optional_<SubParser> optional(SubParser&& subParser) {\n  // Constructs a parser that accepts zero or one of the given sub-parser, returning a Maybe\n  // of the sub-parser's result.\n  return Optional_<SubParser>(kj::fwd<SubParser>(subParser));\n}"
  },
  {
    "function_name": "Optional_",
    "container": "Optional_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "527-528",
    "snippet": "explicit constexpr Optional_(SubParser&& subParser)\n      : subParser(kj::fwd<SubParser>(subParser)) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nOptional_ {\n  explicit constexpr Optional_(SubParser&& subParser)\n        : subParser(kj::fwd<SubParser>(subParser)) {}\n}"
  },
  {
    "function_name": "times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "515-518",
    "snippet": "constexpr Times_<SubParser> times(SubParser&& subParser, uint count) {\n  // Constructs a parser that repeats the subParser exactly `count` times.\n  return Times_<SubParser>(kj::fwd<SubParser>(subParser), count);\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Times_<SubParser>",
          "args": [
            "kj::fwd<SubParser>(subParser)",
            "count"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "Times_",
          "container": "Times_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "453-454",
          "snippet": "explicit constexpr Times_(SubParser&& subParser, uint count)\n      : subParser(kj::fwd<SubParser>(subParser)), count(count) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nTimes_ {\n  explicit constexpr Times_(SubParser&& subParser, uint count)\n        : subParser(kj::fwd<SubParser>(subParser)), count(count) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Times_<SubParser> times(SubParser&& subParser, uint count) {\n  // Constructs a parser that repeats the subParser exactly `count` times.\n  return Times_<SubParser>(kj::fwd<SubParser>(subParser), count);\n}"
  },
  {
    "function_name": "Times_<SubParser>::operator()",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "509-512",
    "snippet": "auto Times_<SubParser>::operator()(Input& input) const\n    -> decltype(Impl<Input>::apply(instance<const SubParser&>(), instance<uint>(), input)) {\n  return Impl<Input, OutputType<SubParser, Input>>::apply(subParser, count, input);\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Impl<Input, OutputType<SubParser, Input>>::apply",
          "args": [
            "subParser",
            "count",
            "input"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "490-504",
          "snippet": "static Maybe<Tuple<>> apply(const SubParser& subParser, uint count, Input& input) {\n    uint actualCount = 0;\n\n    while (actualCount < count) {\n      if (input.atEnd()) {\n        return nullptr;\n      } else KJ_IF_MAYBE(subResult, subParser(input)) {\n        ++actualCount;\n      } else {\n        return nullptr;\n      }\n    }\n\n    return tuple();\n  }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nstatic Maybe<Tuple<>> apply(const SubParser& subParser, uint count, Input& input) {\n    uint actualCount = 0;\n\n    while (actualCount < count) {\n      if (input.atEnd()) {\n        return nullptr;\n      } else KJ_IF_MAYBE(subResult, subParser(input)) {\n        ++actualCount;\n      } else {\n        return nullptr;\n      }\n    }\n\n    return tuple();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "instance<uint>",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance<const SubParser&>",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nauto Times_<SubParser>::operator()(Input& input) const\n    -> decltype(Impl<Input>::apply(instance<const SubParser&>(), instance<uint>(), input)) {\n  return Impl<Input, OutputType<SubParser, Input>>::apply(subParser, count, input);\n}"
  },
  {
    "function_name": "apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "490-504",
    "snippet": "static Maybe<Tuple<>> apply(const SubParser& subParser, uint count, Input& input) {\n    uint actualCount = 0;\n\n    while (actualCount < count) {\n      if (input.atEnd()) {\n        return nullptr;\n      } else KJ_IF_MAYBE(subResult, subParser(input)) {\n        ++actualCount;\n      } else {\n        return nullptr;\n      }\n    }\n\n    return tuple();\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuple",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "tuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/tuple.h",
          "lines": "333-338",
          "snippet": "inline auto tuple(Params&&... params)\n    -> decltype(_::expandAndApply(_::MakeTupleFunc(), kj::fwd<Params>(params)...)) {\n  // Construct a new tuple from the given values.  Any tuples in the argument list will be\n  // flattened into the result.\n  return _::expandAndApply(_::MakeTupleFunc(), kj::fwd<Params>(params)...);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\ninline auto tuple(Params&&... params)\n    -> decltype(_::expandAndApply(_::MakeTupleFunc(), kj::fwd<Params>(params)...)) {\n  // Construct a new tuple from the given values.  Any tuples in the argument list will be\n  // flattened into the result.\n  return _::expandAndApply(_::MakeTupleFunc(), kj::fwd<Params>(params)...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "subResult",
            "subParser(input)"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common-test.c++",
          "lines": "385-387",
          "snippet": "KJ_IF_MAYBE(s, result) {\n      EXPECT_EQ(\"bar\", *s);\n    }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../string.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../string.h\"\n#include \"common.h\"\n\nKJ_IF_MAYBE(s, result) {\n      EXPECT_EQ(\"bar\", *s);\n    }"
        }
      },
      {
        "call_info": {
          "callee": "subParser",
          "args": [
            "input"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.atEnd",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "atEnd",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "75-75",
          "snippet": "bool atEnd() { return pos == end; }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  bool atEnd() { return pos == end; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nstatic Maybe<Tuple<>> apply(const SubParser& subParser, uint count, Input& input) {\n    uint actualCount = 0;\n\n    while (actualCount < count) {\n      if (input.atEnd()) {\n        return nullptr;\n      } else KJ_IF_MAYBE(subResult, subParser(input)) {\n        ++actualCount;\n      } else {\n        return nullptr;\n      }\n    }\n\n    return tuple();\n  }"
  },
  {
    "function_name": "apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "468-482",
    "snippet": "static Maybe<Array<Output>> apply(const SubParser& subParser, uint count, Input& input) {\n    auto results = heapArrayBuilder<OutputType<SubParser, Input>>(count);\n\n    while (results.size() < count) {\n      if (input.atEnd()) {\n        return nullptr;\n      } else KJ_IF_MAYBE(subResult, subParser(input)) {\n        results.add(kj::mv(*subResult));\n      } else {\n        return nullptr;\n      }\n    }\n\n    return results.finish();\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "results.finish",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "results.add",
          "args": [
            "kj::mv(*subResult)"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*subResult"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "subResult",
            "subParser(input)"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common-test.c++",
          "lines": "385-387",
          "snippet": "KJ_IF_MAYBE(s, result) {\n      EXPECT_EQ(\"bar\", *s);\n    }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../string.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../string.h\"\n#include \"common.h\"\n\nKJ_IF_MAYBE(s, result) {\n      EXPECT_EQ(\"bar\", *s);\n    }"
        }
      },
      {
        "call_info": {
          "callee": "subParser",
          "args": [
            "input"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "input.atEnd",
          "args": [],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "atEnd",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "75-75",
          "snippet": "bool atEnd() { return pos == end; }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  bool atEnd() { return pos == end; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "results.size",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<OutputType<SubParser, Input>>",
          "args": [
            "count"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nstatic Maybe<Array<Output>> apply(const SubParser& subParser, uint count, Input& input) {\n    auto results = heapArrayBuilder<OutputType<SubParser, Input>>(count);\n\n    while (results.size() < count) {\n      if (input.atEnd()) {\n        return nullptr;\n      } else KJ_IF_MAYBE(subResult, subParser(input)) {\n        results.add(kj::mv(*subResult));\n      } else {\n        return nullptr;\n      }\n    }\n\n    return results.finish();\n  }"
  },
  {
    "function_name": "Times_",
    "container": "Times_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "453-454",
    "snippet": "explicit constexpr Times_(SubParser&& subParser, uint count)\n      : subParser(kj::fwd<SubParser>(subParser)), count(count) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nTimes_ {\n  explicit constexpr Times_(SubParser&& subParser, uint count)\n        : subParser(kj::fwd<SubParser>(subParser)), count(count) {}\n}"
  },
  {
    "function_name": "oneOrMore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "439-442",
    "snippet": "constexpr Many_<SubParser, true> oneOrMore(SubParser&& subParser) {\n  // Like `many()` but the parser must parse at least one item to be successful.\n  return Many_<SubParser, true>(kj::fwd<SubParser>(subParser));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Many_<SubParser, true>",
          "args": [
            "kj::fwd<SubParser>(subParser)"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "Many_",
          "container": "Many_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "360-361",
          "snippet": "explicit constexpr Many_(SubParser&& subParser)\n      : subParser(kj::fwd<SubParser>(subParser)) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nMany_ {\n  explicit constexpr Many_(SubParser&& subParser)\n        : subParser(kj::fwd<SubParser>(subParser)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Many_<SubParser, true> oneOrMore(SubParser&& subParser) {\n  // Like `many()` but the parser must parse at least one item to be successful.\n  return Many_<SubParser, true>(kj::fwd<SubParser>(subParser));\n}"
  },
  {
    "function_name": "many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "432-436",
    "snippet": "constexpr Many_<SubParser, false> many(SubParser&& subParser) {\n  // Constructs a parser that repeatedly executes the given parser until it fails, returning an\n  // Array of the results (or a uint count if `subParser` returns an empty tuple).\n  return Many_<SubParser, false>(kj::fwd<SubParser>(subParser));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Many_<SubParser, false>",
          "args": [
            "kj::fwd<SubParser>(subParser)"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "Many_",
          "container": "Many_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "360-361",
          "snippet": "explicit constexpr Many_(SubParser&& subParser)\n      : subParser(kj::fwd<SubParser>(subParser)) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nMany_ {\n  explicit constexpr Many_(SubParser&& subParser)\n        : subParser(kj::fwd<SubParser>(subParser)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Many_<SubParser, false> many(SubParser&& subParser) {\n  // Constructs a parser that repeatedly executes the given parser until it fails, returning an\n  // Array of the results (or a uint count if `subParser` returns an empty tuple).\n  return Many_<SubParser, false>(kj::fwd<SubParser>(subParser));\n}"
  },
  {
    "function_name": "Many_<SubParser, atLeastOne>::operator()",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "426-429",
    "snippet": "auto Many_<SubParser, atLeastOne>::operator()(Input& input) const\n    -> decltype(Impl<Input>::apply(instance<const SubParser&>(), input)) {\n  return Impl<Input, OutputType<SubParser, Input>>::apply(subParser, input);\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Impl<Input, OutputType<SubParser, Input>>::apply",
          "args": [
            "subParser",
            "input"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/orphan.h",
          "lines": "311-313",
          "snippet": "static inline _::OrphanBuilder apply(_::BuilderArena* arena, uint size) {\n    return _::OrphanBuilder::initData(arena, size * BYTES);\n  }",
          "includes": [
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n\nstatic inline _::OrphanBuilder apply(_::BuilderArena* arena, uint size) {\n    return _::OrphanBuilder::initData(arena, size * BYTES);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "instance<const SubParser&>",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nauto Many_<SubParser, atLeastOne>::operator()(Input& input) const\n    -> decltype(Impl<Input>::apply(instance<const SubParser&>(), input)) {\n  return Impl<Input, OutputType<SubParser, Input>>::apply(subParser, input);\n}"
  },
  {
    "function_name": "if",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "416-418",
    "snippet": "if (atLeastOne && count == 0) {\n      return nullptr;\n    }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nif (atLeastOne && count == 0) {\n      return nullptr;\n    }"
  },
  {
    "function_name": "apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "402-414",
    "snippet": "static Maybe<uint> apply(const SubParser& subParser, Input& input) {\n    uint count = 0;\n\n    while (!input.atEnd()) {\n      Input subInput(input);\n\n      KJ_IF_MAYBE(subResult, subParser(subInput)) {\n        subInput.advanceParent();\n        ++count;\n      } else {\n        break;\n      }\n    }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "subInput.advanceParent",
          "args": [],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "advanceParent",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "68-70",
          "snippet": "void advanceParent() {\n    parent->pos = pos;\n  }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  void advanceParent() {\n      parent->pos = pos;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.atEnd",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "atEnd",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "75-75",
          "snippet": "bool atEnd() { return pos == end; }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  bool atEnd() { return pos == end; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nstatic Maybe<uint> apply(const SubParser& subParser, Input& input) {\n    uint count = 0;\n\n    while (!input.atEnd()) {\n      Input subInput(input);\n\n      KJ_IF_MAYBE(subResult, subParser(subInput)) {\n        subInput.advanceParent();\n        ++count;\n      } else {\n        break;\n      }\n    }"
  },
  {
    "function_name": "if",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "389-391",
    "snippet": "if (atLeastOne && results.empty()) {\n      return nullptr;\n    }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nif (atLeastOne && results.empty()) {\n      return nullptr;\n    }"
  },
  {
    "function_name": "apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "374-387",
    "snippet": "static Maybe<Array<Output>> apply(const SubParser& subParser, Input& input) {\n    typedef Vector<OutputType<SubParser, Input>> Results;\n    Results results;\n\n    while (!input.atEnd()) {\n      Input subInput(input);\n\n      KJ_IF_MAYBE(subResult, subParser(subInput)) {\n        subInput.advanceParent();\n        results.add(kj::mv(*subResult));\n      } else {\n        break;\n      }\n    }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "results.add",
          "args": [
            "kj::mv(*subResult)"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*subResult"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subInput.advanceParent",
          "args": [],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "advanceParent",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "68-70",
          "snippet": "void advanceParent() {\n    parent->pos = pos;\n  }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  void advanceParent() {\n      parent->pos = pos;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.atEnd",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "atEnd",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "75-75",
          "snippet": "bool atEnd() { return pos == end; }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  bool atEnd() { return pos == end; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nstatic Maybe<Array<Output>> apply(const SubParser& subParser, Input& input) {\n    typedef Vector<OutputType<SubParser, Input>> Results;\n    Results results;\n\n    while (!input.atEnd()) {\n      Input subInput(input);\n\n      KJ_IF_MAYBE(subResult, subParser(subInput)) {\n        subInput.advanceParent();\n        results.add(kj::mv(*subResult));\n      } else {\n        break;\n      }\n    }"
  },
  {
    "function_name": "Many_",
    "container": "Many_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "360-361",
    "snippet": "explicit constexpr Many_(SubParser&& subParser)\n      : subParser(kj::fwd<SubParser>(subParser)) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nMany_ {\n  explicit constexpr Many_(SubParser&& subParser)\n        : subParser(kj::fwd<SubParser>(subParser)) {}\n}"
  },
  {
    "function_name": "sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "344-349",
    "snippet": "constexpr Sequence_<SubParsers...> sequence(SubParsers&&... subParsers) {\n  // Constructs a parser that executes each of the parameter parsers in sequence and returns a\n  // tuple of their results.\n\n  return Sequence_<SubParsers...>(kj::fwd<SubParsers>(subParsers)...);\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Sequence_<SubParsers...>",
          "args": [
            "kj::fwd<SubParsers>(subParsers)..."
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "Sequence_",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "298-299",
          "snippet": "explicit constexpr Sequence_(T&& firstSubParser, U&&... rest)\n      : first(kj::fwd<T>(firstSubParser)), rest(kj::fwd<U>(rest)...) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nexplicit constexpr Sequence_(T&& firstSubParser, U&&... rest)\n      : first(kj::fwd<T>(firstSubParser)), rest(kj::fwd<U>(rest)...) {}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParsers>",
          "args": [
            "subParsers"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Sequence_<SubParsers...> sequence(SubParsers&&... subParsers) {\n  // Constructs a parser that executes each of the parameter parsers in sequence and returns a\n  // tuple of their results.\n\n  return Sequence_<SubParsers...>(kj::fwd<SubParsers>(subParsers)...);\n}"
  },
  {
    "function_name": "parseNext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "337-340",
    "snippet": "auto parseNext(Input& input, Params&&... params) const ->\n      Maybe<decltype(tuple(kj::fwd<Params>(params)...))> {\n    return tuple(kj::fwd<Params>(params)...);\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tuple",
          "args": [
            "kj::fwd<Params>(params)..."
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuple",
          "args": [
            "kj::fwd<Params>(params)..."
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nauto parseNext(Input& input, Params&&... params) const ->\n      Maybe<decltype(tuple(kj::fwd<Params>(params)...))> {\n    return tuple(kj::fwd<Params>(params)...);\n  }"
  },
  {
    "function_name": "parseNext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "310-321",
    "snippet": "auto parseNext(Input& input, InitialParams&&... initialParams) const ->\n      Maybe<decltype(tuple(\n          kj::fwd<InitialParams>(initialParams)...,\n          instance<OutputType<FirstSubParser, Input>>(),\n          instance<OutputType<SubParsers, Input>>()...))> {\n    KJ_IF_MAYBE(firstResult, first(input)) {\n      return rest.parseNext(input, kj::fwd<InitialParams>(initialParams)...,\n                            kj::mv(*firstResult));\n    } else {\n      return nullptr;\n    }\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rest.parseNext",
          "args": [
            "input",
            "kj::fwd<InitialParams>(initialParams)...",
            "kj::mv(*firstResult)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*firstResult"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<InitialParams>",
          "args": [
            "initialParams"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuple",
          "args": [
            "kj::fwd<InitialParams>(initialParams)...",
            "instance<OutputType<FirstSubParser, Input>>()",
            "instance<OutputType<SubParsers, Input>>()..."
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance<OutputType<SubParsers, Input>>",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instance<OutputType<FirstSubParser, Input>>",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<InitialParams>",
          "args": [
            "initialParams"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nauto parseNext(Input& input, InitialParams&&... initialParams) const ->\n      Maybe<decltype(tuple(\n          kj::fwd<InitialParams>(initialParams)...,\n          instance<OutputType<FirstSubParser, Input>>(),\n          instance<OutputType<SubParsers, Input>>()...))> {\n    KJ_IF_MAYBE(firstResult, first(input)) {\n      return rest.parseNext(input, kj::fwd<InitialParams>(initialParams)...,\n                            kj::mv(*firstResult));\n    } else {\n      return nullptr;\n    }\n  }"
  },
  {
    "function_name": "Sequence_",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "298-299",
    "snippet": "explicit constexpr Sequence_(T&& firstSubParser, U&&... rest)\n      : first(kj::fwd<T>(firstSubParser)), rest(kj::fwd<U>(rest)...) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<U>",
          "args": [
            "rest"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<T>",
          "args": [
            "firstSubParser"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nexplicit constexpr Sequence_(T&& firstSubParser, U&&... rest)\n      : first(kj::fwd<T>(firstSubParser)), rest(kj::fwd<U>(rest)...) {}"
  },
  {
    "function_name": "discard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "283-286",
    "snippet": "constexpr ConstResult_<SubParser, Tuple<>> discard(SubParser&& subParser) {\n  // Constructs a parser which wraps `subParser` but discards the result.\n  return constResult(kj::fwd<SubParser>(subParser), Tuple<>());\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "constResult",
          "args": [
            "kj::fwd<SubParser>(subParser)",
            "Tuple<>()"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "constResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "277-280",
          "snippet": "constexpr ConstResult_<SubParser, Result> constResult(SubParser&& subParser, Result&& result) {\n  // Constructs a parser which returns exactly `result` if `subParser` is successful.\n  return ConstResult_<SubParser, Result>(kj::fwd<SubParser>(subParser), kj::fwd<Result>(result));\n}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr ConstResult_<SubParser, Result> constResult(SubParser&& subParser, Result&& result) {\n  // Constructs a parser which returns exactly `result` if `subParser` is successful.\n  return ConstResult_<SubParser, Result>(kj::fwd<SubParser>(subParser), kj::fwd<Result>(result));\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tuple<>",
          "args": [],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "Expression::Builder::disownTuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3648-3653",
          "snippet": "inline ::capnp::Orphan< ::capnp::List< ::capnp::compiler::Expression::Param>> Expression::Builder::disownTuple() {\n  KJ_IREQUIRE(which() == Expression::TUPLE,\n              \"Must check which() before get()ing a union member.\");\n  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::compiler::Expression::Param>>::disown(\n      _builder.getPointerField(0 * ::capnp::POINTERS));\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::capnp::Orphan< ::capnp::List< ::capnp::compiler::Expression::Param>> Expression::Builder::disownTuple() {\n  KJ_IREQUIRE(which() == Expression::TUPLE,\n              \"Must check which() before get()ing a union member.\");\n  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::compiler::Expression::Param>>::disown(\n      _builder.getPointerField(0 * ::capnp::POINTERS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr ConstResult_<SubParser, Tuple<>> discard(SubParser&& subParser) {\n  // Constructs a parser which wraps `subParser` but discards the result.\n  return constResult(kj::fwd<SubParser>(subParser), Tuple<>());\n}"
  },
  {
    "function_name": "constResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "277-280",
    "snippet": "constexpr ConstResult_<SubParser, Result> constResult(SubParser&& subParser, Result&& result) {\n  // Constructs a parser which returns exactly `result` if `subParser` is successful.\n  return ConstResult_<SubParser, Result>(kj::fwd<SubParser>(subParser), kj::fwd<Result>(result));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ConstResult_<SubParser, Result>",
          "args": [
            "kj::fwd<SubParser>(subParser)",
            "kj::fwd<Result>(result)"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ConstResult_",
          "container": "ConstResult_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "259-260",
          "snippet": "explicit constexpr ConstResult_(SubParser&& subParser, Result&& result)\n      : subParser(kj::fwd<SubParser>(subParser)), result(kj::fwd<Result>(result)) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nConstResult_ {\n  explicit constexpr ConstResult_(SubParser&& subParser, Result&& result)\n        : subParser(kj::fwd<SubParser>(subParser)), result(kj::fwd<Result>(result)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<Result>",
          "args": [
            "result"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr ConstResult_<SubParser, Result> constResult(SubParser&& subParser, Result&& result) {\n  // Constructs a parser which returns exactly `result` if `subParser` is successful.\n  return ConstResult_<SubParser, Result>(kj::fwd<SubParser>(subParser), kj::fwd<Result>(result));\n}"
  },
  {
    "function_name": "ConstResult_",
    "container": "ConstResult_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "259-260",
    "snippet": "explicit constexpr ConstResult_(SubParser&& subParser, Result&& result)\n      : subParser(kj::fwd<SubParser>(subParser)), result(kj::fwd<Result>(result)) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<Result>",
          "args": [
            "result"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<SubParser>",
          "args": [
            "subParser"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nConstResult_ {\n  explicit constexpr ConstResult_(SubParser&& subParser, Result&& result)\n        : subParser(kj::fwd<SubParser>(subParser)), result(kj::fwd<Result>(result)) {}\n}"
  },
  {
    "function_name": "exactlyConst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "245-251",
    "snippet": "constexpr ExactlyConst_<T, expected> exactlyConst() {\n  // Constructs a parser which succeeds when the input is exactly the token specified.  The\n  // result is always the empty tuple.  This parser is templated on the token value which may cause\n  // it to perform better -- or worse.  Be sure to measure.\n\n  return ExactlyConst_<T, expected>();\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExactlyConst_<T, expected>",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ExactlyConst_",
          "container": "ExactlyConst_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "231-231",
          "snippet": "explicit constexpr ExactlyConst_() {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nExactlyConst_ {\n  explicit constexpr ExactlyConst_() {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr ExactlyConst_<T, expected> exactlyConst() {\n  // Constructs a parser which succeeds when the input is exactly the token specified.  The\n  // result is always the empty tuple.  This parser is templated on the token value which may cause\n  // it to perform better -- or worse.  Be sure to measure.\n\n  return ExactlyConst_<T, expected>();\n}"
  },
  {
    "function_name": "ExactlyConst_",
    "container": "ExactlyConst_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "231-231",
    "snippet": "explicit constexpr ExactlyConst_() {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nExactlyConst_ {\n  explicit constexpr ExactlyConst_() {}\n}"
  },
  {
    "function_name": "exactly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "217-222",
    "snippet": "constexpr Exactly_<T> exactly(T&& expected) {\n  // Constructs a parser which succeeds when the input is exactly the token specified.  The\n  // result is always the empty tuple.\n\n  return Exactly_<T>(kj::fwd<T>(expected));\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Exactly_<T>",
          "args": [
            "kj::fwd<T>(expected)"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "Exactly_",
          "container": "Exactly_",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "200-200",
          "snippet": "explicit constexpr Exactly_(T&& expected): expected(expected) {}",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nExactly_ {\n  explicit constexpr Exactly_(T&& expected): expected(expected) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<T>",
          "args": [
            "expected"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr Exactly_<T> exactly(T&& expected) {\n  // Constructs a parser which succeeds when the input is exactly the token specified.  The\n  // result is always the empty tuple.\n\n  return Exactly_<T>(kj::fwd<T>(expected));\n}"
  },
  {
    "function_name": "Exactly_",
    "container": "Exactly_",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "200-200",
    "snippet": "explicit constexpr Exactly_(T&& expected): expected(expected) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nExactly_ {\n  explicit constexpr Exactly_(T&& expected): expected(expected) {}\n}"
  },
  {
    "function_name": "ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "167-172",
    "snippet": "constexpr ParserRef<Input, OutputType<ParserImpl, Input>> ref(ParserImpl& impl) {\n  // Constructs a ParserRef.  You must specify the input type explicitly, e.g.\n  // `ref<MyInput>(myParser)`.\n\n  return ParserRef<Input, OutputType<ParserImpl, Input>>(impl);\n}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ParserRef<Input, OutputType<ParserImpl, Input>>",
          "args": [
            "impl"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nconstexpr ParserRef<Input, OutputType<ParserImpl, Input>> ref(ParserImpl& impl) {\n  // Constructs a ParserRef.  You must specify the input type explicitly, e.g.\n  // `ref<MyInput>(myParser)`.\n\n  return ParserRef<Input, OutputType<ParserImpl, Input>>(impl);\n}"
  },
  {
    "function_name": "parse",
    "container": "ParserRef::WrapperImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "148-150",
    "snippet": "Maybe<Output> parse(const void* parser, Input& input) const override {\n      return (*reinterpret_cast<const ParserImpl*>(parser))(input);\n    }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "input"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const ParserImpl*>",
          "args": [
            "parser"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nParserRef {\n  WrapperImpl {\n    Maybe<Output> parse(const void* parser, Input& input) const override {\n          return (*reinterpret_cast<const ParserImpl*>(parser))(input);\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "ParserRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "136-140",
    "snippet": "KJ_ALWAYS_INLINE(Maybe<Output> operator()(Input& input) const) {\n    // Always inline in the hopes that this allows branch prediction to kick in so the virtual call\n    // doesn't hurt so much.\n    return wrapper->parse(parser, input);\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wrapper->parse",
          "args": [
            "parser",
            "input"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "ParserRef::WrapperImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "148-150",
          "snippet": "Maybe<Output> parse(const void* parser, Input& input) const override {\n      return (*reinterpret_cast<const ParserImpl*>(parser))(input);\n    }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nParserRef {\n  WrapperImpl {\n    Maybe<Output> parse(const void* parser, Input& input) const override {\n          return (*reinterpret_cast<const ParserImpl*>(parser))(input);\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nParserRef {\n  KJ_ALWAYS_INLINE(Maybe<Output> operator()(Input& input) const) {\n      // Always inline in the hopes that this allows branch prediction to kick in so the virtual call\n      // doesn't hurt so much.\n      return wrapper->parse(parser, input);\n    }\n}"
  },
  {
    "function_name": "ParserRef",
    "container": "ParserRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "123-126",
    "snippet": "constexpr ParserRef(Other&& other)\n      : parser(&other), wrapper(&WrapperImplInstance<Decay<Other>>::instance) {\n    static_assert(kj::isReference<Other>(), \"ParseRef should not be assigned to a temporary.\");\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::isReference<Other>",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "isReference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "390-390",
          "snippet": "constexpr bool isReference() { return IsReference_<T>::value; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr bool isReference() { return IsReference_<T>::value; }"
        }
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nParserRef {\n  constexpr ParserRef(Other&& other)\n        : parser(&other), wrapper(&WrapperImplInstance<Decay<Other>>::instance) {\n      static_assert(kj::isReference<Other>(), \"ParseRef should not be assigned to a temporary.\");\n    }\n}"
  },
  {
    "function_name": "ParserRef",
    "container": "ParserRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "116-116",
    "snippet": "ParserRef(): parser(nullptr), wrapper(nullptr) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nParserRef {\n  ParserRef(): parser(nullptr), wrapper(nullptr) {}\n}"
  },
  {
    "function_name": "getPosition",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "91-91",
    "snippet": "Iterator getPosition() { return pos; }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  Iterator getPosition() { return pos; }\n}"
  },
  {
    "function_name": "getBest",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "89-89",
    "snippet": "Iterator getBest() { return kj::max(pos, best); }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "pos",
            "best"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  Iterator getBest() { return kj::max(pos, best); }\n}"
  },
  {
    "function_name": "next",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "84-87",
    "snippet": "void next() {\n    KJ_IREQUIRE(!atEnd());\n    ++pos;\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "!atEnd()"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atEnd",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "atEnd",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "75-75",
          "snippet": "bool atEnd() { return pos == end; }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  bool atEnd() { return pos == end; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  void next() {\n      KJ_IREQUIRE(!atEnd());\n      ++pos;\n    }\n}"
  },
  {
    "function_name": "consume",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "80-83",
    "snippet": "auto consume() -> decltype(*instance<Iterator>()) {\n    KJ_IREQUIRE(!atEnd());\n    return *pos++;\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "!atEnd()"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atEnd",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "atEnd",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "75-75",
          "snippet": "bool atEnd() { return pos == end; }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  bool atEnd() { return pos == end; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance<Iterator>",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  auto consume() -> decltype(*instance<Iterator>()) {\n      KJ_IREQUIRE(!atEnd());\n      return *pos++;\n    }\n}"
  },
  {
    "function_name": "current",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "76-79",
    "snippet": "auto current() -> decltype(*instance<Iterator>()) {\n    KJ_IREQUIRE(!atEnd());\n    return *pos;\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "!atEnd()"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atEnd",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "atEnd",
          "container": "IteratorInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
          "lines": "75-75",
          "snippet": "bool atEnd() { return pos == end; }",
          "includes": [
            "#include \"../vector.h\"",
            "#include \"../tuple.h\"",
            "#include \"../array.h\"",
            "#include \"../memory.h\"",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  bool atEnd() { return pos == end; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance<Iterator>",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  auto current() -> decltype(*instance<Iterator>()) {\n      KJ_IREQUIRE(!atEnd());\n      return *pos;\n    }\n}"
  },
  {
    "function_name": "atEnd",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "75-75",
    "snippet": "bool atEnd() { return pos == end; }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  bool atEnd() { return pos == end; }\n}"
  },
  {
    "function_name": "forgetParent",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "71-73",
    "snippet": "void forgetParent() {\n    parent = nullptr;\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  void forgetParent() {\n      parent = nullptr;\n    }\n}"
  },
  {
    "function_name": "advanceParent",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "68-70",
    "snippet": "void advanceParent() {\n    parent->pos = pos;\n  }",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  void advanceParent() {\n      parent->pos = pos;\n    }\n}"
  },
  {
    "function_name": "IteratorInput",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "59-60",
    "snippet": "explicit IteratorInput(IteratorInput& parent)\n      : parent(&parent), pos(parent.pos), end(parent.end), best(parent.pos) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  explicit IteratorInput(IteratorInput& parent)\n        : parent(&parent), pos(parent.pos), end(parent.end), best(parent.pos) {}\n}"
  },
  {
    "function_name": "IteratorInput",
    "container": "IteratorInput",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/parse/common.h",
    "lines": "57-58",
    "snippet": "IteratorInput(Iterator begin, Iterator end)\n      : parent(nullptr), pos(begin), end(end), best(begin) {}",
    "includes": [
      "#include \"../vector.h\"",
      "#include \"../tuple.h\"",
      "#include \"../array.h\"",
      "#include \"../memory.h\"",
      "#include \"../common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"../vector.h\"\n#include \"../tuple.h\"\n#include \"../array.h\"\n#include \"../memory.h\"\n#include \"../common.h\"\n\nIteratorInput {\n  IteratorInput(Iterator begin, Iterator end)\n        : parent(nullptr), pos(begin), end(end), best(begin) {}\n}"
  }
]