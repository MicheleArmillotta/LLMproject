[
  {
    "function_name": "TwoPartyVatNetwork::shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "136-142",
    "snippet": "kj::Promise<void> TwoPartyVatNetwork::shutdown() {\n  kj::Promise<void> result = KJ_ASSERT_NONNULL(previousWrite, \"already shut down\").then([this]() {\n    stream.shutdownWrite();\n  });\n  previousWrite = nullptr;\n  return kj::mv(result);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "[this]() {\n    stream.shutdownWrite();\n  }"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stream.shutdownWrite",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "previousWrite",
            "\"already shut down\""
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::Promise<void> TwoPartyVatNetwork::shutdown() {\n  kj::Promise<void> result = KJ_ASSERT_NONNULL(previousWrite, \"already shut down\").then([this]() {\n    stream.shutdownWrite();\n  });\n  previousWrite = nullptr;\n  return kj::mv(result);\n}"
  },
  {
    "function_name": "TwoPartyVatNetwork::receiveIncomingMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "122-134",
    "snippet": "kj::Promise<kj::Maybe<kj::Own<IncomingRpcMessage>>> TwoPartyVatNetwork::receiveIncomingMessage() {\n  return kj::evalLater([&]() {\n    return tryReadMessage(stream, receiveOptions)\n        .then([&](kj::Maybe<kj::Own<MessageReader>>&& message)\n              -> kj::Maybe<kj::Own<IncomingRpcMessage>> {\n      KJ_IF_MAYBE(m, message) {\n        return kj::Own<IncomingRpcMessage>(kj::heap<IncomingMessageImpl>(kj::mv(*m)));\n      } else {\n        return nullptr;\n      }\n    });\n  });\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "[&]() {\n    return tryReadMessage(stream, receiveOptions)\n        .then([&](kj::Maybe<kj::Own<MessageReader>>&& message)\n              -> kj::Maybe<kj::Own<IncomingRpcMessage>> {\n      KJ_IF_MAYBE(m, message) {\n        return kj::Own<IncomingRpcMessage>(kj::heap<IncomingMessageImpl>(kj::mv(*m)));\n      } else {\n        return nullptr;\n      }\n    });\n  }"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "tryReadMessage",
          "args": [
            "[&](kj::Maybe<kj::Own<MessageReader>>&& message)\n              -> kj::Maybe<kj::Own<IncomingRpcMessage>> {\n      KJ_IF_MAYBE(m, message) {\n        return kj::Own<IncomingRpcMessage>(kj::heap<IncomingMessageImpl>(kj::mv(*m)));\n      } else {\n        return nullptr;\n      }\n    }"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Own<IncomingRpcMessage>",
          "args": [
            "kj::heap<IncomingMessageImpl>(kj::mv(*m))"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "Own",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "181-181",
          "snippet": "inline explicit Own(decltype(nullptr)): disposer(nullptr), ptr(nullptr) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline explicit Own(decltype(nullptr)): disposer(nullptr), ptr(nullptr) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<IncomingMessageImpl>",
          "args": [
            "kj::mv(*m)"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*m"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryReadMessage",
          "args": [
            "stream",
            "receiveOptions"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::Promise<kj::Maybe<kj::Own<IncomingRpcMessage>>> TwoPartyVatNetwork::receiveIncomingMessage() {\n  return kj::evalLater([&]() {\n    return tryReadMessage(stream, receiveOptions)\n        .then([&](kj::Maybe<kj::Own<MessageReader>>&& message)\n              -> kj::Maybe<kj::Own<IncomingRpcMessage>> {\n      KJ_IF_MAYBE(m, message) {\n        return kj::Own<IncomingRpcMessage>(kj::heap<IncomingMessageImpl>(kj::mv(*m)));\n      } else {\n        return nullptr;\n      }\n    });\n  });\n}"
  },
  {
    "function_name": "TwoPartyVatNetwork::newOutgoingMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "118-120",
    "snippet": "kj::Own<OutgoingRpcMessage> TwoPartyVatNetwork::newOutgoingMessage(uint firstSegmentWordSize) {\n  return kj::refcounted<OutgoingMessageImpl>(*this, firstSegmentWordSize);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<OutgoingMessageImpl>",
          "args": [
            "*this",
            "firstSegmentWordSize"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::Own<OutgoingRpcMessage> TwoPartyVatNetwork::newOutgoingMessage(uint firstSegmentWordSize) {\n  return kj::refcounted<OutgoingMessageImpl>(*this, firstSegmentWordSize);\n}"
  },
  {
    "function_name": "initCapTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "110-112",
    "snippet": "void initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>>&& capTable) override {\n    message->initCapTable(kj::mv(capTable));\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "capTable"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>>&& capTable) override {\n    message->initCapTable(kj::mv(capTable));\n  }"
  },
  {
    "function_name": "getBody",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "106-108",
    "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message->getRoot<AnyPointer>",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
  },
  {
    "function_name": "IncomingMessageImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "104-104",
    "snippet": "IncomingMessageImpl(kj::Own<MessageReader> message): message(kj::mv(message)) {}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nIncomingMessageImpl(kj::Own<MessageReader> message): message(kj::mv(message)) {}"
  },
  {
    "function_name": "send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "83-95",
    "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "nullptr"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "kj::addRef(*this)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "[&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeMessage",
          "args": [
            "network.stream",
            "message"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "writeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.h",
          "lines": "58-60",
          "snippet": "inline kj::Promise<void> writeMessage(kj::AsyncOutputStream& output, MessageBuilder& builder) {\n  return writeMessage(output, builder.getSegmentsForOutput());\n}",
          "includes": [
            "#include \"message.h\"",
            "#include <kj/async-io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"message.h\"\n#include <kj/async-io.h>\n\ninline kj::Promise<void> writeMessage(kj::AsyncOutputStream& output, MessageBuilder& builder) {\n  return writeMessage(output, builder.getSegmentsForOutput());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "network.previousWrite",
            "\"already shut down\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
  },
  {
    "function_name": "getCapTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "79-81",
    "snippet": "kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() override {\n    return message.getCapTable();\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() override {\n    return message.getCapTable();\n  }"
  },
  {
    "function_name": "getBody",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "75-77",
    "snippet": "AnyPointer::Builder getBody() override {\n    return message.getRoot<AnyPointer>();\n  }",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message.getRoot<AnyPointer>",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Builder getBody() override {\n    return message.getRoot<AnyPointer>();\n  }"
  },
  {
    "function_name": "OutgoingMessageImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "71-73",
    "snippet": "OutgoingMessageImpl(TwoPartyVatNetwork& network, uint firstSegmentWordSize)\n      : network(network),\n        message(firstSegmentWordSize == 0 ? SUGGESTED_FIRST_SEGMENT_WORDS : firstSegmentWordSize) {}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nOutgoingMessageImpl(TwoPartyVatNetwork& network, uint firstSegmentWordSize)\n      : network(network),\n        message(firstSegmentWordSize == 0 ? SUGGESTED_FIRST_SEGMENT_WORDS : firstSegmentWordSize) {}"
  },
  {
    "function_name": "TwoPartyVatNetwork::accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "56-66",
    "snippet": "kj::Promise<kj::Own<TwoPartyVatNetworkBase::Connection>> TwoPartyVatNetwork::accept() {\n  if (side == rpc::twoparty::Side::SERVER && !accepted) {\n    accepted = true;\n    return asConnection();\n  } else {\n    // Create a promise that will never be fulfilled.\n    auto paf = kj::newPromiseAndFulfiller<kj::Own<TwoPartyVatNetworkBase::Connection>>();\n    acceptFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<kj::Own<TwoPartyVatNetworkBase::Connection>>",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asConnection",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "TwoPartyVatNetwork::asConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "42-45",
          "snippet": "kj::Own<TwoPartyVatNetworkBase::Connection> TwoPartyVatNetwork::asConnection() {\n  ++disconnectFulfiller.refcount;\n  return kj::Own<TwoPartyVatNetworkBase::Connection>(this, disconnectFulfiller);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::Own<TwoPartyVatNetworkBase::Connection> TwoPartyVatNetwork::asConnection() {\n  ++disconnectFulfiller.refcount;\n  return kj::Own<TwoPartyVatNetworkBase::Connection>(this, disconnectFulfiller);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::Promise<kj::Own<TwoPartyVatNetworkBase::Connection>> TwoPartyVatNetwork::accept() {\n  if (side == rpc::twoparty::Side::SERVER && !accepted) {\n    accepted = true;\n    return asConnection();\n  } else {\n    // Create a promise that will never be fulfilled.\n    auto paf = kj::newPromiseAndFulfiller<kj::Own<TwoPartyVatNetworkBase::Connection>>();\n    acceptFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }\n}"
  },
  {
    "function_name": "TwoPartyVatNetwork::connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "47-54",
    "snippet": "kj::Maybe<kj::Own<TwoPartyVatNetworkBase::Connection>> TwoPartyVatNetwork::connect(\n    rpc::twoparty::VatId::Reader ref) {\n  if (ref.getSide() == side) {\n    return nullptr;\n  } else {\n    return asConnection();\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asConnection",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "TwoPartyVatNetwork::asConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "42-45",
          "snippet": "kj::Own<TwoPartyVatNetworkBase::Connection> TwoPartyVatNetwork::asConnection() {\n  ++disconnectFulfiller.refcount;\n  return kj::Own<TwoPartyVatNetworkBase::Connection>(this, disconnectFulfiller);\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::Own<TwoPartyVatNetworkBase::Connection> TwoPartyVatNetwork::asConnection() {\n  ++disconnectFulfiller.refcount;\n  return kj::Own<TwoPartyVatNetworkBase::Connection>(this, disconnectFulfiller);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref.getSide",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::Maybe<kj::Own<TwoPartyVatNetworkBase::Connection>> TwoPartyVatNetwork::connect(\n    rpc::twoparty::VatId::Reader ref) {\n  if (ref.getSide() == side) {\n    return nullptr;\n  } else {\n    return asConnection();\n  }\n}"
  },
  {
    "function_name": "TwoPartyVatNetwork::asConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "42-45",
    "snippet": "kj::Own<TwoPartyVatNetworkBase::Connection> TwoPartyVatNetwork::asConnection() {\n  ++disconnectFulfiller.refcount;\n  return kj::Own<TwoPartyVatNetworkBase::Connection>(this, disconnectFulfiller);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::Own<TwoPartyVatNetworkBase::Connection>",
          "args": [
            "this",
            "disconnectFulfiller"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "Own",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "128-128",
          "snippet": "inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nkj::Own<TwoPartyVatNetworkBase::Connection> TwoPartyVatNetwork::asConnection() {\n  ++disconnectFulfiller.refcount;\n  return kj::Own<TwoPartyVatNetworkBase::Connection>(this, disconnectFulfiller);\n}"
  },
  {
    "function_name": "TwoPartyVatNetwork::FulfillerDisposer::disposeImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "36-40",
    "snippet": "void TwoPartyVatNetwork::FulfillerDisposer::disposeImpl(void* pointer) const {\n  if (--refcount == 0) {\n    fulfiller->fulfill();\n  }\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fulfiller->fulfill",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "68-72",
          "snippet": "void fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid TwoPartyVatNetwork::FulfillerDisposer::disposeImpl(void* pointer) const {\n  if (--refcount == 0) {\n    fulfiller->fulfill();\n  }\n}"
  },
  {
    "function_name": "TwoPartyVatNetwork::TwoPartyVatNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
    "lines": "28-34",
    "snippet": "TwoPartyVatNetwork::TwoPartyVatNetwork(kj::AsyncIoStream& stream, rpc::twoparty::Side side,\n                                       ReaderOptions receiveOptions)\n    : stream(stream), side(side), receiveOptions(receiveOptions), previousWrite(kj::READY_NOW) {\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  disconnectPromise = paf.promise.fork();\n  disconnectFulfiller.fulfiller = kj::mv(paf.fulfiller);\n}",
    "includes": [
      "#include <kj/debug.h>",
      "#include \"serialize-async.h\"",
      "#include \"rpc-twoparty.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.fork",
          "args": [],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nTwoPartyVatNetwork::TwoPartyVatNetwork(kj::AsyncIoStream& stream, rpc::twoparty::Side side,\n                                       ReaderOptions receiveOptions)\n    : stream(stream), side(side), receiveOptions(receiveOptions), previousWrite(kj::READY_NOW) {\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  disconnectPromise = paf.promise.fork();\n  disconnectFulfiller.fulfiller = kj::mv(paf.fulfiller);\n}"
  }
]