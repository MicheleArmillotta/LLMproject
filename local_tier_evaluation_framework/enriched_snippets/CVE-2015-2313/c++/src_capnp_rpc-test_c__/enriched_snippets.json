[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1109-1123",
    "snippet": "TEST(Rpc, RealmGatewayExport) {\n  TestRealmGateway::Client gateway = kj::heap<TestGateway>();\n  Persistent<test::TestSturdyRef>::Client bootstrap = kj::heap<TestPersistent>(\"foo\");\n\n  MallocMessageBuilder hostIdBuilder;\n  auto hostId = hostIdBuilder.getRoot<test::TestSturdyRefHostId>();\n  hostId.setHost(\"server\");\n\n  TestContext context(bootstrap, gateway, true);\n  auto client = context.rpcClient.bootstrap(hostId).castAs<Persistent<Text>>();\n\n  auto response = client.saveRequest().send().wait(context.waitScope);\n\n  EXPECT_EQ(\"exported-foo\", response.getSturdyRef());\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"exported-foo\"",
            "response.getSturdyRef()"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getSturdyRef",
          "args": [],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.saveRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.saveRequest",
          "args": [],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.saveRequest",
          "args": [],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.rpcClient.bootstrap",
          "args": [],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.rpcClient.bootstrap",
          "args": [
            "hostId"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "bootstrap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2620-2624",
          "snippet": "Capability::Client bootstrap(_::StructReader vatId) {\n    // For now we delegate to restore() since it's equivalent, but eventually we'll remove restore()\n    // and implement bootstrap() directly.\n    return restore(vatId, AnyPointer::Reader());\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nCapability::Client bootstrap(_::StructReader vatId) {\n    // For now we delegate to restore() since it's equivalent, but eventually we'll remove restore()\n    // and implement bootstrap() directly.\n    return restore(vatId, AnyPointer::Reader());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "hostId.setHost",
          "args": [
            "\"server\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIdBuilder.getRoot<test::TestSturdyRefHostId>",
          "args": [],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<TestPersistent>",
          "args": [
            "\"foo\""
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, RealmGatewayExport) {\n  TestRealmGateway::Client gateway = kj::heap<TestGateway>();\n  Persistent<test::TestSturdyRef>::Client bootstrap = kj::heap<TestPersistent>(\"foo\");\n\n  MallocMessageBuilder hostIdBuilder;\n  auto hostId = hostIdBuilder.getRoot<test::TestSturdyRefHostId>();\n  hostId.setHost(\"server\");\n\n  TestContext context(bootstrap, gateway, true);\n  auto client = context.rpcClient.bootstrap(hostId).castAs<Persistent<Text>>();\n\n  auto response = client.saveRequest().send().wait(context.waitScope);\n\n  EXPECT_EQ(\"exported-foo\", response.getSturdyRef());\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1093-1107",
    "snippet": "TEST(Rpc, RealmGatewayImport) {\n  TestRealmGateway::Client gateway = kj::heap<TestGateway>();\n  Persistent<Text>::Client bootstrap = kj::heap<TestPersistentText>(\"foo\");\n\n  MallocMessageBuilder hostIdBuilder;\n  auto hostId = hostIdBuilder.getRoot<test::TestSturdyRefHostId>();\n  hostId.setHost(\"server\");\n\n  TestContext context(bootstrap, gateway);\n  auto client = context.rpcClient.bootstrap(hostId).castAs<Persistent<test::TestSturdyRef>>();\n\n  auto response = client.saveRequest().send().wait(context.waitScope);\n\n  EXPECT_EQ(\"imported-foo\", response.getSturdyRef().getObjectId().getAs<Text>());\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"imported-foo\"",
            "response.getSturdyRef().getObjectId().getAs<Text>()"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getSturdyRef",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getSturdyRef",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getSturdyRef",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.saveRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.saveRequest",
          "args": [],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.saveRequest",
          "args": [],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.rpcClient.bootstrap",
          "args": [],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.rpcClient.bootstrap",
          "args": [
            "hostId"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "bootstrap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2620-2624",
          "snippet": "Capability::Client bootstrap(_::StructReader vatId) {\n    // For now we delegate to restore() since it's equivalent, but eventually we'll remove restore()\n    // and implement bootstrap() directly.\n    return restore(vatId, AnyPointer::Reader());\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nCapability::Client bootstrap(_::StructReader vatId) {\n    // For now we delegate to restore() since it's equivalent, but eventually we'll remove restore()\n    // and implement bootstrap() directly.\n    return restore(vatId, AnyPointer::Reader());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "hostId.setHost",
          "args": [
            "\"server\""
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIdBuilder.getRoot<test::TestSturdyRefHostId>",
          "args": [],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<TestPersistentText>",
          "args": [
            "\"foo\""
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, RealmGatewayImport) {\n  TestRealmGateway::Client gateway = kj::heap<TestGateway>();\n  Persistent<Text>::Client bootstrap = kj::heap<TestPersistentText>(\"foo\");\n\n  MallocMessageBuilder hostIdBuilder;\n  auto hostId = hostIdBuilder.getRoot<test::TestSturdyRefHostId>();\n  hostId.setHost(\"server\");\n\n  TestContext context(bootstrap, gateway);\n  auto client = context.rpcClient.bootstrap(hostId).castAs<Persistent<test::TestSturdyRef>>();\n\n  auto response = client.saveRequest().send().wait(context.waitScope);\n\n  EXPECT_EQ(\"imported-foo\", response.getSturdyRef().getObjectId().getAs<Text>());\n}"
  },
  {
    "function_name": "save",
    "container": "TestPersistentText",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1084-1087",
    "snippet": "kj::Promise<void> save(SaveContext context) override {\n    context.initResults().setSturdyRef(name);\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [
            "name"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestPersistentText {\n  kj::Promise<void> save(SaveContext context) override {\n      context.initResults().setSturdyRef(name);\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "TestPersistentText",
    "container": "TestPersistentText",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1082-1082",
    "snippet": "TestPersistentText(kj::StringPtr name): name(name) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestPersistentText {\n  TestPersistentText(kj::StringPtr name): name(name) {}\n}"
  },
  {
    "function_name": "save",
    "container": "TestPersistent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1071-1074",
    "snippet": "kj::Promise<void> save(SaveContext context) override {\n    context.initResults().initSturdyRef().getObjectId().setAs<Text>(name);\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [
            "name"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.initResults",
          "args": [],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestPersistent {\n  kj::Promise<void> save(SaveContext context) override {\n      context.initResults().initSturdyRef().getObjectId().setAs<Text>(name);\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "TestPersistent",
    "container": "TestPersistent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1069-1069",
    "snippet": "TestPersistent(kj::StringPtr name): name(name) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestPersistent {\n  TestPersistent(kj::StringPtr name): name(name) {}\n}"
  },
  {
    "function_name": "export_",
    "container": "TestGateway",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1056-1064",
    "snippet": "kj::Promise<void> export_(ExportContext context) override {\n    auto cap = context.getParams().getCap();\n    context.releaseParams();\n    return cap.saveRequest().send()\n        .then([context](Response<Persistent<test::TestSturdyRef>::SaveResults> response) mutable {\n      context.getResults().setSturdyRef(kj::str(\"exported-\",\n          response.getSturdyRef().getObjectId().getAs<Text>()));\n    });\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [
            "[context](Response<Persistent<test::TestSturdyRef>::SaveResults> response) mutable {\n      context.getResults().setSturdyRef(kj::str(\"exported-\",\n          response.getSturdyRef().getObjectId().getAs<Text>()));\n    }"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::str(\"exported-\",\n          response.getSturdyRef().getObjectId().getAs<Text>())"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"exported-\"",
            "response.getSturdyRef().getObjectId().getAs<Text>()"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getSturdyRef",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getSturdyRef",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getSturdyRef",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestGateway {\n  kj::Promise<void> export_(ExportContext context) override {\n      auto cap = context.getParams().getCap();\n      context.releaseParams();\n      return cap.saveRequest().send()\n          .then([context](Response<Persistent<test::TestSturdyRef>::SaveResults> response) mutable {\n        context.getResults().setSturdyRef(kj::str(\"exported-\",\n            response.getSturdyRef().getObjectId().getAs<Text>()));\n      });\n    }\n}"
  },
  {
    "function_name": "import",
    "container": "TestGateway",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1046-1054",
    "snippet": "kj::Promise<void> import(ImportContext context) override {\n    auto cap = context.getParams().getCap();\n    context.releaseParams();\n    return cap.saveRequest().send()\n        .then([context](Response<Persistent<Text>::SaveResults> response) mutable {\n      context.getResults().initSturdyRef().getObjectId().setAs<Text>(\n          kj::str(\"imported-\", response.getSturdyRef()));\n    });\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [
            "[context](Response<Persistent<Text>::SaveResults> response) mutable {\n      context.getResults().initSturdyRef().getObjectId().setAs<Text>(\n          kj::str(\"imported-\", response.getSturdyRef()));\n    }"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::str(\"imported-\", response.getSturdyRef())"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"imported-\"",
            "response.getSturdyRef()"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getSturdyRef",
          "args": [],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.saveRequest",
          "args": [],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.releaseParams",
          "args": [],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestGateway {\n  kj::Promise<void> import(ImportContext context) override {\n      auto cap = context.getParams().getCap();\n      context.releaseParams();\n      return cap.saveRequest().send()\n          .then([context](Response<Persistent<Text>::SaveResults> response) mutable {\n        context.getResults().initSturdyRef().getObjectId().setAs<Text>(\n            kj::str(\"imported-\", response.getSturdyRef()));\n      });\n    }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "1014-1038",
    "snippet": "TEST(Rpc, Abort) {\n  // Verify that aborts are received.\n\n  TestContext context;\n\n  MallocMessageBuilder refMessage(128);\n  auto hostId = refMessage.initRoot<test::TestSturdyRefHostId>();\n  hostId.setHost(\"server\");\n\n  auto conn = KJ_ASSERT_NONNULL(context.clientNetwork.connect(hostId));\n\n  {\n    // Send an invalid message (Return to non-existent question).\n    auto msg = conn->newOutgoingMessage(128);\n    auto body = msg->getBody().initAs<rpc::Message>().initReturn();\n    body.setAnswerId(1234);\n    body.setCanceled();\n    msg->send();\n  }\n\n  auto reply = KJ_ASSERT_NONNULL(conn->receiveIncomingMessage().wait(context.waitScope));\n  EXPECT_EQ(rpc::Message::ABORT, reply->getBody().getAs<rpc::Message>().which());\n\n  EXPECT_TRUE(conn->receiveIncomingMessage().wait(context.waitScope) == nullptr);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "conn->receiveIncomingMessage().wait(context.waitScope) == nullptr"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->receiveIncomingMessage",
          "args": [
            "context.waitScope"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->receiveIncomingMessage",
          "args": [],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "rpc::Message::ABORT",
            "reply->getBody().getAs<rpc::Message>().which()"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reply->getBody",
          "args": [],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "262-264",
          "snippet": "AnyPointer::Builder getBody() override {\n        return message.getRoot<AnyPointer>();\n      }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      AnyPointer::Builder getBody() override {\n              return message.getRoot<AnyPointer>();\n            }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "conn->receiveIncomingMessage().wait(context.waitScope)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->receiveIncomingMessage",
          "args": [
            "context.waitScope"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->receiveIncomingMessage",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg->send",
          "args": [],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "body.setCanceled",
          "args": [],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.setAnswerId",
          "args": [
            "1234"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->newOutgoingMessage",
          "args": [
            "128"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "newOutgoingMessage",
          "container": "TestNetworkAdapter::ConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "305-307",
          "snippet": "kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override {\n      return kj::heap<OutgoingRpcMessageImpl>(*this, firstSegmentWordSize);\n    }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override {\n          return kj::heap<OutgoingRpcMessageImpl>(*this, firstSegmentWordSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "context.clientNetwork.connect(hostId)"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.clientNetwork.connect",
          "args": [
            "hostId"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostId.setHost",
          "args": [
            "\"server\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refMessage.initRoot<test::TestSturdyRefHostId>",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, Abort) {\n  // Verify that aborts are received.\n\n  TestContext context;\n\n  MallocMessageBuilder refMessage(128);\n  auto hostId = refMessage.initRoot<test::TestSturdyRefHostId>();\n  hostId.setHost(\"server\");\n\n  auto conn = KJ_ASSERT_NONNULL(context.clientNetwork.connect(hostId));\n\n  {\n    // Send an invalid message (Return to non-existent question).\n    auto msg = conn->newOutgoingMessage(128);\n    auto body = msg->getBody().initAs<rpc::Message>().initReturn();\n    body.setAnswerId(1234);\n    body.setCanceled();\n    msg->send();\n  }\n\n  auto reply = KJ_ASSERT_NONNULL(conn->receiveIncomingMessage().wait(context.waitScope));\n  EXPECT_EQ(rpc::Message::ABORT, reply->getBody().getAs<rpc::Message>().which());\n\n  EXPECT_TRUE(conn->receiveIncomingMessage().wait(context.waitScope) == nullptr);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "961-1012",
    "snippet": "TEST(Rpc, CallBrokenPromise) {\n  // Tell the server to call back to a promise client, then resolve the promise to an error.\n\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n  auto paf = kj::newPromiseAndFulfiller<test::TestInterface::Client>();\n\n  {\n    auto req = client.holdRequest();\n    req.setCap(kj::mv(paf.promise));\n    req.send().wait(context.waitScope);\n  }\n\n  bool returned = false;\n  auto req = client.callHeldRequest().send()\n      .then([&](capnp::Response<test::TestMoreStuff::CallHeldResults>&&) {\n    returned = true;\n  }, [&](kj::Exception&& e) {\n    returned = true;\n    kj::throwRecoverableException(kj::mv(e));\n  }).eagerlyEvaluate(nullptr);\n\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n\n  EXPECT_FALSE(returned);\n\n  paf.fulfiller->rejectIfThrows([]() { KJ_FAIL_ASSERT(\"foo\") { break; } });\n\n  expectPromiseThrows(kj::mv(req), context.waitScope);\n  EXPECT_TRUE(returned);\n\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n\n  // Verify that we're still connected (there were no protocol errors).\n  getCallSequence(client, 1).wait(context.waitScope);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getCallSequence",
          "args": [
            "context.waitScope"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "TestMoreStuffImpl::getCallSequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "991-995",
          "snippet": "kj::Promise<void> TestMoreStuffImpl::getCallSequence(GetCallSequenceContext context) {\n  auto result = context.getResults();\n  result.setN(callCount++);\n  return kj::READY_NOW;\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nkj::Promise<void> TestMoreStuffImpl::getCallSequence(GetCallSequenceContext context) {\n  auto result = context.getResults();\n  result.setN(callCount++);\n  return kj::READY_NOW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getCallSequence",
          "args": [
            "client",
            "1"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "getCallSequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "861-866",
          "snippet": "RemotePromise<test::TestCallOrder::GetCallSequenceResults> getCallSequence(\n    test::TestCallOrder::Client& client, uint expected) {\n  auto req = client.getCallSequenceRequest();\n  req.setExpected(expected);\n  return req.send();\n}",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nRemotePromise<test::TestCallOrder::GetCallSequenceResults> getCallSequence(\n    test::TestCallOrder::Client& client, uint expected) {\n  auto req = client.getCallSequenceRequest();\n  req.setExpected(expected);\n  return req.send();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "context.waitScope"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "returned"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectPromiseThrows",
          "args": [
            "kj::mv(req)",
            "context.waitScope"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "req"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.fulfiller->rejectIfThrows",
          "args": [
            "[]() { KJ_FAIL_ASSERT(\"foo\") { break; } }"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "returned"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callHeldRequest",
          "args": [
            "nullptr"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callHeldRequest",
          "args": [
            "[&](capnp::Response<test::TestMoreStuff::CallHeldResults>&&) {\n    returned = true;\n  }",
            "[&](kj::Exception&& e) {\n    returned = true;\n    kj::throwRecoverableException(kj::mv(e));\n  }"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::throwRecoverableException",
          "args": [
            "kj::mv(e)"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "throwRecoverableException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "353-355",
          "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callHeldRequest",
          "args": [],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callHeldRequest",
          "args": [],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [
            "context.waitScope"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "270-298",
          "snippet": "void send() override {\n        if (connection.networkException != nullptr) {\n          return;\n        }\n\n        ++connection.network.sent;\n\n        // Uncomment to get a debug dump.\n//        kj::String msg = connection.network.network.dumper.dump(\n//            message.getRoot<rpc::Message>(), connection.sender);\n//        KJ_ DBG(msg);\n\n        auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n\n        auto connectionPtr = &connection;\n        connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n            [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n          KJ_IF_MAYBE(p, connectionPtr->partner) {\n            if (p->fulfillers.empty()) {\n              p->messages.push(kj::mv(message));\n            } else {\n              ++p->network.received;\n              p->fulfillers.front()->fulfill(\n                  kj::Own<IncomingRpcMessage>(kj::mv(message)));\n              p->fulfillers.pop();\n            }\n          }\n        })));\n      }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      void send() override {\n              if (connection.networkException != nullptr) {\n                return;\n              }\n      \n              ++connection.network.sent;\n      \n              // Uncomment to get a debug dump.\n      //        kj::String msg = connection.network.network.dumper.dump(\n      //            message.getRoot<rpc::Message>(), connection.sender);\n      //        KJ_ DBG(msg);\n      \n              auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n      \n              auto connectionPtr = &connection;\n              connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n                  [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n                KJ_IF_MAYBE(p, connectionPtr->partner) {\n                  if (p->fulfillers.empty()) {\n                    p->messages.push(kj::mv(message));\n                  } else {\n                    ++p->network.received;\n                    p->fulfillers.front()->fulfill(\n                        kj::Own<IncomingRpcMessage>(kj::mv(message)));\n                    p->fulfillers.pop();\n                  }\n                }\n              })));\n            }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "req.setCap",
          "args": [
            "kj::mv(paf.promise)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.holdRequest",
          "args": [],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<test::TestInterface::Client>",
          "args": [],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, CallBrokenPromise) {\n  // Tell the server to call back to a promise client, then resolve the promise to an error.\n\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n  auto paf = kj::newPromiseAndFulfiller<test::TestInterface::Client>();\n\n  {\n    auto req = client.holdRequest();\n    req.setCap(kj::mv(paf.promise));\n    req.send().wait(context.waitScope);\n  }\n\n  bool returned = false;\n  auto req = client.callHeldRequest().send()\n      .then([&](capnp::Response<test::TestMoreStuff::CallHeldResults>&&) {\n    returned = true;\n  }, [&](kj::Exception&& e) {\n    returned = true;\n    kj::throwRecoverableException(kj::mv(e));\n  }).eagerlyEvaluate(nullptr);\n\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n\n  EXPECT_FALSE(returned);\n\n  paf.fulfiller->rejectIfThrows([]() { KJ_FAIL_ASSERT(\"foo\") { break; } });\n\n  expectPromiseThrows(kj::mv(req), context.waitScope);\n  EXPECT_TRUE(returned);\n\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n\n  // Verify that we're still connected (there were no protocol errors).\n  getCallSequence(client, 1).wait(context.waitScope);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "917-959",
    "snippet": "TEST(Rpc, EmbargoError) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto paf = kj::newPromiseAndFulfiller<test::TestCallOrder::Client>();\n\n  auto cap = test::TestCallOrder::Client(kj::mv(paf.promise));\n\n  auto earlyCall = client.getCallSequenceRequest().send();\n\n  auto echoRequest = client.echoRequest();\n  echoRequest.setCap(cap);\n  auto echo = echoRequest.send();\n\n  auto pipeline = echo.getCap();\n\n  auto call0 = getCallSequence(pipeline, 0);\n  auto call1 = getCallSequence(pipeline, 1);\n\n  earlyCall.wait(context.waitScope);\n\n  auto call2 = getCallSequence(pipeline, 2);\n\n  auto resolved = echo.wait(context.waitScope).getCap();\n\n  auto call3 = getCallSequence(pipeline, 3);\n  auto call4 = getCallSequence(pipeline, 4);\n  auto call5 = getCallSequence(pipeline, 5);\n\n  paf.fulfiller->rejectIfThrows([]() { KJ_FAIL_ASSERT(\"foo\") { break; } });\n\n  expectPromiseThrows(kj::mv(call0), context.waitScope);\n  expectPromiseThrows(kj::mv(call1), context.waitScope);\n  expectPromiseThrows(kj::mv(call2), context.waitScope);\n  expectPromiseThrows(kj::mv(call3), context.waitScope);\n  expectPromiseThrows(kj::mv(call4), context.waitScope);\n  expectPromiseThrows(kj::mv(call5), context.waitScope);\n\n  // Verify that we're still connected (there were no protocol errors).\n  getCallSequence(client, 1).wait(context.waitScope);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getCallSequence",
          "args": [
            "context.waitScope"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "TestMoreStuffImpl::getCallSequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "991-995",
          "snippet": "kj::Promise<void> TestMoreStuffImpl::getCallSequence(GetCallSequenceContext context) {\n  auto result = context.getResults();\n  result.setN(callCount++);\n  return kj::READY_NOW;\n}",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nkj::Promise<void> TestMoreStuffImpl::getCallSequence(GetCallSequenceContext context) {\n  auto result = context.getResults();\n  result.setN(callCount++);\n  return kj::READY_NOW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getCallSequence",
          "args": [
            "client",
            "1"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "getCallSequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "861-866",
          "snippet": "RemotePromise<test::TestCallOrder::GetCallSequenceResults> getCallSequence(\n    test::TestCallOrder::Client& client, uint expected) {\n  auto req = client.getCallSequenceRequest();\n  req.setExpected(expected);\n  return req.send();\n}",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nRemotePromise<test::TestCallOrder::GetCallSequenceResults> getCallSequence(\n    test::TestCallOrder::Client& client, uint expected) {\n  auto req = client.getCallSequenceRequest();\n  req.setExpected(expected);\n  return req.send();\n}"
        }
      },
      {
        "call_info": {
          "callee": "expectPromiseThrows",
          "args": [
            "kj::mv(call5)",
            "context.waitScope"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "call5"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectPromiseThrows",
          "args": [
            "kj::mv(call4)",
            "context.waitScope"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "call4"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectPromiseThrows",
          "args": [
            "kj::mv(call3)",
            "context.waitScope"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "call3"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectPromiseThrows",
          "args": [
            "kj::mv(call2)",
            "context.waitScope"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "call2"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectPromiseThrows",
          "args": [
            "kj::mv(call1)",
            "context.waitScope"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "call1"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expectPromiseThrows",
          "args": [
            "kj::mv(call0)",
            "context.waitScope"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "call0"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.fulfiller->rejectIfThrows",
          "args": [
            "[]() { KJ_FAIL_ASSERT(\"foo\") { break; } }"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "echo.wait",
          "args": [],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "echo.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earlyCall.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "echo.getCap",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "echoRequest.send",
          "args": [],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "echoRequest.setCap",
          "args": [
            "cap"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.echoRequest",
          "args": [],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestCallOrder::Client",
          "args": [
            "kj::mv(paf.promise)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<test::TestCallOrder::Client>",
          "args": [],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, EmbargoError) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto paf = kj::newPromiseAndFulfiller<test::TestCallOrder::Client>();\n\n  auto cap = test::TestCallOrder::Client(kj::mv(paf.promise));\n\n  auto earlyCall = client.getCallSequenceRequest().send();\n\n  auto echoRequest = client.echoRequest();\n  echoRequest.setCap(cap);\n  auto echo = echoRequest.send();\n\n  auto pipeline = echo.getCap();\n\n  auto call0 = getCallSequence(pipeline, 0);\n  auto call1 = getCallSequence(pipeline, 1);\n\n  earlyCall.wait(context.waitScope);\n\n  auto call2 = getCallSequence(pipeline, 2);\n\n  auto resolved = echo.wait(context.waitScope).getCap();\n\n  auto call3 = getCallSequence(pipeline, 3);\n  auto call4 = getCallSequence(pipeline, 4);\n  auto call5 = getCallSequence(pipeline, 5);\n\n  paf.fulfiller->rejectIfThrows([]() { KJ_FAIL_ASSERT(\"foo\") { break; } });\n\n  expectPromiseThrows(kj::mv(call0), context.waitScope);\n  expectPromiseThrows(kj::mv(call1), context.waitScope);\n  expectPromiseThrows(kj::mv(call2), context.waitScope);\n  expectPromiseThrows(kj::mv(call3), context.waitScope);\n  expectPromiseThrows(kj::mv(call4), context.waitScope);\n  expectPromiseThrows(kj::mv(call5), context.waitScope);\n\n  // Verify that we're still connected (there were no protocol errors).\n  getCallSequence(client, 1).wait(context.waitScope);\n}"
  },
  {
    "function_name": "expectPromiseThrows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "912-915",
    "snippet": "void expectPromiseThrows(kj::Promise<void>&& promise, kj::WaitScope& waitScope) {\n  EXPECT_TRUE(promise.then([]() { return false; }, [](kj::Exception&&) { return true; })\n      .wait(waitScope));\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "promise.then([]() { return false; }, [](kj::Exception&&) { return true; })\n      .wait(waitScope)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "waitScope"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[]() { return false; }",
            "[](kj::Exception&&) { return true; }"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nvoid expectPromiseThrows(kj::Promise<void>&& promise, kj::WaitScope& waitScope) {\n  EXPECT_TRUE(promise.then([]() { return false; }, [](kj::Exception&&) { return true; })\n      .wait(waitScope));\n}"
  },
  {
    "function_name": "expectPromiseThrows",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "906-909",
    "snippet": "void expectPromiseThrows(kj::Promise<T>&& promise, kj::WaitScope& waitScope) {\n  EXPECT_TRUE(promise.then([](T&&) { return false; }, [](kj::Exception&&) { return true; })\n      .wait(waitScope));\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "promise.then([](T&&) { return false; }, [](kj::Exception&&) { return true; })\n      .wait(waitScope)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "waitScope"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[](T&&) { return false; }",
            "[](kj::Exception&&) { return true; }"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nvoid expectPromiseThrows(kj::Promise<T>&& promise, kj::WaitScope& waitScope) {\n  EXPECT_TRUE(promise.then([](T&&) { return false; }, [](kj::Exception&&) { return true; })\n      .wait(waitScope));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "868-903",
    "snippet": "TEST(Rpc, Embargo) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto cap = test::TestCallOrder::Client(kj::heap<TestCallOrderImpl>());\n\n  auto earlyCall = client.getCallSequenceRequest().send();\n\n  auto echoRequest = client.echoRequest();\n  echoRequest.setCap(cap);\n  auto echo = echoRequest.send();\n\n  auto pipeline = echo.getCap();\n\n  auto call0 = getCallSequence(pipeline, 0);\n  auto call1 = getCallSequence(pipeline, 1);\n\n  earlyCall.wait(context.waitScope);\n\n  auto call2 = getCallSequence(pipeline, 2);\n\n  auto resolved = echo.wait(context.waitScope).getCap();\n\n  auto call3 = getCallSequence(pipeline, 3);\n  auto call4 = getCallSequence(pipeline, 4);\n  auto call5 = getCallSequence(pipeline, 5);\n\n  EXPECT_EQ(0, call0.wait(context.waitScope).getN());\n  EXPECT_EQ(1, call1.wait(context.waitScope).getN());\n  EXPECT_EQ(2, call2.wait(context.waitScope).getN());\n  EXPECT_EQ(3, call3.wait(context.waitScope).getN());\n  EXPECT_EQ(4, call4.wait(context.waitScope).getN());\n  EXPECT_EQ(5, call5.wait(context.waitScope).getN());\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "5",
            "call5.wait(context.waitScope).getN()"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call5.wait",
          "args": [],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "call5.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "4",
            "call4.wait(context.waitScope).getN()"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call4.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "call3.wait(context.waitScope).getN()"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call3.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "call2.wait(context.waitScope).getN()"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call2.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "call1.wait(context.waitScope).getN()"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call1.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "call0.wait(context.waitScope).getN()"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call0.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getCallSequence",
          "args": [
            "pipeline",
            "5"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "getCallSequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "861-866",
          "snippet": "RemotePromise<test::TestCallOrder::GetCallSequenceResults> getCallSequence(\n    test::TestCallOrder::Client& client, uint expected) {\n  auto req = client.getCallSequenceRequest();\n  req.setExpected(expected);\n  return req.send();\n}",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nRemotePromise<test::TestCallOrder::GetCallSequenceResults> getCallSequence(\n    test::TestCallOrder::Client& client, uint expected) {\n  auto req = client.getCallSequenceRequest();\n  req.setExpected(expected);\n  return req.send();\n}"
        }
      },
      {
        "call_info": {
          "callee": "echo.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earlyCall.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "echo.getCap",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "echoRequest.send",
          "args": [],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "echoRequest.setCap",
          "args": [
            "cap"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.echoRequest",
          "args": [],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestCallOrder::Client",
          "args": [
            "kj::heap<TestCallOrderImpl>()"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestCallOrderImpl>",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, Embargo) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto cap = test::TestCallOrder::Client(kj::heap<TestCallOrderImpl>());\n\n  auto earlyCall = client.getCallSequenceRequest().send();\n\n  auto echoRequest = client.echoRequest();\n  echoRequest.setCap(cap);\n  auto echo = echoRequest.send();\n\n  auto pipeline = echo.getCap();\n\n  auto call0 = getCallSequence(pipeline, 0);\n  auto call1 = getCallSequence(pipeline, 1);\n\n  earlyCall.wait(context.waitScope);\n\n  auto call2 = getCallSequence(pipeline, 2);\n\n  auto resolved = echo.wait(context.waitScope).getCap();\n\n  auto call3 = getCallSequence(pipeline, 3);\n  auto call4 = getCallSequence(pipeline, 4);\n  auto call5 = getCallSequence(pipeline, 5);\n\n  EXPECT_EQ(0, call0.wait(context.waitScope).getN());\n  EXPECT_EQ(1, call1.wait(context.waitScope).getN());\n  EXPECT_EQ(2, call2.wait(context.waitScope).getN());\n  EXPECT_EQ(3, call3.wait(context.waitScope).getN());\n  EXPECT_EQ(4, call4.wait(context.waitScope).getN());\n  EXPECT_EQ(5, call5.wait(context.waitScope).getN());\n}"
  },
  {
    "function_name": "getCallSequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "861-866",
    "snippet": "RemotePromise<test::TestCallOrder::GetCallSequenceResults> getCallSequence(\n    test::TestCallOrder::Client& client, uint expected) {\n  auto req = client.getCallSequenceRequest();\n  req.setExpected(expected);\n  return req.send();\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "req.send",
          "args": [],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "req.setExpected",
          "args": [
            "expected"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nRemotePromise<test::TestCallOrder::GetCallSequenceResults> getCallSequence(\n    test::TestCallOrder::Client& client, uint expected) {\n  auto req = client.getCallSequenceRequest();\n  req.setExpected(expected);\n  return req.send();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "820-859",
    "snippet": "TEST(Rpc, SendTwice) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  auto cap = test::TestInterface::Client(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)));\n\n  {\n    auto request = client.callFooRequest();\n    request.setCap(cap);\n\n    EXPECT_EQ(\"bar\", request.send().wait(context.waitScope).getS());\n  }\n\n  // Allow some time for the server to release `cap`.\n  EXPECT_EQ(1, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n\n  {\n    // More requests with the same cap.\n    auto request = client.callFooRequest();\n    auto request2 = client.callFooRequest();\n    request.setCap(cap);\n    request2.setCap(kj::mv(cap));\n\n    auto promise = request.send();\n    auto promise2 = request2.send();\n\n    EXPECT_EQ(\"bar\", promise.wait(context.waitScope).getS());\n    EXPECT_EQ(\"bar\", promise2.wait(context.waitScope).getS());\n  }\n\n  // Now the cap should be released.\n  destructionPromise.wait(context.waitScope);\n  EXPECT_TRUE(destroyed);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "destroyed"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destructionPromise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "promise2.wait(context.waitScope).getS()"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "promise.wait(context.waitScope).getS()"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request2.send",
          "args": [],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request2.setCap",
          "args": [
            "kj::mv(cap)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "cap"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callFooRequest",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callFooRequest",
          "args": [],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "client.getCallSequenceRequest().send().wait(context.waitScope).getN()"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "request.send().wait(context.waitScope).getS()"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "context.waitScope"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "270-298",
          "snippet": "void send() override {\n        if (connection.networkException != nullptr) {\n          return;\n        }\n\n        ++connection.network.sent;\n\n        // Uncomment to get a debug dump.\n//        kj::String msg = connection.network.network.dumper.dump(\n//            message.getRoot<rpc::Message>(), connection.sender);\n//        KJ_ DBG(msg);\n\n        auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n\n        auto connectionPtr = &connection;\n        connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n            [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n          KJ_IF_MAYBE(p, connectionPtr->partner) {\n            if (p->fulfillers.empty()) {\n              p->messages.push(kj::mv(message));\n            } else {\n              ++p->network.received;\n              p->fulfillers.front()->fulfill(\n                  kj::Own<IncomingRpcMessage>(kj::mv(message)));\n              p->fulfillers.pop();\n            }\n          }\n        })));\n      }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      void send() override {\n              if (connection.networkException != nullptr) {\n                return;\n              }\n      \n              ++connection.network.sent;\n      \n              // Uncomment to get a debug dump.\n      //        kj::String msg = connection.network.network.dumper.dump(\n      //            message.getRoot<rpc::Message>(), connection.sender);\n      //        KJ_ DBG(msg);\n      \n              auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n      \n              auto connectionPtr = &connection;\n              connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n                  [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n                KJ_IF_MAYBE(p, connectionPtr->partner) {\n                  if (p->fulfillers.empty()) {\n                    p->messages.push(kj::mv(message));\n                  } else {\n                    ++p->network.received;\n                    p->fulfillers.front()->fulfill(\n                        kj::Own<IncomingRpcMessage>(kj::mv(message)));\n                    p->fulfillers.pop();\n                  }\n                }\n              })));\n            }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "cap"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callFooRequest",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TestInterface::Client",
          "args": [
            "kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller))"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestCapDestructor>",
          "args": [
            "kj::mv(paf.fulfiller)"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "nullptr"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[&]() { destroyed = true; }"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, SendTwice) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  auto cap = test::TestInterface::Client(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)));\n\n  {\n    auto request = client.callFooRequest();\n    request.setCap(cap);\n\n    EXPECT_EQ(\"bar\", request.send().wait(context.waitScope).getS());\n  }\n\n  // Allow some time for the server to release `cap`.\n  EXPECT_EQ(1, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n\n  {\n    // More requests with the same cap.\n    auto request = client.callFooRequest();\n    auto request2 = client.callFooRequest();\n    request.setCap(cap);\n    request2.setCap(kj::mv(cap));\n\n    auto promise = request.send();\n    auto promise2 = request2.send();\n\n    EXPECT_EQ(\"bar\", promise.wait(context.waitScope).getS());\n    EXPECT_EQ(\"bar\", promise2.wait(context.waitScope).getS());\n  }\n\n  // Now the cap should be released.\n  destructionPromise.wait(context.waitScope);\n  EXPECT_TRUE(destroyed);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "789-818",
    "snippet": "TEST(Rpc, Cancel) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  {\n    auto request = client.neverReturnRequest();\n    request.setCap(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)));\n\n    {\n      auto responsePromise = request.send();\n\n      // Allow some time to settle.\n      EXPECT_EQ(1, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n      EXPECT_EQ(2, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n\n      // The cap shouldn't have been destroyed yet because the call never returned.\n      EXPECT_FALSE(destroyed);\n    }\n  }\n\n  // Now the cap should be released.\n  destructionPromise.wait(context.waitScope);\n  EXPECT_TRUE(destroyed);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "destroyed"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destructionPromise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "destroyed"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "client.getCallSequenceRequest().send().wait(context.waitScope).getN()"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "client.getCallSequenceRequest().send().wait(context.waitScope).getN()"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller))"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestCapDestructor>",
          "args": [
            "kj::mv(paf.fulfiller)"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.neverReturnRequest",
          "args": [],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "nullptr"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[&]() { destroyed = true; }"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, Cancel) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  {\n    auto request = client.neverReturnRequest();\n    request.setCap(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)));\n\n    {\n      auto responsePromise = request.send();\n\n      // Allow some time to settle.\n      EXPECT_EQ(1, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n      EXPECT_EQ(2, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n\n      // The cap shouldn't have been destroyed yet because the call never returned.\n      EXPECT_FALSE(destroyed);\n    }\n  }\n\n  // Now the cap should be released.\n  destructionPromise.wait(context.waitScope);\n  EXPECT_TRUE(destroyed);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "726-787",
    "snippet": "TEST(Rpc, RetainAndRelease) {\n  TestContext context;\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  {\n    auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n        .castAs<test::TestMoreStuff>();\n\n    {\n      auto request = client.holdRequest();\n      request.setCap(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)));\n      request.send().wait(context.waitScope);\n    }\n\n    // Do some other call to add a round trip.\n    EXPECT_EQ(1, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n\n    // Shouldn't be destroyed because it's being held by the server.\n    EXPECT_FALSE(destroyed);\n\n    // We can ask it to call the held capability.\n    EXPECT_EQ(\"bar\", client.callHeldRequest().send().wait(context.waitScope).getS());\n\n    {\n      // We can get the cap back from it.\n      auto capCopy = client.getHeldRequest().send().wait(context.waitScope).getCap();\n\n      {\n        // And call it, without any network communications.\n        uint oldSentCount = context.clientNetwork.getSentCount();\n        auto request = capCopy.fooRequest();\n        request.setI(123);\n        request.setJ(true);\n        EXPECT_EQ(\"foo\", request.send().wait(context.waitScope).getX());\n        EXPECT_EQ(oldSentCount, context.clientNetwork.getSentCount());\n      }\n\n      {\n        // We can send another copy of the same cap to another method, and it works.\n        auto request = client.callFooRequest();\n        request.setCap(capCopy);\n        EXPECT_EQ(\"bar\", request.send().wait(context.waitScope).getS());\n      }\n    }\n\n    // Give some time to settle.\n    EXPECT_EQ(5, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n    EXPECT_EQ(6, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n    EXPECT_EQ(7, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n\n    // Can't be destroyed, we haven't released it.\n    EXPECT_FALSE(destroyed);\n  }\n\n  // We released our client, which should cause the server to be released, which in turn will\n  // release the cap pointing back to us.\n  destructionPromise.wait(context.waitScope);\n  EXPECT_TRUE(destroyed);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "destroyed"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destructionPromise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "destroyed"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "7",
            "client.getCallSequenceRequest().send().wait(context.waitScope).getN()"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "6",
            "client.getCallSequenceRequest().send().wait(context.waitScope).getN()"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "5",
            "client.getCallSequenceRequest().send().wait(context.waitScope).getN()"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "request.send().wait(context.waitScope).getS()"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "context.waitScope"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "270-298",
          "snippet": "void send() override {\n        if (connection.networkException != nullptr) {\n          return;\n        }\n\n        ++connection.network.sent;\n\n        // Uncomment to get a debug dump.\n//        kj::String msg = connection.network.network.dumper.dump(\n//            message.getRoot<rpc::Message>(), connection.sender);\n//        KJ_ DBG(msg);\n\n        auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n\n        auto connectionPtr = &connection;\n        connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n            [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n          KJ_IF_MAYBE(p, connectionPtr->partner) {\n            if (p->fulfillers.empty()) {\n              p->messages.push(kj::mv(message));\n            } else {\n              ++p->network.received;\n              p->fulfillers.front()->fulfill(\n                  kj::Own<IncomingRpcMessage>(kj::mv(message)));\n              p->fulfillers.pop();\n            }\n          }\n        })));\n      }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      void send() override {\n              if (connection.networkException != nullptr) {\n                return;\n              }\n      \n              ++connection.network.sent;\n      \n              // Uncomment to get a debug dump.\n      //        kj::String msg = connection.network.network.dumper.dump(\n      //            message.getRoot<rpc::Message>(), connection.sender);\n      //        KJ_ DBG(msg);\n      \n              auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n      \n              auto connectionPtr = &connection;\n              connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n                  [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n                KJ_IF_MAYBE(p, connectionPtr->partner) {\n                  if (p->fulfillers.empty()) {\n                    p->messages.push(kj::mv(message));\n                  } else {\n                    ++p->network.received;\n                    p->fulfillers.front()->fulfill(\n                        kj::Own<IncomingRpcMessage>(kj::mv(message)));\n                    p->fulfillers.pop();\n                  }\n                }\n              })));\n            }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "capCopy"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callFooRequest",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "oldSentCount",
            "context.clientNetwork.getSentCount()"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.clientNetwork.getSentCount",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "getSentCount",
          "container": "TestNetworkAdapter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "208-208",
          "snippet": "uint getSentCount() { return sent; }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  uint getSentCount() { return sent; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "request.send().wait(context.waitScope).getX()"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setJ",
          "args": [
            "true"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setI",
          "args": [
            "123"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capCopy.fooRequest",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHeldRequest",
          "args": [],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHeldRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHeldRequest",
          "args": [],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHeldRequest",
          "args": [],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "client.callHeldRequest().send().wait(context.waitScope).getS()"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callHeldRequest",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callHeldRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callHeldRequest",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callHeldRequest",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "destroyed"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "client.getCallSequenceRequest().send().wait(context.waitScope).getN()"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller))"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestCapDestructor>",
          "args": [
            "kj::mv(paf.fulfiller)"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.holdRequest",
          "args": [],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "nullptr"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[&]() { destroyed = true; }"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, RetainAndRelease) {\n  TestContext context;\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  {\n    auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n        .castAs<test::TestMoreStuff>();\n\n    {\n      auto request = client.holdRequest();\n      request.setCap(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)));\n      request.send().wait(context.waitScope);\n    }\n\n    // Do some other call to add a round trip.\n    EXPECT_EQ(1, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n\n    // Shouldn't be destroyed because it's being held by the server.\n    EXPECT_FALSE(destroyed);\n\n    // We can ask it to call the held capability.\n    EXPECT_EQ(\"bar\", client.callHeldRequest().send().wait(context.waitScope).getS());\n\n    {\n      // We can get the cap back from it.\n      auto capCopy = client.getHeldRequest().send().wait(context.waitScope).getCap();\n\n      {\n        // And call it, without any network communications.\n        uint oldSentCount = context.clientNetwork.getSentCount();\n        auto request = capCopy.fooRequest();\n        request.setI(123);\n        request.setJ(true);\n        EXPECT_EQ(\"foo\", request.send().wait(context.waitScope).getX());\n        EXPECT_EQ(oldSentCount, context.clientNetwork.getSentCount());\n      }\n\n      {\n        // We can send another copy of the same cap to another method, and it works.\n        auto request = client.callFooRequest();\n        request.setCap(capCopy);\n        EXPECT_EQ(\"bar\", request.send().wait(context.waitScope).getS());\n      }\n    }\n\n    // Give some time to settle.\n    EXPECT_EQ(5, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n    EXPECT_EQ(6, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n    EXPECT_EQ(7, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n\n    // Can't be destroyed, we haven't released it.\n    EXPECT_FALSE(destroyed);\n  }\n\n  // We released our client, which should cause the server to be released, which in turn will\n  // release the cap pointing back to us.\n  destructionPromise.wait(context.waitScope);\n  EXPECT_TRUE(destroyed);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "688-724",
    "snippet": "TEST(Rpc, PromiseResolve) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  int chainedCallCount = 0;\n\n  auto request = client.callFooRequest();\n  auto request2 = client.callFooWhenResolvedRequest();\n\n  auto paf = kj::newPromiseAndFulfiller<test::TestInterface::Client>();\n\n  {\n    auto fork = paf.promise.fork();\n    request.setCap(fork.addBranch());\n    request2.setCap(fork.addBranch());\n  }\n\n  auto promise = request.send();\n  auto promise2 = request2.send();\n\n  // Make sure getCap() has been called on the server side by sending another call and waiting\n  // for it.\n  EXPECT_EQ(2, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n  EXPECT_EQ(3, context.restorer.callCount);\n\n  // OK, now fulfill the local promise.\n  paf.fulfiller->fulfill(kj::heap<TestInterfaceImpl>(chainedCallCount));\n\n  // We should now be able to wait for getCap() to finish.\n  EXPECT_EQ(\"bar\", promise.wait(context.waitScope).getS());\n  EXPECT_EQ(\"bar\", promise2.wait(context.waitScope).getS());\n\n  EXPECT_EQ(3, context.restorer.callCount);\n  EXPECT_EQ(2, chainedCallCount);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "chainedCallCount"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "context.restorer.callCount"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "promise2.wait(context.waitScope).getS()"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "promise.wait(context.waitScope).getS()"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.fulfiller->fulfill",
          "args": [
            "kj::heap<TestInterfaceImpl>(chainedCallCount)"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1295-1297",
          "snippet": "void fulfill(kj::Promise<kj::Own<RpcResponse>>&& promise) {\n      fulfiller->fulfill(kj::mv(promise));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  void fulfill(kj::Promise<kj::Own<RpcResponse>>&& promise) {\n        fulfiller->fulfill(kj::mv(promise));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceImpl>",
          "args": [
            "chainedCallCount"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "context.restorer.callCount"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "client.getCallSequenceRequest().send().wait(context.waitScope).getN()"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCallSequenceRequest",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request2.send",
          "args": [],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request2.setCap",
          "args": [
            "fork.addBranch()"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork.addBranch",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "fork.addBranch()"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.fork",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<test::TestInterface::Client>",
          "args": [],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "client.callFooWhenResolvedRequest",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.callFooRequest",
          "args": [],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, PromiseResolve) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  int chainedCallCount = 0;\n\n  auto request = client.callFooRequest();\n  auto request2 = client.callFooWhenResolvedRequest();\n\n  auto paf = kj::newPromiseAndFulfiller<test::TestInterface::Client>();\n\n  {\n    auto fork = paf.promise.fork();\n    request.setCap(fork.addBranch());\n    request2.setCap(fork.addBranch());\n  }\n\n  auto promise = request.send();\n  auto promise2 = request2.send();\n\n  // Make sure getCap() has been called on the server side by sending another call and waiting\n  // for it.\n  EXPECT_EQ(2, client.getCallSequenceRequest().send().wait(context.waitScope).getN());\n  EXPECT_EQ(3, context.restorer.callCount);\n\n  // OK, now fulfill the local promise.\n  paf.fulfiller->fulfill(kj::heap<TestInterfaceImpl>(chainedCallCount));\n\n  // We should now be able to wait for getCap() to finish.\n  EXPECT_EQ(\"bar\", promise.wait(context.waitScope).getS());\n  EXPECT_EQ(\"bar\", promise2.wait(context.waitScope).getS());\n\n  EXPECT_EQ(3, context.restorer.callCount);\n  EXPECT_EQ(2, chainedCallCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "647-686",
    "snippet": "TEST(Rpc, Cancelation) {\n  // Tests allowCancellation().\n\n  TestContext context;\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  kj::Promise<void> promise = nullptr;\n\n  bool returned = false;\n  {\n    auto request = client.expectCancelRequest();\n    request.setCap(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)));\n    promise = request.send().then(\n        [&](Response<test::TestMoreStuff::ExpectCancelResults>&& response) {\n      returned = true;\n    }).eagerlyEvaluate(nullptr);\n  }\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n\n  // We can detect that the method was canceled because it will drop the cap.\n  EXPECT_FALSE(destroyed);\n  EXPECT_FALSE(returned);\n\n  promise = nullptr;  // request cancellation\n  destructionPromise.wait(context.waitScope);\n\n  EXPECT_TRUE(destroyed);\n  EXPECT_FALSE(returned);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "returned"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "destroyed"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destructionPromise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "returned"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "destroyed"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "context.waitScope"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "nullptr"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "270-298",
          "snippet": "void send() override {\n        if (connection.networkException != nullptr) {\n          return;\n        }\n\n        ++connection.network.sent;\n\n        // Uncomment to get a debug dump.\n//        kj::String msg = connection.network.network.dumper.dump(\n//            message.getRoot<rpc::Message>(), connection.sender);\n//        KJ_ DBG(msg);\n\n        auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n\n        auto connectionPtr = &connection;\n        connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n            [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n          KJ_IF_MAYBE(p, connectionPtr->partner) {\n            if (p->fulfillers.empty()) {\n              p->messages.push(kj::mv(message));\n            } else {\n              ++p->network.received;\n              p->fulfillers.front()->fulfill(\n                  kj::Own<IncomingRpcMessage>(kj::mv(message)));\n              p->fulfillers.pop();\n            }\n          }\n        })));\n      }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      void send() override {\n              if (connection.networkException != nullptr) {\n                return;\n              }\n      \n              ++connection.network.sent;\n      \n              // Uncomment to get a debug dump.\n      //        kj::String msg = connection.network.network.dumper.dump(\n      //            message.getRoot<rpc::Message>(), connection.sender);\n      //        KJ_ DBG(msg);\n      \n              auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n      \n              auto connectionPtr = &connection;\n              connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n                  [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n                KJ_IF_MAYBE(p, connectionPtr->partner) {\n                  if (p->fulfillers.empty()) {\n                    p->messages.push(kj::mv(message));\n                  } else {\n                    ++p->network.received;\n                    p->fulfillers.front()->fulfill(\n                        kj::Own<IncomingRpcMessage>(kj::mv(message)));\n                    p->fulfillers.pop();\n                  }\n                }\n              })));\n            }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setCap",
          "args": [
            "kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller))"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestCapDestructor>",
          "args": [
            "kj::mv(paf.fulfiller)"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.expectCancelRequest",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "nullptr"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.then",
          "args": [
            "[&]() { destroyed = true; }"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, Cancelation) {\n  // Tests allowCancellation().\n\n  TestContext context;\n\n  auto paf = kj::newPromiseAndFulfiller<void>();\n  bool destroyed = false;\n  auto destructionPromise = paf.promise.then([&]() { destroyed = true; }).eagerlyEvaluate(nullptr);\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  kj::Promise<void> promise = nullptr;\n\n  bool returned = false;\n  {\n    auto request = client.expectCancelRequest();\n    request.setCap(kj::heap<TestCapDestructor>(kj::mv(paf.fulfiller)));\n    promise = request.send().then(\n        [&](Response<test::TestMoreStuff::ExpectCancelResults>&& response) {\n      returned = true;\n    }).eagerlyEvaluate(nullptr);\n  }\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n  kj::evalLater([]() {}).wait(context.waitScope);\n\n  // We can detect that the method was canceled because it will drop the cap.\n  EXPECT_FALSE(destroyed);\n  EXPECT_FALSE(returned);\n\n  promise = nullptr;  // request cancellation\n  destructionPromise.wait(context.waitScope);\n\n  EXPECT_TRUE(destroyed);\n  EXPECT_FALSE(returned);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "613-645",
    "snippet": "TEST(Rpc, TailCall) {\n  TestContext context;\n\n  auto caller = context.connect(test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLER)\n      .castAs<test::TestTailCaller>();\n\n  int calleeCallCount = 0;\n\n  test::TestTailCallee::Client callee(kj::heap<TestTailCalleeImpl>(calleeCallCount));\n\n  auto request = caller.fooRequest();\n  request.setI(456);\n  request.setCallee(callee);\n\n  auto promise = request.send();\n\n  auto dependentCall0 = promise.getC().getCallSequenceRequest().send();\n\n  auto response = promise.wait(context.waitScope);\n  EXPECT_EQ(456, response.getI());\n  EXPECT_EQ(\"from TestTailCaller\", response.getT());\n\n  auto dependentCall1 = promise.getC().getCallSequenceRequest().send();\n\n  auto dependentCall2 = response.getC().getCallSequenceRequest().send();\n\n  EXPECT_EQ(0, dependentCall0.wait(context.waitScope).getN());\n  EXPECT_EQ(1, dependentCall1.wait(context.waitScope).getN());\n  EXPECT_EQ(2, dependentCall2.wait(context.waitScope).getN());\n\n  EXPECT_EQ(1, calleeCallCount);\n  EXPECT_EQ(1, context.restorer.callCount);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "context.restorer.callCount"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "calleeCallCount"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "dependentCall2.wait(context.waitScope).getN()"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall2.wait",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dependentCall2.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "dependentCall1.wait(context.waitScope).getN()"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall1.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "dependentCall0.wait(context.waitScope).getN()"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dependentCall0.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getC",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"from TestTailCaller\"",
            "response.getT()"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getT",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "response.getI()"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getI",
          "args": [],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getC",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setCallee",
          "args": [
            "callee"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setI",
          "args": [
            "456"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "caller.fooRequest",
          "args": [],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLER"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, TailCall) {\n  TestContext context;\n\n  auto caller = context.connect(test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLER)\n      .castAs<test::TestTailCaller>();\n\n  int calleeCallCount = 0;\n\n  test::TestTailCallee::Client callee(kj::heap<TestTailCalleeImpl>(calleeCallCount));\n\n  auto request = caller.fooRequest();\n  request.setI(456);\n  request.setCallee(callee);\n\n  auto promise = request.send();\n\n  auto dependentCall0 = promise.getC().getCallSequenceRequest().send();\n\n  auto response = promise.wait(context.waitScope);\n  EXPECT_EQ(456, response.getI());\n  EXPECT_EQ(\"from TestTailCaller\", response.getT());\n\n  auto dependentCall1 = promise.getC().getCallSequenceRequest().send();\n\n  auto dependentCall2 = response.getC().getCallSequenceRequest().send();\n\n  EXPECT_EQ(0, dependentCall0.wait(context.waitScope).getN());\n  EXPECT_EQ(1, dependentCall1.wait(context.waitScope).getN());\n  EXPECT_EQ(2, dependentCall2.wait(context.waitScope).getN());\n\n  EXPECT_EQ(1, calleeCallCount);\n  EXPECT_EQ(1, context.restorer.callCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "584-611",
    "snippet": "TEST(Rpc, ReleaseOnCancel) {\n  // At one time, there was a bug where if a Return contained capabilities, but the client had\n  // canceled the request and already send a Finish (which presumably didn't reach the server before\n  // the Return), then we'd leak those caps. Test for that.\n\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n  client.whenResolved().wait(context.waitScope);\n\n  {\n    auto promise = client.getHandleRequest().send();\n\n    // If the server receives cancellation too early, it won't even return a capability in the\n    // results, it will just return \"canceled\". We want to emulate the case where the return message\n    // and the cancel (finish) message cross paths. It turns out that exactly two evalLater()s get\n    // us there.\n    //\n    // TODO(cleanup): This is fragile, but I'm not sure how else to write it without a ton\n    //   of scaffolding.\n    kj::evalLater([]() {}).wait(context.waitScope);\n    kj::evalLater([]() {}).wait(context.waitScope);\n  }\n\n  for (uint i = 0; i < 16; i++) kj::evalLater([]() {}).wait(context.waitScope);\n  EXPECT_EQ(0, context.restorer.handleCount);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "context.restorer.handleCount"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "context.waitScope"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.whenResolved",
          "args": [
            "context.waitScope"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.whenResolved",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, ReleaseOnCancel) {\n  // At one time, there was a bug where if a Return contained capabilities, but the client had\n  // canceled the request and already send a Finish (which presumably didn't reach the server before\n  // the Return), then we'd leak those caps. Test for that.\n\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n  client.whenResolved().wait(context.waitScope);\n\n  {\n    auto promise = client.getHandleRequest().send();\n\n    // If the server receives cancellation too early, it won't even return a capability in the\n    // results, it will just return \"canceled\". We want to emulate the case where the return message\n    // and the cancel (finish) message cross paths. It turns out that exactly two evalLater()s get\n    // us there.\n    //\n    // TODO(cleanup): This is fragile, but I'm not sure how else to write it without a ton\n    //   of scaffolding.\n    kj::evalLater([]() {}).wait(context.waitScope);\n    kj::evalLater([]() {}).wait(context.waitScope);\n  }\n\n  for (uint i = 0; i < 16; i++) kj::evalLater([]() {}).wait(context.waitScope);\n  EXPECT_EQ(0, context.restorer.handleCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "556-582",
    "snippet": "TEST(Rpc, Release) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto handle1 = client.getHandleRequest().send().wait(context.waitScope).getHandle();\n  auto promise = client.getHandleRequest().send();\n  auto handle2 = promise.wait(context.waitScope).getHandle();\n\n  EXPECT_EQ(2, context.restorer.handleCount);\n\n  handle1 = nullptr;\n\n  for (uint i = 0; i < 16; i++) kj::evalLater([]() {}).wait(context.waitScope);\n  EXPECT_EQ(1, context.restorer.handleCount);\n\n  handle2 = nullptr;\n\n  for (uint i = 0; i < 16; i++) kj::evalLater([]() {}).wait(context.waitScope);\n  EXPECT_EQ(1, context.restorer.handleCount);\n\n  promise = nullptr;\n\n  for (uint i = 0; i < 16; i++) kj::evalLater([]() {}).wait(context.waitScope);\n  EXPECT_EQ(0, context.restorer.handleCount);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "context.restorer.handleCount"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "context.waitScope"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "context.restorer.handleCount"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "context.restorer.handleCount"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "context.restorer.handleCount"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [
            "context.waitScope"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getHandleRequest",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, Release) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF)\n      .castAs<test::TestMoreStuff>();\n\n  auto handle1 = client.getHandleRequest().send().wait(context.waitScope).getHandle();\n  auto promise = client.getHandleRequest().send();\n  auto handle2 = promise.wait(context.waitScope).getHandle();\n\n  EXPECT_EQ(2, context.restorer.handleCount);\n\n  handle1 = nullptr;\n\n  for (uint i = 0; i < 16; i++) kj::evalLater([]() {}).wait(context.waitScope);\n  EXPECT_EQ(1, context.restorer.handleCount);\n\n  handle2 = nullptr;\n\n  for (uint i = 0; i < 16; i++) kj::evalLater([]() {}).wait(context.waitScope);\n  EXPECT_EQ(1, context.restorer.handleCount);\n\n  promise = nullptr;\n\n  for (uint i = 0; i < 16; i++) kj::evalLater([]() {}).wait(context.waitScope);\n  EXPECT_EQ(0, context.restorer.handleCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "520-554",
    "snippet": "TEST(Rpc, Pipelining) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_PIPELINE)\n      .castAs<test::TestPipeline>();\n\n  int chainedCallCount = 0;\n\n  auto request = client.getCapRequest();\n  request.setN(234);\n  request.setInCap(kj::heap<TestInterfaceImpl>(chainedCallCount));\n\n  auto promise = request.send();\n\n  auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n  pipelineRequest.setI(321);\n  auto pipelinePromise = pipelineRequest.send();\n\n  auto pipelineRequest2 = promise.getOutBox().getCap().castAs<test::TestExtends>().graultRequest();\n  auto pipelinePromise2 = pipelineRequest2.send();\n\n  promise = nullptr;  // Just to be annoying, drop the original promise.\n\n  EXPECT_EQ(0, context.restorer.callCount);\n  EXPECT_EQ(0, chainedCallCount);\n\n  auto response = pipelinePromise.wait(context.waitScope);\n  EXPECT_EQ(\"bar\", response.getX());\n\n  auto response2 = pipelinePromise2.wait(context.waitScope);\n  checkTestMessage(response2);\n\n  EXPECT_EQ(3, context.restorer.callCount);\n  EXPECT_EQ(1, chainedCallCount);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "chainedCallCount"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "context.restorer.callCount"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkTestMessage",
          "args": [
            "response2"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "checkTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "844-844",
          "snippet": "void checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid checkTestMessage(TestListDefaults::Reader reader) { genericCheckListDefaults(reader); }"
        }
      },
      {
        "call_info": {
          "callee": "pipelinePromise2.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "response.getX()"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getX",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelinePromise.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "chainedCallCount"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "context.restorer.callCount"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest2.send",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipelineRequest.setI",
          "args": [
            "321"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.getOutBox",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setInCap",
          "args": [
            "kj::heap<TestInterfaceImpl>(chainedCallCount)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceImpl>",
          "args": [
            "chainedCallCount"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.setN",
          "args": [
            "234"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getCapRequest",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_PIPELINE"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, Pipelining) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_PIPELINE)\n      .castAs<test::TestPipeline>();\n\n  int chainedCallCount = 0;\n\n  auto request = client.getCapRequest();\n  request.setN(234);\n  request.setInCap(kj::heap<TestInterfaceImpl>(chainedCallCount));\n\n  auto promise = request.send();\n\n  auto pipelineRequest = promise.getOutBox().getCap().fooRequest();\n  pipelineRequest.setI(321);\n  auto pipelinePromise = pipelineRequest.send();\n\n  auto pipelineRequest2 = promise.getOutBox().getCap().castAs<test::TestExtends>().graultRequest();\n  auto pipelinePromise2 = pipelineRequest2.send();\n\n  promise = nullptr;  // Just to be annoying, drop the original promise.\n\n  EXPECT_EQ(0, context.restorer.callCount);\n  EXPECT_EQ(0, chainedCallCount);\n\n  auto response = pipelinePromise.wait(context.waitScope);\n  EXPECT_EQ(\"bar\", response.getX());\n\n  auto response2 = pipelinePromise2.wait(context.waitScope);\n  checkTestMessage(response2);\n\n  EXPECT_EQ(3, context.restorer.callCount);\n  EXPECT_EQ(1, chainedCallCount);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "479-518",
    "snippet": "TEST(Rpc, Basic) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_INTERFACE)\n      .castAs<test::TestInterface>();\n\n  auto request1 = client.fooRequest();\n  request1.setI(123);\n  request1.setJ(true);\n  auto promise1 = request1.send();\n\n  // We used to call bar() after baz(), hence the numbering, but this masked the case where the\n  // RPC system actually disconnected on bar() (thus returning an exception, which we decided\n  // was expected).\n  bool barFailed = false;\n  auto request3 = client.barRequest();\n  auto promise3 = request3.send().then(\n      [](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        barFailed = true;\n      });\n\n  auto request2 = client.bazRequest();\n  initTestMessage(request2.initS());\n  auto promise2 = request2.send();\n\n  EXPECT_EQ(0, context.restorer.callCount);\n\n  auto response1 = promise1.wait(context.waitScope);\n\n  EXPECT_EQ(\"foo\", response1.getX());\n\n  auto response2 = promise2.wait(context.waitScope);\n\n  promise3.wait(context.waitScope);\n\n  EXPECT_EQ(2, context.restorer.callCount);\n  EXPECT_TRUE(barFailed);\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "barFailed"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2",
            "context.restorer.callCount"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise3.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise2.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response1.getX()"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response1.getX",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise1.wait",
          "args": [
            "context.waitScope"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "context.restorer.callCount"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request2.send",
          "args": [],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "initTestMessage",
          "args": [
            "request2.initS()"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "initTestMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/test-util.c++",
          "lines": "836-836",
          "snippet": "void initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"test-util.h\"\n\nvoid initTestMessage(TestListDefaults::Builder builder) { genericInitListDefaults(builder); }"
        }
      },
      {
        "call_info": {
          "callee": "request2.initS",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.bazRequest",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request3.send",
          "args": [
            "[](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }",
            "[&](kj::Exception&& e) {\n        barFailed = true;\n      }"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "LocalRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "207-241",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
            "kj::Maybe<Response<AnyPointer>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.barRequest",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setJ",
          "args": [
            "true"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request1.setI",
          "args": [
            "123"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.fooRequest",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.connect",
          "args": [
            "test::TestSturdyRefObjectId::Tag::TEST_INTERFACE"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTEST(Rpc, Basic) {\n  TestContext context;\n\n  auto client = context.connect(test::TestSturdyRefObjectId::Tag::TEST_INTERFACE)\n      .castAs<test::TestInterface>();\n\n  auto request1 = client.fooRequest();\n  request1.setI(123);\n  request1.setJ(true);\n  auto promise1 = request1.send();\n\n  // We used to call bar() after baz(), hence the numbering, but this masked the case where the\n  // RPC system actually disconnected on bar() (thus returning an exception, which we decided\n  // was expected).\n  bool barFailed = false;\n  auto request3 = client.barRequest();\n  auto promise3 = request3.send().then(\n      [](Response<test::TestInterface::BarResults>&& response) {\n        ADD_FAILURE() << \"Expected bar() call to fail.\";\n      }, [&](kj::Exception&& e) {\n        barFailed = true;\n      });\n\n  auto request2 = client.bazRequest();\n  initTestMessage(request2.initS());\n  auto promise2 = request2.send();\n\n  EXPECT_EQ(0, context.restorer.callCount);\n\n  auto response1 = promise1.wait(context.waitScope);\n\n  EXPECT_EQ(\"foo\", response1.getX());\n\n  auto response2 = promise2.wait(context.waitScope);\n\n  promise3.wait(context.waitScope);\n\n  EXPECT_EQ(2, context.restorer.callCount);\n  EXPECT_TRUE(barFailed);\n}"
  },
  {
    "function_name": "connect",
    "container": "TestContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "468-476",
    "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpcClient.restore",
          "args": [
            "hostId",
            "ref.getObjectId()"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "restore",
          "container": "ClientContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "101-116",
          "snippet": "Capability::Client restore(kj::StringPtr name) {\n      word scratch[64];\n      memset(scratch, 0, sizeof(scratch));\n      MallocMessageBuilder message(scratch);\n\n      auto hostIdOrphan = message.getOrphanage().newOrphan<rpc::twoparty::VatId>();\n      auto hostId = hostIdOrphan.get();\n      hostId.setSide(rpc::twoparty::Side::SERVER);\n\n      auto objectId = message.getRoot<AnyPointer>();\n      objectId.setAs<Text>(name);\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n      return rpcSystem.restore(hostId, objectId);\n#pragma GCC diagnostic pop\n    }",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nClientContext {\n  Capability::Client restore(kj::StringPtr name) {\n        word scratch[64];\n        memset(scratch, 0, sizeof(scratch));\n        MallocMessageBuilder message(scratch);\n  \n        auto hostIdOrphan = message.getOrphanage().newOrphan<rpc::twoparty::VatId>();\n        auto hostId = hostIdOrphan.get();\n        hostId.setSide(rpc::twoparty::Side::SERVER);\n  \n        auto objectId = message.getRoot<AnyPointer>();\n        objectId.setAs<Text>(name);\n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n        return rpcSystem.restore(hostId, objectId);\n  #pragma GCC diagnostic pop\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref.getObjectId",
          "args": [],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref.getObjectId",
          "args": [
            "tag"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref.getObjectId",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref.getObjectId",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostId.setHost",
          "args": [
            "\"server\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref.initHostId",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refMessage.initRoot<test::TestSturdyRef>",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
  },
  {
    "function_name": "TestContext",
    "container": "TestContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "459-466",
    "snippet": "TestContext(Capability::Client bootstrap,\n              RealmGateway<test::TestSturdyRef, Text>::Client gateway,\n              bool)\n      : waitScope(loop),\n        clientNetwork(network.add(\"client\")),\n        serverNetwork(network.add(\"server\")),\n        rpcClient(makeRpcClient(clientNetwork)),\n        rpcServer(makeRpcServer(serverNetwork, bootstrap, gateway)) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeRpcServer",
          "args": [
            "serverNetwork",
            "bootstrap",
            "gateway"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "382-387",
          "snippet": "RpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    Capability::Client bootstrapInterface, RealmGatewayClient gateway) {\n  return RpcSystem<VatId>(network, kj::mv(bootstrapInterface),\n      gateway.template castAs<RealmGateway<>>());\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    Capability::Client bootstrapInterface, RealmGatewayClient gateway) {\n  return RpcSystem<VatId>(network, kj::mv(bootstrapInterface),\n      gateway.template castAs<RealmGateway<>>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeRpcClient",
          "args": [
            "clientNetwork"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "399-402",
          "snippet": "RpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "network.add",
          "args": [
            "\"server\""
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  TestContext(Capability::Client bootstrap,\n                RealmGateway<test::TestSturdyRef, Text>::Client gateway,\n                bool)\n        : waitScope(loop),\n          clientNetwork(network.add(\"client\")),\n          serverNetwork(network.add(\"server\")),\n          rpcClient(makeRpcClient(clientNetwork)),\n          rpcServer(makeRpcServer(serverNetwork, bootstrap, gateway)) {}\n}"
  },
  {
    "function_name": "TestContext",
    "container": "TestContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "452-458",
    "snippet": "TestContext(Capability::Client bootstrap,\n              RealmGateway<test::TestSturdyRef, Text>::Client gateway)\n      : waitScope(loop),\n        clientNetwork(network.add(\"client\")),\n        serverNetwork(network.add(\"server\")),\n        rpcClient(makeRpcClient(clientNetwork, gateway)),\n        rpcServer(makeRpcServer(serverNetwork, bootstrap)) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeRpcServer",
          "args": [
            "serverNetwork",
            "bootstrap"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "391-395",
          "snippet": "RpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    SturdyRefRestorer<LocalSturdyRefObjectId>& restorer) {\n  return RpcSystem<VatId>(network, restorer);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    SturdyRefRestorer<LocalSturdyRefObjectId>& restorer) {\n  return RpcSystem<VatId>(network, restorer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeRpcClient",
          "args": [
            "clientNetwork",
            "gateway"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "407-411",
          "snippet": "RpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    RealmGatewayClient gateway) {\n  return RpcSystem<VatId>(network, nullptr, gateway.template castAs<RealmGateway<>>());\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    RealmGatewayClient gateway) {\n  return RpcSystem<VatId>(network, nullptr, gateway.template castAs<RealmGateway<>>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "network.add",
          "args": [
            "\"server\""
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  TestContext(Capability::Client bootstrap,\n                RealmGateway<test::TestSturdyRef, Text>::Client gateway)\n        : waitScope(loop),\n          clientNetwork(network.add(\"client\")),\n          serverNetwork(network.add(\"server\")),\n          rpcClient(makeRpcClient(clientNetwork, gateway)),\n          rpcServer(makeRpcServer(serverNetwork, bootstrap)) {}\n}"
  },
  {
    "function_name": "TestContext",
    "container": "TestContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "446-451",
    "snippet": "TestContext()\n      : waitScope(loop),\n        clientNetwork(network.add(\"client\")),\n        serverNetwork(network.add(\"server\")),\n        rpcClient(makeRpcClient(clientNetwork)),\n        rpcServer(makeRpcServer(serverNetwork, restorer)) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeRpcServer",
          "args": [
            "serverNetwork",
            "restorer"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "391-395",
          "snippet": "RpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    SturdyRefRestorer<LocalSturdyRefObjectId>& restorer) {\n  return RpcSystem<VatId>(network, restorer);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    SturdyRefRestorer<LocalSturdyRefObjectId>& restorer) {\n  return RpcSystem<VatId>(network, restorer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "makeRpcClient",
          "args": [
            "clientNetwork"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "399-402",
          "snippet": "RpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "network.add",
          "args": [
            "\"server\""
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  TestContext()\n        : waitScope(loop),\n          clientNetwork(network.add(\"client\")),\n          serverNetwork(network.add(\"server\")),\n          rpcClient(makeRpcClient(clientNetwork)),\n          rpcServer(makeRpcServer(serverNetwork, restorer)) {}\n}"
  },
  {
    "function_name": "restore",
    "container": "TestRestorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "417-433",
    "snippet": "Capability::Client restore(test::TestSturdyRefObjectId::Reader objectId) override {\n    switch (objectId.getTag()) {\n      case test::TestSturdyRefObjectId::Tag::TEST_INTERFACE:\n        return kj::heap<TestInterfaceImpl>(callCount);\n      case test::TestSturdyRefObjectId::Tag::TEST_EXTENDS:\n        return Capability::Client(newBrokenCap(\"No TestExtends implemented.\"));\n      case test::TestSturdyRefObjectId::Tag::TEST_PIPELINE:\n        return kj::heap<TestPipelineImpl>(callCount);\n      case test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLEE:\n        return kj::heap<TestTailCalleeImpl>(callCount);\n      case test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLER:\n        return kj::heap<TestTailCallerImpl>(callCount);\n      case test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF:\n        return kj::heap<TestMoreStuffImpl>(callCount, handleCount);\n    }\n    KJ_UNREACHABLE;\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<TestMoreStuffImpl>",
          "args": [
            "callCount",
            "handleCount"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestTailCallerImpl>",
          "args": [
            "callCount"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Capability::Client",
          "args": [
            "newBrokenCap(\"No TestExtends implemented.\")"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "\"No TestExtends implemented.\""
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "objectId.getTag",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestRestorer {\n  Capability::Client restore(test::TestSturdyRefObjectId::Reader objectId) override {\n      switch (objectId.getTag()) {\n        case test::TestSturdyRefObjectId::Tag::TEST_INTERFACE:\n          return kj::heap<TestInterfaceImpl>(callCount);\n        case test::TestSturdyRefObjectId::Tag::TEST_EXTENDS:\n          return Capability::Client(newBrokenCap(\"No TestExtends implemented.\"));\n        case test::TestSturdyRefObjectId::Tag::TEST_PIPELINE:\n          return kj::heap<TestPipelineImpl>(callCount);\n        case test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLEE:\n          return kj::heap<TestTailCalleeImpl>(callCount);\n        case test::TestSturdyRefObjectId::Tag::TEST_TAIL_CALLER:\n          return kj::heap<TestTailCallerImpl>(callCount);\n        case test::TestSturdyRefObjectId::Tag::TEST_MORE_STUFF:\n          return kj::heap<TestMoreStuffImpl>(callCount, handleCount);\n      }\n      KJ_UNREACHABLE;\n    }\n}"
  },
  {
    "function_name": "TestNetwork::~TestNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "404-404",
    "snippet": "TestNetwork::~TestNetwork() noexcept(false) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetwork::~TestNetwork() noexcept(false) {}"
  },
  {
    "function_name": "accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "382-392",
    "snippet": "kj::Promise<kj::Own<Connection>> accept() override {\n    if (connectionQueue.empty()) {\n      auto paf = kj::newPromiseAndFulfiller<kj::Own<Connection>>();\n      fulfillerQueue.push(kj::mv(paf.fulfiller));\n      return kj::mv(paf.promise);\n    } else {\n      auto result = kj::mv(connectionQueue.front());\n      connectionQueue.pop();\n      return kj::mv(result);\n    }\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionQueue.pop",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connectionQueue.front()"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionQueue.front",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fulfillerQueue.push",
          "args": [
            "kj::mv(paf.fulfiller)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<kj::Own<Connection>>",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectionQueue.empty",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "53-53",
          "snippet": "inline bool empty() const { return size() == 0; }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline bool empty() const { return size() == 0; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nkj::Promise<kj::Own<Connection>> accept() override {\n    if (connectionQueue.empty()) {\n      auto paf = kj::newPromiseAndFulfiller<kj::Own<Connection>>();\n      fulfillerQueue.push(kj::mv(paf.fulfiller));\n      return kj::mv(paf.promise);\n    } else {\n      auto result = kj::mv(connectionQueue.front());\n      connectionQueue.pop();\n      return kj::mv(result);\n    }\n  }"
  },
  {
    "function_name": "connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "357-380",
    "snippet": "kj::Maybe<kj::Own<Connection>> connect(test::TestSturdyRefHostId::Reader hostId) override {\n    TestNetworkAdapter& dst = KJ_REQUIRE_NONNULL(network.find(hostId.getHost()));\n\n    auto iter = connections.find(&dst);\n    if (iter == connections.end()) {\n      auto local = kj::refcounted<ConnectionImpl>(*this, RpcDumper::CLIENT);\n      auto remote = kj::refcounted<ConnectionImpl>(dst, RpcDumper::SERVER);\n      local->attach(*remote);\n\n      connections[&dst] = kj::addRef(*local);\n      dst.connections[this] = kj::addRef(*remote);\n\n      if (dst.fulfillerQueue.empty()) {\n        dst.connectionQueue.push(kj::mv(remote));\n      } else {\n        dst.fulfillerQueue.front()->fulfill(kj::mv(remote));\n        dst.fulfillerQueue.pop();\n      }\n\n      return kj::Own<Connection>(kj::mv(local));\n    } else {\n      return kj::Own<Connection>(kj::addRef(*iter->second));\n    }\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::Own<Connection>",
          "args": [
            "kj::addRef(*iter->second)"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "Own",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "181-181",
          "snippet": "inline explicit Own(decltype(nullptr)): disposer(nullptr), ptr(nullptr) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline explicit Own(decltype(nullptr)): disposer(nullptr), ptr(nullptr) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*iter->second"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "local"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.fulfillerQueue.pop",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.fulfillerQueue.front",
          "args": [
            "kj::mv(remote)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "remote"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.fulfillerQueue.front",
          "args": [],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.connectionQueue.push",
          "args": [
            "kj::mv(remote)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "remote"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.fulfillerQueue.empty",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "53-53",
          "snippet": "inline bool empty() const { return size() == 0; }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline bool empty() const { return size() == 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "local->attach",
          "args": [
            "*remote"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "attach",
          "container": "TestNetworkAdapter::ConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "219-224",
          "snippet": "void attach(ConnectionImpl& other) {\n      KJ_REQUIRE(partner == nullptr);\n      KJ_REQUIRE(other.partner == nullptr);\n      partner = other;\n      other.partner = *this;\n    }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    void attach(ConnectionImpl& other) {\n          KJ_REQUIRE(partner == nullptr);\n          KJ_REQUIRE(other.partner == nullptr);\n          partner = other;\n          other.partner = *this;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<ConnectionImpl>",
          "args": [
            "dst",
            "RpcDumper::SERVER"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<ConnectionImpl>",
          "args": [
            "*this",
            "RpcDumper::CLIENT"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connections.end",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "connections.find",
          "args": [
            "&dst"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "TestNetwork",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "178-185",
          "snippet": "kj::Maybe<TestNetworkAdapter&> find(kj::StringPtr name) {\n    auto iter = map.find(name);\n    if (iter == map.end()) {\n      return nullptr;\n    } else {\n      return *iter->second;\n    }\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetwork {\n  kj::Maybe<TestNetworkAdapter&> find(kj::StringPtr name) {\n      auto iter = map.find(name);\n      if (iter == map.end()) {\n        return nullptr;\n      } else {\n        return *iter->second;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE_NONNULL",
          "args": [
            "network.find(hostId.getHost())"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostId.getHost",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<Connection>> connect(test::TestSturdyRefHostId::Reader hostId) override {\n    TestNetworkAdapter& dst = KJ_REQUIRE_NONNULL(network.find(hostId.getHost()));\n\n    auto iter = connections.find(&dst);\n    if (iter == connections.end()) {\n      auto local = kj::refcounted<ConnectionImpl>(*this, RpcDumper::CLIENT);\n      auto remote = kj::refcounted<ConnectionImpl>(dst, RpcDumper::SERVER);\n      local->attach(*remote);\n\n      connections[&dst] = kj::addRef(*local);\n      dst.connections[this] = kj::addRef(*remote);\n\n      if (dst.fulfillerQueue.empty()) {\n        dst.connectionQueue.push(kj::mv(remote));\n      } else {\n        dst.fulfillerQueue.front()->fulfill(kj::mv(remote));\n        dst.fulfillerQueue.pop();\n      }\n\n      return kj::Own<Connection>(kj::mv(local));\n    } else {\n      return kj::Own<Connection>(kj::addRef(*iter->second));\n    }\n  }"
  },
  {
    "function_name": "taskFailed",
    "container": "TestNetworkAdapter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "339-341",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n      ADD_FAILURE() << kj::str(exception).cStr();\n    }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "331-339",
          "snippet": "String str(Params&&... params) {\n  // Magic function which builds a string from a bunch of arbitrary values.  Example:\n  //     str(1, \" / \", 2, \" = \", 0.5)\n  // returns:\n  //     \"1 / 2 = 0.5\"\n  // To teach `str` how to stringify a type, see `Stringifier`.\n\n  return _::concat(toCharSequence(kj::fwd<Params>(params))...);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString str(Params&&... params) {\n  // Magic function which builds a string from a bunch of arbitrary values.  Example:\n  //     str(1, \" / \", 2, \" = \", 0.5)\n  // returns:\n  //     \"1 / 2 = 0.5\"\n  // To teach `str` how to stringify a type, see `Stringifier`.\n\n  return _::concat(toCharSequence(kj::fwd<Params>(params))...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ADD_FAILURE",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  void taskFailed(kj::Exception&& exception) override {\n        ADD_FAILURE() << kj::str(exception).cStr();\n      }\n}"
  },
  {
    "function_name": "receiveIncomingMessage",
    "container": "TestNetworkAdapter::ConnectionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "308-322",
    "snippet": "kj::Promise<kj::Maybe<kj::Own<IncomingRpcMessage>>> receiveIncomingMessage() override {\n      KJ_IF_MAYBE(e, networkException) {\n        return kj::cp(*e);\n      }\n\n      if (messages.empty()) {\n        KJ_IF_MAYBE(f, fulfillOnEnd) {\n          f->get()->fulfill();\n          return kj::Maybe<kj::Own<IncomingRpcMessage>>(nullptr);\n        } else {\n          auto paf = kj::newPromiseAndFulfiller<kj::Maybe<kj::Own<IncomingRpcMessage>>>();\n          fulfillers.push(kj::mv(paf.fulfiller));\n          return kj::mv(paf.promise);\n        }\n      }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fulfillers.push",
          "args": [
            "kj::mv(paf.fulfiller)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<kj::Maybe<kj::Own<IncomingRpcMessage>>>",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Maybe<kj::Own<IncomingRpcMessage>>",
          "args": [
            "nullptr"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->get",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "messages.empty",
          "args": [],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "53-53",
          "snippet": "inline bool empty() const { return size() == 0; }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline bool empty() const { return size() == 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "*e"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    kj::Promise<kj::Maybe<kj::Own<IncomingRpcMessage>>> receiveIncomingMessage() override {\n          KJ_IF_MAYBE(e, networkException) {\n            return kj::cp(*e);\n          }\n    \n          if (messages.empty()) {\n            KJ_IF_MAYBE(f, fulfillOnEnd) {\n              f->get()->fulfill();\n              return kj::Maybe<kj::Own<IncomingRpcMessage>>(nullptr);\n            } else {\n              auto paf = kj::newPromiseAndFulfiller<kj::Maybe<kj::Own<IncomingRpcMessage>>>();\n              fulfillers.push(kj::mv(paf.fulfiller));\n              return kj::mv(paf.promise);\n            }\n          }\n  }\n}"
  },
  {
    "function_name": "newOutgoingMessage",
    "container": "TestNetworkAdapter::ConnectionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "305-307",
    "snippet": "kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override {\n      return kj::heap<OutgoingRpcMessageImpl>(*this, firstSegmentWordSize);\n    }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<OutgoingRpcMessageImpl>",
          "args": [
            "*this",
            "firstSegmentWordSize"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    kj::Own<OutgoingRpcMessage> newOutgoingMessage(uint firstSegmentWordSize) override {\n          return kj::heap<OutgoingRpcMessageImpl>(*this, firstSegmentWordSize);\n        }\n  }\n}"
  },
  {
    "function_name": "send",
    "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "270-298",
    "snippet": "void send() override {\n        if (connection.networkException != nullptr) {\n          return;\n        }\n\n        ++connection.network.sent;\n\n        // Uncomment to get a debug dump.\n//        kj::String msg = connection.network.network.dumper.dump(\n//            message.getRoot<rpc::Message>(), connection.sender);\n//        KJ_ DBG(msg);\n\n        auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n\n        auto connectionPtr = &connection;\n        connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n            [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n          KJ_IF_MAYBE(p, connectionPtr->partner) {\n            if (p->fulfillers.empty()) {\n              p->messages.push(kj::mv(message));\n            } else {\n              ++p->network.received;\n              p->fulfillers.front()->fulfill(\n                  kj::Own<IncomingRpcMessage>(kj::mv(message)));\n              p->fulfillers.pop();\n            }\n          }\n        })));\n      }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connection.tasks->add",
          "args": [
            "kj::evalLater(kj::mvCapture(incomingMessage,\n            [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n          KJ_IF_MAYBE(p, connectionPtr->partner) {\n            if (p->fulfillers.empty()) {\n              p->messages.push(kj::mv(message));\n            } else {\n              ++p->network.received;\n              p->fulfillers.front()->fulfill(\n                  kj::Own<IncomingRpcMessage>(kj::mv(message)));\n              p->fulfillers.pop();\n            }\n          }\n        }))"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "kj::mvCapture(incomingMessage,\n            [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n          KJ_IF_MAYBE(p, connectionPtr->partner) {\n            if (p->fulfillers.empty()) {\n              p->messages.push(kj::mv(message));\n            } else {\n              ++p->network.received;\n              p->fulfillers.front()->fulfill(\n                  kj::Own<IncomingRpcMessage>(kj::mv(message)));\n              p->fulfillers.pop();\n            }\n          }\n        })"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "incomingMessage",
            "[connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n          KJ_IF_MAYBE(p, connectionPtr->partner) {\n            if (p->fulfillers.empty()) {\n              p->messages.push(kj::mv(message));\n            } else {\n              ++p->network.received;\n              p->fulfillers.front()->fulfill(\n                  kj::Own<IncomingRpcMessage>(kj::mv(message)));\n              p->fulfillers.pop();\n            }\n          }\n        }"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->fulfillers.pop",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->fulfillers.front",
          "args": [
            "kj::Own<IncomingRpcMessage>(kj::mv(message))"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Own<IncomingRpcMessage>",
          "args": [
            "kj::mv(message)"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "Own",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "181-181",
          "snippet": "inline explicit Own(decltype(nullptr)): disposer(nullptr), ptr(nullptr) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline explicit Own(decltype(nullptr)): disposer(nullptr), ptr(nullptr) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->fulfillers.front",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->messages.push",
          "args": [
            "kj::mv(message)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->fulfillers.empty",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "53-53",
          "snippet": "inline bool empty() const { return size() == 0; }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline bool empty() const { return size() == 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "p",
            "connectionPtr->partner"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<IncomingRpcMessageImpl>",
          "args": [
            "messageToFlatArray(message)"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "messageToFlatArray",
          "args": [
            "message"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "messageToFlatArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
          "lines": "100-130",
          "snippet": "kj::Array<word> messageToFlatArray(kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  kj::Array<word> result = kj::heapArray<word>(computeSerializedSizeInWords(segments));\n\n  _::WireValue<uint32_t>* table =\n      reinterpret_cast<_::WireValue<uint32_t>*>(result.begin());\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  table[0].set(segments.size() - 1);\n\n  for (uint i = 0; i < segments.size(); i++) {\n    table[i + 1].set(segments[i].size());\n  }\n\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    table[segments.size() + 1].set(0);\n  }\n\n  word* dst = result.begin() + segments.size() / 2 + 1;\n\n  for (auto& segment: segments) {\n    memcpy(dst, segment.begin(), segment.size() * sizeof(word));\n    dst += segment.size();\n  }\n\n  KJ_DASSERT(dst == result.end(), \"Buffer overrun/underrun bug in code above.\");\n\n  return kj::mv(result);\n}",
          "includes": [
            "#include <exception>",
            "#include <kj/debug.h>",
            "#include \"layout.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nkj::Array<word> messageToFlatArray(kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  kj::Array<word> result = kj::heapArray<word>(computeSerializedSizeInWords(segments));\n\n  _::WireValue<uint32_t>* table =\n      reinterpret_cast<_::WireValue<uint32_t>*>(result.begin());\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  table[0].set(segments.size() - 1);\n\n  for (uint i = 0; i < segments.size(); i++) {\n    table[i + 1].set(segments[i].size());\n  }\n\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    table[segments.size() + 1].set(0);\n  }\n\n  word* dst = result.begin() + segments.size() / 2 + 1;\n\n  for (auto& segment: segments) {\n    memcpy(dst, segment.begin(), segment.size() * sizeof(word));\n    dst += segment.size();\n  }\n\n  KJ_DASSERT(dst == result.end(), \"Buffer overrun/underrun bug in code above.\");\n\n  return kj::mv(result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      void send() override {\n              if (connection.networkException != nullptr) {\n                return;\n              }\n      \n              ++connection.network.sent;\n      \n              // Uncomment to get a debug dump.\n      //        kj::String msg = connection.network.network.dumper.dump(\n      //            message.getRoot<rpc::Message>(), connection.sender);\n      //        KJ_ DBG(msg);\n      \n              auto incomingMessage = kj::heap<IncomingRpcMessageImpl>(messageToFlatArray(message));\n      \n              auto connectionPtr = &connection;\n              connection.tasks->add(kj::evalLater(kj::mvCapture(incomingMessage,\n                  [connectionPtr](kj::Own<IncomingRpcMessageImpl>&& message) {\n                KJ_IF_MAYBE(p, connectionPtr->partner) {\n                  if (p->fulfillers.empty()) {\n                    p->messages.push(kj::mv(message));\n                  } else {\n                    ++p->network.received;\n                    p->fulfillers.front()->fulfill(\n                        kj::Own<IncomingRpcMessage>(kj::mv(message)));\n                    p->fulfillers.pop();\n                  }\n                }\n              })));\n            }\n    }\n  }\n}"
  },
  {
    "function_name": "getCapTable",
    "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "266-268",
    "snippet": "kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() override {\n        return message.getCapTable();\n      }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() override {\n              return message.getCapTable();\n            }\n    }\n  }\n}"
  },
  {
    "function_name": "getBody",
    "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "262-264",
    "snippet": "AnyPointer::Builder getBody() override {\n        return message.getRoot<AnyPointer>();\n      }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message.getRoot<AnyPointer>",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      AnyPointer::Builder getBody() override {\n              return message.getRoot<AnyPointer>();\n            }\n    }\n  }\n}"
  },
  {
    "function_name": "OutgoingRpcMessageImpl",
    "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "257-260",
    "snippet": "OutgoingRpcMessageImpl(ConnectionImpl& connection, uint firstSegmentWordSize)\n          : connection(connection),\n            message(firstSegmentWordSize == 0 ? SUGGESTED_FIRST_SEGMENT_WORDS\n                                              : firstSegmentWordSize) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      OutgoingRpcMessageImpl(ConnectionImpl& connection, uint firstSegmentWordSize)\n                : connection(connection),\n                  message(firstSegmentWordSize == 0 ? SUGGESTED_FIRST_SEGMENT_WORDS\n                                                    : firstSegmentWordSize) {}\n    }\n  }\n}"
  },
  {
    "function_name": "initCapTable",
    "container": "TestNetworkAdapter::ConnectionImpl::IncomingRpcMessageImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "247-249",
    "snippet": "void initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>>&& capTable) override {\n        message.initCapTable(kj::mv(capTable));\n      }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "capTable"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    IncomingRpcMessageImpl {\n      void initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>>&& capTable) override {\n              message.initCapTable(kj::mv(capTable));\n            }\n    }\n  }\n}"
  },
  {
    "function_name": "getBody",
    "container": "TestNetworkAdapter::ConnectionImpl::IncomingRpcMessageImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "243-245",
    "snippet": "AnyPointer::Reader getBody() override {\n        return message.getRoot<AnyPointer>();\n      }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message.getRoot<AnyPointer>",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    IncomingRpcMessageImpl {\n      AnyPointer::Reader getBody() override {\n              return message.getRoot<AnyPointer>();\n            }\n    }\n  }\n}"
  },
  {
    "function_name": "IncomingRpcMessageImpl",
    "container": "TestNetworkAdapter::ConnectionImpl::IncomingRpcMessageImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "239-241",
    "snippet": "IncomingRpcMessageImpl(kj::Array<word> data)\n          : data(kj::mv(data)),\n            message(this->data) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "data"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    IncomingRpcMessageImpl {\n      IncomingRpcMessageImpl(kj::Array<word> data)\n                : data(kj::mv(data)),\n                  message(this->data) {}\n    }\n  }\n}"
  },
  {
    "function_name": "disconnect",
    "container": "TestNetworkAdapter::ConnectionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "226-235",
    "snippet": "void disconnect(kj::Exception&& exception) {\n      while (!fulfillers.empty()) {\n        fulfillers.front()->reject(kj::cp(exception));\n        fulfillers.pop();\n      }\n\n      networkException = kj::mv(exception);\n\n      tasks = nullptr;\n    }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fulfillers.pop",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fulfillers.front",
          "args": [
            "kj::cp(exception)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "exception"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      },
      {
        "call_info": {
          "callee": "fulfillers.front",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fulfillers.empty",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "53-53",
          "snippet": "inline bool empty() const { return size() == 0; }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline bool empty() const { return size() == 0; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    void disconnect(kj::Exception&& exception) {\n          while (!fulfillers.empty()) {\n            fulfillers.front()->reject(kj::cp(exception));\n            fulfillers.pop();\n          }\n    \n          networkException = kj::mv(exception);\n    \n          tasks = nullptr;\n        }\n  }\n}"
  },
  {
    "function_name": "attach",
    "container": "TestNetworkAdapter::ConnectionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "219-224",
    "snippet": "void attach(ConnectionImpl& other) {\n      KJ_REQUIRE(partner == nullptr);\n      KJ_REQUIRE(other.partner == nullptr);\n      partner = other;\n      other.partner = *this;\n    }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "other.partner == nullptr"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "partner == nullptr"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    void attach(ConnectionImpl& other) {\n          KJ_REQUIRE(partner == nullptr);\n          KJ_REQUIRE(other.partner == nullptr);\n          partner = other;\n          other.partner = *this;\n        }\n  }\n}"
  },
  {
    "function_name": "ConnectionImpl",
    "container": "TestNetworkAdapter::ConnectionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "216-217",
    "snippet": "ConnectionImpl(TestNetworkAdapter& network, RpcDumper::Sender sender)\n        : network(network), sender(sender), tasks(kj::heap<kj::TaskSet>(*this)) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<kj::TaskSet>",
          "args": [
            "*this"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    ConnectionImpl(TestNetworkAdapter& network, RpcDumper::Sender sender)\n            : network(network), sender(sender), tasks(kj::heap<kj::TaskSet>(*this)) {}\n  }\n}"
  },
  {
    "function_name": "getReceivedCount",
    "container": "TestNetworkAdapter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "209-209",
    "snippet": "uint getReceivedCount() { return received; }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  uint getReceivedCount() { return received; }\n}"
  },
  {
    "function_name": "getSentCount",
    "container": "TestNetworkAdapter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "208-208",
    "snippet": "uint getSentCount() { return sent; }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  uint getSentCount() { return sent; }\n}"
  },
  {
    "function_name": "TestNetworkAdapter",
    "container": "TestNetworkAdapter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "199-199",
    "snippet": "TestNetworkAdapter(TestNetwork& network): network(network) {}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  TestNetworkAdapter(TestNetwork& network): network(network) {}\n}"
  },
  {
    "function_name": "find",
    "container": "TestNetwork",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "178-185",
    "snippet": "kj::Maybe<TestNetworkAdapter&> find(kj::StringPtr name) {\n    auto iter = map.find(name);\n    if (iter == map.end()) {\n      return nullptr;\n    } else {\n      return *iter->second;\n    }\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map.end",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetwork {\n  kj::Maybe<TestNetworkAdapter&> find(kj::StringPtr name) {\n      auto iter = map.find(name);\n      if (iter == map.end()) {\n        return nullptr;\n      } else {\n        return *iter->second;\n      }\n    }\n}"
  },
  {
    "function_name": "TestNetwork",
    "container": "TestNetwork",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "165-173",
    "snippet": "TestNetwork() {\n    dumper.addSchema(Schema::from<test::TestInterface>());\n    dumper.addSchema(Schema::from<test::TestExtends>());\n    dumper.addSchema(Schema::from<test::TestPipeline>());\n    dumper.addSchema(Schema::from<test::TestCallOrder>());\n    dumper.addSchema(Schema::from<test::TestTailCallee>());\n    dumper.addSchema(Schema::from<test::TestTailCaller>());\n    dumper.addSchema(Schema::from<test::TestMoreStuff>());\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dumper.addSchema",
          "args": [
            "Schema::from<test::TestMoreStuff>()"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "addSchema",
          "container": "RpcDumper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "54-56",
          "snippet": "void addSchema(InterfaceSchema schema) {\n    schemas[schema.getProto().getId()] = schema;\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nRpcDumper {\n  void addSchema(InterfaceSchema schema) {\n      schemas[schema.getProto().getId()] = schema;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Schema::from<test::TestMoreStuff>",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetwork {\n  TestNetwork() {\n      dumper.addSchema(Schema::from<test::TestInterface>());\n      dumper.addSchema(Schema::from<test::TestExtends>());\n      dumper.addSchema(Schema::from<test::TestPipeline>());\n      dumper.addSchema(Schema::from<test::TestCallOrder>());\n      dumper.addSchema(Schema::from<test::TestTailCallee>());\n      dumper.addSchema(Schema::from<test::TestTailCaller>());\n      dumper.addSchema(Schema::from<test::TestMoreStuff>());\n    }\n}"
  },
  {
    "function_name": "dump",
    "container": "RpcDumper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "63-152",
    "snippet": "kj::String dump(rpc::Message::Reader message, Sender sender) {\n    const char* senderName = sender == CLIENT ? \"client\" : \"server\";\n\n    switch (message.which()) {\n      case rpc::Message::CALL: {\n        auto call = message.getCall();\n        auto iter = schemas.find(call.getInterfaceId());\n        if (iter == schemas.end()) {\n          break;\n        }\n        InterfaceSchema schema = iter->second;\n        auto methods = schema.getMethods();\n        if (call.getMethodId() >= methods.size()) {\n          break;\n        }\n        InterfaceSchema::Method method = methods[call.getMethodId()];\n\n        auto schemaProto = schema.getProto();\n        auto interfaceName =\n            schemaProto.getDisplayName().slice(schemaProto.getDisplayNamePrefixLength());\n\n        auto methodProto = method.getProto();\n        auto paramType = method.getParamType();\n        auto resultType = method.getResultType();\n\n        if (call.getSendResultsTo().isCaller()) {\n          returnTypes[std::make_pair(sender, call.getQuestionId())] = resultType;\n        }\n\n        auto payload = call.getParams();\n        auto params = kj::str(payload.getContent().getAs<DynamicStruct>(paramType));\n\n        auto sendResultsTo = call.getSendResultsTo();\n\n        return kj::str(senderName, \"(\", call.getQuestionId(), \"): call \",\n                       call.getTarget(), \" <- \", interfaceName, \".\",\n                       methodProto.getName(), params,\n                       \" caps:[\", kj::strArray(payload.getCapTable(), \", \"), \"]\",\n                       sendResultsTo.isCaller() ? kj::str()\n                                                : kj::str(\" sendResultsTo:\", sendResultsTo));\n      }\n\n      case rpc::Message::RETURN: {\n        auto ret = message.getReturn();\n\n        auto iter = returnTypes.find(\n            std::make_pair(sender == CLIENT ? SERVER : CLIENT, ret.getAnswerId()));\n        if (iter == returnTypes.end()) {\n          break;\n        }\n\n        auto schema = iter->second;\n        returnTypes.erase(iter);\n        if (ret.which() != rpc::Return::RESULTS) {\n          // Oops, no results returned.  We don't check this earlier because we want to make sure\n          // returnTypes.erase() gets a chance to happen.\n          break;\n        }\n\n        auto payload = ret.getResults();\n\n        if (schema.getProto().isStruct()) {\n          auto results = kj::str(payload.getContent().getAs<DynamicStruct>(schema.asStruct()));\n\n          return kj::str(senderName, \"(\", ret.getAnswerId(), \"): return \", results,\n                         \" caps:[\", kj::strArray(payload.getCapTable(), \", \"), \"]\");\n        } else if (schema.getProto().isInterface()) {\n          payload.getContent().getAs<DynamicCapability>(schema.asInterface());\n          return kj::str(senderName, \"(\", ret.getAnswerId(), \"): return cap \",\n                         kj::strArray(payload.getCapTable(), \", \"));\n        } else {\n          break;\n        }\n      }\n\n      case rpc::Message::BOOTSTRAP: {\n        auto restore = message.getBootstrap();\n\n        returnTypes[std::make_pair(sender, restore.getQuestionId())] = InterfaceSchema();\n\n        return kj::str(senderName, \"(\", restore.getQuestionId(), \"): bootstrap \",\n                       restore.getDeprecatedObjectId().getAs<test::TestSturdyRefObjectId>());\n      }\n\n      default:\n        break;\n    }\n\n    return kj::str(senderName, \": \", message);\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "senderName",
            "\": \"",
            "message"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "senderName",
            "\"(\"",
            "restore.getQuestionId()",
            "\"): bootstrap \"",
            "restore.getDeprecatedObjectId().getAs<test::TestSturdyRefObjectId>()"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore.getDeprecatedObjectId",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore.getDeprecatedObjectId",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore.getQuestionId",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InterfaceSchema",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "sender",
            "restore.getQuestionId()"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore.getQuestionId",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getBootstrap",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "senderName",
            "\"(\"",
            "ret.getAnswerId()",
            "\"): return cap \"",
            "kj::strArray(payload.getCapTable(), \", \")"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "payload.getCapTable()",
            "\", \""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "payload.getCapTable",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "getCapTable",
          "container": "TestNetworkAdapter::ConnectionImpl::OutgoingRpcMessageImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "266-268",
          "snippet": "kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() override {\n        return message.getCapTable();\n      }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  ConnectionImpl {\n    OutgoingRpcMessageImpl {\n      kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() override {\n              return message.getCapTable();\n            }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.getAnswerId",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "payload.getContent",
          "args": [
            "schema.asInterface()"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.asInterface",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "payload.getContent",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "getContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1232-1234",
          "snippet": "MaybeTruncated<ArrayPtr<const byte>> getContent() override {\n    return { contentBuffer.slice(0, receivedSize), contentTruncated };\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nMaybeTruncated<ArrayPtr<const byte>> getContent() override {\n    return { contentBuffer.slice(0, receivedSize), contentTruncated };\n  }"
        }
      },
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "senderName",
            "\"(\"",
            "ret.getAnswerId()",
            "\"): return \"",
            "results",
            "\" caps:[\"",
            "kj::strArray(payload.getCapTable(), \", \")",
            "\"]\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "payload.getCapTable()",
            "\", \""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.getAnswerId",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "payload.getContent().getAs<DynamicStruct>(schema.asStruct())"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "payload.getContent",
          "args": [
            "schema.asStruct()"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.asStruct",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.getResults",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ret.which",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "returnTypes.erase",
          "args": [
            "iter"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "204-216",
          "snippet": "T erase(Id id) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    if (id < kj::size(low)) {\n      T toRelease = kj::mv(low[id]);\n      low[id] = T();\n      return toRelease;\n    } else {\n      T toRelease = kj::mv(high[id]);\n      high.erase(id);\n      return toRelease;\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  T erase(Id id) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      if (id < kj::size(low)) {\n        T toRelease = kj::mv(low[id]);\n        low[id] = T();\n        return toRelease;\n      } else {\n        T toRelease = kj::mv(high[id]);\n        high.erase(id);\n        return toRelease;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "returnTypes.end",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "returnTypes.find",
          "args": [
            "std::make_pair(sender == CLIENT ? SERVER : CLIENT, ret.getAnswerId())"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "TestNetwork",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "178-185",
          "snippet": "kj::Maybe<TestNetworkAdapter&> find(kj::StringPtr name) {\n    auto iter = map.find(name);\n    if (iter == map.end()) {\n      return nullptr;\n    } else {\n      return *iter->second;\n    }\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetwork {\n  kj::Maybe<TestNetworkAdapter&> find(kj::StringPtr name) {\n      auto iter = map.find(name);\n      if (iter == map.end()) {\n        return nullptr;\n      } else {\n        return *iter->second;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "sender == CLIENT ? SERVER : CLIENT",
            "ret.getAnswerId()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret.getAnswerId",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getReturn",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "senderName",
            "\"(\"",
            "call.getQuestionId()",
            "\"): call \"",
            "call.getTarget()",
            "\" <- \"",
            "interfaceName",
            "\".\"",
            "methodProto.getName()",
            "params",
            "\" caps:[\"",
            "kj::strArray(payload.getCapTable(), \", \")",
            "\"]\"",
            "sendResultsTo.isCaller() ? kj::str()\n                                                : kj::str(\" sendResultsTo:\", sendResultsTo)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\" sendResultsTo:\"",
            "sendResultsTo"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendResultsTo.isCaller",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strArray",
          "args": [
            "payload.getCapTable()",
            "\", \""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "methodProto.getName",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getTarget",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getQuestionId",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getSendResultsTo",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "payload.getContent",
          "args": [
            "paramType"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getParams",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "sender",
            "call.getQuestionId()"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getQuestionId",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getSendResultsTo",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getSendResultsTo",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getResultType",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getParamType",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaProto.getDisplayName",
          "args": [
            "schemaProto.getDisplayNamePrefixLength()"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaProto.getDisplayNamePrefixLength",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaProto.getDisplayName",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "call.getMethodId",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "methods.size",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "call.getMethodId",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getMethods",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getInterfaceId",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getCall",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "getCall",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1325-1327",
          "snippet": "inline rpc::Call::Builder getCall() {\n      return callBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline rpc::Call::Builder getCall() {\n        return callBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.which",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nRpcDumper {\n  kj::String dump(rpc::Message::Reader message, Sender sender) {\n      const char* senderName = sender == CLIENT ? \"client\" : \"server\";\n  \n      switch (message.which()) {\n        case rpc::Message::CALL: {\n          auto call = message.getCall();\n          auto iter = schemas.find(call.getInterfaceId());\n          if (iter == schemas.end()) {\n            break;\n          }\n          InterfaceSchema schema = iter->second;\n          auto methods = schema.getMethods();\n          if (call.getMethodId() >= methods.size()) {\n            break;\n          }\n          InterfaceSchema::Method method = methods[call.getMethodId()];\n  \n          auto schemaProto = schema.getProto();\n          auto interfaceName =\n              schemaProto.getDisplayName().slice(schemaProto.getDisplayNamePrefixLength());\n  \n          auto methodProto = method.getProto();\n          auto paramType = method.getParamType();\n          auto resultType = method.getResultType();\n  \n          if (call.getSendResultsTo().isCaller()) {\n            returnTypes[std::make_pair(sender, call.getQuestionId())] = resultType;\n          }\n  \n          auto payload = call.getParams();\n          auto params = kj::str(payload.getContent().getAs<DynamicStruct>(paramType));\n  \n          auto sendResultsTo = call.getSendResultsTo();\n  \n          return kj::str(senderName, \"(\", call.getQuestionId(), \"): call \",\n                         call.getTarget(), \" <- \", interfaceName, \".\",\n                         methodProto.getName(), params,\n                         \" caps:[\", kj::strArray(payload.getCapTable(), \", \"), \"]\",\n                         sendResultsTo.isCaller() ? kj::str()\n                                                  : kj::str(\" sendResultsTo:\", sendResultsTo));\n        }\n  \n        case rpc::Message::RETURN: {\n          auto ret = message.getReturn();\n  \n          auto iter = returnTypes.find(\n              std::make_pair(sender == CLIENT ? SERVER : CLIENT, ret.getAnswerId()));\n          if (iter == returnTypes.end()) {\n            break;\n          }\n  \n          auto schema = iter->second;\n          returnTypes.erase(iter);\n          if (ret.which() != rpc::Return::RESULTS) {\n            // Oops, no results returned.  We don't check this earlier because we want to make sure\n            // returnTypes.erase() gets a chance to happen.\n            break;\n          }\n  \n          auto payload = ret.getResults();\n  \n          if (schema.getProto().isStruct()) {\n            auto results = kj::str(payload.getContent().getAs<DynamicStruct>(schema.asStruct()));\n  \n            return kj::str(senderName, \"(\", ret.getAnswerId(), \"): return \", results,\n                           \" caps:[\", kj::strArray(payload.getCapTable(), \", \"), \"]\");\n          } else if (schema.getProto().isInterface()) {\n            payload.getContent().getAs<DynamicCapability>(schema.asInterface());\n            return kj::str(senderName, \"(\", ret.getAnswerId(), \"): return cap \",\n                           kj::strArray(payload.getCapTable(), \", \"));\n          } else {\n            break;\n          }\n        }\n  \n        case rpc::Message::BOOTSTRAP: {\n          auto restore = message.getBootstrap();\n  \n          returnTypes[std::make_pair(sender, restore.getQuestionId())] = InterfaceSchema();\n  \n          return kj::str(senderName, \"(\", restore.getQuestionId(), \"): bootstrap \",\n                         restore.getDeprecatedObjectId().getAs<test::TestSturdyRefObjectId>());\n        }\n  \n        default:\n          break;\n      }\n  \n      return kj::str(senderName, \": \", message);\n    }\n}"
  },
  {
    "function_name": "addSchema",
    "container": "RpcDumper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "54-56",
    "snippet": "void addSchema(InterfaceSchema schema) {\n    schemas[schema.getProto().getId()] = schema;\n  }",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nRpcDumper {\n  void addSchema(InterfaceSchema schema) {\n      schemas[schema.getProto().getId()] = schema;\n    }\n}"
  },
  {
    "function_name": "KJ_STRINGIFY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
    "lines": "36-38",
    "snippet": "inline kj::String KJ_STRINGIFY(Message::Which which) {\n  return kj::str(static_cast<uint16_t>(which));\n}",
    "includes": [
      "#include <queue>",
      "#include <map>",
      "#include <capnp/rpc.capnp.h>",
      "#include <kj/compat/gtest.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/debug.h>",
      "#include \"serialize.h\"",
      "#include \"schema.h\"",
      "#include \"test-util.h\"",
      "#include \"rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "static_cast<uint16_t>(which)"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint16_t>",
          "args": [
            "which"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\ninline kj::String KJ_STRINGIFY(Message::Which which) {\n  return kj::str(static_cast<uint16_t>(which));\n}"
  }
]