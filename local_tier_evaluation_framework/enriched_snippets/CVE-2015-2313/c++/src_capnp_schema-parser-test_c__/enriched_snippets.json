[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
    "lines": "143-182",
    "snippet": "TEST(SchemaParser, Constants) {\n  // This is actually a test of the full dynamic API stack for constants, because the schemas for\n  // constants are not actually accessible from the generated code API, so the only way to ever\n  // get a ConstSchema is by parsing it.\n\n  SchemaParser parser;\n  FakeFileReader reader;\n\n  reader.add(\"const.capnp\",\n      \"@0x8123456789abcdef;\\n\"\n      \"const uint32Const :UInt32 = 1234;\\n\"\n      \"const listConst :List(Float32) = [1.25, 2.5, 3e4];\\n\"\n      \"const structConst :Foo = (bar = 123, baz = \\\"qux\\\");\\n\"\n      \"struct Foo {\\n\"\n      \"  bar @0 :Int16;\\n\"\n      \"  baz @1 :Text;\\n\"\n      \"}\\n\"\n      \"const genericConst :TestGeneric(Text) = (value = \\\"text\\\");\\n\"\n      \"struct TestGeneric(T) {\\n\"\n      \"  value @0 :T;\\n\"\n      \"}\\n\");\n\n  ParsedSchema fileSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"const.capnp\", \"const.capnp\", nullptr, reader));\n\n  EXPECT_EQ(1234, fileSchema.getNested(\"uint32Const\").asConst().as<uint32_t>());\n\n  auto list = fileSchema.getNested(\"listConst\").asConst().as<DynamicList>();\n  ASSERT_EQ(3u, list.size());\n  EXPECT_EQ(1.25, list[0].as<float>());\n  EXPECT_EQ(2.5, list[1].as<float>());\n  EXPECT_EQ(3e4f, list[2].as<float>());\n\n  auto structConst = fileSchema.getNested(\"structConst\").asConst().as<DynamicStruct>();\n  EXPECT_EQ(123, structConst.get(\"bar\").as<int16_t>());\n  EXPECT_EQ(\"qux\", structConst.get(\"baz\").as<Text>());\n\n  auto genericConst = fileSchema.getNested(\"genericConst\").asConst().as<DynamicStruct>();\n  EXPECT_EQ(\"text\", genericConst.get(\"value\").as<Text>());\n}",
    "includes": [
      "#include <map>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include <kj/compat/gtest.h>",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"text\"",
            "genericConst.get(\"value\").as<Text>()"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genericConst.get",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "genericConst.get",
          "args": [
            "\"value\""
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [
            "\"genericConst\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"qux\"",
            "structConst.get(\"baz\").as<Text>()"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "structConst.get(\"bar\").as<int16_t>()"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [
            "\"structConst\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3e4f",
            "list[2].as<float>()"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list[2].as<float>",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "2.5",
            "list[1].as<float>()"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1.25",
            "list[0].as<float>()"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "3u",
            "list.size()"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list.size",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [
            "\"listConst\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1234",
            "fileSchema.getNested(\"uint32Const\").asConst().as<uint32_t>()"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileSchema.getNested",
          "args": [
            "\"uint32Const\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parseFile",
          "args": [
            "SchemaFile::newDiskFile(\n      \"const.capnp\", \"const.capnp\", nullptr, reader)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SchemaFile::newDiskFile",
          "args": [
            "\"const.capnp\"",
            "\"const.capnp\"",
            "nullptr",
            "reader"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaFile::newDiskFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "476-482",
          "snippet": "kj::Own<SchemaFile> SchemaFile::newDiskFile(\n    kj::StringPtr displayName, kj::StringPtr diskPath,\n    kj::ArrayPtr<const kj::StringPtr> importPath,\n    const FileReader& fileReader) {\n  return kj::heap<DiskSchemaFile>(fileReader, canonicalizePath(displayName),\n                                  canonicalizePath(diskPath), importPath);\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Own<SchemaFile> SchemaFile::newDiskFile(\n    kj::StringPtr displayName, kj::StringPtr diskPath,\n    kj::ArrayPtr<const kj::StringPtr> importPath,\n    const FileReader& fileReader) {\n  return kj::heap<DiskSchemaFile>(fileReader, canonicalizePath(displayName),\n                                  canonicalizePath(diskPath), importPath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.add",
          "args": [
            "\"const.capnp\"",
            "\"@0x8123456789abcdef;\\n\"\n      \"const uint32Const :UInt32 = 1234;\\n\"\n      \"const listConst :List(Float32) = [1.25, 2.5, 3e4];\\n\"\n      \"const structConst :Foo = (bar = 123, baz = \\\"qux\\\");\\n\"\n      \"struct Foo {\\n\"\n      \"  bar @0 :Int16;\\n\"\n      \"  baz @1 :Text;\\n\"\n      \"}\\n\"\n      \"const genericConst :TestGeneric(Text) = (value = \\\"text\\\");\\n\"\n      \"struct TestGeneric(T) {\\n\"\n      \"  value @0 :T;\\n\"\n      \"}\\n\""
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "FakeFileReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
          "lines": "33-35",
          "snippet": "void add(kj::StringPtr name, kj::StringPtr content) {\n    files[name] = content;\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include <kj/compat/gtest.h>",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nFakeFileReader {\n  void add(kj::StringPtr name, kj::StringPtr content) {\n      files[name] = content;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nTEST(SchemaParser, Constants) {\n  // This is actually a test of the full dynamic API stack for constants, because the schemas for\n  // constants are not actually accessible from the generated code API, so the only way to ever\n  // get a ConstSchema is by parsing it.\n\n  SchemaParser parser;\n  FakeFileReader reader;\n\n  reader.add(\"const.capnp\",\n      \"@0x8123456789abcdef;\\n\"\n      \"const uint32Const :UInt32 = 1234;\\n\"\n      \"const listConst :List(Float32) = [1.25, 2.5, 3e4];\\n\"\n      \"const structConst :Foo = (bar = 123, baz = \\\"qux\\\");\\n\"\n      \"struct Foo {\\n\"\n      \"  bar @0 :Int16;\\n\"\n      \"  baz @1 :Text;\\n\"\n      \"}\\n\"\n      \"const genericConst :TestGeneric(Text) = (value = \\\"text\\\");\\n\"\n      \"struct TestGeneric(T) {\\n\"\n      \"  value @0 :T;\\n\"\n      \"}\\n\");\n\n  ParsedSchema fileSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"const.capnp\", \"const.capnp\", nullptr, reader));\n\n  EXPECT_EQ(1234, fileSchema.getNested(\"uint32Const\").asConst().as<uint32_t>());\n\n  auto list = fileSchema.getNested(\"listConst\").asConst().as<DynamicList>();\n  ASSERT_EQ(3u, list.size());\n  EXPECT_EQ(1.25, list[0].as<float>());\n  EXPECT_EQ(2.5, list[1].as<float>());\n  EXPECT_EQ(3e4f, list[2].as<float>());\n\n  auto structConst = fileSchema.getNested(\"structConst\").asConst().as<DynamicStruct>();\n  EXPECT_EQ(123, structConst.get(\"bar\").as<int16_t>());\n  EXPECT_EQ(\"qux\", structConst.get(\"baz\").as<Text>());\n\n  auto genericConst = fileSchema.getNested(\"genericConst\").asConst().as<DynamicStruct>();\n  EXPECT_EQ(\"text\", genericConst.get(\"value\").as<Text>());\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
    "lines": "59-141",
    "snippet": "TEST(SchemaParser, Basic) {\n  SchemaParser parser;\n  FakeFileReader reader;\n\n  reader.add(\"src/foo/bar.capnp\",\n      \"@0x8123456789abcdef;\\n\"\n      \"struct Bar {\\n\"\n      \"  baz @0: import \\\"baz.capnp\\\".Baz;\\n\"\n      \"  corge @1: import \\\"../qux/corge.capnp\\\".Corge;\\n\"\n      \"  grault @2: import \\\"/grault.capnp\\\".Grault;\\n\"\n      \"  garply @3: import \\\"/garply.capnp\\\".Garply;\\n\"\n      \"}\\n\");\n  reader.add(\"src/foo/baz.capnp\",\n      \"@0x823456789abcdef1;\\n\"\n      \"struct Baz {}\\n\");\n  reader.add(\"src/qux/corge.capnp\",\n      \"@0x83456789abcdef12;\\n\"\n      \"struct Corge {}\\n\");\n  reader.add(\"/usr/include/grault.capnp\",\n      \"@0x8456789abcdef123;\\n\"\n      \"struct Grault {}\\n\");\n  reader.add(\"/opt/include/grault.capnp\",\n      \"@0x8000000000000001;\\n\"\n      \"struct WrongGrault {}\\n\");\n  reader.add(\"/usr/local/include/garply.capnp\",\n      \"@0x856789abcdef1234;\\n\"\n      \"struct Garply {}\\n\");\n\n  kj::StringPtr importPath[] = {\n    \"/usr/include\", \"/usr/local/include\", \"/opt/include\"\n  };\n\n  ParsedSchema barSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"foo2/bar2.capnp\", \"src/foo/bar.capnp\", importPath, reader));\n\n  auto barProto = barSchema.getProto();\n  EXPECT_EQ(0x8123456789abcdefull, barProto.getId());\n  EXPECT_EQ(\"foo2/bar2.capnp\", barProto.getDisplayName());\n\n  auto barStruct = barSchema.getNested(\"Bar\");\n  auto barFields = barStruct.asStruct().getFields();\n  ASSERT_EQ(4u, barFields.size());\n  EXPECT_EQ(\"baz\", barFields[0].getProto().getName());\n  EXPECT_EQ(0x823456789abcdef1ull, getFieldTypeFileId(barFields[0]));\n  EXPECT_EQ(\"corge\", barFields[1].getProto().getName());\n  EXPECT_EQ(0x83456789abcdef12ull, getFieldTypeFileId(barFields[1]));\n  EXPECT_EQ(\"grault\", barFields[2].getProto().getName());\n  EXPECT_EQ(0x8456789abcdef123ull, getFieldTypeFileId(barFields[2]));\n  EXPECT_EQ(\"garply\", barFields[3].getProto().getName());\n  EXPECT_EQ(0x856789abcdef1234ull, getFieldTypeFileId(barFields[3]));\n\n  auto bazSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"src/foo/baz.capnp\", importPath, reader));\n  EXPECT_EQ(0x823456789abcdef1ull, bazSchema.getProto().getId());\n  EXPECT_EQ(\"foo2/baz.capnp\", bazSchema.getProto().getDisplayName());\n  auto bazStruct = bazSchema.getNested(\"Baz\").asStruct();\n  EXPECT_EQ(bazStruct, barStruct.getDependency(bazStruct.getProto().getId()));\n\n  auto corgeSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"src/qux/corge.capnp\", importPath, reader));\n  EXPECT_EQ(0x83456789abcdef12ull, corgeSchema.getProto().getId());\n  EXPECT_EQ(\"qux/corge.capnp\", corgeSchema.getProto().getDisplayName());\n  auto corgeStruct = corgeSchema.getNested(\"Corge\").asStruct();\n  EXPECT_EQ(corgeStruct, barStruct.getDependency(corgeStruct.getProto().getId()));\n\n  auto graultSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"/usr/include/grault.capnp\", importPath, reader));\n  EXPECT_EQ(0x8456789abcdef123ull, graultSchema.getProto().getId());\n  EXPECT_EQ(\"grault.capnp\", graultSchema.getProto().getDisplayName());\n  auto graultStruct = graultSchema.getNested(\"Grault\").asStruct();\n  EXPECT_EQ(graultStruct, barStruct.getDependency(graultStruct.getProto().getId()));\n\n  // Try importing the other grault.capnp directly.  It'll get the display name we specify since\n  // it wasn't imported before.\n  auto wrongGraultSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"weird/display/name.capnp\",\n      \"/opt/include/grault.capnp\", importPath, reader));\n  EXPECT_EQ(0x8000000000000001ull, wrongGraultSchema.getProto().getId());\n  EXPECT_EQ(\"weird/display/name.capnp\", wrongGraultSchema.getProto().getDisplayName());\n}",
    "includes": [
      "#include <map>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include <kj/compat/gtest.h>",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"weird/display/name.capnp\"",
            "wrongGraultSchema.getProto().getDisplayName()"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrongGraultSchema.getProto",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x8000000000000001ull",
            "wrongGraultSchema.getProto().getId()"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parseFile",
          "args": [
            "SchemaFile::newDiskFile(\n      \"weird/display/name.capnp\",\n      \"/opt/include/grault.capnp\", importPath, reader)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SchemaFile::newDiskFile",
          "args": [
            "\"weird/display/name.capnp\"",
            "\"/opt/include/grault.capnp\"",
            "importPath",
            "reader"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "SchemaFile::newDiskFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "476-482",
          "snippet": "kj::Own<SchemaFile> SchemaFile::newDiskFile(\n    kj::StringPtr displayName, kj::StringPtr diskPath,\n    kj::ArrayPtr<const kj::StringPtr> importPath,\n    const FileReader& fileReader) {\n  return kj::heap<DiskSchemaFile>(fileReader, canonicalizePath(displayName),\n                                  canonicalizePath(diskPath), importPath);\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::Own<SchemaFile> SchemaFile::newDiskFile(\n    kj::StringPtr displayName, kj::StringPtr diskPath,\n    kj::ArrayPtr<const kj::StringPtr> importPath,\n    const FileReader& fileReader) {\n  return kj::heap<DiskSchemaFile>(fileReader, canonicalizePath(displayName),\n                                  canonicalizePath(diskPath), importPath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "graultStruct",
            "barStruct.getDependency(graultStruct.getProto().getId())"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barStruct.getDependency",
          "args": [
            "graultStruct.getProto().getId()"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graultSchema.getNested",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "graultSchema.getNested",
          "args": [
            "\"Grault\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"grault.capnp\"",
            "graultSchema.getProto().getDisplayName()"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x8456789abcdef123ull",
            "graultSchema.getProto().getId()"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parseFile",
          "args": [
            "SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"/usr/include/grault.capnp\", importPath, reader)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "corgeStruct",
            "barStruct.getDependency(corgeStruct.getProto().getId())"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barStruct.getDependency",
          "args": [
            "corgeStruct.getProto().getId()"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "corgeSchema.getNested",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "corgeSchema.getNested",
          "args": [
            "\"Corge\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"qux/corge.capnp\"",
            "corgeSchema.getProto().getDisplayName()"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x83456789abcdef12ull",
            "corgeSchema.getProto().getId()"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parseFile",
          "args": [
            "SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"src/qux/corge.capnp\", importPath, reader)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "bazStruct",
            "barStruct.getDependency(bazStruct.getProto().getId())"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barStruct.getDependency",
          "args": [
            "bazStruct.getProto().getId()"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bazSchema.getNested",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bazSchema.getNested",
          "args": [
            "\"Baz\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo2/baz.capnp\"",
            "bazSchema.getProto().getDisplayName()"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x823456789abcdef1ull",
            "bazSchema.getProto().getId()"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parser.parseFile",
          "args": [
            "SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"src/foo/baz.capnp\", importPath, reader)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x856789abcdef1234ull",
            "getFieldTypeFileId(barFields[3])"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getFieldTypeFileId",
          "args": [
            "barFields[3]"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "getFieldTypeFileId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
          "lines": "53-57",
          "snippet": "static uint64_t getFieldTypeFileId(StructSchema::Field field) {\n  return field.getContainingStruct()\n      .getDependency(field.getProto().getSlot().getType().getStruct().getTypeId())\n      .getProto().getScopeId();\n}",
          "includes": [
            "#include <map>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include <kj/compat/gtest.h>",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nstatic uint64_t getFieldTypeFileId(StructSchema::Field field) {\n  return field.getContainingStruct()\n      .getDependency(field.getProto().getSlot().getType().getStruct().getTypeId())\n      .getProto().getScopeId();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"garply\"",
            "barFields[3].getProto().getName()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x8456789abcdef123ull",
            "getFieldTypeFileId(barFields[2])"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"grault\"",
            "barFields[2].getProto().getName()"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x83456789abcdef12ull",
            "getFieldTypeFileId(barFields[1])"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"corge\"",
            "barFields[1].getProto().getName()"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x823456789abcdef1ull",
            "getFieldTypeFileId(barFields[0])"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"baz\"",
            "barFields[0].getProto().getName()"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "4u",
            "barFields.size()"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barFields.size",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "barStruct.asStruct",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barStruct.asStruct",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barSchema.getNested",
          "args": [
            "\"Bar\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo2/bar2.capnp\"",
            "barProto.getDisplayName()"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barProto.getDisplayName",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0x8123456789abcdefull",
            "barProto.getId()"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barProto.getId",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parser.parseFile",
          "args": [
            "SchemaFile::newDiskFile(\n      \"foo2/bar2.capnp\", \"src/foo/bar.capnp\", importPath, reader)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.add",
          "args": [
            "\"/usr/local/include/garply.capnp\"",
            "\"@0x856789abcdef1234;\\n\"\n      \"struct Garply {}\\n\""
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "FakeFileReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
          "lines": "33-35",
          "snippet": "void add(kj::StringPtr name, kj::StringPtr content) {\n    files[name] = content;\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/debug.h>",
            "#include \"test-util.h\"",
            "#include <kj/compat/gtest.h>",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nFakeFileReader {\n  void add(kj::StringPtr name, kj::StringPtr content) {\n      files[name] = content;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nTEST(SchemaParser, Basic) {\n  SchemaParser parser;\n  FakeFileReader reader;\n\n  reader.add(\"src/foo/bar.capnp\",\n      \"@0x8123456789abcdef;\\n\"\n      \"struct Bar {\\n\"\n      \"  baz @0: import \\\"baz.capnp\\\".Baz;\\n\"\n      \"  corge @1: import \\\"../qux/corge.capnp\\\".Corge;\\n\"\n      \"  grault @2: import \\\"/grault.capnp\\\".Grault;\\n\"\n      \"  garply @3: import \\\"/garply.capnp\\\".Garply;\\n\"\n      \"}\\n\");\n  reader.add(\"src/foo/baz.capnp\",\n      \"@0x823456789abcdef1;\\n\"\n      \"struct Baz {}\\n\");\n  reader.add(\"src/qux/corge.capnp\",\n      \"@0x83456789abcdef12;\\n\"\n      \"struct Corge {}\\n\");\n  reader.add(\"/usr/include/grault.capnp\",\n      \"@0x8456789abcdef123;\\n\"\n      \"struct Grault {}\\n\");\n  reader.add(\"/opt/include/grault.capnp\",\n      \"@0x8000000000000001;\\n\"\n      \"struct WrongGrault {}\\n\");\n  reader.add(\"/usr/local/include/garply.capnp\",\n      \"@0x856789abcdef1234;\\n\"\n      \"struct Garply {}\\n\");\n\n  kj::StringPtr importPath[] = {\n    \"/usr/include\", \"/usr/local/include\", \"/opt/include\"\n  };\n\n  ParsedSchema barSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"foo2/bar2.capnp\", \"src/foo/bar.capnp\", importPath, reader));\n\n  auto barProto = barSchema.getProto();\n  EXPECT_EQ(0x8123456789abcdefull, barProto.getId());\n  EXPECT_EQ(\"foo2/bar2.capnp\", barProto.getDisplayName());\n\n  auto barStruct = barSchema.getNested(\"Bar\");\n  auto barFields = barStruct.asStruct().getFields();\n  ASSERT_EQ(4u, barFields.size());\n  EXPECT_EQ(\"baz\", barFields[0].getProto().getName());\n  EXPECT_EQ(0x823456789abcdef1ull, getFieldTypeFileId(barFields[0]));\n  EXPECT_EQ(\"corge\", barFields[1].getProto().getName());\n  EXPECT_EQ(0x83456789abcdef12ull, getFieldTypeFileId(barFields[1]));\n  EXPECT_EQ(\"grault\", barFields[2].getProto().getName());\n  EXPECT_EQ(0x8456789abcdef123ull, getFieldTypeFileId(barFields[2]));\n  EXPECT_EQ(\"garply\", barFields[3].getProto().getName());\n  EXPECT_EQ(0x856789abcdef1234ull, getFieldTypeFileId(barFields[3]));\n\n  auto bazSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"src/foo/baz.capnp\", importPath, reader));\n  EXPECT_EQ(0x823456789abcdef1ull, bazSchema.getProto().getId());\n  EXPECT_EQ(\"foo2/baz.capnp\", bazSchema.getProto().getDisplayName());\n  auto bazStruct = bazSchema.getNested(\"Baz\").asStruct();\n  EXPECT_EQ(bazStruct, barStruct.getDependency(bazStruct.getProto().getId()));\n\n  auto corgeSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"src/qux/corge.capnp\", importPath, reader));\n  EXPECT_EQ(0x83456789abcdef12ull, corgeSchema.getProto().getId());\n  EXPECT_EQ(\"qux/corge.capnp\", corgeSchema.getProto().getDisplayName());\n  auto corgeStruct = corgeSchema.getNested(\"Corge\").asStruct();\n  EXPECT_EQ(corgeStruct, barStruct.getDependency(corgeStruct.getProto().getId()));\n\n  auto graultSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"not/used/because/already/loaded\",\n      \"/usr/include/grault.capnp\", importPath, reader));\n  EXPECT_EQ(0x8456789abcdef123ull, graultSchema.getProto().getId());\n  EXPECT_EQ(\"grault.capnp\", graultSchema.getProto().getDisplayName());\n  auto graultStruct = graultSchema.getNested(\"Grault\").asStruct();\n  EXPECT_EQ(graultStruct, barStruct.getDependency(graultStruct.getProto().getId()));\n\n  // Try importing the other grault.capnp directly.  It'll get the display name we specify since\n  // it wasn't imported before.\n  auto wrongGraultSchema = parser.parseFile(SchemaFile::newDiskFile(\n      \"weird/display/name.capnp\",\n      \"/opt/include/grault.capnp\", importPath, reader));\n  EXPECT_EQ(0x8000000000000001ull, wrongGraultSchema.getProto().getId());\n  EXPECT_EQ(\"weird/display/name.capnp\", wrongGraultSchema.getProto().getDisplayName());\n}"
  },
  {
    "function_name": "getFieldTypeFileId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
    "lines": "53-57",
    "snippet": "static uint64_t getFieldTypeFileId(StructSchema::Field field) {\n  return field.getContainingStruct()\n      .getDependency(field.getProto().getSlot().getType().getStruct().getTypeId())\n      .getProto().getScopeId();\n}",
    "includes": [
      "#include <map>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include <kj/compat/gtest.h>",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field.getContainingStruct",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "getContainingStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "274-274",
          "snippet": "inline StructSchema getContainingStruct() const { return parent; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline StructSchema getContainingStruct() const { return parent; }"
        }
      },
      {
        "call_info": {
          "callee": "field.getContainingStruct",
          "args": [
            "field.getProto().getSlot().getType().getStruct().getTypeId()"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nstatic uint64_t getFieldTypeFileId(StructSchema::Field field) {\n  return field.getContainingStruct()\n      .getDependency(field.getProto().getSlot().getType().getStruct().getTypeId())\n      .getProto().getScopeId();\n}"
  },
  {
    "function_name": "read",
    "container": "FakeFileReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
    "lines": "41-47",
    "snippet": "kj::Array<const char> read(kj::StringPtr path) const override {\n    auto iter = files.find(path);\n    KJ_ASSERT(iter != files.end(), \"FakeFileReader has no such file.\", path);\n    auto result = kj::heapArray<char>(iter->second.size());\n    memcpy(result.begin(), iter->second.begin(), iter->second.size());\n    return kj::mv(result);\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include <kj/compat/gtest.h>",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result.begin()",
            "iter->second.begin()",
            "iter->second.size()"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->second.size",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "iter->second.begin",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<char>",
          "args": [
            "iter->second.size()"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "iter != files.end()",
            "\"FakeFileReader has no such file.\"",
            "path"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files.end",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "files.find",
          "args": [
            "path"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nFakeFileReader {\n  kj::Array<const char> read(kj::StringPtr path) const override {\n      auto iter = files.find(path);\n      KJ_ASSERT(iter != files.end(), \"FakeFileReader has no such file.\", path);\n      auto result = kj::heapArray<char>(iter->second.size());\n      memcpy(result.begin(), iter->second.begin(), iter->second.size());\n      return kj::mv(result);\n    }\n}"
  },
  {
    "function_name": "exists",
    "container": "FakeFileReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
    "lines": "37-39",
    "snippet": "bool exists(kj::StringPtr path) const override {\n    return files.count(path) > 0;\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include <kj/compat/gtest.h>",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "files.count",
          "args": [
            "path"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nFakeFileReader {\n  bool exists(kj::StringPtr path) const override {\n      return files.count(path) > 0;\n    }\n}"
  },
  {
    "function_name": "add",
    "container": "FakeFileReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser-test.c++",
    "lines": "33-35",
    "snippet": "void add(kj::StringPtr name, kj::StringPtr content) {\n    files[name] = content;\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/debug.h>",
      "#include \"test-util.h\"",
      "#include <kj/compat/gtest.h>",
      "#include \"schema-parser.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <kj/debug.h>\n#include \"test-util.h\"\n#include <kj/compat/gtest.h>\n#include \"schema-parser.h\"\n\nFakeFileReader {\n  void add(kj::StringPtr name, kj::StringPtr content) {\n      files[name] = content;\n    }\n}"
  }
]