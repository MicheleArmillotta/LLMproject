[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount-test.c++",
    "lines": "34-53",
    "snippet": "TEST(Refcount, Basic) {\n  bool b = false;\n  Own<SetTrueInDestructor> ref1 = kj::refcounted<SetTrueInDestructor>(&b);\n  Own<SetTrueInDestructor> ref2 = kj::addRef(*ref1);\n  Own<SetTrueInDestructor> ref3 = kj::addRef(*ref2);\n\n  EXPECT_FALSE(b);\n  ref1 = Own<SetTrueInDestructor>();\n  EXPECT_FALSE(b);\n  ref3 = Own<SetTrueInDestructor>();\n  EXPECT_FALSE(b);\n  ref2 = Own<SetTrueInDestructor>();\n  EXPECT_TRUE(b);\n\n#if defined(KJ_DEBUG) && !KJ_NO_EXCEPTIONS\n  b = false;\n  SetTrueInDestructor obj(&b);\n  EXPECT_ANY_THROW(addRef(obj));\n#endif\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"refcount.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "addRef(obj)"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addRef",
          "args": [
            "obj"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "b"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Own<SetTrueInDestructor>",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "Arena::allocateOwn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "187-193",
          "snippet": "Own<T> Arena::allocateOwn(Params&&... params) {\n  T& result = *reinterpret_cast<T*>(allocateBytes(sizeof(T), alignof(T), false));\n  if (!__has_trivial_constructor(T) || sizeof...(Params) > 0) {\n    ctor(result, kj::fwd<Params>(params)...);\n  }\n  return Own<T>(&result, DestructorOnlyDisposer<T>::instance);\n}",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nOwn<T> Arena::allocateOwn(Params&&... params) {\n  T& result = *reinterpret_cast<T*>(allocateBytes(sizeof(T), alignof(T), false));\n  if (!__has_trivial_constructor(T) || sizeof...(Params) > 0) {\n    ctor(result, kj::fwd<Params>(params)...);\n  }\n  return Own<T>(&result, DestructorOnlyDisposer<T>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "b"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "b"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_FALSE",
          "args": [
            "b"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<SetTrueInDestructor>",
          "args": [
            "&b"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"refcount.h\"\n\nTEST(Refcount, Basic) {\n  bool b = false;\n  Own<SetTrueInDestructor> ref1 = kj::refcounted<SetTrueInDestructor>(&b);\n  Own<SetTrueInDestructor> ref2 = kj::addRef(*ref1);\n  Own<SetTrueInDestructor> ref3 = kj::addRef(*ref2);\n\n  EXPECT_FALSE(b);\n  ref1 = Own<SetTrueInDestructor>();\n  EXPECT_FALSE(b);\n  ref3 = Own<SetTrueInDestructor>();\n  EXPECT_FALSE(b);\n  ref2 = Own<SetTrueInDestructor>();\n  EXPECT_TRUE(b);\n\n#if defined(KJ_DEBUG) && !KJ_NO_EXCEPTIONS\n  b = false;\n  SetTrueInDestructor obj(&b);\n  EXPECT_ANY_THROW(addRef(obj));\n#endif\n}"
  },
  {
    "function_name": "SetTrueInDestructor",
    "container": "SetTrueInDestructor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount-test.c++",
    "lines": "28-28",
    "snippet": "SetTrueInDestructor(bool* ptr): ptr(ptr) {}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"refcount.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"refcount.h\"\n\nSetTrueInDestructor {\n  SetTrueInDestructor(bool* ptr): ptr(ptr) {}\n}"
  }
]