[
  {
    "function_name": "Stringifier::operator*",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
    "lines": "343-347",
    "snippet": "CappedArray<char, kDoubleToBufferSize> Stringifier::operator*(double f) const {\n  CappedArray<char, kDoubleToBufferSize> result;\n  result.setSize(strlen(DoubleToBuffer(f, result.begin())));\n  return result;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <float.h>",
      "#include <stdio.h>",
      "#include \"debug.h\"",
      "#include \"string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.setSize",
          "args": [
            "strlen(DoubleToBuffer(f, result.begin()))"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "setSize",
          "container": "CappedArray",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "458-458",
          "snippet": "inline void setSize(size_t s) { KJ_IREQUIRE(s <= fixedSize); currentSize = s; }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nCappedArray {\n  inline void setSize(size_t s) { KJ_IREQUIRE(s <= fixedSize); currentSize = s; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "DoubleToBuffer(f, result.begin())"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DoubleToBuffer",
          "args": [
            "f",
            "result.begin()"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nCappedArray<char, kDoubleToBufferSize> Stringifier::operator*(double f) const {\n  CappedArray<char, kDoubleToBufferSize> result;\n  result.setSize(strlen(DoubleToBuffer(f, result.begin())));\n  return result;\n}"
  },
  {
    "function_name": "Stringifier::operator*",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
    "lines": "337-341",
    "snippet": "CappedArray<char, kFloatToBufferSize> Stringifier::operator*(float f) const {\n  CappedArray<char, kFloatToBufferSize> result;\n  result.setSize(strlen(FloatToBuffer(f, result.begin())));\n  return result;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <float.h>",
      "#include <stdio.h>",
      "#include \"debug.h\"",
      "#include \"string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.setSize",
          "args": [
            "strlen(FloatToBuffer(f, result.begin()))"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "setSize",
          "container": "CappedArray",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "458-458",
          "snippet": "inline void setSize(size_t s) { KJ_IREQUIRE(s <= fixedSize); currentSize = s; }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nCappedArray {\n  inline void setSize(size_t s) { KJ_IREQUIRE(s <= fixedSize); currentSize = s; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "FloatToBuffer(f, result.begin())"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FloatToBuffer",
          "args": [
            "f",
            "result.begin()"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nCappedArray<char, kFloatToBufferSize> Stringifier::operator*(float f) const {\n  CappedArray<char, kFloatToBufferSize> result;\n  result.setSize(strlen(FloatToBuffer(f, result.begin())));\n  return result;\n}"
  },
  {
    "function_name": "HEXIFY_INT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
    "lines": "56-333",
    "snippet": "HEXIFY_INT(unsigned char, \"%x\");\nHEXIFY_INT(unsigned short, \"%x\");\nHEXIFY_INT(unsigned int, \"%x\");\nHEXIFY_INT(unsigned long, \"%lx\");\nHEXIFY_INT(unsigned long long, \"%llx\");\n\n#undef HEXIFY_INT\n\nnamespace _ {  // private\n\nStringPtr Stringifier::operator*(decltype(nullptr)) const {\n  return \"nullptr\";\n}\n\nStringPtr Stringifier::operator*(bool b) const {\n  return b ? StringPtr(\"true\") : StringPtr(\"false\");\n}\n\n#define STRINGIFY_INT(type, format) \\\nCappedArray<char, sizeof(type) * 3 + 2> Stringifier::operator*(type i) const { \\\n  CappedArray<char, sizeof(type) * 3 + 2> result; \\\n  result.setSize(sprintf(result.begin(), format, i)); \\\n  return result; \\\n}\n\nSTRINGIFY_INT(signed char, \"%d\");\nSTRINGIFY_INT(unsigned char, \"%u\");\nSTRINGIFY_INT(short, \"%d\");\nSTRINGIFY_INT(unsigned short, \"%u\");\nSTRINGIFY_INT(int, \"%d\");\nSTRINGIFY_INT(unsigned int, \"%u\");\nSTRINGIFY_INT(long, \"%ld\");\nSTRINGIFY_INT(unsigned long, \"%lu\");\nSTRINGIFY_INT(long long, \"%lld\");\nSTRINGIFY_INT(unsigned long long, \"%llu\");\nSTRINGIFY_INT(const void*, \"%p\");\n\n#undef STRINGIFY_INT\n\nnamespace {\n\n// ----------------------------------------------------------------------\n// DoubleToBuffer()\n// FloatToBuffer()\n//    Copied from Protocol Buffers, (C) Google, BSD license.\n//    Kenton wrote this code originally.  The following commentary is\n//    from the original.\n//\n//    Description: converts a double or float to a string which, if\n//    passed to NoLocaleStrtod(), will produce the exact same original double\n//    (except in case of NaN; all NaNs are considered the same value).\n//    We try to keep the string short but it's not guaranteed to be as\n//    short as possible.\n//\n//    DoubleToBuffer() and FloatToBuffer() write the text to the given\n//    buffer and return it.  The buffer must be at least\n//    kDoubleToBufferSize bytes for doubles and kFloatToBufferSize\n//    bytes for floats.  kFastToBufferSize is also guaranteed to be large\n//    enough to hold either.\n//\n//    We want to print the value without losing precision, but we also do\n//    not want to print more digits than necessary.  This turns out to be\n//    trickier than it sounds.  Numbers like 0.2 cannot be represented\n//    exactly in binary.  If we print 0.2 with a very large precision,\n//    e.g. \"%.50g\", we get \"0.2000000000000000111022302462515654042363167\".\n//    On the other hand, if we set the precision too low, we lose\n//    significant digits when printing numbers that actually need them.\n//    It turns out there is no precision value that does the right thing\n//    for all numbers.\n//\n//    Our strategy is to first try printing with a precision that is never\n//    over-precise, then parse the result with strtod() to see if it\n//    matches.  If not, we print again with a precision that will always\n//    give a precise result, but may use more digits than necessary.\n//\n//    An arguably better strategy would be to use the algorithm described\n//    in \"How to Print Floating-Point Numbers Accurately\" by Steele &\n//    White, e.g. as implemented by David M. Gay's dtoa().  It turns out,\n//    however, that the following implementation is about as fast as\n//    DMG's code.  Furthermore, DMG's code locks mutexes, which means it\n//    will not scale well on multi-core machines.  DMG's code is slightly\n//    more accurate (in that it will never use more digits than\n//    necessary), but this is probably irrelevant for most users.\n//\n//    Rob Pike and Ken Thompson also have an implementation of dtoa() in\n//    third_party/fmt/fltfmt.cc.  Their implementation is similar to this\n//    one in that it makes guesses and then uses strtod() to check them.\n//    Their implementation is faster because they use their own code to\n//    generate the digits in the first place rather than use snprintf(),\n//    thus avoiding format string parsing overhead.  However, this makes\n//    it considerably more complicated than the following implementation,\n//    and it is embedded in a larger library.  If speed turns out to be\n//    an issue, we could re-implement this in terms of their\n//    implementation.\n// ----------------------------------------------------------------------\n\n#ifdef _WIN32\n// MSVC has only _snprintf, not snprintf.\n//\n// MinGW has both snprintf and _snprintf, but they appear to be different\n// functions.  The former is buggy.  When invoked like so:\n//   char buffer[32];\n//   snprintf(buffer, 32, \"%.*g\\n\", FLT_DIG, 1.23e10f);\n// it prints \"1.23000e+10\".  This is plainly wrong:  %g should never print\n// trailing zeros after the decimal point.  For some reason this bug only\n// occurs with some input values, not all.  In any case, _snprintf does the\n// right thing, so we use it.\n#define snprintf _snprintf\n#endif\n\ninline bool IsNaN(double value) {\n  // NaN is never equal to anything, even itself.\n  return value != value;\n}\n\n// In practice, doubles should never need more than 24 bytes and floats\n// should never need more than 14 (including null terminators), but we\n// overestimate to be safe.\nstatic const int kDoubleToBufferSize = 32;\nstatic const int kFloatToBufferSize = 24;\n\nstatic inline bool IsValidFloatChar(char c) {\n  return ('0' <= c && c <= '9') ||\n         c == 'e' || c == 'E' ||\n         c == '+' || c == '-';\n}\n\nvoid DelocalizeRadix(char* buffer) {\n  // Fast check:  if the buffer has a normal decimal point, assume no\n  // translation is needed.\n  if (strchr(buffer, '.') != NULL) return;\n\n  // Find the first unknown character.\n  while (IsValidFloatChar(*buffer)) ++buffer;\n\n  if (*buffer == '\\0') {\n    // No radix character found.\n    return;\n  }\n\n  // We are now pointing at the locale-specific radix character.  Replace it\n  // with '.'.\n  *buffer = '.';\n  ++buffer;\n\n  if (!IsValidFloatChar(*buffer) && *buffer != '\\0') {\n    // It appears the radix was a multi-byte character.  We need to remove the\n    // extra bytes.\n    char* target = buffer;\n    do { ++buffer; } while (!IsValidFloatChar(*buffer) && *buffer != '\\0');\n    memmove(target, buffer, strlen(buffer) + 1);\n  }\n}\n\nvoid RemovePlus(char* buffer) {\n  // Remove any + characters because they are redundant and ugly.\n\n  for (;;) {\n    buffer = strchr(buffer, '+');\n    if (buffer == NULL) {\n      return;\n    }\n    memmove(buffer, buffer + 1, strlen(buffer + 1) + 1);\n  }\n}\n\n#if _WIN32\nvoid RemoveE0(char* buffer) {\n  // Remove redundant leading 0's after an e, e.g. 1e012. Seems to appear on\n  // Windows.\n\n  for (;;) {\n    buffer = strstr(buffer, \"e0\");\n    if (buffer == NULL || buffer[2] < '0' || buffer[2] > '9') {\n      return;\n    }\n    memmove(buffer + 1, buffer + 2, strlen(buffer + 2) + 1);\n  }\n}\n#endif\n\nchar* DoubleToBuffer(double value, char* buffer) {\n  // DBL_DIG is 15 for IEEE-754 doubles, which are used on almost all\n  // platforms these days.  Just in case some system exists where DBL_DIG\n  // is significantly larger -- and risks overflowing our buffer -- we have\n  // this assert.\n  static_assert(DBL_DIG < 20, \"DBL_DIG is too big.\");\n\n  if (value == inf()) {\n    strcpy(buffer, \"inf\");\n    return buffer;\n  } else if (value == -inf()) {\n    strcpy(buffer, \"-inf\");\n    return buffer;\n  } else if (IsNaN(value)) {\n    strcpy(buffer, \"nan\");\n    return buffer;\n  }\n\n  int snprintf_result =\n    snprintf(buffer, kDoubleToBufferSize, \"%.*g\", DBL_DIG, value);\n\n  // The snprintf should never overflow because the buffer is significantly\n  // larger than the precision we asked for.\n  KJ_DASSERT(snprintf_result > 0 && snprintf_result < kDoubleToBufferSize);\n\n  // We need to make parsed_value volatile in order to force the compiler to\n  // write it out to the stack.  Otherwise, it may keep the value in a\n  // register, and if it does that, it may keep it as a long double instead\n  // of a double.  This long double may have extra bits that make it compare\n  // unequal to \"value\" even though it would be exactly equal if it were\n  // truncated to a double.\n  volatile double parsed_value = strtod(buffer, NULL);\n  if (parsed_value != value) {\n    int snprintf_result2 =\n      snprintf(buffer, kDoubleToBufferSize, \"%.*g\", DBL_DIG+2, value);\n\n    // Should never overflow; see above.\n    KJ_DASSERT(snprintf_result2 > 0 && snprintf_result2 < kDoubleToBufferSize);\n  }\n\n  DelocalizeRadix(buffer);\n  RemovePlus(buffer);\n#if _WIN32\n  RemoveE0(buffer);\n#endif // _WIN32\n  return buffer;\n}\n\nbool safe_strtof(const char* str, float* value) {\n  char* endptr;\n  errno = 0;  // errno only gets set on errors\n#if defined(_WIN32) || defined (__hpux)  // has no strtof()\n  *value = static_cast<float>(strtod(str, &endptr));\n#else\n  *value = strtof(str, &endptr);\n#endif\n  return *str != 0 && *endptr == 0 && errno == 0;\n}\n\nchar* FloatToBuffer(float value, char* buffer) {\n  // FLT_DIG is 6 for IEEE-754 floats, which are used on almost all\n  // platforms these days.  Just in case some system exists where FLT_DIG\n  // is significantly larger -- and risks overflowing our buffer -- we have\n  // this assert.\n  static_assert(FLT_DIG < 10, \"FLT_DIG is too big\");\n\n  if (value == inf()) {\n    strcpy(buffer, \"inf\");\n    return buffer;\n  } else if (value == -inf()) {\n    strcpy(buffer, \"-inf\");\n    return buffer;\n  } else if (IsNaN(value)) {\n    strcpy(buffer, \"nan\");\n    return buffer;\n  }\n\n  int snprintf_result =\n    snprintf(buffer, kFloatToBufferSize, \"%.*g\", FLT_DIG, value);\n\n  // The snprintf should never overflow because the buffer is significantly\n  // larger than the precision we asked for.\n  KJ_DASSERT(snprintf_result > 0 && snprintf_result < kFloatToBufferSize);\n\n  float parsed_value;\n  if (!safe_strtof(buffer, &parsed_value) || parsed_value != value) {\n    int snprintf_result2 =\n      snprintf(buffer, kFloatToBufferSize, \"%.*g\", FLT_DIG+2, value);\n\n    // Should never overflow; see above.\n    KJ_DASSERT(snprintf_result2 > 0 && snprintf_result2 < kFloatToBufferSize);\n  }\n\n  DelocalizeRadix(buffer);\n  RemovePlus(buffer);\n  return buffer;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <float.h>",
      "#include <stdio.h>",
      "#include \"debug.h\"",
      "#include \"string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RemovePlus",
          "args": [
            "buffer"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DelocalizeRadix",
          "args": [
            "buffer"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "snprintf_result2 > 0 && snprintf_result2 < kFloatToBufferSize"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "kFloatToBufferSize",
            "\"%.*g\"",
            "FLT_DIG+2",
            "value"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_strtof",
          "args": [
            "buffer",
            "&parsed_value"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "snprintf_result > 0 && snprintf_result < kFloatToBufferSize"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "kFloatToBufferSize",
            "\"%.*g\"",
            "FLT_DIG",
            "value"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"nan\""
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsNaN",
          "args": [
            "value"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"-inf\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inf",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "inf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "580-580",
          "snippet": "inline constexpr float inf() { return (float)(1e300 * 1e300); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr float inf() { return (float)(1e300 * 1e300); }"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buffer",
            "\"inf\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_strtof",
          "args": [
            "const char* str",
            "float* value"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RemoveE0",
          "args": [
            "buffer"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RemovePlus",
          "args": [
            "buffer"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DelocalizeRadix",
          "args": [
            "buffer"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "snprintf_result2 > 0 && snprintf_result2 < kDoubleToBufferSize"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "kDoubleToBufferSize",
            "\"%.*g\"",
            "DBL_DIG+2",
            "value"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n  if",
          "args": [
            "parsed_value != value"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtod",
          "args": [
            "buffer",
            "NULL"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "snprintf_result > 0 && snprintf_result < kDoubleToBufferSize"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "kDoubleToBufferSize",
            "\"%.*g\"",
            "DBL_DIG",
            "value"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buffer + 1",
            "buffer + 2",
            "strlen(buffer + 2) + 1"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer + 2"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    if",
          "args": [
            "buffer == NULL || buffer[2] < '0' || buffer[2] > '9'"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buffer",
            "\"e0\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n  // Remove redundant leading 0's after an e, e.g. 1e012. Seems to appear on\n  // Windows.\n\n  for",
          "args": [
            ";;"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RemoveE0",
          "args": [
            "char* buffer"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buffer",
            "buffer + 1",
            "strlen(buffer + 1) + 1"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buffer + 1"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    if",
          "args": [
            "buffer == NULL"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buffer",
            "'+'"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer; } while",
          "args": [
            "!IsValidFloatChar(*buffer) && *buffer != '\\0'"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsValidFloatChar",
          "args": [
            "*buffer"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer;\n\n  if",
          "args": [
            "!IsValidFloatChar(*buffer) && *buffer != '\\0'"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsValidFloatChar",
          "args": [
            "*buffer"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer;\n\n  if",
          "args": [
            "*buffer == '\\0'"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return;\n\n  // Find the first unknown character.\n  while",
          "args": [
            "IsValidFloatChar(*buffer)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsValidFloatChar",
          "args": [
            "*buffer"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n  // Fast check:  if the buffer has a normal decimal point, assume no\n  // translation is needed.\n  if",
          "args": [
            "strchr(buffer, '.') != NULL"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "buffer",
            "'.'"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DelocalizeRadix",
          "args": [
            "char* buffer"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n  return",
          "args": [
            "'0' <= c && c <= '9'"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsValidFloatChar",
          "args": [
            "charc"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nHEXIFY_INT(unsigned char, \"%x\");\nHEXIFY_INT(unsigned short, \"%x\");\nHEXIFY_INT(unsigned int, \"%x\");\nHEXIFY_INT(unsigned long, \"%lx\");\nHEXIFY_INT(unsigned long long, \"%llx\");\n\n#undef HEXIFY_INT\n\nnamespace _ {  // private\n\nStringPtr Stringifier::operator*(decltype(nullptr)) const {\n  return \"nullptr\";\n}\n\nStringPtr Stringifier::operator*(bool b) const {\n  return b ? StringPtr(\"true\") : StringPtr(\"false\");\n}\n\n#define STRINGIFY_INT(type, format) \\\nCappedArray<char, sizeof(type) * 3 + 2> Stringifier::operator*(type i) const { \\\n  CappedArray<char, sizeof(type) * 3 + 2> result; \\\n  result.setSize(sprintf(result.begin(), format, i)); \\\n  return result; \\\n}\n\nSTRINGIFY_INT(signed char, \"%d\");\nSTRINGIFY_INT(unsigned char, \"%u\");\nSTRINGIFY_INT(short, \"%d\");\nSTRINGIFY_INT(unsigned short, \"%u\");\nSTRINGIFY_INT(int, \"%d\");\nSTRINGIFY_INT(unsigned int, \"%u\");\nSTRINGIFY_INT(long, \"%ld\");\nSTRINGIFY_INT(unsigned long, \"%lu\");\nSTRINGIFY_INT(long long, \"%lld\");\nSTRINGIFY_INT(unsigned long long, \"%llu\");\nSTRINGIFY_INT(const void*, \"%p\");\n\n#undef STRINGIFY_INT\n\nnamespace {\n\n// ----------------------------------------------------------------------\n// DoubleToBuffer()\n// FloatToBuffer()\n//    Copied from Protocol Buffers, (C) Google, BSD license.\n//    Kenton wrote this code originally.  The following commentary is\n//    from the original.\n//\n//    Description: converts a double or float to a string which, if\n//    passed to NoLocaleStrtod(), will produce the exact same original double\n//    (except in case of NaN; all NaNs are considered the same value).\n//    We try to keep the string short but it's not guaranteed to be as\n//    short as possible.\n//\n//    DoubleToBuffer() and FloatToBuffer() write the text to the given\n//    buffer and return it.  The buffer must be at least\n//    kDoubleToBufferSize bytes for doubles and kFloatToBufferSize\n//    bytes for floats.  kFastToBufferSize is also guaranteed to be large\n//    enough to hold either.\n//\n//    We want to print the value without losing precision, but we also do\n//    not want to print more digits than necessary.  This turns out to be\n//    trickier than it sounds.  Numbers like 0.2 cannot be represented\n//    exactly in binary.  If we print 0.2 with a very large precision,\n//    e.g. \"%.50g\", we get \"0.2000000000000000111022302462515654042363167\".\n//    On the other hand, if we set the precision too low, we lose\n//    significant digits when printing numbers that actually need them.\n//    It turns out there is no precision value that does the right thing\n//    for all numbers.\n//\n//    Our strategy is to first try printing with a precision that is never\n//    over-precise, then parse the result with strtod() to see if it\n//    matches.  If not, we print again with a precision that will always\n//    give a precise result, but may use more digits than necessary.\n//\n//    An arguably better strategy would be to use the algorithm described\n//    in \"How to Print Floating-Point Numbers Accurately\" by Steele &\n//    White, e.g. as implemented by David M. Gay's dtoa().  It turns out,\n//    however, that the following implementation is about as fast as\n//    DMG's code.  Furthermore, DMG's code locks mutexes, which means it\n//    will not scale well on multi-core machines.  DMG's code is slightly\n//    more accurate (in that it will never use more digits than\n//    necessary), but this is probably irrelevant for most users.\n//\n//    Rob Pike and Ken Thompson also have an implementation of dtoa() in\n//    third_party/fmt/fltfmt.cc.  Their implementation is similar to this\n//    one in that it makes guesses and then uses strtod() to check them.\n//    Their implementation is faster because they use their own code to\n//    generate the digits in the first place rather than use snprintf(),\n//    thus avoiding format string parsing overhead.  However, this makes\n//    it considerably more complicated than the following implementation,\n//    and it is embedded in a larger library.  If speed turns out to be\n//    an issue, we could re-implement this in terms of their\n//    implementation.\n// ----------------------------------------------------------------------\n\n#ifdef _WIN32\n// MSVC has only _snprintf, not snprintf.\n//\n// MinGW has both snprintf and _snprintf, but they appear to be different\n// functions.  The former is buggy.  When invoked like so:\n//   char buffer[32];\n//   snprintf(buffer, 32, \"%.*g\\n\", FLT_DIG, 1.23e10f);\n// it prints \"1.23000e+10\".  This is plainly wrong:  %g should never print\n// trailing zeros after the decimal point.  For some reason this bug only\n// occurs with some input values, not all.  In any case, _snprintf does the\n// right thing, so we use it.\n#define snprintf _snprintf\n#endif\n\ninline bool IsNaN(double value) {\n  // NaN is never equal to anything, even itself.\n  return value != value;\n}\n\n// In practice, doubles should never need more than 24 bytes and floats\n// should never need more than 14 (including null terminators), but we\n// overestimate to be safe.\nstatic const int kDoubleToBufferSize = 32;\nstatic const int kFloatToBufferSize = 24;\n\nstatic inline bool IsValidFloatChar(char c) {\n  return ('0' <= c && c <= '9') ||\n         c == 'e' || c == 'E' ||\n         c == '+' || c == '-';\n}\n\nvoid DelocalizeRadix(char* buffer) {\n  // Fast check:  if the buffer has a normal decimal point, assume no\n  // translation is needed.\n  if (strchr(buffer, '.') != NULL) return;\n\n  // Find the first unknown character.\n  while (IsValidFloatChar(*buffer)) ++buffer;\n\n  if (*buffer == '\\0') {\n    // No radix character found.\n    return;\n  }\n\n  // We are now pointing at the locale-specific radix character.  Replace it\n  // with '.'.\n  *buffer = '.';\n  ++buffer;\n\n  if (!IsValidFloatChar(*buffer) && *buffer != '\\0') {\n    // It appears the radix was a multi-byte character.  We need to remove the\n    // extra bytes.\n    char* target = buffer;\n    do { ++buffer; } while (!IsValidFloatChar(*buffer) && *buffer != '\\0');\n    memmove(target, buffer, strlen(buffer) + 1);\n  }\n}\n\nvoid RemovePlus(char* buffer) {\n  // Remove any + characters because they are redundant and ugly.\n\n  for (;;) {\n    buffer = strchr(buffer, '+');\n    if (buffer == NULL) {\n      return;\n    }\n    memmove(buffer, buffer + 1, strlen(buffer + 1) + 1);\n  }\n}\n\n#if _WIN32\nvoid RemoveE0(char* buffer) {\n  // Remove redundant leading 0's after an e, e.g. 1e012. Seems to appear on\n  // Windows.\n\n  for (;;) {\n    buffer = strstr(buffer, \"e0\");\n    if (buffer == NULL || buffer[2] < '0' || buffer[2] > '9') {\n      return;\n    }\n    memmove(buffer + 1, buffer + 2, strlen(buffer + 2) + 1);\n  }\n}\n#endif\n\nchar* DoubleToBuffer(double value, char* buffer) {\n  // DBL_DIG is 15 for IEEE-754 doubles, which are used on almost all\n  // platforms these days.  Just in case some system exists where DBL_DIG\n  // is significantly larger -- and risks overflowing our buffer -- we have\n  // this assert.\n  static_assert(DBL_DIG < 20, \"DBL_DIG is too big.\");\n\n  if (value == inf()) {\n    strcpy(buffer, \"inf\");\n    return buffer;\n  } else if (value == -inf()) {\n    strcpy(buffer, \"-inf\");\n    return buffer;\n  } else if (IsNaN(value)) {\n    strcpy(buffer, \"nan\");\n    return buffer;\n  }\n\n  int snprintf_result =\n    snprintf(buffer, kDoubleToBufferSize, \"%.*g\", DBL_DIG, value);\n\n  // The snprintf should never overflow because the buffer is significantly\n  // larger than the precision we asked for.\n  KJ_DASSERT(snprintf_result > 0 && snprintf_result < kDoubleToBufferSize);\n\n  // We need to make parsed_value volatile in order to force the compiler to\n  // write it out to the stack.  Otherwise, it may keep the value in a\n  // register, and if it does that, it may keep it as a long double instead\n  // of a double.  This long double may have extra bits that make it compare\n  // unequal to \"value\" even though it would be exactly equal if it were\n  // truncated to a double.\n  volatile double parsed_value = strtod(buffer, NULL);\n  if (parsed_value != value) {\n    int snprintf_result2 =\n      snprintf(buffer, kDoubleToBufferSize, \"%.*g\", DBL_DIG+2, value);\n\n    // Should never overflow; see above.\n    KJ_DASSERT(snprintf_result2 > 0 && snprintf_result2 < kDoubleToBufferSize);\n  }\n\n  DelocalizeRadix(buffer);\n  RemovePlus(buffer);\n#if _WIN32\n  RemoveE0(buffer);\n#endif // _WIN32\n  return buffer;\n}\n\nbool safe_strtof(const char* str, float* value) {\n  char* endptr;\n  errno = 0;  // errno only gets set on errors\n#if defined(_WIN32) || defined (__hpux)  // has no strtof()\n  *value = static_cast<float>(strtod(str, &endptr));\n#else\n  *value = strtof(str, &endptr);\n#endif\n  return *str != 0 && *endptr == 0 && errno == 0;\n}\n\nchar* FloatToBuffer(float value, char* buffer) {\n  // FLT_DIG is 6 for IEEE-754 floats, which are used on almost all\n  // platforms these days.  Just in case some system exists where FLT_DIG\n  // is significantly larger -- and risks overflowing our buffer -- we have\n  // this assert.\n  static_assert(FLT_DIG < 10, \"FLT_DIG is too big\");\n\n  if (value == inf()) {\n    strcpy(buffer, \"inf\");\n    return buffer;\n  } else if (value == -inf()) {\n    strcpy(buffer, \"-inf\");\n    return buffer;\n  } else if (IsNaN(value)) {\n    strcpy(buffer, \"nan\");\n    return buffer;\n  }\n\n  int snprintf_result =\n    snprintf(buffer, kFloatToBufferSize, \"%.*g\", FLT_DIG, value);\n\n  // The snprintf should never overflow because the buffer is significantly\n  // larger than the precision we asked for.\n  KJ_DASSERT(snprintf_result > 0 && snprintf_result < kFloatToBufferSize);\n\n  float parsed_value;\n  if (!safe_strtof(buffer, &parsed_value) || parsed_value != value) {\n    int snprintf_result2 =\n      snprintf(buffer, kFloatToBufferSize, \"%.*g\", FLT_DIG+2, value);\n\n    // Should never overflow; see above.\n    KJ_DASSERT(snprintf_result2 > 0 && snprintf_result2 < kFloatToBufferSize);\n  }\n\n  DelocalizeRadix(buffer);\n  RemovePlus(buffer);\n  return buffer;\n}"
  },
  {
    "function_name": "heapString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
    "lines": "42-47",
    "snippet": "String heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <float.h>",
      "#include <stdio.h>",
      "#include \"debug.h\"",
      "#include \"string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String",
          "args": [
            "buffer",
            "size",
            "_::HeapArrayDisposer::instance"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "value",
            "size"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::HeapArrayDisposer::allocate<char>",
          "args": [
            "size + 1"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
  },
  {
    "function_name": "heapString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
    "lines": "36-40",
    "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <float.h>",
      "#include <stdio.h>",
      "#include \"debug.h\"",
      "#include \"string.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "String",
          "args": [
            "buffer",
            "size",
            "_::HeapArrayDisposer::instance"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::HeapArrayDisposer::allocate<char>",
          "args": [
            "size + 1"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
  }
]