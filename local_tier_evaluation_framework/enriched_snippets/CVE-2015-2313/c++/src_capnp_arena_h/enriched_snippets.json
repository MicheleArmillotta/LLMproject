[
  {
    "function_name": "SegmentBuilder::tryTruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "444-446",
    "snippet": "inline void SegmentBuilder::tryTruncate(word* from, word* to) {\n  if (pos == from) pos = to;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline void SegmentBuilder::tryTruncate(word* from, word* to) {\n  if (pos == from) pos = to;\n}"
  },
  {
    "function_name": "SegmentBuilder::reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "438-442",
    "snippet": "inline void SegmentBuilder::reset() {\n  word* start = getPtrUnchecked(0 * WORDS);\n  memset(start, 0, (pos - start) * sizeof(word));\n  pos = start;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "start",
            "0",
            "(pos - start) * sizeof(word)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPtrUnchecked",
          "args": [
            "0 * WORDS"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline void SegmentBuilder::reset() {\n  word* start = getPtrUnchecked(0 * WORDS);\n  memset(start, 0, (pos - start) * sizeof(word));\n  pos = start;\n}"
  },
  {
    "function_name": "SegmentBuilder::currentlyAllocated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "434-436",
    "snippet": "inline kj::ArrayPtr<const word> SegmentBuilder::currentlyAllocated() {\n  return kj::arrayPtr(ptr.begin(), pos - ptr.begin());\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "ptr.begin()",
            "pos - ptr.begin()"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr.begin",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline kj::ArrayPtr<const word> SegmentBuilder::currentlyAllocated() {\n  return kj::arrayPtr(ptr.begin(), pos - ptr.begin());\n}"
  },
  {
    "function_name": "SegmentBuilder::checkWritable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "420-422",
    "snippet": "inline void SegmentBuilder::checkWritable() {\n  if (KJ_UNLIKELY(readOnly)) throwNotWritable();\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "throwNotWritable",
          "args": [],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "SegmentBuilder::throwNotWritable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
          "lines": "51-56",
          "snippet": "void SegmentBuilder::throwNotWritable() {\n  KJ_FAIL_REQUIRE(\n      \"Tried to form a Builder to an external data segment referenced by the MessageBuilder.  \"\n      \"When you use Orphanage::reference*(), you are not allowed to obtain Builders to the \"\n      \"referenced data, only Readers, because that data is const.\");\n}",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <vector>",
            "#include <kj/refcount.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"arena.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nvoid SegmentBuilder::throwNotWritable() {\n  KJ_FAIL_REQUIRE(\n      \"Tried to form a Builder to an external data segment referenced by the MessageBuilder.  \"\n      \"When you use Orphanage::reference*(), you are not allowed to obtain Builders to the \"\n      \"referenced data, only Readers, because that data is const.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "readOnly"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline void SegmentBuilder::checkWritable() {\n  if (KJ_UNLIKELY(readOnly)) throwNotWritable();\n}"
  },
  {
    "function_name": "SegmentBuilder::SegmentBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "404-406",
    "snippet": "inline SegmentBuilder::SegmentBuilder(BuilderArena* arena, SegmentId id, decltype(nullptr),\n                                      ReadLimiter* readLimiter)\n    : SegmentReader(arena, id, nullptr, readLimiter), pos(nullptr), readOnly(false) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline SegmentBuilder::SegmentBuilder(BuilderArena* arena, SegmentId id, decltype(nullptr),\n                                      ReadLimiter* readLimiter)\n    : SegmentReader(arena, id, nullptr, readLimiter), pos(nullptr), readOnly(false) {}"
  },
  {
    "function_name": "SegmentBuilder::SegmentBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "397-403",
    "snippet": "inline SegmentBuilder::SegmentBuilder(\n    BuilderArena* arena, SegmentId id, kj::ArrayPtr<const word> ptr, ReadLimiter* readLimiter)\n    : SegmentReader(arena, id, ptr, readLimiter),\n      // const_cast is safe here because the member won't ever be dereferenced because it appears\n      // to point to the end of the segment anyway.\n      pos(const_cast<word*>(ptr.end())),\n      readOnly(true) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "const_cast<word*>",
          "args": [
            "ptr.end()"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr.end",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline SegmentBuilder::SegmentBuilder(\n    BuilderArena* arena, SegmentId id, kj::ArrayPtr<const word> ptr, ReadLimiter* readLimiter)\n    : SegmentReader(arena, id, ptr, readLimiter),\n      // const_cast is safe here because the member won't ever be dereferenced because it appears\n      // to point to the end of the segment anyway.\n      pos(const_cast<word*>(ptr.end())),\n      readOnly(true) {}"
  },
  {
    "function_name": "SegmentBuilder::SegmentBuilder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "393-396",
    "snippet": "inline SegmentBuilder::SegmentBuilder(\n    BuilderArena* arena, SegmentId id, kj::ArrayPtr<word> ptr, ReadLimiter* readLimiter,\n    size_t wordsUsed)\n    : SegmentReader(arena, id, ptr, readLimiter), pos(ptr.begin() + wordsUsed), readOnly(false) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr.begin",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline SegmentBuilder::SegmentBuilder(\n    BuilderArena* arena, SegmentId id, kj::ArrayPtr<word> ptr, ReadLimiter* readLimiter,\n    size_t wordsUsed)\n    : SegmentReader(arena, id, ptr, readLimiter), pos(ptr.begin() + wordsUsed), readOnly(false) {}"
  },
  {
    "function_name": "SegmentReader::unread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "389-389",
    "snippet": "inline void SegmentReader::unread(WordCount64 amount) { readLimiter->unread(amount); }",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readLimiter->unread",
          "args": [
            "amount"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline void SegmentReader::unread(WordCount64 amount) { readLimiter->unread(amount); }"
  },
  {
    "function_name": "SegmentReader::getArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "388-388",
    "snippet": "inline kj::ArrayPtr<const word> SegmentReader::getArray() { return ptr; }",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline kj::ArrayPtr<const word> SegmentReader::getArray() { return ptr; }"
  },
  {
    "function_name": "SegmentReader::getSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "387-387",
    "snippet": "inline WordCount SegmentReader::getSize() { return ptr.size() * WORDS; }",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr.size",
          "args": [],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline WordCount SegmentReader::getSize() { return ptr.size() * WORDS; }"
  },
  {
    "function_name": "SegmentReader::getOffsetTo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "384-386",
    "snippet": "inline WordCount SegmentReader::getOffsetTo(const word* ptr) {\n  return intervalLength(this->ptr.begin(), ptr);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "intervalLength",
          "args": [
            "this->ptr.begin()",
            "ptr"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "intervalLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "415-417",
          "snippet": "inline constexpr WordCount intervalLength(const word* a, const word* b) {\n  return uint(b - a) * WORDS;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr WordCount intervalLength(const word* a, const word* b) {\n  return uint(b - a) * WORDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->ptr.begin",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline WordCount SegmentReader::getOffsetTo(const word* ptr) {\n  return intervalLength(this->ptr.begin(), ptr);\n}"
  },
  {
    "function_name": "SegmentReader::getSegmentId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "382-382",
    "snippet": "inline SegmentId SegmentReader::getSegmentId() { return id; }",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline SegmentId SegmentReader::getSegmentId() { return id; }"
  },
  {
    "function_name": "SegmentReader::amplifiedRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "377-379",
    "snippet": "inline bool SegmentReader::amplifiedRead(WordCount virtualAmount) {\n  return readLimiter->canRead(virtualAmount, arena);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readLimiter->canRead",
          "args": [
            "virtualAmount",
            "arena"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline bool SegmentReader::amplifiedRead(WordCount virtualAmount) {\n  return readLimiter->canRead(virtualAmount, arena);\n}"
  },
  {
    "function_name": "SegmentReader::containsInterval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "369-375",
    "snippet": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to)) / BYTES_PER_WORD,\n          arena);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readLimiter->canRead",
          "args": [
            "intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to)) / BYTES_PER_WORD",
            "arena"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intervalLength",
          "args": [
            "reinterpret_cast<const byte*>(from)",
            "reinterpret_cast<const byte*>(to)"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "intervalLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "415-417",
          "snippet": "inline constexpr WordCount intervalLength(const word* a, const word* b) {\n  return uint(b - a) * WORDS;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr WordCount intervalLength(const word* a, const word* b) {\n  return uint(b - a) * WORDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "to"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "from"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->ptr.end",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "this->ptr.begin",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to)) / BYTES_PER_WORD,\n          arena);\n}"
  },
  {
    "function_name": "SegmentReader::SegmentReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "365-367",
    "snippet": "inline SegmentReader::SegmentReader(Arena* arena, SegmentId id, kj::ArrayPtr<const word> ptr,\n                                    ReadLimiter* readLimiter)\n    : arena(arena), id(id), ptr(ptr), readLimiter(readLimiter) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline SegmentReader::SegmentReader(Arena* arena, SegmentId id, kj::ArrayPtr<const word> ptr,\n                                    ReadLimiter* readLimiter)\n    : arena(arena), id(id), ptr(ptr), readLimiter(readLimiter) {}"
  },
  {
    "function_name": "ReadLimiter::canRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "350-361",
    "snippet": "inline bool ReadLimiter::canRead(WordCount amount, Arena* arena) {\n  // Be careful not to store an underflowed value into `limit`, even if multiple threads are\n  // decrementing it.\n  uint64_t current = limit;\n  if (KJ_UNLIKELY(amount / WORDS > current)) {\n    arena->reportReadLimitReached();\n    return false;\n  } else {\n    limit = current - amount / WORDS;\n    return true;\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena->reportReadLimitReached",
          "args": [],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "amount / WORDS > current"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline bool ReadLimiter::canRead(WordCount amount, Arena* arena) {\n  // Be careful not to store an underflowed value into `limit`, even if multiple threads are\n  // decrementing it.\n  uint64_t current = limit;\n  if (KJ_UNLIKELY(amount / WORDS > current)) {\n    arena->reportReadLimitReached();\n    return false;\n  } else {\n    limit = current - amount / WORDS;\n    return true;\n  }\n}"
  },
  {
    "function_name": "ReadLimiter::reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "348-348",
    "snippet": "inline void ReadLimiter::reset(WordCount64 limit) { this->limit = limit / WORDS; }",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline void ReadLimiter::reset(WordCount64 limit) { this->limit = limit / WORDS; }"
  },
  {
    "function_name": "ReadLimiter::ReadLimiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "346-346",
    "snippet": "inline ReadLimiter::ReadLimiter(WordCount64 limit): limit(limit / WORDS) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline ReadLimiter::ReadLimiter(WordCount64 limit): limit(limit / WORDS) {}"
  },
  {
    "function_name": "ReadLimiter::ReadLimiter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "343-344",
    "snippet": "inline ReadLimiter::ReadLimiter()\n    : limit(kj::maxValue) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\ninline ReadLimiter::ReadLimiter()\n    : limit(kj::maxValue) {}"
  },
  {
    "function_name": "getCapTable",
    "container": "BuilderArena",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "270-270",
    "snippet": "inline kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() { return capTable; }",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\nBuilderArena {\n  inline kj::ArrayPtr<kj::Maybe<kj::Own<ClientHook>>> getCapTable() { return capTable; }\n}"
  },
  {
    "function_name": "initCapTable",
    "container": "ReaderArena",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "217-222",
    "snippet": "inline void initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>> capTable) {\n    // Imbues the arena with a capability table.  This is not passed to the constructor because the\n    // table itself may be built based on some other part of the message (as is the case with the\n    // RPC protocol).\n    this->capTable = kj::mv(capTable);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "capTable"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\nReaderArena {\n  inline void initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>> capTable) {\n      // Imbues the arena with a capability table.  This is not passed to the constructor because the\n      // table itself may be built based on some other part of the message (as is the case with the\n      // RPC protocol).\n      this->capTable = kj::mv(capTable);\n    }\n}"
  },
  {
    "function_name": "isWritable",
    "container": "SegmentBuilder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
    "lines": "174-174",
    "snippet": "inline bool isWritable() { return !readOnly; }",
    "includes": [
      "#include \"capability.h\"",
      "#include <unordered_map>",
      "#include \"layout.h\"",
      "#include \"message.h\"",
      "#include \"common.h\"",
      "#include <kj/vector.h>",
      "#include <kj/exception.h>",
      "#include <kj/mutex.h>",
      "#include <kj/common.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\nSegmentBuilder {\n  inline bool isWritable() { return !readOnly; }\n}"
  }
]