[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "330-334",
    "snippet": "TEST(Array, Map) {\n  StringPtr foo = \"abcd\";\n  Array<char> bar = KJ_MAP(c, foo) -> char { return c + 1; };\n  EXPECT_STREQ(\"bcde\", str(bar).cStr());\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_STREQ",
          "args": [
            "\"bcde\"",
            "str(bar).cStr()"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "destroy",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "115-117",
          "snippet": "void destroy() {\n    doAll(destroyVariant<Variants>()...);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  void destroy() {\n      doAll(destroyVariant<Variants>()...);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "bar"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "c",
            "foo"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, Map) {\n  StringPtr foo = \"abcd\";\n  Array<char> bar = KJ_MAP(c, foo) -> char { return c + 1; };\n  EXPECT_STREQ(\"bcde\", str(bar).cStr());\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "309-328",
    "snippet": "TEST(Array, OwnConst) {\n  ArrayBuilder<int> builder = heapArrayBuilder<int>(2);\n  int x[2] = {123, 234};\n  builder.addAll(x, x + 2);\n\n  Array<int> i = builder.finish(); //heapArray<int>({123, 234});\n  ASSERT_EQ(2u, i.size());\n  EXPECT_EQ(123, i[0]);\n  EXPECT_EQ(234, i[1]);\n\n  Array<const int> ci = mv(i);\n  ASSERT_EQ(2u, ci.size());\n  EXPECT_EQ(123, ci[0]);\n  EXPECT_EQ(234, ci[1]);\n\n  Array<const int> ci2 = heapArray<const int>({345, 456});\n  ASSERT_EQ(2u, ci2.size());\n  EXPECT_EQ(345, ci2[0]);\n  EXPECT_EQ(456, ci2[1]);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "ci2[1]"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "345",
            "ci2[0]"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "2u",
            "ci2.size()"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ci2.size",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArray<const int>",
          "args": [
            "{345, 456}"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "234",
            "ci[1]"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "ci[0]"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "2u",
            "ci.size()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "i"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "234",
            "i[1]"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "i[0]"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "2u",
            "i.size()"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i.size",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "FixedArray",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "426-426",
          "snippet": "inline size_t size() const { return fixedSize; }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nFixedArray {\n  inline size_t size() const { return fixedSize; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.addAll",
          "args": [
            "x",
            "x + 2"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "81-85",
          "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<int>",
          "args": [
            "2"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, OwnConst) {\n  ArrayBuilder<int> builder = heapArrayBuilder<int>(2);\n  int x[2] = {123, 234};\n  builder.addAll(x, x + 2);\n\n  Array<int> i = builder.finish(); //heapArray<int>({123, 234});\n  ASSERT_EQ(2u, i.size());\n  EXPECT_EQ(123, i[0]);\n  EXPECT_EQ(234, i[1]);\n\n  Array<const int> ci = mv(i);\n  ASSERT_EQ(2u, ci.size());\n  EXPECT_EQ(123, ci[0]);\n  EXPECT_EQ(234, ci[1]);\n\n  Array<const int> ci2 = heapArray<const int>({345, 456});\n  ASSERT_EQ(2u, ci2.size());\n  EXPECT_EQ(345, ci2[0]);\n  EXPECT_EQ(456, ci2[1]);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "290-307",
    "snippet": "TEST(Array, HeapCopy) {\n  {\n    Array<char> copy = heapArray(\"foo\", 3);\n    EXPECT_EQ(3u, copy.size());\n    EXPECT_EQ(\"foo\", std::string(copy.begin(), 3));\n  }\n  {\n    Array<char> copy = heapArray(ArrayPtr<const char>(\"bar\", 3));\n    EXPECT_EQ(3u, copy.size());\n    EXPECT_EQ(\"bar\", std::string(copy.begin(), 3));\n  }\n  {\n    const char* ptr = \"baz\";\n    Array<char> copy = heapArray<char>(ptr, ptr + 3);\n    EXPECT_EQ(3u, copy.size());\n    EXPECT_EQ(\"baz\", std::string(copy.begin(), 3));\n  }\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"baz\"",
            "std::string(copy.begin(), 3)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "copy.begin()",
            "3"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy.begin",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "copy.size()"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy.size",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArray<char>",
          "args": [
            "ptr",
            "ptr + 3"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "688-693",
          "snippet": "Array<T>\nheapArray(Iterator begin, Iterator end) {\n  ArrayBuilder<T> builder = heapArrayBuilder<T>(end - begin);\n  builder.addAll(begin, end);\n  return builder.finish();\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArray<T>\nheapArray(Iterator begin, Iterator end) {\n  ArrayBuilder<T> builder = heapArrayBuilder<T>(end - begin);\n  builder.addAll(begin, end);\n  return builder.finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "std::string(copy.begin(), 3)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "copy.begin()",
            "3"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "copy.size()"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayPtr<const char>",
          "args": [
            "\"bar\"",
            "3"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "std::string(copy.begin(), 3)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "copy.begin()",
            "3"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3u",
            "copy.size()"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, HeapCopy) {\n  {\n    Array<char> copy = heapArray(\"foo\", 3);\n    EXPECT_EQ(3u, copy.size());\n    EXPECT_EQ(\"foo\", std::string(copy.begin(), 3));\n  }\n  {\n    Array<char> copy = heapArray(ArrayPtr<const char>(\"bar\", 3));\n    EXPECT_EQ(3u, copy.size());\n    EXPECT_EQ(\"bar\", std::string(copy.begin(), 3));\n  }\n  {\n    const char* ptr = \"baz\";\n    Array<char> copy = heapArray<char>(ptr, ptr + 3);\n    EXPECT_EQ(3u, copy.size());\n    EXPECT_EQ(\"baz\", std::string(copy.begin(), 3));\n  }\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "173-288",
    "snippet": "TEST(Array, AraryBuilderAddAll) {\n  {\n    // Trivial case.\n    char text[] = \"foo\";\n    ArrayBuilder<char> builder = heapArrayBuilder<char>(5);\n    builder.add('<');\n    builder.addAll(text, text + 3);\n    builder.add('>');\n    auto array = builder.finish();\n    EXPECT_EQ(\"<foo>\", std::string(array.begin(), array.end()));\n  }\n\n  {\n    // Trivial case, const.\n    const char* text = \"foo\";\n    ArrayBuilder<char> builder = heapArrayBuilder<char>(5);\n    builder.add('<');\n    builder.addAll(text, text + 3);\n    builder.add('>');\n    auto array = builder.finish();\n    EXPECT_EQ(\"<foo>\", std::string(array.begin(), array.end()));\n  }\n\n  {\n    // Trivial case, non-pointer iterator.\n    std::list<char> text = {'f', 'o', 'o'};\n    ArrayBuilder<char> builder = heapArrayBuilder<char>(5);\n    builder.add('<');\n    builder.addAll(text);\n    builder.add('>');\n    auto array = builder.finish();\n    EXPECT_EQ(\"<foo>\", std::string(array.begin(), array.end()));\n  }\n\n  {\n    // Complex case.\n    std::string strs[] = {\"foo\", \"bar\", \"baz\"};\n    ArrayBuilder<std::string> builder = heapArrayBuilder<std::string>(5);\n    builder.add(\"qux\");\n    builder.addAll(strs, strs + 3);\n    builder.add(\"quux\");\n    auto array = builder.finish();\n    EXPECT_EQ(\"qux\", array[0]);\n    EXPECT_EQ(\"foo\", array[1]);\n    EXPECT_EQ(\"bar\", array[2]);\n    EXPECT_EQ(\"baz\", array[3]);\n    EXPECT_EQ(\"quux\", array[4]);\n  }\n\n  {\n    // Complex case, noexcept.\n    TestNoexceptObject::count = 0;\n    TestNoexceptObject::copiedCount = 0;\n    TestNoexceptObject objs[3];\n    EXPECT_EQ(3, TestNoexceptObject::count);\n    EXPECT_EQ(0, TestNoexceptObject::copiedCount);\n    ArrayBuilder<TestNoexceptObject> builder = heapArrayBuilder<TestNoexceptObject>(3);\n    EXPECT_EQ(3, TestNoexceptObject::count);\n    EXPECT_EQ(0, TestNoexceptObject::copiedCount);\n    builder.addAll(objs, objs + 3);\n    EXPECT_EQ(3, TestNoexceptObject::count);\n    EXPECT_EQ(3, TestNoexceptObject::copiedCount);\n    auto array = builder.finish();\n    EXPECT_EQ(3, TestNoexceptObject::count);\n    EXPECT_EQ(3, TestNoexceptObject::copiedCount);\n  }\n  EXPECT_EQ(0, TestNoexceptObject::count);\n  EXPECT_EQ(0, TestNoexceptObject::copiedCount);\n\n  {\n    // Complex case, exceptions possible.\n    TestObject::count = 0;\n    TestObject::copiedCount = 0;\n    TestObject::throwAt = -1;\n    TestObject objs[3];\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n    ArrayBuilder<TestObject> builder = heapArrayBuilder<TestObject>(3);\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n    builder.addAll(objs, objs + 3);\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(3, TestObject::copiedCount);\n    auto array = builder.finish();\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(3, TestObject::copiedCount);\n  }\n  EXPECT_EQ(0, TestObject::count);\n  EXPECT_EQ(0, TestObject::copiedCount);\n\n#if !KJ_NO_EXCEPTIONS\n  {\n    // Complex case, exceptions occur.\n    TestObject::count = 0;\n    TestObject::copiedCount = 0;\n    TestObject::throwAt = -1;\n    TestObject objs[3];\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n\n    TestObject::throwAt = 1;\n\n    ArrayBuilder<TestObject> builder = heapArrayBuilder<TestObject>(3);\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n\n    EXPECT_ANY_THROW(builder.addAll(objs, objs + 3));\n    TestObject::throwAt = -1;\n\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n  }\n  EXPECT_EQ(0, TestObject::count);\n  EXPECT_EQ(0, TestObject::copiedCount);\n#endif  // !KJ_NO_EXCEPTIONS\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::copiedCount"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::count"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::copiedCount"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::count"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "builder.addAll(objs, objs + 3)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.addAll",
          "args": [
            "objs",
            "objs + 3"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "81-85",
          "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::copiedCount"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::count"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<TestObject>",
          "args": [
            "3"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::copiedCount"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::count"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::copiedCount"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::count"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::copiedCount"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::count"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::copiedCount"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::count"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::copiedCount"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::count"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::copiedCount"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestObject::count"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestNoexceptObject::copiedCount"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestNoexceptObject::count"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestNoexceptObject::copiedCount"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestNoexceptObject::count"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestNoexceptObject::copiedCount"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestNoexceptObject::count"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestNoexceptObject::copiedCount"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestNoexceptObject::count"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestNoexceptObject::copiedCount"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "3",
            "TestNoexceptObject::count"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"quux\"",
            "array[4]"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"baz\"",
            "array[3]"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"bar\"",
            "array[2]"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "array[1]"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"qux\"",
            "array[0]"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.add",
          "args": [
            "\"quux\""
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"<foo>\"",
            "std::string(array.begin(), array.end())"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "array.begin()",
            "array.end()"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array.end",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "array.begin",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.addAll",
          "args": [
            "text"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "357-359",
          "snippet": "void addAll(Container&& container) {\n    addAll(container.begin(), container.end());\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  void addAll(Container&& container) {\n      addAll(container.begin(), container.end());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"<foo>\"",
            "std::string(array.begin(), array.end())"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "array.begin()",
            "array.end()"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"<foo>\"",
            "std::string(array.begin(), array.end())"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "array.begin()",
            "array.end()"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, AraryBuilderAddAll) {\n  {\n    // Trivial case.\n    char text[] = \"foo\";\n    ArrayBuilder<char> builder = heapArrayBuilder<char>(5);\n    builder.add('<');\n    builder.addAll(text, text + 3);\n    builder.add('>');\n    auto array = builder.finish();\n    EXPECT_EQ(\"<foo>\", std::string(array.begin(), array.end()));\n  }\n\n  {\n    // Trivial case, const.\n    const char* text = \"foo\";\n    ArrayBuilder<char> builder = heapArrayBuilder<char>(5);\n    builder.add('<');\n    builder.addAll(text, text + 3);\n    builder.add('>');\n    auto array = builder.finish();\n    EXPECT_EQ(\"<foo>\", std::string(array.begin(), array.end()));\n  }\n\n  {\n    // Trivial case, non-pointer iterator.\n    std::list<char> text = {'f', 'o', 'o'};\n    ArrayBuilder<char> builder = heapArrayBuilder<char>(5);\n    builder.add('<');\n    builder.addAll(text);\n    builder.add('>');\n    auto array = builder.finish();\n    EXPECT_EQ(\"<foo>\", std::string(array.begin(), array.end()));\n  }\n\n  {\n    // Complex case.\n    std::string strs[] = {\"foo\", \"bar\", \"baz\"};\n    ArrayBuilder<std::string> builder = heapArrayBuilder<std::string>(5);\n    builder.add(\"qux\");\n    builder.addAll(strs, strs + 3);\n    builder.add(\"quux\");\n    auto array = builder.finish();\n    EXPECT_EQ(\"qux\", array[0]);\n    EXPECT_EQ(\"foo\", array[1]);\n    EXPECT_EQ(\"bar\", array[2]);\n    EXPECT_EQ(\"baz\", array[3]);\n    EXPECT_EQ(\"quux\", array[4]);\n  }\n\n  {\n    // Complex case, noexcept.\n    TestNoexceptObject::count = 0;\n    TestNoexceptObject::copiedCount = 0;\n    TestNoexceptObject objs[3];\n    EXPECT_EQ(3, TestNoexceptObject::count);\n    EXPECT_EQ(0, TestNoexceptObject::copiedCount);\n    ArrayBuilder<TestNoexceptObject> builder = heapArrayBuilder<TestNoexceptObject>(3);\n    EXPECT_EQ(3, TestNoexceptObject::count);\n    EXPECT_EQ(0, TestNoexceptObject::copiedCount);\n    builder.addAll(objs, objs + 3);\n    EXPECT_EQ(3, TestNoexceptObject::count);\n    EXPECT_EQ(3, TestNoexceptObject::copiedCount);\n    auto array = builder.finish();\n    EXPECT_EQ(3, TestNoexceptObject::count);\n    EXPECT_EQ(3, TestNoexceptObject::copiedCount);\n  }\n  EXPECT_EQ(0, TestNoexceptObject::count);\n  EXPECT_EQ(0, TestNoexceptObject::copiedCount);\n\n  {\n    // Complex case, exceptions possible.\n    TestObject::count = 0;\n    TestObject::copiedCount = 0;\n    TestObject::throwAt = -1;\n    TestObject objs[3];\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n    ArrayBuilder<TestObject> builder = heapArrayBuilder<TestObject>(3);\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n    builder.addAll(objs, objs + 3);\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(3, TestObject::copiedCount);\n    auto array = builder.finish();\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(3, TestObject::copiedCount);\n  }\n  EXPECT_EQ(0, TestObject::count);\n  EXPECT_EQ(0, TestObject::copiedCount);\n\n#if !KJ_NO_EXCEPTIONS\n  {\n    // Complex case, exceptions occur.\n    TestObject::count = 0;\n    TestObject::copiedCount = 0;\n    TestObject::throwAt = -1;\n    TestObject objs[3];\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n\n    TestObject::throwAt = 1;\n\n    ArrayBuilder<TestObject> builder = heapArrayBuilder<TestObject>(3);\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n\n    EXPECT_ANY_THROW(builder.addAll(objs, objs + 3));\n    TestObject::throwAt = -1;\n\n    EXPECT_EQ(3, TestObject::count);\n    EXPECT_EQ(0, TestObject::copiedCount);\n  }\n  EXPECT_EQ(0, TestObject::count);\n  EXPECT_EQ(0, TestObject::copiedCount);\n#endif  // !KJ_NO_EXCEPTIONS\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "149-171",
    "snippet": "TEST(Array, AraryBuilder) {\n  TestObject::count = 0;\n  TestObject::throwAt = -1;\n\n  Array<TestObject> array;\n\n  {\n    ArrayBuilder<TestObject> builder = heapArrayBuilder<TestObject>(32);\n\n    for (int i = 0; i < 32; i++) {\n      EXPECT_EQ(i, TestObject::count);\n      builder.add();\n    }\n\n    EXPECT_EQ(32, TestObject::count);\n    array = builder.finish();\n    EXPECT_EQ(32, TestObject::count);\n  }\n\n  EXPECT_EQ(32, TestObject::count);\n  array = nullptr;\n  EXPECT_EQ(0, TestObject::count);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::count"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "32",
            "TestObject::count"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "32",
            "TestObject::count"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.finish",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "32",
            "TestObject::count"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.add",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "i",
            "TestObject::count"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapArrayBuilder<TestObject>",
          "args": [
            "32"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, AraryBuilder) {\n  TestObject::count = 0;\n  TestObject::throwAt = -1;\n\n  Array<TestObject> array;\n\n  {\n    ArrayBuilder<TestObject> builder = heapArrayBuilder<TestObject>(32);\n\n    for (int i = 0; i < 32; i++) {\n      EXPECT_EQ(i, TestObject::count);\n      builder.add();\n    }\n\n    EXPECT_EQ(32, TestObject::count);\n    array = builder.finish();\n    EXPECT_EQ(32, TestObject::count);\n  }\n\n  EXPECT_EQ(32, TestObject::count);\n  array = nullptr;\n  EXPECT_EQ(0, TestObject::count);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "135-146",
    "snippet": "TEST(Array, ThrowingDestructor) {\n  TestObject::count = 0;\n  TestObject::throwAt = -1;\n\n  Array<TestObject> array = heapArray<TestObject>(32);\n  EXPECT_EQ(32, TestObject::count);\n\n  // If a destructor throws, all elements should still be destroyed.\n  TestObject::throwAt = 16;\n  EXPECT_ANY_THROW(array = nullptr);\n  EXPECT_EQ(0, TestObject::count);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::count"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "array = nullptr"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "32",
            "TestObject::count"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapArray<TestObject>",
          "args": [
            "32"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, ThrowingDestructor) {\n  TestObject::count = 0;\n  TestObject::throwAt = -1;\n\n  Array<TestObject> array = heapArray<TestObject>(32);\n  EXPECT_EQ(32, TestObject::count);\n\n  // If a destructor throws, all elements should still be destroyed.\n  TestObject::throwAt = 16;\n  EXPECT_ANY_THROW(array = nullptr);\n  EXPECT_EQ(0, TestObject::count);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "126-133",
    "snippet": "TEST(Array, ThrowingConstructor) {\n  TestObject::count = 0;\n  TestObject::throwAt = 16;\n\n  // If a constructor throws, the previous elements should still be destroyed.\n  EXPECT_ANY_THROW(heapArray<TestObject>(32));\n  EXPECT_EQ(0, TestObject::count);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::count"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_ANY_THROW",
          "args": [
            "heapArray<TestObject>(32)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapArray<TestObject>",
          "args": [
            "32"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, ThrowingConstructor) {\n  TestObject::count = 0;\n  TestObject::throwAt = 16;\n\n  // If a constructor throws, the previous elements should still be destroyed.\n  EXPECT_ANY_THROW(heapArray<TestObject>(32));\n  EXPECT_EQ(0, TestObject::count);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "114-123",
    "snippet": "TEST(Array, ComplexConstructor) {\n  TestObject::count = 0;\n  TestObject::throwAt = -1;\n\n  {\n    Array<TestObject> array = heapArray<TestObject>(32);\n    EXPECT_EQ(32, TestObject::count);\n  }\n  EXPECT_EQ(0, TestObject::count);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "TestObject::count"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "32",
            "TestObject::count"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapArray<TestObject>",
          "args": [
            "32"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, ComplexConstructor) {\n  TestObject::count = 0;\n  TestObject::throwAt = -1;\n\n  {\n    Array<TestObject> array = heapArray<TestObject>(32);\n    EXPECT_EQ(32, TestObject::count);\n  }\n  EXPECT_EQ(0, TestObject::count);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "90-112",
    "snippet": "TEST(Array, TrivialConstructor) {\n//  char* ptr;\n  {\n    Array<char> chars = heapArray<char>(32);\n//    ptr = chars.begin();\n    chars[0] = 12;\n    chars[1] = 34;\n  }\n\n  {\n    Array<char> chars = heapArray<char>(32);\n\n    // TODO(test):  The following doesn't work in opt mode -- I guess some allocators zero the\n    //   memory?  Is there some other way we can test this?  Maybe override malloc()?\n//    // Somewhat hacky:  We can't guarantee that the new array is allocated in the same place, but\n//    // any reasonable allocator is highly likely to do so.  If it does, then we expect that the\n//    // memory has not been initialized.\n//    if (chars.begin() == ptr) {\n//      EXPECT_NE(chars[0], 0);\n//      EXPECT_NE(chars[1], 0);\n//    }\n  }\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heapArray<char>",
          "args": [
            "32"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTEST(Array, TrivialConstructor) {\n//  char* ptr;\n  {\n    Array<char> chars = heapArray<char>(32);\n//    ptr = chars.begin();\n    chars[0] = 12;\n    chars[1] = 34;\n  }\n\n  {\n    Array<char> chars = heapArray<char>(32);\n\n    // TODO(test):  The following doesn't work in opt mode -- I guess some allocators zero the\n    //   memory?  Is there some other way we can test this?  Maybe override malloc()?\n//    // Somewhat hacky:  We can't guarantee that the new array is allocated in the same place, but\n//    // any reasonable allocator is highly likely to do so.  If it does, then we expect that the\n//    // memory has not been initialized.\n//    if (chars.begin() == ptr) {\n//      EXPECT_NE(chars[0], 0);\n//      EXPECT_NE(chars[1], 0);\n//    }\n  }\n}"
  },
  {
    "function_name": "TestNoexceptObject",
    "container": "TestNoexceptObject",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "68-71",
    "snippet": "TestNoexceptObject(const TestNoexceptObject& other) noexcept {\n    index = -1;\n    copiedCount++;\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTestNoexceptObject {\n  TestNoexceptObject(const TestNoexceptObject& other) noexcept {\n      index = -1;\n      copiedCount++;\n    }\n}"
  },
  {
    "function_name": "TestNoexceptObject",
    "container": "TestNoexceptObject",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "64-67",
    "snippet": "TestNoexceptObject() noexcept {\n    index = count;\n    ++count;\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTestNoexceptObject {\n  TestNoexceptObject() noexcept {\n      index = count;\n      ++count;\n    }\n}"
  },
  {
    "function_name": "TestObject",
    "container": "TestObject",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "37-41",
    "snippet": "TestObject(const TestObject& other) {\n    KJ_ASSERT(other.index != throwAt);\n    index = -1;\n    copiedCount++;\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "other.index != throwAt"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTestObject {\n  TestObject(const TestObject& other) {\n      KJ_ASSERT(other.index != throwAt);\n      index = -1;\n      copiedCount++;\n    }\n}"
  },
  {
    "function_name": "TestObject",
    "container": "TestObject",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array-test.c++",
    "lines": "32-36",
    "snippet": "TestObject() {\n    index = count;\n    KJ_ASSERT(index != throwAt);\n    ++count;\n  }",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <list>",
      "#include <string>",
      "#include \"debug.h\"",
      "#include \"array.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "index != throwAt"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <list>\n#include <string>\n#include \"debug.h\"\n#include \"array.h\"\n\nTestObject {\n  TestObject() {\n      index = count;\n      KJ_ASSERT(index != throwAt);\n      ++count;\n    }\n}"
  }
]