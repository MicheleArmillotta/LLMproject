[
  {
    "function_name": "UnixEventPort::wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "815-820",
    "snippet": "void UnixEventPort::wake() const {\n  int error = pthread_kill(*reinterpret_cast<const pthread_t*>(&threadId), reservedSignal);\n  if (error != 0) {\n    KJ_FAIL_SYSCALL(\"pthread_kill\", error);\n  }\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"pthread_kill\"",
            "error"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_kill",
          "args": [
            "*reinterpret_cast<const pthread_t*>(&threadId)",
            "reservedSignal"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const pthread_t*>",
          "args": [
            "&threadId"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::wake() const {\n  int error = pthread_kill(*reinterpret_cast<const pthread_t*>(&threadId), reservedSignal);\n  if (error != 0) {\n    KJ_FAIL_SYSCALL(\"pthread_kill\", error);\n  }\n}"
  },
  {
    "function_name": "UnixEventPort::poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "753-813",
    "snippet": "bool UnixEventPort::poll() {\n  // volatile so that longjmp() doesn't clobber it.\n  volatile bool woken = false;\n\n  sigset_t pending;\n  sigset_t waitMask;\n  sigemptyset(&pending);\n  sigfillset(&waitMask);\n\n  // Count how many signals that we care about are pending.\n  KJ_SYSCALL(sigpending(&pending));\n  uint signalCount = 0;\n\n  if (sigismember(&pending, reservedSignal)) {\n    ++signalCount;\n    sigdelset(&pending, reservedSignal);\n    sigdelset(&waitMask, reservedSignal);\n  }\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      if (sigismember(&pending, ptr->signum)) {\n        ++signalCount;\n        sigdelset(&pending, ptr->signum);\n        sigdelset(&waitMask, ptr->signum);\n      }\n      ptr = ptr->next;\n    }\n  }\n\n  // Wait for each pending signal.  It would be nice to use sigtimedwait() here but it is not\n  // available on OSX.  :(  Instead, we call sigsuspend() once per expected signal.\n  while (signalCount-- > 0) {\n    SignalCapture capture;\n    threadCapture = &capture;\n    if (sigsetjmp(capture.jumpTo, true)) {\n      // We received a signal and longjmp'd back out of the signal handler.\n      sigdelset(&waitMask, capture.siginfo.si_signo);\n      if (capture.siginfo.si_signo == reservedSignal) {\n        woken = true;\n      } else {\n        gotSignal(capture.siginfo);\n      }\n    } else {\n      sigsuspend(&waitMask);\n      KJ_FAIL_ASSERT(\"sigsuspend() shouldn't return because the signal handler should \"\n                     \"have siglongjmp()ed.\");\n    }\n    threadCapture = nullptr;\n  }\n\n  {\n    PollContext pollContext(observersHead);\n    pollContext.run(0);\n    pollContext.processResults();\n  }\n  processTimers();\n\n  return woken;\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "processTimers",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::processTimers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "94-103",
          "snippet": "void UnixEventPort::processTimers() {\n  frozenSteadyTime = currentSteadyTime();\n  for (;;) {\n    auto front = timers->timers.begin();\n    if (front == timers->timers.end() || (*front)->time > frozenSteadyTime) {\n      break;\n    }\n    (*front)->fulfill();\n  }\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::processTimers() {\n  frozenSteadyTime = currentSteadyTime();\n  for (;;) {\n    auto front = timers->timers.begin();\n    if (front == timers->timers.end() || (*front)->time > frozenSteadyTime) {\n      break;\n    }\n    (*front)->fulfill();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pollContext.processResults",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "processResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "665-678",
          "snippet": "void processResults() {\n    if (pollResult < 0) {\n      KJ_FAIL_SYSCALL(\"poll()\", pollError);\n    }\n\n    for (auto i: indices(pollfds)) {\n      if (pollfds[i].revents != 0) {\n        pollEvents[i]->fire(pollfds[i].revents);\n        if (--pollResult <= 0) {\n          break;\n        }\n      }\n    }\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid processResults() {\n    if (pollResult < 0) {\n      KJ_FAIL_SYSCALL(\"poll()\", pollError);\n    }\n\n    for (auto i: indices(pollfds)) {\n      if (pollfds[i].revents != 0) {\n        pollEvents[i]->fire(pollfds[i].revents);\n        if (--pollResult <= 0) {\n          break;\n        }\n      }\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "pollContext.run",
          "args": [
            "0"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "655-663",
          "snippet": "void run(int timeout) {\n    do {\n      pollResult = ::poll(pollfds.begin(), pollfds.size(), timeout);\n      pollError = pollResult < 0 ? errno : 0;\n\n      // EINTR should only happen if we received a signal *other than* the ones registered via\n      // the UnixEventPort, so we don't care about that case.\n    } while (pollError == EINTR);\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid run(int timeout) {\n    do {\n      pollResult = ::poll(pollfds.begin(), pollfds.size(), timeout);\n      pollError = pollResult < 0 ? errno : 0;\n\n      // EINTR should only happen if we received a signal *other than* the ones registered via\n      // the UnixEventPort, so we don't care about that case.\n    } while (pollError == EINTR);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"sigsuspend() shouldn't return because the signal handler should \"\n                     \"have siglongjmp()ed.\""
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigsuspend",
          "args": [
            "&waitMask"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gotSignal",
          "args": [
            "capture.siginfo"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::gotSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "232-243",
          "snippet": "void UnixEventPort::gotSignal(const siginfo_t& siginfo) {\n  // Fire any events waiting on this signal.\n  auto ptr = signalHead;\n  while (ptr != nullptr) {\n    if (ptr->signum == siginfo.si_signo) {\n      ptr->fulfiller.fulfill(kj::cp(siginfo));\n      ptr = ptr->removeFromList();\n    } else {\n      ptr = ptr->next;\n    }\n  }\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::gotSignal(const siginfo_t& siginfo) {\n  // Fire any events waiting on this signal.\n  auto ptr = signalHead;\n  while (ptr != nullptr) {\n    if (ptr->signum == siginfo.si_signo) {\n      ptr->fulfiller.fulfill(kj::cp(siginfo));\n      ptr = ptr->removeFromList();\n    } else {\n      ptr = ptr->next;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&waitMask",
            "capture.siginfo.si_signo"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigsetjmp",
          "args": [
            "capture.jumpTo",
            "true"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&waitMask",
            "ptr->signum"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&pending",
            "ptr->signum"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&pending",
            "ptr->signum"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&waitMask",
            "reservedSignal"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&pending",
            "reservedSignal"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&pending",
            "reservedSignal"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigpending(&pending)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigpending",
          "args": [
            "&pending"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&waitMask"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&pending"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nbool UnixEventPort::poll() {\n  // volatile so that longjmp() doesn't clobber it.\n  volatile bool woken = false;\n\n  sigset_t pending;\n  sigset_t waitMask;\n  sigemptyset(&pending);\n  sigfillset(&waitMask);\n\n  // Count how many signals that we care about are pending.\n  KJ_SYSCALL(sigpending(&pending));\n  uint signalCount = 0;\n\n  if (sigismember(&pending, reservedSignal)) {\n    ++signalCount;\n    sigdelset(&pending, reservedSignal);\n    sigdelset(&waitMask, reservedSignal);\n  }\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      if (sigismember(&pending, ptr->signum)) {\n        ++signalCount;\n        sigdelset(&pending, ptr->signum);\n        sigdelset(&waitMask, ptr->signum);\n      }\n      ptr = ptr->next;\n    }\n  }\n\n  // Wait for each pending signal.  It would be nice to use sigtimedwait() here but it is not\n  // available on OSX.  :(  Instead, we call sigsuspend() once per expected signal.\n  while (signalCount-- > 0) {\n    SignalCapture capture;\n    threadCapture = &capture;\n    if (sigsetjmp(capture.jumpTo, true)) {\n      // We received a signal and longjmp'd back out of the signal handler.\n      sigdelset(&waitMask, capture.siginfo.si_signo);\n      if (capture.siginfo.si_signo == reservedSignal) {\n        woken = true;\n      } else {\n        gotSignal(capture.siginfo);\n      }\n    } else {\n      sigsuspend(&waitMask);\n      KJ_FAIL_ASSERT(\"sigsuspend() shouldn't return because the signal handler should \"\n                     \"have siglongjmp()ed.\");\n    }\n    threadCapture = nullptr;\n  }\n\n  {\n    PollContext pollContext(observersHead);\n    pollContext.run(0);\n    pollContext.processResults();\n  }\n  processTimers();\n\n  return woken;\n}"
  },
  {
    "function_name": "UnixEventPort::wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "687-751",
    "snippet": "bool UnixEventPort::wait() {\n  sigset_t newMask;\n  sigemptyset(&newMask);\n  sigaddset(&newMask, reservedSignal);\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      sigaddset(&newMask, ptr->signum);\n      ptr = ptr->next;\n    }\n  }\n\n  PollContext pollContext(observersHead);\n\n  // Capture signals.\n  SignalCapture capture;\n\n  if (sigsetjmp(capture.jumpTo, true)) {\n    // We received a signal and longjmp'd back out of the signal handler.\n    threadCapture = nullptr;\n\n    if (capture.siginfo.si_signo == reservedSignal) {\n      return true;\n    } else {\n      gotSignal(capture.siginfo);\n      return false;\n    }\n  }\n\n  // Enable signals, run the poll, then mask them again.\n  sigset_t origMask;\n  threadCapture = &capture;\n  sigprocmask(SIG_UNBLOCK, &newMask, &origMask);\n\n  // poll()'s timeout is an `int` count of milliseconds, so truncate to that.\n  // Also, make sure that we aren't within a millisecond of overflowing a `Duration` since that\n  // will break the math below.\n  constexpr Duration MAX_TIMEOUT =\n      min(int(maxValue) * MILLISECONDS, Duration(maxValue) - MILLISECONDS);\n\n  int pollTimeout = -1;\n  auto timer = timers->timers.begin();\n  if (timer != timers->timers.end()) {\n    Duration timeout = (*timer)->time - currentSteadyTime();\n    if (timeout < 0 * SECONDS) {\n      pollTimeout = 0;\n    } else if (timeout < MAX_TIMEOUT) {\n      // Round up to the next millisecond\n      pollTimeout = (timeout + 1 * MILLISECONDS - unit<Duration>()) / MILLISECONDS;\n    } else {\n      pollTimeout = MAX_TIMEOUT / MILLISECONDS;\n    }\n  }\n  pollContext.run(pollTimeout);\n\n  sigprocmask(SIG_SETMASK, &origMask, nullptr);\n  threadCapture = nullptr;\n\n  // Queue events.\n  pollContext.processResults();\n  processTimers();\n\n  return false;\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "processTimers",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::processTimers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "94-103",
          "snippet": "void UnixEventPort::processTimers() {\n  frozenSteadyTime = currentSteadyTime();\n  for (;;) {\n    auto front = timers->timers.begin();\n    if (front == timers->timers.end() || (*front)->time > frozenSteadyTime) {\n      break;\n    }\n    (*front)->fulfill();\n  }\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::processTimers() {\n  frozenSteadyTime = currentSteadyTime();\n  for (;;) {\n    auto front = timers->timers.begin();\n    if (front == timers->timers.end() || (*front)->time > frozenSteadyTime) {\n      break;\n    }\n    (*front)->fulfill();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pollContext.processResults",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "processResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "665-678",
          "snippet": "void processResults() {\n    if (pollResult < 0) {\n      KJ_FAIL_SYSCALL(\"poll()\", pollError);\n    }\n\n    for (auto i: indices(pollfds)) {\n      if (pollfds[i].revents != 0) {\n        pollEvents[i]->fire(pollfds[i].revents);\n        if (--pollResult <= 0) {\n          break;\n        }\n      }\n    }\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid processResults() {\n    if (pollResult < 0) {\n      KJ_FAIL_SYSCALL(\"poll()\", pollError);\n    }\n\n    for (auto i: indices(pollfds)) {\n      if (pollfds[i].revents != 0) {\n        pollEvents[i]->fire(pollfds[i].revents);\n        if (--pollResult <= 0) {\n          break;\n        }\n      }\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&origMask",
            "nullptr"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pollContext.run",
          "args": [
            "pollTimeout"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "655-663",
          "snippet": "void run(int timeout) {\n    do {\n      pollResult = ::poll(pollfds.begin(), pollfds.size(), timeout);\n      pollError = pollResult < 0 ? errno : 0;\n\n      // EINTR should only happen if we received a signal *other than* the ones registered via\n      // the UnixEventPort, so we don't care about that case.\n    } while (pollError == EINTR);\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid run(int timeout) {\n    do {\n      pollResult = ::poll(pollfds.begin(), pollfds.size(), timeout);\n      pollError = pollResult < 0 ? errno : 0;\n\n      // EINTR should only happen if we received a signal *other than* the ones registered via\n      // the UnixEventPort, so we don't care about that case.\n    } while (pollError == EINTR);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "unit<Duration>",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "unit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/units.h",
          "lines": "360-360",
          "snippet": "inline constexpr T unit() { return T(1); }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\ninline constexpr T unit() { return T(1); }"
        }
      },
      {
        "call_info": {
          "callee": "currentSteadyTime",
          "args": [],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::currentSteadyTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "89-92",
          "snippet": "TimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nTimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timers->timers.end",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "timers->timers.begin",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "int(maxValue) * MILLISECONDS",
            "Duration(maxValue) - MILLISECONDS"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Duration",
          "args": [
            "maxValue"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "maxValue"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_UNBLOCK",
            "&newMask",
            "&origMask"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gotSignal",
          "args": [
            "capture.siginfo"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::gotSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "232-243",
          "snippet": "void UnixEventPort::gotSignal(const siginfo_t& siginfo) {\n  // Fire any events waiting on this signal.\n  auto ptr = signalHead;\n  while (ptr != nullptr) {\n    if (ptr->signum == siginfo.si_signo) {\n      ptr->fulfiller.fulfill(kj::cp(siginfo));\n      ptr = ptr->removeFromList();\n    } else {\n      ptr = ptr->next;\n    }\n  }\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::gotSignal(const siginfo_t& siginfo) {\n  // Fire any events waiting on this signal.\n  auto ptr = signalHead;\n  while (ptr != nullptr) {\n    if (ptr->signum == siginfo.si_signo) {\n      ptr->fulfiller.fulfill(kj::cp(siginfo));\n      ptr = ptr->removeFromList();\n    } else {\n      ptr = ptr->next;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigsetjmp",
          "args": [
            "capture.jumpTo",
            "true"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&newMask",
            "ptr->signum"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&newMask",
            "reservedSignal"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&newMask"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nbool UnixEventPort::wait() {\n  sigset_t newMask;\n  sigemptyset(&newMask);\n  sigaddset(&newMask, reservedSignal);\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      sigaddset(&newMask, ptr->signum);\n      ptr = ptr->next;\n    }\n  }\n\n  PollContext pollContext(observersHead);\n\n  // Capture signals.\n  SignalCapture capture;\n\n  if (sigsetjmp(capture.jumpTo, true)) {\n    // We received a signal and longjmp'd back out of the signal handler.\n    threadCapture = nullptr;\n\n    if (capture.siginfo.si_signo == reservedSignal) {\n      return true;\n    } else {\n      gotSignal(capture.siginfo);\n      return false;\n    }\n  }\n\n  // Enable signals, run the poll, then mask them again.\n  sigset_t origMask;\n  threadCapture = &capture;\n  sigprocmask(SIG_UNBLOCK, &newMask, &origMask);\n\n  // poll()'s timeout is an `int` count of milliseconds, so truncate to that.\n  // Also, make sure that we aren't within a millisecond of overflowing a `Duration` since that\n  // will break the math below.\n  constexpr Duration MAX_TIMEOUT =\n      min(int(maxValue) * MILLISECONDS, Duration(maxValue) - MILLISECONDS);\n\n  int pollTimeout = -1;\n  auto timer = timers->timers.begin();\n  if (timer != timers->timers.end()) {\n    Duration timeout = (*timer)->time - currentSteadyTime();\n    if (timeout < 0 * SECONDS) {\n      pollTimeout = 0;\n    } else if (timeout < MAX_TIMEOUT) {\n      // Round up to the next millisecond\n      pollTimeout = (timeout + 1 * MILLISECONDS - unit<Duration>()) / MILLISECONDS;\n    } else {\n      pollTimeout = MAX_TIMEOUT / MILLISECONDS;\n    }\n  }\n  pollContext.run(pollTimeout);\n\n  sigprocmask(SIG_SETMASK, &origMask, nullptr);\n  threadCapture = nullptr;\n\n  // Queue events.\n  pollContext.processResults();\n  processTimers();\n\n  return false;\n}"
  },
  {
    "function_name": "processResults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "665-678",
    "snippet": "void processResults() {\n    if (pollResult < 0) {\n      KJ_FAIL_SYSCALL(\"poll()\", pollError);\n    }\n\n    for (auto i: indices(pollfds)) {\n      if (pollfds[i].revents != 0) {\n        pollEvents[i]->fire(pollfds[i].revents);\n        if (--pollResult <= 0) {\n          break;\n        }\n      }\n    }\n  }",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pollEvents[i]->fire",
          "args": [
            "pollfds[i].revents"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indices",
          "args": [
            "pollfds"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"poll()\"",
            "pollError"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid processResults() {\n    if (pollResult < 0) {\n      KJ_FAIL_SYSCALL(\"poll()\", pollError);\n    }\n\n    for (auto i: indices(pollfds)) {\n      if (pollfds[i].revents != 0) {\n        pollEvents[i]->fire(pollfds[i].revents);\n        if (--pollResult <= 0) {\n          break;\n        }\n      }\n    }\n  }"
  },
  {
    "function_name": "run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "655-663",
    "snippet": "void run(int timeout) {\n    do {\n      pollResult = ::poll(pollfds.begin(), pollfds.size(), timeout);\n      pollError = pollResult < 0 ? errno : 0;\n\n      // EINTR should only happen if we received a signal *other than* the ones registered via\n      // the UnixEventPort, so we don't care about that case.\n    } while (pollError == EINTR);\n  }",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "::poll",
          "args": [
            "pollfds.begin()",
            "pollfds.size()",
            "timeout"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pollfds.size",
          "args": [],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pollfds.begin",
          "args": [],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid run(int timeout) {\n    do {\n      pollResult = ::poll(pollfds.begin(), pollfds.size(), timeout);\n      pollError = pollResult < 0 ? errno : 0;\n\n      // EINTR should only happen if we received a signal *other than* the ones registered via\n      // the UnixEventPort, so we don't care about that case.\n    } while (pollError == EINTR);\n  }"
  },
  {
    "function_name": "PollContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "643-653",
    "snippet": "PollContext(FdObserver* ptr) {\n    while (ptr != nullptr) {\n      struct pollfd pollfd;\n      memset(&pollfd, 0, sizeof(pollfd));\n      pollfd.fd = ptr->fd;\n      pollfd.events = ptr->getEventMask();\n      pollfds.add(pollfd);\n      pollEvents.add(ptr);\n      ptr = ptr->next;\n    }\n  }",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pollEvents.add",
          "args": [
            "ptr"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr->getEventMask",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pollfd",
            "0",
            "sizeof(pollfd)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nPollContext(FdObserver* ptr) {\n    while (ptr != nullptr) {\n      struct pollfd pollfd;\n      memset(&pollfd, 0, sizeof(pollfd));\n      pollfd.fd = ptr->fd;\n      pollfd.events = ptr->getEventMask();\n      pollfds.add(pollfd);\n      pollEvents.add(ptr);\n      ptr = ptr->next;\n    }\n  }"
  },
  {
    "function_name": "UnixEventPort::FdObserver::whenBecomesWritable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "626-639",
    "snippet": "Promise<void> UnixEventPort::FdObserver::whenBecomesWritable() {\n  KJ_REQUIRE(flags & OBSERVE_WRITE, \"FdObserver was not set to observe writes.\");\n\n  if (prev == nullptr) {\n    KJ_DASSERT(next == nullptr);\n    prev = eventPort.observersTail;\n    *prev = this;\n    eventPort.observersTail = &next;\n  }\n\n  auto paf = newPromiseAndFulfiller<void>();\n  writeFulfiller = kj::mv(paf.fulfiller);\n  return kj::mv(paf.promise);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<void>",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "next == nullptr"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "flags & OBSERVE_WRITE",
            "\"FdObserver was not set to observe writes.\""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nPromise<void> UnixEventPort::FdObserver::whenBecomesWritable() {\n  KJ_REQUIRE(flags & OBSERVE_WRITE, \"FdObserver was not set to observe writes.\");\n\n  if (prev == nullptr) {\n    KJ_DASSERT(next == nullptr);\n    prev = eventPort.observersTail;\n    *prev = this;\n    eventPort.observersTail = &next;\n  }\n\n  auto paf = newPromiseAndFulfiller<void>();\n  writeFulfiller = kj::mv(paf.fulfiller);\n  return kj::mv(paf.promise);\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::whenBecomesReadable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "611-624",
    "snippet": "Promise<void> UnixEventPort::FdObserver::whenBecomesReadable() {\n  KJ_REQUIRE(flags & OBSERVE_READ, \"FdObserver was not set to observe reads.\");\n\n  if (prev == nullptr) {\n    KJ_DASSERT(next == nullptr);\n    prev = eventPort.observersTail;\n    *prev = this;\n    eventPort.observersTail = &next;\n  }\n\n  auto paf = newPromiseAndFulfiller<void>();\n  readFulfiller = kj::mv(paf.fulfiller);\n  return kj::mv(paf.promise);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<void>",
          "args": [],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "next == nullptr"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "flags & OBSERVE_READ",
            "\"FdObserver was not set to observe reads.\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nPromise<void> UnixEventPort::FdObserver::whenBecomesReadable() {\n  KJ_REQUIRE(flags & OBSERVE_READ, \"FdObserver was not set to observe reads.\");\n\n  if (prev == nullptr) {\n    KJ_DASSERT(next == nullptr);\n    prev = eventPort.observersTail;\n    *prev = this;\n    eventPort.observersTail = &next;\n  }\n\n  auto paf = newPromiseAndFulfiller<void>();\n  readFulfiller = kj::mv(paf.fulfiller);\n  return kj::mv(paf.promise);\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::getEventMask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "606-609",
    "snippet": "short UnixEventPort::FdObserver::getEventMask() {\n  return (readFulfiller == nullptr ? 0 : (POLLIN | POLLRDHUP)) |\n         (writeFulfiller == nullptr ? 0 : POLLOUT);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define POLLRDHUP 0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\n#define POLLRDHUP 0\n\nshort UnixEventPort::FdObserver::getEventMask() {\n  return (readFulfiller == nullptr ? 0 : (POLLIN | POLLRDHUP)) |\n         (writeFulfiller == nullptr ? 0 : POLLOUT);\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "568-604",
    "snippet": "void UnixEventPort::FdObserver::fire(short events) {\n  if (events & (POLLIN | POLLHUP | POLLRDHUP | POLLERR | POLLNVAL)) {\n    if (events & (POLLHUP | POLLRDHUP)) {\n      atEnd = true;\n#if POLLRDHUP\n    } else {\n      // Since POLLRDHUP exists on this platform, and we didn't receive it, we know that we're not\n      // at the end.\n      atEnd = false;\n#endif\n    }\n\n    KJ_IF_MAYBE(f, readFulfiller) {\n      f->get()->fulfill();\n      readFulfiller = nullptr;\n    }\n  }\n\n  if (events & (POLLOUT | POLLHUP | POLLERR | POLLNVAL)) {\n    KJ_IF_MAYBE(f, writeFulfiller) {\n      f->get()->fulfill();\n      writeFulfiller = nullptr;\n    }\n  }\n\n  if (readFulfiller == nullptr && writeFulfiller == nullptr) {\n    // Remove from list.\n    if (next == nullptr) {\n      eventPort.observersTail = prev;\n    } else {\n      next->prev = prev;\n    }\n    *prev = next;\n    next = nullptr;\n    prev = nullptr;\n  }\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [
      "#define POLLRDHUP 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f->get",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\n#define POLLRDHUP 0\n\nvoid UnixEventPort::FdObserver::fire(short events) {\n  if (events & (POLLIN | POLLHUP | POLLRDHUP | POLLERR | POLLNVAL)) {\n    if (events & (POLLHUP | POLLRDHUP)) {\n      atEnd = true;\n#if POLLRDHUP\n    } else {\n      // Since POLLRDHUP exists on this platform, and we didn't receive it, we know that we're not\n      // at the end.\n      atEnd = false;\n#endif\n    }\n\n    KJ_IF_MAYBE(f, readFulfiller) {\n      f->get()->fulfill();\n      readFulfiller = nullptr;\n    }\n  }\n\n  if (events & (POLLOUT | POLLHUP | POLLERR | POLLNVAL)) {\n    KJ_IF_MAYBE(f, writeFulfiller) {\n      f->get()->fulfill();\n      writeFulfiller = nullptr;\n    }\n  }\n\n  if (readFulfiller == nullptr && writeFulfiller == nullptr) {\n    // Remove from list.\n    if (next == nullptr) {\n      eventPort.observersTail = prev;\n    } else {\n      next->prev = prev;\n    }\n    *prev = next;\n    next = nullptr;\n    prev = nullptr;\n  }\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::~FdObserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "557-566",
    "snippet": "UnixEventPort::FdObserver::~FdObserver() noexcept(false) {\n  if (prev != nullptr) {\n    if (next == nullptr) {\n      eventPort.observersTail = prev;\n    } else {\n      next->prev = prev;\n    }\n    *prev = next;\n  }\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nUnixEventPort::FdObserver::~FdObserver() noexcept(false) {\n  if (prev != nullptr) {\n    if (next == nullptr) {\n      eventPort.observersTail = prev;\n    } else {\n      next->prev = prev;\n    }\n    *prev = next;\n  }\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::FdObserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "554-555",
    "snippet": "UnixEventPort::FdObserver::FdObserver(UnixEventPort& eventPort, int fd, uint flags)\n    : eventPort(eventPort), fd(fd), flags(flags), next(nullptr), prev(nullptr) {}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nUnixEventPort::FdObserver::FdObserver(UnixEventPort& eventPort, int fd, uint flags)\n    : eventPort(eventPort), fd(fd), flags(flags), next(nullptr), prev(nullptr) {}"
  },
  {
    "function_name": "UnixEventPort::~UnixEventPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "552-552",
    "snippet": "UnixEventPort::~UnixEventPort() noexcept(false) {}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nUnixEventPort::~UnixEventPort() noexcept(false) {}"
  },
  {
    "function_name": "UnixEventPort::UnixEventPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "542-550",
    "snippet": "UnixEventPort::UnixEventPort()\n    : timers(kj::heap<TimerSet>()),\n      frozenSteadyTime(currentSteadyTime()) {\n  static_assert(sizeof(threadId) >= sizeof(pthread_t),\n                \"pthread_t is larger than a long long on your platform.  Please port.\");\n  *reinterpret_cast<pthread_t*>(&threadId) = pthread_self();\n\n  pthread_once(&registerReservedSignalOnce, &registerReservedSignal);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_once",
          "args": [
            "&registerReservedSignalOnce",
            "&registerReservedSignal"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_self",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<pthread_t*>",
          "args": [
            "&threadId"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "currentSteadyTime",
          "args": [],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::currentSteadyTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "89-92",
          "snippet": "TimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nTimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<TimerSet>",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nUnixEventPort::UnixEventPort()\n    : timers(kj::heap<TimerSet>()),\n      frozenSteadyTime(currentSteadyTime()) {\n  static_assert(sizeof(threadId) >= sizeof(pthread_t),\n                \"pthread_t is larger than a long long on your platform.  Please port.\");\n  *reinterpret_cast<pthread_t*>(&threadId) = pthread_self();\n\n  pthread_once(&registerReservedSignalOnce, &registerReservedSignal);\n}"
  },
  {
    "function_name": "UnixEventPort::doEpollWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "477-532",
    "snippet": "bool UnixEventPort::doEpollWait(int timeout) {\n  sigset_t newMask;\n  sigemptyset(&newMask);\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      sigaddset(&newMask, ptr->signum);\n      ptr = ptr->next;\n    }\n  }\n\n  if (memcmp(&newMask, &signalFdSigset, sizeof(newMask)) != 0) {\n    // Apparently we're not waiting on the same signals as last time. Need to update the signal\n    // FD's mask.\n    signalFdSigset = newMask;\n    KJ_SYSCALL(signalfd(signalFd, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC));\n  }\n\n  struct epoll_event events[16];\n  int n;\n  KJ_SYSCALL(n = epoll_wait(epollFd, events, kj::size(events), timeout));\n\n  bool woken = false;\n\n  for (int i = 0; i < n; i++) {\n    if (events[i].data.u64 == 0) {\n      for (;;) {\n        struct signalfd_siginfo siginfo;\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(signalFd, &siginfo, sizeof(siginfo)));\n        if (n < 0) break;  // no more signals\n\n        KJ_ASSERT(n == sizeof(siginfo));\n\n        gotSignal(toRegularSiginfo(siginfo));\n      }\n    } else if (events[i].data.u64 == 1) {\n      // Someone called wake() from another thread. Consume the event.\n      uint64_t value;\n      ssize_t n;\n      KJ_NONBLOCKING_SYSCALL(n = read(eventFd, &value, sizeof(value)));\n      KJ_ASSERT(n < 0 || n == sizeof(value));\n\n      // We were woken. Need to return true.\n      woken = true;\n    } else {\n      FdObserver* observer = reinterpret_cast<FdObserver*>(events[i].data.ptr);\n      observer->fire(events[i].events);\n    }\n  }\n\n  processTimers();\n\n  return woken;\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "processTimers",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::processTimers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "94-103",
          "snippet": "void UnixEventPort::processTimers() {\n  frozenSteadyTime = currentSteadyTime();\n  for (;;) {\n    auto front = timers->timers.begin();\n    if (front == timers->timers.end() || (*front)->time > frozenSteadyTime) {\n      break;\n    }\n    (*front)->fulfill();\n  }\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::processTimers() {\n  frozenSteadyTime = currentSteadyTime();\n  for (;;) {\n    auto front = timers->timers.begin();\n    if (front == timers->timers.end() || (*front)->time > frozenSteadyTime) {\n      break;\n    }\n    (*front)->fulfill();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "observer->fire",
          "args": [
            "events[i].events"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<FdObserver*>",
          "args": [
            "events[i].data.ptr"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n < 0 || n == sizeof(value)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = read(eventFd, &value, sizeof(value))"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "eventFd",
            "&value",
            "sizeof(value)"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncInputStream::read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1340-1342",
          "snippet": "Promise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}"
        }
      },
      {
        "call_info": {
          "callee": "gotSignal",
          "args": [
            "toRegularSiginfo(siginfo)"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::gotSignal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "232-243",
          "snippet": "void UnixEventPort::gotSignal(const siginfo_t& siginfo) {\n  // Fire any events waiting on this signal.\n  auto ptr = signalHead;\n  while (ptr != nullptr) {\n    if (ptr->signum == siginfo.si_signo) {\n      ptr->fulfiller.fulfill(kj::cp(siginfo));\n      ptr = ptr->removeFromList();\n    } else {\n      ptr = ptr->next;\n    }\n  }\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::gotSignal(const siginfo_t& siginfo) {\n  // Fire any events waiting on this signal.\n  auto ptr = signalHead;\n  while (ptr != nullptr) {\n    if (ptr->signum == siginfo.si_signo) {\n      ptr->fulfiller.fulfill(kj::cp(siginfo));\n      ptr = ptr->removeFromList();\n    } else {\n      ptr = ptr->next;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "toRegularSiginfo",
          "args": [
            "siginfo"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "toRegularSiginfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "376-475",
          "snippet": "static siginfo_t toRegularSiginfo(const struct signalfd_siginfo& siginfo) {\n  // Unfortunately, siginfo_t is mostly a big union and the correct set of fields to fill in\n  // depends on the type of signal. OTOH, signalfd_siginfo is a flat struct that expands all\n  // siginfo_t's union fields out to be non-overlapping. We can't just copy all the fields over\n  // because of the unions; we have to carefully figure out which fields are appropriate to fill\n  // in for this signal. Ick.\n\n  siginfo_t result;\n  memset(&result, 0, sizeof(result));\n\n  result.si_signo = siginfo.ssi_signo;\n  result.si_errno = siginfo.ssi_errno;\n  result.si_code = siginfo.ssi_code;\n\n  if (siginfo.ssi_code > 0) {\n    // Signal originated from the kernel. The structure of the siginfo depends primarily on the\n    // signal number.\n\n    switch (siginfo.ssi_signo) {\n    case SIGCHLD:\n      result.si_pid = siginfo.ssi_pid;\n      result.si_uid = siginfo.ssi_uid;\n      result.si_status = siginfo.ssi_status;\n      result.si_utime = siginfo.ssi_utime;\n      result.si_stime = siginfo.ssi_stime;\n      break;\n\n    case SIGILL:\n    case SIGFPE:\n    case SIGSEGV:\n    case SIGBUS:\n    case SIGTRAP:\n      result.si_addr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_addr));\n#ifdef si_trapno\n      result.si_trapno = siginfo.ssi_trapno;\n#endif\n#ifdef si_addr_lsb\n      // ssi_addr_lsb is defined as coming immediately after ssi_addr in the kernel headers but\n      // apparently the userspace headers were never updated. So we do a pointer hack. :(\n      result.si_addr_lsb = *reinterpret_cast<const uint16_t*>(&siginfo.ssi_addr + 1);\n#endif\n      break;\n\n    case SIGIO:\n      static_assert(SIGIO == SIGPOLL, \"SIGIO != SIGPOLL?\");\n\n      // Note: Technically, code can arrange for SIGIO signals to be delivered with a signal number\n      //   other than SIGIO. AFAICT there is no way for us to detect this in the siginfo. Luckily\n      //   SIGIO is totally obsoleted by epoll so it shouldn't come up.\n\n      result.si_band = siginfo.ssi_band;\n      result.si_fd = siginfo.ssi_fd;\n      break;\n\n    case SIGSYS:\n      // Apparently SIGSYS's fields are not available in signalfd_siginfo?\n      break;\n    }\n\n  } else {\n    // Signal originated from userspace. The sender could specify whatever signal number they\n    // wanted. The structure of the signal is determined by the API they used, which is identified\n    // by SI_CODE.\n\n    switch (siginfo.ssi_code) {\n      case SI_USER:\n      case SI_TKILL:\n        // kill(), tkill(), or tgkill().\n        result.si_pid = siginfo.ssi_pid;\n        result.si_uid = siginfo.ssi_uid;\n        break;\n\n      case SI_QUEUE:\n      case SI_MESGQ:\n      case SI_ASYNCIO:\n      default:\n        result.si_pid = siginfo.ssi_pid;\n        result.si_uid = siginfo.ssi_uid;\n\n        // This is awkward. In siginfo_t, si_ptr and si_int are in a union together. In\n        // signalfd_siginfo, they are not. We don't really know whether the app intended to send\n        // an int or a pointer. Presumably since the pointer is always larger than the int, if\n        // we write the pointer, we'll end up with the right value for the int? Presumably the\n        // two fields of signalfd_siginfo are actually extracted from one of these unions\n        // originally, so actually contain redundant data? Better write some tests...\n        result.si_ptr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_ptr));\n        break;\n\n      case SI_TIMER:\n        result.si_timerid = siginfo.ssi_tid;\n        result.si_overrun = siginfo.ssi_overrun;\n\n        // Again with this weirdness...\n        result.si_ptr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_ptr));\n        break;\n    }\n  }\n\n  return result;\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nstatic siginfo_t toRegularSiginfo(const struct signalfd_siginfo& siginfo) {\n  // Unfortunately, siginfo_t is mostly a big union and the correct set of fields to fill in\n  // depends on the type of signal. OTOH, signalfd_siginfo is a flat struct that expands all\n  // siginfo_t's union fields out to be non-overlapping. We can't just copy all the fields over\n  // because of the unions; we have to carefully figure out which fields are appropriate to fill\n  // in for this signal. Ick.\n\n  siginfo_t result;\n  memset(&result, 0, sizeof(result));\n\n  result.si_signo = siginfo.ssi_signo;\n  result.si_errno = siginfo.ssi_errno;\n  result.si_code = siginfo.ssi_code;\n\n  if (siginfo.ssi_code > 0) {\n    // Signal originated from the kernel. The structure of the siginfo depends primarily on the\n    // signal number.\n\n    switch (siginfo.ssi_signo) {\n    case SIGCHLD:\n      result.si_pid = siginfo.ssi_pid;\n      result.si_uid = siginfo.ssi_uid;\n      result.si_status = siginfo.ssi_status;\n      result.si_utime = siginfo.ssi_utime;\n      result.si_stime = siginfo.ssi_stime;\n      break;\n\n    case SIGILL:\n    case SIGFPE:\n    case SIGSEGV:\n    case SIGBUS:\n    case SIGTRAP:\n      result.si_addr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_addr));\n#ifdef si_trapno\n      result.si_trapno = siginfo.ssi_trapno;\n#endif\n#ifdef si_addr_lsb\n      // ssi_addr_lsb is defined as coming immediately after ssi_addr in the kernel headers but\n      // apparently the userspace headers were never updated. So we do a pointer hack. :(\n      result.si_addr_lsb = *reinterpret_cast<const uint16_t*>(&siginfo.ssi_addr + 1);\n#endif\n      break;\n\n    case SIGIO:\n      static_assert(SIGIO == SIGPOLL, \"SIGIO != SIGPOLL?\");\n\n      // Note: Technically, code can arrange for SIGIO signals to be delivered with a signal number\n      //   other than SIGIO. AFAICT there is no way for us to detect this in the siginfo. Luckily\n      //   SIGIO is totally obsoleted by epoll so it shouldn't come up.\n\n      result.si_band = siginfo.ssi_band;\n      result.si_fd = siginfo.ssi_fd;\n      break;\n\n    case SIGSYS:\n      // Apparently SIGSYS's fields are not available in signalfd_siginfo?\n      break;\n    }\n\n  } else {\n    // Signal originated from userspace. The sender could specify whatever signal number they\n    // wanted. The structure of the signal is determined by the API they used, which is identified\n    // by SI_CODE.\n\n    switch (siginfo.ssi_code) {\n      case SI_USER:\n      case SI_TKILL:\n        // kill(), tkill(), or tgkill().\n        result.si_pid = siginfo.ssi_pid;\n        result.si_uid = siginfo.ssi_uid;\n        break;\n\n      case SI_QUEUE:\n      case SI_MESGQ:\n      case SI_ASYNCIO:\n      default:\n        result.si_pid = siginfo.ssi_pid;\n        result.si_uid = siginfo.ssi_uid;\n\n        // This is awkward. In siginfo_t, si_ptr and si_int are in a union together. In\n        // signalfd_siginfo, they are not. We don't really know whether the app intended to send\n        // an int or a pointer. Presumably since the pointer is always larger than the int, if\n        // we write the pointer, we'll end up with the right value for the int? Presumably the\n        // two fields of signalfd_siginfo are actually extracted from one of these unions\n        // originally, so actually contain redundant data? Better write some tests...\n        result.si_ptr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_ptr));\n        break;\n\n      case SI_TIMER:\n        result.si_timerid = siginfo.ssi_tid;\n        result.si_overrun = siginfo.ssi_overrun;\n\n        // Again with this weirdness...\n        result.si_ptr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_ptr));\n        break;\n    }\n  }\n\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n == sizeof(siginfo)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = read(signalFd, &siginfo, sizeof(siginfo))"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = epoll_wait(epollFd, events, kj::size(events), timeout)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epoll_wait",
          "args": [
            "epollFd",
            "events",
            "kj::size(events)",
            "timeout"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "events"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "signalfd(signalFd, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd",
          "args": [
            "signalFd",
            "&signalFdSigset",
            "SFD_NONBLOCK | SFD_CLOEXEC"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&newMask",
            "&signalFdSigset",
            "sizeof(newMask)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&newMask",
            "ptr->signum"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&newMask"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nbool UnixEventPort::doEpollWait(int timeout) {\n  sigset_t newMask;\n  sigemptyset(&newMask);\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      sigaddset(&newMask, ptr->signum);\n      ptr = ptr->next;\n    }\n  }\n\n  if (memcmp(&newMask, &signalFdSigset, sizeof(newMask)) != 0) {\n    // Apparently we're not waiting on the same signals as last time. Need to update the signal\n    // FD's mask.\n    signalFdSigset = newMask;\n    KJ_SYSCALL(signalfd(signalFd, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC));\n  }\n\n  struct epoll_event events[16];\n  int n;\n  KJ_SYSCALL(n = epoll_wait(epollFd, events, kj::size(events), timeout));\n\n  bool woken = false;\n\n  for (int i = 0; i < n; i++) {\n    if (events[i].data.u64 == 0) {\n      for (;;) {\n        struct signalfd_siginfo siginfo;\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(signalFd, &siginfo, sizeof(siginfo)));\n        if (n < 0) break;  // no more signals\n\n        KJ_ASSERT(n == sizeof(siginfo));\n\n        gotSignal(toRegularSiginfo(siginfo));\n      }\n    } else if (events[i].data.u64 == 1) {\n      // Someone called wake() from another thread. Consume the event.\n      uint64_t value;\n      ssize_t n;\n      KJ_NONBLOCKING_SYSCALL(n = read(eventFd, &value, sizeof(value)));\n      KJ_ASSERT(n < 0 || n == sizeof(value));\n\n      // We were woken. Need to return true.\n      woken = true;\n    } else {\n      FdObserver* observer = reinterpret_cast<FdObserver*>(events[i].data.ptr);\n      observer->fire(events[i].events);\n    }\n  }\n\n  processTimers();\n\n  return woken;\n}"
  },
  {
    "function_name": "toRegularSiginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "376-475",
    "snippet": "static siginfo_t toRegularSiginfo(const struct signalfd_siginfo& siginfo) {\n  // Unfortunately, siginfo_t is mostly a big union and the correct set of fields to fill in\n  // depends on the type of signal. OTOH, signalfd_siginfo is a flat struct that expands all\n  // siginfo_t's union fields out to be non-overlapping. We can't just copy all the fields over\n  // because of the unions; we have to carefully figure out which fields are appropriate to fill\n  // in for this signal. Ick.\n\n  siginfo_t result;\n  memset(&result, 0, sizeof(result));\n\n  result.si_signo = siginfo.ssi_signo;\n  result.si_errno = siginfo.ssi_errno;\n  result.si_code = siginfo.ssi_code;\n\n  if (siginfo.ssi_code > 0) {\n    // Signal originated from the kernel. The structure of the siginfo depends primarily on the\n    // signal number.\n\n    switch (siginfo.ssi_signo) {\n    case SIGCHLD:\n      result.si_pid = siginfo.ssi_pid;\n      result.si_uid = siginfo.ssi_uid;\n      result.si_status = siginfo.ssi_status;\n      result.si_utime = siginfo.ssi_utime;\n      result.si_stime = siginfo.ssi_stime;\n      break;\n\n    case SIGILL:\n    case SIGFPE:\n    case SIGSEGV:\n    case SIGBUS:\n    case SIGTRAP:\n      result.si_addr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_addr));\n#ifdef si_trapno\n      result.si_trapno = siginfo.ssi_trapno;\n#endif\n#ifdef si_addr_lsb\n      // ssi_addr_lsb is defined as coming immediately after ssi_addr in the kernel headers but\n      // apparently the userspace headers were never updated. So we do a pointer hack. :(\n      result.si_addr_lsb = *reinterpret_cast<const uint16_t*>(&siginfo.ssi_addr + 1);\n#endif\n      break;\n\n    case SIGIO:\n      static_assert(SIGIO == SIGPOLL, \"SIGIO != SIGPOLL?\");\n\n      // Note: Technically, code can arrange for SIGIO signals to be delivered with a signal number\n      //   other than SIGIO. AFAICT there is no way for us to detect this in the siginfo. Luckily\n      //   SIGIO is totally obsoleted by epoll so it shouldn't come up.\n\n      result.si_band = siginfo.ssi_band;\n      result.si_fd = siginfo.ssi_fd;\n      break;\n\n    case SIGSYS:\n      // Apparently SIGSYS's fields are not available in signalfd_siginfo?\n      break;\n    }\n\n  } else {\n    // Signal originated from userspace. The sender could specify whatever signal number they\n    // wanted. The structure of the signal is determined by the API they used, which is identified\n    // by SI_CODE.\n\n    switch (siginfo.ssi_code) {\n      case SI_USER:\n      case SI_TKILL:\n        // kill(), tkill(), or tgkill().\n        result.si_pid = siginfo.ssi_pid;\n        result.si_uid = siginfo.ssi_uid;\n        break;\n\n      case SI_QUEUE:\n      case SI_MESGQ:\n      case SI_ASYNCIO:\n      default:\n        result.si_pid = siginfo.ssi_pid;\n        result.si_uid = siginfo.ssi_uid;\n\n        // This is awkward. In siginfo_t, si_ptr and si_int are in a union together. In\n        // signalfd_siginfo, they are not. We don't really know whether the app intended to send\n        // an int or a pointer. Presumably since the pointer is always larger than the int, if\n        // we write the pointer, we'll end up with the right value for the int? Presumably the\n        // two fields of signalfd_siginfo are actually extracted from one of these unions\n        // originally, so actually contain redundant data? Better write some tests...\n        result.si_ptr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_ptr));\n        break;\n\n      case SI_TIMER:\n        result.si_timerid = siginfo.ssi_tid;\n        result.si_overrun = siginfo.ssi_overrun;\n\n        // Again with this weirdness...\n        result.si_ptr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_ptr));\n        break;\n    }\n  }\n\n  return result;\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<void*>",
          "args": [
            "static_cast<uintptr_t>(siginfo.ssi_ptr)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uintptr_t>",
          "args": [
            "siginfo.ssi_ptr"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<void*>",
          "args": [
            "static_cast<uintptr_t>(siginfo.ssi_ptr)"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uintptr_t>",
          "args": [
            "siginfo.ssi_ptr"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const uint16_t*>",
          "args": [
            "&siginfo.ssi_addr + 1"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<void*>",
          "args": [
            "static_cast<uintptr_t>(siginfo.ssi_addr)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uintptr_t>",
          "args": [
            "siginfo.ssi_addr"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(result)"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nstatic siginfo_t toRegularSiginfo(const struct signalfd_siginfo& siginfo) {\n  // Unfortunately, siginfo_t is mostly a big union and the correct set of fields to fill in\n  // depends on the type of signal. OTOH, signalfd_siginfo is a flat struct that expands all\n  // siginfo_t's union fields out to be non-overlapping. We can't just copy all the fields over\n  // because of the unions; we have to carefully figure out which fields are appropriate to fill\n  // in for this signal. Ick.\n\n  siginfo_t result;\n  memset(&result, 0, sizeof(result));\n\n  result.si_signo = siginfo.ssi_signo;\n  result.si_errno = siginfo.ssi_errno;\n  result.si_code = siginfo.ssi_code;\n\n  if (siginfo.ssi_code > 0) {\n    // Signal originated from the kernel. The structure of the siginfo depends primarily on the\n    // signal number.\n\n    switch (siginfo.ssi_signo) {\n    case SIGCHLD:\n      result.si_pid = siginfo.ssi_pid;\n      result.si_uid = siginfo.ssi_uid;\n      result.si_status = siginfo.ssi_status;\n      result.si_utime = siginfo.ssi_utime;\n      result.si_stime = siginfo.ssi_stime;\n      break;\n\n    case SIGILL:\n    case SIGFPE:\n    case SIGSEGV:\n    case SIGBUS:\n    case SIGTRAP:\n      result.si_addr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_addr));\n#ifdef si_trapno\n      result.si_trapno = siginfo.ssi_trapno;\n#endif\n#ifdef si_addr_lsb\n      // ssi_addr_lsb is defined as coming immediately after ssi_addr in the kernel headers but\n      // apparently the userspace headers were never updated. So we do a pointer hack. :(\n      result.si_addr_lsb = *reinterpret_cast<const uint16_t*>(&siginfo.ssi_addr + 1);\n#endif\n      break;\n\n    case SIGIO:\n      static_assert(SIGIO == SIGPOLL, \"SIGIO != SIGPOLL?\");\n\n      // Note: Technically, code can arrange for SIGIO signals to be delivered with a signal number\n      //   other than SIGIO. AFAICT there is no way for us to detect this in the siginfo. Luckily\n      //   SIGIO is totally obsoleted by epoll so it shouldn't come up.\n\n      result.si_band = siginfo.ssi_band;\n      result.si_fd = siginfo.ssi_fd;\n      break;\n\n    case SIGSYS:\n      // Apparently SIGSYS's fields are not available in signalfd_siginfo?\n      break;\n    }\n\n  } else {\n    // Signal originated from userspace. The sender could specify whatever signal number they\n    // wanted. The structure of the signal is determined by the API they used, which is identified\n    // by SI_CODE.\n\n    switch (siginfo.ssi_code) {\n      case SI_USER:\n      case SI_TKILL:\n        // kill(), tkill(), or tgkill().\n        result.si_pid = siginfo.ssi_pid;\n        result.si_uid = siginfo.ssi_uid;\n        break;\n\n      case SI_QUEUE:\n      case SI_MESGQ:\n      case SI_ASYNCIO:\n      default:\n        result.si_pid = siginfo.ssi_pid;\n        result.si_uid = siginfo.ssi_uid;\n\n        // This is awkward. In siginfo_t, si_ptr and si_int are in a union together. In\n        // signalfd_siginfo, they are not. We don't really know whether the app intended to send\n        // an int or a pointer. Presumably since the pointer is always larger than the int, if\n        // we write the pointer, we'll end up with the right value for the int? Presumably the\n        // two fields of signalfd_siginfo are actually extracted from one of these unions\n        // originally, so actually contain redundant data? Better write some tests...\n        result.si_ptr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_ptr));\n        break;\n\n      case SI_TIMER:\n        result.si_timerid = siginfo.ssi_tid;\n        result.si_overrun = siginfo.ssi_overrun;\n\n        // Again with this weirdness...\n        result.si_ptr = reinterpret_cast<void*>(static_cast<uintptr_t>(siginfo.ssi_ptr));\n        break;\n    }\n  }\n\n  return result;\n}"
  },
  {
    "function_name": "UnixEventPort::wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "369-374",
    "snippet": "void UnixEventPort::wake() const {\n  uint64_t one = 1;\n  ssize_t n;\n  KJ_NONBLOCKING_SYSCALL(n = write(eventFd, &one, sizeof(one)));\n  KJ_ASSERT(n < 0 || n == sizeof(one));\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n < 0 || n == sizeof(one)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = write(eventFd, &one, sizeof(one))"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "eventFd",
            "&one",
            "sizeof(one)"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::wake() const {\n  uint64_t one = 1;\n  ssize_t n;\n  KJ_NONBLOCKING_SYSCALL(n = write(eventFd, &one, sizeof(one)));\n  KJ_ASSERT(n < 0 || n == sizeof(one));\n}"
  },
  {
    "function_name": "UnixEventPort::poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "365-367",
    "snippet": "bool UnixEventPort::poll() {\n  return doEpollWait(0);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "doEpollWait",
          "args": [
            "0"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::doEpollWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "477-532",
          "snippet": "bool UnixEventPort::doEpollWait(int timeout) {\n  sigset_t newMask;\n  sigemptyset(&newMask);\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      sigaddset(&newMask, ptr->signum);\n      ptr = ptr->next;\n    }\n  }\n\n  if (memcmp(&newMask, &signalFdSigset, sizeof(newMask)) != 0) {\n    // Apparently we're not waiting on the same signals as last time. Need to update the signal\n    // FD's mask.\n    signalFdSigset = newMask;\n    KJ_SYSCALL(signalfd(signalFd, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC));\n  }\n\n  struct epoll_event events[16];\n  int n;\n  KJ_SYSCALL(n = epoll_wait(epollFd, events, kj::size(events), timeout));\n\n  bool woken = false;\n\n  for (int i = 0; i < n; i++) {\n    if (events[i].data.u64 == 0) {\n      for (;;) {\n        struct signalfd_siginfo siginfo;\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(signalFd, &siginfo, sizeof(siginfo)));\n        if (n < 0) break;  // no more signals\n\n        KJ_ASSERT(n == sizeof(siginfo));\n\n        gotSignal(toRegularSiginfo(siginfo));\n      }\n    } else if (events[i].data.u64 == 1) {\n      // Someone called wake() from another thread. Consume the event.\n      uint64_t value;\n      ssize_t n;\n      KJ_NONBLOCKING_SYSCALL(n = read(eventFd, &value, sizeof(value)));\n      KJ_ASSERT(n < 0 || n == sizeof(value));\n\n      // We were woken. Need to return true.\n      woken = true;\n    } else {\n      FdObserver* observer = reinterpret_cast<FdObserver*>(events[i].data.ptr);\n      observer->fire(events[i].events);\n    }\n  }\n\n  processTimers();\n\n  return woken;\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nbool UnixEventPort::doEpollWait(int timeout) {\n  sigset_t newMask;\n  sigemptyset(&newMask);\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      sigaddset(&newMask, ptr->signum);\n      ptr = ptr->next;\n    }\n  }\n\n  if (memcmp(&newMask, &signalFdSigset, sizeof(newMask)) != 0) {\n    // Apparently we're not waiting on the same signals as last time. Need to update the signal\n    // FD's mask.\n    signalFdSigset = newMask;\n    KJ_SYSCALL(signalfd(signalFd, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC));\n  }\n\n  struct epoll_event events[16];\n  int n;\n  KJ_SYSCALL(n = epoll_wait(epollFd, events, kj::size(events), timeout));\n\n  bool woken = false;\n\n  for (int i = 0; i < n; i++) {\n    if (events[i].data.u64 == 0) {\n      for (;;) {\n        struct signalfd_siginfo siginfo;\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(signalFd, &siginfo, sizeof(siginfo)));\n        if (n < 0) break;  // no more signals\n\n        KJ_ASSERT(n == sizeof(siginfo));\n\n        gotSignal(toRegularSiginfo(siginfo));\n      }\n    } else if (events[i].data.u64 == 1) {\n      // Someone called wake() from another thread. Consume the event.\n      uint64_t value;\n      ssize_t n;\n      KJ_NONBLOCKING_SYSCALL(n = read(eventFd, &value, sizeof(value)));\n      KJ_ASSERT(n < 0 || n == sizeof(value));\n\n      // We were woken. Need to return true.\n      woken = true;\n    } else {\n      FdObserver* observer = reinterpret_cast<FdObserver*>(events[i].data.ptr);\n      observer->fire(events[i].events);\n    }\n  }\n\n  processTimers();\n\n  return woken;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nbool UnixEventPort::poll() {\n  return doEpollWait(0);\n}"
  },
  {
    "function_name": "UnixEventPort::wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "341-363",
    "snippet": "bool UnixEventPort::wait() {\n  // epoll_wait()'s timeout is an `int` count of milliseconds, so truncate to that.\n  // Also, make sure that we aren't within a millisecond of overflowing a `Duration` since that\n  // will break the math below.\n  constexpr Duration MAX_TIMEOUT =\n      min(int(maxValue) * MILLISECONDS, Duration(maxValue) - MILLISECONDS);\n\n  int epollTimeout = -1;\n  auto timer = timers->timers.begin();\n  if (timer != timers->timers.end()) {\n    Duration timeout = (*timer)->time - currentSteadyTime();\n    if (timeout < 0 * SECONDS) {\n      epollTimeout = 0;\n    } else if (timeout < MAX_TIMEOUT) {\n      // Round up to the next millisecond\n      epollTimeout = (timeout + 1 * MILLISECONDS - unit<Duration>()) / MILLISECONDS;\n    } else {\n      epollTimeout = MAX_TIMEOUT / MILLISECONDS;\n    }\n  }\n\n  return doEpollWait(epollTimeout);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "doEpollWait",
          "args": [
            "epollTimeout"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::doEpollWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "477-532",
          "snippet": "bool UnixEventPort::doEpollWait(int timeout) {\n  sigset_t newMask;\n  sigemptyset(&newMask);\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      sigaddset(&newMask, ptr->signum);\n      ptr = ptr->next;\n    }\n  }\n\n  if (memcmp(&newMask, &signalFdSigset, sizeof(newMask)) != 0) {\n    // Apparently we're not waiting on the same signals as last time. Need to update the signal\n    // FD's mask.\n    signalFdSigset = newMask;\n    KJ_SYSCALL(signalfd(signalFd, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC));\n  }\n\n  struct epoll_event events[16];\n  int n;\n  KJ_SYSCALL(n = epoll_wait(epollFd, events, kj::size(events), timeout));\n\n  bool woken = false;\n\n  for (int i = 0; i < n; i++) {\n    if (events[i].data.u64 == 0) {\n      for (;;) {\n        struct signalfd_siginfo siginfo;\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(signalFd, &siginfo, sizeof(siginfo)));\n        if (n < 0) break;  // no more signals\n\n        KJ_ASSERT(n == sizeof(siginfo));\n\n        gotSignal(toRegularSiginfo(siginfo));\n      }\n    } else if (events[i].data.u64 == 1) {\n      // Someone called wake() from another thread. Consume the event.\n      uint64_t value;\n      ssize_t n;\n      KJ_NONBLOCKING_SYSCALL(n = read(eventFd, &value, sizeof(value)));\n      KJ_ASSERT(n < 0 || n == sizeof(value));\n\n      // We were woken. Need to return true.\n      woken = true;\n    } else {\n      FdObserver* observer = reinterpret_cast<FdObserver*>(events[i].data.ptr);\n      observer->fire(events[i].events);\n    }\n  }\n\n  processTimers();\n\n  return woken;\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nbool UnixEventPort::doEpollWait(int timeout) {\n  sigset_t newMask;\n  sigemptyset(&newMask);\n\n  {\n    auto ptr = signalHead;\n    while (ptr != nullptr) {\n      sigaddset(&newMask, ptr->signum);\n      ptr = ptr->next;\n    }\n  }\n\n  if (memcmp(&newMask, &signalFdSigset, sizeof(newMask)) != 0) {\n    // Apparently we're not waiting on the same signals as last time. Need to update the signal\n    // FD's mask.\n    signalFdSigset = newMask;\n    KJ_SYSCALL(signalfd(signalFd, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC));\n  }\n\n  struct epoll_event events[16];\n  int n;\n  KJ_SYSCALL(n = epoll_wait(epollFd, events, kj::size(events), timeout));\n\n  bool woken = false;\n\n  for (int i = 0; i < n; i++) {\n    if (events[i].data.u64 == 0) {\n      for (;;) {\n        struct signalfd_siginfo siginfo;\n        ssize_t n;\n        KJ_NONBLOCKING_SYSCALL(n = read(signalFd, &siginfo, sizeof(siginfo)));\n        if (n < 0) break;  // no more signals\n\n        KJ_ASSERT(n == sizeof(siginfo));\n\n        gotSignal(toRegularSiginfo(siginfo));\n      }\n    } else if (events[i].data.u64 == 1) {\n      // Someone called wake() from another thread. Consume the event.\n      uint64_t value;\n      ssize_t n;\n      KJ_NONBLOCKING_SYSCALL(n = read(eventFd, &value, sizeof(value)));\n      KJ_ASSERT(n < 0 || n == sizeof(value));\n\n      // We were woken. Need to return true.\n      woken = true;\n    } else {\n      FdObserver* observer = reinterpret_cast<FdObserver*>(events[i].data.ptr);\n      observer->fire(events[i].events);\n    }\n  }\n\n  processTimers();\n\n  return woken;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unit<Duration>",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "unit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/units.h",
          "lines": "360-360",
          "snippet": "inline constexpr T unit() { return T(1); }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\ninline constexpr T unit() { return T(1); }"
        }
      },
      {
        "call_info": {
          "callee": "currentSteadyTime",
          "args": [],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::currentSteadyTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "89-92",
          "snippet": "TimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nTimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timers->timers.end",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "timers->timers.begin",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "int(maxValue) * MILLISECONDS",
            "Duration(maxValue) - MILLISECONDS"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Duration",
          "args": [
            "maxValue"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "maxValue"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nbool UnixEventPort::wait() {\n  // epoll_wait()'s timeout is an `int` count of milliseconds, so truncate to that.\n  // Also, make sure that we aren't within a millisecond of overflowing a `Duration` since that\n  // will break the math below.\n  constexpr Duration MAX_TIMEOUT =\n      min(int(maxValue) * MILLISECONDS, Duration(maxValue) - MILLISECONDS);\n\n  int epollTimeout = -1;\n  auto timer = timers->timers.begin();\n  if (timer != timers->timers.end()) {\n    Duration timeout = (*timer)->time - currentSteadyTime();\n    if (timeout < 0 * SECONDS) {\n      epollTimeout = 0;\n    } else if (timeout < MAX_TIMEOUT) {\n      // Round up to the next millisecond\n      epollTimeout = (timeout + 1 * MILLISECONDS - unit<Duration>()) / MILLISECONDS;\n    } else {\n      epollTimeout = MAX_TIMEOUT / MILLISECONDS;\n    }\n  }\n\n  return doEpollWait(epollTimeout);\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::whenBecomesWritable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "333-339",
    "snippet": "Promise<void> UnixEventPort::FdObserver::whenBecomesWritable() {\n  KJ_REQUIRE(flags & OBSERVE_WRITE, \"FdObserver was not set to observe writes.\");\n\n  auto paf = newPromiseAndFulfiller<void>();\n  writeFulfiller = kj::mv(paf.fulfiller);\n  return kj::mv(paf.promise);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<void>",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "flags & OBSERVE_WRITE",
            "\"FdObserver was not set to observe writes.\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nPromise<void> UnixEventPort::FdObserver::whenBecomesWritable() {\n  KJ_REQUIRE(flags & OBSERVE_WRITE, \"FdObserver was not set to observe writes.\");\n\n  auto paf = newPromiseAndFulfiller<void>();\n  writeFulfiller = kj::mv(paf.fulfiller);\n  return kj::mv(paf.promise);\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::whenBecomesReadable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "325-331",
    "snippet": "Promise<void> UnixEventPort::FdObserver::whenBecomesReadable() {\n  KJ_REQUIRE(flags & OBSERVE_READ, \"FdObserver was not set to observe reads.\");\n\n  auto paf = newPromiseAndFulfiller<void>();\n  readFulfiller = kj::mv(paf.fulfiller);\n  return kj::mv(paf.promise);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newPromiseAndFulfiller<void>",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "flags & OBSERVE_READ",
            "\"FdObserver was not set to observe reads.\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nPromise<void> UnixEventPort::FdObserver::whenBecomesReadable() {\n  KJ_REQUIRE(flags & OBSERVE_READ, \"FdObserver was not set to observe reads.\");\n\n  auto paf = newPromiseAndFulfiller<void>();\n  readFulfiller = kj::mv(paf.fulfiller);\n  return kj::mv(paf.promise);\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::fire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "302-323",
    "snippet": "void UnixEventPort::FdObserver::fire(short events) {\n  if (events & (EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR)) {\n    if (events & (EPOLLHUP | EPOLLRDHUP)) {\n      atEnd = true;\n    } else {\n      // Since we didn't receive EPOLLRDHUP, we know that we're not at the end.\n      atEnd = false;\n    }\n\n    KJ_IF_MAYBE(f, readFulfiller) {\n      f->get()->fulfill();\n      readFulfiller = nullptr;\n    }\n  }\n\n  if (events & (EPOLLOUT | EPOLLHUP | EPOLLERR)) {\n    KJ_IF_MAYBE(f, writeFulfiller) {\n      f->get()->fulfill();\n      writeFulfiller = nullptr;\n    }\n  }\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f->get",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::FdObserver::fire(short events) {\n  if (events & (EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR)) {\n    if (events & (EPOLLHUP | EPOLLRDHUP)) {\n      atEnd = true;\n    } else {\n      // Since we didn't receive EPOLLRDHUP, we know that we're not at the end.\n      atEnd = false;\n    }\n\n    KJ_IF_MAYBE(f, readFulfiller) {\n      f->get()->fulfill();\n      readFulfiller = nullptr;\n    }\n  }\n\n  if (events & (EPOLLOUT | EPOLLHUP | EPOLLERR)) {\n    KJ_IF_MAYBE(f, writeFulfiller) {\n      f->get()->fulfill();\n      writeFulfiller = nullptr;\n    }\n  }\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::~FdObserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "298-300",
    "snippet": "UnixEventPort::FdObserver::~FdObserver() noexcept(false) {\n  KJ_SYSCALL(epoll_ctl(eventPort.epollFd, EPOLL_CTL_DEL, fd, nullptr));\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "epoll_ctl(eventPort.epollFd, EPOLL_CTL_DEL, fd, nullptr)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epoll_ctl",
          "args": [
            "eventPort.epollFd",
            "EPOLL_CTL_DEL",
            "fd",
            "nullptr"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nUnixEventPort::FdObserver::~FdObserver() noexcept(false) {\n  KJ_SYSCALL(epoll_ctl(eventPort.epollFd, EPOLL_CTL_DEL, fd, nullptr));\n}"
  },
  {
    "function_name": "UnixEventPort::FdObserver::FdObserver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "280-296",
    "snippet": "UnixEventPort::FdObserver::FdObserver(UnixEventPort& eventPort, int fd, uint flags)\n    : eventPort(eventPort), fd(fd), flags(flags) {\n  struct epoll_event event;\n  memset(&event, 0, sizeof(event));\n\n  if (flags & OBSERVE_READ) {\n    event.events |= EPOLLIN | EPOLLRDHUP;\n  }\n  if (flags & OBSERVE_WRITE) {\n    event.events |= EPOLLOUT;\n  }\n  event.events |= EPOLLET;  // Set edge-triggered mode.\n\n  event.data.ptr = this;\n\n  KJ_SYSCALL(epoll_ctl(eventPort.epollFd, EPOLL_CTL_ADD, fd, &event));\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "epoll_ctl(eventPort.epollFd, EPOLL_CTL_ADD, fd, &event)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epoll_ctl",
          "args": [
            "eventPort.epollFd",
            "EPOLL_CTL_ADD",
            "fd",
            "&event"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&event",
            "0",
            "sizeof(event)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nUnixEventPort::FdObserver::FdObserver(UnixEventPort& eventPort, int fd, uint flags)\n    : eventPort(eventPort), fd(fd), flags(flags) {\n  struct epoll_event event;\n  memset(&event, 0, sizeof(event));\n\n  if (flags & OBSERVE_READ) {\n    event.events |= EPOLLIN | EPOLLRDHUP;\n  }\n  if (flags & OBSERVE_WRITE) {\n    event.events |= EPOLLOUT;\n  }\n  event.events |= EPOLLET;  // Set edge-triggered mode.\n\n  event.data.ptr = this;\n\n  KJ_SYSCALL(epoll_ctl(eventPort.epollFd, EPOLL_CTL_ADD, fd, &event));\n}"
  },
  {
    "function_name": "UnixEventPort::~UnixEventPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "278-278",
    "snippet": "UnixEventPort::~UnixEventPort() noexcept(false) {}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nUnixEventPort::~UnixEventPort() noexcept(false) {}"
  },
  {
    "function_name": "UnixEventPort::UnixEventPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "249-276",
    "snippet": "UnixEventPort::UnixEventPort()\n    : timers(kj::heap<TimerSet>()),\n      frozenSteadyTime(currentSteadyTime()),\n      epollFd(-1),\n      signalFd(-1),\n      eventFd(-1) {\n  pthread_once(&registerReservedSignalOnce, &registerReservedSignal);\n\n  int fd;\n  KJ_SYSCALL(fd = epoll_create1(EPOLL_CLOEXEC));\n  epollFd = AutoCloseFd(fd);\n\n  KJ_SYSCALL(sigemptyset(&signalFdSigset));\n  KJ_SYSCALL(fd = signalfd(-1, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC));\n  signalFd = AutoCloseFd(fd);\n\n  KJ_SYSCALL(fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK));\n  eventFd = AutoCloseFd(fd);\n\n\n  struct epoll_event event;\n  memset(&event, 0, sizeof(event));\n  event.events = EPOLLIN;\n  event.data.u64 = 0;\n  KJ_SYSCALL(epoll_ctl(epollFd, EPOLL_CTL_ADD, signalFd, &event));\n  event.data.u64 = 1;\n  KJ_SYSCALL(epoll_ctl(epollFd, EPOLL_CTL_ADD, eventFd, &event));\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "epoll_ctl(epollFd, EPOLL_CTL_ADD, eventFd, &event)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epoll_ctl",
          "args": [
            "epollFd",
            "EPOLL_CTL_ADD",
            "eventFd",
            "&event"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "epoll_ctl(epollFd, EPOLL_CTL_ADD, signalFd, &event)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epoll_ctl",
          "args": [
            "epollFd",
            "EPOLL_CTL_ADD",
            "signalFd",
            "&event"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&event",
            "0",
            "sizeof(event)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AutoCloseFd",
          "args": [
            "fd"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "AutoCloseFd",
          "container": "AutoCloseFd",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "241-241",
          "snippet": "inline AutoCloseFd(AutoCloseFd&& other) noexcept: fd(other.fd) { other.fd = -1; }",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nAutoCloseFd {\n  inline AutoCloseFd(AutoCloseFd&& other) noexcept: fd(other.fd) { other.fd = -1; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd",
          "args": [
            "0",
            "EFD_CLOEXEC | EFD_NONBLOCK"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = signalfd(-1, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC)"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd",
          "args": [
            "-1",
            "&signalFdSigset",
            "SFD_NONBLOCK | SFD_CLOEXEC"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigemptyset(&signalFdSigset)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&signalFdSigset"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = epoll_create1(EPOLL_CLOEXEC)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "epoll_create1",
          "args": [
            "EPOLL_CLOEXEC"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_once",
          "args": [
            "&registerReservedSignalOnce",
            "&registerReservedSignal"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "currentSteadyTime",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::currentSteadyTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "89-92",
          "snippet": "TimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nTimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<TimerSet>",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nUnixEventPort::UnixEventPort()\n    : timers(kj::heap<TimerSet>()),\n      frozenSteadyTime(currentSteadyTime()),\n      epollFd(-1),\n      signalFd(-1),\n      eventFd(-1) {\n  pthread_once(&registerReservedSignalOnce, &registerReservedSignal);\n\n  int fd;\n  KJ_SYSCALL(fd = epoll_create1(EPOLL_CLOEXEC));\n  epollFd = AutoCloseFd(fd);\n\n  KJ_SYSCALL(sigemptyset(&signalFdSigset));\n  KJ_SYSCALL(fd = signalfd(-1, &signalFdSigset, SFD_NONBLOCK | SFD_CLOEXEC));\n  signalFd = AutoCloseFd(fd);\n\n  KJ_SYSCALL(fd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK));\n  eventFd = AutoCloseFd(fd);\n\n\n  struct epoll_event event;\n  memset(&event, 0, sizeof(event));\n  event.events = EPOLLIN;\n  event.data.u64 = 0;\n  KJ_SYSCALL(epoll_ctl(epollFd, EPOLL_CTL_ADD, signalFd, &event));\n  event.data.u64 = 1;\n  KJ_SYSCALL(epoll_ctl(epollFd, EPOLL_CTL_ADD, eventFd, &event));\n}"
  },
  {
    "function_name": "UnixEventPort::gotSignal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "232-243",
    "snippet": "void UnixEventPort::gotSignal(const siginfo_t& siginfo) {\n  // Fire any events waiting on this signal.\n  auto ptr = signalHead;\n  while (ptr != nullptr) {\n    if (ptr->signum == siginfo.si_signo) {\n      ptr->fulfiller.fulfill(kj::cp(siginfo));\n      ptr = ptr->removeFromList();\n    } else {\n      ptr = ptr->next;\n    }\n  }\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr->removeFromList",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr->fulfiller.fulfill",
          "args": [
            "kj::cp(siginfo)"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": "WeakFulfiller",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "847-851",
          "snippet": "void fulfill(FixVoid<T>&& value) override {\n    if (inner != nullptr) {\n      inner->fulfill(kj::mv(value));\n    }\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "WeakFulfiller {\n  void fulfill(FixVoid<T>&& value) override {\n      if (inner != nullptr) {\n        inner->fulfill(kj::mv(value));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "siginfo"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::gotSignal(const siginfo_t& siginfo) {\n  // Fire any events waiting on this signal.\n  auto ptr = signalHead;\n  while (ptr != nullptr) {\n    if (ptr->signum == siginfo.si_signo) {\n      ptr->fulfiller.fulfill(kj::cp(siginfo));\n      ptr = ptr->removeFromList();\n    } else {\n      ptr = ptr->next;\n    }\n  }\n}"
  },
  {
    "function_name": "UnixEventPort::setReservedSignal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "221-230",
    "snippet": "void UnixEventPort::setReservedSignal(int signum) {\n  KJ_REQUIRE(!tooLateToSetReserved,\n             \"setReservedSignal() must be called before any calls to `captureSignal()` and \"\n             \"before any `UnixEventPort` is constructed.\");\n  if (reservedSignal != SIGUSR1 && reservedSignal != signum) {\n    KJ_FAIL_REQUIRE(\"Detected multiple conflicting calls to setReservedSignal().  Please only \"\n                    \"call this once, or always call it with the same signal number.\");\n  }\n  reservedSignal = signum;\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Detected multiple conflicting calls to setReservedSignal().  Please only \"\n                    \"call this once, or always call it with the same signal number.\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "!tooLateToSetReserved",
            "\"setReservedSignal() must be called before any calls to `captureSignal()` and \"\n             \"before any `UnixEventPort` is constructed.\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::setReservedSignal(int signum) {\n  KJ_REQUIRE(!tooLateToSetReserved,\n             \"setReservedSignal() must be called before any calls to `captureSignal()` and \"\n             \"before any `UnixEventPort` is constructed.\");\n  if (reservedSignal != SIGUSR1 && reservedSignal != signum) {\n    KJ_FAIL_REQUIRE(\"Detected multiple conflicting calls to setReservedSignal().  Please only \"\n                    \"call this once, or always call it with the same signal number.\");\n  }\n  reservedSignal = signum;\n}"
  },
  {
    "function_name": "UnixEventPort::captureSignal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "209-219",
    "snippet": "void UnixEventPort::captureSignal(int signum) {\n  if (reservedSignal == SIGUSR1) {\n    KJ_REQUIRE(signum != SIGUSR1,\n               \"Sorry, SIGUSR1 is reserved by the UnixEventPort implementation.  You may call \"\n               \"UnixEventPort::setReservedSignal() to reserve a different signal.\");\n  } else {\n    KJ_REQUIRE(signum != reservedSignal,\n               \"Can't capture signal reserved using setReservedSignal().\", signum);\n  }\n  registerSignalHandler(signum);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "registerSignalHandler",
          "args": [
            "signum"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "registerSignalHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "130-146",
          "snippet": "void registerSignalHandler(int signum) {\n  tooLateToSetReserved = true;\n\n  sigset_t mask;\n  KJ_SYSCALL(sigemptyset(&mask));\n  KJ_SYSCALL(sigaddset(&mask, signum));\n  KJ_SYSCALL(sigprocmask(SIG_BLOCK, &mask, nullptr));\n\n#if !KJ_USE_EPOLL  // on Linux we'll use signalfd\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_sigaction = &signalHandler;\n  KJ_SYSCALL(sigfillset(&action.sa_mask));\n  action.sa_flags = SA_SIGINFO;\n  KJ_SYSCALL(sigaction(signum, &action, nullptr));\n#endif\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid registerSignalHandler(int signum) {\n  tooLateToSetReserved = true;\n\n  sigset_t mask;\n  KJ_SYSCALL(sigemptyset(&mask));\n  KJ_SYSCALL(sigaddset(&mask, signum));\n  KJ_SYSCALL(sigprocmask(SIG_BLOCK, &mask, nullptr));\n\n#if !KJ_USE_EPOLL  // on Linux we'll use signalfd\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_sigaction = &signalHandler;\n  KJ_SYSCALL(sigfillset(&action.sa_mask));\n  action.sa_flags = SA_SIGINFO;\n  KJ_SYSCALL(sigaction(signum, &action, nullptr));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "signum != reservedSignal",
            "\"Can't capture signal reserved using setReservedSignal().\"",
            "signum"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "signum != SIGUSR1",
            "\"Sorry, SIGUSR1 is reserved by the UnixEventPort implementation.  You may call \"\n               \"UnixEventPort::setReservedSignal() to reserve a different signal.\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::captureSignal(int signum) {\n  if (reservedSignal == SIGUSR1) {\n    KJ_REQUIRE(signum != SIGUSR1,\n               \"Sorry, SIGUSR1 is reserved by the UnixEventPort implementation.  You may call \"\n               \"UnixEventPort::setReservedSignal() to reserve a different signal.\");\n  } else {\n    KJ_REQUIRE(signum != reservedSignal,\n               \"Can't capture signal reserved using setReservedSignal().\", signum);\n  }\n  registerSignalHandler(signum);\n}"
  },
  {
    "function_name": "UnixEventPort::onSignal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "205-207",
    "snippet": "Promise<siginfo_t> UnixEventPort::onSignal(int signum) {\n  return newAdaptedPromise<siginfo_t, SignalPromiseAdapter>(*this, signum);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newAdaptedPromise<siginfo_t, SignalPromiseAdapter>",
          "args": [
            "*this",
            "signum"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nPromise<siginfo_t> UnixEventPort::onSignal(int signum) {\n  return newAdaptedPromise<siginfo_t, SignalPromiseAdapter>(*this, signum);\n}"
  },
  {
    "function_name": "SignalPromiseAdapter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "166-172",
    "snippet": "inline SignalPromiseAdapter(PromiseFulfiller<siginfo_t>& fulfiller,\n                              UnixEventPort& loop, int signum)\n      : loop(loop), signum(signum), fulfiller(fulfiller) {\n    prev = loop.signalTail;\n    *loop.signalTail = this;\n    loop.signalTail = &next;\n  }",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\ninline SignalPromiseAdapter(PromiseFulfiller<siginfo_t>& fulfiller,\n                              UnixEventPort& loop, int signum)\n      : loop(loop), signum(signum), fulfiller(fulfiller) {\n    prev = loop.signalTail;\n    *loop.signalTail = this;\n    loop.signalTail = &next;\n  }"
  },
  {
    "function_name": "registerReservedSignal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "148-158",
    "snippet": "void registerReservedSignal() {\n  registerSignalHandler(reservedSignal);\n\n  // We also disable SIGPIPE because users of UnixEventLoop almost certainly don't want it.\n  while (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {\n    int error = errno;\n    if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"signal(SIGPIPE, SIG_IGN)\", error);\n    }\n  }\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"signal(SIGPIPE, SIG_IGN)\"",
            "error"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_IGN"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "registerSignalHandler",
          "args": [
            "reservedSignal"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "registerSignalHandler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "130-146",
          "snippet": "void registerSignalHandler(int signum) {\n  tooLateToSetReserved = true;\n\n  sigset_t mask;\n  KJ_SYSCALL(sigemptyset(&mask));\n  KJ_SYSCALL(sigaddset(&mask, signum));\n  KJ_SYSCALL(sigprocmask(SIG_BLOCK, &mask, nullptr));\n\n#if !KJ_USE_EPOLL  // on Linux we'll use signalfd\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_sigaction = &signalHandler;\n  KJ_SYSCALL(sigfillset(&action.sa_mask));\n  action.sa_flags = SA_SIGINFO;\n  KJ_SYSCALL(sigaction(signum, &action, nullptr));\n#endif\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid registerSignalHandler(int signum) {\n  tooLateToSetReserved = true;\n\n  sigset_t mask;\n  KJ_SYSCALL(sigemptyset(&mask));\n  KJ_SYSCALL(sigaddset(&mask, signum));\n  KJ_SYSCALL(sigprocmask(SIG_BLOCK, &mask, nullptr));\n\n#if !KJ_USE_EPOLL  // on Linux we'll use signalfd\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_sigaction = &signalHandler;\n  KJ_SYSCALL(sigfillset(&action.sa_mask));\n  action.sa_flags = SA_SIGINFO;\n  KJ_SYSCALL(sigaction(signum, &action, nullptr));\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid registerReservedSignal() {\n  registerSignalHandler(reservedSignal);\n\n  // We also disable SIGPIPE because users of UnixEventLoop almost certainly don't want it.\n  while (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {\n    int error = errno;\n    if (error != EINTR) {\n      KJ_FAIL_SYSCALL(\"signal(SIGPIPE, SIG_IGN)\", error);\n    }\n  }\n}"
  },
  {
    "function_name": "registerSignalHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "130-146",
    "snippet": "void registerSignalHandler(int signum) {\n  tooLateToSetReserved = true;\n\n  sigset_t mask;\n  KJ_SYSCALL(sigemptyset(&mask));\n  KJ_SYSCALL(sigaddset(&mask, signum));\n  KJ_SYSCALL(sigprocmask(SIG_BLOCK, &mask, nullptr));\n\n#if !KJ_USE_EPOLL  // on Linux we'll use signalfd\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_sigaction = &signalHandler;\n  KJ_SYSCALL(sigfillset(&action.sa_mask));\n  action.sa_flags = SA_SIGINFO;\n  KJ_SYSCALL(sigaction(signum, &action, nullptr));\n#endif\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaction(signum, &action, nullptr)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "signum",
            "&action",
            "nullptr"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigfillset(&action.sa_mask)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigfillset",
          "args": [
            "&action.sa_mask"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&action",
            "0",
            "sizeof(action)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigprocmask(SIG_BLOCK, &mask, nullptr)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_BLOCK",
            "&mask",
            "nullptr"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigaddset(&mask, signum)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&mask",
            "signum"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "sigemptyset(&mask)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&mask"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid registerSignalHandler(int signum) {\n  tooLateToSetReserved = true;\n\n  sigset_t mask;\n  KJ_SYSCALL(sigemptyset(&mask));\n  KJ_SYSCALL(sigaddset(&mask, signum));\n  KJ_SYSCALL(sigprocmask(SIG_BLOCK, &mask, nullptr));\n\n#if !KJ_USE_EPOLL  // on Linux we'll use signalfd\n  struct sigaction action;\n  memset(&action, 0, sizeof(action));\n  action.sa_sigaction = &signalHandler;\n  KJ_SYSCALL(sigfillset(&action.sa_mask));\n  action.sa_flags = SA_SIGINFO;\n  KJ_SYSCALL(sigaction(signum, &action, nullptr));\n#endif\n}"
  },
  {
    "function_name": "signalHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "121-127",
    "snippet": "void signalHandler(int, siginfo_t* siginfo, void*) {\n  SignalCapture* capture = threadCapture;\n  if (capture != nullptr) {\n    capture->siginfo = *siginfo;\n    siglongjmp(capture->jumpTo, 1);\n  }\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "siglongjmp",
          "args": [
            "capture->jumpTo",
            "1"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid signalHandler(int, siginfo_t* siginfo, void*) {\n  SignalCapture* capture = threadCapture;\n  if (capture != nullptr) {\n    capture->siginfo = *siginfo;\n    siglongjmp(capture->jumpTo, 1);\n  }\n}"
  },
  {
    "function_name": "UnixEventPort::processTimers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "94-103",
    "snippet": "void UnixEventPort::processTimers() {\n  frozenSteadyTime = currentSteadyTime();\n  for (;;) {\n    auto front = timers->timers.begin();\n    if (front == timers->timers.end() || (*front)->time > frozenSteadyTime) {\n      break;\n    }\n    (*front)->fulfill();\n  }\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timers->timers.end",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "timers->timers.begin",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "currentSteadyTime",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "UnixEventPort::currentSteadyTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "89-92",
          "snippet": "TimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nTimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid UnixEventPort::processTimers() {\n  frozenSteadyTime = currentSteadyTime();\n  for (;;) {\n    auto front = timers->timers.begin();\n    if (front == timers->timers.end() || (*front)->time > frozenSteadyTime) {\n      break;\n    }\n    (*front)->fulfill();\n  }\n}"
  },
  {
    "function_name": "UnixEventPort::currentSteadyTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "89-92",
    "snippet": "TimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::chrono::duration_cast<std::chrono::nanoseconds>",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::chrono::duration_cast<std::chrono::nanoseconds>",
          "args": [
            "std::chrono::steady_clock::now().time_since_epoch()"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::chrono::steady_clock::now",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "now",
          "container": "TimerImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "886-886",
          "snippet": "TimePoint now() override { return eventPort.steadyTime(); }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTimerImpl {\n  TimePoint now() override { return eventPort.steadyTime(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin<TimePoint>",
          "args": [],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "origin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/units.h",
          "lines": "432-432",
          "snippet": "inline constexpr T origin() { return T(0 * unit<UnitOf<T>>()); }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\ninline constexpr T origin() { return T(0 * unit<UnitOf<T>>()); }"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nTimePoint UnixEventPort::currentSteadyTime() {\n  return origin<TimePoint>() + std::chrono::duration_cast<std::chrono::nanoseconds>(\n      std::chrono::steady_clock::now().time_since_epoch()).count() * NANOSECONDS;\n}"
  },
  {
    "function_name": "UnixEventPort::atSteadyTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "85-87",
    "snippet": "Promise<void> UnixEventPort::atSteadyTime(TimePoint time) {\n  return newAdaptedPromise<void, TimerPromiseAdapter>(*this, time);\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newAdaptedPromise<void, TimerPromiseAdapter>",
          "args": [
            "*this",
            "time"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nPromise<void> UnixEventPort::atSteadyTime(TimePoint time) {\n  return newAdaptedPromise<void, TimerPromiseAdapter>(*this, time);\n}"
  },
  {
    "function_name": "UnixEventPort::TimerSet::TimerBefore::operator()",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "80-83",
    "snippet": "bool UnixEventPort::TimerSet::TimerBefore::operator()(\n    TimerPromiseAdapter* lhs, TimerPromiseAdapter* rhs) {\n  return lhs->time < rhs->time;\n}",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nbool UnixEventPort::TimerSet::TimerBefore::operator()(\n    TimerPromiseAdapter* lhs, TimerPromiseAdapter* rhs) {\n  return lhs->time < rhs->time;\n}"
  },
  {
    "function_name": "fulfill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "68-72",
    "snippet": "void fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "port.timers->timers.end",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port.timers->timers.erase",
          "args": [
            "pos"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "204-216",
          "snippet": "T erase(Id id) {\n    // Remove an entry from the table and return it.  We return it so that the caller can be\n    // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n    if (id < kj::size(low)) {\n      T toRelease = kj::mv(low[id]);\n      low[id] = T();\n      return toRelease;\n    } else {\n      T toRelease = kj::mv(high[id]);\n      high.erase(id);\n      return toRelease;\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  T erase(Id id) {\n      // Remove an entry from the table and return it.  We return it so that the caller can be\n      // careful to release it (possibly invoking arbitrary destructors) at a time that makes sense.\n      if (id < kj::size(low)) {\n        T toRelease = kj::mv(low[id]);\n        low[id] = T();\n        return toRelease;\n      } else {\n        T toRelease = kj::mv(high[id]);\n        high.erase(id);\n        return toRelease;\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }"
  },
  {
    "function_name": "TimerPromiseAdapter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
    "lines": "57-60",
    "snippet": "TimerPromiseAdapter(PromiseFulfiller<void>& fulfiller, UnixEventPort& port, TimePoint time)\n      : time(time), fulfiller(fulfiller), port(port) {\n    pos = port.timers->timers.insert(this);\n  }",
    "includes": [
      "#include <poll.h>",
      "#include <sys/eventfd.h>",
      "#include <sys/signalfd.h>",
      "#include <sys/epoll.h>",
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <chrono>",
      "#include <set>",
      "#include <limits>",
      "#include <inttypes.h>",
      "#include <errno.h>",
      "#include <setjmp.h>",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "port.timers->timers.insert",
          "args": [
            "this"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nTimerPromiseAdapter(PromiseFulfiller<void>& fulfiller, UnixEventPort& port, TimePoint time)\n      : time(time), fulfiller(fulfiller), port(port) {\n    pos = port.timers->timers.insert(this);\n  }"
  }
]