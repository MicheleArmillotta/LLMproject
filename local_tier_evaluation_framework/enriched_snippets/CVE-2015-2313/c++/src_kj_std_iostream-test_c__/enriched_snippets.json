[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/std/iostream-test.c++",
    "lines": "75-99",
    "snippet": "TEST(StdIoStream, ReadToEndOfFile) {\n  // Check that read throws an exception when eof is reached before specified\n  // bytes.\n\n  ::std::stringstream ss;\n\n  StdInputStream in(ss);\n  StdOutputStream out(ss);\n\n  const void* bytes = \"foobar\";\n\n  out.write(bytes, 6);\n\n  char buf[9];\n\n  Maybe<Exception> e = kj::runCatchingExceptions([&]() {\n    in.read(buf, 8, 8);\n  });\n  buf[6] = '\\0';\n\n  ASSERT_FALSE(e == nullptr);\n\n  // Ensure that the value is still read up to the EOF.\n  EXPECT_STREQ(\"foobar\", buf);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <sstream>",
      "#include \"iostream.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_STREQ",
          "args": [
            "\"foobar\"",
            "buf"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_FALSE",
          "args": [
            "e == nullptr"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    in.read(buf, 8, 8);\n  }"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.read",
          "args": [
            "buf",
            "8",
            "8"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "Uncompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "101-113",
          "snippet": "static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                   google::protobuf::MessageLite* message) {\n    google::protobuf::io::CodedInputStream input(rawInput);\n    uint32_t size;\n    GOOGLE_CHECK(input.ReadVarint32(&size));\n\n    auto limit = input.PushLimit(size);\n\n    GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                 input.ConsumedEntireMessage());\n\n    input.PopLimit(limit);\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nUncompressed {\n  static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                     google::protobuf::MessageLite* message) {\n      google::protobuf::io::CodedInputStream input(rawInput);\n      uint32_t size;\n      GOOGLE_CHECK(input.ReadVarint32(&size));\n  \n      auto limit = input.PushLimit(size);\n  \n      GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                   input.ConsumedEntireMessage());\n  \n      input.PopLimit(limit);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "bytes",
            "6"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "StdOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/std/iostream.h",
          "lines": "45-49",
          "snippet": "virtual void write(const void* src, size_t size) override {\n    // Always writes the full size.\n\n    stream_.write((char*)src, size);\n  }",
          "includes": [
            "#include <iostream>",
            "#include \"../io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"../io.h\"\n\nStdOutputStream {\n  virtual void write(const void* src, size_t size) override {\n      // Always writes the full size.\n  \n      stream_.write((char*)src, size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <sstream>\n#include \"iostream.h\"\n\nTEST(StdIoStream, ReadToEndOfFile) {\n  // Check that read throws an exception when eof is reached before specified\n  // bytes.\n\n  ::std::stringstream ss;\n\n  StdInputStream in(ss);\n  StdOutputStream out(ss);\n\n  const void* bytes = \"foobar\";\n\n  out.write(bytes, 6);\n\n  char buf[9];\n\n  Maybe<Exception> e = kj::runCatchingExceptions([&]() {\n    in.read(buf, 8, 8);\n  });\n  buf[6] = '\\0';\n\n  ASSERT_FALSE(e == nullptr);\n\n  // Ensure that the value is still read up to the EOF.\n  EXPECT_STREQ(\"foobar\", buf);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/std/iostream-test.c++",
    "lines": "56-73",
    "snippet": "TEST(StdIoStream, TryReadToEndOfFile) {\n  // Check that tryRead works when eof is reached before minBytes.\n\n  ::std::stringstream ss;\n\n  StdInputStream in(ss);\n  StdOutputStream out(ss);\n\n  const void* bytes = \"foobar\";\n\n  out.write(bytes, 6);\n\n  char buf[9];\n  in.tryRead(buf, 8, 8);\n  buf[6] = '\\0';\n\n  EXPECT_STREQ(\"foobar\", buf);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <sstream>",
      "#include \"iostream.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_STREQ",
          "args": [
            "\"foobar\"",
            "buf"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.tryRead",
          "args": [
            "buf",
            "8",
            "8"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "StdInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/std/iostream.h",
          "lines": "72-78",
          "snippet": "virtual size_t tryRead(\n      void* buffer, size_t minBytes, size_t maxBytes) override {\n    // Like read(), but may return fewer than minBytes on EOF.\n\n    stream_.read((char*)buffer, maxBytes);\n    return stream_.gcount();\n  }",
          "includes": [
            "#include <iostream>",
            "#include \"../io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"../io.h\"\n\nStdInputStream {\n  virtual size_t tryRead(\n        void* buffer, size_t minBytes, size_t maxBytes) override {\n      // Like read(), but may return fewer than minBytes on EOF.\n  \n      stream_.read((char*)buffer, maxBytes);\n      return stream_.gcount();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "bytes",
            "6"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "StdOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/std/iostream.h",
          "lines": "45-49",
          "snippet": "virtual void write(const void* src, size_t size) override {\n    // Always writes the full size.\n\n    stream_.write((char*)src, size);\n  }",
          "includes": [
            "#include <iostream>",
            "#include \"../io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"../io.h\"\n\nStdOutputStream {\n  virtual void write(const void* src, size_t size) override {\n      // Always writes the full size.\n  \n      stream_.write((char*)src, size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <sstream>\n#include \"iostream.h\"\n\nTEST(StdIoStream, TryReadToEndOfFile) {\n  // Check that tryRead works when eof is reached before minBytes.\n\n  ::std::stringstream ss;\n\n  StdInputStream in(ss);\n  StdOutputStream out(ss);\n\n  const void* bytes = \"foobar\";\n\n  out.write(bytes, 6);\n\n  char buf[9];\n  in.tryRead(buf, 8, 8);\n  buf[6] = '\\0';\n\n  EXPECT_STREQ(\"foobar\", buf);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/std/iostream-test.c++",
    "lines": "30-54",
    "snippet": "TEST(StdIoStream, WriteVec) {\n  // Check that writing an array of arrays works even when some of the arrays\n  // are empty.  (This used to not work in some cases.)\n\n  ::std::stringstream ss;\n\n  StdInputStream in(ss);\n  StdOutputStream out(ss);\n\n  ArrayPtr<const byte> pieces[5] = {\n    arrayPtr(implicitCast<const byte*>(nullptr), 0),\n    arrayPtr(reinterpret_cast<const byte*>(\"foo\"), 3),\n    arrayPtr(implicitCast<const byte*>(nullptr), 0),\n    arrayPtr(reinterpret_cast<const byte*>(\"bar\"), 3),\n    arrayPtr(implicitCast<const byte*>(nullptr), 0)\n  };\n\n  out.write(pieces);\n\n  char buf[7];\n  in.read(buf, 6);\n  buf[6] = '\\0';\n\n  EXPECT_STREQ(\"foobar\", buf);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include <sstream>",
      "#include \"iostream.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_STREQ",
          "args": [
            "\"foobar\"",
            "buf"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.read",
          "args": [
            "buf",
            "6"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "SnappyCompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "149-159",
          "snippet": "static void read(int* input, google::protobuf::MessageLite* message) {\n    uint32_t size;\n    readAll(*input, &size, sizeof(size));\n    readAll(*input, scratch, size);\n\n    size_t uncompressedSize;\n    GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n    GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n\n    GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nSnappyCompressed {\n  static void read(int* input, google::protobuf::MessageLite* message) {\n      uint32_t size;\n      readAll(*input, &size, sizeof(size));\n      readAll(*input, scratch, size);\n  \n      size_t uncompressedSize;\n      GOOGLE_CHECK(snappy::GetUncompressedLength(scratch, size, &uncompressedSize));\n      GOOGLE_CHECK(snappy::RawUncompress(scratch, size, scratch2));\n  \n      GOOGLE_CHECK(message->ParsePartialFromArray(scratch2, uncompressedSize));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "pieces"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "StdOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/std/iostream.h",
          "lines": "51-59",
          "snippet": "virtual void write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    // Equivalent to write()ing each byte array in sequence, which is what the\n    // default implementation does. Override if you can do something better,\n    // e.g. use writev() to do the write in a single syscall.\n\n    for (auto piece : pieces) {\n      write(piece.begin(), piece.size());\n    }\n  }",
          "includes": [
            "#include <iostream>",
            "#include \"../io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"../io.h\"\n\nStdOutputStream {\n  virtual void write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n      // Equivalent to write()ing each byte array in sequence, which is what the\n      // default implementation does. Override if you can do something better,\n      // e.g. use writev() to do the write in a single syscall.\n  \n      for (auto piece : pieces) {\n        write(piece.begin(), piece.size());\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arrayPtr",
          "args": [
            "implicitCast<const byte*>(nullptr)",
            "0"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "implicitCast<const byte*>",
          "args": [
            "nullptr"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "implicitCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1203-1207",
          "snippet": "To implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nTo implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "\"bar\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "\"foo\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <sstream>\n#include \"iostream.h\"\n\nTEST(StdIoStream, WriteVec) {\n  // Check that writing an array of arrays works even when some of the arrays\n  // are empty.  (This used to not work in some cases.)\n\n  ::std::stringstream ss;\n\n  StdInputStream in(ss);\n  StdOutputStream out(ss);\n\n  ArrayPtr<const byte> pieces[5] = {\n    arrayPtr(implicitCast<const byte*>(nullptr), 0),\n    arrayPtr(reinterpret_cast<const byte*>(\"foo\"), 3),\n    arrayPtr(implicitCast<const byte*>(nullptr), 0),\n    arrayPtr(reinterpret_cast<const byte*>(\"bar\"), 3),\n    arrayPtr(implicitCast<const byte*>(nullptr), 0)\n  };\n\n  out.write(pieces);\n\n  char buf[7];\n  in.read(buf, 6);\n  buf[6] = '\\0';\n\n  EXPECT_STREQ(\"foobar\", buf);\n}"
  }
]