[
  {
    "function_name": "OrphanBuilder::euthanize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2858-2876",
    "snippet": "void OrphanBuilder::euthanize() {\n  // Carefully catch any exceptions and rethrow them as recoverable exceptions since we may be in\n  // a destructor.\n  auto exception = kj::runCatchingExceptions([&]() {\n    if (tagAsPtr()->isPositional()) {\n      WireHelpers::zeroObject(segment, tagAsPtr(), location);\n    } else {\n      WireHelpers::zeroObject(segment, tagAsPtr());\n    }\n\n    memset(&tag, 0, sizeof(tag));\n    segment = nullptr;\n    location = nullptr;\n  });\n\n  KJ_IF_MAYBE(e, exception) {\n    kj::getExceptionCallback().onRecoverableException(kj::mv(*e));\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::getExceptionCallback",
          "args": [
            "kj::mv(*e)"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*e"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::getExceptionCallback",
          "args": [],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    if (tagAsPtr()->isPositional()) {\n      WireHelpers::zeroObject(segment, tagAsPtr(), location);\n    } else {\n      WireHelpers::zeroObject(segment, tagAsPtr());\n    }\n\n    memset(&tag, 0, sizeof(tag));\n    segment = nullptr;\n    location = nullptr;\n  }"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tag",
            "0",
            "sizeof(tag)"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::zeroObject",
          "args": [
            "segment",
            "tagAsPtr()"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid OrphanBuilder::euthanize() {\n  // Carefully catch any exceptions and rethrow them as recoverable exceptions since we may be in\n  // a destructor.\n  auto exception = kj::runCatchingExceptions([&]() {\n    if (tagAsPtr()->isPositional()) {\n      WireHelpers::zeroObject(segment, tagAsPtr(), location);\n    } else {\n      WireHelpers::zeroObject(segment, tagAsPtr());\n    }\n\n    memset(&tag, 0, sizeof(tag));\n    segment = nullptr;\n    location = nullptr;\n  });\n\n  KJ_IF_MAYBE(e, exception) {\n    kj::getExceptionCallback().onRecoverableException(kj::mv(*e));\n  }\n}"
  },
  {
    "function_name": "OrphanBuilder::truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2824-2856",
    "snippet": "void OrphanBuilder::truncate(ElementCount size, bool isText) {\n  if (isText) size += 1 * ELEMENTS;\n\n  WirePointer* ref = tagAsPtr();\n  SegmentBuilder* segment = this->segment;\n\n  word* target = WireHelpers::followFars(ref, location, segment);\n\n  KJ_REQUIRE(ref->kind() == WirePointer::LIST, \"Can't truncate non-list.\") {\n    return;\n  }\n\n  // TODO(someday): Implement truncation of all sizes.\n  KJ_ASSERT(ref->listRef.elementSize() == ElementSize::BYTE,\n            \"Not implemented: truncate non-blob.\");\n\n  auto oldSize = ref->listRef.elementCount();\n  KJ_REQUIRE(size <= oldSize, \"Truncate size must be smaller than existing size.\") {\n    return;\n  }\n\n  ref->listRef.set(ref->listRef.elementSize(), size);\n\n  byte* begin = reinterpret_cast<byte*>(target);\n  byte* truncPoint = begin + size * (1 * BYTES / ELEMENTS);\n  byte* end = begin + oldSize * (1 * BYTES / ELEMENTS);\n  memset(truncPoint - isText, 0, end - truncPoint + isText);\n\n  word* truncWord = target + WireHelpers::roundBytesUpToWords(size * (1 * BYTES / ELEMENTS));\n  word* endWord = target + WireHelpers::roundBytesUpToWords(oldSize * (1 * BYTES / ELEMENTS));\n\n  segment->tryTruncate(endWord, truncWord);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segment->tryTruncate",
          "args": [
            "endWord",
            "truncWord"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::roundBytesUpToWords",
          "args": [
            "oldSize * (1 * BYTES / ELEMENTS)"
          ],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::roundBytesUpToWords",
          "args": [
            "size * (1 * BYTES / ELEMENTS)"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "truncPoint - isText",
            "0",
            "end - truncPoint + isText"
          ],
          "line": 2850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "target"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.set",
          "args": [
            "ref->listRef.elementSize()",
            "size"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "size <= oldSize",
            "\"Truncate size must be smaller than existing size.\""
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "ref->listRef.elementSize() == ElementSize::BYTE",
            "\"Not implemented: truncate non-blob.\""
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::LIST",
            "\"Can't truncate non-list.\""
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::followFars",
          "args": [
            "ref",
            "location",
            "segment"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid OrphanBuilder::truncate(ElementCount size, bool isText) {\n  if (isText) size += 1 * ELEMENTS;\n\n  WirePointer* ref = tagAsPtr();\n  SegmentBuilder* segment = this->segment;\n\n  word* target = WireHelpers::followFars(ref, location, segment);\n\n  KJ_REQUIRE(ref->kind() == WirePointer::LIST, \"Can't truncate non-list.\") {\n    return;\n  }\n\n  // TODO(someday): Implement truncation of all sizes.\n  KJ_ASSERT(ref->listRef.elementSize() == ElementSize::BYTE,\n            \"Not implemented: truncate non-blob.\");\n\n  auto oldSize = ref->listRef.elementCount();\n  KJ_REQUIRE(size <= oldSize, \"Truncate size must be smaller than existing size.\") {\n    return;\n  }\n\n  ref->listRef.set(ref->listRef.elementSize(), size);\n\n  byte* begin = reinterpret_cast<byte*>(target);\n  byte* truncPoint = begin + size * (1 * BYTES / ELEMENTS);\n  byte* end = begin + oldSize * (1 * BYTES / ELEMENTS);\n  memset(truncPoint - isText, 0, end - truncPoint + isText);\n\n  word* truncWord = target + WireHelpers::roundBytesUpToWords(size * (1 * BYTES / ELEMENTS));\n  word* endWord = target + WireHelpers::roundBytesUpToWords(oldSize * (1 * BYTES / ELEMENTS));\n\n  segment->tryTruncate(endWord, truncWord);\n}"
  },
  {
    "function_name": "OrphanBuilder::asDataReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2819-2822",
    "snippet": "Data::Reader OrphanBuilder::asDataReader() const {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n  return WireHelpers::readDataPointer(segment, tagAsPtr(), location, nullptr, 0 * BYTES);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readDataPointer",
          "args": [
            "segment",
            "tagAsPtr()",
            "location",
            "nullptr",
            "0 * BYTES"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nData::Reader OrphanBuilder::asDataReader() const {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n  return WireHelpers::readDataPointer(segment, tagAsPtr(), location, nullptr, 0 * BYTES);\n}"
  },
  {
    "function_name": "OrphanBuilder::asTextReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2814-2817",
    "snippet": "Text::Reader OrphanBuilder::asTextReader() const {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n  return WireHelpers::readTextPointer(segment, tagAsPtr(), location, nullptr, 0 * BYTES);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readTextPointer",
          "args": [
            "segment",
            "tagAsPtr()",
            "location",
            "nullptr",
            "0 * BYTES"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nText::Reader OrphanBuilder::asTextReader() const {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n  return WireHelpers::readTextPointer(segment, tagAsPtr(), location, nullptr, 0 * BYTES);\n}"
  },
  {
    "function_name": "OrphanBuilder::asCapability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2809-2811",
    "snippet": "kj::Own<ClientHook> OrphanBuilder::asCapability() const {\n  return WireHelpers::readCapabilityPointer(segment, tagAsPtr(), kj::maxValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readCapabilityPointer",
          "args": [
            "segment",
            "tagAsPtr()",
            "kj::maxValue"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nkj::Own<ClientHook> OrphanBuilder::asCapability() const {\n  return WireHelpers::readCapabilityPointer(segment, tagAsPtr(), kj::maxValue);\n}"
  },
  {
    "function_name": "OrphanBuilder::asListReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2802-2806",
    "snippet": "ListReader OrphanBuilder::asListReader(ElementSize elementSize) const {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n  return WireHelpers::readListPointer(\n      segment, tagAsPtr(), location, nullptr, elementSize, kj::maxValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readListPointer",
          "args": [
            "segment",
            "tagAsPtr()",
            "location",
            "nullptr",
            "elementSize",
            "kj::maxValue"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListReader OrphanBuilder::asListReader(ElementSize elementSize) const {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n  return WireHelpers::readListPointer(\n      segment, tagAsPtr(), location, nullptr, elementSize, kj::maxValue);\n}"
  },
  {
    "function_name": "OrphanBuilder::asStructReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2796-2800",
    "snippet": "StructReader OrphanBuilder::asStructReader(StructSize size) const {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n  return WireHelpers::readStructPointer(\n      segment, tagAsPtr(), location, nullptr, kj::maxValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readStructPointer",
          "args": [
            "segment",
            "tagAsPtr()",
            "location",
            "nullptr",
            "kj::maxValue"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nStructReader OrphanBuilder::asStructReader(StructSize size) const {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n  return WireHelpers::readStructPointer(\n      segment, tagAsPtr(), location, nullptr, kj::maxValue);\n}"
  },
  {
    "function_name": "OrphanBuilder::asData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2789-2794",
    "snippet": "Data::Builder OrphanBuilder::asData() {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  // Never relocates.\n  return WireHelpers::getWritableDataPointer(tagAsPtr(), location, segment, nullptr, 0 * BYTES);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::getWritableDataPointer",
          "args": [
            "tagAsPtr()",
            "location",
            "segment",
            "nullptr",
            "0 * BYTES"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nData::Builder OrphanBuilder::asData() {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  // Never relocates.\n  return WireHelpers::getWritableDataPointer(tagAsPtr(), location, segment, nullptr, 0 * BYTES);\n}"
  },
  {
    "function_name": "OrphanBuilder::asText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2782-2787",
    "snippet": "Text::Builder OrphanBuilder::asText() {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  // Never relocates.\n  return WireHelpers::getWritableTextPointer(tagAsPtr(), location, segment, nullptr, 0 * BYTES);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::getWritableTextPointer",
          "args": [
            "tagAsPtr()",
            "location",
            "segment",
            "nullptr",
            "0 * BYTES"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nText::Builder OrphanBuilder::asText() {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  // Never relocates.\n  return WireHelpers::getWritableTextPointer(tagAsPtr(), location, segment, nullptr, 0 * BYTES);\n}"
  },
  {
    "function_name": "OrphanBuilder::asStructList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2770-2780",
    "snippet": "ListBuilder OrphanBuilder::asStructList(StructSize elementSize) {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  ListBuilder result = WireHelpers::getWritableStructListPointer(\n      tagAsPtr(), location, segment, elementSize, nullptr, segment->getArena());\n\n  // Watch out, the pointer could have been updated if the object had to be relocated.\n  location = result.getLocation();\n\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.getLocation",
          "args": [],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::getWritableStructListPointer",
          "args": [
            "tagAsPtr()",
            "location",
            "segment",
            "elementSize",
            "nullptr",
            "segment->getArena()"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListBuilder OrphanBuilder::asStructList(StructSize elementSize) {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  ListBuilder result = WireHelpers::getWritableStructListPointer(\n      tagAsPtr(), location, segment, elementSize, nullptr, segment->getArena());\n\n  // Watch out, the pointer could have been updated if the object had to be relocated.\n  location = result.getLocation();\n\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::asList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2756-2768",
    "snippet": "ListBuilder OrphanBuilder::asList(ElementSize elementSize) {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  ListBuilder result = WireHelpers::getWritableListPointer(\n      tagAsPtr(), location, segment, elementSize, nullptr, segment->getArena());\n\n  // Watch out, the pointer could have been updated if the object had to be relocated.\n  // (Actually, currently this is not true for primitive lists, but let's not turn into a bug if\n  // it changes!)\n  location = result.getLocation();\n\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.getLocation",
          "args": [],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::getWritableListPointer",
          "args": [
            "tagAsPtr()",
            "location",
            "segment",
            "elementSize",
            "nullptr",
            "segment->getArena()"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListBuilder OrphanBuilder::asList(ElementSize elementSize) {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  ListBuilder result = WireHelpers::getWritableListPointer(\n      tagAsPtr(), location, segment, elementSize, nullptr, segment->getArena());\n\n  // Watch out, the pointer could have been updated if the object had to be relocated.\n  // (Actually, currently this is not true for primitive lists, but let's not turn into a bug if\n  // it changes!)\n  location = result.getLocation();\n\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::asStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2744-2754",
    "snippet": "StructBuilder OrphanBuilder::asStruct(StructSize size) {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  StructBuilder result = WireHelpers::getWritableStructPointer(\n      tagAsPtr(), location, segment, size, nullptr, segment->getArena());\n\n  // Watch out, the pointer could have been updated if the object had to be relocated.\n  location = reinterpret_cast<word*>(result.data);\n\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "result.data"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::getWritableStructPointer",
          "args": [
            "tagAsPtr()",
            "location",
            "segment",
            "size",
            "nullptr",
            "segment->getArena()"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "tagAsPtr()->isNull() == (location == nullptr)"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tagAsPtr",
          "args": [],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nStructBuilder OrphanBuilder::asStruct(StructSize size) {\n  KJ_DASSERT(tagAsPtr()->isNull() == (location == nullptr));\n\n  StructBuilder result = WireHelpers::getWritableStructPointer(\n      tagAsPtr(), location, segment, size, nullptr, segment->getArena());\n\n  // Watch out, the pointer could have been updated if the object had to be relocated.\n  location = reinterpret_cast<word*>(result.data);\n\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::referenceExternalData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2725-2742",
    "snippet": "OrphanBuilder OrphanBuilder::referenceExternalData(BuilderArena* arena, Data::Reader data) {\n  KJ_REQUIRE(reinterpret_cast<uintptr_t>(data.begin()) % sizeof(void*) == 0,\n             \"Cannot referenceExternalData() that is not aligned.\");\n\n  auto wordCount = WireHelpers::roundBytesUpToWords(data.size() * BYTES);\n  kj::ArrayPtr<const word> words(reinterpret_cast<const word*>(data.begin()), wordCount / WORDS);\n\n  OrphanBuilder result;\n  result.tagAsPtr()->setKindForOrphan(WirePointer::LIST);\n  result.tagAsPtr()->listRef.set(ElementSize::BYTE, data.size() * ELEMENTS);\n  result.segment = arena->addExternalSegment(words);\n\n  // const_cast OK here because we will check whether the segment is writable when we try to get\n  // a builder.\n  result.location = const_cast<word*>(words.begin());\n\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "const_cast<word*>",
          "args": [
            "words.begin()"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "words.begin",
          "args": [],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "arena->addExternalSegment",
          "args": [
            "words"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [
            "ElementSize::BYTE",
            "data.size() * ELEMENTS"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [
            "WirePointer::LIST"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const word*>",
          "args": [
            "data.begin()"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::roundBytesUpToWords",
          "args": [
            "data.size() * BYTES"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "reinterpret_cast<uintptr_t>(data.begin()) % sizeof(void*) == 0",
            "\"Cannot referenceExternalData() that is not aligned.\""
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uintptr_t>",
          "args": [
            "data.begin()"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::referenceExternalData(BuilderArena* arena, Data::Reader data) {\n  KJ_REQUIRE(reinterpret_cast<uintptr_t>(data.begin()) % sizeof(void*) == 0,\n             \"Cannot referenceExternalData() that is not aligned.\");\n\n  auto wordCount = WireHelpers::roundBytesUpToWords(data.size() * BYTES);\n  kj::ArrayPtr<const word> words(reinterpret_cast<const word*>(data.begin()), wordCount / WORDS);\n\n  OrphanBuilder result;\n  result.tagAsPtr()->setKindForOrphan(WirePointer::LIST);\n  result.tagAsPtr()->listRef.set(ElementSize::BYTE, data.size() * ELEMENTS);\n  result.segment = arena->addExternalSegment(words);\n\n  // const_cast OK here because we will check whether the segment is writable when we try to get\n  // a builder.\n  result.location = const_cast<word*>(words.begin());\n\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2716-2722",
    "snippet": "OrphanBuilder OrphanBuilder::copy(BuilderArena* arena, kj::Own<ClientHook> copyFrom) {\n  OrphanBuilder result;\n  WireHelpers::setCapabilityPointer(nullptr, result.tagAsPtr(), kj::mv(copyFrom), arena);\n  result.segment = arena->getSegment(SegmentId(0));\n  result.location = &result.tag;  // dummy to make location non-null\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena->getSegment",
          "args": [
            "SegmentId(0)"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "getSegment",
          "container": "AsyncMessageReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "40-47",
          "snippet": "kj::ArrayPtr<const word> getSegment(uint id) override {\n    if (id >= segmentCount()) {\n      return nullptr;\n    } else {\n      uint32_t size = id == 0 ? segment0Size() : moreSizes[id - 1].get();\n      return kj::arrayPtr(segmentStarts[id], size);\n    }\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  kj::ArrayPtr<const word> getSegment(uint id) override {\n      if (id >= segmentCount()) {\n        return nullptr;\n      } else {\n        uint32_t size = id == 0 ? segment0Size() : moreSizes[id - 1].get();\n        return kj::arrayPtr(segmentStarts[id], size);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SegmentId",
          "args": [
            "0"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::setCapabilityPointer",
          "args": [
            "nullptr",
            "result.tagAsPtr()",
            "kj::mv(copyFrom)",
            "arena"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "copyFrom"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::copy(BuilderArena* arena, kj::Own<ClientHook> copyFrom) {\n  OrphanBuilder result;\n  WireHelpers::setCapabilityPointer(nullptr, result.tagAsPtr(), kj::mv(copyFrom), arena);\n  result.segment = arena->getSegment(SegmentId(0));\n  result.location = &result.tag;  // dummy to make location non-null\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2706-2713",
    "snippet": "OrphanBuilder OrphanBuilder::copy(BuilderArena* arena, Data::Reader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::setDataPointer(\n      result.tagAsPtr(), nullptr, copyFrom, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value.begin());\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "allocation.value.begin()"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocation.value.begin",
          "args": [],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::setDataPointer",
          "args": [
            "result.tagAsPtr()",
            "nullptr",
            "copyFrom",
            "arena"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::copy(BuilderArena* arena, Data::Reader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::setDataPointer(\n      result.tagAsPtr(), nullptr, copyFrom, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value.begin());\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2697-2704",
    "snippet": "OrphanBuilder OrphanBuilder::copy(BuilderArena* arena, Text::Reader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::setTextPointer(\n      result.tagAsPtr(), nullptr, copyFrom, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value.begin());\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "allocation.value.begin()"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocation.value.begin",
          "args": [],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::setTextPointer",
          "args": [
            "result.tagAsPtr()",
            "nullptr",
            "copyFrom",
            "arena"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::copy(BuilderArena* arena, Text::Reader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::setTextPointer(\n      result.tagAsPtr(), nullptr, copyFrom, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value.begin());\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2688-2695",
    "snippet": "OrphanBuilder OrphanBuilder::copy(BuilderArena* arena, PointerReader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::copyPointer(\n      nullptr, result.tagAsPtr(), copyFrom.segment, copyFrom.pointer, copyFrom.nestingLimit, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value);\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "allocation.value"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::copyPointer",
          "args": [
            "nullptr",
            "result.tagAsPtr()",
            "copyFrom.segment",
            "copyFrom.pointer",
            "copyFrom.nestingLimit",
            "arena"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "copyPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "1619-1761",
          "snippet": "static SegmentAnd<word*> copyPointer(\n      SegmentBuilder* dstSegment, WirePointer* dst,\n      SegmentReader* srcSegment, const WirePointer* src, const word* srcTarget,\n      int nestingLimit, BuilderArena* orphanArena = nullptr) {\n    // Deep-copy the object pointed to by src into dst.  It turns out we can't reuse\n    // readStructPointer(), etc. because they do type checking whereas here we want to accept any\n    // valid pointer.\n\n    if (src->isNull()) {\n    useDefault:\n      if (!dst->isNull()) {\n        zeroObject(dstSegment, dst);\n        memset(dst, 0, sizeof(*dst));\n      }\n      return { dstSegment, nullptr };\n    }\n\n    const word* ptr = WireHelpers::followFars(src, srcTarget, srcSegment);\n    if (KJ_UNLIKELY(ptr == nullptr)) {\n      // Already reported the error.\n      goto useDefault;\n    }\n\n    switch (src->kind()) {\n      case WirePointer::STRUCT:\n        KJ_REQUIRE(nestingLimit > 0,\n              \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n          goto useDefault;\n        }\n\n        KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + src->structRef.wordSize()),\n                   \"Message contained out-of-bounds struct pointer.\") {\n          goto useDefault;\n        }\n        return setStructPointer(dstSegment, dst,\n            StructReader(srcSegment, ptr,\n                         reinterpret_cast<const WirePointer*>(ptr + src->structRef.dataSize.get()),\n                         src->structRef.dataSize.get() * BITS_PER_WORD,\n                         src->structRef.ptrCount.get(),\n                         nestingLimit - 1),\n            orphanArena);\n\n      case WirePointer::LIST: {\n        ElementSize elementSize = src->listRef.elementSize();\n\n        KJ_REQUIRE(nestingLimit > 0,\n              \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n          goto useDefault;\n        }\n\n        if (elementSize == ElementSize::INLINE_COMPOSITE) {\n          WordCount wordCount = src->listRef.inlineCompositeWordCount();\n          const WirePointer* tag = reinterpret_cast<const WirePointer*>(ptr);\n          ptr += POINTER_SIZE_IN_WORDS;\n\n          KJ_REQUIRE(boundsCheck(srcSegment, ptr - POINTER_SIZE_IN_WORDS, ptr + wordCount),\n                     \"Message contains out-of-bounds list pointer.\") {\n            goto useDefault;\n          }\n\n          KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n                     \"INLINE_COMPOSITE lists of non-STRUCT type are not supported.\") {\n            goto useDefault;\n          }\n\n          ElementCount elementCount = tag->inlineCompositeListElementCount();\n          auto wordsPerElement = tag->structRef.wordSize() / ELEMENTS;\n\n          KJ_REQUIRE(wordsPerElement * ElementCount64(elementCount) <= wordCount,\n                     \"INLINE_COMPOSITE list's elements overrun its word count.\") {\n            goto useDefault;\n          }\n\n          if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {\n            // Watch out for lists of zero-sized structs, which can claim to be arbitrarily large\n            // without having sent actual data.\n            KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n                       \"Message contains amplified list pointer.\") {\n              goto useDefault;\n            }\n          }\n\n          return setListPointer(dstSegment, dst,\n              ListReader(srcSegment, ptr, elementCount, wordsPerElement * BITS_PER_WORD,\n                         tag->structRef.dataSize.get() * BITS_PER_WORD,\n                         tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE,\n                         nestingLimit - 1),\n              orphanArena);\n        } else {\n          BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;\n          WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;\n          auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n          ElementCount elementCount = src->listRef.elementCount();\n          WordCount64 wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n\n          KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + wordCount),\n                     \"Message contains out-of-bounds list pointer.\") {\n            goto useDefault;\n          }\n\n          if (elementSize == ElementSize::VOID) {\n            // Watch out for lists of void, which can claim to be arbitrarily large without having\n            // sent actual data.\n            KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n                       \"Message contains amplified list pointer.\") {\n              goto useDefault;\n            }\n          }\n\n          return setListPointer(dstSegment, dst,\n              ListReader(srcSegment, ptr, elementCount, step, dataSize, pointerCount, elementSize,\n                         nestingLimit - 1),\n              orphanArena);\n        }\n      }\n\n      case WirePointer::FAR:\n        KJ_FAIL_ASSERT(\"Far pointer should have been handled above.\") {\n          goto useDefault;\n        }\n\n      case WirePointer::OTHER: {\n        KJ_REQUIRE(src->isCapability(), \"Unknown pointer type.\") {\n          goto useDefault;\n        }\n\n#if !CAPNP_LITE\n        KJ_IF_MAYBE(cap, srcSegment->getArena()->extractCap(src->capRef.index.get())) {\n          setCapabilityPointer(dstSegment, dst, kj::mv(*cap), orphanArena);\n          return { dstSegment, nullptr };\n        } else {\n#endif  // !CAPNP_LITE\n          KJ_FAIL_REQUIRE(\"Message contained invalid capability pointer.\") {\n            goto useDefault;\n          }\n#if !CAPNP_LITE\n        }\n#endif  // !CAPNP_LITE\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static SegmentAnd<word*> copyPointer(\n        SegmentBuilder* dstSegment, WirePointer* dst,\n        SegmentReader* srcSegment, const WirePointer* src, const word* srcTarget,\n        int nestingLimit, BuilderArena* orphanArena = nullptr) {\n      // Deep-copy the object pointed to by src into dst.  It turns out we can't reuse\n      // readStructPointer(), etc. because they do type checking whereas here we want to accept any\n      // valid pointer.\n  \n      if (src->isNull()) {\n      useDefault:\n        if (!dst->isNull()) {\n          zeroObject(dstSegment, dst);\n          memset(dst, 0, sizeof(*dst));\n        }\n        return { dstSegment, nullptr };\n      }\n  \n      const word* ptr = WireHelpers::followFars(src, srcTarget, srcSegment);\n      if (KJ_UNLIKELY(ptr == nullptr)) {\n        // Already reported the error.\n        goto useDefault;\n      }\n  \n      switch (src->kind()) {\n        case WirePointer::STRUCT:\n          KJ_REQUIRE(nestingLimit > 0,\n                \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n            goto useDefault;\n          }\n  \n          KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + src->structRef.wordSize()),\n                     \"Message contained out-of-bounds struct pointer.\") {\n            goto useDefault;\n          }\n          return setStructPointer(dstSegment, dst,\n              StructReader(srcSegment, ptr,\n                           reinterpret_cast<const WirePointer*>(ptr + src->structRef.dataSize.get()),\n                           src->structRef.dataSize.get() * BITS_PER_WORD,\n                           src->structRef.ptrCount.get(),\n                           nestingLimit - 1),\n              orphanArena);\n  \n        case WirePointer::LIST: {\n          ElementSize elementSize = src->listRef.elementSize();\n  \n          KJ_REQUIRE(nestingLimit > 0,\n                \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n            goto useDefault;\n          }\n  \n          if (elementSize == ElementSize::INLINE_COMPOSITE) {\n            WordCount wordCount = src->listRef.inlineCompositeWordCount();\n            const WirePointer* tag = reinterpret_cast<const WirePointer*>(ptr);\n            ptr += POINTER_SIZE_IN_WORDS;\n  \n            KJ_REQUIRE(boundsCheck(srcSegment, ptr - POINTER_SIZE_IN_WORDS, ptr + wordCount),\n                       \"Message contains out-of-bounds list pointer.\") {\n              goto useDefault;\n            }\n  \n            KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n                       \"INLINE_COMPOSITE lists of non-STRUCT type are not supported.\") {\n              goto useDefault;\n            }\n  \n            ElementCount elementCount = tag->inlineCompositeListElementCount();\n            auto wordsPerElement = tag->structRef.wordSize() / ELEMENTS;\n  \n            KJ_REQUIRE(wordsPerElement * ElementCount64(elementCount) <= wordCount,\n                       \"INLINE_COMPOSITE list's elements overrun its word count.\") {\n              goto useDefault;\n            }\n  \n            if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {\n              // Watch out for lists of zero-sized structs, which can claim to be arbitrarily large\n              // without having sent actual data.\n              KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n                         \"Message contains amplified list pointer.\") {\n                goto useDefault;\n              }\n            }\n  \n            return setListPointer(dstSegment, dst,\n                ListReader(srcSegment, ptr, elementCount, wordsPerElement * BITS_PER_WORD,\n                           tag->structRef.dataSize.get() * BITS_PER_WORD,\n                           tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE,\n                           nestingLimit - 1),\n                orphanArena);\n          } else {\n            BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;\n            WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;\n            auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n            ElementCount elementCount = src->listRef.elementCount();\n            WordCount64 wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n  \n            KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + wordCount),\n                       \"Message contains out-of-bounds list pointer.\") {\n              goto useDefault;\n            }\n  \n            if (elementSize == ElementSize::VOID) {\n              // Watch out for lists of void, which can claim to be arbitrarily large without having\n              // sent actual data.\n              KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n                         \"Message contains amplified list pointer.\") {\n                goto useDefault;\n              }\n            }\n  \n            return setListPointer(dstSegment, dst,\n                ListReader(srcSegment, ptr, elementCount, step, dataSize, pointerCount, elementSize,\n                           nestingLimit - 1),\n                orphanArena);\n          }\n        }\n  \n        case WirePointer::FAR:\n          KJ_FAIL_ASSERT(\"Far pointer should have been handled above.\") {\n            goto useDefault;\n          }\n  \n        case WirePointer::OTHER: {\n          KJ_REQUIRE(src->isCapability(), \"Unknown pointer type.\") {\n            goto useDefault;\n          }\n  \n  #if !CAPNP_LITE\n          KJ_IF_MAYBE(cap, srcSegment->getArena()->extractCap(src->capRef.index.get())) {\n            setCapabilityPointer(dstSegment, dst, kj::mv(*cap), orphanArena);\n            return { dstSegment, nullptr };\n          } else {\n  #endif  // !CAPNP_LITE\n            KJ_FAIL_REQUIRE(\"Message contained invalid capability pointer.\") {\n              goto useDefault;\n            }\n  #if !CAPNP_LITE\n          }\n  #endif  // !CAPNP_LITE\n        }\n      }\n  \n      KJ_UNREACHABLE;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::copy(BuilderArena* arena, PointerReader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::copyPointer(\n      nullptr, result.tagAsPtr(), copyFrom.segment, copyFrom.pointer, copyFrom.nestingLimit, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value);\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2680-2686",
    "snippet": "OrphanBuilder OrphanBuilder::copy(BuilderArena* arena, ListReader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::setListPointer(nullptr, result.tagAsPtr(), copyFrom, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value);\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "allocation.value"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::setListPointer",
          "args": [
            "nullptr",
            "result.tagAsPtr()",
            "copyFrom",
            "arena"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::copy(BuilderArena* arena, ListReader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::setListPointer(nullptr, result.tagAsPtr(), copyFrom, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value);\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2672-2678",
    "snippet": "OrphanBuilder OrphanBuilder::copy(BuilderArena* arena, StructReader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::setStructPointer(nullptr, result.tagAsPtr(), copyFrom, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value);\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "allocation.value"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::setStructPointer",
          "args": [
            "nullptr",
            "result.tagAsPtr()",
            "copyFrom",
            "arena"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::copy(BuilderArena* arena, StructReader copyFrom) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::setStructPointer(nullptr, result.tagAsPtr(), copyFrom, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value);\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::initData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2664-2670",
    "snippet": "OrphanBuilder OrphanBuilder::initData(BuilderArena* arena, ByteCount size) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::initDataPointer(result.tagAsPtr(), nullptr, size, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value.begin());\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "allocation.value.begin()"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocation.value.begin",
          "args": [],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::initDataPointer",
          "args": [
            "result.tagAsPtr()",
            "nullptr",
            "size",
            "arena"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::initData(BuilderArena* arena, ByteCount size) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::initDataPointer(result.tagAsPtr(), nullptr, size, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value.begin());\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::initText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2656-2662",
    "snippet": "OrphanBuilder OrphanBuilder::initText(BuilderArena* arena, ByteCount size) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::initTextPointer(result.tagAsPtr(), nullptr, size, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value.begin());\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "allocation.value.begin()"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocation.value.begin",
          "args": [],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::initTextPointer",
          "args": [
            "result.tagAsPtr()",
            "nullptr",
            "size",
            "arena"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::initText(BuilderArena* arena, ByteCount size) {\n  OrphanBuilder result;\n  auto allocation = WireHelpers::initTextPointer(result.tagAsPtr(), nullptr, size, arena);\n  result.segment = allocation.segment;\n  result.location = reinterpret_cast<word*>(allocation.value.begin());\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::initStructList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2646-2654",
    "snippet": "OrphanBuilder OrphanBuilder::initStructList(\n    BuilderArena* arena, ElementCount elementCount, StructSize elementSize) {\n  OrphanBuilder result;\n  ListBuilder builder = WireHelpers::initStructListPointer(\n      result.tagAsPtr(), nullptr, elementCount, elementSize, arena);\n  result.segment = builder.segment;\n  result.location = builder.getLocation();\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.getLocation",
          "args": [],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::initStructListPointer",
          "args": [
            "result.tagAsPtr()",
            "nullptr",
            "elementCount",
            "elementSize",
            "arena"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::initStructList(\n    BuilderArena* arena, ElementCount elementCount, StructSize elementSize) {\n  OrphanBuilder result;\n  ListBuilder builder = WireHelpers::initStructListPointer(\n      result.tagAsPtr(), nullptr, elementCount, elementSize, arena);\n  result.segment = builder.segment;\n  result.location = builder.getLocation();\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::initList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2636-2644",
    "snippet": "OrphanBuilder OrphanBuilder::initList(\n    BuilderArena* arena, ElementCount elementCount, ElementSize elementSize) {\n  OrphanBuilder result;\n  ListBuilder builder = WireHelpers::initListPointer(\n      result.tagAsPtr(), nullptr, elementCount, elementSize, arena);\n  result.segment = builder.segment;\n  result.location = builder.getLocation();\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.getLocation",
          "args": [],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::initListPointer",
          "args": [
            "result.tagAsPtr()",
            "nullptr",
            "elementCount",
            "elementSize",
            "arena"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::initList(\n    BuilderArena* arena, ElementCount elementCount, ElementSize elementSize) {\n  OrphanBuilder result;\n  ListBuilder builder = WireHelpers::initListPointer(\n      result.tagAsPtr(), nullptr, elementCount, elementSize, arena);\n  result.segment = builder.segment;\n  result.location = builder.getLocation();\n  return result;\n}"
  },
  {
    "function_name": "OrphanBuilder::initStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2628-2634",
    "snippet": "OrphanBuilder OrphanBuilder::initStruct(BuilderArena* arena, StructSize size) {\n  OrphanBuilder result;\n  StructBuilder builder = WireHelpers::initStructPointer(result.tagAsPtr(), nullptr, size, arena);\n  result.segment = builder.segment;\n  result.location = builder.getLocation();\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.getLocation",
          "args": [],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::initStructPointer",
          "args": [
            "result.tagAsPtr()",
            "nullptr",
            "size",
            "arena"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder OrphanBuilder::initStruct(BuilderArena* arena, StructSize size) {\n  OrphanBuilder result;\n  StructBuilder builder = WireHelpers::initStructPointer(result.tagAsPtr(), nullptr, size, arena);\n  result.segment = builder.segment;\n  result.location = builder.getLocation();\n  return result;\n}"
  },
  {
    "function_name": "ListReader::getStructElement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2602-2623",
    "snippet": "StructReader ListReader::getStructElement(ElementCount index) const {\n  KJ_REQUIRE(nestingLimit > 0,\n             \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n    return StructReader();\n  }\n\n  BitCount64 indexBit = ElementCount64(index) * step;\n  const byte* structData = ptr + indexBit / BITS_PER_BYTE;\n  const WirePointer* structPointers =\n      reinterpret_cast<const WirePointer*>(structData + structDataSize / BITS_PER_BYTE);\n\n  // This check should pass if there are no bugs in the list pointer validation code.\n  KJ_DASSERT(structPointerCount == 0 * POINTERS ||\n         (uintptr_t)structPointers % sizeof(void*) == 0,\n         \"Pointer section of struct list element not aligned.\");\n\n  KJ_DASSERT(indexBit % BITS_PER_BYTE == 0 * BITS);\n  return StructReader(\n      segment, structData, structPointers,\n      structDataSize, structPointerCount,\n      nestingLimit - 1);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructReader",
          "args": [
            "segment",
            "structData",
            "structPointers",
            "structDataSize",
            "structPointerCount",
            "nestingLimit - 1"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "StructReader",
          "container": "StructReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "539-543",
          "snippet": "inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,\n                      BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)\n      : segment(segment), data(data), pointers(pointers),\n        dataSize(dataSize), pointerCount(pointerCount),\n        nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructReader {\n  inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,\n                        BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)\n        : segment(segment), data(data), pointers(pointers),\n          dataSize(dataSize), pointerCount(pointerCount),\n          nestingLimit(nestingLimit) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "indexBit % BITS_PER_BYTE == 0 * BITS"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "structPointerCount == 0 * POINTERS ||\n         (uintptr_t)structPointers % sizeof(void*) == 0",
            "\"Pointer section of struct list element not aligned.\""
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "structData + structDataSize / BITS_PER_BYTE"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "index"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StructReader",
          "args": [],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "getPointerSectionSize",
          "container": "StructReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "491-491",
          "snippet": "inline WirePointerCount getPointerSectionSize() const { return pointerCount; }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructReader {\n  inline WirePointerCount getPointerSectionSize() const { return pointerCount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "nestingLimit > 0",
            "\"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\""
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nStructReader ListReader::getStructElement(ElementCount index) const {\n  KJ_REQUIRE(nestingLimit > 0,\n             \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n    return StructReader();\n  }\n\n  BitCount64 indexBit = ElementCount64(index) * step;\n  const byte* structData = ptr + indexBit / BITS_PER_BYTE;\n  const WirePointer* structPointers =\n      reinterpret_cast<const WirePointer*>(structData + structDataSize / BITS_PER_BYTE);\n\n  // This check should pass if there are no bugs in the list pointer validation code.\n  KJ_DASSERT(structPointerCount == 0 * POINTERS ||\n         (uintptr_t)structPointers % sizeof(void*) == 0,\n         \"Pointer section of struct list element not aligned.\");\n\n  KJ_DASSERT(indexBit % BITS_PER_BYTE == 0 * BITS);\n  return StructReader(\n      segment, structData, structPointers,\n      structDataSize, structPointerCount,\n      nestingLimit - 1);\n}"
  },
  {
    "function_name": "ListReader::asData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2593-2600",
    "snippet": "Data::Reader ListReader::asData() {\n  KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,\n             \"Expected Text, got list of non-bytes.\") {\n    return Data::Reader();\n  }\n\n  return Data::Reader(reinterpret_cast<const byte*>(ptr), elementCount / ELEMENTS);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Data::Reader",
          "args": [
            "reinterpret_cast<const byte*>(ptr)",
            "elementCount / ELEMENTS"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "Reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "80-80",
          "snippet": "inline Reader(const char* value, size_t size): StringPtr(value, size) {}",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Reader(const char* value, size_t size): StringPtr(value, size) {}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "ptr"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Data::Reader",
          "args": [],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS",
            "\"Expected Text, got list of non-bytes.\""
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nData::Reader ListReader::asData() {\n  KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,\n             \"Expected Text, got list of non-bytes.\") {\n    return Data::Reader();\n  }\n\n  return Data::Reader(reinterpret_cast<const byte*>(ptr), elementCount / ELEMENTS);\n}"
  },
  {
    "function_name": "ListReader::asText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2571-2591",
    "snippet": "Text::Reader ListReader::asText() {\n  KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,\n             \"Expected Text, got list of non-bytes.\") {\n    return Text::Reader();\n  }\n\n  size_t size = elementCount / ELEMENTS;\n\n  KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {\n    return Text::Reader();\n  }\n\n  const char* cptr = reinterpret_cast<const char*>(ptr);\n  --size;  // NUL terminator\n\n  KJ_REQUIRE(cptr[size] == '\\0', \"Message contains text that is not NUL-terminated.\") {\n    return Text::Reader();\n  }\n\n  return Text::Reader(cptr, size);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Text::Reader",
          "args": [
            "cptr",
            "size"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "Reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "80-80",
          "snippet": "inline Reader(const char* value, size_t size): StringPtr(value, size) {}",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Reader(const char* value, size_t size): StringPtr(value, size) {}"
        }
      },
      {
        "call_info": {
          "callee": "Text::Reader",
          "args": [],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "cptr[size] == '\\0'",
            "\"Message contains text that is not NUL-terminated.\""
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "ptr"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Text::Reader",
          "args": [],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "size > 0",
            "\"Message contains text that is not NUL-terminated.\""
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Text::Reader",
          "args": [],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS",
            "\"Expected Text, got list of non-bytes.\""
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nText::Reader ListReader::asText() {\n  KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,\n             \"Expected Text, got list of non-bytes.\") {\n    return Text::Reader();\n  }\n\n  size_t size = elementCount / ELEMENTS;\n\n  KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {\n    return Text::Reader();\n  }\n\n  const char* cptr = reinterpret_cast<const char*>(ptr);\n  --size;  // NUL terminator\n\n  KJ_REQUIRE(cptr[size] == '\\0', \"Message contains text that is not NUL-terminated.\") {\n    return Text::Reader();\n  }\n\n  return Text::Reader(cptr, size);\n}"
  },
  {
    "function_name": "ListBuilder::asReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2559-2562",
    "snippet": "ListReader ListBuilder::asReader() const {\n  return ListReader(segment, ptr, elementCount, step, structDataSize, structPointerCount,\n                    elementSize, kj::maxValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListReader",
          "args": [
            "segment",
            "ptr",
            "elementCount",
            "step",
            "structDataSize",
            "structPointerCount",
            "elementSize",
            "kj::maxValue"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "ListReader",
          "container": "ListReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "690-697",
          "snippet": "inline ListReader(SegmentReader* segment, const void* ptr,\n                    ElementCount elementCount, decltype(BITS / ELEMENTS) step,\n                    BitCount structDataSize, WirePointerCount structPointerCount,\n                    ElementSize elementSize, int nestingLimit)\n      : segment(segment), ptr(reinterpret_cast<const byte*>(ptr)), elementCount(elementCount),\n        step(step), structDataSize(structDataSize),\n        structPointerCount(structPointerCount), elementSize(elementSize),\n        nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListReader {\n  inline ListReader(SegmentReader* segment, const void* ptr,\n                      ElementCount elementCount, decltype(BITS / ELEMENTS) step,\n                      BitCount structDataSize, WirePointerCount structPointerCount,\n                      ElementSize elementSize, int nestingLimit)\n        : segment(segment), ptr(reinterpret_cast<const byte*>(ptr)), elementCount(elementCount),\n          step(step), structDataSize(structDataSize),\n          structPointerCount(structPointerCount), elementSize(elementSize),\n          nestingLimit(nestingLimit) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListReader ListBuilder::asReader() const {\n  return ListReader(segment, ptr, elementCount, step, structDataSize, structPointerCount,\n                    elementSize, kj::maxValue);\n}"
  },
  {
    "function_name": "ListBuilder::getStructElement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2550-2557",
    "snippet": "StructBuilder ListBuilder::getStructElement(ElementCount index) {\n  BitCount64 indexBit = ElementCount64(index) * step;\n  byte* structData = ptr + indexBit / BITS_PER_BYTE;\n  KJ_DASSERT(indexBit % BITS_PER_BYTE == 0 * BITS);\n  return StructBuilder(segment, structData,\n      reinterpret_cast<WirePointer*>(structData + structDataSize / BITS_PER_BYTE),\n      structDataSize, structPointerCount);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructBuilder",
          "args": [
            "segment",
            "structData",
            "reinterpret_cast<WirePointer*>(structData + structDataSize / BITS_PER_BYTE)",
            "structDataSize",
            "structPointerCount"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "StructBuilder",
          "container": "StructBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "472-475",
          "snippet": "inline StructBuilder(SegmentBuilder* segment, void* data, WirePointer* pointers,\n                       BitCount dataSize, WirePointerCount pointerCount)\n      : segment(segment), data(data), pointers(pointers),\n        dataSize(dataSize), pointerCount(pointerCount) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructBuilder {\n  inline StructBuilder(SegmentBuilder* segment, void* data, WirePointer* pointers,\n                         BitCount dataSize, WirePointerCount pointerCount)\n        : segment(segment), data(data), pointers(pointers),\n          dataSize(dataSize), pointerCount(pointerCount) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "structData + structDataSize / BITS_PER_BYTE"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "indexBit % BITS_PER_BYTE == 0 * BITS"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "index"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nStructBuilder ListBuilder::getStructElement(ElementCount index) {\n  BitCount64 indexBit = ElementCount64(index) * step;\n  byte* structData = ptr + indexBit / BITS_PER_BYTE;\n  KJ_DASSERT(indexBit % BITS_PER_BYTE == 0 * BITS);\n  return StructBuilder(segment, structData,\n      reinterpret_cast<WirePointer*>(structData + structDataSize / BITS_PER_BYTE),\n      structDataSize, structPointerCount);\n}"
  },
  {
    "function_name": "ListBuilder::asData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2541-2548",
    "snippet": "Data::Builder ListBuilder::asData() {\n  KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,\n             \"Expected Text, got list of non-bytes.\") {\n    return Data::Builder();\n  }\n\n  return Data::Builder(reinterpret_cast<byte*>(ptr), elementCount / ELEMENTS);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Data::Builder",
          "args": [
            "reinterpret_cast<byte*>(ptr)",
            "elementCount / ELEMENTS"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "Builder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "116-118",
          "snippet": "inline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "ptr"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS",
            "\"Expected Text, got list of non-bytes.\""
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nData::Builder ListBuilder::asData() {\n  KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,\n             \"Expected Text, got list of non-bytes.\") {\n    return Data::Builder();\n  }\n\n  return Data::Builder(reinterpret_cast<byte*>(ptr), elementCount / ELEMENTS);\n}"
  },
  {
    "function_name": "ListBuilder::asText",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2519-2539",
    "snippet": "Text::Builder ListBuilder::asText() {\n  KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,\n             \"Expected Text, got list of non-bytes.\") {\n    return Text::Builder();\n  }\n\n  size_t size = elementCount / ELEMENTS;\n\n  KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {\n    return Text::Builder();\n  }\n\n  char* cptr = reinterpret_cast<char*>(ptr);\n  --size;  // NUL terminator\n\n  KJ_REQUIRE(cptr[size] == '\\0', \"Message contains text that is not NUL-terminated.\") {\n    return Text::Builder();\n  }\n\n  return Text::Builder(cptr, size);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Text::Builder",
          "args": [
            "cptr",
            "size"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "Builder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "116-118",
          "snippet": "inline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "cptr[size] == '\\0'",
            "\"Message contains text that is not NUL-terminated.\""
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "ptr"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "size > 0",
            "\"Message contains text that is not NUL-terminated.\""
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS",
            "\"Expected Text, got list of non-bytes.\""
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nText::Builder ListBuilder::asText() {\n  KJ_REQUIRE(structDataSize == 8 * BITS && structPointerCount == 0 * POINTERS,\n             \"Expected Text, got list of non-bytes.\") {\n    return Text::Builder();\n  }\n\n  size_t size = elementCount / ELEMENTS;\n\n  KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {\n    return Text::Builder();\n  }\n\n  char* cptr = reinterpret_cast<char*>(ptr);\n  --size;  // NUL terminator\n\n  KJ_REQUIRE(cptr[size] == '\\0', \"Message contains text that is not NUL-terminated.\") {\n    return Text::Builder();\n  }\n\n  return Text::Builder(cptr, size);\n}"
  },
  {
    "function_name": "StructReader::totalSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2499-2514",
    "snippet": "MessageSizeCounts StructReader::totalSize() const {\n  MessageSizeCounts result = {\n    WireHelpers::roundBitsUpToWords(dataSize) + pointerCount * WORDS_PER_POINTER, 0 };\n\n  for (uint i = 0; i < pointerCount / POINTERS; i++) {\n    result += WireHelpers::totalSize(segment, pointers + i, nestingLimit);\n  }\n\n  if (segment != nullptr) {\n    // This traversal should not count against the read limit, because it's highly likely that\n    // the caller is going to traverse the object again, e.g. to copy it.\n    segment->unread(result.wordCount);\n  }\n\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segment->unread",
          "args": [
            "result.wordCount"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::totalSize",
          "args": [
            "segment",
            "pointers + i",
            "nestingLimit"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "totalSize",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "609-738",
          "snippet": "static MessageSizeCounts totalSize(\n      SegmentReader* segment, const WirePointer* ref, int nestingLimit) {\n    // Compute the total size of the object pointed to, not counting far pointer overhead.\n\n    MessageSizeCounts result = { 0 * WORDS, 0 };\n\n    if (ref->isNull()) {\n      return result;\n    }\n\n    KJ_REQUIRE(nestingLimit > 0, \"Message is too deeply-nested.\") {\n      return result;\n    }\n    --nestingLimit;\n\n    const word* ptr = followFars(ref, ref->target(), segment);\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT: {\n        KJ_REQUIRE(boundsCheck(segment, ptr, ptr + ref->structRef.wordSize()),\n                   \"Message contained out-of-bounds struct pointer.\") {\n          return result;\n        }\n        result.wordCount += ref->structRef.wordSize();\n\n        const WirePointer* pointerSection =\n            reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get());\n        uint count = ref->structRef.ptrCount.get() / POINTERS;\n        for (uint i = 0; i < count; i++) {\n          result += totalSize(segment, pointerSection + i, nestingLimit);\n        }\n        break;\n      }\n      case WirePointer::LIST: {\n        switch (ref->listRef.elementSize()) {\n          case ElementSize::VOID:\n            // Nothing.\n            break;\n          case ElementSize::BIT:\n          case ElementSize::BYTE:\n          case ElementSize::TWO_BYTES:\n          case ElementSize::FOUR_BYTES:\n          case ElementSize::EIGHT_BYTES: {\n            WordCount64 totalWords = roundBitsUpToWords(\n                ElementCount64(ref->listRef.elementCount()) *\n                dataBitsPerElement(ref->listRef.elementSize()));\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + totalWords),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n            result.wordCount += totalWords;\n            break;\n          }\n          case ElementSize::POINTER: {\n            WirePointerCount count = ref->listRef.elementCount() * (POINTERS / ELEMENTS);\n\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + count * WORDS_PER_POINTER),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n\n            result.wordCount += count * WORDS_PER_POINTER;\n\n            for (uint i = 0; i < count / POINTERS; i++) {\n              result += totalSize(segment, reinterpret_cast<const WirePointer*>(ptr) + i,\n                                  nestingLimit);\n            }\n            break;\n          }\n          case ElementSize::INLINE_COMPOSITE: {\n            WordCount wordCount = ref->listRef.inlineCompositeWordCount();\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount + POINTER_SIZE_IN_WORDS),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n\n            const WirePointer* elementTag = reinterpret_cast<const WirePointer*>(ptr);\n            ElementCount count = elementTag->inlineCompositeListElementCount();\n\n            KJ_REQUIRE(elementTag->kind() == WirePointer::STRUCT,\n                       \"Don't know how to handle non-STRUCT inline composite.\") {\n              return result;\n            }\n\n            auto actualSize = elementTag->structRef.wordSize() / ELEMENTS * ElementCount64(count);\n            KJ_REQUIRE(actualSize <= wordCount,\n                       \"Struct list pointer's elements overran size.\") {\n              return result;\n            }\n\n            // We count the actual size rather than the claimed word count because that's what\n            // we'll end up with if we make a copy.\n            result.wordCount += actualSize + POINTER_SIZE_IN_WORDS;\n\n            WordCount dataSize = elementTag->structRef.dataSize.get();\n            WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();\n\n            if (pointerCount > 0 * POINTERS) {\n              const word* pos = ptr + POINTER_SIZE_IN_WORDS;\n              for (uint i = 0; i < count / ELEMENTS; i++) {\n                pos += dataSize;\n\n                for (uint j = 0; j < pointerCount / POINTERS; j++) {\n                  result += totalSize(segment, reinterpret_cast<const WirePointer*>(pos),\n                                      nestingLimit);\n                  pos += POINTER_SIZE_IN_WORDS;\n                }\n              }\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case WirePointer::FAR:\n        KJ_FAIL_ASSERT(\"Unexpected FAR pointer.\") {\n          break;\n        }\n        break;\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n          result.capCount++;\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n\n    return result;\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static MessageSizeCounts totalSize(\n        SegmentReader* segment, const WirePointer* ref, int nestingLimit) {\n      // Compute the total size of the object pointed to, not counting far pointer overhead.\n  \n      MessageSizeCounts result = { 0 * WORDS, 0 };\n  \n      if (ref->isNull()) {\n        return result;\n      }\n  \n      KJ_REQUIRE(nestingLimit > 0, \"Message is too deeply-nested.\") {\n        return result;\n      }\n      --nestingLimit;\n  \n      const word* ptr = followFars(ref, ref->target(), segment);\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT: {\n          KJ_REQUIRE(boundsCheck(segment, ptr, ptr + ref->structRef.wordSize()),\n                     \"Message contained out-of-bounds struct pointer.\") {\n            return result;\n          }\n          result.wordCount += ref->structRef.wordSize();\n  \n          const WirePointer* pointerSection =\n              reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get());\n          uint count = ref->structRef.ptrCount.get() / POINTERS;\n          for (uint i = 0; i < count; i++) {\n            result += totalSize(segment, pointerSection + i, nestingLimit);\n          }\n          break;\n        }\n        case WirePointer::LIST: {\n          switch (ref->listRef.elementSize()) {\n            case ElementSize::VOID:\n              // Nothing.\n              break;\n            case ElementSize::BIT:\n            case ElementSize::BYTE:\n            case ElementSize::TWO_BYTES:\n            case ElementSize::FOUR_BYTES:\n            case ElementSize::EIGHT_BYTES: {\n              WordCount64 totalWords = roundBitsUpToWords(\n                  ElementCount64(ref->listRef.elementCount()) *\n                  dataBitsPerElement(ref->listRef.elementSize()));\n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + totalWords),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n              result.wordCount += totalWords;\n              break;\n            }\n            case ElementSize::POINTER: {\n              WirePointerCount count = ref->listRef.elementCount() * (POINTERS / ELEMENTS);\n  \n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + count * WORDS_PER_POINTER),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n  \n              result.wordCount += count * WORDS_PER_POINTER;\n  \n              for (uint i = 0; i < count / POINTERS; i++) {\n                result += totalSize(segment, reinterpret_cast<const WirePointer*>(ptr) + i,\n                                    nestingLimit);\n              }\n              break;\n            }\n            case ElementSize::INLINE_COMPOSITE: {\n              WordCount wordCount = ref->listRef.inlineCompositeWordCount();\n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount + POINTER_SIZE_IN_WORDS),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n  \n              const WirePointer* elementTag = reinterpret_cast<const WirePointer*>(ptr);\n              ElementCount count = elementTag->inlineCompositeListElementCount();\n  \n              KJ_REQUIRE(elementTag->kind() == WirePointer::STRUCT,\n                         \"Don't know how to handle non-STRUCT inline composite.\") {\n                return result;\n              }\n  \n              auto actualSize = elementTag->structRef.wordSize() / ELEMENTS * ElementCount64(count);\n              KJ_REQUIRE(actualSize <= wordCount,\n                         \"Struct list pointer's elements overran size.\") {\n                return result;\n              }\n  \n              // We count the actual size rather than the claimed word count because that's what\n              // we'll end up with if we make a copy.\n              result.wordCount += actualSize + POINTER_SIZE_IN_WORDS;\n  \n              WordCount dataSize = elementTag->structRef.dataSize.get();\n              WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();\n  \n              if (pointerCount > 0 * POINTERS) {\n                const word* pos = ptr + POINTER_SIZE_IN_WORDS;\n                for (uint i = 0; i < count / ELEMENTS; i++) {\n                  pos += dataSize;\n  \n                  for (uint j = 0; j < pointerCount / POINTERS; j++) {\n                    result += totalSize(segment, reinterpret_cast<const WirePointer*>(pos),\n                                        nestingLimit);\n                    pos += POINTER_SIZE_IN_WORDS;\n                  }\n                }\n              }\n              break;\n            }\n          }\n          break;\n        }\n        case WirePointer::FAR:\n          KJ_FAIL_ASSERT(\"Unexpected FAR pointer.\") {\n            break;\n          }\n          break;\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n            result.capCount++;\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n  \n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::roundBitsUpToWords",
          "args": [
            "dataSize"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nMessageSizeCounts StructReader::totalSize() const {\n  MessageSizeCounts result = {\n    WireHelpers::roundBitsUpToWords(dataSize) + pointerCount * WORDS_PER_POINTER, 0 };\n\n  for (uint i = 0; i < pointerCount / POINTERS; i++) {\n    result += WireHelpers::totalSize(segment, pointers + i, nestingLimit);\n  }\n\n  if (segment != nullptr) {\n    // This traversal should not count against the read limit, because it's highly likely that\n    // the caller is going to traverse the object again, e.g. to copy it.\n    segment->unread(result.wordCount);\n  }\n\n  return result;\n}"
  },
  {
    "function_name": "StructBuilder::asReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2487-2490",
    "snippet": "StructReader StructBuilder::asReader() const {\n  return StructReader(segment, data, pointers,\n      dataSize, pointerCount, kj::maxValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructReader",
          "args": [
            "segment",
            "data",
            "pointers",
            "dataSize",
            "pointerCount",
            "kj::maxValue"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "StructReader",
          "container": "StructReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "539-543",
          "snippet": "inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,\n                      BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)\n      : segment(segment), data(data), pointers(pointers),\n        dataSize(dataSize), pointerCount(pointerCount),\n        nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructReader {\n  inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,\n                        BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)\n        : segment(segment), data(data), pointers(pointers),\n          dataSize(dataSize), pointerCount(pointerCount),\n          nestingLimit(nestingLimit) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nStructReader StructBuilder::asReader() const {\n  return StructReader(segment, data, pointers,\n      dataSize, pointerCount, kj::maxValue);\n}"
  },
  {
    "function_name": "StructBuilder::copyContentFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2451-2485",
    "snippet": "void StructBuilder::copyContentFrom(StructReader other) {\n  // Determine the amount of data the builders have in common.\n  BitCount sharedDataSize = kj::min(dataSize, other.dataSize);\n\n  if (dataSize > sharedDataSize) {\n    // Since the target is larger than the source, make sure to zero out the extra bits that the\n    // source doesn't have.\n    if (dataSize == 1 * BITS) {\n      setDataField<bool>(0 * ELEMENTS, false);\n    } else {\n      byte* unshared = reinterpret_cast<byte*>(data) + sharedDataSize / BITS_PER_BYTE / BYTES;\n      memset(unshared, 0, (dataSize - sharedDataSize) / BITS_PER_BYTE / BYTES);\n    }\n  }\n\n  // Copy over the shared part.\n  if (sharedDataSize == 1 * BITS) {\n    setDataField<bool>(0 * ELEMENTS, other.getDataField<bool>(0 * ELEMENTS));\n  } else {\n    memcpy(data, other.data, sharedDataSize / BITS_PER_BYTE / BYTES);\n  }\n\n  // Zero out all pointers in the target.\n  for (uint i = 0; i < pointerCount / POINTERS; i++) {\n    WireHelpers::zeroObject(segment, pointers + i);\n  }\n  memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);\n\n  // Copy the pointers.\n  WirePointerCount sharedPointerCount = kj::min(pointerCount, other.pointerCount);\n  for (uint i = 0; i < sharedPointerCount / POINTERS; i++) {\n    WireHelpers::copyPointer(segment, pointers + i,\n        other.segment, other.pointers + i, other.nestingLimit);\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::copyPointer",
          "args": [
            "segment",
            "pointers + i",
            "other.segment",
            "other.pointers + i",
            "other.nestingLimit"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "pointerCount",
            "other.pointerCount"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pointers",
            "0",
            "pointerCount * BYTES_PER_POINTER / BYTES"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::zeroObject",
          "args": [
            "segment",
            "pointers + i"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "other.data",
            "sharedDataSize / BITS_PER_BYTE / BYTES"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setDataField<bool>",
          "args": [
            "0 * ELEMENTS",
            "other.getDataField<bool>(0 * ELEMENTS)"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "StructBuilder::setDataField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "867-869",
          "snippet": "inline void StructBuilder::setDataField(ElementCount offset, kj::NoInfer<T> value) {\n  reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline void StructBuilder::setDataField(ElementCount offset, kj::NoInfer<T> value) {\n  reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "other.getDataField<bool>",
          "args": [
            "0 * ELEMENTS"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "unshared",
            "0",
            "(dataSize - sharedDataSize) / BITS_PER_BYTE / BYTES"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "data"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid StructBuilder::copyContentFrom(StructReader other) {\n  // Determine the amount of data the builders have in common.\n  BitCount sharedDataSize = kj::min(dataSize, other.dataSize);\n\n  if (dataSize > sharedDataSize) {\n    // Since the target is larger than the source, make sure to zero out the extra bits that the\n    // source doesn't have.\n    if (dataSize == 1 * BITS) {\n      setDataField<bool>(0 * ELEMENTS, false);\n    } else {\n      byte* unshared = reinterpret_cast<byte*>(data) + sharedDataSize / BITS_PER_BYTE / BYTES;\n      memset(unshared, 0, (dataSize - sharedDataSize) / BITS_PER_BYTE / BYTES);\n    }\n  }\n\n  // Copy over the shared part.\n  if (sharedDataSize == 1 * BITS) {\n    setDataField<bool>(0 * ELEMENTS, other.getDataField<bool>(0 * ELEMENTS));\n  } else {\n    memcpy(data, other.data, sharedDataSize / BITS_PER_BYTE / BYTES);\n  }\n\n  // Zero out all pointers in the target.\n  for (uint i = 0; i < pointerCount / POINTERS; i++) {\n    WireHelpers::zeroObject(segment, pointers + i);\n  }\n  memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);\n\n  // Copy the pointers.\n  WirePointerCount sharedPointerCount = kj::min(pointerCount, other.pointerCount);\n  for (uint i = 0; i < sharedPointerCount / POINTERS; i++) {\n    WireHelpers::copyPointer(segment, pointers + i,\n        other.segment, other.pointers + i, other.nestingLimit);\n  }\n}"
  },
  {
    "function_name": "StructBuilder::transferContentFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2411-2449",
    "snippet": "void StructBuilder::transferContentFrom(StructBuilder other) {\n  // Determine the amount of data the builders have in common.\n  BitCount sharedDataSize = kj::min(dataSize, other.dataSize);\n\n  if (dataSize > sharedDataSize) {\n    // Since the target is larger than the source, make sure to zero out the extra bits that the\n    // source doesn't have.\n    if (dataSize == 1 * BITS) {\n      setDataField<bool>(0 * ELEMENTS, false);\n    } else {\n      byte* unshared = reinterpret_cast<byte*>(data) + sharedDataSize / BITS_PER_BYTE / BYTES;\n      memset(unshared, 0, (dataSize - sharedDataSize) / BITS_PER_BYTE / BYTES);\n    }\n  }\n\n  // Copy over the shared part.\n  if (sharedDataSize == 1 * BITS) {\n    setDataField<bool>(0 * ELEMENTS, other.getDataField<bool>(0 * ELEMENTS));\n  } else {\n    memcpy(data, other.data, sharedDataSize / BITS_PER_BYTE / BYTES);\n  }\n\n  // Zero out all pointers in the target.\n  for (uint i = 0; i < pointerCount / POINTERS; i++) {\n    WireHelpers::zeroObject(segment, pointers + i);\n  }\n  memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);\n\n  // Transfer the pointers.\n  WirePointerCount sharedPointerCount = kj::min(pointerCount, other.pointerCount);\n  for (uint i = 0; i < sharedPointerCount / POINTERS; i++) {\n    WireHelpers::transferPointer(segment, pointers + i, other.segment, other.pointers + i);\n  }\n\n  // Zero out the pointers that were transferred in the source because it no longer has ownership.\n  // If the source had any extra pointers that the destination didn't have space for, we\n  // intentionally leave them be, so that they'll be cleaned up later.\n  memset(other.pointers, 0, sharedPointerCount * BYTES_PER_POINTER / BYTES);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "other.pointers",
            "0",
            "sharedPointerCount * BYTES_PER_POINTER / BYTES"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::transferPointer",
          "args": [
            "segment",
            "pointers + i",
            "other.segment",
            "other.pointers + i"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "transferPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "856-877",
          "snippet": "static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                              SegmentBuilder* srcSegment, WirePointer* src) {\n    // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n    // be in different segments.  Not always-inline because this is rarely used.\n    //\n    // Caller MUST zero out the source pointer after calling this, to make sure no later code\n    // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n    // this zeroing itself because many callers transfer several pointers in a loop then zero out\n    // the whole section.\n\n    KJ_DASSERT(dst->isNull());\n    // We expect the caller to ensure the target is already null so won't leak.\n\n    if (src->isNull()) {\n      memset(dst, 0, sizeof(WirePointer));\n    } else if (src->kind() == WirePointer::FAR) {\n      // Far pointers are position-independent, so we can just copy.\n      memcpy(dst, src, sizeof(WirePointer));\n    } else {\n      transferPointer(dstSegment, dst, srcSegment, src, src->target());\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                                SegmentBuilder* srcSegment, WirePointer* src) {\n      // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n      // be in different segments.  Not always-inline because this is rarely used.\n      //\n      // Caller MUST zero out the source pointer after calling this, to make sure no later code\n      // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n      // this zeroing itself because many callers transfer several pointers in a loop then zero out\n      // the whole section.\n  \n      KJ_DASSERT(dst->isNull());\n      // We expect the caller to ensure the target is already null so won't leak.\n  \n      if (src->isNull()) {\n        memset(dst, 0, sizeof(WirePointer));\n      } else if (src->kind() == WirePointer::FAR) {\n        // Far pointers are position-independent, so we can just copy.\n        memcpy(dst, src, sizeof(WirePointer));\n      } else {\n        transferPointer(dstSegment, dst, srcSegment, src, src->target());\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "pointerCount",
            "other.pointerCount"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pointers",
            "0",
            "pointerCount * BYTES_PER_POINTER / BYTES"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::zeroObject",
          "args": [
            "segment",
            "pointers + i"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "other.data",
            "sharedDataSize / BITS_PER_BYTE / BYTES"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setDataField<bool>",
          "args": [
            "0 * ELEMENTS",
            "other.getDataField<bool>(0 * ELEMENTS)"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "StructBuilder::setDataField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "867-869",
          "snippet": "inline void StructBuilder::setDataField(ElementCount offset, kj::NoInfer<T> value) {\n  reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline void StructBuilder::setDataField(ElementCount offset, kj::NoInfer<T> value) {\n  reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "other.getDataField<bool>",
          "args": [
            "0 * ELEMENTS"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "unshared",
            "0",
            "(dataSize - sharedDataSize) / BITS_PER_BYTE / BYTES"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "data"
          ],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid StructBuilder::transferContentFrom(StructBuilder other) {\n  // Determine the amount of data the builders have in common.\n  BitCount sharedDataSize = kj::min(dataSize, other.dataSize);\n\n  if (dataSize > sharedDataSize) {\n    // Since the target is larger than the source, make sure to zero out the extra bits that the\n    // source doesn't have.\n    if (dataSize == 1 * BITS) {\n      setDataField<bool>(0 * ELEMENTS, false);\n    } else {\n      byte* unshared = reinterpret_cast<byte*>(data) + sharedDataSize / BITS_PER_BYTE / BYTES;\n      memset(unshared, 0, (dataSize - sharedDataSize) / BITS_PER_BYTE / BYTES);\n    }\n  }\n\n  // Copy over the shared part.\n  if (sharedDataSize == 1 * BITS) {\n    setDataField<bool>(0 * ELEMENTS, other.getDataField<bool>(0 * ELEMENTS));\n  } else {\n    memcpy(data, other.data, sharedDataSize / BITS_PER_BYTE / BYTES);\n  }\n\n  // Zero out all pointers in the target.\n  for (uint i = 0; i < pointerCount / POINTERS; i++) {\n    WireHelpers::zeroObject(segment, pointers + i);\n  }\n  memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);\n\n  // Transfer the pointers.\n  WirePointerCount sharedPointerCount = kj::min(pointerCount, other.pointerCount);\n  for (uint i = 0; i < sharedPointerCount / POINTERS; i++) {\n    WireHelpers::transferPointer(segment, pointers + i, other.segment, other.pointers + i);\n  }\n\n  // Zero out the pointers that were transferred in the source because it no longer has ownership.\n  // If the source had any extra pointers that the destination didn't have space for, we\n  // intentionally leave them be, so that they'll be cleaned up later.\n  memset(other.pointers, 0, sharedPointerCount * BYTES_PER_POINTER / BYTES);\n}"
  },
  {
    "function_name": "StructBuilder::clearAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2398-2409",
    "snippet": "void StructBuilder::clearAll() {\n  if (dataSize == 1 * BITS) {\n    setDataField<bool>(1 * ELEMENTS, false);\n  } else {\n    memset(data, 0, dataSize / BITS_PER_BYTE / BYTES);\n  }\n\n  for (uint i = 0; i < pointerCount / POINTERS; i++) {\n    WireHelpers::zeroObject(segment, pointers + i);\n  }\n  memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pointers",
            "0",
            "pointerCount * BYTES_PER_POINTER / BYTES"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::zeroObject",
          "args": [
            "segment",
            "pointers + i"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "dataSize / BITS_PER_BYTE / BYTES"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setDataField<bool>",
          "args": [
            "1 * ELEMENTS",
            "false"
          ],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "StructBuilder::setDataField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "867-869",
          "snippet": "inline void StructBuilder::setDataField(ElementCount offset, kj::NoInfer<T> value) {\n  reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline void StructBuilder::setDataField(ElementCount offset, kj::NoInfer<T> value) {\n  reinterpret_cast<WireValue<T>*>(data)[offset / ELEMENTS].set(value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid StructBuilder::clearAll() {\n  if (dataSize == 1 * BITS) {\n    setDataField<bool>(1 * ELEMENTS, false);\n  } else {\n    memset(data, 0, dataSize / BITS_PER_BYTE / BYTES);\n  }\n\n  for (uint i = 0; i < pointerCount / POINTERS; i++) {\n    WireHelpers::zeroObject(segment, pointers + i);\n  }\n  memset(pointers, 0, pointerCount * BYTES_PER_POINTER / BYTES);\n}"
  },
  {
    "function_name": "PointerReader::getArena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2391-2393",
    "snippet": "kj::Maybe<Arena&> PointerReader::getArena() const {\n  return segment == nullptr ? nullptr : segment->getArena();\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nkj::Maybe<Arena&> PointerReader::getArena() const {\n  return segment == nullptr ? nullptr : segment->getArena();\n}"
  },
  {
    "function_name": "PointerReader::isList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2383-2389",
    "snippet": "bool PointerReader::isList() const {\n  word* refTarget = nullptr;\n  const WirePointer* ptr = pointer;\n  SegmentReader* sgmt = segment;\n  WireHelpers::followFars(ptr, refTarget, sgmt);\n  return ptr->kind() == WirePointer::Kind::LIST;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr->kind",
          "args": [],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::followFars",
          "args": [
            "ptr",
            "refTarget",
            "sgmt"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nbool PointerReader::isList() const {\n  word* refTarget = nullptr;\n  const WirePointer* ptr = pointer;\n  SegmentReader* sgmt = segment;\n  WireHelpers::followFars(ptr, refTarget, sgmt);\n  return ptr->kind() == WirePointer::Kind::LIST;\n}"
  },
  {
    "function_name": "PointerReader::isStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2375-2381",
    "snippet": "bool PointerReader::isStruct() const {\n  word* refTarget = nullptr;\n  const WirePointer* ptr = pointer;\n  SegmentReader* sgmt = segment;\n  WireHelpers::followFars(ptr, refTarget, sgmt);\n  return ptr->kind() == WirePointer::Kind::STRUCT;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr->kind",
          "args": [],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::followFars",
          "args": [
            "ptr",
            "refTarget",
            "sgmt"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nbool PointerReader::isStruct() const {\n  word* refTarget = nullptr;\n  const WirePointer* ptr = pointer;\n  SegmentReader* sgmt = segment;\n  WireHelpers::followFars(ptr, refTarget, sgmt);\n  return ptr->kind() == WirePointer::Kind::STRUCT;\n}"
  },
  {
    "function_name": "PointerReader::isNull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2371-2373",
    "snippet": "bool PointerReader::isNull() const {\n  return pointer == nullptr || pointer->isNull();\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pointer->isNull",
          "args": [],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nbool PointerReader::isNull() const {\n  return pointer == nullptr || pointer->isNull();\n}"
  },
  {
    "function_name": "PointerReader::targetSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2366-2369",
    "snippet": "MessageSizeCounts PointerReader::targetSize() const {\n  return pointer == nullptr ? MessageSizeCounts { 0 * WORDS, 0 }\n                            : WireHelpers::totalSize(segment, pointer, nestingLimit);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::totalSize",
          "args": [
            "segment",
            "pointer",
            "nestingLimit"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "totalSize",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "609-738",
          "snippet": "static MessageSizeCounts totalSize(\n      SegmentReader* segment, const WirePointer* ref, int nestingLimit) {\n    // Compute the total size of the object pointed to, not counting far pointer overhead.\n\n    MessageSizeCounts result = { 0 * WORDS, 0 };\n\n    if (ref->isNull()) {\n      return result;\n    }\n\n    KJ_REQUIRE(nestingLimit > 0, \"Message is too deeply-nested.\") {\n      return result;\n    }\n    --nestingLimit;\n\n    const word* ptr = followFars(ref, ref->target(), segment);\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT: {\n        KJ_REQUIRE(boundsCheck(segment, ptr, ptr + ref->structRef.wordSize()),\n                   \"Message contained out-of-bounds struct pointer.\") {\n          return result;\n        }\n        result.wordCount += ref->structRef.wordSize();\n\n        const WirePointer* pointerSection =\n            reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get());\n        uint count = ref->structRef.ptrCount.get() / POINTERS;\n        for (uint i = 0; i < count; i++) {\n          result += totalSize(segment, pointerSection + i, nestingLimit);\n        }\n        break;\n      }\n      case WirePointer::LIST: {\n        switch (ref->listRef.elementSize()) {\n          case ElementSize::VOID:\n            // Nothing.\n            break;\n          case ElementSize::BIT:\n          case ElementSize::BYTE:\n          case ElementSize::TWO_BYTES:\n          case ElementSize::FOUR_BYTES:\n          case ElementSize::EIGHT_BYTES: {\n            WordCount64 totalWords = roundBitsUpToWords(\n                ElementCount64(ref->listRef.elementCount()) *\n                dataBitsPerElement(ref->listRef.elementSize()));\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + totalWords),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n            result.wordCount += totalWords;\n            break;\n          }\n          case ElementSize::POINTER: {\n            WirePointerCount count = ref->listRef.elementCount() * (POINTERS / ELEMENTS);\n\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + count * WORDS_PER_POINTER),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n\n            result.wordCount += count * WORDS_PER_POINTER;\n\n            for (uint i = 0; i < count / POINTERS; i++) {\n              result += totalSize(segment, reinterpret_cast<const WirePointer*>(ptr) + i,\n                                  nestingLimit);\n            }\n            break;\n          }\n          case ElementSize::INLINE_COMPOSITE: {\n            WordCount wordCount = ref->listRef.inlineCompositeWordCount();\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount + POINTER_SIZE_IN_WORDS),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n\n            const WirePointer* elementTag = reinterpret_cast<const WirePointer*>(ptr);\n            ElementCount count = elementTag->inlineCompositeListElementCount();\n\n            KJ_REQUIRE(elementTag->kind() == WirePointer::STRUCT,\n                       \"Don't know how to handle non-STRUCT inline composite.\") {\n              return result;\n            }\n\n            auto actualSize = elementTag->structRef.wordSize() / ELEMENTS * ElementCount64(count);\n            KJ_REQUIRE(actualSize <= wordCount,\n                       \"Struct list pointer's elements overran size.\") {\n              return result;\n            }\n\n            // We count the actual size rather than the claimed word count because that's what\n            // we'll end up with if we make a copy.\n            result.wordCount += actualSize + POINTER_SIZE_IN_WORDS;\n\n            WordCount dataSize = elementTag->structRef.dataSize.get();\n            WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();\n\n            if (pointerCount > 0 * POINTERS) {\n              const word* pos = ptr + POINTER_SIZE_IN_WORDS;\n              for (uint i = 0; i < count / ELEMENTS; i++) {\n                pos += dataSize;\n\n                for (uint j = 0; j < pointerCount / POINTERS; j++) {\n                  result += totalSize(segment, reinterpret_cast<const WirePointer*>(pos),\n                                      nestingLimit);\n                  pos += POINTER_SIZE_IN_WORDS;\n                }\n              }\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case WirePointer::FAR:\n        KJ_FAIL_ASSERT(\"Unexpected FAR pointer.\") {\n          break;\n        }\n        break;\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n          result.capCount++;\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n\n    return result;\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static MessageSizeCounts totalSize(\n        SegmentReader* segment, const WirePointer* ref, int nestingLimit) {\n      // Compute the total size of the object pointed to, not counting far pointer overhead.\n  \n      MessageSizeCounts result = { 0 * WORDS, 0 };\n  \n      if (ref->isNull()) {\n        return result;\n      }\n  \n      KJ_REQUIRE(nestingLimit > 0, \"Message is too deeply-nested.\") {\n        return result;\n      }\n      --nestingLimit;\n  \n      const word* ptr = followFars(ref, ref->target(), segment);\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT: {\n          KJ_REQUIRE(boundsCheck(segment, ptr, ptr + ref->structRef.wordSize()),\n                     \"Message contained out-of-bounds struct pointer.\") {\n            return result;\n          }\n          result.wordCount += ref->structRef.wordSize();\n  \n          const WirePointer* pointerSection =\n              reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get());\n          uint count = ref->structRef.ptrCount.get() / POINTERS;\n          for (uint i = 0; i < count; i++) {\n            result += totalSize(segment, pointerSection + i, nestingLimit);\n          }\n          break;\n        }\n        case WirePointer::LIST: {\n          switch (ref->listRef.elementSize()) {\n            case ElementSize::VOID:\n              // Nothing.\n              break;\n            case ElementSize::BIT:\n            case ElementSize::BYTE:\n            case ElementSize::TWO_BYTES:\n            case ElementSize::FOUR_BYTES:\n            case ElementSize::EIGHT_BYTES: {\n              WordCount64 totalWords = roundBitsUpToWords(\n                  ElementCount64(ref->listRef.elementCount()) *\n                  dataBitsPerElement(ref->listRef.elementSize()));\n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + totalWords),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n              result.wordCount += totalWords;\n              break;\n            }\n            case ElementSize::POINTER: {\n              WirePointerCount count = ref->listRef.elementCount() * (POINTERS / ELEMENTS);\n  \n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + count * WORDS_PER_POINTER),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n  \n              result.wordCount += count * WORDS_PER_POINTER;\n  \n              for (uint i = 0; i < count / POINTERS; i++) {\n                result += totalSize(segment, reinterpret_cast<const WirePointer*>(ptr) + i,\n                                    nestingLimit);\n              }\n              break;\n            }\n            case ElementSize::INLINE_COMPOSITE: {\n              WordCount wordCount = ref->listRef.inlineCompositeWordCount();\n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount + POINTER_SIZE_IN_WORDS),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n  \n              const WirePointer* elementTag = reinterpret_cast<const WirePointer*>(ptr);\n              ElementCount count = elementTag->inlineCompositeListElementCount();\n  \n              KJ_REQUIRE(elementTag->kind() == WirePointer::STRUCT,\n                         \"Don't know how to handle non-STRUCT inline composite.\") {\n                return result;\n              }\n  \n              auto actualSize = elementTag->structRef.wordSize() / ELEMENTS * ElementCount64(count);\n              KJ_REQUIRE(actualSize <= wordCount,\n                         \"Struct list pointer's elements overran size.\") {\n                return result;\n              }\n  \n              // We count the actual size rather than the claimed word count because that's what\n              // we'll end up with if we make a copy.\n              result.wordCount += actualSize + POINTER_SIZE_IN_WORDS;\n  \n              WordCount dataSize = elementTag->structRef.dataSize.get();\n              WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();\n  \n              if (pointerCount > 0 * POINTERS) {\n                const word* pos = ptr + POINTER_SIZE_IN_WORDS;\n                for (uint i = 0; i < count / ELEMENTS; i++) {\n                  pos += dataSize;\n  \n                  for (uint j = 0; j < pointerCount / POINTERS; j++) {\n                    result += totalSize(segment, reinterpret_cast<const WirePointer*>(pos),\n                                        nestingLimit);\n                    pos += POINTER_SIZE_IN_WORDS;\n                  }\n                }\n              }\n              break;\n            }\n          }\n          break;\n        }\n        case WirePointer::FAR:\n          KJ_FAIL_ASSERT(\"Unexpected FAR pointer.\") {\n            break;\n          }\n          break;\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n            result.capCount++;\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n  \n      return result;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nMessageSizeCounts PointerReader::targetSize() const {\n  return pointer == nullptr ? MessageSizeCounts { 0 * WORDS, 0 }\n                            : WireHelpers::totalSize(segment, pointer, nestingLimit);\n}"
  },
  {
    "function_name": "PointerReader::getCapability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2355-2358",
    "snippet": "kj::Own<ClientHook> PointerReader::getCapability() const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readCapabilityPointer(segment, ref, nestingLimit);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readCapabilityPointer",
          "args": [
            "segment",
            "ref",
            "nestingLimit"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nkj::Own<ClientHook> PointerReader::getCapability() const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readCapabilityPointer(segment, ref, nestingLimit);\n}"
  },
  {
    "function_name": "PointerReader::getBlob<Data>",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2349-2352",
    "snippet": "Data::Reader PointerReader::getBlob<Data>(const void* defaultValue, ByteCount defaultSize) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readDataPointer(segment, ref, defaultValue, defaultSize);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readDataPointer",
          "args": [
            "segment",
            "ref",
            "defaultValue",
            "defaultSize"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nData::Reader PointerReader::getBlob<Data>(const void* defaultValue, ByteCount defaultSize) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readDataPointer(segment, ref, defaultValue, defaultSize);\n}"
  },
  {
    "function_name": "PointerReader::getBlob<Text>",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2343-2346",
    "snippet": "Text::Reader PointerReader::getBlob<Text>(const void* defaultValue, ByteCount defaultSize) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readTextPointer(segment, ref, defaultValue, defaultSize);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readTextPointer",
          "args": [
            "segment",
            "ref",
            "defaultValue",
            "defaultSize"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nText::Reader PointerReader::getBlob<Text>(const void* defaultValue, ByteCount defaultSize) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readTextPointer(segment, ref, defaultValue, defaultSize);\n}"
  },
  {
    "function_name": "PointerReader::getListAnySize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2336-2340",
    "snippet": "ListReader PointerReader::getListAnySize(const word* defaultValue) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readListPointer(\n      segment, ref, defaultValue, ElementSize::VOID /* dummy */, nestingLimit, false);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readListPointer",
          "args": [
            "segment",
            "ref",
            "defaultValue",
            "ElementSize::VOID/* dummy */",
            "nestingLimit",
            "false"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListReader PointerReader::getListAnySize(const word* defaultValue) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readListPointer(\n      segment, ref, defaultValue, ElementSize::VOID /* dummy */, nestingLimit, false);\n}"
  },
  {
    "function_name": "PointerReader::getList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2330-2334",
    "snippet": "ListReader PointerReader::getList(ElementSize expectedElementSize, const word* defaultValue) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readListPointer(\n      segment, ref, defaultValue, expectedElementSize, nestingLimit);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readListPointer",
          "args": [
            "segment",
            "ref",
            "defaultValue",
            "expectedElementSize",
            "nestingLimit"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListReader PointerReader::getList(ElementSize expectedElementSize, const word* defaultValue) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readListPointer(\n      segment, ref, defaultValue, expectedElementSize, nestingLimit);\n}"
  },
  {
    "function_name": "PointerReader::getStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2325-2328",
    "snippet": "StructReader PointerReader::getStruct(const word* defaultValue) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readStructPointer(segment, ref, defaultValue, nestingLimit);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readStructPointer",
          "args": [
            "segment",
            "ref",
            "defaultValue",
            "nestingLimit"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nStructReader PointerReader::getStruct(const word* defaultValue) const {\n  const WirePointer* ref = pointer == nullptr ? &zero.pointer : pointer;\n  return WireHelpers::readStructPointer(segment, ref, defaultValue, nestingLimit);\n}"
  },
  {
    "function_name": "PointerReader::getRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2315-2323",
    "snippet": "PointerReader PointerReader::getRoot(SegmentReader* segment, const word* location,\n                                     int nestingLimit) {\n  KJ_REQUIRE(WireHelpers::boundsCheck(segment, location, location + POINTER_SIZE_IN_WORDS),\n             \"Root location out-of-bounds.\") {\n    location = nullptr;\n  }\n\n  return PointerReader(segment, reinterpret_cast<const WirePointer*>(location), nestingLimit);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerReader",
          "args": [
            "segment",
            "reinterpret_cast<const WirePointer*>(location)",
            "nestingLimit"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "PointerReader",
          "container": "PointerReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "390-391",
          "snippet": "inline PointerReader(SegmentReader* segment, const WirePointer* pointer, int nestingLimit)\n      : segment(segment), pointer(pointer), nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nPointerReader {\n  inline PointerReader(SegmentReader* segment, const WirePointer* pointer, int nestingLimit)\n        : segment(segment), pointer(pointer), nestingLimit(nestingLimit) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "location"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "WireHelpers::boundsCheck(segment, location, location + POINTER_SIZE_IN_WORDS)",
            "\"Root location out-of-bounds.\""
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::boundsCheck",
          "args": [
            "segment",
            "location",
            "location + POINTER_SIZE_IN_WORDS"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nPointerReader PointerReader::getRoot(SegmentReader* segment, const word* location,\n                                     int nestingLimit) {\n  KJ_REQUIRE(WireHelpers::boundsCheck(segment, location, location + POINTER_SIZE_IN_WORDS),\n             \"Root location out-of-bounds.\") {\n    location = nullptr;\n  }\n\n  return PointerReader(segment, reinterpret_cast<const WirePointer*>(location), nestingLimit);\n}"
  },
  {
    "function_name": "PointerBuilder::asReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2304-2306",
    "snippet": "PointerReader PointerBuilder::asReader() const {\n  return PointerReader(segment, pointer, kj::maxValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerReader",
          "args": [
            "segment",
            "pointer",
            "kj::maxValue"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "PointerReader",
          "container": "PointerReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "390-391",
          "snippet": "inline PointerReader(SegmentReader* segment, const WirePointer* pointer, int nestingLimit)\n      : segment(segment), pointer(pointer), nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nPointerReader {\n  inline PointerReader(SegmentReader* segment, const WirePointer* pointer, int nestingLimit)\n        : segment(segment), pointer(pointer), nestingLimit(nestingLimit) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nPointerReader PointerBuilder::asReader() const {\n  return PointerReader(segment, pointer, kj::maxValue);\n}"
  },
  {
    "function_name": "PointerBuilder::copyFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2294-2302",
    "snippet": "void PointerBuilder::copyFrom(PointerReader other) {\n  if (!pointer->isNull()) {\n    WireHelpers::zeroObject(segment, pointer);\n    memset(pointer, 0, sizeof(*pointer));\n  }\n  if (other.pointer != nullptr) {\n    WireHelpers::copyPointer(segment, pointer, other.segment, other.pointer, other.nestingLimit);\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::copyPointer",
          "args": [
            "segment",
            "pointer",
            "other.segment",
            "other.pointer",
            "other.nestingLimit"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pointer",
            "0",
            "sizeof(*pointer)"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::zeroObject",
          "args": [
            "segment",
            "pointer"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pointer->isNull",
          "args": [],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::copyFrom(PointerReader other) {\n  if (!pointer->isNull()) {\n    WireHelpers::zeroObject(segment, pointer);\n    memset(pointer, 0, sizeof(*pointer));\n  }\n  if (other.pointer != nullptr) {\n    WireHelpers::copyPointer(segment, pointer, other.segment, other.pointer, other.nestingLimit);\n  }\n}"
  },
  {
    "function_name": "PointerBuilder::transferFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2286-2292",
    "snippet": "void PointerBuilder::transferFrom(PointerBuilder other) {\n  if (!pointer->isNull()) {\n    WireHelpers::zeroObject(segment, pointer);\n    memset(pointer, 0, sizeof(*pointer));\n  }\n  WireHelpers::transferPointer(segment, pointer, other.segment, other.pointer);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::transferPointer",
          "args": [
            "segment",
            "pointer",
            "other.segment",
            "other.pointer"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "transferPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "856-877",
          "snippet": "static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                              SegmentBuilder* srcSegment, WirePointer* src) {\n    // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n    // be in different segments.  Not always-inline because this is rarely used.\n    //\n    // Caller MUST zero out the source pointer after calling this, to make sure no later code\n    // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n    // this zeroing itself because many callers transfer several pointers in a loop then zero out\n    // the whole section.\n\n    KJ_DASSERT(dst->isNull());\n    // We expect the caller to ensure the target is already null so won't leak.\n\n    if (src->isNull()) {\n      memset(dst, 0, sizeof(WirePointer));\n    } else if (src->kind() == WirePointer::FAR) {\n      // Far pointers are position-independent, so we can just copy.\n      memcpy(dst, src, sizeof(WirePointer));\n    } else {\n      transferPointer(dstSegment, dst, srcSegment, src, src->target());\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                                SegmentBuilder* srcSegment, WirePointer* src) {\n      // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n      // be in different segments.  Not always-inline because this is rarely used.\n      //\n      // Caller MUST zero out the source pointer after calling this, to make sure no later code\n      // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n      // this zeroing itself because many callers transfer several pointers in a loop then zero out\n      // the whole section.\n  \n      KJ_DASSERT(dst->isNull());\n      // We expect the caller to ensure the target is already null so won't leak.\n  \n      if (src->isNull()) {\n        memset(dst, 0, sizeof(WirePointer));\n      } else if (src->kind() == WirePointer::FAR) {\n        // Far pointers are position-independent, so we can just copy.\n        memcpy(dst, src, sizeof(WirePointer));\n      } else {\n        transferPointer(dstSegment, dst, srcSegment, src, src->target());\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pointer",
            "0",
            "sizeof(*pointer)"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::zeroObject",
          "args": [
            "segment",
            "pointer"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pointer->isNull",
          "args": [],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::transferFrom(PointerBuilder other) {\n  if (!pointer->isNull()) {\n    WireHelpers::zeroObject(segment, pointer);\n    memset(pointer, 0, sizeof(*pointer));\n  }\n  WireHelpers::transferPointer(segment, pointer, other.segment, other.pointer);\n}"
  },
  {
    "function_name": "PointerBuilder::isList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2280-2284",
    "snippet": "bool PointerBuilder::isList() {\n  WirePointer* ptr = pointer;\n  WireHelpers::followFars(ptr, ptr->target(), segment);\n  return ptr->kind() == WirePointer::Kind::LIST;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr->kind",
          "args": [],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::followFars",
          "args": [
            "ptr",
            "ptr->target()",
            "segment"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr->target",
          "args": [],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nbool PointerBuilder::isList() {\n  WirePointer* ptr = pointer;\n  WireHelpers::followFars(ptr, ptr->target(), segment);\n  return ptr->kind() == WirePointer::Kind::LIST;\n}"
  },
  {
    "function_name": "PointerBuilder::isStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2274-2278",
    "snippet": "bool PointerBuilder::isStruct() {\n  WirePointer* ptr = pointer;\n  WireHelpers::followFars(ptr, ptr->target(), segment);\n  return ptr->kind() == WirePointer::Kind::STRUCT;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptr->kind",
          "args": [],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WireHelpers::followFars",
          "args": [
            "ptr",
            "ptr->target()",
            "segment"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr->target",
          "args": [],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nbool PointerBuilder::isStruct() {\n  WirePointer* ptr = pointer;\n  WireHelpers::followFars(ptr, ptr->target(), segment);\n  return ptr->kind() == WirePointer::Kind::STRUCT;\n}"
  },
  {
    "function_name": "PointerBuilder::isNull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2270-2272",
    "snippet": "bool PointerBuilder::isNull() {\n  return pointer->isNull();\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pointer->isNull",
          "args": [],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nbool PointerBuilder::isNull() {\n  return pointer->isNull();\n}"
  },
  {
    "function_name": "PointerBuilder::clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2265-2268",
    "snippet": "void PointerBuilder::clear() {\n  WireHelpers::zeroObject(segment, pointer);\n  memset(pointer, 0, sizeof(WirePointer));\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pointer",
            "0",
            "sizeof(WirePointer)"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::zeroObject",
          "args": [
            "segment",
            "pointer"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::clear() {\n  WireHelpers::zeroObject(segment, pointer);\n  memset(pointer, 0, sizeof(WirePointer));\n}"
  },
  {
    "function_name": "PointerBuilder::disown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2261-2263",
    "snippet": "OrphanBuilder PointerBuilder::disown() {\n  return WireHelpers::disown(segment, pointer);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::disown",
          "args": [
            "segment",
            "pointer"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "disown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "1113-1115",
          "snippet": "static inline Orphan<DynamicCapability> disown(PointerBuilder builder, InterfaceSchema schema) {\n    return Orphan<DynamicCapability>(schema, builder.disown());\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\nstatic inline Orphan<DynamicCapability> disown(PointerBuilder builder, InterfaceSchema schema) {\n    return Orphan<DynamicCapability>(schema, builder.disown());\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nOrphanBuilder PointerBuilder::disown() {\n  return WireHelpers::disown(segment, pointer);\n}"
  },
  {
    "function_name": "PointerBuilder::adopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2257-2259",
    "snippet": "void PointerBuilder::adopt(OrphanBuilder&& value) {\n  WireHelpers::adopt(segment, pointer, kj::mv(value));\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::adopt",
          "args": [
            "segment",
            "pointer",
            "kj::mv(value)"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "adopt",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "1763-1785",
          "snippet": "static void adopt(SegmentBuilder* segment, WirePointer* ref, OrphanBuilder&& value) {\n    KJ_REQUIRE(value.segment == nullptr || value.segment->getArena() == segment->getArena(),\n               \"Adopted object must live in the same message.\");\n\n    if (!ref->isNull()) {\n      zeroObject(segment, ref);\n    }\n\n    if (value == nullptr) {\n      // Set null.\n      memset(ref, 0, sizeof(*ref));\n    } else if (value.tagAsPtr()->isPositional()) {\n      WireHelpers::transferPointer(segment, ref, value.segment, value.tagAsPtr(), value.location);\n    } else {\n      // FAR and OTHER pointers are position-independent, so we can just copy.\n      memcpy(ref, value.tagAsPtr(), sizeof(WirePointer));\n    }\n\n    // Take ownership away from the OrphanBuilder.\n    memset(value.tagAsPtr(), 0, sizeof(WirePointer));\n    value.location = nullptr;\n    value.segment = nullptr;\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void adopt(SegmentBuilder* segment, WirePointer* ref, OrphanBuilder&& value) {\n      KJ_REQUIRE(value.segment == nullptr || value.segment->getArena() == segment->getArena(),\n                 \"Adopted object must live in the same message.\");\n  \n      if (!ref->isNull()) {\n        zeroObject(segment, ref);\n      }\n  \n      if (value == nullptr) {\n        // Set null.\n        memset(ref, 0, sizeof(*ref));\n      } else if (value.tagAsPtr()->isPositional()) {\n        WireHelpers::transferPointer(segment, ref, value.segment, value.tagAsPtr(), value.location);\n      } else {\n        // FAR and OTHER pointers are position-independent, so we can just copy.\n        memcpy(ref, value.tagAsPtr(), sizeof(WirePointer));\n      }\n  \n      // Take ownership away from the OrphanBuilder.\n      memset(value.tagAsPtr(), 0, sizeof(WirePointer));\n      value.location = nullptr;\n      value.segment = nullptr;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::adopt(OrphanBuilder&& value) {\n  WireHelpers::adopt(segment, pointer, kj::mv(value));\n}"
  },
  {
    "function_name": "PointerBuilder::setCapability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2252-2254",
    "snippet": "void PointerBuilder::setCapability(kj::Own<ClientHook>&& cap) {\n  WireHelpers::setCapabilityPointer(segment, pointer, kj::mv(cap));\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::setCapabilityPointer",
          "args": [
            "segment",
            "pointer",
            "kj::mv(cap)"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "setCapabilityPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "1545-1553",
          "snippet": "static void setCapabilityPointer(\n      SegmentBuilder* segment, WirePointer* ref, kj::Own<ClientHook>&& cap,\n      BuilderArena* orphanArena = nullptr) {\n    if (orphanArena == nullptr) {\n      ref->setCap(segment->getArena()->injectCap(kj::mv(cap)));\n    } else {\n      ref->setCap(orphanArena->injectCap(kj::mv(cap)));\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void setCapabilityPointer(\n        SegmentBuilder* segment, WirePointer* ref, kj::Own<ClientHook>&& cap,\n        BuilderArena* orphanArena = nullptr) {\n      if (orphanArena == nullptr) {\n        ref->setCap(segment->getArena()->injectCap(kj::mv(cap)));\n      } else {\n        ref->setCap(orphanArena->injectCap(kj::mv(cap)));\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::setCapability(kj::Own<ClientHook>&& cap) {\n  WireHelpers::setCapabilityPointer(segment, pointer, kj::mv(cap));\n}"
  },
  {
    "function_name": "PointerBuilder::getCapability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2247-2250",
    "snippet": "kj::Own<ClientHook> PointerBuilder::getCapability() {\n  return WireHelpers::readCapabilityPointer(\n      segment, pointer, kj::maxValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::readCapabilityPointer",
          "args": [
            "segment",
            "pointer",
            "kj::maxValue"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nkj::Own<ClientHook> PointerBuilder::getCapability() {\n  return WireHelpers::readCapabilityPointer(\n      segment, pointer, kj::maxValue);\n}"
  },
  {
    "function_name": "PointerBuilder::setList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2242-2244",
    "snippet": "void PointerBuilder::setList(const ListReader& value) {\n  WireHelpers::setListPointer(segment, pointer, value);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::setListPointer",
          "args": [
            "segment",
            "pointer",
            "value"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "setListPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "1556-1610",
          "snippet": "static SegmentAnd<word*> setListPointer(\n      SegmentBuilder* segment, WirePointer* ref, ListReader value,\n      BuilderArena* orphanArena = nullptr) {\n    WordCount totalSize = roundBitsUpToWords(value.elementCount * value.step);\n\n    if (value.elementSize != ElementSize::INLINE_COMPOSITE) {\n      // List of non-structs.\n      word* ptr = allocate(ref, segment, totalSize, WirePointer::LIST, orphanArena);\n\n      if (value.elementSize == ElementSize::POINTER) {\n        // List of pointers.\n        ref->listRef.set(ElementSize::POINTER, value.elementCount);\n        for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {\n          copyPointer(segment, reinterpret_cast<WirePointer*>(ptr) + i,\n                      value.segment, reinterpret_cast<const WirePointer*>(value.ptr) + i,\n                      value.nestingLimit);\n        }\n      } else {\n        // List of data.\n        ref->listRef.set(value.elementSize, value.elementCount);\n        memcpy(ptr, value.ptr, totalSize * BYTES_PER_WORD / BYTES);\n      }\n\n      return { segment, ptr };\n    } else {\n      // List of structs.\n      word* ptr = allocate(ref, segment, totalSize + POINTER_SIZE_IN_WORDS, WirePointer::LIST,\n                           orphanArena);\n      ref->listRef.setInlineComposite(totalSize);\n\n      WordCount dataSize = roundBitsUpToWords(value.structDataSize);\n      WirePointerCount pointerCount = value.structPointerCount;\n\n      WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);\n      tag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, value.elementCount);\n      tag->structRef.set(dataSize, pointerCount);\n      word* dst = ptr + POINTER_SIZE_IN_WORDS;\n\n      const word* src = reinterpret_cast<const word*>(value.ptr);\n      for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {\n        memcpy(dst, src, value.structDataSize / BITS_PER_BYTE / BYTES);\n        dst += dataSize;\n        src += dataSize;\n\n        for (uint j = 0; j < pointerCount / POINTERS; j++) {\n          copyPointer(segment, reinterpret_cast<WirePointer*>(dst),\n              value.segment, reinterpret_cast<const WirePointer*>(src), value.nestingLimit);\n          dst += POINTER_SIZE_IN_WORDS;\n          src += POINTER_SIZE_IN_WORDS;\n        }\n      }\n\n      return { segment, ptr };\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static SegmentAnd<word*> setListPointer(\n        SegmentBuilder* segment, WirePointer* ref, ListReader value,\n        BuilderArena* orphanArena = nullptr) {\n      WordCount totalSize = roundBitsUpToWords(value.elementCount * value.step);\n  \n      if (value.elementSize != ElementSize::INLINE_COMPOSITE) {\n        // List of non-structs.\n        word* ptr = allocate(ref, segment, totalSize, WirePointer::LIST, orphanArena);\n  \n        if (value.elementSize == ElementSize::POINTER) {\n          // List of pointers.\n          ref->listRef.set(ElementSize::POINTER, value.elementCount);\n          for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {\n            copyPointer(segment, reinterpret_cast<WirePointer*>(ptr) + i,\n                        value.segment, reinterpret_cast<const WirePointer*>(value.ptr) + i,\n                        value.nestingLimit);\n          }\n        } else {\n          // List of data.\n          ref->listRef.set(value.elementSize, value.elementCount);\n          memcpy(ptr, value.ptr, totalSize * BYTES_PER_WORD / BYTES);\n        }\n  \n        return { segment, ptr };\n      } else {\n        // List of structs.\n        word* ptr = allocate(ref, segment, totalSize + POINTER_SIZE_IN_WORDS, WirePointer::LIST,\n                             orphanArena);\n        ref->listRef.setInlineComposite(totalSize);\n  \n        WordCount dataSize = roundBitsUpToWords(value.structDataSize);\n        WirePointerCount pointerCount = value.structPointerCount;\n  \n        WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);\n        tag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, value.elementCount);\n        tag->structRef.set(dataSize, pointerCount);\n        word* dst = ptr + POINTER_SIZE_IN_WORDS;\n  \n        const word* src = reinterpret_cast<const word*>(value.ptr);\n        for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {\n          memcpy(dst, src, value.structDataSize / BITS_PER_BYTE / BYTES);\n          dst += dataSize;\n          src += dataSize;\n  \n          for (uint j = 0; j < pointerCount / POINTERS; j++) {\n            copyPointer(segment, reinterpret_cast<WirePointer*>(dst),\n                value.segment, reinterpret_cast<const WirePointer*>(src), value.nestingLimit);\n            dst += POINTER_SIZE_IN_WORDS;\n            src += POINTER_SIZE_IN_WORDS;\n          }\n        }\n  \n        return { segment, ptr };\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::setList(const ListReader& value) {\n  WireHelpers::setListPointer(segment, pointer, value);\n}"
  },
  {
    "function_name": "PointerBuilder::setStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2238-2240",
    "snippet": "void PointerBuilder::setStruct(const StructReader& value) {\n  WireHelpers::setStructPointer(segment, pointer, value);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::setStructPointer",
          "args": [
            "segment",
            "pointer",
            "value"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "setStructPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "1520-1542",
          "snippet": "static SegmentAnd<word*> setStructPointer(\n      SegmentBuilder* segment, WirePointer* ref, StructReader value,\n      BuilderArena* orphanArena = nullptr) {\n    WordCount dataSize = roundBitsUpToWords(value.dataSize);\n    WordCount totalSize = dataSize + value.pointerCount * WORDS_PER_POINTER;\n\n    word* ptr = allocate(ref, segment, totalSize, WirePointer::STRUCT, orphanArena);\n    ref->structRef.set(dataSize, value.pointerCount);\n\n    if (value.dataSize == 1 * BITS) {\n      *reinterpret_cast<char*>(ptr) = value.getDataField<bool>(0 * ELEMENTS);\n    } else {\n      memcpy(ptr, value.data, value.dataSize / BITS_PER_BYTE / BYTES);\n    }\n\n    WirePointer* pointerSection = reinterpret_cast<WirePointer*>(ptr + dataSize);\n    for (uint i = 0; i < value.pointerCount / POINTERS; i++) {\n      copyPointer(segment, pointerSection + i, value.segment, value.pointers + i,\n                  value.nestingLimit);\n    }\n\n    return { segment, ptr };\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static SegmentAnd<word*> setStructPointer(\n        SegmentBuilder* segment, WirePointer* ref, StructReader value,\n        BuilderArena* orphanArena = nullptr) {\n      WordCount dataSize = roundBitsUpToWords(value.dataSize);\n      WordCount totalSize = dataSize + value.pointerCount * WORDS_PER_POINTER;\n  \n      word* ptr = allocate(ref, segment, totalSize, WirePointer::STRUCT, orphanArena);\n      ref->structRef.set(dataSize, value.pointerCount);\n  \n      if (value.dataSize == 1 * BITS) {\n        *reinterpret_cast<char*>(ptr) = value.getDataField<bool>(0 * ELEMENTS);\n      } else {\n        memcpy(ptr, value.data, value.dataSize / BITS_PER_BYTE / BYTES);\n      }\n  \n      WirePointer* pointerSection = reinterpret_cast<WirePointer*>(ptr + dataSize);\n      for (uint i = 0; i < value.pointerCount / POINTERS; i++) {\n        copyPointer(segment, pointerSection + i, value.segment, value.pointers + i,\n                    value.nestingLimit);\n      }\n  \n      return { segment, ptr };\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::setStruct(const StructReader& value) {\n  WireHelpers::setStructPointer(segment, pointer, value);\n}"
  },
  {
    "function_name": "PointerBuilder::getBlob<Data>",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2234-2236",
    "snippet": "Data::Builder PointerBuilder::getBlob<Data>(const void* defaultValue, ByteCount defaultSize) {\n  return WireHelpers::getWritableDataPointer(pointer, segment, defaultValue, defaultSize);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::getWritableDataPointer",
          "args": [
            "pointer",
            "segment",
            "defaultValue",
            "defaultSize"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nData::Builder PointerBuilder::getBlob<Data>(const void* defaultValue, ByteCount defaultSize) {\n  return WireHelpers::getWritableDataPointer(pointer, segment, defaultValue, defaultSize);\n}"
  },
  {
    "function_name": "PointerBuilder::setBlob<Data>",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2230-2232",
    "snippet": "void PointerBuilder::setBlob<Data>(Data::Reader value) {\n  WireHelpers::setDataPointer(pointer, segment, value);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::setDataPointer",
          "args": [
            "pointer",
            "segment",
            "value"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::setBlob<Data>(Data::Reader value) {\n  WireHelpers::setDataPointer(pointer, segment, value);\n}"
  },
  {
    "function_name": "PointerBuilder::initBlob<Data>",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2226-2228",
    "snippet": "Data::Builder PointerBuilder::initBlob<Data>(ByteCount size) {\n  return WireHelpers::initDataPointer(pointer, segment, size).value;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::initDataPointer",
          "args": [
            "pointer",
            "segment",
            "size"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nData::Builder PointerBuilder::initBlob<Data>(ByteCount size) {\n  return WireHelpers::initDataPointer(pointer, segment, size).value;\n}"
  },
  {
    "function_name": "PointerBuilder::getBlob<Text>",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2221-2223",
    "snippet": "Text::Builder PointerBuilder::getBlob<Text>(const void* defaultValue, ByteCount defaultSize) {\n  return WireHelpers::getWritableTextPointer(pointer, segment, defaultValue, defaultSize);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::getWritableTextPointer",
          "args": [
            "pointer",
            "segment",
            "defaultValue",
            "defaultSize"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nText::Builder PointerBuilder::getBlob<Text>(const void* defaultValue, ByteCount defaultSize) {\n  return WireHelpers::getWritableTextPointer(pointer, segment, defaultValue, defaultSize);\n}"
  },
  {
    "function_name": "PointerBuilder::setBlob<Text>",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2217-2219",
    "snippet": "void PointerBuilder::setBlob<Text>(Text::Reader value) {\n  WireHelpers::setTextPointer(pointer, segment, value);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::setTextPointer",
          "args": [
            "pointer",
            "segment",
            "value"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid PointerBuilder::setBlob<Text>(Text::Reader value) {\n  WireHelpers::setTextPointer(pointer, segment, value);\n}"
  },
  {
    "function_name": "PointerBuilder::initBlob<Text>",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2213-2215",
    "snippet": "Text::Builder PointerBuilder::initBlob<Text>(ByteCount size) {\n  return WireHelpers::initTextPointer(pointer, segment, size).value;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::initTextPointer",
          "args": [
            "pointer",
            "segment",
            "size"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nText::Builder PointerBuilder::initBlob<Text>(ByteCount size) {\n  return WireHelpers::initTextPointer(pointer, segment, size).value;\n}"
  },
  {
    "function_name": "PointerBuilder::getListAnySize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2208-2210",
    "snippet": "ListBuilder PointerBuilder::getListAnySize(const word* defaultValue) {\n  return WireHelpers::getWritableListPointerAnySize(pointer, segment, defaultValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::getWritableListPointerAnySize",
          "args": [
            "pointer",
            "segment",
            "defaultValue"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListBuilder PointerBuilder::getListAnySize(const word* defaultValue) {\n  return WireHelpers::getWritableListPointerAnySize(pointer, segment, defaultValue);\n}"
  },
  {
    "function_name": "PointerBuilder::getStructList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2204-2206",
    "snippet": "ListBuilder PointerBuilder::getStructList(StructSize elementSize, const word* defaultValue) {\n  return WireHelpers::getWritableStructListPointer(pointer, segment, elementSize, defaultValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::getWritableStructListPointer",
          "args": [
            "pointer",
            "segment",
            "elementSize",
            "defaultValue"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListBuilder PointerBuilder::getStructList(StructSize elementSize, const word* defaultValue) {\n  return WireHelpers::getWritableStructListPointer(pointer, segment, elementSize, defaultValue);\n}"
  },
  {
    "function_name": "PointerBuilder::getList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2200-2202",
    "snippet": "ListBuilder PointerBuilder::getList(ElementSize elementSize, const word* defaultValue) {\n  return WireHelpers::getWritableListPointer(pointer, segment, elementSize, defaultValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::getWritableListPointer",
          "args": [
            "pointer",
            "segment",
            "elementSize",
            "defaultValue"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListBuilder PointerBuilder::getList(ElementSize elementSize, const word* defaultValue) {\n  return WireHelpers::getWritableListPointer(pointer, segment, elementSize, defaultValue);\n}"
  },
  {
    "function_name": "PointerBuilder::initStructList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2196-2198",
    "snippet": "ListBuilder PointerBuilder::initStructList(ElementCount elementCount, StructSize elementSize) {\n  return WireHelpers::initStructListPointer(pointer, segment, elementCount, elementSize);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::initStructListPointer",
          "args": [
            "pointer",
            "segment",
            "elementCount",
            "elementSize"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListBuilder PointerBuilder::initStructList(ElementCount elementCount, StructSize elementSize) {\n  return WireHelpers::initStructListPointer(pointer, segment, elementCount, elementSize);\n}"
  },
  {
    "function_name": "PointerBuilder::initList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2192-2194",
    "snippet": "ListBuilder PointerBuilder::initList(ElementSize elementSize, ElementCount elementCount) {\n  return WireHelpers::initListPointer(pointer, segment, elementCount, elementSize);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::initListPointer",
          "args": [
            "pointer",
            "segment",
            "elementCount",
            "elementSize"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nListBuilder PointerBuilder::initList(ElementSize elementSize, ElementCount elementCount) {\n  return WireHelpers::initListPointer(pointer, segment, elementCount, elementSize);\n}"
  },
  {
    "function_name": "PointerBuilder::getStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2188-2190",
    "snippet": "StructBuilder PointerBuilder::getStruct(StructSize size, const word* defaultValue) {\n  return WireHelpers::getWritableStructPointer(pointer, segment, size, defaultValue);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::getWritableStructPointer",
          "args": [
            "pointer",
            "segment",
            "size",
            "defaultValue"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nStructBuilder PointerBuilder::getStruct(StructSize size, const word* defaultValue) {\n  return WireHelpers::getWritableStructPointer(pointer, segment, size, defaultValue);\n}"
  },
  {
    "function_name": "PointerBuilder::initStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2184-2186",
    "snippet": "StructBuilder PointerBuilder::initStruct(StructSize size) {\n  return WireHelpers::initStructPointer(pointer, segment, size);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WireHelpers::initStructPointer",
          "args": [
            "pointer",
            "segment",
            "size"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nStructBuilder PointerBuilder::initStruct(StructSize size) {\n  return WireHelpers::initStructPointer(pointer, segment, size);\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2144-2178",
    "snippet": "static KJ_ALWAYS_INLINE(Data::Reader readDataPointer(\n      SegmentReader* segment, const WirePointer* ref, const word* refTarget,\n      const void* defaultValue, ByteCount defaultSize)) {\n    if (ref->isNull()) {\n    useDefault:\n      return Data::Reader(reinterpret_cast<const byte*>(defaultValue), defaultSize / BYTES);\n    } else {\n      const word* ptr = followFars(ref, refTarget, segment);\n\n      if (KJ_UNLIKELY(ptr == nullptr)) {\n        // Already reported error.\n        goto useDefault;\n      }\n\n      uint size = ref->listRef.elementCount() / ELEMENTS;\n\n      KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n                 \"Message contains non-list pointer where data was expected.\") {\n        goto useDefault;\n      }\n\n      KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,\n                 \"Message contains list pointer of non-bytes where data was expected.\") {\n        goto useDefault;\n      }\n\n      KJ_REQUIRE(boundsCheck(segment, ptr, ptr +\n                     roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS))),\n                 \"Message contained out-of-bounds data pointer.\") {\n        goto useDefault;\n      }\n\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Data::Reader",
          "args": [
            "reinterpret_cast<const byte*>(ptr)",
            "size"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "Reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "80-80",
          "snippet": "inline Reader(const char* value, size_t size): StringPtr(value, size) {}",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Reader(const char* value, size_t size): StringPtr(value, size) {}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "ptr"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr +\n                     roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS)))",
            "\"Message contained out-of-bounds data pointer.\""
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr +\n                     roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS))"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBytesUpToWords",
          "args": [
            "ref->listRef.elementCount() * (1 * BYTES / ELEMENTS)"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->listRef.elementSize() == ElementSize::BYTE",
            "\"Message contains list pointer of non-bytes where data was expected.\""
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::LIST",
            "\"Message contains non-list pointer where data was expected.\""
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "ptr == nullptr"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "refTarget",
            "segment"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "defaultValue"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(Data::Reader readDataPointer(\n        SegmentReader* segment, const WirePointer* ref, const word* refTarget,\n        const void* defaultValue, ByteCount defaultSize)) {\n      if (ref->isNull()) {\n      useDefault:\n        return Data::Reader(reinterpret_cast<const byte*>(defaultValue), defaultSize / BYTES);\n      } else {\n        const word* ptr = followFars(ref, refTarget, segment);\n  \n        if (KJ_UNLIKELY(ptr == nullptr)) {\n          // Already reported error.\n          goto useDefault;\n        }\n  \n        uint size = ref->listRef.elementCount() / ELEMENTS;\n  \n        KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n                   \"Message contains non-list pointer where data was expected.\") {\n          goto useDefault;\n        }\n  \n        KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,\n                   \"Message contains list pointer of non-bytes where data was expected.\") {\n          goto useDefault;\n        }\n  \n        KJ_REQUIRE(boundsCheck(segment, ptr, ptr +\n                       roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS))),\n                   \"Message contained out-of-bounds data pointer.\") {\n          goto useDefault;\n        }\n  \n        return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2138-2142",
    "snippet": "static KJ_ALWAYS_INLINE(Data::Reader readDataPointer(\n      SegmentReader* segment, const WirePointer* ref,\n      const void* defaultValue, ByteCount defaultSize)) {\n    return readDataPointer(segment, ref, ref->target(), defaultValue, defaultSize);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readDataPointer",
          "args": [
            "segment",
            "ref",
            "ref->target()",
            "defaultValue",
            "defaultSize"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(Data::Reader readDataPointer(\n        SegmentReader* segment, const WirePointer* ref,\n        const void* defaultValue, ByteCount defaultSize)) {\n      return readDataPointer(segment, ref, ref->target(), defaultValue, defaultSize);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2090-2136",
    "snippet": "static KJ_ALWAYS_INLINE(Text::Reader readTextPointer(\n      SegmentReader* segment, const WirePointer* ref, const word* refTarget,\n      const void* defaultValue, ByteCount defaultSize)) {\n    if (ref->isNull()) {\n    useDefault:\n      if (defaultValue == nullptr) defaultValue = \"\";\n      return Text::Reader(reinterpret_cast<const char*>(defaultValue), defaultSize / BYTES);\n    } else {\n      const word* ptr = followFars(ref, refTarget, segment);\n\n      if (KJ_UNLIKELY(ptr == nullptr)) {\n        // Already reported error.\n        goto useDefault;\n      }\n\n      uint size = ref->listRef.elementCount() / ELEMENTS;\n\n      KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n                 \"Message contains non-list pointer where text was expected.\") {\n        goto useDefault;\n      }\n\n      KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,\n                 \"Message contains list pointer of non-bytes where text was expected.\") {\n        goto useDefault;\n      }\n\n      KJ_REQUIRE(boundsCheck(segment, ptr, ptr +\n                     roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS))),\n                 \"Message contained out-of-bounds text pointer.\") {\n        goto useDefault;\n      }\n\n      KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {\n        goto useDefault;\n      }\n\n      const char* cptr = reinterpret_cast<const char*>(ptr);\n      --size;  // NUL terminator\n\n      KJ_REQUIRE(cptr[size] == '\\0', \"Message contains text that is not NUL-terminated.\") {\n        goto useDefault;\n      }\n\n      return Text::Reader(cptr, size);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Text::Reader",
          "args": [
            "cptr",
            "size"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "Reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "80-80",
          "snippet": "inline Reader(const char* value, size_t size): StringPtr(value, size) {}",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Reader(const char* value, size_t size): StringPtr(value, size) {}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "cptr[size] == '\\0'",
            "\"Message contains text that is not NUL-terminated.\""
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "ptr"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "size > 0",
            "\"Message contains text that is not NUL-terminated.\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr +\n                     roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS)))",
            "\"Message contained out-of-bounds text pointer.\""
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr +\n                     roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS))"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBytesUpToWords",
          "args": [
            "ref->listRef.elementCount() * (1 * BYTES / ELEMENTS)"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->listRef.elementSize() == ElementSize::BYTE",
            "\"Message contains list pointer of non-bytes where text was expected.\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::LIST",
            "\"Message contains non-list pointer where text was expected.\""
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "ptr == nullptr"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "refTarget",
            "segment"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "defaultValue"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(Text::Reader readTextPointer(\n        SegmentReader* segment, const WirePointer* ref, const word* refTarget,\n        const void* defaultValue, ByteCount defaultSize)) {\n      if (ref->isNull()) {\n      useDefault:\n        if (defaultValue == nullptr) defaultValue = \"\";\n        return Text::Reader(reinterpret_cast<const char*>(defaultValue), defaultSize / BYTES);\n      } else {\n        const word* ptr = followFars(ref, refTarget, segment);\n  \n        if (KJ_UNLIKELY(ptr == nullptr)) {\n          // Already reported error.\n          goto useDefault;\n        }\n  \n        uint size = ref->listRef.elementCount() / ELEMENTS;\n  \n        KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n                   \"Message contains non-list pointer where text was expected.\") {\n          goto useDefault;\n        }\n  \n        KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,\n                   \"Message contains list pointer of non-bytes where text was expected.\") {\n          goto useDefault;\n        }\n  \n        KJ_REQUIRE(boundsCheck(segment, ptr, ptr +\n                       roundBytesUpToWords(ref->listRef.elementCount() * (1 * BYTES / ELEMENTS))),\n                   \"Message contained out-of-bounds text pointer.\") {\n          goto useDefault;\n        }\n  \n        KJ_REQUIRE(size > 0, \"Message contains text that is not NUL-terminated.\") {\n          goto useDefault;\n        }\n  \n        const char* cptr = reinterpret_cast<const char*>(ptr);\n        --size;  // NUL terminator\n  \n        KJ_REQUIRE(cptr[size] == '\\0', \"Message contains text that is not NUL-terminated.\") {\n          goto useDefault;\n        }\n  \n        return Text::Reader(cptr, size);\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "2084-2088",
    "snippet": "static KJ_ALWAYS_INLINE(Text::Reader readTextPointer(\n      SegmentReader* segment, const WirePointer* ref,\n      const void* defaultValue, ByteCount defaultSize)) {\n    return readTextPointer(segment, ref, ref->target(), defaultValue, defaultSize);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readTextPointer",
          "args": [
            "segment",
            "ref",
            "ref->target()",
            "defaultValue",
            "defaultSize"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(Text::Reader readTextPointer(\n        SegmentReader* segment, const WirePointer* ref,\n        const void* defaultValue, ByteCount defaultSize)) {\n      return readTextPointer(segment, ref, ref->target(), defaultValue, defaultSize);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1900-2082",
    "snippet": "static KJ_ALWAYS_INLINE(ListReader readListPointer(\n      SegmentReader* segment, const WirePointer* ref, const word* refTarget,\n      const word* defaultValue, ElementSize expectedElementSize, int nestingLimit,\n      bool checkElementSize = true)) {\n    if (ref->isNull()) {\n    useDefault:\n      if (defaultValue == nullptr ||\n          reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n        return ListReader();\n      }\n      segment = nullptr;\n      ref = reinterpret_cast<const WirePointer*>(defaultValue);\n      refTarget = ref->target();\n      defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n    }\n\n    KJ_REQUIRE(nestingLimit > 0,\n               \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n      goto useDefault;\n    }\n\n    const word* ptr = followFars(ref, refTarget, segment);\n    if (KJ_UNLIKELY(ptr == nullptr)) {\n      // Already reported error.\n      goto useDefault;\n    }\n\n    KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n               \"Message contains non-list pointer where list pointer was expected.\") {\n      goto useDefault;\n    }\n\n    ElementSize elementSize = ref->listRef.elementSize();\n    if (elementSize == ElementSize::INLINE_COMPOSITE) {\n#if _MSC_VER\n      // TODO(msvc): MSVC thinks decltype(WORDS/ELEMENTS) is a const type. /eyeroll\n      uint wordsPerElement;\n#else\n      decltype(WORDS/ELEMENTS) wordsPerElement;\n#endif\n      ElementCount size;\n\n      WordCount wordCount = ref->listRef.inlineCompositeWordCount();\n\n      // An INLINE_COMPOSITE list points to a tag, which is formatted like a pointer.\n      const WirePointer* tag = reinterpret_cast<const WirePointer*>(ptr);\n      ptr += POINTER_SIZE_IN_WORDS;\n\n      KJ_REQUIRE(boundsCheck(segment, ptr - POINTER_SIZE_IN_WORDS, ptr + wordCount),\n                 \"Message contains out-of-bounds list pointer.\") {\n        goto useDefault;\n      }\n\n      KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n                 \"INLINE_COMPOSITE lists of non-STRUCT type are not supported.\") {\n        goto useDefault;\n      }\n\n      size = tag->inlineCompositeListElementCount();\n      wordsPerElement = tag->structRef.wordSize() / ELEMENTS;\n\n      KJ_REQUIRE(ElementCount64(size) * wordsPerElement <= wordCount,\n                 \"INLINE_COMPOSITE list's elements overrun its word count.\") {\n        goto useDefault;\n      }\n\n      if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {\n        // Watch out for lists of zero-sized structs, which can claim to be arbitrarily large\n        // without having sent actual data.\n        KJ_REQUIRE(amplifiedRead(segment, size * (1 * WORDS / ELEMENTS)),\n                   \"Message contains amplified list pointer.\") {\n          goto useDefault;\n        }\n      }\n\n      if (checkElementSize) {\n        // If a struct list was not expected, then presumably a non-struct list was upgraded to a\n        // struct list.  We need to manipulate the pointer to point at the first field of the\n        // struct.  Together with the \"stepBits\", this will allow the struct list to be accessed as\n        // if it were a primitive list without branching.\n\n        // Check whether the size is compatible.\n        switch (expectedElementSize) {\n          case ElementSize::VOID:\n            break;\n\n          case ElementSize::BIT:\n            KJ_FAIL_REQUIRE(\n                \"Found struct list where bit list was expected; upgrading boolean lists to structs \"\n                \"is no longer supported.\") {\n              goto useDefault;\n            }\n            break;\n\n          case ElementSize::BYTE:\n          case ElementSize::TWO_BYTES:\n          case ElementSize::FOUR_BYTES:\n          case ElementSize::EIGHT_BYTES:\n            KJ_REQUIRE(tag->structRef.dataSize.get() > 0 * WORDS,\n                       \"Expected a primitive list, but got a list of pointer-only structs.\") {\n              goto useDefault;\n            }\n            break;\n\n          case ElementSize::POINTER:\n            // We expected a list of pointers but got a list of structs.  Assuming the first field\n            // in the struct is the pointer we were looking for, we want to munge the pointer to\n            // point at the first element's pointer section.\n            ptr += tag->structRef.dataSize.get();\n            KJ_REQUIRE(tag->structRef.ptrCount.get() > 0 * POINTERS,\n                       \"Expected a pointer list, but got a list of data-only structs.\") {\n              goto useDefault;\n            }\n            break;\n\n          case ElementSize::INLINE_COMPOSITE:\n            break;\n        }\n      }\n\n      return ListReader(\n          segment, ptr, size, wordsPerElement * BITS_PER_WORD,\n          tag->structRef.dataSize.get() * BITS_PER_WORD,\n          tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE,\n          nestingLimit - 1);\n\n    } else {\n      // This is a primitive or pointer list, but all such lists can also be interpreted as struct\n      // lists.  We need to compute the data size and pointer count for such structs.\n      BitCount dataSize = dataBitsPerElement(ref->listRef.elementSize()) * ELEMENTS;\n      WirePointerCount pointerCount =\n          pointersPerElement(ref->listRef.elementSize()) * ELEMENTS;\n      ElementCount elementCount = ref->listRef.elementCount();\n      auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n\n      WordCount wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n      KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount),\n                 \"Message contains out-of-bounds list pointer.\") {\n        goto useDefault;\n      }\n\n      if (elementSize == ElementSize::VOID) {\n        // Watch out for lists of void, which can claim to be arbitrarily large without having sent\n        // actual data.\n        KJ_REQUIRE(amplifiedRead(segment, elementCount * (1 * WORDS / ELEMENTS)),\n                   \"Message contains amplified list pointer.\") {\n          goto useDefault;\n        }\n      }\n\n      if (checkElementSize) {\n        if (elementSize == ElementSize::BIT && expectedElementSize != ElementSize::BIT) {\n          KJ_FAIL_REQUIRE(\n              \"Found bit list where struct list was expected; upgrading boolean lists to structs \"\n              \"is no longer supported.\") {\n            goto useDefault;\n          }\n        }\n\n        // Verify that the elements are at least as large as the expected type.  Note that if we\n        // expected INLINE_COMPOSITE, the expected sizes here will be zero, because bounds checking\n        // will be performed at field access time.  So this check here is for the case where we\n        // expected a list of some primitive or pointer type.\n\n        BitCount expectedDataBitsPerElement =\n            dataBitsPerElement(expectedElementSize) * ELEMENTS;\n        WirePointerCount expectedPointersPerElement =\n            pointersPerElement(expectedElementSize) * ELEMENTS;\n\n        KJ_REQUIRE(expectedDataBitsPerElement <= dataSize,\n                   \"Message contained list with incompatible element type.\") {\n          goto useDefault;\n        }\n        KJ_REQUIRE(expectedPointersPerElement <= pointerCount,\n                   \"Message contained list with incompatible element type.\") {\n          goto useDefault;\n        }\n      }\n\n      return ListReader(segment, ptr, elementCount, step,\n                        dataSize, pointerCount, elementSize, nestingLimit - 1);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListReader",
          "args": [
            "segment",
            "ptr",
            "elementCount",
            "step",
            "dataSize",
            "pointerCount",
            "elementSize",
            "nestingLimit - 1"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "ListReader",
          "container": "ListReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "690-697",
          "snippet": "inline ListReader(SegmentReader* segment, const void* ptr,\n                    ElementCount elementCount, decltype(BITS / ELEMENTS) step,\n                    BitCount structDataSize, WirePointerCount structPointerCount,\n                    ElementSize elementSize, int nestingLimit)\n      : segment(segment), ptr(reinterpret_cast<const byte*>(ptr)), elementCount(elementCount),\n        step(step), structDataSize(structDataSize),\n        structPointerCount(structPointerCount), elementSize(elementSize),\n        nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListReader {\n  inline ListReader(SegmentReader* segment, const void* ptr,\n                      ElementCount elementCount, decltype(BITS / ELEMENTS) step,\n                      BitCount structDataSize, WirePointerCount structPointerCount,\n                      ElementSize elementSize, int nestingLimit)\n        : segment(segment), ptr(reinterpret_cast<const byte*>(ptr)), elementCount(elementCount),\n          step(step), structDataSize(structDataSize),\n          structPointerCount(structPointerCount), elementSize(elementSize),\n          nestingLimit(nestingLimit) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "expectedPointersPerElement <= pointerCount",
            "\"Message contained list with incompatible element type.\""
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "expectedDataBitsPerElement <= dataSize",
            "\"Message contained list with incompatible element type.\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointersPerElement",
          "args": [
            "expectedElementSize"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "pointersPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "103-105",
          "snippet": "inline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dataBitsPerElement",
          "args": [
            "expectedElementSize"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "dataBitsPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "99-101",
          "snippet": "inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Found bit list where struct list was expected; upgrading boolean lists to structs \"\n              \"is no longer supported.\""
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "amplifiedRead(segment, elementCount * (1 * WORDS / ELEMENTS))",
            "\"Message contains amplified list pointer.\""
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amplifiedRead",
          "args": [
            "segment",
            "elementCount * (1 * WORDS / ELEMENTS)"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr + wordCount)",
            "\"Message contains out-of-bounds list pointer.\""
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr + wordCount"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToWords",
          "args": [
            "ElementCount64(elementCount) * step"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "elementCount"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->structRef.ptrCount.get",
          "args": [],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tag->structRef.ptrCount.get() > 0 * POINTERS",
            "\"Expected a pointer list, but got a list of data-only structs.\""
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tag->structRef.dataSize.get() > 0 * WORDS",
            "\"Expected a primitive list, but got a list of pointer-only structs.\""
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Found struct list where bit list was expected; upgrading boolean lists to structs \"\n                \"is no longer supported.\""
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "amplifiedRead(segment, size * (1 * WORDS / ELEMENTS))",
            "\"Message contains amplified list pointer.\""
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amplifiedRead",
          "args": [
            "segment",
            "size * (1 * WORDS / ELEMENTS)"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ElementCount64(size) * wordsPerElement <= wordCount",
            "\"INLINE_COMPOSITE list's elements overrun its word count.\""
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "size"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->structRef.wordSize",
          "args": [],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "wordSize",
          "container": "WirePointer::StructRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "185-187",
          "snippet": "inline WordCount wordSize() const {\n      return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n    }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    inline WordCount wordSize() const {\n          return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag->inlineCompositeListElementCount",
          "args": [],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tag->kind() == WirePointer::STRUCT",
            "\"INLINE_COMPOSITE lists of non-STRUCT type are not supported.\""
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->kind",
          "args": [],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr - POINTER_SIZE_IN_WORDS, ptr + wordCount)",
            "\"Message contains out-of-bounds list pointer.\""
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr - POINTER_SIZE_IN_WORDS",
            "ptr + wordCount"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.inlineCompositeWordCount",
          "args": [],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::LIST",
            "\"Message contains non-list pointer where list pointer was expected.\""
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "ptr == nullptr"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "refTarget",
            "segment"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "nestingLimit > 0",
            "\"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListReader",
          "args": [],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "getElementSize",
          "container": "ListReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "653-653",
          "snippet": "inline ElementSize getElementSize() const { return elementSize; }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListReader {\n  inline ElementSize getElementSize() const { return elementSize; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListReader readListPointer(\n        SegmentReader* segment, const WirePointer* ref, const word* refTarget,\n        const word* defaultValue, ElementSize expectedElementSize, int nestingLimit,\n        bool checkElementSize = true)) {\n      if (ref->isNull()) {\n      useDefault:\n        if (defaultValue == nullptr ||\n            reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n          return ListReader();\n        }\n        segment = nullptr;\n        ref = reinterpret_cast<const WirePointer*>(defaultValue);\n        refTarget = ref->target();\n        defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n      }\n  \n      KJ_REQUIRE(nestingLimit > 0,\n                 \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n        goto useDefault;\n      }\n  \n      const word* ptr = followFars(ref, refTarget, segment);\n      if (KJ_UNLIKELY(ptr == nullptr)) {\n        // Already reported error.\n        goto useDefault;\n      }\n  \n      KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n                 \"Message contains non-list pointer where list pointer was expected.\") {\n        goto useDefault;\n      }\n  \n      ElementSize elementSize = ref->listRef.elementSize();\n      if (elementSize == ElementSize::INLINE_COMPOSITE) {\n  #if _MSC_VER\n        // TODO(msvc): MSVC thinks decltype(WORDS/ELEMENTS) is a const type. /eyeroll\n        uint wordsPerElement;\n  #else\n        decltype(WORDS/ELEMENTS) wordsPerElement;\n  #endif\n        ElementCount size;\n  \n        WordCount wordCount = ref->listRef.inlineCompositeWordCount();\n  \n        // An INLINE_COMPOSITE list points to a tag, which is formatted like a pointer.\n        const WirePointer* tag = reinterpret_cast<const WirePointer*>(ptr);\n        ptr += POINTER_SIZE_IN_WORDS;\n  \n        KJ_REQUIRE(boundsCheck(segment, ptr - POINTER_SIZE_IN_WORDS, ptr + wordCount),\n                   \"Message contains out-of-bounds list pointer.\") {\n          goto useDefault;\n        }\n  \n        KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n                   \"INLINE_COMPOSITE lists of non-STRUCT type are not supported.\") {\n          goto useDefault;\n        }\n  \n        size = tag->inlineCompositeListElementCount();\n        wordsPerElement = tag->structRef.wordSize() / ELEMENTS;\n  \n        KJ_REQUIRE(ElementCount64(size) * wordsPerElement <= wordCount,\n                   \"INLINE_COMPOSITE list's elements overrun its word count.\") {\n          goto useDefault;\n        }\n  \n        if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {\n          // Watch out for lists of zero-sized structs, which can claim to be arbitrarily large\n          // without having sent actual data.\n          KJ_REQUIRE(amplifiedRead(segment, size * (1 * WORDS / ELEMENTS)),\n                     \"Message contains amplified list pointer.\") {\n            goto useDefault;\n          }\n        }\n  \n        if (checkElementSize) {\n          // If a struct list was not expected, then presumably a non-struct list was upgraded to a\n          // struct list.  We need to manipulate the pointer to point at the first field of the\n          // struct.  Together with the \"stepBits\", this will allow the struct list to be accessed as\n          // if it were a primitive list without branching.\n  \n          // Check whether the size is compatible.\n          switch (expectedElementSize) {\n            case ElementSize::VOID:\n              break;\n  \n            case ElementSize::BIT:\n              KJ_FAIL_REQUIRE(\n                  \"Found struct list where bit list was expected; upgrading boolean lists to structs \"\n                  \"is no longer supported.\") {\n                goto useDefault;\n              }\n              break;\n  \n            case ElementSize::BYTE:\n            case ElementSize::TWO_BYTES:\n            case ElementSize::FOUR_BYTES:\n            case ElementSize::EIGHT_BYTES:\n              KJ_REQUIRE(tag->structRef.dataSize.get() > 0 * WORDS,\n                         \"Expected a primitive list, but got a list of pointer-only structs.\") {\n                goto useDefault;\n              }\n              break;\n  \n            case ElementSize::POINTER:\n              // We expected a list of pointers but got a list of structs.  Assuming the first field\n              // in the struct is the pointer we were looking for, we want to munge the pointer to\n              // point at the first element's pointer section.\n              ptr += tag->structRef.dataSize.get();\n              KJ_REQUIRE(tag->structRef.ptrCount.get() > 0 * POINTERS,\n                         \"Expected a pointer list, but got a list of data-only structs.\") {\n                goto useDefault;\n              }\n              break;\n  \n            case ElementSize::INLINE_COMPOSITE:\n              break;\n          }\n        }\n  \n        return ListReader(\n            segment, ptr, size, wordsPerElement * BITS_PER_WORD,\n            tag->structRef.dataSize.get() * BITS_PER_WORD,\n            tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE,\n            nestingLimit - 1);\n  \n      } else {\n        // This is a primitive or pointer list, but all such lists can also be interpreted as struct\n        // lists.  We need to compute the data size and pointer count for such structs.\n        BitCount dataSize = dataBitsPerElement(ref->listRef.elementSize()) * ELEMENTS;\n        WirePointerCount pointerCount =\n            pointersPerElement(ref->listRef.elementSize()) * ELEMENTS;\n        ElementCount elementCount = ref->listRef.elementCount();\n        auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n  \n        WordCount wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n        KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount),\n                   \"Message contains out-of-bounds list pointer.\") {\n          goto useDefault;\n        }\n  \n        if (elementSize == ElementSize::VOID) {\n          // Watch out for lists of void, which can claim to be arbitrarily large without having sent\n          // actual data.\n          KJ_REQUIRE(amplifiedRead(segment, elementCount * (1 * WORDS / ELEMENTS)),\n                     \"Message contains amplified list pointer.\") {\n            goto useDefault;\n          }\n        }\n  \n        if (checkElementSize) {\n          if (elementSize == ElementSize::BIT && expectedElementSize != ElementSize::BIT) {\n            KJ_FAIL_REQUIRE(\n                \"Found bit list where struct list was expected; upgrading boolean lists to structs \"\n                \"is no longer supported.\") {\n              goto useDefault;\n            }\n          }\n  \n          // Verify that the elements are at least as large as the expected type.  Note that if we\n          // expected INLINE_COMPOSITE, the expected sizes here will be zero, because bounds checking\n          // will be performed at field access time.  So this check here is for the case where we\n          // expected a list of some primitive or pointer type.\n  \n          BitCount expectedDataBitsPerElement =\n              dataBitsPerElement(expectedElementSize) * ELEMENTS;\n          WirePointerCount expectedPointersPerElement =\n              pointersPerElement(expectedElementSize) * ELEMENTS;\n  \n          KJ_REQUIRE(expectedDataBitsPerElement <= dataSize,\n                     \"Message contained list with incompatible element type.\") {\n            goto useDefault;\n          }\n          KJ_REQUIRE(expectedPointersPerElement <= pointerCount,\n                     \"Message contained list with incompatible element type.\") {\n            goto useDefault;\n          }\n        }\n  \n        return ListReader(segment, ptr, elementCount, step,\n                          dataSize, pointerCount, elementSize, nestingLimit - 1);\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1893-1898",
    "snippet": "static KJ_ALWAYS_INLINE(ListReader readListPointer(\n      SegmentReader* segment, const WirePointer* ref, const word* defaultValue,\n      ElementSize expectedElementSize, int nestingLimit, bool checkElementSize = true)) {\n    return readListPointer(segment, ref, ref->target(), defaultValue,\n                           expectedElementSize, nestingLimit, checkElementSize);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readListPointer",
          "args": [
            "segment",
            "ref",
            "ref->target()",
            "defaultValue",
            "expectedElementSize",
            "nestingLimit",
            "checkElementSize"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListReader readListPointer(\n        SegmentReader* segment, const WirePointer* ref, const word* defaultValue,\n        ElementSize expectedElementSize, int nestingLimit, bool checkElementSize = true)) {\n      return readListPointer(segment, ref, ref->target(), defaultValue,\n                             expectedElementSize, nestingLimit, checkElementSize);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1864-1887",
    "snippet": "static KJ_ALWAYS_INLINE(kj::Own<ClientHook> readCapabilityPointer(\n      SegmentReader* segment, const WirePointer* ref, int nestingLimit)) {\n    kj::Maybe<kj::Own<ClientHook>> maybeCap;\n\n    KJ_REQUIRE(brokenCapFactory != nullptr,\n               \"Trying to read capabilities without ever having created a capability context.  \"\n               \"To read capabilities from a message, you must imbue it with CapReaderContext, or \"\n               \"use the Cap'n Proto RPC system.\");\n\n    if (ref->isNull()) {\n      return brokenCapFactory->newBrokenCap(\"Calling null capability pointer.\");\n    } else if (!ref->isCapability()) {\n      KJ_FAIL_REQUIRE(\n          \"Message contains non-capability pointer where capability pointer was expected.\") {\n        break;\n      }\n      return brokenCapFactory->newBrokenCap(\n          \"Calling capability extracted from a non-capability pointer.\");\n    } else KJ_IF_MAYBE(cap, segment->getArena()->extractCap(ref->capRef.index.get())) {\n      return kj::mv(*cap);\n    } else {\n      KJ_FAIL_REQUIRE(\"Message contains invalid capability pointer.\") {\n        break;\n      }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Message contains invalid capability pointer.\""
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*cap"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "cap",
            "segment->getArena()->extractCap(ref->capRef.index.get())"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "ref->capRef.index.get()"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->capRef.index.get",
          "args": [],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brokenCapFactory->newBrokenCap",
          "args": [
            "\"Calling capability extracted from a non-capability pointer.\""
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Message contains non-capability pointer where capability pointer was expected.\""
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isCapability",
          "args": [],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "brokenCapFactory != nullptr",
            "\"Trying to read capabilities without ever having created a capability context.  \"\n               \"To read capabilities from a message, you must imbue it with CapReaderContext, or \"\n               \"use the Cap'n Proto RPC system.\""
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(kj::Own<ClientHook> readCapabilityPointer(\n        SegmentReader* segment, const WirePointer* ref, int nestingLimit)) {\n      kj::Maybe<kj::Own<ClientHook>> maybeCap;\n  \n      KJ_REQUIRE(brokenCapFactory != nullptr,\n                 \"Trying to read capabilities without ever having created a capability context.  \"\n                 \"To read capabilities from a message, you must imbue it with CapReaderContext, or \"\n                 \"use the Cap'n Proto RPC system.\");\n  \n      if (ref->isNull()) {\n        return brokenCapFactory->newBrokenCap(\"Calling null capability pointer.\");\n      } else if (!ref->isCapability()) {\n        KJ_FAIL_REQUIRE(\n            \"Message contains non-capability pointer where capability pointer was expected.\") {\n          break;\n        }\n        return brokenCapFactory->newBrokenCap(\n            \"Calling capability extracted from a non-capability pointer.\");\n      } else KJ_IF_MAYBE(cap, segment->getArena()->extractCap(ref->capRef.index.get())) {\n        return kj::mv(*cap);\n      } else {\n        KJ_FAIL_REQUIRE(\"Message contains invalid capability pointer.\") {\n          break;\n        }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1820-1861",
    "snippet": "static KJ_ALWAYS_INLINE(StructReader readStructPointer(\n      SegmentReader* segment, const WirePointer* ref, const word* refTarget,\n      const word* defaultValue, int nestingLimit)) {\n    if (ref->isNull()) {\n    useDefault:\n      if (defaultValue == nullptr ||\n          reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n        return StructReader();\n      }\n      segment = nullptr;\n      ref = reinterpret_cast<const WirePointer*>(defaultValue);\n      refTarget = ref->target();\n      defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n    }\n\n    KJ_REQUIRE(nestingLimit > 0,\n               \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n      goto useDefault;\n    }\n\n    const word* ptr = followFars(ref, refTarget, segment);\n    if (KJ_UNLIKELY(ptr == nullptr)) {\n      // Already reported the error.\n      goto useDefault;\n    }\n\n    KJ_REQUIRE(ref->kind() == WirePointer::STRUCT,\n               \"Message contains non-struct pointer where struct pointer was expected.\") {\n      goto useDefault;\n    }\n\n    KJ_REQUIRE(boundsCheck(segment, ptr, ptr + ref->structRef.wordSize()),\n               \"Message contained out-of-bounds struct pointer.\") {\n      goto useDefault;\n    }\n\n    return StructReader(\n        segment, ptr, reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get()),\n        ref->structRef.dataSize.get() * BITS_PER_WORD,\n        ref->structRef.ptrCount.get(),\n        nestingLimit - 1);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructReader",
          "args": [
            "segment",
            "ptr",
            "reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get())",
            "ref->structRef.dataSize.get() * BITS_PER_WORD",
            "ref->structRef.ptrCount.get()",
            "nestingLimit - 1"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "StructReader",
          "container": "StructReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "539-543",
          "snippet": "inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,\n                      BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)\n      : segment(segment), data(data), pointers(pointers),\n        dataSize(dataSize), pointerCount(pointerCount),\n        nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructReader {\n  inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,\n                        BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)\n        : segment(segment), data(data), pointers(pointers),\n          dataSize(dataSize), pointerCount(pointerCount),\n          nestingLimit(nestingLimit) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->structRef.ptrCount.get",
          "args": [],
          "line": 1859
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "ptr + ref->structRef.dataSize.get()"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr + ref->structRef.wordSize())",
            "\"Message contained out-of-bounds struct pointer.\""
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr + ref->structRef.wordSize()"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->structRef.wordSize",
          "args": [],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "wordSize",
          "container": "WirePointer::StructRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "185-187",
          "snippet": "inline WordCount wordSize() const {\n      return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n    }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    inline WordCount wordSize() const {\n          return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::STRUCT",
            "\"Message contains non-struct pointer where struct pointer was expected.\""
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "ptr == nullptr"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "refTarget",
            "segment"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "nestingLimit > 0",
            "\"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\""
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StructReader",
          "args": [],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "getPointerSectionSize",
          "container": "StructReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "491-491",
          "snippet": "inline WirePointerCount getPointerSectionSize() const { return pointerCount; }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructReader {\n  inline WirePointerCount getPointerSectionSize() const { return pointerCount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(StructReader readStructPointer(\n        SegmentReader* segment, const WirePointer* ref, const word* refTarget,\n        const word* defaultValue, int nestingLimit)) {\n      if (ref->isNull()) {\n      useDefault:\n        if (defaultValue == nullptr ||\n            reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n          return StructReader();\n        }\n        segment = nullptr;\n        ref = reinterpret_cast<const WirePointer*>(defaultValue);\n        refTarget = ref->target();\n        defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n      }\n  \n      KJ_REQUIRE(nestingLimit > 0,\n                 \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n        goto useDefault;\n      }\n  \n      const word* ptr = followFars(ref, refTarget, segment);\n      if (KJ_UNLIKELY(ptr == nullptr)) {\n        // Already reported the error.\n        goto useDefault;\n      }\n  \n      KJ_REQUIRE(ref->kind() == WirePointer::STRUCT,\n                 \"Message contains non-struct pointer where struct pointer was expected.\") {\n        goto useDefault;\n      }\n  \n      KJ_REQUIRE(boundsCheck(segment, ptr, ptr + ref->structRef.wordSize()),\n                 \"Message contained out-of-bounds struct pointer.\") {\n        goto useDefault;\n      }\n  \n      return StructReader(\n          segment, ptr, reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get()),\n          ref->structRef.dataSize.get() * BITS_PER_WORD,\n          ref->structRef.ptrCount.get(),\n          nestingLimit - 1);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1814-1818",
    "snippet": "static KJ_ALWAYS_INLINE(StructReader readStructPointer(\n      SegmentReader* segment, const WirePointer* ref, const word* defaultValue,\n      int nestingLimit)) {\n    return readStructPointer(segment, ref, ref->target(), defaultValue, nestingLimit);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readStructPointer",
          "args": [
            "segment",
            "ref",
            "ref->target()",
            "defaultValue",
            "nestingLimit"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(StructReader readStructPointer(\n        SegmentReader* segment, const WirePointer* ref, const word* defaultValue,\n        int nestingLimit)) {\n      return readStructPointer(segment, ref, ref->target(), defaultValue, nestingLimit);\n    }\n}"
  },
  {
    "function_name": "disown",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1787-1810",
    "snippet": "static OrphanBuilder disown(SegmentBuilder* segment, WirePointer* ref) {\n    word* location;\n\n    if (ref->isNull()) {\n      location = nullptr;\n    } else if (ref->kind() == WirePointer::OTHER) {\n      KJ_REQUIRE(ref->isCapability(), \"Unknown pointer type.\") { break; }\n      location = reinterpret_cast<word*>(ref);  // dummy so that it is non-null\n    } else {\n      WirePointer* refCopy = ref;\n      location = followFarsNoWritableCheck(refCopy, ref->target(), segment);\n    }\n\n    OrphanBuilder result(ref, segment, location);\n\n    if (!ref->isNull() && ref->isPositional()) {\n      result.tagAsPtr()->setKindForOrphan(ref->kind());\n    }\n\n    // Zero out the pointer that was disowned.\n    memset(ref, 0, sizeof(*ref));\n\n    return result;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ref",
            "0",
            "sizeof(*ref)"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [
            "ref->kind()"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.tagAsPtr",
          "args": [],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isPositional",
          "args": [],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFarsNoWritableCheck",
          "args": [
            "refCopy",
            "ref->target()",
            "segment"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "ref"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->isCapability()",
            "\"Unknown pointer type.\""
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isCapability",
          "args": [],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static OrphanBuilder disown(SegmentBuilder* segment, WirePointer* ref) {\n      word* location;\n  \n      if (ref->isNull()) {\n        location = nullptr;\n      } else if (ref->kind() == WirePointer::OTHER) {\n        KJ_REQUIRE(ref->isCapability(), \"Unknown pointer type.\") { break; }\n        location = reinterpret_cast<word*>(ref);  // dummy so that it is non-null\n      } else {\n        WirePointer* refCopy = ref;\n        location = followFarsNoWritableCheck(refCopy, ref->target(), segment);\n      }\n  \n      OrphanBuilder result(ref, segment, location);\n  \n      if (!ref->isNull() && ref->isPositional()) {\n        result.tagAsPtr()->setKindForOrphan(ref->kind());\n      }\n  \n      // Zero out the pointer that was disowned.\n      memset(ref, 0, sizeof(*ref));\n  \n      return result;\n    }\n}"
  },
  {
    "function_name": "adopt",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1763-1785",
    "snippet": "static void adopt(SegmentBuilder* segment, WirePointer* ref, OrphanBuilder&& value) {\n    KJ_REQUIRE(value.segment == nullptr || value.segment->getArena() == segment->getArena(),\n               \"Adopted object must live in the same message.\");\n\n    if (!ref->isNull()) {\n      zeroObject(segment, ref);\n    }\n\n    if (value == nullptr) {\n      // Set null.\n      memset(ref, 0, sizeof(*ref));\n    } else if (value.tagAsPtr()->isPositional()) {\n      WireHelpers::transferPointer(segment, ref, value.segment, value.tagAsPtr(), value.location);\n    } else {\n      // FAR and OTHER pointers are position-independent, so we can just copy.\n      memcpy(ref, value.tagAsPtr(), sizeof(WirePointer));\n    }\n\n    // Take ownership away from the OrphanBuilder.\n    memset(value.tagAsPtr(), 0, sizeof(WirePointer));\n    value.location = nullptr;\n    value.segment = nullptr;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value.tagAsPtr()",
            "0",
            "sizeof(WirePointer)"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.tagAsPtr",
          "args": [],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ref",
            "value.tagAsPtr()",
            "sizeof(WirePointer)"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.tagAsPtr",
          "args": [],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::transferPointer",
          "args": [
            "segment",
            "ref",
            "value.segment",
            "value.tagAsPtr()",
            "value.location"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "transferPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "879-920",
          "snippet": "static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                              SegmentBuilder* srcSegment, const WirePointer* srcTag,\n                              word* srcPtr) {\n    // Like the other overload, but splits src into a tag and a target.  Particularly useful for\n    // OrphanBuilder.\n\n    if (dstSegment == srcSegment) {\n      // Same segment, so create a direct pointer.\n      dst->setKindAndTarget(srcTag->kind(), srcPtr, dstSegment);\n\n      // We can just copy the upper 32 bits.  (Use memcpy() to comply with aliasing rules.)\n      memcpy(&dst->upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n    } else {\n      // Need to create a far pointer.  Try to allocate it in the same segment as the source, so\n      // that it doesn't need to be a double-far.\n\n      WirePointer* landingPad =\n          reinterpret_cast<WirePointer*>(srcSegment->allocate(1 * WORDS));\n      if (landingPad == nullptr) {\n        // Darn, need a double-far.\n        auto allocation = srcSegment->getArena()->allocate(2 * WORDS);\n        SegmentBuilder* farSegment = allocation.segment;\n        landingPad = reinterpret_cast<WirePointer*>(allocation.words);\n\n        landingPad[0].setFar(false, srcSegment->getOffsetTo(srcPtr));\n        landingPad[0].farRef.segmentId.set(srcSegment->getSegmentId());\n\n        landingPad[1].setKindWithZeroOffset(srcTag->kind());\n        memcpy(&landingPad[1].upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n\n        dst->setFar(true, farSegment->getOffsetTo(reinterpret_cast<word*>(landingPad)));\n        dst->farRef.set(farSegment->getSegmentId());\n      } else {\n        // Simple landing pad is just a pointer.\n        landingPad->setKindAndTarget(srcTag->kind(), srcPtr, srcSegment);\n        memcpy(&landingPad->upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n\n        dst->setFar(false, srcSegment->getOffsetTo(reinterpret_cast<word*>(landingPad)));\n        dst->farRef.set(srcSegment->getSegmentId());\n      }\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                                SegmentBuilder* srcSegment, const WirePointer* srcTag,\n                                word* srcPtr) {\n      // Like the other overload, but splits src into a tag and a target.  Particularly useful for\n      // OrphanBuilder.\n  \n      if (dstSegment == srcSegment) {\n        // Same segment, so create a direct pointer.\n        dst->setKindAndTarget(srcTag->kind(), srcPtr, dstSegment);\n  \n        // We can just copy the upper 32 bits.  (Use memcpy() to comply with aliasing rules.)\n        memcpy(&dst->upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n      } else {\n        // Need to create a far pointer.  Try to allocate it in the same segment as the source, so\n        // that it doesn't need to be a double-far.\n  \n        WirePointer* landingPad =\n            reinterpret_cast<WirePointer*>(srcSegment->allocate(1 * WORDS));\n        if (landingPad == nullptr) {\n          // Darn, need a double-far.\n          auto allocation = srcSegment->getArena()->allocate(2 * WORDS);\n          SegmentBuilder* farSegment = allocation.segment;\n          landingPad = reinterpret_cast<WirePointer*>(allocation.words);\n  \n          landingPad[0].setFar(false, srcSegment->getOffsetTo(srcPtr));\n          landingPad[0].farRef.segmentId.set(srcSegment->getSegmentId());\n  \n          landingPad[1].setKindWithZeroOffset(srcTag->kind());\n          memcpy(&landingPad[1].upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n  \n          dst->setFar(true, farSegment->getOffsetTo(reinterpret_cast<word*>(landingPad)));\n          dst->farRef.set(farSegment->getSegmentId());\n        } else {\n          // Simple landing pad is just a pointer.\n          landingPad->setKindAndTarget(srcTag->kind(), srcPtr, srcSegment);\n          memcpy(&landingPad->upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n  \n          dst->setFar(false, srcSegment->getOffsetTo(reinterpret_cast<word*>(landingPad)));\n          dst->farRef.set(srcSegment->getSegmentId());\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.tagAsPtr",
          "args": [],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.tagAsPtr",
          "args": [],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.tagAsPtr",
          "args": [],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ref",
            "0",
            "sizeof(*ref)"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zeroObject",
          "args": [
            "segment",
            "ref"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "value.segment == nullptr || value.segment->getArena() == segment->getArena()",
            "\"Adopted object must live in the same message.\""
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.segment->getArena",
          "args": [],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void adopt(SegmentBuilder* segment, WirePointer* ref, OrphanBuilder&& value) {\n      KJ_REQUIRE(value.segment == nullptr || value.segment->getArena() == segment->getArena(),\n                 \"Adopted object must live in the same message.\");\n  \n      if (!ref->isNull()) {\n        zeroObject(segment, ref);\n      }\n  \n      if (value == nullptr) {\n        // Set null.\n        memset(ref, 0, sizeof(*ref));\n      } else if (value.tagAsPtr()->isPositional()) {\n        WireHelpers::transferPointer(segment, ref, value.segment, value.tagAsPtr(), value.location);\n      } else {\n        // FAR and OTHER pointers are position-independent, so we can just copy.\n        memcpy(ref, value.tagAsPtr(), sizeof(WirePointer));\n      }\n  \n      // Take ownership away from the OrphanBuilder.\n      memset(value.tagAsPtr(), 0, sizeof(WirePointer));\n      value.location = nullptr;\n      value.segment = nullptr;\n    }\n}"
  },
  {
    "function_name": "copyPointer",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1619-1761",
    "snippet": "static SegmentAnd<word*> copyPointer(\n      SegmentBuilder* dstSegment, WirePointer* dst,\n      SegmentReader* srcSegment, const WirePointer* src, const word* srcTarget,\n      int nestingLimit, BuilderArena* orphanArena = nullptr) {\n    // Deep-copy the object pointed to by src into dst.  It turns out we can't reuse\n    // readStructPointer(), etc. because they do type checking whereas here we want to accept any\n    // valid pointer.\n\n    if (src->isNull()) {\n    useDefault:\n      if (!dst->isNull()) {\n        zeroObject(dstSegment, dst);\n        memset(dst, 0, sizeof(*dst));\n      }\n      return { dstSegment, nullptr };\n    }\n\n    const word* ptr = WireHelpers::followFars(src, srcTarget, srcSegment);\n    if (KJ_UNLIKELY(ptr == nullptr)) {\n      // Already reported the error.\n      goto useDefault;\n    }\n\n    switch (src->kind()) {\n      case WirePointer::STRUCT:\n        KJ_REQUIRE(nestingLimit > 0,\n              \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n          goto useDefault;\n        }\n\n        KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + src->structRef.wordSize()),\n                   \"Message contained out-of-bounds struct pointer.\") {\n          goto useDefault;\n        }\n        return setStructPointer(dstSegment, dst,\n            StructReader(srcSegment, ptr,\n                         reinterpret_cast<const WirePointer*>(ptr + src->structRef.dataSize.get()),\n                         src->structRef.dataSize.get() * BITS_PER_WORD,\n                         src->structRef.ptrCount.get(),\n                         nestingLimit - 1),\n            orphanArena);\n\n      case WirePointer::LIST: {\n        ElementSize elementSize = src->listRef.elementSize();\n\n        KJ_REQUIRE(nestingLimit > 0,\n              \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n          goto useDefault;\n        }\n\n        if (elementSize == ElementSize::INLINE_COMPOSITE) {\n          WordCount wordCount = src->listRef.inlineCompositeWordCount();\n          const WirePointer* tag = reinterpret_cast<const WirePointer*>(ptr);\n          ptr += POINTER_SIZE_IN_WORDS;\n\n          KJ_REQUIRE(boundsCheck(srcSegment, ptr - POINTER_SIZE_IN_WORDS, ptr + wordCount),\n                     \"Message contains out-of-bounds list pointer.\") {\n            goto useDefault;\n          }\n\n          KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n                     \"INLINE_COMPOSITE lists of non-STRUCT type are not supported.\") {\n            goto useDefault;\n          }\n\n          ElementCount elementCount = tag->inlineCompositeListElementCount();\n          auto wordsPerElement = tag->structRef.wordSize() / ELEMENTS;\n\n          KJ_REQUIRE(wordsPerElement * ElementCount64(elementCount) <= wordCount,\n                     \"INLINE_COMPOSITE list's elements overrun its word count.\") {\n            goto useDefault;\n          }\n\n          if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {\n            // Watch out for lists of zero-sized structs, which can claim to be arbitrarily large\n            // without having sent actual data.\n            KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n                       \"Message contains amplified list pointer.\") {\n              goto useDefault;\n            }\n          }\n\n          return setListPointer(dstSegment, dst,\n              ListReader(srcSegment, ptr, elementCount, wordsPerElement * BITS_PER_WORD,\n                         tag->structRef.dataSize.get() * BITS_PER_WORD,\n                         tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE,\n                         nestingLimit - 1),\n              orphanArena);\n        } else {\n          BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;\n          WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;\n          auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n          ElementCount elementCount = src->listRef.elementCount();\n          WordCount64 wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n\n          KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + wordCount),\n                     \"Message contains out-of-bounds list pointer.\") {\n            goto useDefault;\n          }\n\n          if (elementSize == ElementSize::VOID) {\n            // Watch out for lists of void, which can claim to be arbitrarily large without having\n            // sent actual data.\n            KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n                       \"Message contains amplified list pointer.\") {\n              goto useDefault;\n            }\n          }\n\n          return setListPointer(dstSegment, dst,\n              ListReader(srcSegment, ptr, elementCount, step, dataSize, pointerCount, elementSize,\n                         nestingLimit - 1),\n              orphanArena);\n        }\n      }\n\n      case WirePointer::FAR:\n        KJ_FAIL_ASSERT(\"Far pointer should have been handled above.\") {\n          goto useDefault;\n        }\n\n      case WirePointer::OTHER: {\n        KJ_REQUIRE(src->isCapability(), \"Unknown pointer type.\") {\n          goto useDefault;\n        }\n\n#if !CAPNP_LITE\n        KJ_IF_MAYBE(cap, srcSegment->getArena()->extractCap(src->capRef.index.get())) {\n          setCapabilityPointer(dstSegment, dst, kj::mv(*cap), orphanArena);\n          return { dstSegment, nullptr };\n        } else {\n#endif  // !CAPNP_LITE\n          KJ_FAIL_REQUIRE(\"Message contained invalid capability pointer.\") {\n            goto useDefault;\n          }\n#if !CAPNP_LITE\n        }\n#endif  // !CAPNP_LITE\n      }\n    }\n\n    KJ_UNREACHABLE;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Message contained invalid capability pointer.\""
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setCapabilityPointer",
          "args": [
            "dstSegment",
            "dst",
            "kj::mv(*cap)",
            "orphanArena"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*cap"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "cap",
            "srcSegment->getArena()->extractCap(src->capRef.index.get())"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      },
      {
        "call_info": {
          "callee": "srcSegment->getArena",
          "args": [
            "src->capRef.index.get()"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->capRef.index.get",
          "args": [],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcSegment->getArena",
          "args": [],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "src->isCapability()",
            "\"Unknown pointer type.\""
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->isCapability",
          "args": [],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Far pointer should have been handled above.\""
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setListPointer",
          "args": [
            "dstSegment",
            "dst",
            "ListReader(srcSegment, ptr, elementCount, step, dataSize, pointerCount, elementSize,\n                         nestingLimit - 1)",
            "orphanArena"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListReader",
          "args": [
            "srcSegment",
            "ptr",
            "elementCount",
            "step",
            "dataSize",
            "pointerCount",
            "elementSize",
            "nestingLimit - 1"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "ListReader",
          "container": "ListReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "690-697",
          "snippet": "inline ListReader(SegmentReader* segment, const void* ptr,\n                    ElementCount elementCount, decltype(BITS / ELEMENTS) step,\n                    BitCount structDataSize, WirePointerCount structPointerCount,\n                    ElementSize elementSize, int nestingLimit)\n      : segment(segment), ptr(reinterpret_cast<const byte*>(ptr)), elementCount(elementCount),\n        step(step), structDataSize(structDataSize),\n        structPointerCount(structPointerCount), elementSize(elementSize),\n        nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListReader {\n  inline ListReader(SegmentReader* segment, const void* ptr,\n                      ElementCount elementCount, decltype(BITS / ELEMENTS) step,\n                      BitCount structDataSize, WirePointerCount structPointerCount,\n                      ElementSize elementSize, int nestingLimit)\n        : segment(segment), ptr(reinterpret_cast<const byte*>(ptr)), elementCount(elementCount),\n          step(step), structDataSize(structDataSize),\n          structPointerCount(structPointerCount), elementSize(elementSize),\n          nestingLimit(nestingLimit) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS))",
            "\"Message contains amplified list pointer.\""
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amplifiedRead",
          "args": [
            "srcSegment",
            "elementCount * (1 * WORDS / ELEMENTS)"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(srcSegment, ptr, ptr + wordCount)",
            "\"Message contains out-of-bounds list pointer.\""
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "srcSegment",
            "ptr",
            "ptr + wordCount"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToWords",
          "args": [
            "ElementCount64(elementCount) * step"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "elementCount"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->listRef.elementCount",
          "args": [],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointersPerElement",
          "args": [
            "elementSize"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "pointersPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "103-105",
          "snippet": "inline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dataBitsPerElement",
          "args": [
            "elementSize"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "dataBitsPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "99-101",
          "snippet": "inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "setListPointer",
          "args": [
            "dstSegment",
            "dst",
            "ListReader(srcSegment, ptr, elementCount, wordsPerElement * BITS_PER_WORD,\n                         tag->structRef.dataSize.get() * BITS_PER_WORD,\n                         tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE,\n                         nestingLimit - 1)",
            "orphanArena"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS))",
            "\"Message contains amplified list pointer.\""
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amplifiedRead",
          "args": [
            "srcSegment",
            "elementCount * (1 * WORDS / ELEMENTS)"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "wordsPerElement * ElementCount64(elementCount) <= wordCount",
            "\"INLINE_COMPOSITE list's elements overrun its word count.\""
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "elementCount"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->structRef.wordSize",
          "args": [],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "wordSize",
          "container": "WirePointer::StructRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "185-187",
          "snippet": "inline WordCount wordSize() const {\n      return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n    }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    inline WordCount wordSize() const {\n          return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag->inlineCompositeListElementCount",
          "args": [],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tag->kind() == WirePointer::STRUCT",
            "\"INLINE_COMPOSITE lists of non-STRUCT type are not supported.\""
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->kind",
          "args": [],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(srcSegment, ptr - POINTER_SIZE_IN_WORDS, ptr + wordCount)",
            "\"Message contains out-of-bounds list pointer.\""
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "srcSegment",
            "ptr - POINTER_SIZE_IN_WORDS",
            "ptr + wordCount"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->listRef.inlineCompositeWordCount",
          "args": [],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "nestingLimit > 0",
            "\"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\""
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->listRef.elementSize",
          "args": [],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setStructPointer",
          "args": [
            "dstSegment",
            "dst",
            "StructReader(srcSegment, ptr,\n                         reinterpret_cast<const WirePointer*>(ptr + src->structRef.dataSize.get()),\n                         src->structRef.dataSize.get() * BITS_PER_WORD,\n                         src->structRef.ptrCount.get(),\n                         nestingLimit - 1)",
            "orphanArena"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StructReader",
          "args": [
            "srcSegment",
            "ptr",
            "reinterpret_cast<const WirePointer*>(ptr + src->structRef.dataSize.get())",
            "src->structRef.dataSize.get() * BITS_PER_WORD",
            "src->structRef.ptrCount.get()",
            "nestingLimit - 1"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "StructReader",
          "container": "StructReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "539-543",
          "snippet": "inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,\n                      BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)\n      : segment(segment), data(data), pointers(pointers),\n        dataSize(dataSize), pointerCount(pointerCount),\n        nestingLimit(nestingLimit) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructReader {\n  inline StructReader(SegmentReader* segment, const void* data, const WirePointer* pointers,\n                        BitCount dataSize, WirePointerCount pointerCount, int nestingLimit)\n        : segment(segment), data(data), pointers(pointers),\n          dataSize(dataSize), pointerCount(pointerCount),\n          nestingLimit(nestingLimit) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "ptr + src->structRef.dataSize.get()"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(srcSegment, ptr, ptr + src->structRef.wordSize())",
            "\"Message contained out-of-bounds struct pointer.\""
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "srcSegment",
            "ptr",
            "ptr + src->structRef.wordSize()"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "nestingLimit > 0",
            "\"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\""
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_UNLIKELY",
          "args": [
            "ptr == nullptr"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WireHelpers::followFars",
          "args": [
            "src",
            "srcTarget",
            "srcSegment"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "0",
            "sizeof(*dst)"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zeroObject",
          "args": [
            "dstSegment",
            "dst"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dst->isNull",
          "args": [],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->isNull",
          "args": [],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static SegmentAnd<word*> copyPointer(\n        SegmentBuilder* dstSegment, WirePointer* dst,\n        SegmentReader* srcSegment, const WirePointer* src, const word* srcTarget,\n        int nestingLimit, BuilderArena* orphanArena = nullptr) {\n      // Deep-copy the object pointed to by src into dst.  It turns out we can't reuse\n      // readStructPointer(), etc. because they do type checking whereas here we want to accept any\n      // valid pointer.\n  \n      if (src->isNull()) {\n      useDefault:\n        if (!dst->isNull()) {\n          zeroObject(dstSegment, dst);\n          memset(dst, 0, sizeof(*dst));\n        }\n        return { dstSegment, nullptr };\n      }\n  \n      const word* ptr = WireHelpers::followFars(src, srcTarget, srcSegment);\n      if (KJ_UNLIKELY(ptr == nullptr)) {\n        // Already reported the error.\n        goto useDefault;\n      }\n  \n      switch (src->kind()) {\n        case WirePointer::STRUCT:\n          KJ_REQUIRE(nestingLimit > 0,\n                \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n            goto useDefault;\n          }\n  \n          KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + src->structRef.wordSize()),\n                     \"Message contained out-of-bounds struct pointer.\") {\n            goto useDefault;\n          }\n          return setStructPointer(dstSegment, dst,\n              StructReader(srcSegment, ptr,\n                           reinterpret_cast<const WirePointer*>(ptr + src->structRef.dataSize.get()),\n                           src->structRef.dataSize.get() * BITS_PER_WORD,\n                           src->structRef.ptrCount.get(),\n                           nestingLimit - 1),\n              orphanArena);\n  \n        case WirePointer::LIST: {\n          ElementSize elementSize = src->listRef.elementSize();\n  \n          KJ_REQUIRE(nestingLimit > 0,\n                \"Message is too deeply-nested or contains cycles.  See capnp::ReaderOptions.\") {\n            goto useDefault;\n          }\n  \n          if (elementSize == ElementSize::INLINE_COMPOSITE) {\n            WordCount wordCount = src->listRef.inlineCompositeWordCount();\n            const WirePointer* tag = reinterpret_cast<const WirePointer*>(ptr);\n            ptr += POINTER_SIZE_IN_WORDS;\n  \n            KJ_REQUIRE(boundsCheck(srcSegment, ptr - POINTER_SIZE_IN_WORDS, ptr + wordCount),\n                       \"Message contains out-of-bounds list pointer.\") {\n              goto useDefault;\n            }\n  \n            KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n                       \"INLINE_COMPOSITE lists of non-STRUCT type are not supported.\") {\n              goto useDefault;\n            }\n  \n            ElementCount elementCount = tag->inlineCompositeListElementCount();\n            auto wordsPerElement = tag->structRef.wordSize() / ELEMENTS;\n  \n            KJ_REQUIRE(wordsPerElement * ElementCount64(elementCount) <= wordCount,\n                       \"INLINE_COMPOSITE list's elements overrun its word count.\") {\n              goto useDefault;\n            }\n  \n            if (wordsPerElement * (1 * ELEMENTS) == 0 * WORDS) {\n              // Watch out for lists of zero-sized structs, which can claim to be arbitrarily large\n              // without having sent actual data.\n              KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n                         \"Message contains amplified list pointer.\") {\n                goto useDefault;\n              }\n            }\n  \n            return setListPointer(dstSegment, dst,\n                ListReader(srcSegment, ptr, elementCount, wordsPerElement * BITS_PER_WORD,\n                           tag->structRef.dataSize.get() * BITS_PER_WORD,\n                           tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE,\n                           nestingLimit - 1),\n                orphanArena);\n          } else {\n            BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;\n            WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;\n            auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n            ElementCount elementCount = src->listRef.elementCount();\n            WordCount64 wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n  \n            KJ_REQUIRE(boundsCheck(srcSegment, ptr, ptr + wordCount),\n                       \"Message contains out-of-bounds list pointer.\") {\n              goto useDefault;\n            }\n  \n            if (elementSize == ElementSize::VOID) {\n              // Watch out for lists of void, which can claim to be arbitrarily large without having\n              // sent actual data.\n              KJ_REQUIRE(amplifiedRead(srcSegment, elementCount * (1 * WORDS / ELEMENTS)),\n                         \"Message contains amplified list pointer.\") {\n                goto useDefault;\n              }\n            }\n  \n            return setListPointer(dstSegment, dst,\n                ListReader(srcSegment, ptr, elementCount, step, dataSize, pointerCount, elementSize,\n                           nestingLimit - 1),\n                orphanArena);\n          }\n        }\n  \n        case WirePointer::FAR:\n          KJ_FAIL_ASSERT(\"Far pointer should have been handled above.\") {\n            goto useDefault;\n          }\n  \n        case WirePointer::OTHER: {\n          KJ_REQUIRE(src->isCapability(), \"Unknown pointer type.\") {\n            goto useDefault;\n          }\n  \n  #if !CAPNP_LITE\n          KJ_IF_MAYBE(cap, srcSegment->getArena()->extractCap(src->capRef.index.get())) {\n            setCapabilityPointer(dstSegment, dst, kj::mv(*cap), orphanArena);\n            return { dstSegment, nullptr };\n          } else {\n  #endif  // !CAPNP_LITE\n            KJ_FAIL_REQUIRE(\"Message contained invalid capability pointer.\") {\n              goto useDefault;\n            }\n  #if !CAPNP_LITE\n          }\n  #endif  // !CAPNP_LITE\n        }\n      }\n  \n      KJ_UNREACHABLE;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1612-1617",
    "snippet": "static KJ_ALWAYS_INLINE(SegmentAnd<word*> copyPointer(\n      SegmentBuilder* dstSegment, WirePointer* dst,\n      SegmentReader* srcSegment, const WirePointer* src,\n      int nestingLimit, BuilderArena* orphanArena = nullptr)) {\n    return copyPointer(dstSegment, dst, srcSegment, src, src->target(), nestingLimit, orphanArena);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyPointer",
          "args": [
            "dstSegment",
            "dst",
            "srcSegment",
            "src",
            "src->target()",
            "nestingLimit",
            "orphanArena"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->target",
          "args": [],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(SegmentAnd<word*> copyPointer(\n        SegmentBuilder* dstSegment, WirePointer* dst,\n        SegmentReader* srcSegment, const WirePointer* src,\n        int nestingLimit, BuilderArena* orphanArena = nullptr)) {\n      return copyPointer(dstSegment, dst, srcSegment, src, src->target(), nestingLimit, orphanArena);\n    }\n}"
  },
  {
    "function_name": "setListPointer",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1556-1610",
    "snippet": "static SegmentAnd<word*> setListPointer(\n      SegmentBuilder* segment, WirePointer* ref, ListReader value,\n      BuilderArena* orphanArena = nullptr) {\n    WordCount totalSize = roundBitsUpToWords(value.elementCount * value.step);\n\n    if (value.elementSize != ElementSize::INLINE_COMPOSITE) {\n      // List of non-structs.\n      word* ptr = allocate(ref, segment, totalSize, WirePointer::LIST, orphanArena);\n\n      if (value.elementSize == ElementSize::POINTER) {\n        // List of pointers.\n        ref->listRef.set(ElementSize::POINTER, value.elementCount);\n        for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {\n          copyPointer(segment, reinterpret_cast<WirePointer*>(ptr) + i,\n                      value.segment, reinterpret_cast<const WirePointer*>(value.ptr) + i,\n                      value.nestingLimit);\n        }\n      } else {\n        // List of data.\n        ref->listRef.set(value.elementSize, value.elementCount);\n        memcpy(ptr, value.ptr, totalSize * BYTES_PER_WORD / BYTES);\n      }\n\n      return { segment, ptr };\n    } else {\n      // List of structs.\n      word* ptr = allocate(ref, segment, totalSize + POINTER_SIZE_IN_WORDS, WirePointer::LIST,\n                           orphanArena);\n      ref->listRef.setInlineComposite(totalSize);\n\n      WordCount dataSize = roundBitsUpToWords(value.structDataSize);\n      WirePointerCount pointerCount = value.structPointerCount;\n\n      WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);\n      tag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, value.elementCount);\n      tag->structRef.set(dataSize, pointerCount);\n      word* dst = ptr + POINTER_SIZE_IN_WORDS;\n\n      const word* src = reinterpret_cast<const word*>(value.ptr);\n      for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {\n        memcpy(dst, src, value.structDataSize / BITS_PER_BYTE / BYTES);\n        dst += dataSize;\n        src += dataSize;\n\n        for (uint j = 0; j < pointerCount / POINTERS; j++) {\n          copyPointer(segment, reinterpret_cast<WirePointer*>(dst),\n              value.segment, reinterpret_cast<const WirePointer*>(src), value.nestingLimit);\n          dst += POINTER_SIZE_IN_WORDS;\n          src += POINTER_SIZE_IN_WORDS;\n        }\n      }\n\n      return { segment, ptr };\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyPointer",
          "args": [
            "segment",
            "reinterpret_cast<WirePointer*>(dst)",
            "value.segment",
            "reinterpret_cast<const WirePointer*>(src)",
            "value.nestingLimit"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "src"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "dst"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "value.structDataSize / BITS_PER_BYTE / BYTES"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const word*>",
          "args": [
            "value.ptr"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->structRef.set",
          "args": [
            "dataSize",
            "pointerCount"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "tag->setKindAndInlineCompositeListElementCount",
          "args": [
            "WirePointer::STRUCT",
            "value.elementCount"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToWords",
          "args": [
            "value.structDataSize"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.setInlineComposite",
          "args": [
            "totalSize"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "totalSize + POINTER_SIZE_IN_WORDS",
            "WirePointer::LIST",
            "orphanArena"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "value.ptr",
            "totalSize * BYTES_PER_WORD / BYTES"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyPointer",
          "args": [
            "segment",
            "reinterpret_cast<WirePointer*>(ptr) + i",
            "value.segment",
            "reinterpret_cast<const WirePointer*>(value.ptr) + i",
            "value.nestingLimit"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "value.ptr"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "totalSize",
            "WirePointer::LIST",
            "orphanArena"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToWords",
          "args": [
            "value.elementCount * value.step"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static SegmentAnd<word*> setListPointer(\n        SegmentBuilder* segment, WirePointer* ref, ListReader value,\n        BuilderArena* orphanArena = nullptr) {\n      WordCount totalSize = roundBitsUpToWords(value.elementCount * value.step);\n  \n      if (value.elementSize != ElementSize::INLINE_COMPOSITE) {\n        // List of non-structs.\n        word* ptr = allocate(ref, segment, totalSize, WirePointer::LIST, orphanArena);\n  \n        if (value.elementSize == ElementSize::POINTER) {\n          // List of pointers.\n          ref->listRef.set(ElementSize::POINTER, value.elementCount);\n          for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {\n            copyPointer(segment, reinterpret_cast<WirePointer*>(ptr) + i,\n                        value.segment, reinterpret_cast<const WirePointer*>(value.ptr) + i,\n                        value.nestingLimit);\n          }\n        } else {\n          // List of data.\n          ref->listRef.set(value.elementSize, value.elementCount);\n          memcpy(ptr, value.ptr, totalSize * BYTES_PER_WORD / BYTES);\n        }\n  \n        return { segment, ptr };\n      } else {\n        // List of structs.\n        word* ptr = allocate(ref, segment, totalSize + POINTER_SIZE_IN_WORDS, WirePointer::LIST,\n                             orphanArena);\n        ref->listRef.setInlineComposite(totalSize);\n  \n        WordCount dataSize = roundBitsUpToWords(value.structDataSize);\n        WirePointerCount pointerCount = value.structPointerCount;\n  \n        WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);\n        tag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, value.elementCount);\n        tag->structRef.set(dataSize, pointerCount);\n        word* dst = ptr + POINTER_SIZE_IN_WORDS;\n  \n        const word* src = reinterpret_cast<const word*>(value.ptr);\n        for (uint i = 0; i < value.elementCount / ELEMENTS; i++) {\n          memcpy(dst, src, value.structDataSize / BITS_PER_BYTE / BYTES);\n          dst += dataSize;\n          src += dataSize;\n  \n          for (uint j = 0; j < pointerCount / POINTERS; j++) {\n            copyPointer(segment, reinterpret_cast<WirePointer*>(dst),\n                value.segment, reinterpret_cast<const WirePointer*>(src), value.nestingLimit);\n            dst += POINTER_SIZE_IN_WORDS;\n            src += POINTER_SIZE_IN_WORDS;\n          }\n        }\n  \n        return { segment, ptr };\n      }\n    }\n}"
  },
  {
    "function_name": "setCapabilityPointer",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1545-1553",
    "snippet": "static void setCapabilityPointer(\n      SegmentBuilder* segment, WirePointer* ref, kj::Own<ClientHook>&& cap,\n      BuilderArena* orphanArena = nullptr) {\n    if (orphanArena == nullptr) {\n      ref->setCap(segment->getArena()->injectCap(kj::mv(cap)));\n    } else {\n      ref->setCap(orphanArena->injectCap(kj::mv(cap)));\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ref->setCap",
          "args": [
            "orphanArena->injectCap(kj::mv(cap))"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanArena->injectCap",
          "args": [
            "kj::mv(cap)"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->setCap",
          "args": [
            "segment->getArena()->injectCap(kj::mv(cap))"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "kj::mv(cap)"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void setCapabilityPointer(\n        SegmentBuilder* segment, WirePointer* ref, kj::Own<ClientHook>&& cap,\n        BuilderArena* orphanArena = nullptr) {\n      if (orphanArena == nullptr) {\n        ref->setCap(segment->getArena()->injectCap(kj::mv(cap)));\n      } else {\n        ref->setCap(orphanArena->injectCap(kj::mv(cap)));\n      }\n    }\n}"
  },
  {
    "function_name": "setStructPointer",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1520-1542",
    "snippet": "static SegmentAnd<word*> setStructPointer(\n      SegmentBuilder* segment, WirePointer* ref, StructReader value,\n      BuilderArena* orphanArena = nullptr) {\n    WordCount dataSize = roundBitsUpToWords(value.dataSize);\n    WordCount totalSize = dataSize + value.pointerCount * WORDS_PER_POINTER;\n\n    word* ptr = allocate(ref, segment, totalSize, WirePointer::STRUCT, orphanArena);\n    ref->structRef.set(dataSize, value.pointerCount);\n\n    if (value.dataSize == 1 * BITS) {\n      *reinterpret_cast<char*>(ptr) = value.getDataField<bool>(0 * ELEMENTS);\n    } else {\n      memcpy(ptr, value.data, value.dataSize / BITS_PER_BYTE / BYTES);\n    }\n\n    WirePointer* pointerSection = reinterpret_cast<WirePointer*>(ptr + dataSize);\n    for (uint i = 0; i < value.pointerCount / POINTERS; i++) {\n      copyPointer(segment, pointerSection + i, value.segment, value.pointers + i,\n                  value.nestingLimit);\n    }\n\n    return { segment, ptr };\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyPointer",
          "args": [
            "segment",
            "pointerSection + i",
            "value.segment",
            "value.pointers + i",
            "value.nestingLimit"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr + dataSize"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "value.data",
            "value.dataSize / BITS_PER_BYTE / BYTES"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getDataField<bool>",
          "args": [
            "0 * ELEMENTS"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "ptr"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->structRef.set",
          "args": [
            "dataSize",
            "value.pointerCount"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "totalSize",
            "WirePointer::STRUCT",
            "orphanArena"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToWords",
          "args": [
            "value.dataSize"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static SegmentAnd<word*> setStructPointer(\n        SegmentBuilder* segment, WirePointer* ref, StructReader value,\n        BuilderArena* orphanArena = nullptr) {\n      WordCount dataSize = roundBitsUpToWords(value.dataSize);\n      WordCount totalSize = dataSize + value.pointerCount * WORDS_PER_POINTER;\n  \n      word* ptr = allocate(ref, segment, totalSize, WirePointer::STRUCT, orphanArena);\n      ref->structRef.set(dataSize, value.pointerCount);\n  \n      if (value.dataSize == 1 * BITS) {\n        *reinterpret_cast<char*>(ptr) = value.getDataField<bool>(0 * ELEMENTS);\n      } else {\n        memcpy(ptr, value.data, value.dataSize / BITS_PER_BYTE / BYTES);\n      }\n  \n      WirePointer* pointerSection = reinterpret_cast<WirePointer*>(ptr + dataSize);\n      for (uint i = 0; i < value.pointerCount / POINTERS; i++) {\n        copyPointer(segment, pointerSection + i, value.segment, value.pointers + i,\n                    value.nestingLimit);\n      }\n  \n      return { segment, ptr };\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1497-1518",
    "snippet": "static KJ_ALWAYS_INLINE(Data::Builder getWritableDataPointer(\n      WirePointer* ref, word* refTarget, SegmentBuilder* segment,\n      const void* defaultValue, ByteCount defaultSize)) {\n    if (ref->isNull()) {\n      if (defaultSize == 0 * BYTES) {\n        return nullptr;\n      } else {\n        Data::Builder builder = initDataPointer(ref, segment, defaultSize).value;\n        memcpy(builder.begin(), defaultValue, defaultSize / BYTES);\n        return builder;\n      }\n    } else {\n      word* ptr = followFars(ref, refTarget, segment);\n\n      KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n          \"Called getData{Field,Element}() but existing pointer is not a list.\");\n      KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,\n          \"Called getData{Field,Element}() but existing list pointer is not byte-sized.\");\n\n      return Data::Builder(reinterpret_cast<byte*>(ptr), ref->listRef.elementCount() / ELEMENTS);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Data::Builder",
          "args": [
            "reinterpret_cast<byte*>(ptr)",
            "ref->listRef.elementCount() / ELEMENTS"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "Builder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "116-118",
          "snippet": "inline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "ptr"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->listRef.elementSize() == ElementSize::BYTE",
            "\"Called getData{Field,Element}() but existing list pointer is not byte-sized.\""
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::LIST",
            "\"Called getData{Field,Element}() but existing pointer is not a list.\""
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "refTarget",
            "segment"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "builder.begin()",
            "defaultValue",
            "defaultSize / BYTES"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.begin",
          "args": [],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "initDataPointer",
          "args": [
            "ref",
            "segment",
            "defaultSize"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(Data::Builder getWritableDataPointer(\n        WirePointer* ref, word* refTarget, SegmentBuilder* segment,\n        const void* defaultValue, ByteCount defaultSize)) {\n      if (ref->isNull()) {\n        if (defaultSize == 0 * BYTES) {\n          return nullptr;\n        } else {\n          Data::Builder builder = initDataPointer(ref, segment, defaultSize).value;\n          memcpy(builder.begin(), defaultValue, defaultSize / BYTES);\n          return builder;\n        }\n      } else {\n        word* ptr = followFars(ref, refTarget, segment);\n  \n        KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n            \"Called getData{Field,Element}() but existing pointer is not a list.\");\n        KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,\n            \"Called getData{Field,Element}() but existing list pointer is not byte-sized.\");\n  \n        return Data::Builder(reinterpret_cast<byte*>(ptr), ref->listRef.elementCount() / ELEMENTS);\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1491-1495",
    "snippet": "static KJ_ALWAYS_INLINE(Data::Builder getWritableDataPointer(\n      WirePointer* ref, SegmentBuilder* segment,\n      const void* defaultValue, ByteCount defaultSize)) {\n    return getWritableDataPointer(ref, ref->target(), segment, defaultValue, defaultSize);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getWritableDataPointer",
          "args": [
            "ref",
            "ref->target()",
            "segment",
            "defaultValue",
            "defaultSize"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(Data::Builder getWritableDataPointer(\n        WirePointer* ref, SegmentBuilder* segment,\n        const void* defaultValue, ByteCount defaultSize)) {\n      return getWritableDataPointer(ref, ref->target(), segment, defaultValue, defaultSize);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1483-1489",
    "snippet": "static KJ_ALWAYS_INLINE(SegmentAnd<Data::Builder> setDataPointer(\n      WirePointer* ref, SegmentBuilder* segment, Data::Reader value,\n      BuilderArena* orphanArena = nullptr)) {\n    auto allocation = initDataPointer(ref, segment, value.size() * BYTES, orphanArena);\n    memcpy(allocation.value.begin(), value.begin(), value.size());\n    return allocation;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "allocation.value.begin()",
            "value.begin()",
            "value.size()"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "value.begin",
          "args": [],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "initDataPointer",
          "args": [
            "ref",
            "segment",
            "value.size() * BYTES",
            "orphanArena"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(SegmentAnd<Data::Builder> setDataPointer(\n        WirePointer* ref, SegmentBuilder* segment, Data::Reader value,\n        BuilderArena* orphanArena = nullptr)) {\n      auto allocation = initDataPointer(ref, segment, value.size() * BYTES, orphanArena);\n      memcpy(allocation.value.begin(), value.begin(), value.size());\n      return allocation;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1470-1481",
    "snippet": "static KJ_ALWAYS_INLINE(SegmentAnd<Data::Builder> initDataPointer(\n      WirePointer* ref, SegmentBuilder* segment, ByteCount size,\n      BuilderArena* orphanArena = nullptr)) {\n    // Allocate the space.\n    word* ptr = allocate(ref, segment, roundBytesUpToWords(size), WirePointer::LIST, orphanArena);\n\n    // Initialize the pointer.\n    ref->listRef.set(ElementSize::BYTE, size * (1 * ELEMENTS / BYTES));\n\n    // Build the Data::Builder.\n    return { segment, Data::Builder(reinterpret_cast<byte*>(ptr), size / BYTES) };\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Data::Builder",
          "args": [
            "reinterpret_cast<byte*>(ptr)",
            "size / BYTES"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "Builder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "116-118",
          "snippet": "inline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "ptr"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.set",
          "args": [
            "ElementSize::BYTE",
            "size * (1 * ELEMENTS / BYTES)"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "roundBytesUpToWords(size)",
            "WirePointer::LIST",
            "orphanArena"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBytesUpToWords",
          "args": [
            "size"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(SegmentAnd<Data::Builder> initDataPointer(\n        WirePointer* ref, SegmentBuilder* segment, ByteCount size,\n        BuilderArena* orphanArena = nullptr)) {\n      // Allocate the space.\n      word* ptr = allocate(ref, segment, roundBytesUpToWords(size), WirePointer::LIST, orphanArena);\n  \n      // Initialize the pointer.\n      ref->listRef.set(ElementSize::BYTE, size * (1 * ELEMENTS / BYTES));\n  \n      // Build the Data::Builder.\n      return { segment, Data::Builder(reinterpret_cast<byte*>(ptr), size / BYTES) };\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1440-1468",
    "snippet": "static KJ_ALWAYS_INLINE(Text::Builder getWritableTextPointer(\n      WirePointer* ref, word* refTarget, SegmentBuilder* segment,\n      const void* defaultValue, ByteCount defaultSize)) {\n    if (ref->isNull()) {\n    useDefault:\n      if (defaultSize == 0 * BYTES) {\n        return nullptr;\n      } else {\n        Text::Builder builder = initTextPointer(ref, segment, defaultSize).value;\n        memcpy(builder.begin(), defaultValue, defaultSize / BYTES);\n        return builder;\n      }\n    } else {\n      word* ptr = followFars(ref, refTarget, segment);\n      char* cptr = reinterpret_cast<char*>(ptr);\n\n      KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n          \"Called getText{Field,Element}() but existing pointer is not a list.\");\n      KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,\n          \"Called getText{Field,Element}() but existing list pointer is not byte-sized.\");\n\n      size_t size = ref->listRef.elementCount() / ELEMENTS;\n      KJ_REQUIRE(size > 0 && cptr[size-1] == '\\0', \"Text blob missing NUL terminator.\") {\n        goto useDefault;\n      }\n\n      return Text::Builder(cptr, size - 1);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Text::Builder",
          "args": [
            "cptr",
            "size - 1"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "Builder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "116-118",
          "snippet": "inline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "size > 0 && cptr[size-1] == '\\0'",
            "\"Text blob missing NUL terminator.\""
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->listRef.elementSize() == ElementSize::BYTE",
            "\"Called getText{Field,Element}() but existing list pointer is not byte-sized.\""
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::LIST",
            "\"Called getText{Field,Element}() but existing pointer is not a list.\""
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "ptr"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "refTarget",
            "segment"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "builder.begin()",
            "defaultValue",
            "defaultSize / BYTES"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.begin",
          "args": [],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "initTextPointer",
          "args": [
            "ref",
            "segment",
            "defaultSize"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(Text::Builder getWritableTextPointer(\n        WirePointer* ref, word* refTarget, SegmentBuilder* segment,\n        const void* defaultValue, ByteCount defaultSize)) {\n      if (ref->isNull()) {\n      useDefault:\n        if (defaultSize == 0 * BYTES) {\n          return nullptr;\n        } else {\n          Text::Builder builder = initTextPointer(ref, segment, defaultSize).value;\n          memcpy(builder.begin(), defaultValue, defaultSize / BYTES);\n          return builder;\n        }\n      } else {\n        word* ptr = followFars(ref, refTarget, segment);\n        char* cptr = reinterpret_cast<char*>(ptr);\n  \n        KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n            \"Called getText{Field,Element}() but existing pointer is not a list.\");\n        KJ_REQUIRE(ref->listRef.elementSize() == ElementSize::BYTE,\n            \"Called getText{Field,Element}() but existing list pointer is not byte-sized.\");\n  \n        size_t size = ref->listRef.elementCount() / ELEMENTS;\n        KJ_REQUIRE(size > 0 && cptr[size-1] == '\\0', \"Text blob missing NUL terminator.\") {\n          goto useDefault;\n        }\n  \n        return Text::Builder(cptr, size - 1);\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1434-1438",
    "snippet": "static KJ_ALWAYS_INLINE(Text::Builder getWritableTextPointer(\n      WirePointer* ref, SegmentBuilder* segment,\n      const void* defaultValue, ByteCount defaultSize)) {\n    return getWritableTextPointer(ref, ref->target(), segment, defaultValue, defaultSize);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getWritableTextPointer",
          "args": [
            "ref",
            "ref->target()",
            "segment",
            "defaultValue",
            "defaultSize"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(Text::Builder getWritableTextPointer(\n        WirePointer* ref, SegmentBuilder* segment,\n        const void* defaultValue, ByteCount defaultSize)) {\n      return getWritableTextPointer(ref, ref->target(), segment, defaultValue, defaultSize);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1426-1432",
    "snippet": "static KJ_ALWAYS_INLINE(SegmentAnd<Text::Builder> setTextPointer(\n      WirePointer* ref, SegmentBuilder* segment, Text::Reader value,\n      BuilderArena* orphanArena = nullptr)) {\n    auto allocation = initTextPointer(ref, segment, value.size() * BYTES, orphanArena);\n    memcpy(allocation.value.begin(), value.begin(), value.size());\n    return allocation;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "allocation.value.begin()",
            "value.begin()",
            "value.size()"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "value.begin",
          "args": [],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "initTextPointer",
          "args": [
            "ref",
            "segment",
            "value.size() * BYTES",
            "orphanArena"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(SegmentAnd<Text::Builder> setTextPointer(\n        WirePointer* ref, SegmentBuilder* segment, Text::Reader value,\n        BuilderArena* orphanArena = nullptr)) {\n      auto allocation = initTextPointer(ref, segment, value.size() * BYTES, orphanArena);\n      memcpy(allocation.value.begin(), value.begin(), value.size());\n      return allocation;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1409-1424",
    "snippet": "static KJ_ALWAYS_INLINE(SegmentAnd<Text::Builder> initTextPointer(\n      WirePointer* ref, SegmentBuilder* segment, ByteCount size,\n      BuilderArena* orphanArena = nullptr)) {\n    // The byte list must include a NUL terminator.\n    ByteCount byteSize = size + 1 * BYTES;\n\n    // Allocate the space.\n    word* ptr = allocate(\n        ref, segment, roundBytesUpToWords(byteSize), WirePointer::LIST, orphanArena);\n\n    // Initialize the pointer.\n    ref->listRef.set(ElementSize::BYTE, byteSize * (1 * ELEMENTS / BYTES));\n\n    // Build the Text::Builder.  This will initialize the NUL terminator.\n    return { segment, Text::Builder(reinterpret_cast<char*>(ptr), size / BYTES) };\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Text::Builder",
          "args": [
            "reinterpret_cast<char*>(ptr)",
            "size / BYTES"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "Builder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "116-118",
          "snippet": "inline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline Builder(char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "ptr"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.set",
          "args": [
            "ElementSize::BYTE",
            "byteSize * (1 * ELEMENTS / BYTES)"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "roundBytesUpToWords(byteSize)",
            "WirePointer::LIST",
            "orphanArena"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBytesUpToWords",
          "args": [
            "byteSize"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(SegmentAnd<Text::Builder> initTextPointer(\n        WirePointer* ref, SegmentBuilder* segment, ByteCount size,\n        BuilderArena* orphanArena = nullptr)) {\n      // The byte list must include a NUL terminator.\n      ByteCount byteSize = size + 1 * BYTES;\n  \n      // Allocate the space.\n      word* ptr = allocate(\n          ref, segment, roundBytesUpToWords(byteSize), WirePointer::LIST, orphanArena);\n  \n      // Initialize the pointer.\n      ref->listRef.set(ElementSize::BYTE, byteSize * (1 * ELEMENTS / BYTES));\n  \n      // Build the Text::Builder.  This will initialize the NUL terminator.\n      return { segment, Text::Builder(reinterpret_cast<char*>(ptr), size / BYTES) };\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1244-1407",
    "snippet": "static KJ_ALWAYS_INLINE(ListBuilder getWritableStructListPointer(\n      WirePointer* origRef, word* origRefTarget, SegmentBuilder* origSegment,\n      StructSize elementSize, const word* defaultValue, BuilderArena* orphanArena = nullptr)) {\n    if (origRef->isNull()) {\n    useDefault:\n      if (defaultValue == nullptr ||\n          reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n        return ListBuilder();\n      }\n      origRefTarget = copyMessage(\n          origSegment, origRef, reinterpret_cast<const WirePointer*>(defaultValue));\n      defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n    }\n\n    // We must verify that the pointer has the right size and potentially upgrade it if not.\n\n    WirePointer* oldRef = origRef;\n    SegmentBuilder* oldSegment = origSegment;\n    word* oldPtr = followFars(oldRef, origRefTarget, oldSegment);\n\n    KJ_REQUIRE(oldRef->kind() == WirePointer::LIST,\n               \"Called getList{Field,Element}() but existing pointer is not a list.\") {\n      goto useDefault;\n    }\n\n    ElementSize oldSize = oldRef->listRef.elementSize();\n\n    if (oldSize == ElementSize::INLINE_COMPOSITE) {\n      // Existing list is INLINE_COMPOSITE, but we need to verify that the sizes match.\n\n      WirePointer* oldTag = reinterpret_cast<WirePointer*>(oldPtr);\n      oldPtr += POINTER_SIZE_IN_WORDS;\n      KJ_REQUIRE(oldTag->kind() == WirePointer::STRUCT,\n                 \"INLINE_COMPOSITE list with non-STRUCT elements not supported.\") {\n        goto useDefault;\n      }\n\n      WordCount oldDataSize = oldTag->structRef.dataSize.get();\n      WirePointerCount oldPointerCount = oldTag->structRef.ptrCount.get();\n      auto oldStep = (oldDataSize + oldPointerCount * WORDS_PER_POINTER) / ELEMENTS;\n      ElementCount elementCount = oldTag->inlineCompositeListElementCount();\n\n      if (oldDataSize >= elementSize.data && oldPointerCount >= elementSize.pointers) {\n        // Old size is at least as large as we need.  Ship it.\n        return ListBuilder(oldSegment, oldPtr, oldStep * BITS_PER_WORD, elementCount,\n                           oldDataSize * BITS_PER_WORD, oldPointerCount,\n                           ElementSize::INLINE_COMPOSITE);\n      }\n\n      // The structs in this list are smaller than expected, probably written using an older\n      // version of the protocol.  We need to make a copy and expand them.\n\n      WordCount newDataSize = kj::max(oldDataSize, elementSize.data);\n      WirePointerCount newPointerCount = kj::max(oldPointerCount, elementSize.pointers);\n      auto newStep = (newDataSize + newPointerCount * WORDS_PER_POINTER) / ELEMENTS;\n      WordCount totalSize = newStep * elementCount;\n\n      // Don't let allocate() zero out the object just yet.\n      zeroPointerAndFars(origSegment, origRef);\n\n      word* newPtr = allocate(origRef, origSegment, totalSize + POINTER_SIZE_IN_WORDS,\n                              WirePointer::LIST, orphanArena);\n      origRef->listRef.setInlineComposite(totalSize);\n\n      WirePointer* newTag = reinterpret_cast<WirePointer*>(newPtr);\n      newTag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, elementCount);\n      newTag->structRef.set(newDataSize, newPointerCount);\n      newPtr += POINTER_SIZE_IN_WORDS;\n\n      word* src = oldPtr;\n      word* dst = newPtr;\n      for (uint i = 0; i < elementCount / ELEMENTS; i++) {\n        // Copy data section.\n        memcpy(dst, src, oldDataSize * BYTES_PER_WORD / BYTES);\n\n        // Copy pointer section.\n        WirePointer* newPointerSection = reinterpret_cast<WirePointer*>(dst + newDataSize);\n        WirePointer* oldPointerSection = reinterpret_cast<WirePointer*>(src + oldDataSize);\n        for (uint j = 0; j < oldPointerCount / POINTERS; j++) {\n          transferPointer(origSegment, newPointerSection + j, oldSegment, oldPointerSection + j);\n        }\n\n        dst += newStep * (1 * ELEMENTS);\n        src += oldStep * (1 * ELEMENTS);\n      }\n\n      // Zero out old location.  See explanation in getWritableStructPointer().\n      memset(oldPtr, 0, oldStep * elementCount * BYTES_PER_WORD / BYTES);\n\n      return ListBuilder(origSegment, newPtr, newStep * BITS_PER_WORD, elementCount,\n                         newDataSize * BITS_PER_WORD, newPointerCount, ElementSize::INLINE_COMPOSITE);\n    } else {\n      // We're upgrading from a non-struct list.\n\n      BitCount oldDataSize = dataBitsPerElement(oldSize) * ELEMENTS;\n      WirePointerCount oldPointerCount = pointersPerElement(oldSize) * ELEMENTS;\n      auto oldStep = (oldDataSize + oldPointerCount * BITS_PER_POINTER) / ELEMENTS;\n      ElementCount elementCount = oldRef->listRef.elementCount();\n\n      if (oldSize == ElementSize::VOID) {\n        // Nothing to copy, just allocate a new list.\n        return initStructListPointer(origRef, origSegment, elementCount, elementSize);\n      } else {\n        // Upgrading to an inline composite list.\n\n        KJ_REQUIRE(oldSize != ElementSize::BIT,\n            \"Found bit list where struct list was expected; upgrading boolean lists to structs \"\n            \"is no longer supported.\") {\n          goto useDefault;\n        }\n\n        WordCount newDataSize = elementSize.data;\n        WirePointerCount newPointerCount = elementSize.pointers;\n\n        if (oldSize == ElementSize::POINTER) {\n          newPointerCount = kj::max(newPointerCount, 1 * POINTERS);\n        } else {\n          // Old list contains data elements, so we need at least 1 word of data.\n          newDataSize = kj::max(newDataSize, 1 * WORDS);\n        }\n\n        auto newStep = (newDataSize + newPointerCount * WORDS_PER_POINTER) / ELEMENTS;\n        WordCount totalWords = elementCount * newStep;\n\n        // Don't let allocate() zero out the object just yet.\n        zeroPointerAndFars(origSegment, origRef);\n\n        word* newPtr = allocate(origRef, origSegment, totalWords + POINTER_SIZE_IN_WORDS,\n                                WirePointer::LIST, orphanArena);\n        origRef->listRef.setInlineComposite(totalWords);\n\n        WirePointer* tag = reinterpret_cast<WirePointer*>(newPtr);\n        tag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, elementCount);\n        tag->structRef.set(newDataSize, newPointerCount);\n        newPtr += POINTER_SIZE_IN_WORDS;\n\n        if (oldSize == ElementSize::POINTER) {\n          WirePointer* dst = reinterpret_cast<WirePointer*>(newPtr + newDataSize);\n          WirePointer* src = reinterpret_cast<WirePointer*>(oldPtr);\n          for (uint i = 0; i < elementCount / ELEMENTS; i++) {\n            transferPointer(origSegment, dst, oldSegment, src);\n            dst += newStep / WORDS_PER_POINTER * (1 * ELEMENTS);\n            ++src;\n          }\n        } else {\n          word* dst = newPtr;\n          char* src = reinterpret_cast<char*>(oldPtr);\n          ByteCount oldByteStep = oldDataSize / BITS_PER_BYTE;\n          for (uint i = 0; i < elementCount / ELEMENTS; i++) {\n            memcpy(dst, src, oldByteStep / BYTES);\n            src += oldByteStep / BYTES;\n            dst += newStep * (1 * ELEMENTS);\n          }\n        }\n\n        // Zero out old location.  See explanation in getWritableStructPointer().\n        memset(oldPtr, 0, roundBitsUpToBytes(oldStep * elementCount) / BYTES);\n\n        return ListBuilder(origSegment, newPtr, newStep * BITS_PER_WORD, elementCount,\n                           newDataSize * BITS_PER_WORD, newPointerCount,\n                           ElementSize::INLINE_COMPOSITE);\n      }\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListBuilder",
          "args": [
            "origSegment",
            "newPtr",
            "newStep * BITS_PER_WORD",
            "elementCount",
            "newDataSize * BITS_PER_WORD",
            "newPointerCount",
            "ElementSize::INLINE_COMPOSITE"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "ListBuilder",
          "container": "ListBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "629-635",
          "snippet": "inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                     decltype(BITS / ELEMENTS) step, ElementCount size,\n                     BitCount structDataSize, WirePointerCount structPointerCount,\n                     ElementSize elementSize)\n      : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n        elementCount(size), step(step), structDataSize(structDataSize),\n        structPointerCount(structPointerCount), elementSize(elementSize) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListBuilder {\n  inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                       decltype(BITS / ELEMENTS) step, ElementCount size,\n                       BitCount structDataSize, WirePointerCount structPointerCount,\n                       ElementSize elementSize)\n        : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n          elementCount(size), step(step), structDataSize(structDataSize),\n          structPointerCount(structPointerCount), elementSize(elementSize) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "oldPtr",
            "0",
            "roundBitsUpToBytes(oldStep * elementCount) / BYTES"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToBytes",
          "args": [
            "oldStep * elementCount"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "oldByteStep / BYTES"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "oldPtr"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transferPointer",
          "args": [
            "origSegment",
            "dst",
            "oldSegment",
            "src"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "transferPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "856-877",
          "snippet": "static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                              SegmentBuilder* srcSegment, WirePointer* src) {\n    // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n    // be in different segments.  Not always-inline because this is rarely used.\n    //\n    // Caller MUST zero out the source pointer after calling this, to make sure no later code\n    // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n    // this zeroing itself because many callers transfer several pointers in a loop then zero out\n    // the whole section.\n\n    KJ_DASSERT(dst->isNull());\n    // We expect the caller to ensure the target is already null so won't leak.\n\n    if (src->isNull()) {\n      memset(dst, 0, sizeof(WirePointer));\n    } else if (src->kind() == WirePointer::FAR) {\n      // Far pointers are position-independent, so we can just copy.\n      memcpy(dst, src, sizeof(WirePointer));\n    } else {\n      transferPointer(dstSegment, dst, srcSegment, src, src->target());\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                                SegmentBuilder* srcSegment, WirePointer* src) {\n      // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n      // be in different segments.  Not always-inline because this is rarely used.\n      //\n      // Caller MUST zero out the source pointer after calling this, to make sure no later code\n      // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n      // this zeroing itself because many callers transfer several pointers in a loop then zero out\n      // the whole section.\n  \n      KJ_DASSERT(dst->isNull());\n      // We expect the caller to ensure the target is already null so won't leak.\n  \n      if (src->isNull()) {\n        memset(dst, 0, sizeof(WirePointer));\n      } else if (src->kind() == WirePointer::FAR) {\n        // Far pointers are position-independent, so we can just copy.\n        memcpy(dst, src, sizeof(WirePointer));\n      } else {\n        transferPointer(dstSegment, dst, srcSegment, src, src->target());\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "oldPtr"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "newPtr + newDataSize"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->structRef.set",
          "args": [
            "newDataSize",
            "newPointerCount"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "tag->setKindAndInlineCompositeListElementCount",
          "args": [
            "WirePointer::STRUCT",
            "elementCount"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "newPtr"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origRef->listRef.setInlineComposite",
          "args": [
            "totalWords"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "origRef",
            "origSegment",
            "totalWords + POINTER_SIZE_IN_WORDS",
            "WirePointer::LIST",
            "orphanArena"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zeroPointerAndFars",
          "args": [
            "origSegment",
            "origRef"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "newDataSize",
            "1 * WORDS"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "oldSize != ElementSize::BIT",
            "\"Found bit list where struct list was expected; upgrading boolean lists to structs \"\n            \"is no longer supported.\""
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStructListPointer",
          "args": [
            "origRef",
            "origSegment",
            "elementCount",
            "elementSize"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldRef->listRef.elementCount",
          "args": [],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointersPerElement",
          "args": [
            "oldSize"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "pointersPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "103-105",
          "snippet": "inline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dataBitsPerElement",
          "args": [
            "oldSize"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "dataBitsPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "99-101",
          "snippet": "inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "oldPtr",
            "0",
            "oldStep * elementCount * BYTES_PER_WORD / BYTES"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "src + oldDataSize"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "dst + newDataSize"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "oldDataSize * BYTES_PER_WORD / BYTES"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newTag->setKindAndInlineCompositeListElementCount",
          "args": [
            "WirePointer::STRUCT",
            "elementCount"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "newPtr"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origRef->listRef.setInlineComposite",
          "args": [
            "totalSize"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "origRef",
            "origSegment",
            "totalSize + POINTER_SIZE_IN_WORDS",
            "WirePointer::LIST",
            "orphanArena"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zeroPointerAndFars",
          "args": [
            "origSegment",
            "origRef"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldTag->inlineCompositeListElementCount",
          "args": [],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldTag->structRef.ptrCount.get",
          "args": [],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "oldTag->kind() == WirePointer::STRUCT",
            "\"INLINE_COMPOSITE list with non-STRUCT elements not supported.\""
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldTag->kind",
          "args": [],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "oldPtr"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldRef->listRef.elementSize",
          "args": [],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "oldRef->kind() == WirePointer::LIST",
            "\"Called getList{Field,Element}() but existing pointer is not a list.\""
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "oldRef",
            "origRefTarget",
            "oldSegment"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyMessage",
          "args": [
            "origSegment",
            "origRef",
            "reinterpret_cast<const WirePointer*>(defaultValue)"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListBuilder",
          "args": [],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "getElementSize",
          "container": "ListBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "582-582",
          "snippet": "inline ElementSize getElementSize() const { return elementSize; }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListBuilder {\n  inline ElementSize getElementSize() const { return elementSize; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origRef->isNull",
          "args": [],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListBuilder getWritableStructListPointer(\n        WirePointer* origRef, word* origRefTarget, SegmentBuilder* origSegment,\n        StructSize elementSize, const word* defaultValue, BuilderArena* orphanArena = nullptr)) {\n      if (origRef->isNull()) {\n      useDefault:\n        if (defaultValue == nullptr ||\n            reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n          return ListBuilder();\n        }\n        origRefTarget = copyMessage(\n            origSegment, origRef, reinterpret_cast<const WirePointer*>(defaultValue));\n        defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n      }\n  \n      // We must verify that the pointer has the right size and potentially upgrade it if not.\n  \n      WirePointer* oldRef = origRef;\n      SegmentBuilder* oldSegment = origSegment;\n      word* oldPtr = followFars(oldRef, origRefTarget, oldSegment);\n  \n      KJ_REQUIRE(oldRef->kind() == WirePointer::LIST,\n                 \"Called getList{Field,Element}() but existing pointer is not a list.\") {\n        goto useDefault;\n      }\n  \n      ElementSize oldSize = oldRef->listRef.elementSize();\n  \n      if (oldSize == ElementSize::INLINE_COMPOSITE) {\n        // Existing list is INLINE_COMPOSITE, but we need to verify that the sizes match.\n  \n        WirePointer* oldTag = reinterpret_cast<WirePointer*>(oldPtr);\n        oldPtr += POINTER_SIZE_IN_WORDS;\n        KJ_REQUIRE(oldTag->kind() == WirePointer::STRUCT,\n                   \"INLINE_COMPOSITE list with non-STRUCT elements not supported.\") {\n          goto useDefault;\n        }\n  \n        WordCount oldDataSize = oldTag->structRef.dataSize.get();\n        WirePointerCount oldPointerCount = oldTag->structRef.ptrCount.get();\n        auto oldStep = (oldDataSize + oldPointerCount * WORDS_PER_POINTER) / ELEMENTS;\n        ElementCount elementCount = oldTag->inlineCompositeListElementCount();\n  \n        if (oldDataSize >= elementSize.data && oldPointerCount >= elementSize.pointers) {\n          // Old size is at least as large as we need.  Ship it.\n          return ListBuilder(oldSegment, oldPtr, oldStep * BITS_PER_WORD, elementCount,\n                             oldDataSize * BITS_PER_WORD, oldPointerCount,\n                             ElementSize::INLINE_COMPOSITE);\n        }\n  \n        // The structs in this list are smaller than expected, probably written using an older\n        // version of the protocol.  We need to make a copy and expand them.\n  \n        WordCount newDataSize = kj::max(oldDataSize, elementSize.data);\n        WirePointerCount newPointerCount = kj::max(oldPointerCount, elementSize.pointers);\n        auto newStep = (newDataSize + newPointerCount * WORDS_PER_POINTER) / ELEMENTS;\n        WordCount totalSize = newStep * elementCount;\n  \n        // Don't let allocate() zero out the object just yet.\n        zeroPointerAndFars(origSegment, origRef);\n  \n        word* newPtr = allocate(origRef, origSegment, totalSize + POINTER_SIZE_IN_WORDS,\n                                WirePointer::LIST, orphanArena);\n        origRef->listRef.setInlineComposite(totalSize);\n  \n        WirePointer* newTag = reinterpret_cast<WirePointer*>(newPtr);\n        newTag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, elementCount);\n        newTag->structRef.set(newDataSize, newPointerCount);\n        newPtr += POINTER_SIZE_IN_WORDS;\n  \n        word* src = oldPtr;\n        word* dst = newPtr;\n        for (uint i = 0; i < elementCount / ELEMENTS; i++) {\n          // Copy data section.\n          memcpy(dst, src, oldDataSize * BYTES_PER_WORD / BYTES);\n  \n          // Copy pointer section.\n          WirePointer* newPointerSection = reinterpret_cast<WirePointer*>(dst + newDataSize);\n          WirePointer* oldPointerSection = reinterpret_cast<WirePointer*>(src + oldDataSize);\n          for (uint j = 0; j < oldPointerCount / POINTERS; j++) {\n            transferPointer(origSegment, newPointerSection + j, oldSegment, oldPointerSection + j);\n          }\n  \n          dst += newStep * (1 * ELEMENTS);\n          src += oldStep * (1 * ELEMENTS);\n        }\n  \n        // Zero out old location.  See explanation in getWritableStructPointer().\n        memset(oldPtr, 0, oldStep * elementCount * BYTES_PER_WORD / BYTES);\n  \n        return ListBuilder(origSegment, newPtr, newStep * BITS_PER_WORD, elementCount,\n                           newDataSize * BITS_PER_WORD, newPointerCount, ElementSize::INLINE_COMPOSITE);\n      } else {\n        // We're upgrading from a non-struct list.\n  \n        BitCount oldDataSize = dataBitsPerElement(oldSize) * ELEMENTS;\n        WirePointerCount oldPointerCount = pointersPerElement(oldSize) * ELEMENTS;\n        auto oldStep = (oldDataSize + oldPointerCount * BITS_PER_POINTER) / ELEMENTS;\n        ElementCount elementCount = oldRef->listRef.elementCount();\n  \n        if (oldSize == ElementSize::VOID) {\n          // Nothing to copy, just allocate a new list.\n          return initStructListPointer(origRef, origSegment, elementCount, elementSize);\n        } else {\n          // Upgrading to an inline composite list.\n  \n          KJ_REQUIRE(oldSize != ElementSize::BIT,\n              \"Found bit list where struct list was expected; upgrading boolean lists to structs \"\n              \"is no longer supported.\") {\n            goto useDefault;\n          }\n  \n          WordCount newDataSize = elementSize.data;\n          WirePointerCount newPointerCount = elementSize.pointers;\n  \n          if (oldSize == ElementSize::POINTER) {\n            newPointerCount = kj::max(newPointerCount, 1 * POINTERS);\n          } else {\n            // Old list contains data elements, so we need at least 1 word of data.\n            newDataSize = kj::max(newDataSize, 1 * WORDS);\n          }\n  \n          auto newStep = (newDataSize + newPointerCount * WORDS_PER_POINTER) / ELEMENTS;\n          WordCount totalWords = elementCount * newStep;\n  \n          // Don't let allocate() zero out the object just yet.\n          zeroPointerAndFars(origSegment, origRef);\n  \n          word* newPtr = allocate(origRef, origSegment, totalWords + POINTER_SIZE_IN_WORDS,\n                                  WirePointer::LIST, orphanArena);\n          origRef->listRef.setInlineComposite(totalWords);\n  \n          WirePointer* tag = reinterpret_cast<WirePointer*>(newPtr);\n          tag->setKindAndInlineCompositeListElementCount(WirePointer::STRUCT, elementCount);\n          tag->structRef.set(newDataSize, newPointerCount);\n          newPtr += POINTER_SIZE_IN_WORDS;\n  \n          if (oldSize == ElementSize::POINTER) {\n            WirePointer* dst = reinterpret_cast<WirePointer*>(newPtr + newDataSize);\n            WirePointer* src = reinterpret_cast<WirePointer*>(oldPtr);\n            for (uint i = 0; i < elementCount / ELEMENTS; i++) {\n              transferPointer(origSegment, dst, oldSegment, src);\n              dst += newStep / WORDS_PER_POINTER * (1 * ELEMENTS);\n              ++src;\n            }\n          } else {\n            word* dst = newPtr;\n            char* src = reinterpret_cast<char*>(oldPtr);\n            ByteCount oldByteStep = oldDataSize / BITS_PER_BYTE;\n            for (uint i = 0; i < elementCount / ELEMENTS; i++) {\n              memcpy(dst, src, oldByteStep / BYTES);\n              src += oldByteStep / BYTES;\n              dst += newStep * (1 * ELEMENTS);\n            }\n          }\n  \n          // Zero out old location.  See explanation in getWritableStructPointer().\n          memset(oldPtr, 0, roundBitsUpToBytes(oldStep * elementCount) / BYTES);\n  \n          return ListBuilder(origSegment, newPtr, newStep * BITS_PER_WORD, elementCount,\n                             newDataSize * BITS_PER_WORD, newPointerCount,\n                             ElementSize::INLINE_COMPOSITE);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1238-1243",
    "snippet": "static KJ_ALWAYS_INLINE(ListBuilder getWritableStructListPointer(\n      WirePointer* origRef, SegmentBuilder* origSegment, StructSize elementSize,\n      const word* defaultValue)) {\n    return getWritableStructListPointer(origRef, origRef->target(), origSegment, elementSize,\n                                        defaultValue);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getWritableStructListPointer",
          "args": [
            "origRef",
            "origRef->target()",
            "origSegment",
            "elementSize",
            "defaultValue"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origRef->target",
          "args": [],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListBuilder getWritableStructListPointer(\n        WirePointer* origRef, SegmentBuilder* origSegment, StructSize elementSize,\n        const word* defaultValue)) {\n      return getWritableStructListPointer(origRef, origRef->target(), origSegment, elementSize,\n                                          defaultValue);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1191-1236",
    "snippet": "static KJ_ALWAYS_INLINE(ListBuilder getWritableListPointerAnySize(\n      WirePointer* origRef, word* origRefTarget, SegmentBuilder* origSegment,\n      const word* defaultValue, BuilderArena* orphanArena = nullptr)) {\n    if (origRef->isNull()) {\n    useDefault:\n      if (defaultValue == nullptr ||\n          reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n        return ListBuilder();\n      }\n      origRefTarget = copyMessage(\n          origSegment, origRef, reinterpret_cast<const WirePointer*>(defaultValue));\n      defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n    }\n\n    WirePointer* ref = origRef;\n    SegmentBuilder* segment = origSegment;\n    word* ptr = followFars(ref, origRefTarget, segment);\n\n    KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n        \"Called getList{Field,Element}() but existing pointer is not a list.\") {\n      goto useDefault;\n    }\n\n    ElementSize elementSize = ref->listRef.elementSize();\n\n    if (elementSize == ElementSize::INLINE_COMPOSITE) {\n      // Read the tag to get the actual element count.\n      WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);\n      KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n          \"INLINE_COMPOSITE list with non-STRUCT elements not supported.\");\n      ptr += POINTER_SIZE_IN_WORDS;\n\n      return ListBuilder(segment, ptr,\n                         tag->structRef.wordSize() * BITS_PER_WORD / ELEMENTS,\n                         tag->inlineCompositeListElementCount(),\n                         tag->structRef.dataSize.get() * BITS_PER_WORD,\n                         tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE);\n    } else {\n      BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;\n      WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;\n\n      auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n      return ListBuilder(segment, ptr, step, ref->listRef.elementCount(),\n                         dataSize, pointerCount, elementSize);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListBuilder",
          "args": [
            "segment",
            "ptr",
            "step",
            "ref->listRef.elementCount()",
            "dataSize",
            "pointerCount",
            "elementSize"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "ListBuilder",
          "container": "ListBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "629-635",
          "snippet": "inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                     decltype(BITS / ELEMENTS) step, ElementCount size,\n                     BitCount structDataSize, WirePointerCount structPointerCount,\n                     ElementSize elementSize)\n      : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n        elementCount(size), step(step), structDataSize(structDataSize),\n        structPointerCount(structPointerCount), elementSize(elementSize) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListBuilder {\n  inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                       decltype(BITS / ELEMENTS) step, ElementCount size,\n                       BitCount structDataSize, WirePointerCount structPointerCount,\n                       ElementSize elementSize)\n        : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n          elementCount(size), step(step), structDataSize(structDataSize),\n          structPointerCount(structPointerCount), elementSize(elementSize) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointersPerElement",
          "args": [
            "elementSize"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "pointersPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "103-105",
          "snippet": "inline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dataBitsPerElement",
          "args": [
            "elementSize"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "dataBitsPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "99-101",
          "snippet": "inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag->structRef.ptrCount.get",
          "args": [],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag->inlineCompositeListElementCount",
          "args": [],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->structRef.wordSize",
          "args": [],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "wordSize",
          "container": "WirePointer::StructRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "185-187",
          "snippet": "inline WordCount wordSize() const {\n      return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n    }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    inline WordCount wordSize() const {\n          return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tag->kind() == WirePointer::STRUCT",
            "\"INLINE_COMPOSITE list with non-STRUCT elements not supported.\""
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->kind",
          "args": [],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::LIST",
            "\"Called getList{Field,Element}() but existing pointer is not a list.\""
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "origRefTarget",
            "segment"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyMessage",
          "args": [
            "origSegment",
            "origRef",
            "reinterpret_cast<const WirePointer*>(defaultValue)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListBuilder",
          "args": [],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "getElementSize",
          "container": "ListBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "582-582",
          "snippet": "inline ElementSize getElementSize() const { return elementSize; }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListBuilder {\n  inline ElementSize getElementSize() const { return elementSize; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origRef->isNull",
          "args": [],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListBuilder getWritableListPointerAnySize(\n        WirePointer* origRef, word* origRefTarget, SegmentBuilder* origSegment,\n        const word* defaultValue, BuilderArena* orphanArena = nullptr)) {\n      if (origRef->isNull()) {\n      useDefault:\n        if (defaultValue == nullptr ||\n            reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n          return ListBuilder();\n        }\n        origRefTarget = copyMessage(\n            origSegment, origRef, reinterpret_cast<const WirePointer*>(defaultValue));\n        defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n      }\n  \n      WirePointer* ref = origRef;\n      SegmentBuilder* segment = origSegment;\n      word* ptr = followFars(ref, origRefTarget, segment);\n  \n      KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n          \"Called getList{Field,Element}() but existing pointer is not a list.\") {\n        goto useDefault;\n      }\n  \n      ElementSize elementSize = ref->listRef.elementSize();\n  \n      if (elementSize == ElementSize::INLINE_COMPOSITE) {\n        // Read the tag to get the actual element count.\n        WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);\n        KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n            \"INLINE_COMPOSITE list with non-STRUCT elements not supported.\");\n        ptr += POINTER_SIZE_IN_WORDS;\n  \n        return ListBuilder(segment, ptr,\n                           tag->structRef.wordSize() * BITS_PER_WORD / ELEMENTS,\n                           tag->inlineCompositeListElementCount(),\n                           tag->structRef.dataSize.get() * BITS_PER_WORD,\n                           tag->structRef.ptrCount.get(), ElementSize::INLINE_COMPOSITE);\n      } else {\n        BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;\n        WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;\n  \n        auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n        return ListBuilder(segment, ptr, step, ref->listRef.elementCount(),\n                           dataSize, pointerCount, elementSize);\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1186-1189",
    "snippet": "static KJ_ALWAYS_INLINE(ListBuilder getWritableListPointerAnySize(\n      WirePointer* origRef, SegmentBuilder* origSegment, const word* defaultValue)) {\n    return getWritableListPointerAnySize(origRef, origRef->target(), origSegment, defaultValue);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getWritableListPointerAnySize",
          "args": [
            "origRef",
            "origRef->target()",
            "origSegment",
            "defaultValue"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origRef->target",
          "args": [],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListBuilder getWritableListPointerAnySize(\n        WirePointer* origRef, SegmentBuilder* origSegment, const word* defaultValue)) {\n      return getWritableListPointerAnySize(origRef, origRef->target(), origSegment, defaultValue);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1066-1184",
    "snippet": "static KJ_ALWAYS_INLINE(ListBuilder getWritableListPointer(\n      WirePointer* origRef, word* origRefTarget, SegmentBuilder* origSegment, ElementSize elementSize,\n      const word* defaultValue, BuilderArena* orphanArena = nullptr)) {\n    KJ_DREQUIRE(elementSize != ElementSize::INLINE_COMPOSITE,\n             \"Use getStructList{Element,Field}() for structs.\");\n\n    if (origRef->isNull()) {\n    useDefault:\n      if (defaultValue == nullptr ||\n          reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n        return ListBuilder();\n      }\n      origRefTarget = copyMessage(\n          origSegment, origRef, reinterpret_cast<const WirePointer*>(defaultValue));\n      defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n    }\n\n    // We must verify that the pointer has the right size.  Unlike in\n    // getWritableStructListPointer(), we never need to \"upgrade\" the data, because this\n    // method is called only for non-struct lists, and there is no allowed upgrade path *to*\n    // a non-struct list, only *from* them.\n\n    WirePointer* ref = origRef;\n    SegmentBuilder* segment = origSegment;\n    word* ptr = followFars(ref, origRefTarget, segment);\n\n    KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n        \"Called getList{Field,Element}() but existing pointer is not a list.\") {\n      goto useDefault;\n    }\n\n    ElementSize oldSize = ref->listRef.elementSize();\n\n    if (oldSize == ElementSize::INLINE_COMPOSITE) {\n      // The existing element size is INLINE_COMPOSITE, though we expected a list of primitives.\n      // The existing data must have been written with a newer version of the protocol.  We\n      // therefore never need to upgrade the data in this case, but we do need to validate that it\n      // is a valid upgrade from what we expected.\n\n      // Read the tag to get the actual element count.\n      WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);\n      KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n          \"INLINE_COMPOSITE list with non-STRUCT elements not supported.\");\n      ptr += POINTER_SIZE_IN_WORDS;\n\n      WordCount dataSize = tag->structRef.dataSize.get();\n      WirePointerCount pointerCount = tag->structRef.ptrCount.get();\n\n      switch (elementSize) {\n        case ElementSize::VOID:\n          // Anything is a valid upgrade from Void.\n          break;\n\n        case ElementSize::BIT:\n          KJ_FAIL_REQUIRE(\n              \"Found struct list where bit list was expected; upgrading boolean lists to structs \"\n              \"is no longer supported.\") {\n            goto useDefault;\n          }\n          break;\n\n        case ElementSize::BYTE:\n        case ElementSize::TWO_BYTES:\n        case ElementSize::FOUR_BYTES:\n        case ElementSize::EIGHT_BYTES:\n          KJ_REQUIRE(dataSize >= 1 * WORDS,\n                     \"Existing list value is incompatible with expected type.\") {\n            goto useDefault;\n          }\n          break;\n\n        case ElementSize::POINTER:\n          KJ_REQUIRE(pointerCount >= 1 * POINTERS,\n                     \"Existing list value is incompatible with expected type.\") {\n            goto useDefault;\n          }\n          // Adjust the pointer to point at the reference segment.\n          ptr += dataSize;\n          break;\n\n        case ElementSize::INLINE_COMPOSITE:\n          KJ_UNREACHABLE;\n      }\n\n      // OK, looks valid.\n\n      return ListBuilder(segment, ptr,\n                         tag->structRef.wordSize() * BITS_PER_WORD / ELEMENTS,\n                         tag->inlineCompositeListElementCount(),\n                         dataSize * BITS_PER_WORD, pointerCount, ElementSize::INLINE_COMPOSITE);\n    } else {\n      BitCount dataSize = dataBitsPerElement(oldSize) * ELEMENTS;\n      WirePointerCount pointerCount = pointersPerElement(oldSize) * ELEMENTS;\n\n      if (elementSize == ElementSize::BIT) {\n        KJ_REQUIRE(oldSize == ElementSize::BIT,\n            \"Found non-bit list where bit list was expected.\") {\n          goto useDefault;\n        }\n      } else {\n        KJ_REQUIRE(oldSize != ElementSize::BIT,\n            \"Found bit list where non-bit list was expected.\") {\n          goto useDefault;\n        }\n        KJ_REQUIRE(dataSize >= dataBitsPerElement(elementSize) * ELEMENTS,\n                   \"Existing list value is incompatible with expected type.\") {\n          goto useDefault;\n        }\n        KJ_REQUIRE(pointerCount >= pointersPerElement(elementSize) * ELEMENTS,\n                   \"Existing list value is incompatible with expected type.\") {\n          goto useDefault;\n        }\n      }\n\n      auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n      return ListBuilder(segment, ptr, step, ref->listRef.elementCount(),\n                         dataSize, pointerCount, oldSize);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListBuilder",
          "args": [
            "segment",
            "ptr",
            "step",
            "ref->listRef.elementCount()",
            "dataSize",
            "pointerCount",
            "oldSize"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "ListBuilder",
          "container": "ListBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "629-635",
          "snippet": "inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                     decltype(BITS / ELEMENTS) step, ElementCount size,\n                     BitCount structDataSize, WirePointerCount structPointerCount,\n                     ElementSize elementSize)\n      : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n        elementCount(size), step(step), structDataSize(structDataSize),\n        structPointerCount(structPointerCount), elementSize(elementSize) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListBuilder {\n  inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                       decltype(BITS / ELEMENTS) step, ElementCount size,\n                       BitCount structDataSize, WirePointerCount structPointerCount,\n                       ElementSize elementSize)\n        : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n          elementCount(size), step(step), structDataSize(structDataSize),\n          structPointerCount(structPointerCount), elementSize(elementSize) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "pointerCount >= pointersPerElement(elementSize) * ELEMENTS",
            "\"Existing list value is incompatible with expected type.\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointersPerElement",
          "args": [
            "elementSize"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "pointersPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "103-105",
          "snippet": "inline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "dataSize >= dataBitsPerElement(elementSize) * ELEMENTS",
            "\"Existing list value is incompatible with expected type.\""
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dataBitsPerElement",
          "args": [
            "elementSize"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "dataBitsPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "99-101",
          "snippet": "inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "oldSize != ElementSize::BIT",
            "\"Found bit list where non-bit list was expected.\""
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "oldSize == ElementSize::BIT",
            "\"Found non-bit list where bit list was expected.\""
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->inlineCompositeListElementCount",
          "args": [],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->structRef.wordSize",
          "args": [],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "wordSize",
          "container": "WirePointer::StructRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "185-187",
          "snippet": "inline WordCount wordSize() const {\n      return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n    }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    inline WordCount wordSize() const {\n          return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "pointerCount >= 1 * POINTERS",
            "\"Existing list value is incompatible with expected type.\""
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "dataSize >= 1 * WORDS",
            "\"Existing list value is incompatible with expected type.\""
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Found struct list where bit list was expected; upgrading boolean lists to structs \"\n              \"is no longer supported.\""
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->structRef.ptrCount.get",
          "args": [],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "tag->kind() == WirePointer::STRUCT",
            "\"INLINE_COMPOSITE list with non-STRUCT elements not supported.\""
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->kind",
          "args": [],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "ref->kind() == WirePointer::LIST",
            "\"Called getList{Field,Element}() but existing pointer is not a list.\""
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "origRefTarget",
            "segment"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyMessage",
          "args": [
            "origSegment",
            "origRef",
            "reinterpret_cast<const WirePointer*>(defaultValue)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListBuilder",
          "args": [],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "getElementSize",
          "container": "ListBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "582-582",
          "snippet": "inline ElementSize getElementSize() const { return elementSize; }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListBuilder {\n  inline ElementSize getElementSize() const { return elementSize; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origRef->isNull",
          "args": [],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "elementSize != ElementSize::INLINE_COMPOSITE",
            "\"Use getStructList{Element,Field}() for structs.\""
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListBuilder getWritableListPointer(\n        WirePointer* origRef, word* origRefTarget, SegmentBuilder* origSegment, ElementSize elementSize,\n        const word* defaultValue, BuilderArena* orphanArena = nullptr)) {\n      KJ_DREQUIRE(elementSize != ElementSize::INLINE_COMPOSITE,\n               \"Use getStructList{Element,Field}() for structs.\");\n  \n      if (origRef->isNull()) {\n      useDefault:\n        if (defaultValue == nullptr ||\n            reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n          return ListBuilder();\n        }\n        origRefTarget = copyMessage(\n            origSegment, origRef, reinterpret_cast<const WirePointer*>(defaultValue));\n        defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n      }\n  \n      // We must verify that the pointer has the right size.  Unlike in\n      // getWritableStructListPointer(), we never need to \"upgrade\" the data, because this\n      // method is called only for non-struct lists, and there is no allowed upgrade path *to*\n      // a non-struct list, only *from* them.\n  \n      WirePointer* ref = origRef;\n      SegmentBuilder* segment = origSegment;\n      word* ptr = followFars(ref, origRefTarget, segment);\n  \n      KJ_REQUIRE(ref->kind() == WirePointer::LIST,\n          \"Called getList{Field,Element}() but existing pointer is not a list.\") {\n        goto useDefault;\n      }\n  \n      ElementSize oldSize = ref->listRef.elementSize();\n  \n      if (oldSize == ElementSize::INLINE_COMPOSITE) {\n        // The existing element size is INLINE_COMPOSITE, though we expected a list of primitives.\n        // The existing data must have been written with a newer version of the protocol.  We\n        // therefore never need to upgrade the data in this case, but we do need to validate that it\n        // is a valid upgrade from what we expected.\n  \n        // Read the tag to get the actual element count.\n        WirePointer* tag = reinterpret_cast<WirePointer*>(ptr);\n        KJ_REQUIRE(tag->kind() == WirePointer::STRUCT,\n            \"INLINE_COMPOSITE list with non-STRUCT elements not supported.\");\n        ptr += POINTER_SIZE_IN_WORDS;\n  \n        WordCount dataSize = tag->structRef.dataSize.get();\n        WirePointerCount pointerCount = tag->structRef.ptrCount.get();\n  \n        switch (elementSize) {\n          case ElementSize::VOID:\n            // Anything is a valid upgrade from Void.\n            break;\n  \n          case ElementSize::BIT:\n            KJ_FAIL_REQUIRE(\n                \"Found struct list where bit list was expected; upgrading boolean lists to structs \"\n                \"is no longer supported.\") {\n              goto useDefault;\n            }\n            break;\n  \n          case ElementSize::BYTE:\n          case ElementSize::TWO_BYTES:\n          case ElementSize::FOUR_BYTES:\n          case ElementSize::EIGHT_BYTES:\n            KJ_REQUIRE(dataSize >= 1 * WORDS,\n                       \"Existing list value is incompatible with expected type.\") {\n              goto useDefault;\n            }\n            break;\n  \n          case ElementSize::POINTER:\n            KJ_REQUIRE(pointerCount >= 1 * POINTERS,\n                       \"Existing list value is incompatible with expected type.\") {\n              goto useDefault;\n            }\n            // Adjust the pointer to point at the reference segment.\n            ptr += dataSize;\n            break;\n  \n          case ElementSize::INLINE_COMPOSITE:\n            KJ_UNREACHABLE;\n        }\n  \n        // OK, looks valid.\n  \n        return ListBuilder(segment, ptr,\n                           tag->structRef.wordSize() * BITS_PER_WORD / ELEMENTS,\n                           tag->inlineCompositeListElementCount(),\n                           dataSize * BITS_PER_WORD, pointerCount, ElementSize::INLINE_COMPOSITE);\n      } else {\n        BitCount dataSize = dataBitsPerElement(oldSize) * ELEMENTS;\n        WirePointerCount pointerCount = pointersPerElement(oldSize) * ELEMENTS;\n  \n        if (elementSize == ElementSize::BIT) {\n          KJ_REQUIRE(oldSize == ElementSize::BIT,\n              \"Found non-bit list where bit list was expected.\") {\n            goto useDefault;\n          }\n        } else {\n          KJ_REQUIRE(oldSize != ElementSize::BIT,\n              \"Found bit list where non-bit list was expected.\") {\n            goto useDefault;\n          }\n          KJ_REQUIRE(dataSize >= dataBitsPerElement(elementSize) * ELEMENTS,\n                     \"Existing list value is incompatible with expected type.\") {\n            goto useDefault;\n          }\n          KJ_REQUIRE(pointerCount >= pointersPerElement(elementSize) * ELEMENTS,\n                     \"Existing list value is incompatible with expected type.\") {\n            goto useDefault;\n          }\n        }\n  \n        auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n        return ListBuilder(segment, ptr, step, ref->listRef.elementCount(),\n                           dataSize, pointerCount, oldSize);\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1059-1064",
    "snippet": "static KJ_ALWAYS_INLINE(ListBuilder getWritableListPointer(\n      WirePointer* origRef, SegmentBuilder* origSegment, ElementSize elementSize,\n      const word* defaultValue)) {\n    return getWritableListPointer(origRef, origRef->target(), origSegment, elementSize,\n                                  defaultValue);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getWritableListPointer",
          "args": [
            "origRef",
            "origRef->target()",
            "origSegment",
            "elementSize",
            "defaultValue"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origRef->target",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListBuilder getWritableListPointer(\n        WirePointer* origRef, SegmentBuilder* origSegment, ElementSize elementSize,\n        const word* defaultValue)) {\n      return getWritableListPointer(origRef, origRef->target(), origSegment, elementSize,\n                                    defaultValue);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1033-1057",
    "snippet": "static KJ_ALWAYS_INLINE(ListBuilder initStructListPointer(\n      WirePointer* ref, SegmentBuilder* segment, ElementCount elementCount,\n      StructSize elementSize, BuilderArena* orphanArena = nullptr)) {\n    auto wordsPerElement = elementSize.total() / ELEMENTS;\n\n    // Allocate the list, prefixed by a single WirePointer.\n    WordCount wordCount = elementCount * wordsPerElement;\n    word* ptr = allocate(ref, segment, POINTER_SIZE_IN_WORDS + wordCount, WirePointer::LIST,\n                         orphanArena);\n\n    // Initialize the pointer.\n    // INLINE_COMPOSITE lists replace the element count with the word count.\n    ref->listRef.setInlineComposite(wordCount);\n\n    // Initialize the list tag.\n    reinterpret_cast<WirePointer*>(ptr)->setKindAndInlineCompositeListElementCount(\n        WirePointer::STRUCT, elementCount);\n    reinterpret_cast<WirePointer*>(ptr)->structRef.set(elementSize);\n    ptr += POINTER_SIZE_IN_WORDS;\n\n    // Build the ListBuilder.\n    return ListBuilder(segment, ptr, wordsPerElement * BITS_PER_WORD, elementCount,\n                       elementSize.data * BITS_PER_WORD, elementSize.pointers,\n                       ElementSize::INLINE_COMPOSITE);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListBuilder",
          "args": [
            "segment",
            "ptr",
            "wordsPerElement * BITS_PER_WORD",
            "elementCount",
            "elementSize.data * BITS_PER_WORD",
            "elementSize.pointers",
            "ElementSize::INLINE_COMPOSITE"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ListBuilder",
          "container": "ListBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "629-635",
          "snippet": "inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                     decltype(BITS / ELEMENTS) step, ElementCount size,\n                     BitCount structDataSize, WirePointerCount structPointerCount,\n                     ElementSize elementSize)\n      : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n        elementCount(size), step(step), structDataSize(structDataSize),\n        structPointerCount(structPointerCount), elementSize(elementSize) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListBuilder {\n  inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                       decltype(BITS / ELEMENTS) step, ElementCount size,\n                       BitCount structDataSize, WirePointerCount structPointerCount,\n                       ElementSize elementSize)\n        : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n          elementCount(size), step(step), structDataSize(structDataSize),\n          structPointerCount(structPointerCount), elementSize(elementSize) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "elementSize"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "WirePointer::STRUCT",
            "elementCount"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.setInlineComposite",
          "args": [
            "wordCount"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "POINTER_SIZE_IN_WORDS + wordCount",
            "WirePointer::LIST",
            "orphanArena"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementSize.total",
          "args": [],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "total",
          "container": "StructSize",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "174-174",
          "snippet": "inline constexpr WordCount total() const { return data + pointers * WORDS_PER_POINTER; }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructSize {\n  inline constexpr WordCount total() const { return data + pointers * WORDS_PER_POINTER; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListBuilder initStructListPointer(\n        WirePointer* ref, SegmentBuilder* segment, ElementCount elementCount,\n        StructSize elementSize, BuilderArena* orphanArena = nullptr)) {\n      auto wordsPerElement = elementSize.total() / ELEMENTS;\n  \n      // Allocate the list, prefixed by a single WirePointer.\n      WordCount wordCount = elementCount * wordsPerElement;\n      word* ptr = allocate(ref, segment, POINTER_SIZE_IN_WORDS + wordCount, WirePointer::LIST,\n                           orphanArena);\n  \n      // Initialize the pointer.\n      // INLINE_COMPOSITE lists replace the element count with the word count.\n      ref->listRef.setInlineComposite(wordCount);\n  \n      // Initialize the list tag.\n      reinterpret_cast<WirePointer*>(ptr)->setKindAndInlineCompositeListElementCount(\n          WirePointer::STRUCT, elementCount);\n      reinterpret_cast<WirePointer*>(ptr)->structRef.set(elementSize);\n      ptr += POINTER_SIZE_IN_WORDS;\n  \n      // Build the ListBuilder.\n      return ListBuilder(segment, ptr, wordsPerElement * BITS_PER_WORD, elementCount,\n                         elementSize.data * BITS_PER_WORD, elementSize.pointers,\n                         ElementSize::INLINE_COMPOSITE);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "1010-1031",
    "snippet": "static KJ_ALWAYS_INLINE(ListBuilder initListPointer(\n      WirePointer* ref, SegmentBuilder* segment, ElementCount elementCount,\n      ElementSize elementSize, BuilderArena* orphanArena = nullptr)) {\n    KJ_DREQUIRE(elementSize != ElementSize::INLINE_COMPOSITE,\n        \"Should have called initStructListPointer() instead.\");\n\n    BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;\n    WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;\n    auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n\n    // Calculate size of the list.\n    WordCount wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n\n    // Allocate the list.\n    word* ptr = allocate(ref, segment, wordCount, WirePointer::LIST, orphanArena);\n\n    // Initialize the pointer.\n    ref->listRef.set(elementSize, elementCount);\n\n    // Build the ListBuilder.\n    return ListBuilder(segment, ptr, step, elementCount, dataSize, pointerCount, elementSize);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListBuilder",
          "args": [
            "segment",
            "ptr",
            "step",
            "elementCount",
            "dataSize",
            "pointerCount",
            "elementSize"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "ListBuilder",
          "container": "ListBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "629-635",
          "snippet": "inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                     decltype(BITS / ELEMENTS) step, ElementCount size,\n                     BitCount structDataSize, WirePointerCount structPointerCount,\n                     ElementSize elementSize)\n      : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n        elementCount(size), step(step), structDataSize(structDataSize),\n        structPointerCount(structPointerCount), elementSize(elementSize) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nListBuilder {\n  inline ListBuilder(SegmentBuilder* segment, void* ptr,\n                       decltype(BITS / ELEMENTS) step, ElementCount size,\n                       BitCount structDataSize, WirePointerCount structPointerCount,\n                       ElementSize elementSize)\n        : segment(segment), ptr(reinterpret_cast<byte*>(ptr)),\n          elementCount(size), step(step), structDataSize(structDataSize),\n          structPointerCount(structPointerCount), elementSize(elementSize) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->listRef.set",
          "args": [
            "elementSize",
            "elementCount"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "wordCount",
            "WirePointer::LIST",
            "orphanArena"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToWords",
          "args": [
            "ElementCount64(elementCount) * step"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "elementCount"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pointersPerElement",
          "args": [
            "elementSize"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "pointersPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "103-105",
          "snippet": "inline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline constexpr PointersPerElement pointersPerElement(ElementSize size) {\n  return size == ElementSize::POINTER ? 1 * POINTERS / ELEMENTS : 0 * POINTERS / ELEMENTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dataBitsPerElement",
          "args": [
            "elementSize"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "dataBitsPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "99-101",
          "snippet": "inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "elementSize != ElementSize::INLINE_COMPOSITE",
            "\"Should have called initStructListPointer() instead.\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ListBuilder initListPointer(\n        WirePointer* ref, SegmentBuilder* segment, ElementCount elementCount,\n        ElementSize elementSize, BuilderArena* orphanArena = nullptr)) {\n      KJ_DREQUIRE(elementSize != ElementSize::INLINE_COMPOSITE,\n          \"Should have called initStructListPointer() instead.\");\n  \n      BitCount dataSize = dataBitsPerElement(elementSize) * ELEMENTS;\n      WirePointerCount pointerCount = pointersPerElement(elementSize) * ELEMENTS;\n      auto step = (dataSize + pointerCount * BITS_PER_POINTER) / ELEMENTS;\n  \n      // Calculate size of the list.\n      WordCount wordCount = roundBitsUpToWords(ElementCount64(elementCount) * step);\n  \n      // Allocate the list.\n      word* ptr = allocate(ref, segment, wordCount, WirePointer::LIST, orphanArena);\n  \n      // Initialize the pointer.\n      ref->listRef.set(elementSize, elementCount);\n  \n      // Build the ListBuilder.\n      return ListBuilder(segment, ptr, step, elementCount, dataSize, pointerCount, elementSize);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "943-1008",
    "snippet": "static KJ_ALWAYS_INLINE(StructBuilder getWritableStructPointer(\n      WirePointer* ref, word* refTarget, SegmentBuilder* segment, StructSize size,\n      const word* defaultValue, BuilderArena* orphanArena = nullptr)) {\n    if (ref->isNull()) {\n    useDefault:\n      if (defaultValue == nullptr ||\n          reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n        return initStructPointer(ref, segment, size, orphanArena);\n      }\n      refTarget = copyMessage(segment, ref, reinterpret_cast<const WirePointer*>(defaultValue));\n      defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n    }\n\n    WirePointer* oldRef = ref;\n    SegmentBuilder* oldSegment = segment;\n    word* oldPtr = followFars(oldRef, refTarget, oldSegment);\n\n    KJ_REQUIRE(oldRef->kind() == WirePointer::STRUCT,\n        \"Message contains non-struct pointer where struct pointer was expected.\") {\n      goto useDefault;\n    }\n\n    WordCount oldDataSize = oldRef->structRef.dataSize.get();\n    WirePointerCount oldPointerCount = oldRef->structRef.ptrCount.get();\n    WirePointer* oldPointerSection =\n        reinterpret_cast<WirePointer*>(oldPtr + oldDataSize);\n\n    if (oldDataSize < size.data || oldPointerCount < size.pointers) {\n      // The space allocated for this struct is too small.  Unlike with readers, we can't just\n      // run with it and do bounds checks at access time, because how would we handle writes?\n      // Instead, we have to copy the struct to a new space now.\n\n      WordCount newDataSize = kj::max(oldDataSize, size.data);\n      WirePointerCount newPointerCount = kj::max(oldPointerCount, size.pointers);\n      WordCount totalSize = newDataSize + newPointerCount * WORDS_PER_POINTER;\n\n      // Don't let allocate() zero out the object just yet.\n      zeroPointerAndFars(segment, ref);\n\n      word* ptr = allocate(ref, segment, totalSize, WirePointer::STRUCT, orphanArena);\n      ref->structRef.set(newDataSize, newPointerCount);\n\n      // Copy data section.\n      memcpy(ptr, oldPtr, oldDataSize * BYTES_PER_WORD / BYTES);\n\n      // Copy pointer section.\n      WirePointer* newPointerSection = reinterpret_cast<WirePointer*>(ptr + newDataSize);\n      for (uint i = 0; i < oldPointerCount / POINTERS; i++) {\n        transferPointer(segment, newPointerSection + i, oldSegment, oldPointerSection + i);\n      }\n\n      // Zero out old location.  This has two purposes:\n      // 1) We don't want to leak the original contents of the struct when the message is written\n      //    out as it may contain secrets that the caller intends to remove from the new copy.\n      // 2) Zeros will be deflated by packing, making this dead memory almost-free if it ever\n      //    hits the wire.\n      memset(oldPtr, 0,\n             (oldDataSize + oldPointerCount * WORDS_PER_POINTER) * BYTES_PER_WORD / BYTES);\n\n      return StructBuilder(segment, ptr, newPointerSection, newDataSize * BITS_PER_WORD,\n                           newPointerCount);\n    } else {\n      return StructBuilder(oldSegment, oldPtr, oldPointerSection, oldDataSize * BITS_PER_WORD,\n                           oldPointerCount);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructBuilder",
          "args": [
            "oldSegment",
            "oldPtr",
            "oldPointerSection",
            "oldDataSize * BITS_PER_WORD",
            "oldPointerCount"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "StructBuilder",
          "container": "StructBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "472-475",
          "snippet": "inline StructBuilder(SegmentBuilder* segment, void* data, WirePointer* pointers,\n                       BitCount dataSize, WirePointerCount pointerCount)\n      : segment(segment), data(data), pointers(pointers),\n        dataSize(dataSize), pointerCount(pointerCount) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructBuilder {\n  inline StructBuilder(SegmentBuilder* segment, void* data, WirePointer* pointers,\n                         BitCount dataSize, WirePointerCount pointerCount)\n        : segment(segment), data(data), pointers(pointers),\n          dataSize(dataSize), pointerCount(pointerCount) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "oldPtr",
            "0",
            "(oldDataSize + oldPointerCount * WORDS_PER_POINTER) * BYTES_PER_WORD / BYTES"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transferPointer",
          "args": [
            "segment",
            "newPointerSection + i",
            "oldSegment",
            "oldPointerSection + i"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "transferPointer",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "856-877",
          "snippet": "static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                              SegmentBuilder* srcSegment, WirePointer* src) {\n    // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n    // be in different segments.  Not always-inline because this is rarely used.\n    //\n    // Caller MUST zero out the source pointer after calling this, to make sure no later code\n    // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n    // this zeroing itself because many callers transfer several pointers in a loop then zero out\n    // the whole section.\n\n    KJ_DASSERT(dst->isNull());\n    // We expect the caller to ensure the target is already null so won't leak.\n\n    if (src->isNull()) {\n      memset(dst, 0, sizeof(WirePointer));\n    } else if (src->kind() == WirePointer::FAR) {\n      // Far pointers are position-independent, so we can just copy.\n      memcpy(dst, src, sizeof(WirePointer));\n    } else {\n      transferPointer(dstSegment, dst, srcSegment, src, src->target());\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                                SegmentBuilder* srcSegment, WirePointer* src) {\n      // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n      // be in different segments.  Not always-inline because this is rarely used.\n      //\n      // Caller MUST zero out the source pointer after calling this, to make sure no later code\n      // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n      // this zeroing itself because many callers transfer several pointers in a loop then zero out\n      // the whole section.\n  \n      KJ_DASSERT(dst->isNull());\n      // We expect the caller to ensure the target is already null so won't leak.\n  \n      if (src->isNull()) {\n        memset(dst, 0, sizeof(WirePointer));\n      } else if (src->kind() == WirePointer::FAR) {\n        // Far pointers are position-independent, so we can just copy.\n        memcpy(dst, src, sizeof(WirePointer));\n      } else {\n        transferPointer(dstSegment, dst, srcSegment, src, src->target());\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr + newDataSize"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "oldPtr",
            "oldDataSize * BYTES_PER_WORD / BYTES"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->structRef.set",
          "args": [
            "newDataSize",
            "newPointerCount"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "totalSize",
            "WirePointer::STRUCT",
            "orphanArena"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zeroPointerAndFars",
          "args": [
            "segment",
            "ref"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "oldPointerCount",
            "size.pointers"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "oldPtr + oldDataSize"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldRef->structRef.ptrCount.get",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "oldRef->kind() == WirePointer::STRUCT",
            "\"Message contains non-struct pointer where struct pointer was expected.\""
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldRef->kind",
          "args": [],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "oldRef",
            "refTarget",
            "oldSegment"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyMessage",
          "args": [
            "segment",
            "ref",
            "reinterpret_cast<const WirePointer*>(defaultValue)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStructPointer",
          "args": [
            "ref",
            "segment",
            "size",
            "orphanArena"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "defaultValue"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(StructBuilder getWritableStructPointer(\n        WirePointer* ref, word* refTarget, SegmentBuilder* segment, StructSize size,\n        const word* defaultValue, BuilderArena* orphanArena = nullptr)) {\n      if (ref->isNull()) {\n      useDefault:\n        if (defaultValue == nullptr ||\n            reinterpret_cast<const WirePointer*>(defaultValue)->isNull()) {\n          return initStructPointer(ref, segment, size, orphanArena);\n        }\n        refTarget = copyMessage(segment, ref, reinterpret_cast<const WirePointer*>(defaultValue));\n        defaultValue = nullptr;  // If the default value is itself invalid, don't use it again.\n      }\n  \n      WirePointer* oldRef = ref;\n      SegmentBuilder* oldSegment = segment;\n      word* oldPtr = followFars(oldRef, refTarget, oldSegment);\n  \n      KJ_REQUIRE(oldRef->kind() == WirePointer::STRUCT,\n          \"Message contains non-struct pointer where struct pointer was expected.\") {\n        goto useDefault;\n      }\n  \n      WordCount oldDataSize = oldRef->structRef.dataSize.get();\n      WirePointerCount oldPointerCount = oldRef->structRef.ptrCount.get();\n      WirePointer* oldPointerSection =\n          reinterpret_cast<WirePointer*>(oldPtr + oldDataSize);\n  \n      if (oldDataSize < size.data || oldPointerCount < size.pointers) {\n        // The space allocated for this struct is too small.  Unlike with readers, we can't just\n        // run with it and do bounds checks at access time, because how would we handle writes?\n        // Instead, we have to copy the struct to a new space now.\n  \n        WordCount newDataSize = kj::max(oldDataSize, size.data);\n        WirePointerCount newPointerCount = kj::max(oldPointerCount, size.pointers);\n        WordCount totalSize = newDataSize + newPointerCount * WORDS_PER_POINTER;\n  \n        // Don't let allocate() zero out the object just yet.\n        zeroPointerAndFars(segment, ref);\n  \n        word* ptr = allocate(ref, segment, totalSize, WirePointer::STRUCT, orphanArena);\n        ref->structRef.set(newDataSize, newPointerCount);\n  \n        // Copy data section.\n        memcpy(ptr, oldPtr, oldDataSize * BYTES_PER_WORD / BYTES);\n  \n        // Copy pointer section.\n        WirePointer* newPointerSection = reinterpret_cast<WirePointer*>(ptr + newDataSize);\n        for (uint i = 0; i < oldPointerCount / POINTERS; i++) {\n          transferPointer(segment, newPointerSection + i, oldSegment, oldPointerSection + i);\n        }\n  \n        // Zero out old location.  This has two purposes:\n        // 1) We don't want to leak the original contents of the struct when the message is written\n        //    out as it may contain secrets that the caller intends to remove from the new copy.\n        // 2) Zeros will be deflated by packing, making this dead memory almost-free if it ever\n        //    hits the wire.\n        memset(oldPtr, 0,\n               (oldDataSize + oldPointerCount * WORDS_PER_POINTER) * BYTES_PER_WORD / BYTES);\n  \n        return StructBuilder(segment, ptr, newPointerSection, newDataSize * BITS_PER_WORD,\n                             newPointerCount);\n      } else {\n        return StructBuilder(oldSegment, oldPtr, oldPointerSection, oldDataSize * BITS_PER_WORD,\n                             oldPointerCount);\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "938-941",
    "snippet": "static KJ_ALWAYS_INLINE(StructBuilder getWritableStructPointer(\n      WirePointer* ref, SegmentBuilder* segment, StructSize size, const word* defaultValue)) {\n    return getWritableStructPointer(ref, ref->target(), segment, size, defaultValue);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getWritableStructPointer",
          "args": [
            "ref",
            "ref->target()",
            "segment",
            "size",
            "defaultValue"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(StructBuilder getWritableStructPointer(\n        WirePointer* ref, SegmentBuilder* segment, StructSize size, const word* defaultValue)) {\n      return getWritableStructPointer(ref, ref->target(), segment, size, defaultValue);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "924-936",
    "snippet": "static KJ_ALWAYS_INLINE(StructBuilder initStructPointer(\n      WirePointer* ref, SegmentBuilder* segment, StructSize size,\n      BuilderArena* orphanArena = nullptr)) {\n    // Allocate space for the new struct.  Newly-allocated space is automatically zeroed.\n    word* ptr = allocate(ref, segment, size.total(), WirePointer::STRUCT, orphanArena);\n\n    // Initialize the pointer.\n    ref->structRef.set(size);\n\n    // Build the StructBuilder.\n    return StructBuilder(segment, ptr, reinterpret_cast<WirePointer*>(ptr + size.data),\n                         size.data * BITS_PER_WORD, size.pointers);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructBuilder",
          "args": [
            "segment",
            "ptr",
            "reinterpret_cast<WirePointer*>(ptr + size.data)",
            "size.data * BITS_PER_WORD",
            "size.pointers"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "StructBuilder",
          "container": "StructBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "472-475",
          "snippet": "inline StructBuilder(SegmentBuilder* segment, void* data, WirePointer* pointers,\n                       BitCount dataSize, WirePointerCount pointerCount)\n      : segment(segment), data(data), pointers(pointers),\n        dataSize(dataSize), pointerCount(pointerCount) {}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructBuilder {\n  inline StructBuilder(SegmentBuilder* segment, void* data, WirePointer* pointers,\n                         BitCount dataSize, WirePointerCount pointerCount)\n        : segment(segment), data(data), pointers(pointers),\n          dataSize(dataSize), pointerCount(pointerCount) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr + size.data"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->structRef.set",
          "args": [
            "size"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "allocate",
          "args": [
            "ref",
            "segment",
            "size.total()",
            "WirePointer::STRUCT",
            "orphanArena"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size.total",
          "args": [],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "total",
          "container": "StructSize",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "174-174",
          "snippet": "inline constexpr WordCount total() const { return data + pointers * WORDS_PER_POINTER; }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nStructSize {\n  inline constexpr WordCount total() const { return data + pointers * WORDS_PER_POINTER; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(StructBuilder initStructPointer(\n        WirePointer* ref, SegmentBuilder* segment, StructSize size,\n        BuilderArena* orphanArena = nullptr)) {\n      // Allocate space for the new struct.  Newly-allocated space is automatically zeroed.\n      word* ptr = allocate(ref, segment, size.total(), WirePointer::STRUCT, orphanArena);\n  \n      // Initialize the pointer.\n      ref->structRef.set(size);\n  \n      // Build the StructBuilder.\n      return StructBuilder(segment, ptr, reinterpret_cast<WirePointer*>(ptr + size.data),\n                           size.data * BITS_PER_WORD, size.pointers);\n    }\n}"
  },
  {
    "function_name": "transferPointer",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "879-920",
    "snippet": "static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                              SegmentBuilder* srcSegment, const WirePointer* srcTag,\n                              word* srcPtr) {\n    // Like the other overload, but splits src into a tag and a target.  Particularly useful for\n    // OrphanBuilder.\n\n    if (dstSegment == srcSegment) {\n      // Same segment, so create a direct pointer.\n      dst->setKindAndTarget(srcTag->kind(), srcPtr, dstSegment);\n\n      // We can just copy the upper 32 bits.  (Use memcpy() to comply with aliasing rules.)\n      memcpy(&dst->upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n    } else {\n      // Need to create a far pointer.  Try to allocate it in the same segment as the source, so\n      // that it doesn't need to be a double-far.\n\n      WirePointer* landingPad =\n          reinterpret_cast<WirePointer*>(srcSegment->allocate(1 * WORDS));\n      if (landingPad == nullptr) {\n        // Darn, need a double-far.\n        auto allocation = srcSegment->getArena()->allocate(2 * WORDS);\n        SegmentBuilder* farSegment = allocation.segment;\n        landingPad = reinterpret_cast<WirePointer*>(allocation.words);\n\n        landingPad[0].setFar(false, srcSegment->getOffsetTo(srcPtr));\n        landingPad[0].farRef.segmentId.set(srcSegment->getSegmentId());\n\n        landingPad[1].setKindWithZeroOffset(srcTag->kind());\n        memcpy(&landingPad[1].upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n\n        dst->setFar(true, farSegment->getOffsetTo(reinterpret_cast<word*>(landingPad)));\n        dst->farRef.set(farSegment->getSegmentId());\n      } else {\n        // Simple landing pad is just a pointer.\n        landingPad->setKindAndTarget(srcTag->kind(), srcPtr, srcSegment);\n        memcpy(&landingPad->upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n\n        dst->setFar(false, srcSegment->getOffsetTo(reinterpret_cast<word*>(landingPad)));\n        dst->farRef.set(srcSegment->getSegmentId());\n      }\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dst->farRef.set",
          "args": [
            "srcSegment->getSegmentId()"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcSegment->getSegmentId",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst->setFar",
          "args": [
            "false",
            "srcSegment->getOffsetTo(reinterpret_cast<word*>(landingPad))"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcSegment->getOffsetTo",
          "args": [
            "reinterpret_cast<word*>(landingPad)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "landingPad"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&landingPad->upper32Bits",
            "&srcTag->upper32Bits",
            "sizeof(srcTag->upper32Bits)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "landingPad->setKindAndTarget",
          "args": [
            "srcTag->kind()",
            "srcPtr",
            "srcSegment"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcTag->kind",
          "args": [],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "farSegment->getSegmentId",
          "args": [],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst->setFar",
          "args": [
            "true",
            "farSegment->getOffsetTo(reinterpret_cast<word*>(landingPad))"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "farSegment->getOffsetTo",
          "args": [
            "reinterpret_cast<word*>(landingPad)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "landingPad"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&landingPad[1].upper32Bits",
            "&srcTag->upper32Bits",
            "sizeof(srcTag->upper32Bits)"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "landingPad[1].setKindWithZeroOffset",
          "args": [
            "srcTag->kind()"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcSegment->getSegmentId",
          "args": [],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "landingPad[0].setFar",
          "args": [
            "false",
            "srcSegment->getOffsetTo(srcPtr)"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcSegment->getOffsetTo",
          "args": [
            "srcPtr"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "allocation.words"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcSegment->getArena",
          "args": [
            "2 * WORDS"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcSegment->getArena",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "srcSegment->allocate(1 * WORDS)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcSegment->allocate",
          "args": [
            "1 * WORDS"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dst->upper32Bits",
            "&srcTag->upper32Bits",
            "sizeof(srcTag->upper32Bits)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst->setKindAndTarget",
          "args": [
            "srcTag->kind()",
            "srcPtr",
            "dstSegment"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                                SegmentBuilder* srcSegment, const WirePointer* srcTag,\n                                word* srcPtr) {\n      // Like the other overload, but splits src into a tag and a target.  Particularly useful for\n      // OrphanBuilder.\n  \n      if (dstSegment == srcSegment) {\n        // Same segment, so create a direct pointer.\n        dst->setKindAndTarget(srcTag->kind(), srcPtr, dstSegment);\n  \n        // We can just copy the upper 32 bits.  (Use memcpy() to comply with aliasing rules.)\n        memcpy(&dst->upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n      } else {\n        // Need to create a far pointer.  Try to allocate it in the same segment as the source, so\n        // that it doesn't need to be a double-far.\n  \n        WirePointer* landingPad =\n            reinterpret_cast<WirePointer*>(srcSegment->allocate(1 * WORDS));\n        if (landingPad == nullptr) {\n          // Darn, need a double-far.\n          auto allocation = srcSegment->getArena()->allocate(2 * WORDS);\n          SegmentBuilder* farSegment = allocation.segment;\n          landingPad = reinterpret_cast<WirePointer*>(allocation.words);\n  \n          landingPad[0].setFar(false, srcSegment->getOffsetTo(srcPtr));\n          landingPad[0].farRef.segmentId.set(srcSegment->getSegmentId());\n  \n          landingPad[1].setKindWithZeroOffset(srcTag->kind());\n          memcpy(&landingPad[1].upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n  \n          dst->setFar(true, farSegment->getOffsetTo(reinterpret_cast<word*>(landingPad)));\n          dst->farRef.set(farSegment->getSegmentId());\n        } else {\n          // Simple landing pad is just a pointer.\n          landingPad->setKindAndTarget(srcTag->kind(), srcPtr, srcSegment);\n          memcpy(&landingPad->upper32Bits, &srcTag->upper32Bits, sizeof(srcTag->upper32Bits));\n  \n          dst->setFar(false, srcSegment->getOffsetTo(reinterpret_cast<word*>(landingPad)));\n          dst->farRef.set(srcSegment->getSegmentId());\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "transferPointer",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "856-877",
    "snippet": "static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                              SegmentBuilder* srcSegment, WirePointer* src) {\n    // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n    // be in different segments.  Not always-inline because this is rarely used.\n    //\n    // Caller MUST zero out the source pointer after calling this, to make sure no later code\n    // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n    // this zeroing itself because many callers transfer several pointers in a loop then zero out\n    // the whole section.\n\n    KJ_DASSERT(dst->isNull());\n    // We expect the caller to ensure the target is already null so won't leak.\n\n    if (src->isNull()) {\n      memset(dst, 0, sizeof(WirePointer));\n    } else if (src->kind() == WirePointer::FAR) {\n      // Far pointers are position-independent, so we can just copy.\n      memcpy(dst, src, sizeof(WirePointer));\n    } else {\n      transferPointer(dstSegment, dst, srcSegment, src, src->target());\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "src->target",
          "args": [],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "sizeof(WirePointer)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->kind",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "0",
            "sizeof(WirePointer)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src->isNull",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "dst->isNull()"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst->isNull",
          "args": [],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void transferPointer(SegmentBuilder* dstSegment, WirePointer* dst,\n                                SegmentBuilder* srcSegment, WirePointer* src) {\n      // Make *dst point to the same object as *src.  Both must reside in the same message, but can\n      // be in different segments.  Not always-inline because this is rarely used.\n      //\n      // Caller MUST zero out the source pointer after calling this, to make sure no later code\n      // mistakenly thinks the source location still owns the object.  transferPointer() doesn't do\n      // this zeroing itself because many callers transfer several pointers in a loop then zero out\n      // the whole section.\n  \n      KJ_DASSERT(dst->isNull());\n      // We expect the caller to ensure the target is already null so won't leak.\n  \n      if (src->isNull()) {\n        memset(dst, 0, sizeof(WirePointer));\n      } else if (src->kind() == WirePointer::FAR) {\n        // Far pointers are position-independent, so we can just copy.\n        memcpy(dst, src, sizeof(WirePointer));\n      } else {\n        transferPointer(dstSegment, dst, srcSegment, src, src->target());\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "743-756",
    "snippet": "static KJ_ALWAYS_INLINE(\n      void copyStruct(SegmentBuilder* segment, word* dst, const word* src,\n                      WordCount dataSize, WirePointerCount pointerCount)) {\n    memcpy(dst, src, dataSize * BYTES_PER_WORD / BYTES);\n\n    const WirePointer* srcRefs = reinterpret_cast<const WirePointer*>(src + dataSize);\n    WirePointer* dstRefs = reinterpret_cast<WirePointer*>(dst + dataSize);\n\n    for (uint i = 0; i < pointerCount / POINTERS; i++) {\n      SegmentBuilder* subSegment = segment;\n      WirePointer* dstRef = dstRefs + i;\n      copyMessage(subSegment, dstRef, srcRefs + i);\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copyMessage",
          "args": [
            "subSegment",
            "dstRef",
            "srcRefs + i"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "dst + dataSize"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "src + dataSize"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "dataSize * BYTES_PER_WORD / BYTES"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(\n        void copyStruct(SegmentBuilder* segment, word* dst, const word* src,\n                        WordCount dataSize, WirePointerCount pointerCount)) {\n      memcpy(dst, src, dataSize * BYTES_PER_WORD / BYTES);\n  \n      const WirePointer* srcRefs = reinterpret_cast<const WirePointer*>(src + dataSize);\n      WirePointer* dstRefs = reinterpret_cast<WirePointer*>(dst + dataSize);\n  \n      for (uint i = 0; i < pointerCount / POINTERS; i++) {\n        SegmentBuilder* subSegment = segment;\n        WirePointer* dstRef = dstRefs + i;\n        copyMessage(subSegment, dstRef, srcRefs + i);\n      }\n    }\n}"
  },
  {
    "function_name": "totalSize",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "609-738",
    "snippet": "static MessageSizeCounts totalSize(\n      SegmentReader* segment, const WirePointer* ref, int nestingLimit) {\n    // Compute the total size of the object pointed to, not counting far pointer overhead.\n\n    MessageSizeCounts result = { 0 * WORDS, 0 };\n\n    if (ref->isNull()) {\n      return result;\n    }\n\n    KJ_REQUIRE(nestingLimit > 0, \"Message is too deeply-nested.\") {\n      return result;\n    }\n    --nestingLimit;\n\n    const word* ptr = followFars(ref, ref->target(), segment);\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT: {\n        KJ_REQUIRE(boundsCheck(segment, ptr, ptr + ref->structRef.wordSize()),\n                   \"Message contained out-of-bounds struct pointer.\") {\n          return result;\n        }\n        result.wordCount += ref->structRef.wordSize();\n\n        const WirePointer* pointerSection =\n            reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get());\n        uint count = ref->structRef.ptrCount.get() / POINTERS;\n        for (uint i = 0; i < count; i++) {\n          result += totalSize(segment, pointerSection + i, nestingLimit);\n        }\n        break;\n      }\n      case WirePointer::LIST: {\n        switch (ref->listRef.elementSize()) {\n          case ElementSize::VOID:\n            // Nothing.\n            break;\n          case ElementSize::BIT:\n          case ElementSize::BYTE:\n          case ElementSize::TWO_BYTES:\n          case ElementSize::FOUR_BYTES:\n          case ElementSize::EIGHT_BYTES: {\n            WordCount64 totalWords = roundBitsUpToWords(\n                ElementCount64(ref->listRef.elementCount()) *\n                dataBitsPerElement(ref->listRef.elementSize()));\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + totalWords),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n            result.wordCount += totalWords;\n            break;\n          }\n          case ElementSize::POINTER: {\n            WirePointerCount count = ref->listRef.elementCount() * (POINTERS / ELEMENTS);\n\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + count * WORDS_PER_POINTER),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n\n            result.wordCount += count * WORDS_PER_POINTER;\n\n            for (uint i = 0; i < count / POINTERS; i++) {\n              result += totalSize(segment, reinterpret_cast<const WirePointer*>(ptr) + i,\n                                  nestingLimit);\n            }\n            break;\n          }\n          case ElementSize::INLINE_COMPOSITE: {\n            WordCount wordCount = ref->listRef.inlineCompositeWordCount();\n            KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount + POINTER_SIZE_IN_WORDS),\n                       \"Message contained out-of-bounds list pointer.\") {\n              return result;\n            }\n\n            const WirePointer* elementTag = reinterpret_cast<const WirePointer*>(ptr);\n            ElementCount count = elementTag->inlineCompositeListElementCount();\n\n            KJ_REQUIRE(elementTag->kind() == WirePointer::STRUCT,\n                       \"Don't know how to handle non-STRUCT inline composite.\") {\n              return result;\n            }\n\n            auto actualSize = elementTag->structRef.wordSize() / ELEMENTS * ElementCount64(count);\n            KJ_REQUIRE(actualSize <= wordCount,\n                       \"Struct list pointer's elements overran size.\") {\n              return result;\n            }\n\n            // We count the actual size rather than the claimed word count because that's what\n            // we'll end up with if we make a copy.\n            result.wordCount += actualSize + POINTER_SIZE_IN_WORDS;\n\n            WordCount dataSize = elementTag->structRef.dataSize.get();\n            WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();\n\n            if (pointerCount > 0 * POINTERS) {\n              const word* pos = ptr + POINTER_SIZE_IN_WORDS;\n              for (uint i = 0; i < count / ELEMENTS; i++) {\n                pos += dataSize;\n\n                for (uint j = 0; j < pointerCount / POINTERS; j++) {\n                  result += totalSize(segment, reinterpret_cast<const WirePointer*>(pos),\n                                      nestingLimit);\n                  pos += POINTER_SIZE_IN_WORDS;\n                }\n              }\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case WirePointer::FAR:\n        KJ_FAIL_ASSERT(\"Unexpected FAR pointer.\") {\n          break;\n        }\n        break;\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n          result.capCount++;\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n\n    return result;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Unknown pointer type.\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isCapability",
          "args": [],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unexpected FAR pointer.\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "pos"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementTag->structRef.ptrCount.get",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "actualSize <= wordCount",
            "\"Struct list pointer's elements overran size.\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "count"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementTag->structRef.wordSize",
          "args": [],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "wordSize",
          "container": "WirePointer::StructRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "185-187",
          "snippet": "inline WordCount wordSize() const {\n      return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n    }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    inline WordCount wordSize() const {\n          return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "elementTag->kind() == WirePointer::STRUCT",
            "\"Don't know how to handle non-STRUCT inline composite.\""
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementTag->kind",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elementTag->inlineCompositeListElementCount",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr + wordCount + POINTER_SIZE_IN_WORDS)",
            "\"Message contained out-of-bounds list pointer.\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr + wordCount + POINTER_SIZE_IN_WORDS"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.inlineCompositeWordCount",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr + count * WORDS_PER_POINTER)",
            "\"Message contained out-of-bounds list pointer.\""
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr + count * WORDS_PER_POINTER"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr + totalWords)",
            "\"Message contained out-of-bounds list pointer.\""
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr + totalWords"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToWords",
          "args": [
            "ElementCount64(ref->listRef.elementCount()) *\n                dataBitsPerElement(ref->listRef.elementSize())"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dataBitsPerElement",
          "args": [
            "ref->listRef.elementSize()"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "dataBitsPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "99-101",
          "snippet": "inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "ref->listRef.elementCount()"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementCount",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->listRef.elementSize",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "ptr + ref->structRef.dataSize.get()"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr + ref->structRef.wordSize())",
            "\"Message contained out-of-bounds struct pointer.\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr + ref->structRef.wordSize()"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFars",
          "args": [
            "ref",
            "ref->target()",
            "segment"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "nestingLimit > 0",
            "\"Message is too deeply-nested.\""
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static MessageSizeCounts totalSize(\n        SegmentReader* segment, const WirePointer* ref, int nestingLimit) {\n      // Compute the total size of the object pointed to, not counting far pointer overhead.\n  \n      MessageSizeCounts result = { 0 * WORDS, 0 };\n  \n      if (ref->isNull()) {\n        return result;\n      }\n  \n      KJ_REQUIRE(nestingLimit > 0, \"Message is too deeply-nested.\") {\n        return result;\n      }\n      --nestingLimit;\n  \n      const word* ptr = followFars(ref, ref->target(), segment);\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT: {\n          KJ_REQUIRE(boundsCheck(segment, ptr, ptr + ref->structRef.wordSize()),\n                     \"Message contained out-of-bounds struct pointer.\") {\n            return result;\n          }\n          result.wordCount += ref->structRef.wordSize();\n  \n          const WirePointer* pointerSection =\n              reinterpret_cast<const WirePointer*>(ptr + ref->structRef.dataSize.get());\n          uint count = ref->structRef.ptrCount.get() / POINTERS;\n          for (uint i = 0; i < count; i++) {\n            result += totalSize(segment, pointerSection + i, nestingLimit);\n          }\n          break;\n        }\n        case WirePointer::LIST: {\n          switch (ref->listRef.elementSize()) {\n            case ElementSize::VOID:\n              // Nothing.\n              break;\n            case ElementSize::BIT:\n            case ElementSize::BYTE:\n            case ElementSize::TWO_BYTES:\n            case ElementSize::FOUR_BYTES:\n            case ElementSize::EIGHT_BYTES: {\n              WordCount64 totalWords = roundBitsUpToWords(\n                  ElementCount64(ref->listRef.elementCount()) *\n                  dataBitsPerElement(ref->listRef.elementSize()));\n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + totalWords),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n              result.wordCount += totalWords;\n              break;\n            }\n            case ElementSize::POINTER: {\n              WirePointerCount count = ref->listRef.elementCount() * (POINTERS / ELEMENTS);\n  \n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + count * WORDS_PER_POINTER),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n  \n              result.wordCount += count * WORDS_PER_POINTER;\n  \n              for (uint i = 0; i < count / POINTERS; i++) {\n                result += totalSize(segment, reinterpret_cast<const WirePointer*>(ptr) + i,\n                                    nestingLimit);\n              }\n              break;\n            }\n            case ElementSize::INLINE_COMPOSITE: {\n              WordCount wordCount = ref->listRef.inlineCompositeWordCount();\n              KJ_REQUIRE(boundsCheck(segment, ptr, ptr + wordCount + POINTER_SIZE_IN_WORDS),\n                         \"Message contained out-of-bounds list pointer.\") {\n                return result;\n              }\n  \n              const WirePointer* elementTag = reinterpret_cast<const WirePointer*>(ptr);\n              ElementCount count = elementTag->inlineCompositeListElementCount();\n  \n              KJ_REQUIRE(elementTag->kind() == WirePointer::STRUCT,\n                         \"Don't know how to handle non-STRUCT inline composite.\") {\n                return result;\n              }\n  \n              auto actualSize = elementTag->structRef.wordSize() / ELEMENTS * ElementCount64(count);\n              KJ_REQUIRE(actualSize <= wordCount,\n                         \"Struct list pointer's elements overran size.\") {\n                return result;\n              }\n  \n              // We count the actual size rather than the claimed word count because that's what\n              // we'll end up with if we make a copy.\n              result.wordCount += actualSize + POINTER_SIZE_IN_WORDS;\n  \n              WordCount dataSize = elementTag->structRef.dataSize.get();\n              WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();\n  \n              if (pointerCount > 0 * POINTERS) {\n                const word* pos = ptr + POINTER_SIZE_IN_WORDS;\n                for (uint i = 0; i < count / ELEMENTS; i++) {\n                  pos += dataSize;\n  \n                  for (uint j = 0; j < pointerCount / POINTERS; j++) {\n                    result += totalSize(segment, reinterpret_cast<const WirePointer*>(pos),\n                                        nestingLimit);\n                    pos += POINTER_SIZE_IN_WORDS;\n                  }\n                }\n              }\n              break;\n            }\n          }\n          break;\n        }\n        case WirePointer::FAR:\n          KJ_FAIL_ASSERT(\"Unexpected FAR pointer.\") {\n            break;\n          }\n          break;\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n            result.capCount++;\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n  \n      return result;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "591-604",
    "snippet": "static KJ_ALWAYS_INLINE(\n      void zeroPointerAndFars(SegmentBuilder* segment, WirePointer* ref)) {\n    // Zero out the pointer itself and, if it is a far pointer, zero the landing pad as well, but\n    // do not zero the object body.  Used when upgrading.\n\n    if (ref->kind() == WirePointer::FAR) {\n      SegmentBuilder* padSegment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n      if (padSegment->isWritable()) {  // Don't zero external data.\n        word* pad = padSegment->getPtrUnchecked(ref->farPositionInSegment());\n        memset(pad, 0, sizeof(WirePointer) * (1 + ref->isDoubleFar()));\n      }\n    }\n    memset(ref, 0, sizeof(*ref));\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ref",
            "0",
            "sizeof(*ref)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pad",
            "0",
            "sizeof(WirePointer) * (1 + ref->isDoubleFar())"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isDoubleFar",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padSegment->getPtrUnchecked",
          "args": [
            "ref->farPositionInSegment()"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->farPositionInSegment",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padSegment->isWritable",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "isWritable",
          "container": "SegmentBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
          "lines": "174-174",
          "snippet": "inline bool isWritable() { return !readOnly; }",
          "includes": [
            "#include \"capability.h\"",
            "#include <unordered_map>",
            "#include \"layout.h\"",
            "#include \"message.h\"",
            "#include \"common.h\"",
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/mutex.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\nSegmentBuilder {\n  inline bool isWritable() { return !readOnly; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "ref->farRef.segmentId.get()"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->farRef.segmentId.get",
          "args": [],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(\n        void zeroPointerAndFars(SegmentBuilder* segment, WirePointer* ref)) {\n      // Zero out the pointer itself and, if it is a far pointer, zero the landing pad as well, but\n      // do not zero the object body.  Used when upgrading.\n  \n      if (ref->kind() == WirePointer::FAR) {\n        SegmentBuilder* padSegment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (padSegment->isWritable()) {  // Don't zero external data.\n          word* pad = padSegment->getPtrUnchecked(ref->farPositionInSegment());\n          memset(pad, 0, sizeof(WirePointer) * (1 + ref->isDoubleFar()));\n        }\n      }\n      memset(ref, 0, sizeof(*ref));\n    }\n}"
  },
  {
    "function_name": "zeroObject",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "512-589",
    "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* tag, word* ptr) {\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (tag->kind()) {\n      case WirePointer::STRUCT: {\n        WirePointer* pointerSection =\n            reinterpret_cast<WirePointer*>(ptr + tag->structRef.dataSize.get());\n        uint count = tag->structRef.ptrCount.get() / POINTERS;\n        for (uint i = 0; i < count; i++) {\n          zeroObject(segment, pointerSection + i);\n        }\n        memset(ptr, 0, tag->structRef.wordSize() * BYTES_PER_WORD / BYTES);\n        break;\n      }\n      case WirePointer::LIST: {\n        switch (tag->listRef.elementSize()) {\n          case ElementSize::VOID:\n            // Nothing.\n            break;\n          case ElementSize::BIT:\n          case ElementSize::BYTE:\n          case ElementSize::TWO_BYTES:\n          case ElementSize::FOUR_BYTES:\n          case ElementSize::EIGHT_BYTES:\n            memset(ptr, 0,\n                roundBitsUpToWords(ElementCount64(tag->listRef.elementCount()) *\n                                   dataBitsPerElement(tag->listRef.elementSize()))\n                    * BYTES_PER_WORD / BYTES);\n            break;\n          case ElementSize::POINTER: {\n            uint count = tag->listRef.elementCount() / ELEMENTS;\n            for (uint i = 0; i < count; i++) {\n              zeroObject(segment, reinterpret_cast<WirePointer*>(ptr) + i);\n            }\n            memset(ptr, 0, POINTER_SIZE_IN_WORDS * count * BYTES_PER_WORD / BYTES);\n            break;\n          }\n          case ElementSize::INLINE_COMPOSITE: {\n            WirePointer* elementTag = reinterpret_cast<WirePointer*>(ptr);\n\n            KJ_ASSERT(elementTag->kind() == WirePointer::STRUCT,\n                  \"Don't know how to handle non-STRUCT inline composite.\");\n            WordCount dataSize = elementTag->structRef.dataSize.get();\n            WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();\n\n            uint count = elementTag->inlineCompositeListElementCount() / ELEMENTS;\n            if (pointerCount > 0 * POINTERS) {\n              word* pos = ptr + POINTER_SIZE_IN_WORDS;\n              for (uint i = 0; i < count; i++) {\n                pos += dataSize;\n\n                for (uint j = 0; j < pointerCount / POINTERS; j++) {\n                  zeroObject(segment, reinterpret_cast<WirePointer*>(pos));\n                  pos += POINTER_SIZE_IN_WORDS;\n                }\n              }\n            }\n\n            memset(ptr, 0, (elementTag->structRef.wordSize() * count + POINTER_SIZE_IN_WORDS)\n                           * BYTES_PER_WORD / BYTES);\n            break;\n          }\n        }\n        break;\n      }\n      case WirePointer::FAR:\n        KJ_FAIL_ASSERT(\"Unexpected FAR pointer.\") {\n          break;\n        }\n        break;\n      case WirePointer::OTHER:\n        KJ_FAIL_ASSERT(\"Unexpected OTHER pointer.\") {\n          break;\n        }\n        break;\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unexpected OTHER pointer.\""
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unexpected FAR pointer.\""
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr",
            "0",
            "(elementTag->structRef.wordSize() * count + POINTER_SIZE_IN_WORDS)\n                           * BYTES_PER_WORD / BYTES"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementTag->structRef.wordSize",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "wordSize",
          "container": "WirePointer::StructRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "185-187",
          "snippet": "inline WordCount wordSize() const {\n      return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n    }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    inline WordCount wordSize() const {\n          return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "pos"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementTag->inlineCompositeListElementCount",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementTag->structRef.ptrCount.get",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "elementTag->kind() == WirePointer::STRUCT",
            "\"Don't know how to handle non-STRUCT inline composite.\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementTag->kind",
          "args": [],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr",
            "0",
            "POINTER_SIZE_IN_WORDS * count * BYTES_PER_WORD / BYTES"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->listRef.elementCount",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr",
            "0",
            "roundBitsUpToWords(ElementCount64(tag->listRef.elementCount()) *\n                                   dataBitsPerElement(tag->listRef.elementSize()))\n                    * BYTES_PER_WORD / BYTES"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundBitsUpToWords",
          "args": [
            "ElementCount64(tag->listRef.elementCount()) *\n                                   dataBitsPerElement(tag->listRef.elementSize())"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dataBitsPerElement",
          "args": [
            "tag->listRef.elementSize()"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "dataBitsPerElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "99-101",
          "snippet": "inline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\ninline KJ_CONSTEXPR() BitsPerElement dataBitsPerElement(ElementSize size) {\n  return _::BITS_PER_ELEMENT_TABLE[static_cast<int>(size)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "tag->listRef.elementSize",
          "args": [],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ElementCount64",
          "args": [
            "tag->listRef.elementCount()"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->listRef.elementCount",
          "args": [],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tag->listRef.elementSize",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr",
            "0",
            "tag->structRef.wordSize() * BYTES_PER_WORD / BYTES"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr + tag->structRef.dataSize.get()"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->isWritable",
          "args": [],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "isWritable",
          "container": "SegmentBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
          "lines": "174-174",
          "snippet": "inline bool isWritable() { return !readOnly; }",
          "includes": [
            "#include \"capability.h\"",
            "#include <unordered_map>",
            "#include \"layout.h\"",
            "#include \"message.h\"",
            "#include \"common.h\"",
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/mutex.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\nSegmentBuilder {\n  inline bool isWritable() { return !readOnly; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* tag, word* ptr) {\n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (tag->kind()) {\n        case WirePointer::STRUCT: {\n          WirePointer* pointerSection =\n              reinterpret_cast<WirePointer*>(ptr + tag->structRef.dataSize.get());\n          uint count = tag->structRef.ptrCount.get() / POINTERS;\n          for (uint i = 0; i < count; i++) {\n            zeroObject(segment, pointerSection + i);\n          }\n          memset(ptr, 0, tag->structRef.wordSize() * BYTES_PER_WORD / BYTES);\n          break;\n        }\n        case WirePointer::LIST: {\n          switch (tag->listRef.elementSize()) {\n            case ElementSize::VOID:\n              // Nothing.\n              break;\n            case ElementSize::BIT:\n            case ElementSize::BYTE:\n            case ElementSize::TWO_BYTES:\n            case ElementSize::FOUR_BYTES:\n            case ElementSize::EIGHT_BYTES:\n              memset(ptr, 0,\n                  roundBitsUpToWords(ElementCount64(tag->listRef.elementCount()) *\n                                     dataBitsPerElement(tag->listRef.elementSize()))\n                      * BYTES_PER_WORD / BYTES);\n              break;\n            case ElementSize::POINTER: {\n              uint count = tag->listRef.elementCount() / ELEMENTS;\n              for (uint i = 0; i < count; i++) {\n                zeroObject(segment, reinterpret_cast<WirePointer*>(ptr) + i);\n              }\n              memset(ptr, 0, POINTER_SIZE_IN_WORDS * count * BYTES_PER_WORD / BYTES);\n              break;\n            }\n            case ElementSize::INLINE_COMPOSITE: {\n              WirePointer* elementTag = reinterpret_cast<WirePointer*>(ptr);\n  \n              KJ_ASSERT(elementTag->kind() == WirePointer::STRUCT,\n                    \"Don't know how to handle non-STRUCT inline composite.\");\n              WordCount dataSize = elementTag->structRef.dataSize.get();\n              WirePointerCount pointerCount = elementTag->structRef.ptrCount.get();\n  \n              uint count = elementTag->inlineCompositeListElementCount() / ELEMENTS;\n              if (pointerCount > 0 * POINTERS) {\n                word* pos = ptr + POINTER_SIZE_IN_WORDS;\n                for (uint i = 0; i < count; i++) {\n                  pos += dataSize;\n  \n                  for (uint j = 0; j < pointerCount / POINTERS; j++) {\n                    zeroObject(segment, reinterpret_cast<WirePointer*>(pos));\n                    pos += POINTER_SIZE_IN_WORDS;\n                  }\n                }\n              }\n  \n              memset(ptr, 0, (elementTag->structRef.wordSize() * count + POINTER_SIZE_IN_WORDS)\n                             * BYTES_PER_WORD / BYTES);\n              break;\n            }\n          }\n          break;\n        }\n        case WirePointer::FAR:\n          KJ_FAIL_ASSERT(\"Unexpected FAR pointer.\") {\n            break;\n          }\n          break;\n        case WirePointer::OTHER:\n          KJ_FAIL_ASSERT(\"Unexpected OTHER pointer.\") {\n            break;\n          }\n          break;\n      }\n    }\n}"
  },
  {
    "function_name": "zeroObject",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "467-510",
    "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Unknown pointer type.\""
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "ref->capRef.index.get()"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->capRef.index.get",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Capability encountered in builder in lite mode?\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isCapability",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pad",
            "0",
            "sizeof(WirePointer)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pad",
            "0",
            "sizeof(WirePointer) * 2"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getPtrUnchecked",
          "args": [
            "pad->farPositionInSegment()"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad->farPositionInSegment",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->isWritable",
          "args": [],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "isWritable",
          "container": "SegmentBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.h",
          "lines": "174-174",
          "snippet": "inline bool isWritable() { return !readOnly; }",
          "includes": [
            "#include \"capability.h\"",
            "#include <unordered_map>",
            "#include \"layout.h\"",
            "#include \"message.h\"",
            "#include \"common.h\"",
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/mutex.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <unordered_map>\n#include \"layout.h\"\n#include \"message.h\"\n#include \"common.h\"\n#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/mutex.h>\n#include <kj/common.h>\n\nSegmentBuilder {\n  inline bool isWritable() { return !readOnly; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "pad->farRef.segmentId.get()"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isDoubleFar",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "segment->getPtrUnchecked(ref->farPositionInSegment())"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getPtrUnchecked",
          "args": [
            "ref->farPositionInSegment()"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->farPositionInSegment",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "ref->farRef.segmentId.get()"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->target",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "422-463",
    "snippet": "static KJ_ALWAYS_INLINE(const word* followFars(\n      const WirePointer*& ref, const word* refTarget, SegmentReader*& segment)) {\n    // Like the other followFars() but operates on readers.\n\n    // If the segment is null, this is an unchecked message, so there are no FAR pointers.\n    if (segment != nullptr && ref->kind() == WirePointer::FAR) {\n      // Look up the segment containing the landing pad.\n      segment = segment->getArena()->tryGetSegment(ref->farRef.segmentId.get());\n      KJ_REQUIRE(segment != nullptr, \"Message contains far pointer to unknown segment.\") {\n        return nullptr;\n      }\n\n      // Find the landing pad and check that it is within bounds.\n      const word* ptr = segment->getStartPtr() + ref->farPositionInSegment();\n      WordCount padWords = (1 + ref->isDoubleFar()) * POINTER_SIZE_IN_WORDS;\n      KJ_REQUIRE(boundsCheck(segment, ptr, ptr + padWords),\n                 \"Message contains out-of-bounds far pointer.\") {\n        return nullptr;\n      }\n\n      const WirePointer* pad = reinterpret_cast<const WirePointer*>(ptr);\n\n      // If this is not a double-far then the landing pad is our final pointer.\n      if (!ref->isDoubleFar()) {\n        ref = pad;\n        return pad->target();\n      }\n\n      // Landing pad is another far pointer.  It is followed by a tag describing the pointed-to\n      // object.\n      ref = pad + 1;\n\n      segment = segment->getArena()->tryGetSegment(pad->farRef.segmentId.get());\n      KJ_REQUIRE(segment != nullptr, \"Message contains double-far pointer to unknown segment.\") {\n        return nullptr;\n      }\n\n      return segment->getStartPtr() + pad->farPositionInSegment();\n    } else {\n      return refTarget;\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pad->farPositionInSegment",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getStartPtr",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "segment != nullptr",
            "\"Message contains double-far pointer to unknown segment.\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "pad->farRef.segmentId.get()"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad->farRef.segmentId.get",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad->target",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isDoubleFar",
          "args": [],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "boundsCheck(segment, ptr, ptr + padWords)",
            "\"Message contains out-of-bounds far pointer.\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boundsCheck",
          "args": [
            "segment",
            "ptr",
            "ptr + padWords"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isDoubleFar",
          "args": [],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->farPositionInSegment",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getStartPtr",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "segment != nullptr",
            "\"Message contains far pointer to unknown segment.\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "ref->farRef.segmentId.get()"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(const word* followFars(\n        const WirePointer*& ref, const word* refTarget, SegmentReader*& segment)) {\n      // Like the other followFars() but operates on readers.\n  \n      // If the segment is null, this is an unchecked message, so there are no FAR pointers.\n      if (segment != nullptr && ref->kind() == WirePointer::FAR) {\n        // Look up the segment containing the landing pad.\n        segment = segment->getArena()->tryGetSegment(ref->farRef.segmentId.get());\n        KJ_REQUIRE(segment != nullptr, \"Message contains far pointer to unknown segment.\") {\n          return nullptr;\n        }\n  \n        // Find the landing pad and check that it is within bounds.\n        const word* ptr = segment->getStartPtr() + ref->farPositionInSegment();\n        WordCount padWords = (1 + ref->isDoubleFar()) * POINTER_SIZE_IN_WORDS;\n        KJ_REQUIRE(boundsCheck(segment, ptr, ptr + padWords),\n                   \"Message contains out-of-bounds far pointer.\") {\n          return nullptr;\n        }\n  \n        const WirePointer* pad = reinterpret_cast<const WirePointer*>(ptr);\n  \n        // If this is not a double-far then the landing pad is our final pointer.\n        if (!ref->isDoubleFar()) {\n          ref = pad;\n          return pad->target();\n        }\n  \n        // Landing pad is another far pointer.  It is followed by a tag describing the pointed-to\n        // object.\n        ref = pad + 1;\n  \n        segment = segment->getArena()->tryGetSegment(pad->farRef.segmentId.get());\n        KJ_REQUIRE(segment != nullptr, \"Message contains double-far pointer to unknown segment.\") {\n          return nullptr;\n        }\n  \n        return segment->getStartPtr() + pad->farPositionInSegment();\n      } else {\n        return refTarget;\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "415-420",
    "snippet": "static KJ_ALWAYS_INLINE(word* followFars(\n      WirePointer*& ref, word* refTarget, SegmentBuilder*& segment)) {\n    auto result = followFarsNoWritableCheck(ref, refTarget, segment);\n    segment->checkWritable();\n    return result;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segment->checkWritable",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "followFarsNoWritableCheck",
          "args": [
            "ref",
            "refTarget",
            "segment"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(word* followFars(\n        WirePointer*& ref, word* refTarget, SegmentBuilder*& segment)) {\n      auto result = followFarsNoWritableCheck(ref, refTarget, segment);\n      segment->checkWritable();\n      return result;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "384-413",
    "snippet": "static KJ_ALWAYS_INLINE(word* followFarsNoWritableCheck(\n      WirePointer*& ref, word* refTarget, SegmentBuilder*& segment)) {\n    // If `ref` is a far pointer, follow it.  On return, `ref` will have been updated to point at\n    // a WirePointer that contains the type information about the target object, and a pointer to\n    // the object contents is returned.  The caller must NOT use `ref->target()` as this may or may\n    // not actually return a valid pointer.  `segment` is also updated to point at the segment which\n    // actually contains the object.\n    //\n    // If `ref` is not a far pointer, this simply returns `refTarget`.  Usually, `refTarget` should\n    // be the same as `ref->target()`, but may not be in cases where `ref` is only a tag.\n\n    if (ref->kind() == WirePointer::FAR) {\n      segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n      WirePointer* pad =\n          reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n      if (!ref->isDoubleFar()) {\n        ref = pad;\n        return pad->target();\n      }\n\n      // Landing pad is another far pointer.  It is followed by a tag describing the pointed-to\n      // object.\n      ref = pad + 1;\n\n      segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n      return segment->getPtrUnchecked(pad->farPositionInSegment());\n    } else {\n      return refTarget;\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segment->getPtrUnchecked",
          "args": [
            "pad->farPositionInSegment()"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad->farPositionInSegment",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "pad->farRef.segmentId.get()"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad->farRef.segmentId.get",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad->target",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isDoubleFar",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "segment->getPtrUnchecked(ref->farPositionInSegment())"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getPtrUnchecked",
          "args": [
            "ref->farPositionInSegment()"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->farPositionInSegment",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "ref->farRef.segmentId.get()"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->kind",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(word* followFarsNoWritableCheck(\n        WirePointer*& ref, word* refTarget, SegmentBuilder*& segment)) {\n      // If `ref` is a far pointer, follow it.  On return, `ref` will have been updated to point at\n      // a WirePointer that contains the type information about the target object, and a pointer to\n      // the object contents is returned.  The caller must NOT use `ref->target()` as this may or may\n      // not actually return a valid pointer.  `segment` is also updated to point at the segment which\n      // actually contains the object.\n      //\n      // If `ref` is not a far pointer, this simply returns `refTarget`.  Usually, `refTarget` should\n      // be the same as `ref->target()`, but may not be in cases where `ref` is only a tag.\n  \n      if (ref->kind() == WirePointer::FAR) {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        WirePointer* pad =\n            reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n        if (!ref->isDoubleFar()) {\n          ref = pad;\n          return pad->target();\n        }\n  \n        // Landing pad is another far pointer.  It is followed by a tag describing the pointed-to\n        // object.\n        ref = pad + 1;\n  \n        segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n        return segment->getPtrUnchecked(pad->farPositionInSegment());\n      } else {\n        return refTarget;\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "316-382",
    "snippet": "static KJ_ALWAYS_INLINE(word* allocate(\n      WirePointer*& ref, SegmentBuilder*& segment, WordCount amount,\n      WirePointer::Kind kind, BuilderArena* orphanArena)) {\n    // Allocate space in the message for a new object, creating far pointers if necessary.\n    //\n    // * `ref` starts out being a reference to the pointer which shall be assigned to point at the\n    //   new object.  On return, `ref` points to a pointer which needs to be initialized with\n    //   the object's type information.  Normally this is the same pointer, but it can change if\n    //   a far pointer was allocated -- in this case, `ref` will end up pointing to the far\n    //   pointer's tag.  Either way, `allocate()` takes care of making sure that the original\n    //   pointer ends up leading to the new object.  On return, only the upper 32 bit of `*ref`\n    //   need to be filled in by the caller.\n    // * `segment` starts out pointing to the segment containing `ref`.  On return, it points to\n    //   the segment containing the allocated object, which is usually the same segment but could\n    //   be a different one if the original segment was out of space.\n    // * `amount` is the number of words to allocate.\n    // * `kind` is the kind of object to allocate.  It is used to initialize the pointer.  It\n    //   cannot be `FAR` -- far pointers are allocated automatically as needed.\n    // * `orphanArena` is usually null.  If it is non-null, then we're allocating an orphan object.\n    //   In this case, `segment` starts out null; the allocation takes place in an arbitrary\n    //   segment belonging to the arena.  `ref` will be initialized as a non-far pointer, but its\n    //   target offset will be set to zero.\n\n    if (orphanArena == nullptr) {\n      if (!ref->isNull()) zeroObject(segment, ref);\n\n      if (amount == 0 * WORDS && kind == WirePointer::STRUCT) {\n        // Note that the check for kind == WirePointer::STRUCT will hopefully cause this whole\n        // branch to be optimized away from all the call sites that are allocating non-structs.\n        ref->setKindAndTargetForEmptyStruct();\n        return reinterpret_cast<word*>(ref);\n      }\n\n      word* ptr = segment->allocate(amount);\n\n      if (ptr == nullptr) {\n        // Need to allocate in a new segment.  We'll need to allocate an extra pointer worth of\n        // space to act as the landing pad for a far pointer.\n\n        WordCount amountPlusRef = amount + POINTER_SIZE_IN_WORDS;\n        auto allocation = segment->getArena()->allocate(amountPlusRef);\n        segment = allocation.segment;\n        ptr = allocation.words;\n\n        // Set up the original pointer to be a far pointer to the new segment.\n        ref->setFar(false, segment->getOffsetTo(ptr));\n        ref->farRef.set(segment->getSegmentId());\n\n        // Initialize the landing pad to indicate that the data immediately follows the pad.\n        ref = reinterpret_cast<WirePointer*>(ptr);\n        ref->setKindAndTarget(kind, ptr + POINTER_SIZE_IN_WORDS, segment);\n\n        // Allocated space follows new pointer.\n        return ptr + POINTER_SIZE_IN_WORDS;\n      } else {\n        ref->setKindAndTarget(kind, ptr, segment);\n        return ptr;\n      }\n    } else {\n      // orphanArena is non-null.  Allocate an orphan.\n      KJ_DASSERT(ref->isNull());\n      auto allocation = orphanArena->allocate(amount);\n      segment = allocation.segment;\n      ref->setKindForOrphan(kind);\n      return allocation.words;\n    }\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ref->setKindForOrphan",
          "args": [
            "kind"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanArena->allocate",
          "args": [
            "amount"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "ref->isNull()"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->setKindAndTarget",
          "args": [
            "kind",
            "ptr",
            "segment"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->setKindAndTarget",
          "args": [
            "kind",
            "ptr + POINTER_SIZE_IN_WORDS",
            "segment"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WirePointer*>",
          "args": [
            "ptr"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->farRef.set",
          "args": [
            "segment->getSegmentId()"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment->getSegmentId",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->setFar",
          "args": [
            "false",
            "segment->getOffsetTo(ptr)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getOffsetTo",
          "args": [
            "ptr"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [
            "amountPlusRef"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->getArena",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->allocate",
          "args": [
            "amount"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "ref"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref->setKindAndTargetForEmptyStruct",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zeroObject",
          "args": [
            "segment",
            "ref"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "zeroObject",
          "container": "WireHelpers",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "467-510",
          "snippet": "static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n    // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n    // target object no longer reachable.\n\n    // We shouldn't zero out external data linked into the message.\n    if (!segment->isWritable()) return;\n\n    switch (ref->kind()) {\n      case WirePointer::STRUCT:\n      case WirePointer::LIST:\n        zeroObject(segment, ref, ref->target());\n        break;\n      case WirePointer::FAR: {\n        segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n        if (segment->isWritable()) {  // Don't zero external data.\n          WirePointer* pad =\n              reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n\n          if (ref->isDoubleFar()) {\n            segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n            if (segment->isWritable()) {\n              zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n            }\n            memset(pad, 0, sizeof(WirePointer) * 2);\n          } else {\n            zeroObject(segment, pad);\n            memset(pad, 0, sizeof(WirePointer));\n          }\n        }\n        break;\n      }\n      case WirePointer::OTHER:\n        if (ref->isCapability()) {\n#if CAPNP_LITE\n          KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n#else  // CAPNP_LINE\n          segment->getArena()->dropCap(ref->capRef.index.get());\n#endif  // CAPNP_LITE, else\n        } else {\n          KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n        }\n        break;\n    }\n  }",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static void zeroObject(SegmentBuilder* segment, WirePointer* ref) {\n      // Zero out the pointed-to object.  Use when the pointer is about to be overwritten making the\n      // target object no longer reachable.\n  \n      // We shouldn't zero out external data linked into the message.\n      if (!segment->isWritable()) return;\n  \n      switch (ref->kind()) {\n        case WirePointer::STRUCT:\n        case WirePointer::LIST:\n          zeroObject(segment, ref, ref->target());\n          break;\n        case WirePointer::FAR: {\n          segment = segment->getArena()->getSegment(ref->farRef.segmentId.get());\n          if (segment->isWritable()) {  // Don't zero external data.\n            WirePointer* pad =\n                reinterpret_cast<WirePointer*>(segment->getPtrUnchecked(ref->farPositionInSegment()));\n  \n            if (ref->isDoubleFar()) {\n              segment = segment->getArena()->getSegment(pad->farRef.segmentId.get());\n              if (segment->isWritable()) {\n                zeroObject(segment, pad + 1, segment->getPtrUnchecked(pad->farPositionInSegment()));\n              }\n              memset(pad, 0, sizeof(WirePointer) * 2);\n            } else {\n              zeroObject(segment, pad);\n              memset(pad, 0, sizeof(WirePointer));\n            }\n          }\n          break;\n        }\n        case WirePointer::OTHER:\n          if (ref->isCapability()) {\n  #if CAPNP_LITE\n            KJ_FAIL_ASSERT(\"Capability encountered in builder in lite mode?\") { break; }\n  #else  // CAPNP_LINE\n            segment->getArena()->dropCap(ref->capRef.index.get());\n  #endif  // CAPNP_LITE, else\n          } else {\n            KJ_FAIL_REQUIRE(\"Unknown pointer type.\") { break; }\n          }\n          break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref->isNull",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(word* allocate(\n        WirePointer*& ref, SegmentBuilder*& segment, WordCount amount,\n        WirePointer::Kind kind, BuilderArena* orphanArena)) {\n      // Allocate space in the message for a new object, creating far pointers if necessary.\n      //\n      // * `ref` starts out being a reference to the pointer which shall be assigned to point at the\n      //   new object.  On return, `ref` points to a pointer which needs to be initialized with\n      //   the object's type information.  Normally this is the same pointer, but it can change if\n      //   a far pointer was allocated -- in this case, `ref` will end up pointing to the far\n      //   pointer's tag.  Either way, `allocate()` takes care of making sure that the original\n      //   pointer ends up leading to the new object.  On return, only the upper 32 bit of `*ref`\n      //   need to be filled in by the caller.\n      // * `segment` starts out pointing to the segment containing `ref`.  On return, it points to\n      //   the segment containing the allocated object, which is usually the same segment but could\n      //   be a different one if the original segment was out of space.\n      // * `amount` is the number of words to allocate.\n      // * `kind` is the kind of object to allocate.  It is used to initialize the pointer.  It\n      //   cannot be `FAR` -- far pointers are allocated automatically as needed.\n      // * `orphanArena` is usually null.  If it is non-null, then we're allocating an orphan object.\n      //   In this case, `segment` starts out null; the allocation takes place in an arbitrary\n      //   segment belonging to the arena.  `ref` will be initialized as a non-far pointer, but its\n      //   target offset will be set to zero.\n  \n      if (orphanArena == nullptr) {\n        if (!ref->isNull()) zeroObject(segment, ref);\n  \n        if (amount == 0 * WORDS && kind == WirePointer::STRUCT) {\n          // Note that the check for kind == WirePointer::STRUCT will hopefully cause this whole\n          // branch to be optimized away from all the call sites that are allocating non-structs.\n          ref->setKindAndTargetForEmptyStruct();\n          return reinterpret_cast<word*>(ref);\n        }\n  \n        word* ptr = segment->allocate(amount);\n  \n        if (ptr == nullptr) {\n          // Need to allocate in a new segment.  We'll need to allocate an extra pointer worth of\n          // space to act as the landing pad for a far pointer.\n  \n          WordCount amountPlusRef = amount + POINTER_SIZE_IN_WORDS;\n          auto allocation = segment->getArena()->allocate(amountPlusRef);\n          segment = allocation.segment;\n          ptr = allocation.words;\n  \n          // Set up the original pointer to be a far pointer to the new segment.\n          ref->setFar(false, segment->getOffsetTo(ptr));\n          ref->farRef.set(segment->getSegmentId());\n  \n          // Initialize the landing pad to indicate that the data immediately follows the pad.\n          ref = reinterpret_cast<WirePointer*>(ptr);\n          ref->setKindAndTarget(kind, ptr + POINTER_SIZE_IN_WORDS, segment);\n  \n          // Allocated space follows new pointer.\n          return ptr + POINTER_SIZE_IN_WORDS;\n        } else {\n          ref->setKindAndTarget(kind, ptr, segment);\n          return ptr;\n        }\n      } else {\n        // orphanArena is non-null.  Allocate an orphan.\n        KJ_DASSERT(ref->isNull());\n        auto allocation = orphanArena->allocate(amount);\n        segment = allocation.segment;\n        ref->setKindForOrphan(kind);\n        return allocation.words;\n      }\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "311-314",
    "snippet": "static KJ_ALWAYS_INLINE(bool amplifiedRead(SegmentReader* segment, WordCount virtualAmount)) {\n    // If segment is null, this is an unchecked message, so we don't do read limiter checks.\n    return segment == nullptr || segment->amplifiedRead(virtualAmount);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segment->amplifiedRead",
          "args": [
            "virtualAmount"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(bool amplifiedRead(SegmentReader* segment, WordCount virtualAmount)) {\n      // If segment is null, this is an unchecked message, so we don't do read limiter checks.\n      return segment == nullptr || segment->amplifiedRead(virtualAmount);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "305-309",
    "snippet": "static KJ_ALWAYS_INLINE(bool boundsCheck(\n      SegmentReader* segment, const word* start, const word* end)) {\n    // If segment is null, this is an unchecked message, so we don't do bounds checks.\n    return segment == nullptr || segment->containsInterval(start, end);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segment->containsInterval",
          "args": [
            "start",
            "end"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(bool boundsCheck(\n        SegmentReader* segment, const word* start, const word* end)) {\n      // If segment is null, this is an unchecked message, so we don't do bounds checks.\n      return segment == nullptr || segment->containsInterval(start, end);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "301-303",
    "snippet": "static KJ_ALWAYS_INLINE(ByteCount64 roundBitsUpToBytes(BitCount64 bits)) {\n    return (bits + 7 * BITS) / BITS_PER_BYTE;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ByteCount64 roundBitsUpToBytes(BitCount64 bits)) {\n      return (bits + 7 * BITS) / BITS_PER_BYTE;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "296-299",
    "snippet": "static KJ_ALWAYS_INLINE(WordCount64 roundBitsUpToWords(BitCount64 bits)) {\n    static_assert(sizeof(word) == 8, \"This code assumes 64-bit words.\");\n    return (bits + 63 * BITS) / BITS_PER_WORD;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(WordCount64 roundBitsUpToWords(BitCount64 bits)) {\n      static_assert(sizeof(word) == 8, \"This code assumes 64-bit words.\");\n      return (bits + 63 * BITS) / BITS_PER_WORD;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "292-294",
    "snippet": "static KJ_ALWAYS_INLINE(ByteCount roundBitsUpToBytes(BitCount bits)) {\n    return (bits + 7 * BITS) / BITS_PER_BYTE;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(ByteCount roundBitsUpToBytes(BitCount bits)) {\n      return (bits + 7 * BITS) / BITS_PER_BYTE;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WireHelpers",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "287-290",
    "snippet": "static KJ_ALWAYS_INLINE(WordCount roundBytesUpToWords(ByteCount bytes)) {\n    static_assert(sizeof(word) == 8, \"This code assumes 64-bit words.\");\n    return (bytes + 7 * BYTES) / BYTES_PER_WORD;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWireHelpers {\n  static KJ_ALWAYS_INLINE(WordCount roundBytesUpToWords(ByteCount bytes)) {\n      static_assert(sizeof(word) == 8, \"This code assumes 64-bit words.\");\n      return (bytes + 7 * BYTES) / BYTES_PER_WORD;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "249-253",
    "snippet": "KJ_ALWAYS_INLINE(bool isNull() const) {\n    // If the upper 32 bits are zero, this is a pointer to an empty struct.  We consider that to be\n    // our \"null\" value.\n    return (offsetAndKind.get() == 0) & (upper32Bits == 0);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(bool isNull() const) {\n      // If the upper 32 bits are zero, this is a pointer to an empty struct.  We consider that to be\n      // our \"null\" value.\n      return (offsetAndKind.get() == 0) & (upper32Bits == 0);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer::FarRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "227-229",
    "snippet": "KJ_ALWAYS_INLINE(void set(SegmentId si)) {\n      segmentId.set(si);\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segmentId.set",
          "args": [
            "si"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  FarRef {\n    KJ_ALWAYS_INLINE(void set(SegmentId si)) {\n          segmentId.set(si);\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer::ListRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "217-221",
    "snippet": "KJ_ALWAYS_INLINE(void setInlineComposite(WordCount wc)) {\n      KJ_DREQUIRE(wc < (1 << 29) * WORDS, \"Inline composite lists are limited to 2**29 words.\");\n      elementSizeAndCount.set(((wc / WORDS) << 3) |\n                              static_cast<int>(ElementSize::INLINE_COMPOSITE));\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elementSizeAndCount.set",
          "args": [
            "((wc / WORDS) << 3) |\n                              static_cast<int>(ElementSize::INLINE_COMPOSITE)"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "ElementSize::INLINE_COMPOSITE"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "wc < (1 << 29) * WORDS",
            "\"Inline composite lists are limited to 2**29 words.\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  ListRef {\n    KJ_ALWAYS_INLINE(void setInlineComposite(WordCount wc)) {\n          KJ_DREQUIRE(wc < (1 << 29) * WORDS, \"Inline composite lists are limited to 2**29 words.\");\n          elementSizeAndCount.set(((wc / WORDS) << 3) |\n                                  static_cast<int>(ElementSize::INLINE_COMPOSITE));\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer::ListRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "212-215",
    "snippet": "KJ_ALWAYS_INLINE(void set(ElementSize es, ElementCount ec)) {\n      KJ_DREQUIRE(ec < (1 << 29) * ELEMENTS, \"Lists are limited to 2**29 elements.\");\n      elementSizeAndCount.set(((ec / ELEMENTS) << 3) | static_cast<int>(es));\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elementSizeAndCount.set",
          "args": [
            "((ec / ELEMENTS) << 3) | static_cast<int>(es)"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "es"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "ec < (1 << 29) * ELEMENTS",
            "\"Lists are limited to 2**29 elements.\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  ListRef {\n    KJ_ALWAYS_INLINE(void set(ElementSize es, ElementCount ec)) {\n          KJ_DREQUIRE(ec < (1 << 29) * ELEMENTS, \"Lists are limited to 2**29 elements.\");\n          elementSizeAndCount.set(((ec / ELEMENTS) << 3) | static_cast<int>(es));\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer::ListRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "208-210",
    "snippet": "KJ_ALWAYS_INLINE(WordCount inlineCompositeWordCount() const) {\n      return elementCount() * (1 * WORDS / ELEMENTS);\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elementCount",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  ListRef {\n    KJ_ALWAYS_INLINE(WordCount inlineCompositeWordCount() const) {\n          return elementCount() * (1 * WORDS / ELEMENTS);\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer::ListRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "205-207",
    "snippet": "KJ_ALWAYS_INLINE(ElementCount elementCount() const) {\n      return (elementSizeAndCount.get() >> 3) * ELEMENTS;\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elementSizeAndCount.get",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  ListRef {\n    KJ_ALWAYS_INLINE(ElementCount elementCount() const) {\n          return (elementSizeAndCount.get() >> 3) * ELEMENTS;\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer::ListRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "202-204",
    "snippet": "KJ_ALWAYS_INLINE(ElementSize elementSize() const) {\n      return static_cast<ElementSize>(elementSizeAndCount.get() & 7);\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<ElementSize>",
          "args": [
            "elementSizeAndCount.get() & 7"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementSizeAndCount.get",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  ListRef {\n    KJ_ALWAYS_INLINE(ElementSize elementSize() const) {\n          return static_cast<ElementSize>(elementSizeAndCount.get() & 7);\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer::StructRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "193-196",
    "snippet": "KJ_ALWAYS_INLINE(void set(StructSize size)) {\n      dataSize.set(size.data);\n      ptrCount.set(size.pointers);\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrCount.set",
          "args": [
            "size.pointers"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    KJ_ALWAYS_INLINE(void set(StructSize size)) {\n          dataSize.set(size.data);\n          ptrCount.set(size.pointers);\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer::StructRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "189-192",
    "snippet": "KJ_ALWAYS_INLINE(void set(WordCount ds, WirePointerCount rc)) {\n      dataSize.set(ds);\n      ptrCount.set(rc);\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrCount.set",
          "args": [
            "rc"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    KJ_ALWAYS_INLINE(void set(WordCount ds, WirePointerCount rc)) {\n          dataSize.set(ds);\n          ptrCount.set(rc);\n        }\n  }\n}"
  },
  {
    "function_name": "wordSize",
    "container": "WirePointer::StructRef",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "185-187",
    "snippet": "inline WordCount wordSize() const {\n      return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n    }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrCount.get",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  StructRef {\n    inline WordCount wordSize() const {\n          return dataSize.get() + ptrCount.get() * WORDS_PER_POINTER;\n        }\n  }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "170-173",
    "snippet": "KJ_ALWAYS_INLINE(void setCap(uint index)) {\n    offsetAndKind.set(static_cast<uint32_t>(Kind::OTHER));\n    capRef.index.set(index);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capRef.index.set",
          "args": [
            "index"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint32_t>",
          "args": [
            "Kind::OTHER"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(void setCap(uint index)) {\n      offsetAndKind.set(static_cast<uint32_t>(Kind::OTHER));\n      capRef.index.set(index);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "166-169",
    "snippet": "KJ_ALWAYS_INLINE(void setFar(bool isDoubleFar, WordCount pos)) {\n    offsetAndKind.set(((pos / WORDS) << 3) | (static_cast<uint32_t>(isDoubleFar) << 2) |\n                      static_cast<uint32_t>(Kind::FAR));\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.set",
          "args": [
            "((pos / WORDS) << 3) | (static_cast<uint32_t>(isDoubleFar) << 2) |\n                      static_cast<uint32_t>(Kind::FAR)"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint32_t>",
          "args": [
            "Kind::FAR"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint32_t>",
          "args": [
            "isDoubleFar"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(void setFar(bool isDoubleFar, WordCount pos)) {\n      offsetAndKind.set(((pos / WORDS) << 3) | (static_cast<uint32_t>(isDoubleFar) << 2) |\n                        static_cast<uint32_t>(Kind::FAR));\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "161-165",
    "snippet": "KJ_ALWAYS_INLINE(bool isDoubleFar() const) {\n    KJ_DREQUIRE(kind() == FAR,\n        \"isDoubleFar() should only be called on FAR pointers.\");\n    return (offsetAndKind.get() >> 2) & 1;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "kind() == FAR",
            "\"isDoubleFar() should only be called on FAR pointers.\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kind",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(bool isDoubleFar() const) {\n      KJ_DREQUIRE(kind() == FAR,\n          \"isDoubleFar() should only be called on FAR pointers.\");\n      return (offsetAndKind.get() >> 2) & 1;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "156-160",
    "snippet": "KJ_ALWAYS_INLINE(WordCount farPositionInSegment() const) {\n    KJ_DREQUIRE(kind() == FAR,\n        \"positionInSegment() should only be called on FAR pointers.\");\n    return (offsetAndKind.get() >> 3) * WORDS;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "kind() == FAR",
            "\"positionInSegment() should only be called on FAR pointers.\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kind",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "kind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/common.h",
          "lines": "153-157",
          "snippet": "inline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}",
          "includes": [
            "#include <kj/string.h>",
            "#include <inttypes.h>",
            "#include <kj/units.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string.h>\n#include <inttypes.h>\n#include <kj/units.h>\n\ninline constexpr Kind kind() {\n  // This overload of kind() matches types which have a Kind_ specialization.\n\n  return k;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(WordCount farPositionInSegment() const) {\n      KJ_DREQUIRE(kind() == FAR,\n          \"positionInSegment() should only be called on FAR pointers.\");\n      return (offsetAndKind.get() >> 3) * WORDS;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "151-154",
    "snippet": "KJ_ALWAYS_INLINE(void setKindAndInlineCompositeListElementCount(\n      Kind kind, ElementCount elementCount)) {\n    offsetAndKind.set(((elementCount / ELEMENTS) << 2) | kind);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.set",
          "args": [
            "((elementCount / ELEMENTS) << 2) | kind"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(void setKindAndInlineCompositeListElementCount(\n        Kind kind, ElementCount elementCount)) {\n      offsetAndKind.set(((elementCount / ELEMENTS) << 2) | kind);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "148-150",
    "snippet": "KJ_ALWAYS_INLINE(ElementCount inlineCompositeListElementCount() const) {\n    return (offsetAndKind.get() >> 2) * ELEMENTS;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(ElementCount inlineCompositeListElementCount() const) {\n      return (offsetAndKind.get() >> 2) * ELEMENTS;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "139-146",
    "snippet": "KJ_ALWAYS_INLINE(void setKindForOrphan(Kind kind)) {\n    // OrphanBuilder contains a WirePointer, but since it isn't located in a segment, it should\n    // not have a valid offset (unless it is a FAR or OTHER pointer).  We set its offset to -1\n    // because setting it to zero would mean a pointer to an empty struct would appear to be a null\n    // pointer.\n    KJ_DREQUIRE(isPositional());\n    offsetAndKind.set(kind | 0xfffffffc);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.set",
          "args": [
            "kind | 0xfffffffc"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "isPositional()"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isPositional",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(void setKindForOrphan(Kind kind)) {\n      // OrphanBuilder contains a WirePointer, but since it isn't located in a segment, it should\n      // not have a valid offset (unless it is a FAR or OTHER pointer).  We set its offset to -1\n      // because setting it to zero would mean a pointer to an empty struct would appear to be a null\n      // pointer.\n      KJ_DREQUIRE(isPositional());\n      offsetAndKind.set(kind | 0xfffffffc);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "131-138",
    "snippet": "KJ_ALWAYS_INLINE(void setKindAndTargetForEmptyStruct()) {\n    // This pointer points at an empty struct.  Assuming the WirePointer itself is in-bounds, we\n    // can set the target to point either at the WirePointer itself or immediately after it.  The\n    // latter would cause the WirePointer to be \"null\" (since for an empty struct the upper 32\n    // bits are going to be zero).  So we set an offset of -1, as if the struct were allocated\n    // immediately before this pointer, to distinguish it from null.\n    offsetAndKind.set(0xfffffffc);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.set",
          "args": [
            "0xfffffffc"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(void setKindAndTargetForEmptyStruct()) {\n      // This pointer points at an empty struct.  Assuming the WirePointer itself is in-bounds, we\n      // can set the target to point either at the WirePointer itself or immediately after it.  The\n      // latter would cause the WirePointer to be \"null\" (since for an empty struct the upper 32\n      // bits are going to be zero).  So we set an offset of -1, as if the struct were allocated\n      // immediately before this pointer, to distinguish it from null.\n      offsetAndKind.set(0xfffffffc);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "128-130",
    "snippet": "KJ_ALWAYS_INLINE(void setKindWithZeroOffset(Kind kind)) {\n    offsetAndKind.set(kind);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.set",
          "args": [
            "kind"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(void setKindWithZeroOffset(Kind kind)) {\n      offsetAndKind.set(kind);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "109-127",
    "snippet": "KJ_ALWAYS_INLINE(void setKindAndTarget(Kind kind, word* target, SegmentBuilder* segment)) {\n    // Check that the target is really in the same segment, otherwise subtracting pointers is\n    // undefined behavior.  As it turns out, it's undefined behavior that actually produces\n    // unexpected results in a real-world situation that actually happened:  At one time,\n    // OrphanBuilder's \"tag\" (a WirePointer) was allowed to be initialized as if it lived in\n    // a particular segment when in fact it does not.  On 32-bit systems, where words might\n    // only be 32-bit aligned, it's possible that the difference between `this` and `target` is\n    // not a whole number of words.  But clang optimizes:\n    //     (target - (word*)this - 1) << 2\n    // to:\n    //     (((ptrdiff_t)target - (ptrdiff_t)this - 8) >> 1)\n    // So now when the pointers are not aligned the same, we can end up corrupting the bottom\n    // two bits, where `kind` is stored.  For example, this turns a struct into a far pointer.\n    // Ouch!\n    KJ_DREQUIRE(segment->containsInterval(\n        reinterpret_cast<word*>(this), reinterpret_cast<word*>(this + 1)));\n    KJ_DREQUIRE(segment->containsInterval(target, target));\n    offsetAndKind.set(((target - reinterpret_cast<word*>(this) - 1) << 2) | kind);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.set",
          "args": [
            "((target - reinterpret_cast<word*>(this) - 1) << 2) | kind"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "this"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "segment->containsInterval(target, target)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->containsInterval",
          "args": [
            "target",
            "target"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "segment->containsInterval(\n        reinterpret_cast<word*>(this), reinterpret_cast<word*>(this + 1))"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment->containsInterval",
          "args": [
            "reinterpret_cast<word*>(this)",
            "reinterpret_cast<word*>(this + 1)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "this + 1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "this"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(void setKindAndTarget(Kind kind, word* target, SegmentBuilder* segment)) {\n      // Check that the target is really in the same segment, otherwise subtracting pointers is\n      // undefined behavior.  As it turns out, it's undefined behavior that actually produces\n      // unexpected results in a real-world situation that actually happened:  At one time,\n      // OrphanBuilder's \"tag\" (a WirePointer) was allowed to be initialized as if it lived in\n      // a particular segment when in fact it does not.  On 32-bit systems, where words might\n      // only be 32-bit aligned, it's possible that the difference between `this` and `target` is\n      // not a whole number of words.  But clang optimizes:\n      //     (target - (word*)this - 1) << 2\n      // to:\n      //     (((ptrdiff_t)target - (ptrdiff_t)this - 8) >> 1)\n      // So now when the pointers are not aligned the same, we can end up corrupting the bottom\n      // two bits, where `kind` is stored.  For example, this turns a struct into a far pointer.\n      // Ouch!\n      KJ_DREQUIRE(segment->containsInterval(\n          reinterpret_cast<word*>(this), reinterpret_cast<word*>(this + 1)));\n      KJ_DREQUIRE(segment->containsInterval(target, target));\n      offsetAndKind.set(((target - reinterpret_cast<word*>(this) - 1) << 2) | kind);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "105-108",
    "snippet": "KJ_ALWAYS_INLINE(const word* target() const) {\n    return reinterpret_cast<const word*>(this) + 1 +\n        (static_cast<int32_t>(offsetAndKind.get()) >> 2);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<int32_t>",
          "args": [
            "offsetAndKind.get()"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const word*>",
          "args": [
            "this"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(const word* target() const) {\n      return reinterpret_cast<const word*>(this) + 1 +\n          (static_cast<int32_t>(offsetAndKind.get()) >> 2);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "102-104",
    "snippet": "KJ_ALWAYS_INLINE(word* target()) {\n    return reinterpret_cast<word*>(this) + 1 + (static_cast<int32_t>(offsetAndKind.get()) >> 2);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<int32_t>",
          "args": [
            "offsetAndKind.get()"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<word*>",
          "args": [
            "this"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(word* target()) {\n      return reinterpret_cast<word*>(this) + 1 + (static_cast<int32_t>(offsetAndKind.get()) >> 2);\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "98-100",
    "snippet": "KJ_ALWAYS_INLINE(bool isCapability() const) {\n    return offsetAndKind.get() == OTHER;\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(bool isCapability() const) {\n      return offsetAndKind.get() == OTHER;\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "95-97",
    "snippet": "KJ_ALWAYS_INLINE(bool isPositional() const) {\n    return (offsetAndKind.get() & 2) == 0;  // match STRUCT and LIST but not FAR or OTHER\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(bool isPositional() const) {\n      return (offsetAndKind.get() & 2) == 0;  // match STRUCT and LIST but not FAR or OTHER\n    }\n}"
  },
  {
    "function_name": "KJ_ALWAYS_INLINE",
    "container": "WirePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "92-94",
    "snippet": "KJ_ALWAYS_INLINE(Kind kind() const) {\n    return static_cast<Kind>(offsetAndKind.get() & 3);\n  }",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<Kind>",
          "args": [
            "offsetAndKind.get() & 3"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offsetAndKind.get",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nWirePointer {\n  KJ_ALWAYS_INLINE(Kind kind() const) {\n      return static_cast<Kind>(offsetAndKind.get() & 3);\n    }\n}"
  },
  {
    "function_name": "setGlobalBrokenCapFactoryForLayoutCpp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
    "lines": "41-45",
    "snippet": "void setGlobalBrokenCapFactoryForLayoutCpp(BrokenCapFactory& factory) {\n  // Called from capability.c++ when the capability API is used, to make sure that layout.c++\n  // is ready for it.  May be called multiple times but always with the same value.\n  __atomic_store_n(&brokenCapFactory, &factory, __ATOMIC_RELAXED);\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include \"arena.h\"",
      "#include <kj/debug.h>",
      "#include \"layout.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_store_n",
          "args": [
            "&brokenCapFactory",
            "&factory",
            "__ATOMIC_RELAXED"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid setGlobalBrokenCapFactoryForLayoutCpp(BrokenCapFactory& factory) {\n  // Called from capability.c++ when the capability API is used, to make sure that layout.c++\n  // is ready for it.  May be called multiple times but always with the same value.\n  __atomic_store_n(&brokenCapFactory, &factory, __ATOMIC_RELAXED);\n}"
  }
]