[
  {
    "function_name": "Debug::Context::logMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "342-352",
    "snippet": "void Debug::Context::logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                                String&& text) {\n  if (!logged) {\n    Value v = ensureInitialized();\n    next.logMessage(LogSeverity::INFO, v.file, v.line, 0,\n                    str(\"context: \", mv(v.description), '\\n'));\n    logged = true;\n  }\n\n  next.logMessage(severity, file, line, contextDepth + 1, mv(text));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next.logMessage",
          "args": [
            "severity",
            "file",
            "line",
            "contextDepth + 1",
            "mv(text)"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "logMessage",
          "container": "TestExceptionCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "252-269",
          "snippet": "void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                  String&& text) override {\n    void* traceSpace[32];\n    auto trace = getStackTrace(traceSpace);\n\n    if (text.size() == 0) {\n      text = kj::heapString(\"expectation failed\");\n    }\n\n    text = kj::str(kj::repeat('_', contextDepth), file, ':', line, \": \", kj::mv(text));\n\n    if (severity == LogSeverity::ERROR || severity == LogSeverity::FATAL) {\n      sawError = true;\n      context.error(kj::str(text, \"\\nstack: \", strArray(trace, \" \"), stringifyStackTrace(trace)));\n    } else {\n      context.warning(text);\n    }\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestExceptionCallback {\n  void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                    String&& text) override {\n      void* traceSpace[32];\n      auto trace = getStackTrace(traceSpace);\n  \n      if (text.size() == 0) {\n        text = kj::heapString(\"expectation failed\");\n      }\n  \n      text = kj::str(kj::repeat('_', contextDepth), file, ':', line, \": \", kj::mv(text));\n  \n      if (severity == LogSeverity::ERROR || severity == LogSeverity::FATAL) {\n        sawError = true;\n        context.error(kj::str(text, \"\\nstack: \", strArray(trace, \" \"), stringifyStackTrace(trace)));\n      } else {\n        context.warning(text);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "text"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"context: \"",
            "mv(v.description)",
            "'\\n'"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "v.description"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureInitialized",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ensureInitialized",
          "container": "RawSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "221-228",
          "snippet": "inline void ensureInitialized() const {\n    // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n    // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n    // types are always initialized; only dynamically-loaded schemas may be lazy.\n\n    const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n    if (i != nullptr) i->init(this);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawSchema {\n  inline void ensureInitialized() const {\n      // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n      // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n      // types are always initialized; only dynamically-loaded schemas may be lazy.\n  \n      const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n      if (i != nullptr) i->init(this);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nvoid Debug::Context::logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                                String&& text) {\n  if (!logged) {\n    Value v = ensureInitialized();\n    next.logMessage(LogSeverity::INFO, v.file, v.line, 0,\n                    str(\"context: \", mv(v.description), '\\n'));\n    logged = true;\n  }\n\n  next.logMessage(severity, file, line, contextDepth + 1, mv(text));\n}"
  },
  {
    "function_name": "Debug::Context::onFatalException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "337-341",
    "snippet": "void Debug::Context::onFatalException(Exception&& exception) {\n  Value v = ensureInitialized();\n  exception.wrapContext(v.file, v.line, mv(v.description));\n  next.onFatalException(kj::mv(exception));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next.onFatalException",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "onFatalException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "303-309",
          "snippet": "void onFatalException(Exception&& exception) override {\n#if KJ_NO_EXCEPTIONS\n    logException(LogSeverity::FATAL, mv(exception));\n#else\n    throw ExceptionImpl(mv(exception));\n#endif\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid onFatalException(Exception&& exception) override {\n#if KJ_NO_EXCEPTIONS\n    logException(LogSeverity::FATAL, mv(exception));\n#else\n    throw ExceptionImpl(mv(exception));\n#endif\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.wrapContext",
          "args": [
            "v.file",
            "v.line",
            "mv(v.description)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "v.description"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureInitialized",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ensureInitialized",
          "container": "RawSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "221-228",
          "snippet": "inline void ensureInitialized() const {\n    // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n    // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n    // types are always initialized; only dynamically-loaded schemas may be lazy.\n\n    const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n    if (i != nullptr) i->init(this);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawSchema {\n  inline void ensureInitialized() const {\n      // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n      // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n      // types are always initialized; only dynamically-loaded schemas may be lazy.\n  \n      const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n      if (i != nullptr) i->init(this);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nvoid Debug::Context::onFatalException(Exception&& exception) {\n  Value v = ensureInitialized();\n  exception.wrapContext(v.file, v.line, mv(v.description));\n  next.onFatalException(kj::mv(exception));\n}"
  },
  {
    "function_name": "Debug::Context::onRecoverableException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "332-336",
    "snippet": "void Debug::Context::onRecoverableException(Exception&& exception) {\n  Value v = ensureInitialized();\n  exception.wrapContext(v.file, v.line, mv(v.description));\n  next.onRecoverableException(kj::mv(exception));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next.onRecoverableException",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "onRecoverableException",
          "container": "RecoverableExceptionCatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "446-452",
          "snippet": "void onRecoverableException(Exception&& exception) override {\n    if (caught == nullptr) {\n      caught = mv(exception);\n    } else {\n      // TODO(someday):  Consider it a secondary fault?\n    }\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nRecoverableExceptionCatcher {\n  void onRecoverableException(Exception&& exception) override {\n      if (caught == nullptr) {\n        caught = mv(exception);\n      } else {\n        // TODO(someday):  Consider it a secondary fault?\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exception.wrapContext",
          "args": [
            "v.file",
            "v.line",
            "mv(v.description)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "v.description"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensureInitialized",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ensureInitialized",
          "container": "RawSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "221-228",
          "snippet": "inline void ensureInitialized() const {\n    // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n    // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n    // types are always initialized; only dynamically-loaded schemas may be lazy.\n\n    const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n    if (i != nullptr) i->init(this);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nRawSchema {\n  inline void ensureInitialized() const {\n      // Lazy initialization support.  Invoke to ensure that initialization has taken place.  This\n      // is required in particular when traversing the dependency list.  RawSchemas for compiled-in\n      // types are always initialized; only dynamically-loaded schemas may be lazy.\n  \n      const Initializer* i = __atomic_load_n(&lazyInitializer, __ATOMIC_ACQUIRE);\n      if (i != nullptr) i->init(this);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nvoid Debug::Context::onRecoverableException(Exception&& exception) {\n  Value v = ensureInitialized();\n  exception.wrapContext(v.file, v.line, mv(v.description));\n  next.onRecoverableException(kj::mv(exception));\n}"
  },
  {
    "function_name": "Debug::Context::ensureInitialized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "322-329",
    "snippet": "Debug::Context::Value Debug::Context::ensureInitialized() {\n  KJ_IF_MAYBE(v, value) {\n    return Value(v->file, v->line, heapString(v->description));\n  } else {\n    Value result = evaluate();\n    value = Value(result.file, result.line, heapString(result.description));\n    return result;\n  }",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Value",
          "args": [
            "result.file",
            "result.line",
            "heapString(result.description)"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "Debug::Context::Value",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.h",
          "lines": "340-341",
          "snippet": "inline Value(const char* file, int line, String&& description)\n          : file(file), line(line), description(mv(description)) {}",
          "includes": [
            "#include \"exception.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"string.h\"\n\nDebug {\n  Context {\n    Value {\n      inline Value(const char* file, int line, String&& description)\n                : file(file), line(line), description(mv(description)) {}\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "result.description"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "evaluate",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "evaluate",
          "container": "Debug::ContextImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.h",
          "lines": "364-366",
          "snippet": "Value evaluate() override {\n      return func();\n    }",
          "includes": [
            "#include \"exception.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"string.h\"\n\nDebug {\n  ContextImpl {\n    Value evaluate() override {\n          return func();\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nDebug::Context::Value Debug::Context::ensureInitialized() {\n  KJ_IF_MAYBE(v, value) {\n    return Value(v->file, v->line, heapString(v->description));\n  } else {\n    Value result = evaluate();\n    value = Value(result.file, result.line, heapString(result.description));\n    return result;\n  }"
  },
  {
    "function_name": "Debug::Context::~Context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "320-320",
    "snippet": "Debug::Context::~Context() noexcept(false) {}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nDebug::Context::~Context() noexcept(false) {}"
  },
  {
    "function_name": "Debug::Context::Context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "319-319",
    "snippet": "Debug::Context::Context(): logged(false) {}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nDebug::Context::Context(): logged(false) {}"
  },
  {
    "function_name": "Debug::getOsErrorNumber",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "309-317",
    "snippet": "int Debug::getOsErrorNumber(bool nonblocking) {\n  int result = errno;\n\n  // On many systems, EAGAIN and EWOULDBLOCK have the same value, but this is not strictly required\n  // by POSIX, so we need to check both.\n  return result == EINTR ? -1\n       : nonblocking && (result == EAGAIN || result == EWOULDBLOCK) ? 0\n       : result;\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nint Debug::getOsErrorNumber(bool nonblocking) {\n  int result = errno;\n\n  // On many systems, EAGAIN and EWOULDBLOCK have the same value, but this is not strictly required\n  // by POSIX, so we need to check both.\n  return result == EINTR ? -1\n       : nonblocking && (result == EAGAIN || result == EWOULDBLOCK) ? 0\n       : result;\n}"
  },
  {
    "function_name": "Debug::makeDescriptionInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "305-307",
    "snippet": "String Debug::makeDescriptionInternal(const char* macroArgs, ArrayPtr<String> argValues) {\n  return makeDescriptionImpl(LOG, nullptr, 0, macroArgs, argValues);\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeDescriptionImpl",
          "args": [
            "LOG",
            "nullptr",
            "0",
            "macroArgs",
            "argValues"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "makeDescriptionImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
          "lines": "134-265",
          "snippet": "static String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}",
          "includes": [
            "#include <errno.h>",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nstatic String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nString Debug::makeDescriptionInternal(const char* macroArgs, ArrayPtr<String> argValues) {\n  return makeDescriptionImpl(LOG, nullptr, 0, macroArgs, argValues);\n}"
  },
  {
    "function_name": "Debug::Fault::init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "298-303",
    "snippet": "void Debug::Fault::init(\n    const char* file, int line, int osErrorNumber,\n    const char* condition, const char* macroArgs, ArrayPtr<String> argValues) {\n  exception = new Exception(typeOfErrno(osErrorNumber), file, line,\n      makeDescriptionImpl(SYSCALL, condition, osErrorNumber, macroArgs, argValues));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeDescriptionImpl",
          "args": [
            "SYSCALL",
            "condition",
            "osErrorNumber",
            "macroArgs",
            "argValues"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "makeDescriptionImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
          "lines": "134-265",
          "snippet": "static String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}",
          "includes": [
            "#include <errno.h>",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nstatic String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "typeOfErrno",
          "args": [
            "osErrorNumber"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "typeOfErrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
          "lines": "39-126",
          "snippet": "Exception::Type typeOfErrno(int error) {\n  switch (error) {\n#ifdef EDQUOT\n    case EDQUOT:\n#endif\n#ifdef EMFILE\n    case EMFILE:\n#endif\n#ifdef ENFILE\n    case ENFILE:\n#endif\n#ifdef ENOBUFS\n    case ENOBUFS:\n#endif\n#ifdef ENOLCK\n    case ENOLCK:\n#endif\n#ifdef ENOMEM\n    case ENOMEM:\n#endif\n#ifdef ENOSPC\n    case ENOSPC:\n#endif\n#ifdef ETIMEDOUT\n    case ETIMEDOUT:\n#endif\n#ifdef EUSERS\n    case EUSERS:\n#endif\n      return Exception::Type::OVERLOADED;\n\n#ifdef ENOTCONN\n    case ENOTCONN:\n#endif\n#ifdef ECONNABORTED\n    case ECONNABORTED:\n#endif\n#ifdef ECONNREFUSED\n    case ECONNREFUSED:\n#endif\n#ifdef ECONNRESET\n    case ECONNRESET:\n#endif\n#ifdef EHOSTDOWN\n    case EHOSTDOWN:\n#endif\n#ifdef EHOSTUNREACH\n    case EHOSTUNREACH:\n#endif\n#ifdef ENETDOWN\n    case ENETDOWN:\n#endif\n#ifdef ENETRESET\n    case ENETRESET:\n#endif\n#ifdef ENETUNREACH\n    case ENETUNREACH:\n#endif\n#ifdef ENONET\n    case ENONET:\n#endif\n#ifdef EPIPE\n    case EPIPE:\n#endif\n      return Exception::Type::DISCONNECTED;\n\n#ifdef ENOSYS\n    case ENOSYS:\n#endif\n#ifdef ENOTSUP\n    case ENOTSUP:\n#endif\n#if defined(EOPNOTSUPP) && EOPNOTSUPP != ENOTSUP\n    case EOPNOTSUPP:\n#endif\n#ifdef ENOPROTOOPT\n    case ENOPROTOOPT:\n#endif\n#ifdef ENOTSOCK\n    // This is really saying \"syscall not implemented for non-sockets\".\n    case ENOTSOCK:\n#endif\n      return Exception::Type::UNIMPLEMENTED;\n\n    default:\n      return Exception::Type::FAILED;\n  }\n}",
          "includes": [
            "#include <errno.h>",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nException::Type typeOfErrno(int error) {\n  switch (error) {\n#ifdef EDQUOT\n    case EDQUOT:\n#endif\n#ifdef EMFILE\n    case EMFILE:\n#endif\n#ifdef ENFILE\n    case ENFILE:\n#endif\n#ifdef ENOBUFS\n    case ENOBUFS:\n#endif\n#ifdef ENOLCK\n    case ENOLCK:\n#endif\n#ifdef ENOMEM\n    case ENOMEM:\n#endif\n#ifdef ENOSPC\n    case ENOSPC:\n#endif\n#ifdef ETIMEDOUT\n    case ETIMEDOUT:\n#endif\n#ifdef EUSERS\n    case EUSERS:\n#endif\n      return Exception::Type::OVERLOADED;\n\n#ifdef ENOTCONN\n    case ENOTCONN:\n#endif\n#ifdef ECONNABORTED\n    case ECONNABORTED:\n#endif\n#ifdef ECONNREFUSED\n    case ECONNREFUSED:\n#endif\n#ifdef ECONNRESET\n    case ECONNRESET:\n#endif\n#ifdef EHOSTDOWN\n    case EHOSTDOWN:\n#endif\n#ifdef EHOSTUNREACH\n    case EHOSTUNREACH:\n#endif\n#ifdef ENETDOWN\n    case ENETDOWN:\n#endif\n#ifdef ENETRESET\n    case ENETRESET:\n#endif\n#ifdef ENETUNREACH\n    case ENETUNREACH:\n#endif\n#ifdef ENONET\n    case ENONET:\n#endif\n#ifdef EPIPE\n    case EPIPE:\n#endif\n      return Exception::Type::DISCONNECTED;\n\n#ifdef ENOSYS\n    case ENOSYS:\n#endif\n#ifdef ENOTSUP\n    case ENOTSUP:\n#endif\n#if defined(EOPNOTSUPP) && EOPNOTSUPP != ENOTSUP\n    case EOPNOTSUPP:\n#endif\n#ifdef ENOPROTOOPT\n    case ENOPROTOOPT:\n#endif\n#ifdef ENOTSOCK\n    // This is really saying \"syscall not implemented for non-sockets\".\n    case ENOTSOCK:\n#endif\n      return Exception::Type::UNIMPLEMENTED;\n\n    default:\n      return Exception::Type::FAILED;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nvoid Debug::Fault::init(\n    const char* file, int line, int osErrorNumber,\n    const char* condition, const char* macroArgs, ArrayPtr<String> argValues) {\n  exception = new Exception(typeOfErrno(osErrorNumber), file, line,\n      makeDescriptionImpl(SYSCALL, condition, osErrorNumber, macroArgs, argValues));\n}"
  },
  {
    "function_name": "Debug::Fault::init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "291-296",
    "snippet": "void Debug::Fault::init(\n    const char* file, int line, Exception::Type type,\n    const char* condition, const char* macroArgs, ArrayPtr<String> argValues) {\n  exception = new Exception(type, file, line,\n      makeDescriptionImpl(ASSERTION, condition, 0, macroArgs, argValues));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeDescriptionImpl",
          "args": [
            "ASSERTION",
            "condition",
            "0",
            "macroArgs",
            "argValues"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "makeDescriptionImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
          "lines": "134-265",
          "snippet": "static String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}",
          "includes": [
            "#include <errno.h>",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nstatic String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nvoid Debug::Fault::init(\n    const char* file, int line, Exception::Type type,\n    const char* condition, const char* macroArgs, ArrayPtr<String> argValues) {\n  exception = new Exception(type, file, line,\n      makeDescriptionImpl(ASSERTION, condition, 0, macroArgs, argValues));\n}"
  },
  {
    "function_name": "Debug::Fault::fatal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "283-289",
    "snippet": "void Debug::Fault::fatal() {\n  Exception copy = mv(*exception);\n  delete exception;\n  exception = nullptr;\n  throwFatalException(mv(copy));\n  abort();\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "abortRead",
          "container": "AsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.h",
          "lines": "69-69",
          "snippet": "virtual void abortRead() {}",
          "includes": [
            "#include \"time.h\"",
            "#include \"thread.h\"",
            "#include \"function.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"time.h\"\n#include \"thread.h\"\n#include \"function.h\"\n#include \"async.h\"\n\nAsyncIoStream {\n  virtual void abortRead() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "throwFatalException",
          "args": [
            "mv(copy)"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "throwFatalException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "348-351",
          "snippet": "void throwFatalException(kj::Exception&& exception) {\n  getExceptionCallback().onFatalException(kj::mv(exception));\n  abort();\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwFatalException(kj::Exception&& exception) {\n  getExceptionCallback().onFatalException(kj::mv(exception));\n  abort();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "copy"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "*exception"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nvoid Debug::Fault::fatal() {\n  Exception copy = mv(*exception);\n  delete exception;\n  exception = nullptr;\n  throwFatalException(mv(copy));\n  abort();\n}"
  },
  {
    "function_name": "Debug::Fault::~Fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "275-281",
    "snippet": "Debug::Fault::~Fault() noexcept(false) {\n  if (exception != nullptr) {\n    Exception copy = mv(*exception);\n    delete exception;\n    throwRecoverableException(mv(copy));\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "throwRecoverableException",
          "args": [
            "mv(copy)"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "throwRecoverableException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "353-355",
          "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "copy"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "*exception"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nDebug::Fault::~Fault() noexcept(false) {\n  if (exception != nullptr) {\n    Exception copy = mv(*exception);\n    delete exception;\n    throwRecoverableException(mv(copy));\n  }\n}"
  },
  {
    "function_name": "Debug::logInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "269-273",
    "snippet": "void Debug::logInternal(const char* file, int line, LogSeverity severity, const char* macroArgs,\n                        ArrayPtr<String> argValues) {\n  getExceptionCallback().logMessage(severity, file, line, 0,\n      makeDescriptionImpl(LOG, nullptr, 0, macroArgs, argValues));\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [
            "severity",
            "file",
            "line",
            "0",
            "makeDescriptionImpl(LOG, nullptr, 0, macroArgs, argValues)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeDescriptionImpl",
          "args": [
            "LOG",
            "nullptr",
            "0",
            "macroArgs",
            "argValues"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "makeDescriptionImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
          "lines": "134-265",
          "snippet": "static String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}",
          "includes": [
            "#include <errno.h>",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdlib.h>",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nstatic String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nvoid Debug::logInternal(const char* file, int line, LogSeverity severity, const char* macroArgs,\n                        ArrayPtr<String> argValues) {\n  getExceptionCallback().logMessage(severity, file, line, 0,\n      makeDescriptionImpl(LOG, nullptr, 0, macroArgs, argValues));\n}"
  },
  {
    "function_name": "makeDescriptionImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "134-265",
    "snippet": "static String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::fill",
          "args": [
            "pos",
            "argValues[i]"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::fill",
          "args": [
            "pos",
            "argNames[i]",
            "sep"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argNames[i].size",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_::fill",
          "args": [
            "pos",
            "delim"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::fill",
          "args": [
            "pos",
            "codeArray",
            "colon",
            "sysErrorArray"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::fill",
          "args": [
            "pos",
            "expected",
            "codeArray"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "totalSize"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errorNumber",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror_r",
          "args": [
            "errorNumber",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "code"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*code"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "code",
            "'='"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [
            "LogSeverity::ERROR",
            "__FILE__",
            "__LINE__",
            "0",
            "str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n')"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"Failed to parse logging macro args into \"",
            "argValues.size()",
            "\" names: \"",
            "macroArgs",
            "'\\n'"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arrayPtr",
          "args": [
            "start",
            "pos - 1"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*pos"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*start"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_STACK_ARRAY",
          "args": [
            "ArrayPtr<const char>",
            "argNames",
            "argValues.size()",
            "8",
            "64"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nstatic String makeDescriptionImpl(DescriptionStyle style, const char* code, int errorNumber,\n                                  const char* macroArgs, ArrayPtr<String> argValues) {\n  KJ_STACK_ARRAY(ArrayPtr<const char>, argNames, argValues.size(), 8, 64);\n\n  if (argValues.size() > 0) {\n    size_t index = 0;\n    const char* start = macroArgs;\n    while (isspace(*start)) ++start;\n    const char* pos = start;\n    uint depth = 0;\n    bool quoted = false;\n    while (char c = *pos++) {\n      if (quoted) {\n        if (c == '\\\\' && *pos != '\\0') {\n          ++pos;\n        } else if (c == '\\\"') {\n          quoted = false;\n        }\n      } else {\n        if (c == '(') {\n          ++depth;\n        } else if (c == ')') {\n          --depth;\n        } else if (c == '\\\"') {\n          quoted = true;\n        } else if (c == ',' && depth == 0) {\n          if (index < argValues.size()) {\n            argNames[index] = arrayPtr(start, pos - 1);\n          }\n          ++index;\n          while (isspace(*pos)) ++pos;\n          start = pos;\n        }\n      }\n    }\n    if (index < argValues.size()) {\n      argNames[index] = arrayPtr(start, pos - 1);\n    }\n    ++index;\n\n    if (index != argValues.size()) {\n      getExceptionCallback().logMessage(LogSeverity::ERROR, __FILE__, __LINE__, 0,\n          str(\"Failed to parse logging macro args into \",\n              argValues.size(), \" names: \", macroArgs, '\\n'));\n    }\n  }\n\n  if (style == SYSCALL) {\n    // Strip off leading \"foo = \" from code, since callers will sometimes write things like:\n    //   ssize_t n;\n    //   RECOVERABLE_SYSCALL(n = read(fd, buffer, sizeof(buffer))) { return \"\"; }\n    //   return std::string(buffer, n);\n    const char* equalsPos = strchr(code, '=');\n    if (equalsPos != nullptr && equalsPos[1] != '=') {\n      code = equalsPos + 1;\n      while (isspace(*code)) ++code;\n    }\n  }\n\n  if (style == ASSERTION && code == nullptr) {\n    style = LOG;\n  }\n\n  {\n    StringPtr expected = \"expected \";\n    StringPtr codeArray = style == LOG ? nullptr : StringPtr(code);\n    StringPtr sep = \" = \";\n    StringPtr delim = \"; \";\n    StringPtr colon = \": \";\n\n    StringPtr sysErrorArray;\n#if __USE_GNU\n    char buffer[256];\n    if (style == SYSCALL) {\n      sysErrorArray = strerror_r(errorNumber, buffer, sizeof(buffer));\n    }\n#else\n    char buffer[256];\n    if (style == SYSCALL) {\n      strerror_r(errorNumber, buffer, sizeof(buffer));\n      sysErrorArray = buffer;\n    }\n#endif\n\n    size_t totalSize = 0;\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        totalSize += expected.size() + codeArray.size();\n        break;\n      case SYSCALL:\n        totalSize += codeArray.size() + colon.size() + sysErrorArray.size();\n        break;\n    }\n\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        totalSize += delim.size();\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        totalSize += argNames[i].size() + sep.size();\n      }\n      totalSize += argValues[i].size();\n    }\n\n    String result = heapString(totalSize);\n    char* pos = result.begin();\n\n    switch (style) {\n      case LOG:\n        break;\n      case ASSERTION:\n        pos = _::fill(pos, expected, codeArray);\n        break;\n      case SYSCALL:\n        pos = _::fill(pos, codeArray, colon, sysErrorArray);\n        break;\n    }\n    for (size_t i = 0; i < argValues.size(); i++) {\n      if (i > 0 || style != LOG) {\n        pos = _::fill(pos, delim);\n      }\n      if (argNames[i].size() > 0 && argNames[i][0] != '\\\"') {\n        pos = _::fill(pos, argNames[i], sep);\n      }\n      pos = _::fill(pos, argValues[i]);\n    }\n\n    return result;\n  }\n}"
  },
  {
    "function_name": "typeOfErrno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug.c++",
    "lines": "39-126",
    "snippet": "Exception::Type typeOfErrno(int error) {\n  switch (error) {\n#ifdef EDQUOT\n    case EDQUOT:\n#endif\n#ifdef EMFILE\n    case EMFILE:\n#endif\n#ifdef ENFILE\n    case ENFILE:\n#endif\n#ifdef ENOBUFS\n    case ENOBUFS:\n#endif\n#ifdef ENOLCK\n    case ENOLCK:\n#endif\n#ifdef ENOMEM\n    case ENOMEM:\n#endif\n#ifdef ENOSPC\n    case ENOSPC:\n#endif\n#ifdef ETIMEDOUT\n    case ETIMEDOUT:\n#endif\n#ifdef EUSERS\n    case EUSERS:\n#endif\n      return Exception::Type::OVERLOADED;\n\n#ifdef ENOTCONN\n    case ENOTCONN:\n#endif\n#ifdef ECONNABORTED\n    case ECONNABORTED:\n#endif\n#ifdef ECONNREFUSED\n    case ECONNREFUSED:\n#endif\n#ifdef ECONNRESET\n    case ECONNRESET:\n#endif\n#ifdef EHOSTDOWN\n    case EHOSTDOWN:\n#endif\n#ifdef EHOSTUNREACH\n    case EHOSTUNREACH:\n#endif\n#ifdef ENETDOWN\n    case ENETDOWN:\n#endif\n#ifdef ENETRESET\n    case ENETRESET:\n#endif\n#ifdef ENETUNREACH\n    case ENETUNREACH:\n#endif\n#ifdef ENONET\n    case ENONET:\n#endif\n#ifdef EPIPE\n    case EPIPE:\n#endif\n      return Exception::Type::DISCONNECTED;\n\n#ifdef ENOSYS\n    case ENOSYS:\n#endif\n#ifdef ENOTSUP\n    case ENOTSUP:\n#endif\n#if defined(EOPNOTSUPP) && EOPNOTSUPP != ENOTSUP\n    case EOPNOTSUPP:\n#endif\n#ifdef ENOPROTOOPT\n    case ENOPROTOOPT:\n#endif\n#ifdef ENOTSOCK\n    // This is really saying \"syscall not implemented for non-sockets\".\n    case ENOTSOCK:\n#endif\n      return Exception::Type::UNIMPLEMENTED;\n\n    default:\n      return Exception::Type::FAILED;\n  }\n}",
    "includes": [
      "#include <errno.h>",
      "#include <string.h>",
      "#include <ctype.h>",
      "#include <stdlib.h>",
      "#include \"debug.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <errno.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include \"debug.h\"\n\nException::Type typeOfErrno(int error) {\n  switch (error) {\n#ifdef EDQUOT\n    case EDQUOT:\n#endif\n#ifdef EMFILE\n    case EMFILE:\n#endif\n#ifdef ENFILE\n    case ENFILE:\n#endif\n#ifdef ENOBUFS\n    case ENOBUFS:\n#endif\n#ifdef ENOLCK\n    case ENOLCK:\n#endif\n#ifdef ENOMEM\n    case ENOMEM:\n#endif\n#ifdef ENOSPC\n    case ENOSPC:\n#endif\n#ifdef ETIMEDOUT\n    case ETIMEDOUT:\n#endif\n#ifdef EUSERS\n    case EUSERS:\n#endif\n      return Exception::Type::OVERLOADED;\n\n#ifdef ENOTCONN\n    case ENOTCONN:\n#endif\n#ifdef ECONNABORTED\n    case ECONNABORTED:\n#endif\n#ifdef ECONNREFUSED\n    case ECONNREFUSED:\n#endif\n#ifdef ECONNRESET\n    case ECONNRESET:\n#endif\n#ifdef EHOSTDOWN\n    case EHOSTDOWN:\n#endif\n#ifdef EHOSTUNREACH\n    case EHOSTUNREACH:\n#endif\n#ifdef ENETDOWN\n    case ENETDOWN:\n#endif\n#ifdef ENETRESET\n    case ENETRESET:\n#endif\n#ifdef ENETUNREACH\n    case ENETUNREACH:\n#endif\n#ifdef ENONET\n    case ENONET:\n#endif\n#ifdef EPIPE\n    case EPIPE:\n#endif\n      return Exception::Type::DISCONNECTED;\n\n#ifdef ENOSYS\n    case ENOSYS:\n#endif\n#ifdef ENOTSUP\n    case ENOTSUP:\n#endif\n#if defined(EOPNOTSUPP) && EOPNOTSUPP != ENOTSUP\n    case EOPNOTSUPP:\n#endif\n#ifdef ENOPROTOOPT\n    case ENOPROTOOPT:\n#endif\n#ifdef ENOTSOCK\n    // This is really saying \"syscall not implemented for non-sockets\".\n    case ENOTSOCK:\n#endif\n      return Exception::Type::UNIMPLEMENTED;\n\n    default:\n      return Exception::Type::FAILED;\n  }\n}"
  }
]