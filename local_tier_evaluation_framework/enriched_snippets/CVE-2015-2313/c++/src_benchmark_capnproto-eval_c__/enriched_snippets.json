[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-eval.c++",
    "lines": "120-124",
    "snippet": "int main(int argc, char* argv[]) {\n  return capnp::benchmark::benchmarkMain<\n      capnp::benchmark::capnp::BenchmarkTypes,\n      capnp::benchmark::capnp::ExpressionTestCase>(argc, argv);\n}",
    "includes": [
      "#include \"capnproto-common.h\"",
      "#include \"eval.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capnp::benchmark::benchmarkMain<\n      capnp::benchmark::capnp::BenchmarkTypes,\n      capnp::benchmark::capnp::ExpressionTestCase>",
          "args": [
            "argc",
            "argv"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "benchmarkMain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "281-292",
          "snippet": "int benchmarkMain(int argc, char* argv[]) {\n  if (argc != 5) {\n    fprintf(stderr, \"USAGE:  %s MODE REUSE COMPRESSION ITERATION_COUNT\\n\", argv[0]);\n    return 1;\n  }\n\n  uint64_t iters = strtoull(argv[4], nullptr, 0);\n  uint64_t throughput = doBenchmark3<BenchmarkTypes, TestCase>(argv[1], argv[2], argv[3], iters);\n  fprintf(stdout, \"%llu\\n\", (long long unsigned int)throughput);\n\n  return 0;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nint benchmarkMain(int argc, char* argv[]) {\n  if (argc != 5) {\n    fprintf(stderr, \"USAGE:  %s MODE REUSE COMPRESSION ITERATION_COUNT\\n\", argv[0]);\n    return 1;\n  }\n\n  uint64_t iters = strtoull(argv[4], nullptr, 0);\n  uint64_t throughput = doBenchmark3<BenchmarkTypes, TestCase>(argv[1], argv[2], argv[3], iters);\n  fprintf(stdout, \"%llu\\n\", (long long unsigned int)throughput);\n\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"eval.capnp.h\"\n\nint main(int argc, char* argv[]) {\n  return capnp::benchmark::benchmarkMain<\n      capnp::benchmark::capnp::BenchmarkTypes,\n      capnp::benchmark::capnp::ExpressionTestCase>(argc, argv);\n}"
  },
  {
    "function_name": "checkResponse",
    "container": "ExpressionTestCase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-eval.c++",
    "lines": "111-113",
    "snippet": "static inline bool checkResponse(EvaluationResult::Reader response, int32_t expected) {\n    return response.getValue() == expected;\n  }",
    "includes": [
      "#include \"capnproto-common.h\"",
      "#include \"eval.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "response.getValue",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"eval.capnp.h\"\n\nExpressionTestCase {\n  static inline bool checkResponse(EvaluationResult::Reader response, int32_t expected) {\n      return response.getValue() == expected;\n    }\n}"
  },
  {
    "function_name": "handleRequest",
    "container": "ExpressionTestCase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-eval.c++",
    "lines": "108-110",
    "snippet": "static inline void handleRequest(Expression::Reader request, EvaluationResult::Builder response) {\n    response.setValue(evaluateExpression(request));\n  }",
    "includes": [
      "#include \"capnproto-common.h\"",
      "#include \"eval.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "response.setValue",
          "args": [
            "evaluateExpression(request)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluateExpression",
          "args": [
            "request"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "evaluateExpression",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-eval.c++",
          "lines": "63-97",
          "snippet": "int32_t evaluateExpression(Expression::Reader exp) {\n  int32_t left = 0, right = 0;\n\n  switch (exp.getLeft().which()) {\n    case Expression::Left::VALUE:\n      left = exp.getLeft().getValue();\n      break;\n    case Expression::Left::EXPRESSION:\n      left = evaluateExpression(exp.getLeft().getExpression());\n      break;\n  }\n\n  switch (exp.getRight().which()) {\n    case Expression::Right::VALUE:\n      right = exp.getRight().getValue();\n      break;\n    case Expression::Right::EXPRESSION:\n      right = evaluateExpression(exp.getRight().getExpression());\n      break;\n  }\n\n  switch (exp.getOp()) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"eval.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"eval.capnp.h\"\n\nint32_t evaluateExpression(Expression::Reader exp) {\n  int32_t left = 0, right = 0;\n\n  switch (exp.getLeft().which()) {\n    case Expression::Left::VALUE:\n      left = exp.getLeft().getValue();\n      break;\n    case Expression::Left::EXPRESSION:\n      left = evaluateExpression(exp.getLeft().getExpression());\n      break;\n  }\n\n  switch (exp.getRight().which()) {\n    case Expression::Right::VALUE:\n      right = exp.getRight().getValue();\n      break;\n    case Expression::Right::EXPRESSION:\n      right = evaluateExpression(exp.getRight().getExpression());\n      break;\n  }\n\n  switch (exp.getOp()) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"eval.capnp.h\"\n\nExpressionTestCase {\n  static inline void handleRequest(Expression::Reader request, EvaluationResult::Builder response) {\n      response.setValue(evaluateExpression(request));\n    }\n}"
  },
  {
    "function_name": "setupRequest",
    "container": "ExpressionTestCase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-eval.c++",
    "lines": "105-107",
    "snippet": "static inline int32_t setupRequest(Expression::Builder request) {\n    return makeExpression(request, 0);\n  }",
    "includes": [
      "#include \"capnproto-common.h\"",
      "#include \"eval.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeExpression",
          "args": [
            "request",
            "0"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "makeExpression",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-eval.c++",
          "lines": "29-61",
          "snippet": "int32_t makeExpression(Expression::Builder exp, uint depth) {\n  exp.setOp((Operation)(fastRand((int)Operation::MODULUS + 1)));\n\n  uint32_t left, right;\n\n  if (fastRand(8) < depth) {\n    left = fastRand(128) + 1;\n    exp.getLeft().setValue(left);\n  } else {\n    left = makeExpression(exp.getLeft().initExpression(), depth + 1);\n  }\n\n  if (fastRand(8) < depth) {\n    right = fastRand(128) + 1;\n    exp.getRight().setValue(right);\n  } else {\n    right = makeExpression(exp.getRight().initExpression(), depth + 1);\n  }\n\n  switch (exp.getOp()) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}",
          "includes": [
            "#include \"capnproto-common.h\"",
            "#include \"eval.capnp.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"eval.capnp.h\"\n\nint32_t makeExpression(Expression::Builder exp, uint depth) {\n  exp.setOp((Operation)(fastRand((int)Operation::MODULUS + 1)));\n\n  uint32_t left, right;\n\n  if (fastRand(8) < depth) {\n    left = fastRand(128) + 1;\n    exp.getLeft().setValue(left);\n  } else {\n    left = makeExpression(exp.getLeft().initExpression(), depth + 1);\n  }\n\n  if (fastRand(8) < depth) {\n    right = fastRand(128) + 1;\n    exp.getRight().setValue(right);\n  } else {\n    right = makeExpression(exp.getRight().initExpression(), depth + 1);\n  }\n\n  switch (exp.getOp()) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"eval.capnp.h\"\n\nExpressionTestCase {\n  static inline int32_t setupRequest(Expression::Builder request) {\n      return makeExpression(request, 0);\n    }\n}"
  },
  {
    "function_name": "evaluateExpression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-eval.c++",
    "lines": "63-97",
    "snippet": "int32_t evaluateExpression(Expression::Reader exp) {\n  int32_t left = 0, right = 0;\n\n  switch (exp.getLeft().which()) {\n    case Expression::Left::VALUE:\n      left = exp.getLeft().getValue();\n      break;\n    case Expression::Left::EXPRESSION:\n      left = evaluateExpression(exp.getLeft().getExpression());\n      break;\n  }\n\n  switch (exp.getRight().which()) {\n    case Expression::Right::VALUE:\n      right = exp.getRight().getValue();\n      break;\n    case Expression::Right::EXPRESSION:\n      right = evaluateExpression(exp.getRight().getExpression());\n      break;\n  }\n\n  switch (exp.getOp()) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}",
    "includes": [
      "#include \"capnproto-common.h\"",
      "#include \"eval.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Can't get here.\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod",
          "args": [
            "left",
            "right"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "81-88",
          "snippet": "inline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div",
          "args": [
            "left",
            "right"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "div",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "72-79",
          "snippet": "inline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp.getOp",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"eval.capnp.h\"\n\nint32_t evaluateExpression(Expression::Reader exp) {\n  int32_t left = 0, right = 0;\n\n  switch (exp.getLeft().which()) {\n    case Expression::Left::VALUE:\n      left = exp.getLeft().getValue();\n      break;\n    case Expression::Left::EXPRESSION:\n      left = evaluateExpression(exp.getLeft().getExpression());\n      break;\n  }\n\n  switch (exp.getRight().which()) {\n    case Expression::Right::VALUE:\n      right = exp.getRight().getValue();\n      break;\n    case Expression::Right::EXPRESSION:\n      right = evaluateExpression(exp.getRight().getExpression());\n      break;\n  }\n\n  switch (exp.getOp()) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}"
  },
  {
    "function_name": "makeExpression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-eval.c++",
    "lines": "29-61",
    "snippet": "int32_t makeExpression(Expression::Builder exp, uint depth) {\n  exp.setOp((Operation)(fastRand((int)Operation::MODULUS + 1)));\n\n  uint32_t left, right;\n\n  if (fastRand(8) < depth) {\n    left = fastRand(128) + 1;\n    exp.getLeft().setValue(left);\n  } else {\n    left = makeExpression(exp.getLeft().initExpression(), depth + 1);\n  }\n\n  if (fastRand(8) < depth) {\n    right = fastRand(128) + 1;\n    exp.getRight().setValue(right);\n  } else {\n    right = makeExpression(exp.getRight().initExpression(), depth + 1);\n  }\n\n  switch (exp.getOp()) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}",
    "includes": [
      "#include \"capnproto-common.h\"",
      "#include \"eval.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::logic_error",
          "args": [
            "\"Can't get here.\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod",
          "args": [
            "left",
            "right"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "81-88",
          "snippet": "inline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t mod(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN % -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a % b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div",
          "args": [
            "left",
            "right"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "div",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "72-79",
          "snippet": "inline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\ninline int32_t div(int32_t a, int32_t b) {\n  if (b == 0) return std::numeric_limits<int32_t>::max();\n  // INT_MIN / -1 => SIGFPE.  Who knew?\n  if (a == std::numeric_limits<int32_t>::min() && b == -1) {\n    return std::numeric_limits<int32_t>::max();\n  }\n  return a / b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp.getOp",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [
            "right"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRight",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastRand",
          "args": [
            "128"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "fastRand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/common.h",
          "lines": "64-66",
          "snippet": "static inline uint32_t fastRand(uint32_t range) {\n  return nextFastRand() % range;\n}",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdexcept>",
            "#include <algorithm>",
            "#include <semaphore.h>",
            "#include <stdlib.h>",
            "#include <sys/wait.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include <limits>",
            "#include <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <stdio.h>\n#include <stdexcept>\n#include <algorithm>\n#include <semaphore.h>\n#include <stdlib.h>\n#include <sys/wait.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <limits>\n#include <unistd.h>\n\nstatic inline uint32_t fastRand(uint32_t range) {\n  return nextFastRand() % range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [
            "left"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getLeft",
          "args": [],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.setOp",
          "args": [
            "(Operation)(fastRand((int)Operation::MODULUS + 1))"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "fastRand((int)Operation::MODULUS + 1)"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capnproto-common.h\"\n#include \"eval.capnp.h\"\n\nint32_t makeExpression(Expression::Builder exp, uint depth) {\n  exp.setOp((Operation)(fastRand((int)Operation::MODULUS + 1)));\n\n  uint32_t left, right;\n\n  if (fastRand(8) < depth) {\n    left = fastRand(128) + 1;\n    exp.getLeft().setValue(left);\n  } else {\n    left = makeExpression(exp.getLeft().initExpression(), depth + 1);\n  }\n\n  if (fastRand(8) < depth) {\n    right = fastRand(128) + 1;\n    exp.getRight().setValue(right);\n  } else {\n    right = makeExpression(exp.getRight().initExpression(), depth + 1);\n  }\n\n  switch (exp.getOp()) {\n    case Operation::ADD:\n      return left + right;\n    case Operation::SUBTRACT:\n      return left - right;\n    case Operation::MULTIPLY:\n      return left * right;\n    case Operation::DIVIDE:\n      return div(left, right);\n    case Operation::MODULUS:\n      return mod(left, right);\n  }\n  throw std::logic_error(\"Can't get here.\");\n}"
  }
]