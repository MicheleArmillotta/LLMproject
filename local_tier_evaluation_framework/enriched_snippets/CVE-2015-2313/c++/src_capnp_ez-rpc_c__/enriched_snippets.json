[
  {
    "function_name": "EzRpcServer::getPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "342-344",
    "snippet": "kj::Promise<uint> EzRpcServer::getPort() {\n  return impl->portPromise.addBranch();\n}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl->portPromise.addBranch",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nkj::Promise<uint> EzRpcServer::getPort() {\n  return impl->portPromise.addBranch();\n}"
  },
  {
    "function_name": "EzRpcServer::exportCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "337-340",
    "snippet": "void EzRpcServer::exportCap(kj::StringPtr name, Capability::Client cap) {\n  Impl::ExportedCap entry(kj::heapString(name), cap);\n  impl->exportMap[entry.name] = kj::mv(entry);\n}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "entry"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nvoid EzRpcServer::exportCap(kj::StringPtr name, Capability::Client cap) {\n  Impl::ExportedCap entry(kj::heapString(name), cap);\n  impl->exportMap[entry.name] = kj::mv(entry);\n}"
  },
  {
    "function_name": "EzRpcServer::~EzRpcServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "335-335",
    "snippet": "EzRpcServer::~EzRpcServer() noexcept(false) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcServer::~EzRpcServer() noexcept(false) {}"
  },
  {
    "function_name": "EzRpcServer::EzRpcServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "332-333",
    "snippet": "EzRpcServer::EzRpcServer(int socketFd, uint port, ReaderOptions readerOpts)\n    : EzRpcServer(nullptr, socketFd, port, readerOpts) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcServer::EzRpcServer(int socketFd, uint port, ReaderOptions readerOpts)\n    : EzRpcServer(nullptr, socketFd, port, readerOpts) {}"
  },
  {
    "function_name": "EzRpcServer::EzRpcServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "328-330",
    "snippet": "EzRpcServer::EzRpcServer(struct sockaddr* bindAddress, uint addrSize,\n                         ReaderOptions readerOpts)\n    : EzRpcServer(nullptr, bindAddress, addrSize, readerOpts) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcServer::EzRpcServer(struct sockaddr* bindAddress, uint addrSize,\n                         ReaderOptions readerOpts)\n    : EzRpcServer(nullptr, bindAddress, addrSize, readerOpts) {}"
  },
  {
    "function_name": "EzRpcServer::EzRpcServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "324-326",
    "snippet": "EzRpcServer::EzRpcServer(kj::StringPtr bindAddress, uint defaultPort,\n                         ReaderOptions readerOpts)\n    : EzRpcServer(nullptr, bindAddress, defaultPort, readerOpts) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcServer::EzRpcServer(kj::StringPtr bindAddress, uint defaultPort,\n                         ReaderOptions readerOpts)\n    : EzRpcServer(nullptr, bindAddress, defaultPort, readerOpts) {}"
  },
  {
    "function_name": "EzRpcServer::EzRpcServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "320-322",
    "snippet": "EzRpcServer::EzRpcServer(Capability::Client mainInterface, int socketFd, uint port,\n                         ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(kj::mv(mainInterface), socketFd, port, readerOpts)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "kj::mv(mainInterface)",
            "socketFd",
            "port",
            "readerOpts"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainInterface"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcServer::EzRpcServer(Capability::Client mainInterface, int socketFd, uint port,\n                         ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(kj::mv(mainInterface), socketFd, port, readerOpts)) {}"
  },
  {
    "function_name": "EzRpcServer::EzRpcServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "316-318",
    "snippet": "EzRpcServer::EzRpcServer(Capability::Client mainInterface, struct sockaddr* bindAddress,\n                         uint addrSize, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(kj::mv(mainInterface), bindAddress, addrSize, readerOpts)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "kj::mv(mainInterface)",
            "bindAddress",
            "addrSize",
            "readerOpts"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainInterface"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcServer::EzRpcServer(Capability::Client mainInterface, struct sockaddr* bindAddress,\n                         uint addrSize, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(kj::mv(mainInterface), bindAddress, addrSize, readerOpts)) {}"
  },
  {
    "function_name": "EzRpcServer::EzRpcServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "312-314",
    "snippet": "EzRpcServer::EzRpcServer(Capability::Client mainInterface, kj::StringPtr bindAddress,\n                         uint defaultPort, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(kj::mv(mainInterface), bindAddress, defaultPort, readerOpts)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "kj::mv(mainInterface)",
            "bindAddress",
            "defaultPort",
            "readerOpts"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainInterface"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcServer::EzRpcServer(Capability::Client mainInterface, kj::StringPtr bindAddress,\n                         uint defaultPort, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(kj::mv(mainInterface), bindAddress, defaultPort, readerOpts)) {}"
  },
  {
    "function_name": "taskFailed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "307-309",
    "snippet": "void taskFailed(kj::Exception&& exception) override {\n    kj::throwFatalException(kj::mv(exception));\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::throwFatalException",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "throwFatalException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "348-351",
          "snippet": "void throwFatalException(kj::Exception&& exception) {\n  getExceptionCallback().onFatalException(kj::mv(exception));\n  abort();\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwFatalException(kj::Exception&& exception) {\n  getExceptionCallback().onFatalException(kj::mv(exception));\n  abort();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nvoid taskFailed(kj::Exception&& exception) override {\n    kj::throwFatalException(kj::mv(exception));\n  }"
  },
  {
    "function_name": "restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "292-305",
    "snippet": "Capability::Client restore(AnyPointer::Reader objectId) override {\n    if (objectId.isNull()) {\n      return mainInterface;\n    } else {\n      auto name = objectId.getAs<Text>();\n      auto iter = exportMap.find(name);\n      if (iter == exportMap.end()) {\n        KJ_FAIL_REQUIRE(\"Server exports no such capability.\", name) { break; }\n        return nullptr;\n      } else {\n        return iter->second.cap;\n      }\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Server exports no such capability.\"",
            "name"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportMap.end",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "exportMap.find",
          "args": [
            "name"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "objectId.getAs<Text>",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objectId.isNull",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nCapability::Client restore(AnyPointer::Reader objectId) override {\n    if (objectId.isNull()) {\n      return mainInterface;\n    } else {\n      auto name = objectId.getAs<Text>();\n      auto iter = exportMap.find(name);\n      if (iter == exportMap.end()) {\n        KJ_FAIL_REQUIRE(\"Server exports no such capability.\", name) { break; }\n        return nullptr;\n      } else {\n        return iter->second.cap;\n      }\n    }\n  }"
  },
  {
    "function_name": "acceptLoop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "277-290",
    "snippet": "void acceptLoop(kj::Own<kj::ConnectionReceiver>&& listener, ReaderOptions readerOpts) {\n    auto ptr = listener.get();\n    tasks.add(ptr->accept().then(kj::mvCapture(kj::mv(listener),\n        [this, readerOpts](kj::Own<kj::ConnectionReceiver>&& listener,\n                           kj::Own<kj::AsyncIoStream>&& connection) {\n      acceptLoop(kj::mv(listener), readerOpts);\n\n      auto server = kj::heap<ServerContext>(kj::mv(connection), *this, readerOpts);\n\n      // Arrange to destroy the server context when all references are gone, or when the\n      // EzRpcServer is destroyed (which will destroy the TaskSet).\n      tasks.add(server->network.onDisconnect().attach(kj::mv(server)));\n    })));\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "ptr->accept().then(kj::mvCapture(kj::mv(listener),\n        [this, readerOpts](kj::Own<kj::ConnectionReceiver>&& listener,\n                           kj::Own<kj::AsyncIoStream>&& connection) {\n      acceptLoop(kj::mv(listener), readerOpts);\n\n      auto server = kj::heap<ServerContext>(kj::mv(connection), *this, readerOpts);\n\n      // Arrange to destroy the server context when all references are gone, or when the\n      // EzRpcServer is destroyed (which will destroy the TaskSet).\n      tasks.add(server->network.onDisconnect().attach(kj::mv(server)));\n    }))"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr->accept",
          "args": [
            "kj::mvCapture(kj::mv(listener),\n        [this, readerOpts](kj::Own<kj::ConnectionReceiver>&& listener,\n                           kj::Own<kj::AsyncIoStream>&& connection) {\n      acceptLoop(kj::mv(listener), readerOpts);\n\n      auto server = kj::heap<ServerContext>(kj::mv(connection), *this, readerOpts);\n\n      // Arrange to destroy the server context when all references are gone, or when the\n      // EzRpcServer is destroyed (which will destroy the TaskSet).\n      tasks.add(server->network.onDisconnect().attach(kj::mv(server)));\n    })"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "kj::mv(listener)",
            "[this, readerOpts](kj::Own<kj::ConnectionReceiver>&& listener,\n                           kj::Own<kj::AsyncIoStream>&& connection) {\n      acceptLoop(kj::mv(listener), readerOpts);\n\n      auto server = kj::heap<ServerContext>(kj::mv(connection), *this, readerOpts);\n\n      // Arrange to destroy the server context when all references are gone, or when the\n      // EzRpcServer is destroyed (which will destroy the TaskSet).\n      tasks.add(server->network.onDisconnect().attach(kj::mv(server)));\n    }"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->network.onDisconnect",
          "args": [
            "kj::mv(server)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "server"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->network.onDisconnect",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "onDisconnect",
          "container": "TwoPartyVatNetwork",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.h",
          "lines": "58-58",
          "snippet": "kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }",
          "includes": [
            "#include <capnp/rpc-twoparty.capnp.h>",
            "#include <kj/async-io.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc-twoparty.capnp.h>\n#include <kj/async-io.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nTwoPartyVatNetwork {\n  kj::Promise<void> onDisconnect() { return disconnectPromise.addBranch(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<ServerContext>",
          "args": [
            "kj::mv(connection)",
            "*this",
            "readerOpts"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "connection"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acceptLoop",
          "args": [
            "kj::mv(listener)",
            "readerOpts"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "listener"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "listener"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr->accept",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "382-392",
          "snippet": "kj::Promise<kj::Own<Connection>> accept() override {\n    if (connectionQueue.empty()) {\n      auto paf = kj::newPromiseAndFulfiller<kj::Own<Connection>>();\n      fulfillerQueue.push(kj::mv(paf.fulfiller));\n      return kj::mv(paf.promise);\n    } else {\n      auto result = kj::mv(connectionQueue.front());\n      connectionQueue.pop();\n      return kj::mv(result);\n    }\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nkj::Promise<kj::Own<Connection>> accept() override {\n    if (connectionQueue.empty()) {\n      auto paf = kj::newPromiseAndFulfiller<kj::Own<Connection>>();\n      fulfillerQueue.push(kj::mv(paf.fulfiller));\n      return kj::mv(paf.promise);\n    } else {\n      auto result = kj::mv(connectionQueue.front());\n      connectionQueue.pop();\n      return kj::mv(result);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "listener.get",
          "args": [],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nvoid acceptLoop(kj::Own<kj::ConnectionReceiver>&& listener, ReaderOptions readerOpts) {\n    auto ptr = listener.get();\n    tasks.add(ptr->accept().then(kj::mvCapture(kj::mv(listener),\n        [this, readerOpts](kj::Own<kj::ConnectionReceiver>&& listener,\n                           kj::Own<kj::AsyncIoStream>&& connection) {\n      acceptLoop(kj::mv(listener), readerOpts);\n\n      auto server = kj::heap<ServerContext>(kj::mv(connection), *this, readerOpts);\n\n      // Arrange to destroy the server context when all references are gone, or when the\n      // EzRpcServer is destroyed (which will destroy the TaskSet).\n      tasks.add(server->network.onDisconnect().attach(kj::mv(server)));\n    })));\n  }"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "269-275",
    "snippet": "Impl(Capability::Client mainInterface, int socketFd, uint port, ReaderOptions readerOpts)\n      : mainInterface(kj::mv(mainInterface)),\n        context(EzRpcContext::getThreadLocal()),\n        portPromise(kj::Promise<uint>(port).fork()),\n        tasks(*this) {\n    acceptLoop(context->getLowLevelIoProvider().wrapListenSocketFd(socketFd), readerOpts);\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "acceptLoop",
          "args": [
            "context->getLowLevelIoProvider().wrapListenSocketFd(socketFd)",
            "readerOpts"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getLowLevelIoProvider",
          "args": [
            "socketFd"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getLowLevelIoProvider",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Promise<uint>",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Promise<uint>",
          "args": [
            "port"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "Promise",
          "container": "Promise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "138-138",
          "snippet": "inline Promise(decltype(nullptr)) {}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nPromise {\n  inline Promise(decltype(nullptr)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EzRpcContext::getThreadLocal",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "getThreadLocal",
          "container": "EzRpcContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "60-67",
          "snippet": "static kj::Own<EzRpcContext> getThreadLocal() {\n    EzRpcContext* existing = threadEzContext;\n    if (existing != nullptr) {\n      return kj::addRef(*existing);\n    } else {\n      return kj::refcounted<EzRpcContext>();\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcContext {\n  static kj::Own<EzRpcContext> getThreadLocal() {\n      EzRpcContext* existing = threadEzContext;\n      if (existing != nullptr) {\n        return kj::addRef(*existing);\n      } else {\n        return kj::refcounted<EzRpcContext>();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainInterface"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nImpl(Capability::Client mainInterface, int socketFd, uint port, ReaderOptions readerOpts)\n      : mainInterface(kj::mv(mainInterface)),\n        context(EzRpcContext::getThreadLocal()),\n        portPromise(kj::Promise<uint>(port).fork()),\n        tasks(*this) {\n    acceptLoop(context->getLowLevelIoProvider().wrapListenSocketFd(socketFd), readerOpts);\n  }"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "259-267",
    "snippet": "Impl(Capability::Client mainInterface, struct sockaddr* bindAddress, uint addrSize,\n       ReaderOptions readerOpts)\n      : mainInterface(kj::mv(mainInterface)),\n        context(EzRpcContext::getThreadLocal()), portPromise(nullptr), tasks(*this) {\n    auto listener = context->getIoProvider().getNetwork()\n        .getSockaddr(bindAddress, addrSize)->listen();\n    portPromise = kj::Promise<uint>(listener->getPort()).fork();\n    acceptLoop(kj::mv(listener), readerOpts);\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "acceptLoop",
          "args": [
            "kj::mv(listener)",
            "readerOpts"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "listener"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Promise<uint>",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Promise<uint>",
          "args": [
            "listener->getPort()"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "Promise",
          "container": "Promise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "138-138",
          "snippet": "inline Promise(decltype(nullptr)) {}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nPromise {\n  inline Promise(decltype(nullptr)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "listener->getPort",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "getPort",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "863-865",
          "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [
            "bindAddress",
            "addrSize"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EzRpcContext::getThreadLocal",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "getThreadLocal",
          "container": "EzRpcContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "60-67",
          "snippet": "static kj::Own<EzRpcContext> getThreadLocal() {\n    EzRpcContext* existing = threadEzContext;\n    if (existing != nullptr) {\n      return kj::addRef(*existing);\n    } else {\n      return kj::refcounted<EzRpcContext>();\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcContext {\n  static kj::Own<EzRpcContext> getThreadLocal() {\n      EzRpcContext* existing = threadEzContext;\n      if (existing != nullptr) {\n        return kj::addRef(*existing);\n      } else {\n        return kj::refcounted<EzRpcContext>();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainInterface"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nImpl(Capability::Client mainInterface, struct sockaddr* bindAddress, uint addrSize,\n       ReaderOptions readerOpts)\n      : mainInterface(kj::mv(mainInterface)),\n        context(EzRpcContext::getThreadLocal()), portPromise(nullptr), tasks(*this) {\n    auto listener = context->getIoProvider().getNetwork()\n        .getSockaddr(bindAddress, addrSize)->listen();\n    portPromise = kj::Promise<uint>(listener->getPort()).fork();\n    acceptLoop(kj::mv(listener), readerOpts);\n  }"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "242-257",
    "snippet": "Impl(Capability::Client mainInterface, kj::StringPtr bindAddress, uint defaultPort,\n       ReaderOptions readerOpts)\n      : mainInterface(kj::mv(mainInterface)),\n        context(EzRpcContext::getThreadLocal()), portPromise(nullptr), tasks(*this) {\n    auto paf = kj::newPromiseAndFulfiller<uint>();\n    portPromise = paf.promise.fork();\n\n    tasks.add(context->getIoProvider().getNetwork().parseAddress(bindAddress, defaultPort)\n        .then(kj::mvCapture(paf.fulfiller,\n          [this, readerOpts](kj::Own<kj::PromiseFulfiller<uint>>&& portFulfiller,\n                             kj::Own<kj::NetworkAddress>&& addr) {\n      auto listener = addr->listen();\n      portFulfiller->fulfill(listener->getPort());\n      acceptLoop(kj::mv(listener), readerOpts);\n    })));\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasks.add",
          "args": [
            "context->getIoProvider().getNetwork().parseAddress(bindAddress, defaultPort)\n        .then(kj::mvCapture(paf.fulfiller,\n          [this, readerOpts](kj::Own<kj::PromiseFulfiller<uint>>&& portFulfiller,\n                             kj::Own<kj::NetworkAddress>&& addr) {\n      auto listener = addr->listen();\n      portFulfiller->fulfill(listener->getPort());\n      acceptLoop(kj::mv(listener), readerOpts);\n    }))"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [
            "kj::mvCapture(paf.fulfiller,\n          [this, readerOpts](kj::Own<kj::PromiseFulfiller<uint>>&& portFulfiller,\n                             kj::Own<kj::NetworkAddress>&& addr) {\n      auto listener = addr->listen();\n      portFulfiller->fulfill(listener->getPort());\n      acceptLoop(kj::mv(listener), readerOpts);\n    })"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "paf.fulfiller",
            "[this, readerOpts](kj::Own<kj::PromiseFulfiller<uint>>&& portFulfiller,\n                             kj::Own<kj::NetworkAddress>&& addr) {\n      auto listener = addr->listen();\n      portFulfiller->fulfill(listener->getPort());\n      acceptLoop(kj::mv(listener), readerOpts);\n    }"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "acceptLoop",
          "args": [
            "kj::mv(listener)",
            "readerOpts"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "listener"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "portFulfiller->fulfill",
          "args": [
            "listener->getPort()"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1295-1297",
          "snippet": "void fulfill(kj::Promise<kj::Own<RpcResponse>>&& promise) {\n      fulfiller->fulfill(kj::mv(promise));\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  void fulfill(kj::Promise<kj::Own<RpcResponse>>&& promise) {\n        fulfiller->fulfill(kj::mv(promise));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "listener->getPort",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "getPort",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "863-865",
          "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr->listen",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "listen",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "959-983",
          "snippet": "Own<ConnectionReceiver> listen() override {\n    if (addrs.size() > 1) {\n      KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n          \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n          \"in the future.\", addrs[0].toString());\n    }\n\n    int fd = addrs[0].socket(SOCK_STREAM);\n\n    {\n      KJ_ON_SCOPE_FAILURE(close(fd));\n\n      // We always enable SO_REUSEADDR because having to take your server down for five minutes\n      // before it can restart really sucks.\n      int optval = 1;\n      KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n\n      addrs[0].bind(fd);\n\n      // TODO(someday):  Let queue size be specified explicitly in string addresses.\n      KJ_SYSCALL(::listen(fd, SOMAXCONN));\n    }\n\n    return lowLevel.wrapListenSocketFd(fd, NEW_FD_FLAGS);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Own<ConnectionReceiver> listen() override {\n      if (addrs.size() > 1) {\n        KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n            \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n            \"in the future.\", addrs[0].toString());\n      }\n  \n      int fd = addrs[0].socket(SOCK_STREAM);\n  \n      {\n        KJ_ON_SCOPE_FAILURE(close(fd));\n  \n        // We always enable SO_REUSEADDR because having to take your server down for five minutes\n        // before it can restart really sucks.\n        int optval = 1;\n        KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n  \n        addrs[0].bind(fd);\n  \n        // TODO(someday):  Let queue size be specified explicitly in string addresses.\n        KJ_SYSCALL(::listen(fd, SOMAXCONN));\n      }\n  \n      return lowLevel.wrapListenSocketFd(fd, NEW_FD_FLAGS);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [
            "bindAddress",
            "defaultPort"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paf.promise.fork",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<uint>",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "EzRpcContext::getThreadLocal",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "getThreadLocal",
          "container": "EzRpcContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "60-67",
          "snippet": "static kj::Own<EzRpcContext> getThreadLocal() {\n    EzRpcContext* existing = threadEzContext;\n    if (existing != nullptr) {\n      return kj::addRef(*existing);\n    } else {\n      return kj::refcounted<EzRpcContext>();\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcContext {\n  static kj::Own<EzRpcContext> getThreadLocal() {\n      EzRpcContext* existing = threadEzContext;\n      if (existing != nullptr) {\n        return kj::addRef(*existing);\n      } else {\n        return kj::refcounted<EzRpcContext>();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "mainInterface"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nImpl(Capability::Client mainInterface, kj::StringPtr bindAddress, uint defaultPort,\n       ReaderOptions readerOpts)\n      : mainInterface(kj::mv(mainInterface)),\n        context(EzRpcContext::getThreadLocal()), portPromise(nullptr), tasks(*this) {\n    auto paf = kj::newPromiseAndFulfiller<uint>();\n    portPromise = paf.promise.fork();\n\n    tasks.add(context->getIoProvider().getNetwork().parseAddress(bindAddress, defaultPort)\n        .then(kj::mvCapture(paf.fulfiller,\n          [this, readerOpts](kj::Own<kj::PromiseFulfiller<uint>>&& portFulfiller,\n                             kj::Own<kj::NetworkAddress>&& addr) {\n      auto listener = addr->listen();\n      portFulfiller->fulfill(listener->getPort());\n      acceptLoop(kj::mv(listener), readerOpts);\n    })));\n  }"
  },
  {
    "function_name": "ServerContext",
    "container": "ServerContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "234-238",
    "snippet": "ServerContext(kj::Own<kj::AsyncIoStream>&& stream, SturdyRefRestorer<AnyPointer>& restorer,\n                  ReaderOptions readerOpts)\n        : stream(kj::mv(stream)),\n          network(*this->stream, rpc::twoparty::Side::SERVER, readerOpts),\n          rpcSystem(makeRpcServer(network, restorer)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeRpcServer",
          "args": [
            "network",
            "restorer"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "391-395",
          "snippet": "RpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    SturdyRefRestorer<LocalSturdyRefObjectId>& restorer) {\n  return RpcSystem<VatId>(network, restorer);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcServer(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network,\n    SturdyRefRestorer<LocalSturdyRefObjectId>& restorer) {\n  return RpcSystem<VatId>(network, restorer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nServerContext {\n  ServerContext(kj::Own<kj::AsyncIoStream>&& stream, SturdyRefRestorer<AnyPointer>& restorer,\n                    ReaderOptions readerOpts)\n          : stream(kj::mv(stream)),\n            network(*this->stream, rpc::twoparty::Side::SERVER, readerOpts),\n            rpcSystem(makeRpcServer(network, restorer)) {}\n}"
  },
  {
    "function_name": "ExportedCap",
    "container": "ExportedCap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "210-211",
    "snippet": "ExportedCap(kj::StringPtr name, Capability::Client cap)\n        : name(kj::heapString(name)), cap(cap) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nExportedCap {\n  ExportedCap(kj::StringPtr name, Capability::Client cap)\n          : name(kj::heapString(name)), cap(cap) {}\n}"
  },
  {
    "function_name": "EzRpcClient::importCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "176-185",
    "snippet": "Capability::Client EzRpcClient::importCap(kj::StringPtr name) {\n  KJ_IF_MAYBE(client, impl->clientContext) {\n    return client->get()->restore(name);\n  } else {\n    return impl->setupPromise.addBranch().then(kj::mvCapture(kj::heapString(name),\n        [this](kj::String&& name) {\n      return KJ_ASSERT_NONNULL(impl->clientContext)->restore(name);\n    }));\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return impl->setupPromise.addBranch",
          "args": [
            "kj::mvCapture(kj::heapString(name),\n        [this](kj::String&& name) {\n      return KJ_ASSERT_NONNULL(impl->clientContext)->restore(name);\n    })"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "kj::heapString(name)",
            "[this](kj::String&& name) {\n      return KJ_ASSERT_NONNULL(impl->clientContext)->restore(name);\n    }"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "name"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "impl->clientContext"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "name"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "return impl->setupPromise.addBranch",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "client->get",
          "args": [
            "name"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "client->get",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "client",
            "impl->clientContext"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nCapability::Client EzRpcClient::importCap(kj::StringPtr name) {\n  KJ_IF_MAYBE(client, impl->clientContext) {\n    return client->get()->restore(name);\n  } else {\n    return impl->setupPromise.addBranch().then(kj::mvCapture(kj::heapString(name),\n        [this](kj::String&& name) {\n      return KJ_ASSERT_NONNULL(impl->clientContext)->restore(name);\n    }));\n  }\n}"
  },
  {
    "function_name": "EzRpcClient::getMain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "166-173",
    "snippet": "Capability::Client EzRpcClient::getMain() {\n  KJ_IF_MAYBE(client, impl->clientContext) {\n    return client->get()->getMain();\n  } else {\n    return impl->setupPromise.addBranch().then([this]() {\n      return KJ_ASSERT_NONNULL(impl->clientContext)->getMain();\n    });\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return impl->setupPromise.addBranch",
          "args": [
            "[this]() {\n      return KJ_ASSERT_NONNULL(impl->clientContext)->getMain();\n    }"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "impl->clientContext"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return impl->setupPromise.addBranch",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "client->get",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "client",
            "impl->clientContext"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2462-2464",
          "snippet": "KJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nKJ_IF_MAYBE(e, exception) {\n          fulfiller->get()->reject(kj::mv(*e));\n        }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nCapability::Client EzRpcClient::getMain() {\n  KJ_IF_MAYBE(client, impl->clientContext) {\n    return client->get()->getMain();\n  } else {\n    return impl->setupPromise.addBranch().then([this]() {\n      return KJ_ASSERT_NONNULL(impl->clientContext)->getMain();\n    });\n  }"
  },
  {
    "function_name": "EzRpcClient::~EzRpcClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "164-164",
    "snippet": "EzRpcClient::~EzRpcClient() noexcept(false) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcClient::~EzRpcClient() noexcept(false) {}"
  },
  {
    "function_name": "EzRpcClient::EzRpcClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "161-162",
    "snippet": "EzRpcClient::EzRpcClient(int socketFd, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(socketFd, readerOpts)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "socketFd",
            "readerOpts"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcClient::EzRpcClient(int socketFd, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(socketFd, readerOpts)) {}"
  },
  {
    "function_name": "EzRpcClient::EzRpcClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "158-159",
    "snippet": "EzRpcClient::EzRpcClient(const struct sockaddr* serverAddress, uint addrSize, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(serverAddress, addrSize, readerOpts)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "serverAddress",
            "addrSize",
            "readerOpts"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcClient::EzRpcClient(const struct sockaddr* serverAddress, uint addrSize, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(serverAddress, addrSize, readerOpts)) {}"
  },
  {
    "function_name": "EzRpcClient::EzRpcClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "155-156",
    "snippet": "EzRpcClient::EzRpcClient(kj::StringPtr serverAddress, uint defaultPort, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(serverAddress, defaultPort, readerOpts)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "serverAddress",
            "defaultPort",
            "readerOpts"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcClient::EzRpcClient(kj::StringPtr serverAddress, uint defaultPort, ReaderOptions readerOpts)\n    : impl(kj::heap<Impl>(serverAddress, defaultPort, readerOpts)) {}"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "147-152",
    "snippet": "Impl(int socketFd, ReaderOptions readerOpts)\n      : context(EzRpcContext::getThreadLocal()),\n        setupPromise(kj::Promise<void>(kj::READY_NOW).fork()),\n        clientContext(kj::heap<ClientContext>(\n            context->getLowLevelIoProvider().wrapSocketFd(socketFd),\n            readerOpts)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<ClientContext>",
          "args": [
            "context->getLowLevelIoProvider().wrapSocketFd(socketFd)",
            "readerOpts"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getLowLevelIoProvider",
          "args": [
            "socketFd"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getLowLevelIoProvider",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Promise<void>",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::Promise<void>",
          "args": [
            "kj::READY_NOW"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "Promise",
          "container": "Promise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "138-138",
          "snippet": "inline Promise(decltype(nullptr)) {}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\nPromise {\n  inline Promise(decltype(nullptr)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EzRpcContext::getThreadLocal",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "getThreadLocal",
          "container": "EzRpcContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "60-67",
          "snippet": "static kj::Own<EzRpcContext> getThreadLocal() {\n    EzRpcContext* existing = threadEzContext;\n    if (existing != nullptr) {\n      return kj::addRef(*existing);\n    } else {\n      return kj::refcounted<EzRpcContext>();\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcContext {\n  static kj::Own<EzRpcContext> getThreadLocal() {\n      EzRpcContext* existing = threadEzContext;\n      if (existing != nullptr) {\n        return kj::addRef(*existing);\n      } else {\n        return kj::refcounted<EzRpcContext>();\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nImpl(int socketFd, ReaderOptions readerOpts)\n      : context(EzRpcContext::getThreadLocal()),\n        setupPromise(kj::Promise<void>(kj::READY_NOW).fork()),\n        clientContext(kj::heap<ClientContext>(\n            context->getLowLevelIoProvider().wrapSocketFd(socketFd),\n            readerOpts)) {}"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "136-145",
    "snippet": "Impl(const struct sockaddr* serverAddress, uint addrSize,\n       ReaderOptions readerOpts)\n      : context(EzRpcContext::getThreadLocal()),\n        setupPromise(\n            connectAttach(context->getIoProvider().getNetwork()\n                .getSockaddr(serverAddress, addrSize))\n            .then([this, readerOpts](kj::Own<kj::AsyncIoStream>&& stream) {\n              clientContext = kj::heap<ClientContext>(kj::mv(stream),\n                                                      readerOpts);\n            }).fork()) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connectAttach",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectAttach",
          "args": [
            "[this, readerOpts](kj::Own<kj::AsyncIoStream>&& stream) {\n              clientContext = kj::heap<ClientContext>(kj::mv(stream),\n                                                      readerOpts);\n            }"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "connectAttach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "75-77",
          "snippet": "kj::Promise<kj::Own<kj::AsyncIoStream>> connectAttach(kj::Own<kj::NetworkAddress>&& addr) {\n  return addr->connect().attach(kj::mv(addr));\n}",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nkj::Promise<kj::Own<kj::AsyncIoStream>> connectAttach(kj::Own<kj::NetworkAddress>&& addr) {\n  return addr->connect().attach(kj::mv(addr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<ClientContext>",
          "args": [
            "kj::mv(stream)",
            "readerOpts"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [
            "serverAddress",
            "addrSize"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EzRpcContext::getThreadLocal",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "getThreadLocal",
          "container": "EzRpcContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "60-67",
          "snippet": "static kj::Own<EzRpcContext> getThreadLocal() {\n    EzRpcContext* existing = threadEzContext;\n    if (existing != nullptr) {\n      return kj::addRef(*existing);\n    } else {\n      return kj::refcounted<EzRpcContext>();\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcContext {\n  static kj::Own<EzRpcContext> getThreadLocal() {\n      EzRpcContext* existing = threadEzContext;\n      if (existing != nullptr) {\n        return kj::addRef(*existing);\n      } else {\n        return kj::refcounted<EzRpcContext>();\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nImpl(const struct sockaddr* serverAddress, uint addrSize,\n       ReaderOptions readerOpts)\n      : context(EzRpcContext::getThreadLocal()),\n        setupPromise(\n            connectAttach(context->getIoProvider().getNetwork()\n                .getSockaddr(serverAddress, addrSize))\n            .then([this, readerOpts](kj::Own<kj::AsyncIoStream>&& stream) {\n              clientContext = kj::heap<ClientContext>(kj::mv(stream),\n                                                      readerOpts);\n            }).fork()) {}"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "124-134",
    "snippet": "Impl(kj::StringPtr serverAddress, uint defaultPort,\n       ReaderOptions readerOpts)\n      : context(EzRpcContext::getThreadLocal()),\n        setupPromise(context->getIoProvider().getNetwork()\n            .parseAddress(serverAddress, defaultPort)\n            .then([readerOpts](kj::Own<kj::NetworkAddress>&& addr) {\n              return connectAttach(kj::mv(addr));\n            }).then([this, readerOpts](kj::Own<kj::AsyncIoStream>&& stream) {\n              clientContext = kj::heap<ClientContext>(kj::mv(stream),\n                                                      readerOpts);\n            }).fork()) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [
            "[this, readerOpts](kj::Own<kj::AsyncIoStream>&& stream) {\n              clientContext = kj::heap<ClientContext>(kj::mv(stream),\n                                                      readerOpts);\n            }"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<ClientContext>",
          "args": [
            "kj::mv(stream)",
            "readerOpts"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [
            "[readerOpts](kj::Own<kj::NetworkAddress>&& addr) {\n              return connectAttach(kj::mv(addr));\n            }"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectAttach",
          "args": [
            "kj::mv(addr)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "connectAttach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "75-77",
          "snippet": "kj::Promise<kj::Own<kj::AsyncIoStream>> connectAttach(kj::Own<kj::NetworkAddress>&& addr) {\n  return addr->connect().attach(kj::mv(addr));\n}",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nkj::Promise<kj::Own<kj::AsyncIoStream>> connectAttach(kj::Own<kj::NetworkAddress>&& addr) {\n  return addr->connect().attach(kj::mv(addr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "addr"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [
            "serverAddress",
            "defaultPort"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getIoProvider",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EzRpcContext::getThreadLocal",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "getThreadLocal",
          "container": "EzRpcContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
          "lines": "60-67",
          "snippet": "static kj::Own<EzRpcContext> getThreadLocal() {\n    EzRpcContext* existing = threadEzContext;\n    if (existing != nullptr) {\n      return kj::addRef(*existing);\n    } else {\n      return kj::refcounted<EzRpcContext>();\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <kj/threadlocal.h>",
            "#include <kj/debug.h>",
            "#include <kj/async-io.h>",
            "#include <capnp/rpc.capnp.h>",
            "#include \"rpc-twoparty.h\"",
            "#include \"ez-rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcContext {\n  static kj::Own<EzRpcContext> getThreadLocal() {\n      EzRpcContext* existing = threadEzContext;\n      if (existing != nullptr) {\n        return kj::addRef(*existing);\n      } else {\n        return kj::refcounted<EzRpcContext>();\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nImpl(kj::StringPtr serverAddress, uint defaultPort,\n       ReaderOptions readerOpts)\n      : context(EzRpcContext::getThreadLocal()),\n        setupPromise(context->getIoProvider().getNetwork()\n            .parseAddress(serverAddress, defaultPort)\n            .then([readerOpts](kj::Own<kj::NetworkAddress>&& addr) {\n              return connectAttach(kj::mv(addr));\n            }).then([this, readerOpts](kj::Own<kj::AsyncIoStream>&& stream) {\n              clientContext = kj::heap<ClientContext>(kj::mv(stream),\n                                                      readerOpts);\n            }).fork()) {}"
  },
  {
    "function_name": "restore",
    "container": "ClientContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "101-116",
    "snippet": "Capability::Client restore(kj::StringPtr name) {\n      word scratch[64];\n      memset(scratch, 0, sizeof(scratch));\n      MallocMessageBuilder message(scratch);\n\n      auto hostIdOrphan = message.getOrphanage().newOrphan<rpc::twoparty::VatId>();\n      auto hostId = hostIdOrphan.get();\n      hostId.setSide(rpc::twoparty::Side::SERVER);\n\n      auto objectId = message.getRoot<AnyPointer>();\n      objectId.setAs<Text>(name);\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n      return rpcSystem.restore(hostId, objectId);\n#pragma GCC diagnostic pop\n    }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "objectId.setAs<Text>",
          "args": [
            "name"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<AnyPointer>",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostId.setSide",
          "args": [
            "rpc::twoparty::Side::SERVER"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hostIdOrphan.get",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message.getOrphanage",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getOrphanage",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "scratch",
            "0",
            "sizeof(scratch)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nClientContext {\n  Capability::Client restore(kj::StringPtr name) {\n        word scratch[64];\n        memset(scratch, 0, sizeof(scratch));\n        MallocMessageBuilder message(scratch);\n  \n        auto hostIdOrphan = message.getOrphanage().newOrphan<rpc::twoparty::VatId>();\n        auto hostId = hostIdOrphan.get();\n        hostId.setSide(rpc::twoparty::Side::SERVER);\n  \n        auto objectId = message.getRoot<AnyPointer>();\n        objectId.setAs<Text>(name);\n  #pragma GCC diagnostic push\n  #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n        return rpcSystem.restore(hostId, objectId);\n  #pragma GCC diagnostic pop\n      }\n}"
  },
  {
    "function_name": "getMain",
    "container": "ClientContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "92-99",
    "snippet": "Capability::Client getMain() {\n      word scratch[4];\n      memset(scratch, 0, sizeof(scratch));\n      MallocMessageBuilder message(scratch);\n      auto hostId = message.getRoot<rpc::twoparty::VatId>();\n      hostId.setSide(rpc::twoparty::Side::SERVER);\n      return rpcSystem.bootstrap(hostId);\n    }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpcSystem.bootstrap",
          "args": [
            "hostId"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "bootstrap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "2620-2624",
          "snippet": "Capability::Client bootstrap(_::StructReader vatId) {\n    // For now we delegate to restore() since it's equivalent, but eventually we'll remove restore()\n    // and implement bootstrap() directly.\n    return restore(vatId, AnyPointer::Reader());\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nCapability::Client bootstrap(_::StructReader vatId) {\n    // For now we delegate to restore() since it's equivalent, but eventually we'll remove restore()\n    // and implement bootstrap() directly.\n    return restore(vatId, AnyPointer::Reader());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "hostId.setSide",
          "args": [
            "rpc::twoparty::Side::SERVER"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<rpc::twoparty::VatId>",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "scratch",
            "0",
            "sizeof(scratch)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nClientContext {\n  Capability::Client getMain() {\n        word scratch[4];\n        memset(scratch, 0, sizeof(scratch));\n        MallocMessageBuilder message(scratch);\n        auto hostId = message.getRoot<rpc::twoparty::VatId>();\n        hostId.setSide(rpc::twoparty::Side::SERVER);\n        return rpcSystem.bootstrap(hostId);\n      }\n}"
  },
  {
    "function_name": "ClientContext",
    "container": "ClientContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "87-90",
    "snippet": "ClientContext(kj::Own<kj::AsyncIoStream>&& stream, ReaderOptions readerOpts)\n        : stream(kj::mv(stream)),\n          network(*this->stream, rpc::twoparty::Side::CLIENT, readerOpts),\n          rpcSystem(makeRpcClient(network)) {}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "makeRpcClient",
          "args": [
            "network"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "makeRpcClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.h",
          "lines": "399-402",
          "snippet": "RpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}",
          "includes": [
            "#include \"rpc-prelude.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc-prelude.h\"\n#include \"capability.h\"\n\nRpcSystem<VatId> makeRpcClient(\n    VatNetwork<VatId, ProvisionId, RecipientId, ThirdPartyCapId, JoinResult>& network) {\n  return RpcSystem<VatId>(network, nullptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nClientContext {\n  ClientContext(kj::Own<kj::AsyncIoStream>&& stream, ReaderOptions readerOpts)\n          : stream(kj::mv(stream)),\n            network(*this->stream, rpc::twoparty::Side::CLIENT, readerOpts),\n            rpcSystem(makeRpcClient(network)) {}\n}"
  },
  {
    "function_name": "connectAttach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "75-77",
    "snippet": "kj::Promise<kj::Own<kj::AsyncIoStream>> connectAttach(kj::Own<kj::NetworkAddress>&& addr) {\n  return addr->connect().attach(kj::mv(addr));\n}",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr->connect",
          "args": [
            "kj::mv(addr)"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "TestContext",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "468-476",
          "snippet": "Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n    MallocMessageBuilder refMessage(128);\n    auto ref = refMessage.initRoot<test::TestSturdyRef>();\n    auto hostId = ref.initHostId();\n    hostId.setHost(\"server\");\n    ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n\n    return rpcClient.restore(hostId, ref.getObjectId());\n  }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestContext {\n  Capability::Client connect(test::TestSturdyRefObjectId::Tag tag) {\n      MallocMessageBuilder refMessage(128);\n      auto ref = refMessage.initRoot<test::TestSturdyRef>();\n      auto hostId = ref.initHostId();\n      hostId.setHost(\"server\");\n      ref.getObjectId().initAs<test::TestSturdyRefObjectId>().setTag(tag);\n  \n      return rpcClient.restore(hostId, ref.getObjectId());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "addr"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr->connect",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "955-957",
          "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nkj::Promise<kj::Own<kj::AsyncIoStream>> connectAttach(kj::Own<kj::NetworkAddress>&& addr) {\n  return addr->connect().attach(kj::mv(addr));\n}"
  },
  {
    "function_name": "getThreadLocal",
    "container": "EzRpcContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "60-67",
    "snippet": "static kj::Own<EzRpcContext> getThreadLocal() {\n    EzRpcContext* existing = threadEzContext;\n    if (existing != nullptr) {\n      return kj::addRef(*existing);\n    } else {\n      return kj::refcounted<EzRpcContext>();\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<EzRpcContext>",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "77-82",
          "snippet": "inline Own<T> refcounted(Params&&... params) {\n  // Allocate a new refcounted instance of T, passing `params` to its constructor.  Returns an\n  // initial reference to the object.  More references can be created with `kj::addRef()`.\n\n  return Refcounted::addRefInternal(new T(kj::fwd<Params>(params)...));\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\ninline Own<T> refcounted(Params&&... params) {\n  // Allocate a new refcounted instance of T, passing `params` to its constructor.  Returns an\n  // initial reference to the object.  More references can be created with `kj::addRef()`.\n\n  return Refcounted::addRefInternal(new T(kj::fwd<Params>(params)...));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*existing"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcContext {\n  static kj::Own<EzRpcContext> getThreadLocal() {\n      EzRpcContext* existing = threadEzContext;\n      if (existing != nullptr) {\n        return kj::addRef(*existing);\n      } else {\n        return kj::refcounted<EzRpcContext>();\n      }\n    }\n}"
  },
  {
    "function_name": "EzRpcContext",
    "container": "EzRpcContext",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc.c++",
    "lines": "36-38",
    "snippet": "EzRpcContext(): ioContext(kj::setupAsyncIo()) {\n    threadEzContext = this;\n  }",
    "includes": [
      "#include <map>",
      "#include <kj/threadlocal.h>",
      "#include <kj/debug.h>",
      "#include <kj/async-io.h>",
      "#include <capnp/rpc.capnp.h>",
      "#include \"rpc-twoparty.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::setupAsyncIo",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "setupAsyncIo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1379-1385",
          "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <kj/threadlocal.h>\n#include <kj/debug.h>\n#include <kj/async-io.h>\n#include <capnp/rpc.capnp.h>\n#include \"rpc-twoparty.h\"\n#include \"ez-rpc.h\"\n\nEzRpcContext {\n  EzRpcContext(): ioContext(kj::setupAsyncIo()) {\n      threadEzContext = this;\n    }\n}"
  }
]