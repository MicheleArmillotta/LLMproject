[
  {
    "function_name": "NodeTranslator::compileAnnotationApplications",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2974-3040",
    "snippet": "Orphan<List<schema::Annotation>> NodeTranslator::compileAnnotationApplications(\n    List<Declaration::AnnotationApplication>::Reader annotations,\n    kj::StringPtr targetsFlagName) {\n  if (annotations.size() == 0 || !compileAnnotations) {\n    // Return null.\n    return Orphan<List<schema::Annotation>>();\n  }\n\n  auto result = orphanage.newOrphan<List<schema::Annotation>>(annotations.size());\n  auto builder = result.get();\n\n  for (uint i = 0; i < annotations.size(); i++) {\n    Declaration::AnnotationApplication::Reader annotation = annotations[i];\n    schema::Annotation::Builder annotationBuilder = builder[i];\n\n    // Set the annotation's value to void in case we fail to produce something better below.\n    annotationBuilder.initValue().setVoid();\n\n    auto name = annotation.getName();\n    KJ_IF_MAYBE(decl, compileDeclExpression(name, noImplicitParams())) {\n      KJ_IF_MAYBE(kind, decl->getKind()) {\n        if (*kind != Declaration::ANNOTATION) {\n          errorReporter.addErrorOn(name, kj::str(\n              \"'\", expressionString(name), \"' is not an annotation.\"));\n        } else {\n          annotationBuilder.setId(decl->getIdAndFillBrand(\n              [&]() { return annotationBuilder.initBrand(); }));\n          KJ_IF_MAYBE(annotationSchema,\n                      resolver.resolveBootstrapSchema(annotationBuilder.getId(),\n                                                      annotationBuilder.getBrand())) {\n            auto node = annotationSchema->getProto().getAnnotation();\n            if (!toDynamic(node).get(targetsFlagName).as<bool>()) {\n              errorReporter.addErrorOn(name, kj::str(\n                  \"'\", expressionString(name), \"' cannot be applied to this kind of declaration.\"));\n            }\n\n            // Interpret the value.\n            auto value = annotation.getValue();\n            switch (value.which()) {\n              case Declaration::AnnotationApplication::Value::NONE:\n                // No value, i.e. void.\n                if (node.getType().isVoid()) {\n                  annotationBuilder.getValue().setVoid();\n                } else {\n                  errorReporter.addErrorOn(name, kj::str(\n                      \"'\", expressionString(name), \"' requires a value.\"));\n                  compileDefaultDefaultValue(node.getType(), annotationBuilder.getValue());\n                }\n                break;\n\n              case Declaration::AnnotationApplication::Value::EXPRESSION:\n                compileBootstrapValue(value.getExpression(), node.getType(),\n                                      annotationBuilder.getValue(),\n                                      *annotationSchema);\n                break;\n            }\n          }\n        }\n      } else if (*kind != Declaration::ANNOTATION) {\n        errorReporter.addErrorOn(name, kj::str(\n            \"'\", expressionString(name), \"' is not an annotation.\"));\n      }\n    }\n  }\n\n  return result;\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);",
      "uint i = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "name",
            "kj::str(\n            \"'\", expressionString(name), \"' is not an annotation.\")"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "expressionString(name)",
            "\"' is not an annotation.\""
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expressionString",
          "args": [
            "name"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "expressionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2444-2446",
          "snippet": "static kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kj::String expressionString(Expression::Reader name);",
            "static kj::String expressionString(Expression::Reader name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\n\nstatic kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}"
        }
      },
      {
        "call_info": {
          "callee": "compileBootstrapValue",
          "args": [
            "value.getExpression()",
            "node.getType()",
            "annotationBuilder.getValue()",
            "*annotationSchema"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::compileBootstrapValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2506-2526",
          "snippet": "void NodeTranslator::compileBootstrapValue(\n    Expression::Reader source, schema::Type::Reader type, schema::Value::Builder target,\n    Schema typeScope) {\n  // Start by filling in a default default value so that if for whatever reason we don't end up\n  // initializing the value, this won't cause schema validation to fail.\n  compileDefaultDefaultValue(type, target);\n\n  switch (type.which()) {\n    case schema::Type::LIST:\n    case schema::Type::STRUCT:\n    case schema::Type::INTERFACE:\n    case schema::Type::ANY_POINTER:\n      unfinishedValues.add(UnfinishedValue { source, type, typeScope, target });\n      break;\n\n    default:\n      // Primitive value.\n      compileValue(source, type, typeScope, target, true);\n      break;\n  }\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
            "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nvoid NodeTranslator::compileBootstrapValue(\n    Expression::Reader source, schema::Type::Reader type, schema::Value::Builder target,\n    Schema typeScope) {\n  // Start by filling in a default default value so that if for whatever reason we don't end up\n  // initializing the value, this won't cause schema validation to fail.\n  compileDefaultDefaultValue(type, target);\n\n  switch (type.which()) {\n    case schema::Type::LIST:\n    case schema::Type::STRUCT:\n    case schema::Type::INTERFACE:\n    case schema::Type::ANY_POINTER:\n      unfinishedValues.add(UnfinishedValue { source, type, typeScope, target });\n      break;\n\n    default:\n      // Primitive value.\n      compileValue(source, type, typeScope, target, true);\n      break;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "annotationBuilder.getValue",
          "args": [],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getType",
          "args": [],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "value.getExpression",
          "args": [],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileDefaultDefaultValue",
          "args": [
            "node.getType()",
            "annotationBuilder.getValue()"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::compileDefaultDefaultValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2478-2504",
          "snippet": "void NodeTranslator::compileDefaultDefaultValue(\n    schema::Type::Reader type, schema::Value::Builder target) {\n  switch (type.which()) {\n    case schema::Type::VOID: target.setVoid(); break;\n    case schema::Type::BOOL: target.setBool(false); break;\n    case schema::Type::INT8: target.setInt8(0); break;\n    case schema::Type::INT16: target.setInt16(0); break;\n    case schema::Type::INT32: target.setInt32(0); break;\n    case schema::Type::INT64: target.setInt64(0); break;\n    case schema::Type::UINT8: target.setUint8(0); break;\n    case schema::Type::UINT16: target.setUint16(0); break;\n    case schema::Type::UINT32: target.setUint32(0); break;\n    case schema::Type::UINT64: target.setUint64(0); break;\n    case schema::Type::FLOAT32: target.setFloat32(0); break;\n    case schema::Type::FLOAT64: target.setFloat64(0); break;\n    case schema::Type::ENUM: target.setEnum(0); break;\n    case schema::Type::INTERFACE: target.setInterface(); break;\n\n    // Bit of a hack:  For Text/Data, we adopt a null orphan, which sets the field to null.\n    // TODO(cleanup):  Create a cleaner way to do this.\n    case schema::Type::TEXT: target.adoptText(Orphan<Text>()); break;\n    case schema::Type::DATA: target.adoptData(Orphan<Data>()); break;\n    case schema::Type::STRUCT: target.initStruct(); break;\n    case schema::Type::LIST: target.initList(); break;\n    case schema::Type::ANY_POINTER: target.initAnyPointer(); break;\n  }\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nvoid NodeTranslator::compileDefaultDefaultValue(\n    schema::Type::Reader type, schema::Value::Builder target) {\n  switch (type.which()) {\n    case schema::Type::VOID: target.setVoid(); break;\n    case schema::Type::BOOL: target.setBool(false); break;\n    case schema::Type::INT8: target.setInt8(0); break;\n    case schema::Type::INT16: target.setInt16(0); break;\n    case schema::Type::INT32: target.setInt32(0); break;\n    case schema::Type::INT64: target.setInt64(0); break;\n    case schema::Type::UINT8: target.setUint8(0); break;\n    case schema::Type::UINT16: target.setUint16(0); break;\n    case schema::Type::UINT32: target.setUint32(0); break;\n    case schema::Type::UINT64: target.setUint64(0); break;\n    case schema::Type::FLOAT32: target.setFloat32(0); break;\n    case schema::Type::FLOAT64: target.setFloat64(0); break;\n    case schema::Type::ENUM: target.setEnum(0); break;\n    case schema::Type::INTERFACE: target.setInterface(); break;\n\n    // Bit of a hack:  For Text/Data, we adopt a null orphan, which sets the field to null.\n    // TODO(cleanup):  Create a cleaner way to do this.\n    case schema::Type::TEXT: target.adoptText(Orphan<Text>()); break;\n    case schema::Type::DATA: target.adoptData(Orphan<Data>()); break;\n    case schema::Type::STRUCT: target.initStruct(); break;\n    case schema::Type::LIST: target.initList(); break;\n    case schema::Type::ANY_POINTER: target.initAnyPointer(); break;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "annotationBuilder.getValue",
          "args": [],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "expressionString(name)",
            "\"' requires a value.\""
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotationBuilder.getValue",
          "args": [],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotationBuilder.getValue",
          "args": [],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.which",
          "args": [],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getValue",
          "args": [],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "expressionString(name)",
            "\"' cannot be applied to this kind of declaration.\""
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toDynamic",
          "args": [],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toDynamic",
          "args": [
            "targetsFlagName"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "toDynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "1246-1248",
          "snippet": "typename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ntypename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "annotationSchema->getProto",
          "args": [],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "annotationSchema",
            "resolver.resolveBootstrapSchema(annotationBuilder.getId(),\n                                                      annotationBuilder.getBrand())"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "resolver.resolveBootstrapSchema",
          "args": [
            "annotationBuilder.getId()",
            "annotationBuilder.getBrand()"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotationBuilder.getBrand",
          "args": [],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotationBuilder.getId",
          "args": [],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "annotationBuilder.setId",
          "args": [
            "decl->getIdAndFillBrand(\n              [&]() { return annotationBuilder.initBrand(); })"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->getIdAndFillBrand",
          "args": [
            "[&]() { return annotationBuilder.initBrand(); }"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotationBuilder.initBrand",
          "args": [],
          "line": 3000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "expressionString(name)",
            "\"' is not an annotation.\""
          ],
          "line": 2996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->getKind",
          "args": [],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "getKind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "77-77",
          "snippet": "Declaration::Which getKind() { return kind; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nDeclaration::Which getKind() { return kind; }"
        }
      },
      {
        "call_info": {
          "callee": "annotation.getName",
          "args": [],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotationBuilder.initValue",
          "args": [],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotationBuilder.initValue",
          "args": [],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotations.size",
          "args": [],
          "line": 2985
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<List<schema::Annotation>>",
          "args": [
            "annotations.size()"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Orphan<List<schema::Annotation>>",
          "args": [],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nOrphan<List<schema::Annotation>> NodeTranslator::compileAnnotationApplications(\n    List<Declaration::AnnotationApplication>::Reader annotations,\n    kj::StringPtr targetsFlagName) {\n  if (annotations.size() == 0 || !compileAnnotations) {\n    // Return null.\n    return Orphan<List<schema::Annotation>>();\n  }\n\n  auto result = orphanage.newOrphan<List<schema::Annotation>>(annotations.size());\n  auto builder = result.get();\n\n  for (uint i = 0; i < annotations.size(); i++) {\n    Declaration::AnnotationApplication::Reader annotation = annotations[i];\n    schema::Annotation::Builder annotationBuilder = builder[i];\n\n    // Set the annotation's value to void in case we fail to produce something better below.\n    annotationBuilder.initValue().setVoid();\n\n    auto name = annotation.getName();\n    KJ_IF_MAYBE(decl, compileDeclExpression(name, noImplicitParams())) {\n      KJ_IF_MAYBE(kind, decl->getKind()) {\n        if (*kind != Declaration::ANNOTATION) {\n          errorReporter.addErrorOn(name, kj::str(\n              \"'\", expressionString(name), \"' is not an annotation.\"));\n        } else {\n          annotationBuilder.setId(decl->getIdAndFillBrand(\n              [&]() { return annotationBuilder.initBrand(); }));\n          KJ_IF_MAYBE(annotationSchema,\n                      resolver.resolveBootstrapSchema(annotationBuilder.getId(),\n                                                      annotationBuilder.getBrand())) {\n            auto node = annotationSchema->getProto().getAnnotation();\n            if (!toDynamic(node).get(targetsFlagName).as<bool>()) {\n              errorReporter.addErrorOn(name, kj::str(\n                  \"'\", expressionString(name), \"' cannot be applied to this kind of declaration.\"));\n            }\n\n            // Interpret the value.\n            auto value = annotation.getValue();\n            switch (value.which()) {\n              case Declaration::AnnotationApplication::Value::NONE:\n                // No value, i.e. void.\n                if (node.getType().isVoid()) {\n                  annotationBuilder.getValue().setVoid();\n                } else {\n                  errorReporter.addErrorOn(name, kj::str(\n                      \"'\", expressionString(name), \"' requires a value.\"));\n                  compileDefaultDefaultValue(node.getType(), annotationBuilder.getValue());\n                }\n                break;\n\n              case Declaration::AnnotationApplication::Value::EXPRESSION:\n                compileBootstrapValue(value.getExpression(), node.getType(),\n                                      annotationBuilder.getValue(),\n                                      *annotationSchema);\n                break;\n            }\n          }\n        }\n      } else if (*kind != Declaration::ANNOTATION) {\n        errorReporter.addErrorOn(name, kj::str(\n            \"'\", expressionString(name), \"' is not an annotation.\"));\n      }\n    }\n  }\n\n  return result;\n}"
  },
  {
    "function_name": "NodeTranslator::readConstant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2878-2972",
    "snippet": "kj::Maybe<DynamicValue::Reader> NodeTranslator::readConstant(\n    Expression::Reader source, bool isBootstrap) {\n  // Look up the constant decl.\n  NodeTranslator::BrandedDecl constDecl = nullptr;\n  KJ_IF_MAYBE(decl, compileDeclExpression(source, noImplicitParams())) {\n    constDecl = *decl;\n  } else {\n    // Lookup will have reported an error.\n    return nullptr;\n  }\n\n  // Is it a constant?\n  if(constDecl.getKind().orDefault(Declaration::FILE) != Declaration::CONST) {\n    errorReporter.addErrorOn(source,\n        kj::str(\"'\", expressionString(source), \"' does not refer to a constant.\"));\n    return nullptr;\n  }\n\n  // Extract the ID and brand.\n  MallocMessageBuilder builder(256);\n  auto constBrand = builder.getRoot<schema::Brand>();\n  uint64_t id = constDecl.getIdAndFillBrand([&]() { return constBrand; });\n\n  // Look up the schema -- we'll need this to compile the constant's type.\n  Schema constSchema;\n  KJ_IF_MAYBE(s, resolver.resolveBootstrapSchema(id, constBrand)) {\n    constSchema = *s;\n  } else {\n    // The constant's schema is broken for reasons already reported.\n    return nullptr;\n  }\n\n  // If we're bootstrapping, then we know we're expecting a primitive value, so if the\n  // constant turns out to be non-primitive, we'll error out anyway.  If we're not\n  // bootstrapping, we may be compiling a non-primitive value and so we need the final\n  // version of the constant to make sure its value is filled in.\n  schema::Node::Reader proto = constSchema.getProto();\n  if (!isBootstrap) {\n    KJ_IF_MAYBE(finalProto, resolver.resolveFinalSchema(id)) {\n      proto = *finalProto;\n    } else {\n      // The constant's final schema is broken for reasons already reported.\n      return nullptr;\n    }\n  }\n\n  auto constReader = proto.getConst();\n  auto dynamicConst = toDynamic(constReader.getValue());\n  auto constValue = dynamicConst.get(KJ_ASSERT_NONNULL(dynamicConst.which()));\n\n  if (constValue.getType() == DynamicValue::ANY_POINTER) {\n    // We need to assign an appropriate schema to this pointer.\n    AnyPointer::Reader objValue = constValue.as<AnyPointer>();\n\n    auto constType = constSchema.asConst().getType();\n    switch (constType.which()) {\n      case schema::Type::STRUCT:\n        constValue = objValue.getAs<DynamicStruct>(constType.asStruct());\n        break;\n      case schema::Type::LIST:\n        constValue = objValue.getAs<DynamicList>(constType.asList());\n        break;\n      case schema::Type::ANY_POINTER:\n        // Fine as-is.\n        break;\n      default:\n        KJ_FAIL_ASSERT(\"Unrecognized AnyPointer-typed member of schema::Value.\");\n        break;\n    }\n  }\n\n  if (source.isRelativeName()) {\n    // A fully unqualified identifier looks like it might refer to a constant visible in the\n    // current scope, but if that's really what the user wanted, we want them to use a\n    // qualified name to make it more obvious.  Report an error.\n    KJ_IF_MAYBE(scope, resolver.resolveBootstrapSchema(proto.getScopeId(),\n                                                       schema::Brand::Reader())) {\n      auto scopeReader = scope->getProto();\n      kj::StringPtr parent;\n      if (scopeReader.isFile()) {\n        parent = \"\";\n      } else {\n        parent = scopeReader.getDisplayName().slice(scopeReader.getDisplayNamePrefixLength());\n      }\n      kj::StringPtr id = source.getRelativeName().getValue();\n\n      errorReporter.addErrorOn(source, kj::str(\n          \"Constant names must be qualified to avoid confusion.  Please replace '\",\n          expressionString(source), \"' with '\", parent, \".\", id,\n          \"', if that's what you intended.\"));\n    }\n  }\n\n  return constValue;\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "source",
            "kj::str(\n          \"Constant names must be qualified to avoid confusion.  Please replace '\",\n          expressionString(source), \"' with '\", parent, \".\", id,\n          \"', if that's what you intended.\")"
          ],
          "line": 2964
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Constant names must be qualified to avoid confusion.  Please replace '\"",
            "expressionString(source)",
            "\"' with '\"",
            "parent",
            "\".\"",
            "id",
            "\"', if that's what you intended.\""
          ],
          "line": 2964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expressionString",
          "args": [
            "source"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "expressionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2444-2446",
          "snippet": "static kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kj::String expressionString(Expression::Reader name);",
            "static kj::String expressionString(Expression::Reader name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\n\nstatic kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}"
        }
      },
      {
        "call_info": {
          "callee": "source.getRelativeName",
          "args": [],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source.getRelativeName",
          "args": [],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeReader.getDisplayName",
          "args": [
            "scopeReader.getDisplayNamePrefixLength()"
          ],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeReader.getDisplayNamePrefixLength",
          "args": [],
          "line": 2960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeReader.getDisplayName",
          "args": [],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "scopeReader.isFile",
          "args": [],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scope->getProto",
          "args": [],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "scope",
            "resolver.resolveBootstrapSchema(proto.getScopeId(),\n                                                       schema::Brand::Reader())"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "resolver.resolveBootstrapSchema",
          "args": [
            "proto.getScopeId()",
            "schema::Brand::Reader()"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema::Brand::Reader",
          "args": [],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getScopeId",
          "args": [],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "source.isRelativeName",
          "args": [],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unrecognized AnyPointer-typed member of schema::Value.\""
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objValue.getAs<DynamicList>",
          "args": [
            "constType.asList()"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constType.asList",
          "args": [],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objValue.getAs<DynamicStruct>",
          "args": [
            "constType.asStruct()"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constType.asStruct",
          "args": [],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constType.which",
          "args": [],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constSchema.asConst",
          "args": [],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "asConst",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1127-1129",
          "snippet": "inline ArrayPtr<const T> asConst() const {\n    return ArrayPtr<const T>(ptr, size_);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr<const T> asConst() const {\n      return ArrayPtr<const T>(ptr, size_);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "constValue.as<AnyPointer>",
          "args": [],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "as",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "601-604",
          "snippet": "BuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nBuilderFor<T> as() {\n    // T must be List<U>.\n    return BuilderFor<T>(_builder);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "constValue.getType",
          "args": [],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "dynamicConst.get",
          "args": [
            "KJ_ASSERT_NONNULL(dynamicConst.which())"
          ],
          "line": 2926
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "dynamicConst.which()"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamicConst.which",
          "args": [],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toDynamic",
          "args": [
            "constReader.getValue()"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "toDynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "1246-1248",
          "snippet": "typename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ntypename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "constReader.getValue",
          "args": [],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getConst",
          "args": [],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveFinalSchema",
          "args": [
            "id"
          ],
          "line": 2916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveBootstrapSchema",
          "args": [
            "id",
            "constBrand"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constDecl.getIdAndFillBrand",
          "args": [
            "[&]() { return constBrand; }"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getRoot<schema::Brand>",
          "args": [],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "expressionString(source)",
            "\"' does not refer to a constant.\""
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constDecl.getKind",
          "args": [
            "Declaration::FILE"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "constDecl.getKind",
          "args": [],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "getKind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "77-77",
          "snippet": "Declaration::Which getKind() { return kind; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nDeclaration::Which getKind() { return kind; }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nkj::Maybe<DynamicValue::Reader> NodeTranslator::readConstant(\n    Expression::Reader source, bool isBootstrap) {\n  // Look up the constant decl.\n  NodeTranslator::BrandedDecl constDecl = nullptr;\n  KJ_IF_MAYBE(decl, compileDeclExpression(source, noImplicitParams())) {\n    constDecl = *decl;\n  } else {\n    // Lookup will have reported an error.\n    return nullptr;\n  }\n\n  // Is it a constant?\n  if(constDecl.getKind().orDefault(Declaration::FILE) != Declaration::CONST) {\n    errorReporter.addErrorOn(source,\n        kj::str(\"'\", expressionString(source), \"' does not refer to a constant.\"));\n    return nullptr;\n  }\n\n  // Extract the ID and brand.\n  MallocMessageBuilder builder(256);\n  auto constBrand = builder.getRoot<schema::Brand>();\n  uint64_t id = constDecl.getIdAndFillBrand([&]() { return constBrand; });\n\n  // Look up the schema -- we'll need this to compile the constant's type.\n  Schema constSchema;\n  KJ_IF_MAYBE(s, resolver.resolveBootstrapSchema(id, constBrand)) {\n    constSchema = *s;\n  } else {\n    // The constant's schema is broken for reasons already reported.\n    return nullptr;\n  }\n\n  // If we're bootstrapping, then we know we're expecting a primitive value, so if the\n  // constant turns out to be non-primitive, we'll error out anyway.  If we're not\n  // bootstrapping, we may be compiling a non-primitive value and so we need the final\n  // version of the constant to make sure its value is filled in.\n  schema::Node::Reader proto = constSchema.getProto();\n  if (!isBootstrap) {\n    KJ_IF_MAYBE(finalProto, resolver.resolveFinalSchema(id)) {\n      proto = *finalProto;\n    } else {\n      // The constant's final schema is broken for reasons already reported.\n      return nullptr;\n    }\n  }\n\n  auto constReader = proto.getConst();\n  auto dynamicConst = toDynamic(constReader.getValue());\n  auto constValue = dynamicConst.get(KJ_ASSERT_NONNULL(dynamicConst.which()));\n\n  if (constValue.getType() == DynamicValue::ANY_POINTER) {\n    // We need to assign an appropriate schema to this pointer.\n    AnyPointer::Reader objValue = constValue.as<AnyPointer>();\n\n    auto constType = constSchema.asConst().getType();\n    switch (constType.which()) {\n      case schema::Type::STRUCT:\n        constValue = objValue.getAs<DynamicStruct>(constType.asStruct());\n        break;\n      case schema::Type::LIST:\n        constValue = objValue.getAs<DynamicList>(constType.asList());\n        break;\n      case schema::Type::ANY_POINTER:\n        // Fine as-is.\n        break;\n      default:\n        KJ_FAIL_ASSERT(\"Unrecognized AnyPointer-typed member of schema::Value.\");\n        break;\n    }\n  }\n\n  if (source.isRelativeName()) {\n    // A fully unqualified identifier looks like it might refer to a constant visible in the\n    // current scope, but if that's really what the user wanted, we want them to use a\n    // qualified name to make it more obvious.  Report an error.\n    KJ_IF_MAYBE(scope, resolver.resolveBootstrapSchema(proto.getScopeId(),\n                                                       schema::Brand::Reader())) {\n      auto scopeReader = scope->getProto();\n      kj::StringPtr parent;\n      if (scopeReader.isFile()) {\n        parent = \"\";\n      } else {\n        parent = scopeReader.getDisplayName().slice(scopeReader.getDisplayNamePrefixLength());\n      }\n      kj::StringPtr id = source.getRelativeName().getValue();\n\n      errorReporter.addErrorOn(source, kj::str(\n          \"Constant names must be qualified to avoid confusion.  Please replace '\",\n          expressionString(source), \"' with '\", parent, \".\", id,\n          \"', if that's what you intended.\"));\n    }\n  }\n\n  return constValue;\n}"
  },
  {
    "function_name": "ValueTranslator::makeTypeName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2852-2876",
    "snippet": "kj::String ValueTranslator::makeTypeName(Type type) {\n  switch (type.which()) {\n    case schema::Type::VOID: return kj::str(\"Void\");\n    case schema::Type::BOOL: return kj::str(\"Bool\");\n    case schema::Type::INT8: return kj::str(\"Int8\");\n    case schema::Type::INT16: return kj::str(\"Int16\");\n    case schema::Type::INT32: return kj::str(\"Int32\");\n    case schema::Type::INT64: return kj::str(\"Int64\");\n    case schema::Type::UINT8: return kj::str(\"UInt8\");\n    case schema::Type::UINT16: return kj::str(\"UInt16\");\n    case schema::Type::UINT32: return kj::str(\"UInt32\");\n    case schema::Type::UINT64: return kj::str(\"UInt64\");\n    case schema::Type::FLOAT32: return kj::str(\"Float32\");\n    case schema::Type::FLOAT64: return kj::str(\"Float64\");\n    case schema::Type::TEXT: return kj::str(\"Text\");\n    case schema::Type::DATA: return kj::str(\"Data\");\n    case schema::Type::LIST:\n      return kj::str(\"List(\", makeTypeName(type.asList().getElementType()), \")\");\n    case schema::Type::ENUM: return makeNodeName(type.asEnum());\n    case schema::Type::STRUCT: return makeNodeName(type.asStruct());\n    case schema::Type::INTERFACE: return makeNodeName(type.asInterface());\n    case schema::Type::ANY_POINTER: return kj::str(\"AnyPointer\");\n  }\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"AnyPointer\""
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "makeNodeName",
          "args": [
            "type.asInterface()"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "ValueTranslator::makeNodeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2847-2850",
          "snippet": "kj::String ValueTranslator::makeNodeName(Schema schema) {\n  schema::Node::Reader proto = schema.getProto();\n  return kj::str(proto.getDisplayName().slice(proto.getDisplayNamePrefixLength()));\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::String ValueTranslator::makeNodeName(Schema schema) {\n  schema::Node::Reader proto = schema.getProto();\n  return kj::str(proto.getDisplayName().slice(proto.getDisplayNamePrefixLength()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.asInterface",
          "args": [],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asStruct",
          "args": [],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asEnum",
          "args": [],
          "line": 2870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"List(\"",
            "makeTypeName(type.asList().getElementType())",
            "\")\""
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asList",
          "args": [],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asList",
          "args": [],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 2853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nkj::String ValueTranslator::makeTypeName(Type type) {\n  switch (type.which()) {\n    case schema::Type::VOID: return kj::str(\"Void\");\n    case schema::Type::BOOL: return kj::str(\"Bool\");\n    case schema::Type::INT8: return kj::str(\"Int8\");\n    case schema::Type::INT16: return kj::str(\"Int16\");\n    case schema::Type::INT32: return kj::str(\"Int32\");\n    case schema::Type::INT64: return kj::str(\"Int64\");\n    case schema::Type::UINT8: return kj::str(\"UInt8\");\n    case schema::Type::UINT16: return kj::str(\"UInt16\");\n    case schema::Type::UINT32: return kj::str(\"UInt32\");\n    case schema::Type::UINT64: return kj::str(\"UInt64\");\n    case schema::Type::FLOAT32: return kj::str(\"Float32\");\n    case schema::Type::FLOAT64: return kj::str(\"Float64\");\n    case schema::Type::TEXT: return kj::str(\"Text\");\n    case schema::Type::DATA: return kj::str(\"Data\");\n    case schema::Type::LIST:\n      return kj::str(\"List(\", makeTypeName(type.asList().getElementType()), \")\");\n    case schema::Type::ENUM: return makeNodeName(type.asEnum());\n    case schema::Type::STRUCT: return makeNodeName(type.asStruct());\n    case schema::Type::INTERFACE: return makeNodeName(type.asInterface());\n    case schema::Type::ANY_POINTER: return kj::str(\"AnyPointer\");\n  }\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "ValueTranslator::makeNodeName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2847-2850",
    "snippet": "kj::String ValueTranslator::makeNodeName(Schema schema) {\n  schema::Node::Reader proto = schema.getProto();\n  return kj::str(proto.getDisplayName().slice(proto.getDisplayNamePrefixLength()));\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "proto.getDisplayName().slice(proto.getDisplayNamePrefixLength())"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getDisplayName",
          "args": [
            "proto.getDisplayNamePrefixLength()"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getDisplayNamePrefixLength",
          "args": [],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getDisplayName",
          "args": [],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::String ValueTranslator::makeNodeName(Schema schema) {\n  schema::Node::Reader proto = schema.getProto();\n  return kj::str(proto.getDisplayName().slice(proto.getDisplayNamePrefixLength()));\n}"
  },
  {
    "function_name": "ValueTranslator::fillStructValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2813-2845",
    "snippet": "void ValueTranslator::fillStructValue(DynamicStruct::Builder builder,\n                                      List<Expression::Param>::Reader assignments) {\n  for (auto assignment: assignments) {\n    if (assignment.isNamed()) {\n      auto fieldName = assignment.getNamed();\n      KJ_IF_MAYBE(field, builder.getSchema().findFieldByName(fieldName.getValue())) {\n        auto fieldProto = field->getProto();\n        auto value = assignment.getValue();\n\n        switch (fieldProto.which()) {\n          case schema::Field::SLOT:\n            KJ_IF_MAYBE(compiledValue, compileValue(value, field->getType())) {\n              builder.adopt(*field, kj::mv(*compiledValue));\n            }\n            break;\n\n          case schema::Field::GROUP:\n            if (value.isTuple()) {\n              fillStructValue(builder.init(*field).as<DynamicStruct>(), value.getTuple());\n            } else {\n              errorReporter.addErrorOn(value, \"Type mismatch; expected group.\");\n            }\n            break;\n        }\n      } else {\n        errorReporter.addErrorOn(fieldName, kj::str(\n            \"Struct has no field named '\", fieldName.getValue(), \"'.\"));\n      }\n    } else {\n      errorReporter.addErrorOn(assignment.getValue(), kj::str(\"Missing field name.\"));\n    }\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "assignment.getValue()",
            "kj::str(\"Missing field name.\")"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Missing field name.\""
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "assignment.getValue",
          "args": [],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Struct has no field named '\"",
            "fieldName.getValue()",
            "\"'.\""
          ],
          "line": 2838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldName.getValue",
          "args": [],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getTuple",
          "args": [],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.init",
          "args": [],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "77-81",
          "snippet": "void init(Params&&... params) {\n    if (tag != 0) destroy();\n    ctor(*reinterpret_cast<T*>(space), kj::fwd<Params>(params)...);\n    tag = typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  void init(Params&&... params) {\n      if (tag != 0) destroy();\n      ctor(*reinterpret_cast<T*>(space), kj::fwd<Params>(params)...);\n      tag = typeIndex<T>();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.init",
          "args": [
            "*field"
          ],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "value.isTuple",
          "args": [],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.adopt",
          "args": [
            "*field",
            "kj::mv(*compiledValue)"
          ],
          "line": 2825
        },
        "resolved": true,
        "details": {
          "function_name": "adopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "828-830",
          "snippet": "static inline void adopt(PointerBuilder builder, Orphan<AnyPointer>&& value) {\n    builder.adopt(kj::mv(value.builder));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void adopt(PointerBuilder builder, Orphan<AnyPointer>&& value) {\n    builder.adopt(kj::mv(value.builder));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*compiledValue"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "compiledValue",
            "compileValue(value, field->getType())"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "compileValue",
          "args": [
            "value",
            "field->getType()"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "ValueTranslator::compileValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2562-2696",
          "snippet": "kj::Maybe<Orphan<DynamicValue>> ValueTranslator::compileValue(Expression::Reader src, Type type) {\n  Orphan<DynamicValue> result = compileValueInner(src, type);\n\n  switch (result.getType()) {\n    case DynamicValue::UNKNOWN:\n      // Error already reported.\n      return nullptr;\n\n    case DynamicValue::VOID:\n      if (type.isVoid()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::BOOL:\n      if (type.isBool()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::INT: {\n      int64_t value = result.getReader().as<int64_t>();\n      if (value < 0) {\n        int64_t minValue = 1;\n        switch (type.which()) {\n          case schema::Type::INT8: minValue = (int8_t)kj::minValue; break;\n          case schema::Type::INT16: minValue = (int16_t)kj::minValue; break;\n          case schema::Type::INT32: minValue = (int32_t)kj::minValue; break;\n          case schema::Type::INT64: minValue = (int64_t)kj::minValue; break;\n          case schema::Type::UINT8: minValue = (uint8_t)kj::minValue; break;\n          case schema::Type::UINT16: minValue = (uint16_t)kj::minValue; break;\n          case schema::Type::UINT32: minValue = (uint32_t)kj::minValue; break;\n          case schema::Type::UINT64: minValue = (uint64_t)kj::minValue; break;\n\n          case schema::Type::FLOAT32:\n          case schema::Type::FLOAT64:\n            // Any integer is acceptable.\n            minValue = (int64_t)kj::minValue;\n            break;\n\n          default: break;\n        }\n        if (minValue == 1) break;\n\n        if (value < minValue) {\n          errorReporter.addErrorOn(src, \"Integer value out of range.\");\n          result = minValue;\n        }\n        return kj::mv(result);\n      }\n\n      // No break -- value is positive, so we can just go on to the uint case below.\n    }\n\n    case DynamicValue::UINT: {\n      uint64_t maxValue = 0;\n      switch (type.which()) {\n        case schema::Type::INT8: maxValue = (int8_t)kj::maxValue; break;\n        case schema::Type::INT16: maxValue = (int16_t)kj::maxValue; break;\n        case schema::Type::INT32: maxValue = (int32_t)kj::maxValue; break;\n        case schema::Type::INT64: maxValue = (int64_t)kj::maxValue; break;\n        case schema::Type::UINT8: maxValue = (uint8_t)kj::maxValue; break;\n        case schema::Type::UINT16: maxValue = (uint16_t)kj::maxValue; break;\n        case schema::Type::UINT32: maxValue = (uint32_t)kj::maxValue; break;\n        case schema::Type::UINT64: maxValue = (uint64_t)kj::maxValue; break;\n\n        case schema::Type::FLOAT32:\n        case schema::Type::FLOAT64:\n          // Any integer is acceptable.\n          maxValue = (uint64_t)kj::maxValue;\n          break;\n\n        default: break;\n      }\n      if (maxValue == 0) break;\n\n      if (result.getReader().as<uint64_t>() > maxValue) {\n        errorReporter.addErrorOn(src, \"Integer value out of range.\");\n        result = maxValue;\n      }\n      return kj::mv(result);\n    }\n\n    case DynamicValue::FLOAT:\n      if (type.isFloat32() || type.isFloat64()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::TEXT:\n      if (type.isText()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::DATA:\n      if (type.isData()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::LIST:\n      if (type.isList()) {\n        if (result.getReader().as<DynamicList>().getSchema() == type.asList()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::ENUM:\n      if (type.isEnum()) {\n        if (result.getReader().as<DynamicEnum>().getSchema() == type.asEnum()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::STRUCT:\n      if (type.isStruct()) {\n        if (result.getReader().as<DynamicStruct>().getSchema() == type.asStruct()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::CAPABILITY:\n      KJ_FAIL_ASSERT(\"Interfaces can't have literal values.\");\n\n    case DynamicValue::ANY_POINTER:\n      KJ_FAIL_ASSERT(\"AnyPointers can't have literal values.\");\n  }\n\n  errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n  return nullptr;\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nkj::Maybe<Orphan<DynamicValue>> ValueTranslator::compileValue(Expression::Reader src, Type type) {\n  Orphan<DynamicValue> result = compileValueInner(src, type);\n\n  switch (result.getType()) {\n    case DynamicValue::UNKNOWN:\n      // Error already reported.\n      return nullptr;\n\n    case DynamicValue::VOID:\n      if (type.isVoid()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::BOOL:\n      if (type.isBool()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::INT: {\n      int64_t value = result.getReader().as<int64_t>();\n      if (value < 0) {\n        int64_t minValue = 1;\n        switch (type.which()) {\n          case schema::Type::INT8: minValue = (int8_t)kj::minValue; break;\n          case schema::Type::INT16: minValue = (int16_t)kj::minValue; break;\n          case schema::Type::INT32: minValue = (int32_t)kj::minValue; break;\n          case schema::Type::INT64: minValue = (int64_t)kj::minValue; break;\n          case schema::Type::UINT8: minValue = (uint8_t)kj::minValue; break;\n          case schema::Type::UINT16: minValue = (uint16_t)kj::minValue; break;\n          case schema::Type::UINT32: minValue = (uint32_t)kj::minValue; break;\n          case schema::Type::UINT64: minValue = (uint64_t)kj::minValue; break;\n\n          case schema::Type::FLOAT32:\n          case schema::Type::FLOAT64:\n            // Any integer is acceptable.\n            minValue = (int64_t)kj::minValue;\n            break;\n\n          default: break;\n        }\n        if (minValue == 1) break;\n\n        if (value < minValue) {\n          errorReporter.addErrorOn(src, \"Integer value out of range.\");\n          result = minValue;\n        }\n        return kj::mv(result);\n      }\n\n      // No break -- value is positive, so we can just go on to the uint case below.\n    }\n\n    case DynamicValue::UINT: {\n      uint64_t maxValue = 0;\n      switch (type.which()) {\n        case schema::Type::INT8: maxValue = (int8_t)kj::maxValue; break;\n        case schema::Type::INT16: maxValue = (int16_t)kj::maxValue; break;\n        case schema::Type::INT32: maxValue = (int32_t)kj::maxValue; break;\n        case schema::Type::INT64: maxValue = (int64_t)kj::maxValue; break;\n        case schema::Type::UINT8: maxValue = (uint8_t)kj::maxValue; break;\n        case schema::Type::UINT16: maxValue = (uint16_t)kj::maxValue; break;\n        case schema::Type::UINT32: maxValue = (uint32_t)kj::maxValue; break;\n        case schema::Type::UINT64: maxValue = (uint64_t)kj::maxValue; break;\n\n        case schema::Type::FLOAT32:\n        case schema::Type::FLOAT64:\n          // Any integer is acceptable.\n          maxValue = (uint64_t)kj::maxValue;\n          break;\n\n        default: break;\n      }\n      if (maxValue == 0) break;\n\n      if (result.getReader().as<uint64_t>() > maxValue) {\n        errorReporter.addErrorOn(src, \"Integer value out of range.\");\n        result = maxValue;\n      }\n      return kj::mv(result);\n    }\n\n    case DynamicValue::FLOAT:\n      if (type.isFloat32() || type.isFloat64()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::TEXT:\n      if (type.isText()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::DATA:\n      if (type.isData()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::LIST:\n      if (type.isList()) {\n        if (result.getReader().as<DynamicList>().getSchema() == type.asList()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::ENUM:\n      if (type.isEnum()) {\n        if (result.getReader().as<DynamicEnum>().getSchema() == type.asEnum()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::STRUCT:\n      if (type.isStruct()) {\n        if (result.getReader().as<DynamicStruct>().getSchema() == type.asStruct()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::CAPABILITY:\n      KJ_FAIL_ASSERT(\"Interfaces can't have literal values.\");\n\n    case DynamicValue::ANY_POINTER:\n      KJ_FAIL_ASSERT(\"AnyPointers can't have literal values.\");\n  }\n\n  errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n  return nullptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "field->getType",
          "args": [],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "fieldProto.which",
          "args": [],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assignment.getValue",
          "args": [],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field->getProto",
          "args": [],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "builder.getSchema",
          "args": [
            "fieldName.getValue()"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldName.getValue",
          "args": [],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getSchema",
          "args": [],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      },
      {
        "call_info": {
          "callee": "assignment.getNamed",
          "args": [],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assignment.isNamed",
          "args": [],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid ValueTranslator::fillStructValue(DynamicStruct::Builder builder,\n                                      List<Expression::Param>::Reader assignments) {\n  for (auto assignment: assignments) {\n    if (assignment.isNamed()) {\n      auto fieldName = assignment.getNamed();\n      KJ_IF_MAYBE(field, builder.getSchema().findFieldByName(fieldName.getValue())) {\n        auto fieldProto = field->getProto();\n        auto value = assignment.getValue();\n\n        switch (fieldProto.which()) {\n          case schema::Field::SLOT:\n            KJ_IF_MAYBE(compiledValue, compileValue(value, field->getType())) {\n              builder.adopt(*field, kj::mv(*compiledValue));\n            }\n            break;\n\n          case schema::Field::GROUP:\n            if (value.isTuple()) {\n              fillStructValue(builder.init(*field).as<DynamicStruct>(), value.getTuple());\n            } else {\n              errorReporter.addErrorOn(value, \"Type mismatch; expected group.\");\n            }\n            break;\n        }\n      } else {\n        errorReporter.addErrorOn(fieldName, kj::str(\n            \"Struct has no field named '\", fieldName.getValue(), \"'.\"));\n      }\n    } else {\n      errorReporter.addErrorOn(assignment.getValue(), kj::str(\"Missing field name.\"));\n    }\n  }\n}"
  },
  {
    "function_name": "ValueTranslator::compileValueInner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2698-2811",
    "snippet": "Orphan<DynamicValue> ValueTranslator::compileValueInner(Expression::Reader src, Type type) {\n  switch (src.which()) {\n    case Expression::RELATIVE_NAME: {\n      auto name = src.getRelativeName();\n\n      // The name is just a bare identifier.  It may be a literal value or an enumerant.\n      kj::StringPtr id = name.getValue();\n\n      if (type.isEnum()) {\n        KJ_IF_MAYBE(enumerant, type.asEnum().findEnumerantByName(id)) {\n          return DynamicEnum(*enumerant);\n        }\n      } else {\n        // Interpret known constant values.\n        if (id == \"void\") {\n          return VOID;\n        } else if (id == \"true\") {\n          return true;\n        } else if (id == \"false\") {\n          return false;\n        } else if (id == \"nan\") {\n          return kj::nan();\n        } else if (id == \"inf\") {\n          return kj::inf();\n        }\n      }\n\n      // Apparently not a literal. Try resolving it.\n      KJ_IF_MAYBE(constValue, resolver.resolveConstant(src)) {\n        return orphanage.newOrphanCopy(*constValue);\n      } else {\n        return nullptr;\n      }\n    }\n\n    case Expression::ABSOLUTE_NAME:\n    case Expression::IMPORT:\n    case Expression::APPLICATION:\n    case Expression::MEMBER:\n      KJ_IF_MAYBE(constValue, resolver.resolveConstant(src)) {\n        return orphanage.newOrphanCopy(*constValue);\n      } else {\n        return nullptr;\n      }\n\n    case Expression::POSITIVE_INT:\n      return src.getPositiveInt();\n\n    case Expression::NEGATIVE_INT: {\n      uint64_t nValue = src.getNegativeInt();\n      if (nValue > ((uint64_t)kj::maxValue >> 1) + 1) {\n        errorReporter.addErrorOn(src, \"Integer is too big to be negative.\");\n        return nullptr;\n      } else {\n        return kj::implicitCast<int64_t>(-nValue);\n      }\n    }\n\n    case Expression::FLOAT:\n      return src.getFloat();\n      break;\n\n    case Expression::STRING:\n      if (type.isData()) {\n        Text::Reader text = src.getString();\n        return orphanage.newOrphanCopy(Data::Reader(text.asBytes()));\n      } else {\n        return orphanage.newOrphanCopy(src.getString());\n      }\n      break;\n\n    case Expression::BINARY:\n      if (!type.isData()) {\n        errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n        return nullptr;\n      }\n      return orphanage.newOrphanCopy(src.getBinary());\n\n    case Expression::LIST: {\n      if (!type.isList()) {\n        errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n        return nullptr;\n      }\n      auto listSchema = type.asList();\n      Type elementType = listSchema.getElementType();\n      auto srcList = src.getList();\n      Orphan<DynamicList> result = orphanage.newOrphan(listSchema, srcList.size());\n      auto dstList = result.get();\n      for (uint i = 0; i < srcList.size(); i++) {\n        KJ_IF_MAYBE(value, compileValue(srcList[i], elementType)) {\n          dstList.adopt(i, kj::mv(*value));\n        }\n      }\n      return kj::mv(result);\n    }\n\n    case Expression::TUPLE: {\n      if (!type.isStruct()) {\n        errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n        return nullptr;\n      }\n      auto structSchema = type.asStruct();\n      Orphan<DynamicStruct> result = orphanage.newOrphan(structSchema);\n      fillStructValue(result.get(), src.getTuple());\n      return kj::mv(result);\n    }\n\n    case Expression::UNKNOWN:\n      // Ignore earlier error.\n      return nullptr;\n  }\n\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);",
      "uint i = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fillStructValue",
          "args": [
            "result.get()",
            "src.getTuple()"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "ValueTranslator::fillStructValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2813-2845",
          "snippet": "void ValueTranslator::fillStructValue(DynamicStruct::Builder builder,\n                                      List<Expression::Param>::Reader assignments) {\n  for (auto assignment: assignments) {\n    if (assignment.isNamed()) {\n      auto fieldName = assignment.getNamed();\n      KJ_IF_MAYBE(field, builder.getSchema().findFieldByName(fieldName.getValue())) {\n        auto fieldProto = field->getProto();\n        auto value = assignment.getValue();\n\n        switch (fieldProto.which()) {\n          case schema::Field::SLOT:\n            KJ_IF_MAYBE(compiledValue, compileValue(value, field->getType())) {\n              builder.adopt(*field, kj::mv(*compiledValue));\n            }\n            break;\n\n          case schema::Field::GROUP:\n            if (value.isTuple()) {\n              fillStructValue(builder.init(*field).as<DynamicStruct>(), value.getTuple());\n            } else {\n              errorReporter.addErrorOn(value, \"Type mismatch; expected group.\");\n            }\n            break;\n        }\n      } else {\n        errorReporter.addErrorOn(fieldName, kj::str(\n            \"Struct has no field named '\", fieldName.getValue(), \"'.\"));\n      }\n    } else {\n      errorReporter.addErrorOn(assignment.getValue(), kj::str(\"Missing field name.\"));\n    }\n  }\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kj::String expressionString(Expression::Reader name);",
            "static kj::String expressionString(Expression::Reader name);",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid ValueTranslator::fillStructValue(DynamicStruct::Builder builder,\n                                      List<Expression::Param>::Reader assignments) {\n  for (auto assignment: assignments) {\n    if (assignment.isNamed()) {\n      auto fieldName = assignment.getNamed();\n      KJ_IF_MAYBE(field, builder.getSchema().findFieldByName(fieldName.getValue())) {\n        auto fieldProto = field->getProto();\n        auto value = assignment.getValue();\n\n        switch (fieldProto.which()) {\n          case schema::Field::SLOT:\n            KJ_IF_MAYBE(compiledValue, compileValue(value, field->getType())) {\n              builder.adopt(*field, kj::mv(*compiledValue));\n            }\n            break;\n\n          case schema::Field::GROUP:\n            if (value.isTuple()) {\n              fillStructValue(builder.init(*field).as<DynamicStruct>(), value.getTuple());\n            } else {\n              errorReporter.addErrorOn(value, \"Type mismatch; expected group.\");\n            }\n            break;\n        }\n      } else {\n        errorReporter.addErrorOn(fieldName, kj::str(\n            \"Struct has no field named '\", fieldName.getValue(), \"'.\"));\n      }\n    } else {\n      errorReporter.addErrorOn(assignment.getValue(), kj::str(\"Missing field name.\"));\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "src.getTuple",
          "args": [],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.get",
          "args": [],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan",
          "args": [
            "structSchema"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asStruct",
          "args": [],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "src",
            "kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\")"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Type mismatch; expected \"",
            "makeTypeName(type)",
            "\".\""
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeTypeName",
          "args": [
            "type"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "ValueTranslator::makeTypeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2852-2876",
          "snippet": "kj::String ValueTranslator::makeTypeName(Type type) {\n  switch (type.which()) {\n    case schema::Type::VOID: return kj::str(\"Void\");\n    case schema::Type::BOOL: return kj::str(\"Bool\");\n    case schema::Type::INT8: return kj::str(\"Int8\");\n    case schema::Type::INT16: return kj::str(\"Int16\");\n    case schema::Type::INT32: return kj::str(\"Int32\");\n    case schema::Type::INT64: return kj::str(\"Int64\");\n    case schema::Type::UINT8: return kj::str(\"UInt8\");\n    case schema::Type::UINT16: return kj::str(\"UInt16\");\n    case schema::Type::UINT32: return kj::str(\"UInt32\");\n    case schema::Type::UINT64: return kj::str(\"UInt64\");\n    case schema::Type::FLOAT32: return kj::str(\"Float32\");\n    case schema::Type::FLOAT64: return kj::str(\"Float64\");\n    case schema::Type::TEXT: return kj::str(\"Text\");\n    case schema::Type::DATA: return kj::str(\"Data\");\n    case schema::Type::LIST:\n      return kj::str(\"List(\", makeTypeName(type.asList().getElementType()), \")\");\n    case schema::Type::ENUM: return makeNodeName(type.asEnum());\n    case schema::Type::STRUCT: return makeNodeName(type.asStruct());\n    case schema::Type::INTERFACE: return makeNodeName(type.asInterface());\n    case schema::Type::ANY_POINTER: return kj::str(\"AnyPointer\");\n  }\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nkj::String ValueTranslator::makeTypeName(Type type) {\n  switch (type.which()) {\n    case schema::Type::VOID: return kj::str(\"Void\");\n    case schema::Type::BOOL: return kj::str(\"Bool\");\n    case schema::Type::INT8: return kj::str(\"Int8\");\n    case schema::Type::INT16: return kj::str(\"Int16\");\n    case schema::Type::INT32: return kj::str(\"Int32\");\n    case schema::Type::INT64: return kj::str(\"Int64\");\n    case schema::Type::UINT8: return kj::str(\"UInt8\");\n    case schema::Type::UINT16: return kj::str(\"UInt16\");\n    case schema::Type::UINT32: return kj::str(\"UInt32\");\n    case schema::Type::UINT64: return kj::str(\"UInt64\");\n    case schema::Type::FLOAT32: return kj::str(\"Float32\");\n    case schema::Type::FLOAT64: return kj::str(\"Float64\");\n    case schema::Type::TEXT: return kj::str(\"Text\");\n    case schema::Type::DATA: return kj::str(\"Data\");\n    case schema::Type::LIST:\n      return kj::str(\"List(\", makeTypeName(type.asList().getElementType()), \")\");\n    case schema::Type::ENUM: return makeNodeName(type.asEnum());\n    case schema::Type::STRUCT: return makeNodeName(type.asStruct());\n    case schema::Type::INTERFACE: return makeNodeName(type.asInterface());\n    case schema::Type::ANY_POINTER: return kj::str(\"AnyPointer\");\n  }\n  KJ_UNREACHABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.isStruct",
          "args": [],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "isStruct",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "142-144",
          "snippet": "inline bool isStruct() {\n      return builder.isStruct();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline bool isStruct() {\n          return builder.isStruct();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dstList.adopt",
          "args": [
            "i",
            "kj::mv(*value)"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "adopt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "828-830",
          "snippet": "static inline void adopt(PointerBuilder builder, Orphan<AnyPointer>&& value) {\n    builder.adopt(kj::mv(value.builder));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void adopt(PointerBuilder builder, Orphan<AnyPointer>&& value) {\n    builder.adopt(kj::mv(value.builder));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*value"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcList.size",
          "args": [],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan",
          "args": [
            "listSchema",
            "srcList.size()"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.getList",
          "args": [],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listSchema.getElementType",
          "args": [],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asList",
          "args": [],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Type mismatch; expected \"",
            "makeTypeName(type)",
            "\".\""
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isList",
          "args": [],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "145-147",
          "snippet": "inline bool isList() {\n      return builder.isList();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline bool isList() {\n          return builder.isList();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "src.getBinary()"
          ],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.getBinary",
          "args": [],
          "line": 2774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Type mismatch; expected \"",
            "makeTypeName(type)",
            "\".\""
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isData",
          "args": [],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "src.getString()"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.getString",
          "args": [],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "Data::Reader(text.asBytes())"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Data::Reader",
          "args": [
            "text.asBytes()"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "Reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3113-3113",
          "snippet": "inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline explicit Reader(::capnp::_::StructReader base): _reader(base) {}"
        }
      },
      {
        "call_info": {
          "callee": "text.asBytes",
          "args": [],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "asBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "128-128",
          "snippet": "inline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }"
        }
      },
      {
        "call_info": {
          "callee": "src.getString",
          "args": [],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isData",
          "args": [],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.getFloat",
          "args": [],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::implicitCast<int64_t>",
          "args": [
            "-nValue"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "implicitCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1203-1207",
          "snippet": "To implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nTo implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "src.getNegativeInt",
          "args": [],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.getPositiveInt",
          "args": [],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "*constValue"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "constValue",
            "resolver.resolveConstant(src)"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "resolver.resolveConstant",
          "args": [
            "src"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "resolveConstant",
          "container": "ValueResolverGlue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnp.c++",
          "lines": "1349-1352",
          "snippet": "kj::Maybe<DynamicValue::Reader> resolveConstant(Expression::Reader name) {\n      errorReporter.addErrorOn(name, kj::str(\"External constants not allowed in encode input.\"));\n      return nullptr;\n    }",
          "includes": [
            "#include \"config.h\"",
            "#include <sys/wait.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <process.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <kj/parse/char.h>",
            "#include <kj/main.h>",
            "#include <iostream>",
            "#include \"../message.h\"",
            "#include <kj/debug.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/vector.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/pretty-print.h>",
            "#include \"node-translator.h\"",
            "#include \"module-loader.h\"",
            "#include \"compiler.h\"",
            "#include \"parser.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CapnpParser parser(arena.getOrphanage(), errorReporter);",
            "ValueResolverGlue resolver(compiler->getLoader(), errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <io.h>\n#include <process.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <kj/parse/char.h>\n#include <kj/main.h>\n#include <iostream>\n#include \"../message.h\"\n#include <kj/debug.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/vector.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/pretty-print.h>\n#include \"node-translator.h\"\n#include \"module-loader.h\"\n#include \"compiler.h\"\n#include \"parser.h\"\n#include \"lexer.h\"\n\nCapnpParser parser(arena.getOrphanage(), errorReporter);\nValueResolverGlue resolver(compiler->getLoader(), errorReporter);\n\nValueResolverGlue {\n  kj::Maybe<DynamicValue::Reader> resolveConstant(Expression::Reader name) {\n        errorReporter.addErrorOn(name, kj::str(\"External constants not allowed in encode input.\"));\n        return nullptr;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphanCopy",
          "args": [
            "*constValue"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::inf",
          "args": [],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "inf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "580-580",
          "snippet": "inline constexpr float inf() { return (float)(1e300 * 1e300); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr float inf() { return (float)(1e300 * 1e300); }"
        }
      },
      {
        "call_info": {
          "callee": "kj::nan",
          "args": [],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "nan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "573-573",
          "snippet": "inline constexpr float nan() { return __builtin_nanf(\"\"); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr float nan() { return __builtin_nanf(\"\"); }"
        }
      },
      {
        "call_info": {
          "callee": "DynamicEnum",
          "args": [
            "*enumerant"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "DynamicEnum",
          "container": "DynamicEnum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "136-136",
          "snippet": "inline DynamicEnum(T&& value): DynamicEnum(toDynamic(value)) {}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\nDynamicEnum {\n  inline DynamicEnum(T&& value): DynamicEnum(toDynamic(value)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.asEnum",
          "args": [
            "id"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asEnum",
          "args": [],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isEnum",
          "args": [],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.getValue",
          "args": [],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.getRelativeName",
          "args": [],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "src.which",
          "args": [],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nOrphan<DynamicValue> ValueTranslator::compileValueInner(Expression::Reader src, Type type) {\n  switch (src.which()) {\n    case Expression::RELATIVE_NAME: {\n      auto name = src.getRelativeName();\n\n      // The name is just a bare identifier.  It may be a literal value or an enumerant.\n      kj::StringPtr id = name.getValue();\n\n      if (type.isEnum()) {\n        KJ_IF_MAYBE(enumerant, type.asEnum().findEnumerantByName(id)) {\n          return DynamicEnum(*enumerant);\n        }\n      } else {\n        // Interpret known constant values.\n        if (id == \"void\") {\n          return VOID;\n        } else if (id == \"true\") {\n          return true;\n        } else if (id == \"false\") {\n          return false;\n        } else if (id == \"nan\") {\n          return kj::nan();\n        } else if (id == \"inf\") {\n          return kj::inf();\n        }\n      }\n\n      // Apparently not a literal. Try resolving it.\n      KJ_IF_MAYBE(constValue, resolver.resolveConstant(src)) {\n        return orphanage.newOrphanCopy(*constValue);\n      } else {\n        return nullptr;\n      }\n    }\n\n    case Expression::ABSOLUTE_NAME:\n    case Expression::IMPORT:\n    case Expression::APPLICATION:\n    case Expression::MEMBER:\n      KJ_IF_MAYBE(constValue, resolver.resolveConstant(src)) {\n        return orphanage.newOrphanCopy(*constValue);\n      } else {\n        return nullptr;\n      }\n\n    case Expression::POSITIVE_INT:\n      return src.getPositiveInt();\n\n    case Expression::NEGATIVE_INT: {\n      uint64_t nValue = src.getNegativeInt();\n      if (nValue > ((uint64_t)kj::maxValue >> 1) + 1) {\n        errorReporter.addErrorOn(src, \"Integer is too big to be negative.\");\n        return nullptr;\n      } else {\n        return kj::implicitCast<int64_t>(-nValue);\n      }\n    }\n\n    case Expression::FLOAT:\n      return src.getFloat();\n      break;\n\n    case Expression::STRING:\n      if (type.isData()) {\n        Text::Reader text = src.getString();\n        return orphanage.newOrphanCopy(Data::Reader(text.asBytes()));\n      } else {\n        return orphanage.newOrphanCopy(src.getString());\n      }\n      break;\n\n    case Expression::BINARY:\n      if (!type.isData()) {\n        errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n        return nullptr;\n      }\n      return orphanage.newOrphanCopy(src.getBinary());\n\n    case Expression::LIST: {\n      if (!type.isList()) {\n        errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n        return nullptr;\n      }\n      auto listSchema = type.asList();\n      Type elementType = listSchema.getElementType();\n      auto srcList = src.getList();\n      Orphan<DynamicList> result = orphanage.newOrphan(listSchema, srcList.size());\n      auto dstList = result.get();\n      for (uint i = 0; i < srcList.size(); i++) {\n        KJ_IF_MAYBE(value, compileValue(srcList[i], elementType)) {\n          dstList.adopt(i, kj::mv(*value));\n        }\n      }\n      return kj::mv(result);\n    }\n\n    case Expression::TUPLE: {\n      if (!type.isStruct()) {\n        errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n        return nullptr;\n      }\n      auto structSchema = type.asStruct();\n      Orphan<DynamicStruct> result = orphanage.newOrphan(structSchema);\n      fillStructValue(result.get(), src.getTuple());\n      return kj::mv(result);\n    }\n\n    case Expression::UNKNOWN:\n      // Ignore earlier error.\n      return nullptr;\n  }\n\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "ValueTranslator::compileValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2562-2696",
    "snippet": "kj::Maybe<Orphan<DynamicValue>> ValueTranslator::compileValue(Expression::Reader src, Type type) {\n  Orphan<DynamicValue> result = compileValueInner(src, type);\n\n  switch (result.getType()) {\n    case DynamicValue::UNKNOWN:\n      // Error already reported.\n      return nullptr;\n\n    case DynamicValue::VOID:\n      if (type.isVoid()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::BOOL:\n      if (type.isBool()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::INT: {\n      int64_t value = result.getReader().as<int64_t>();\n      if (value < 0) {\n        int64_t minValue = 1;\n        switch (type.which()) {\n          case schema::Type::INT8: minValue = (int8_t)kj::minValue; break;\n          case schema::Type::INT16: minValue = (int16_t)kj::minValue; break;\n          case schema::Type::INT32: minValue = (int32_t)kj::minValue; break;\n          case schema::Type::INT64: minValue = (int64_t)kj::minValue; break;\n          case schema::Type::UINT8: minValue = (uint8_t)kj::minValue; break;\n          case schema::Type::UINT16: minValue = (uint16_t)kj::minValue; break;\n          case schema::Type::UINT32: minValue = (uint32_t)kj::minValue; break;\n          case schema::Type::UINT64: minValue = (uint64_t)kj::minValue; break;\n\n          case schema::Type::FLOAT32:\n          case schema::Type::FLOAT64:\n            // Any integer is acceptable.\n            minValue = (int64_t)kj::minValue;\n            break;\n\n          default: break;\n        }\n        if (minValue == 1) break;\n\n        if (value < minValue) {\n          errorReporter.addErrorOn(src, \"Integer value out of range.\");\n          result = minValue;\n        }\n        return kj::mv(result);\n      }\n\n      // No break -- value is positive, so we can just go on to the uint case below.\n    }\n\n    case DynamicValue::UINT: {\n      uint64_t maxValue = 0;\n      switch (type.which()) {\n        case schema::Type::INT8: maxValue = (int8_t)kj::maxValue; break;\n        case schema::Type::INT16: maxValue = (int16_t)kj::maxValue; break;\n        case schema::Type::INT32: maxValue = (int32_t)kj::maxValue; break;\n        case schema::Type::INT64: maxValue = (int64_t)kj::maxValue; break;\n        case schema::Type::UINT8: maxValue = (uint8_t)kj::maxValue; break;\n        case schema::Type::UINT16: maxValue = (uint16_t)kj::maxValue; break;\n        case schema::Type::UINT32: maxValue = (uint32_t)kj::maxValue; break;\n        case schema::Type::UINT64: maxValue = (uint64_t)kj::maxValue; break;\n\n        case schema::Type::FLOAT32:\n        case schema::Type::FLOAT64:\n          // Any integer is acceptable.\n          maxValue = (uint64_t)kj::maxValue;\n          break;\n\n        default: break;\n      }\n      if (maxValue == 0) break;\n\n      if (result.getReader().as<uint64_t>() > maxValue) {\n        errorReporter.addErrorOn(src, \"Integer value out of range.\");\n        result = maxValue;\n      }\n      return kj::mv(result);\n    }\n\n    case DynamicValue::FLOAT:\n      if (type.isFloat32() || type.isFloat64()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::TEXT:\n      if (type.isText()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::DATA:\n      if (type.isData()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::LIST:\n      if (type.isList()) {\n        if (result.getReader().as<DynamicList>().getSchema() == type.asList()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::ENUM:\n      if (type.isEnum()) {\n        if (result.getReader().as<DynamicEnum>().getSchema() == type.asEnum()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::STRUCT:\n      if (type.isStruct()) {\n        if (result.getReader().as<DynamicStruct>().getSchema() == type.asStruct()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::CAPABILITY:\n      KJ_FAIL_ASSERT(\"Interfaces can't have literal values.\");\n\n    case DynamicValue::ANY_POINTER:\n      KJ_FAIL_ASSERT(\"AnyPointers can't have literal values.\");\n  }\n\n  errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n  return nullptr;\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "src",
            "kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\")"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Type mismatch; expected \"",
            "makeTypeName(type)",
            "\".\""
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeTypeName",
          "args": [
            "type"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "ValueTranslator::makeTypeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2852-2876",
          "snippet": "kj::String ValueTranslator::makeTypeName(Type type) {\n  switch (type.which()) {\n    case schema::Type::VOID: return kj::str(\"Void\");\n    case schema::Type::BOOL: return kj::str(\"Bool\");\n    case schema::Type::INT8: return kj::str(\"Int8\");\n    case schema::Type::INT16: return kj::str(\"Int16\");\n    case schema::Type::INT32: return kj::str(\"Int32\");\n    case schema::Type::INT64: return kj::str(\"Int64\");\n    case schema::Type::UINT8: return kj::str(\"UInt8\");\n    case schema::Type::UINT16: return kj::str(\"UInt16\");\n    case schema::Type::UINT32: return kj::str(\"UInt32\");\n    case schema::Type::UINT64: return kj::str(\"UInt64\");\n    case schema::Type::FLOAT32: return kj::str(\"Float32\");\n    case schema::Type::FLOAT64: return kj::str(\"Float64\");\n    case schema::Type::TEXT: return kj::str(\"Text\");\n    case schema::Type::DATA: return kj::str(\"Data\");\n    case schema::Type::LIST:\n      return kj::str(\"List(\", makeTypeName(type.asList().getElementType()), \")\");\n    case schema::Type::ENUM: return makeNodeName(type.asEnum());\n    case schema::Type::STRUCT: return makeNodeName(type.asStruct());\n    case schema::Type::INTERFACE: return makeNodeName(type.asInterface());\n    case schema::Type::ANY_POINTER: return kj::str(\"AnyPointer\");\n  }\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nkj::String ValueTranslator::makeTypeName(Type type) {\n  switch (type.which()) {\n    case schema::Type::VOID: return kj::str(\"Void\");\n    case schema::Type::BOOL: return kj::str(\"Bool\");\n    case schema::Type::INT8: return kj::str(\"Int8\");\n    case schema::Type::INT16: return kj::str(\"Int16\");\n    case schema::Type::INT32: return kj::str(\"Int32\");\n    case schema::Type::INT64: return kj::str(\"Int64\");\n    case schema::Type::UINT8: return kj::str(\"UInt8\");\n    case schema::Type::UINT16: return kj::str(\"UInt16\");\n    case schema::Type::UINT32: return kj::str(\"UInt32\");\n    case schema::Type::UINT64: return kj::str(\"UInt64\");\n    case schema::Type::FLOAT32: return kj::str(\"Float32\");\n    case schema::Type::FLOAT64: return kj::str(\"Float64\");\n    case schema::Type::TEXT: return kj::str(\"Text\");\n    case schema::Type::DATA: return kj::str(\"Data\");\n    case schema::Type::LIST:\n      return kj::str(\"List(\", makeTypeName(type.asList().getElementType()), \")\");\n    case schema::Type::ENUM: return makeNodeName(type.asEnum());\n    case schema::Type::STRUCT: return makeNodeName(type.asStruct());\n    case schema::Type::INTERFACE: return makeNodeName(type.asInterface());\n    case schema::Type::ANY_POINTER: return kj::str(\"AnyPointer\");\n  }\n  KJ_UNREACHABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"AnyPointers can't have literal values.\""
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Interfaces can't have literal values.\""
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asStruct",
          "args": [],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isStruct",
          "args": [],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "isStruct",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "142-144",
          "snippet": "inline bool isStruct() {\n      return builder.isStruct();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline bool isStruct() {\n          return builder.isStruct();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asEnum",
          "args": [],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isEnum",
          "args": [],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asList",
          "args": [],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isList",
          "args": [],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "isList",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "145-147",
          "snippet": "inline bool isList() {\n      return builder.isList();\n    }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline bool isList() {\n          return builder.isList();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isData",
          "args": [],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isText",
          "args": [],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isFloat64",
          "args": [],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isFloat32",
          "args": [],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getReader",
          "args": [],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isBool",
          "args": [],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.isVoid",
          "args": [],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getType",
          "args": [],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "compileValueInner",
          "args": [
            "src",
            "type"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nkj::Maybe<Orphan<DynamicValue>> ValueTranslator::compileValue(Expression::Reader src, Type type) {\n  Orphan<DynamicValue> result = compileValueInner(src, type);\n\n  switch (result.getType()) {\n    case DynamicValue::UNKNOWN:\n      // Error already reported.\n      return nullptr;\n\n    case DynamicValue::VOID:\n      if (type.isVoid()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::BOOL:\n      if (type.isBool()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::INT: {\n      int64_t value = result.getReader().as<int64_t>();\n      if (value < 0) {\n        int64_t minValue = 1;\n        switch (type.which()) {\n          case schema::Type::INT8: minValue = (int8_t)kj::minValue; break;\n          case schema::Type::INT16: minValue = (int16_t)kj::minValue; break;\n          case schema::Type::INT32: minValue = (int32_t)kj::minValue; break;\n          case schema::Type::INT64: minValue = (int64_t)kj::minValue; break;\n          case schema::Type::UINT8: minValue = (uint8_t)kj::minValue; break;\n          case schema::Type::UINT16: minValue = (uint16_t)kj::minValue; break;\n          case schema::Type::UINT32: minValue = (uint32_t)kj::minValue; break;\n          case schema::Type::UINT64: minValue = (uint64_t)kj::minValue; break;\n\n          case schema::Type::FLOAT32:\n          case schema::Type::FLOAT64:\n            // Any integer is acceptable.\n            minValue = (int64_t)kj::minValue;\n            break;\n\n          default: break;\n        }\n        if (minValue == 1) break;\n\n        if (value < minValue) {\n          errorReporter.addErrorOn(src, \"Integer value out of range.\");\n          result = minValue;\n        }\n        return kj::mv(result);\n      }\n\n      // No break -- value is positive, so we can just go on to the uint case below.\n    }\n\n    case DynamicValue::UINT: {\n      uint64_t maxValue = 0;\n      switch (type.which()) {\n        case schema::Type::INT8: maxValue = (int8_t)kj::maxValue; break;\n        case schema::Type::INT16: maxValue = (int16_t)kj::maxValue; break;\n        case schema::Type::INT32: maxValue = (int32_t)kj::maxValue; break;\n        case schema::Type::INT64: maxValue = (int64_t)kj::maxValue; break;\n        case schema::Type::UINT8: maxValue = (uint8_t)kj::maxValue; break;\n        case schema::Type::UINT16: maxValue = (uint16_t)kj::maxValue; break;\n        case schema::Type::UINT32: maxValue = (uint32_t)kj::maxValue; break;\n        case schema::Type::UINT64: maxValue = (uint64_t)kj::maxValue; break;\n\n        case schema::Type::FLOAT32:\n        case schema::Type::FLOAT64:\n          // Any integer is acceptable.\n          maxValue = (uint64_t)kj::maxValue;\n          break;\n\n        default: break;\n      }\n      if (maxValue == 0) break;\n\n      if (result.getReader().as<uint64_t>() > maxValue) {\n        errorReporter.addErrorOn(src, \"Integer value out of range.\");\n        result = maxValue;\n      }\n      return kj::mv(result);\n    }\n\n    case DynamicValue::FLOAT:\n      if (type.isFloat32() || type.isFloat64()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::TEXT:\n      if (type.isText()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::DATA:\n      if (type.isData()) {\n        return kj::mv(result);\n      }\n      break;\n\n    case DynamicValue::LIST:\n      if (type.isList()) {\n        if (result.getReader().as<DynamicList>().getSchema() == type.asList()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::ENUM:\n      if (type.isEnum()) {\n        if (result.getReader().as<DynamicEnum>().getSchema() == type.asEnum()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::STRUCT:\n      if (type.isStruct()) {\n        if (result.getReader().as<DynamicStruct>().getSchema() == type.asStruct()) {\n          return kj::mv(result);\n        }\n      }\n      break;\n\n    case DynamicValue::CAPABILITY:\n      KJ_FAIL_ASSERT(\"Interfaces can't have literal values.\");\n\n    case DynamicValue::ANY_POINTER:\n      KJ_FAIL_ASSERT(\"AnyPointers can't have literal values.\");\n  }\n\n  errorReporter.addErrorOn(src, kj::str(\"Type mismatch; expected \", makeTypeName(type), \".\"));\n  return nullptr;\n}"
  },
  {
    "function_name": "NodeTranslator::compileValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2528-2560",
    "snippet": "void NodeTranslator::compileValue(Expression::Reader source, schema::Type::Reader type,\n                                  Schema typeScope, schema::Value::Builder target,\n                                  bool isBootstrap) {\n  class ResolverGlue: public ValueTranslator::Resolver {\n  public:\n    inline ResolverGlue(NodeTranslator& translator, bool isBootstrap)\n        : translator(translator), isBootstrap(isBootstrap) {}\n\n    kj::Maybe<DynamicValue::Reader> resolveConstant(Expression::Reader name) override {\n      return translator.readConstant(name, isBootstrap);\n    }\n\n  private:\n    NodeTranslator& translator;\n    bool isBootstrap;\n  };\n\n  ResolverGlue glue(*this, isBootstrap);\n  ValueTranslator valueTranslator(glue, errorReporter, orphanage);\n\n  KJ_IF_MAYBE(typeSchema, resolver.resolveBootstrapType(type, typeScope)) {\n    kj::StringPtr fieldName = Schema::from<schema::Type>()\n        .getUnionFields()[static_cast<uint>(typeSchema->which())].getProto().getName();\n\n    KJ_IF_MAYBE(value, valueTranslator.compileValue(source, *typeSchema)) {\n      if (typeSchema->isEnum()) {\n        target.setEnum(value->getReader().as<DynamicEnum>().getRaw());\n      } else {\n        toDynamic(target).adopt(fieldName, kj::mv(*value));\n      }\n    }\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "toDynamic",
          "args": [
            "fieldName",
            "kj::mv(*value)"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*value"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toDynamic",
          "args": [
            "target"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "toDynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "1246-1248",
          "snippet": "typename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ntypename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "target.setEnum",
          "args": [
            "value->getReader().as<DynamicEnum>().getRaw()"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->getReader",
          "args": [],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->getReader",
          "args": [],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value->getReader",
          "args": [],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeSchema->isEnum",
          "args": [],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "value",
            "valueTranslator.compileValue(source, *typeSchema)"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "valueTranslator.compileValue",
          "args": [
            "source",
            "*typeSchema"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Schema::from<schema::Type>",
          "args": [],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "fromImpl",
          "container": "InterfaceSchema",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "466-468",
          "snippet": "static inline InterfaceSchema fromImpl() {\n    return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n  }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\nInterfaceSchema {\n  static inline InterfaceSchema fromImpl() {\n      return InterfaceSchema(Schema(&_::rawBrandedSchema<T>()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint>",
          "args": [
            "typeSchema->which()"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeSchema->which",
          "args": [],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveBootstrapType",
          "args": [
            "type",
            "typeScope"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "translator.readConstant",
          "args": [
            "name",
            "isBootstrap"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid NodeTranslator::compileValue(Expression::Reader source, schema::Type::Reader type,\n                                  Schema typeScope, schema::Value::Builder target,\n                                  bool isBootstrap) {\n  class ResolverGlue: public ValueTranslator::Resolver {\n  public:\n    inline ResolverGlue(NodeTranslator& translator, bool isBootstrap)\n        : translator(translator), isBootstrap(isBootstrap) {}\n\n    kj::Maybe<DynamicValue::Reader> resolveConstant(Expression::Reader name) override {\n      return translator.readConstant(name, isBootstrap);\n    }\n\n  private:\n    NodeTranslator& translator;\n    bool isBootstrap;\n  };\n\n  ResolverGlue glue(*this, isBootstrap);\n  ValueTranslator valueTranslator(glue, errorReporter, orphanage);\n\n  KJ_IF_MAYBE(typeSchema, resolver.resolveBootstrapType(type, typeScope)) {\n    kj::StringPtr fieldName = Schema::from<schema::Type>()\n        .getUnionFields()[static_cast<uint>(typeSchema->which())].getProto().getName();\n\n    KJ_IF_MAYBE(value, valueTranslator.compileValue(source, *typeSchema)) {\n      if (typeSchema->isEnum()) {\n        target.setEnum(value->getReader().as<DynamicEnum>().getRaw());\n      } else {\n        toDynamic(target).adopt(fieldName, kj::mv(*value));\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::compileBootstrapValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2506-2526",
    "snippet": "void NodeTranslator::compileBootstrapValue(\n    Expression::Reader source, schema::Type::Reader type, schema::Value::Builder target,\n    Schema typeScope) {\n  // Start by filling in a default default value so that if for whatever reason we don't end up\n  // initializing the value, this won't cause schema validation to fail.\n  compileDefaultDefaultValue(type, target);\n\n  switch (type.which()) {\n    case schema::Type::LIST:\n    case schema::Type::STRUCT:\n    case schema::Type::INTERFACE:\n    case schema::Type::ANY_POINTER:\n      unfinishedValues.add(UnfinishedValue { source, type, typeScope, target });\n      break;\n\n    default:\n      // Primitive value.\n      compileValue(source, type, typeScope, target, true);\n      break;\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "compileValue",
          "args": [
            "source",
            "type",
            "typeScope",
            "target",
            "true"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unfinishedValues.add",
          "args": [
            "UnfinishedValue { source, type, typeScope, target }"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileDefaultDefaultValue",
          "args": [
            "type",
            "target"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::compileDefaultDefaultValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2478-2504",
          "snippet": "void NodeTranslator::compileDefaultDefaultValue(\n    schema::Type::Reader type, schema::Value::Builder target) {\n  switch (type.which()) {\n    case schema::Type::VOID: target.setVoid(); break;\n    case schema::Type::BOOL: target.setBool(false); break;\n    case schema::Type::INT8: target.setInt8(0); break;\n    case schema::Type::INT16: target.setInt16(0); break;\n    case schema::Type::INT32: target.setInt32(0); break;\n    case schema::Type::INT64: target.setInt64(0); break;\n    case schema::Type::UINT8: target.setUint8(0); break;\n    case schema::Type::UINT16: target.setUint16(0); break;\n    case schema::Type::UINT32: target.setUint32(0); break;\n    case schema::Type::UINT64: target.setUint64(0); break;\n    case schema::Type::FLOAT32: target.setFloat32(0); break;\n    case schema::Type::FLOAT64: target.setFloat64(0); break;\n    case schema::Type::ENUM: target.setEnum(0); break;\n    case schema::Type::INTERFACE: target.setInterface(); break;\n\n    // Bit of a hack:  For Text/Data, we adopt a null orphan, which sets the field to null.\n    // TODO(cleanup):  Create a cleaner way to do this.\n    case schema::Type::TEXT: target.adoptText(Orphan<Text>()); break;\n    case schema::Type::DATA: target.adoptData(Orphan<Data>()); break;\n    case schema::Type::STRUCT: target.initStruct(); break;\n    case schema::Type::LIST: target.initList(); break;\n    case schema::Type::ANY_POINTER: target.initAnyPointer(); break;\n  }\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nvoid NodeTranslator::compileDefaultDefaultValue(\n    schema::Type::Reader type, schema::Value::Builder target) {\n  switch (type.which()) {\n    case schema::Type::VOID: target.setVoid(); break;\n    case schema::Type::BOOL: target.setBool(false); break;\n    case schema::Type::INT8: target.setInt8(0); break;\n    case schema::Type::INT16: target.setInt16(0); break;\n    case schema::Type::INT32: target.setInt32(0); break;\n    case schema::Type::INT64: target.setInt64(0); break;\n    case schema::Type::UINT8: target.setUint8(0); break;\n    case schema::Type::UINT16: target.setUint16(0); break;\n    case schema::Type::UINT32: target.setUint32(0); break;\n    case schema::Type::UINT64: target.setUint64(0); break;\n    case schema::Type::FLOAT32: target.setFloat32(0); break;\n    case schema::Type::FLOAT64: target.setFloat64(0); break;\n    case schema::Type::ENUM: target.setEnum(0); break;\n    case schema::Type::INTERFACE: target.setInterface(); break;\n\n    // Bit of a hack:  For Text/Data, we adopt a null orphan, which sets the field to null.\n    // TODO(cleanup):  Create a cleaner way to do this.\n    case schema::Type::TEXT: target.adoptText(Orphan<Text>()); break;\n    case schema::Type::DATA: target.adoptData(Orphan<Data>()); break;\n    case schema::Type::STRUCT: target.initStruct(); break;\n    case schema::Type::LIST: target.initList(); break;\n    case schema::Type::ANY_POINTER: target.initAnyPointer(); break;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nvoid NodeTranslator::compileBootstrapValue(\n    Expression::Reader source, schema::Type::Reader type, schema::Value::Builder target,\n    Schema typeScope) {\n  // Start by filling in a default default value so that if for whatever reason we don't end up\n  // initializing the value, this won't cause schema validation to fail.\n  compileDefaultDefaultValue(type, target);\n\n  switch (type.which()) {\n    case schema::Type::LIST:\n    case schema::Type::STRUCT:\n    case schema::Type::INTERFACE:\n    case schema::Type::ANY_POINTER:\n      unfinishedValues.add(UnfinishedValue { source, type, typeScope, target });\n      break;\n\n    default:\n      // Primitive value.\n      compileValue(source, type, typeScope, target, true);\n      break;\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::compileDefaultDefaultValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2478-2504",
    "snippet": "void NodeTranslator::compileDefaultDefaultValue(\n    schema::Type::Reader type, schema::Value::Builder target) {\n  switch (type.which()) {\n    case schema::Type::VOID: target.setVoid(); break;\n    case schema::Type::BOOL: target.setBool(false); break;\n    case schema::Type::INT8: target.setInt8(0); break;\n    case schema::Type::INT16: target.setInt16(0); break;\n    case schema::Type::INT32: target.setInt32(0); break;\n    case schema::Type::INT64: target.setInt64(0); break;\n    case schema::Type::UINT8: target.setUint8(0); break;\n    case schema::Type::UINT16: target.setUint16(0); break;\n    case schema::Type::UINT32: target.setUint32(0); break;\n    case schema::Type::UINT64: target.setUint64(0); break;\n    case schema::Type::FLOAT32: target.setFloat32(0); break;\n    case schema::Type::FLOAT64: target.setFloat64(0); break;\n    case schema::Type::ENUM: target.setEnum(0); break;\n    case schema::Type::INTERFACE: target.setInterface(); break;\n\n    // Bit of a hack:  For Text/Data, we adopt a null orphan, which sets the field to null.\n    // TODO(cleanup):  Create a cleaner way to do this.\n    case schema::Type::TEXT: target.adoptText(Orphan<Text>()); break;\n    case schema::Type::DATA: target.adoptData(Orphan<Data>()); break;\n    case schema::Type::STRUCT: target.initStruct(); break;\n    case schema::Type::LIST: target.initList(); break;\n    case schema::Type::ANY_POINTER: target.initAnyPointer(); break;\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initList",
          "args": [],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initStruct",
          "args": [],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.adoptData",
          "args": [
            "Orphan<Data>()"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Orphan<Data>",
          "args": [],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "OrphanBuilder",
          "container": "OrphanBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.h",
          "lines": "709-709",
          "snippet": "inline OrphanBuilder(): segment(nullptr), location(nullptr) { memset(&tag, 0, sizeof(tag)); }",
          "includes": [
            "#include \"endian.h\"",
            "#include \"blob.h\"",
            "#include \"common.h\"",
            "#include <kj/memory.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"endian.h\"\n#include \"blob.h\"\n#include \"common.h\"\n#include <kj/memory.h>\n#include <kj/common.h>\n\nOrphanBuilder {\n  inline OrphanBuilder(): segment(nullptr), location(nullptr) { memset(&tag, 0, sizeof(tag)); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "target.adoptText",
          "args": [
            "Orphan<Text>()"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInterface",
          "args": [],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setEnum",
          "args": [
            "0"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setFloat64",
          "args": [
            "0"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setFloat32",
          "args": [
            "0"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setUint64",
          "args": [
            "0"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setUint32",
          "args": [
            "0"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setUint16",
          "args": [
            "0"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setUint8",
          "args": [
            "0"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInt64",
          "args": [
            "0"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInt32",
          "args": [
            "0"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInt16",
          "args": [
            "0"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInt8",
          "args": [
            "0"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setBool",
          "args": [
            "false"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setVoid",
          "args": [],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nvoid NodeTranslator::compileDefaultDefaultValue(\n    schema::Type::Reader type, schema::Value::Builder target) {\n  switch (type.which()) {\n    case schema::Type::VOID: target.setVoid(); break;\n    case schema::Type::BOOL: target.setBool(false); break;\n    case schema::Type::INT8: target.setInt8(0); break;\n    case schema::Type::INT16: target.setInt16(0); break;\n    case schema::Type::INT32: target.setInt32(0); break;\n    case schema::Type::INT64: target.setInt64(0); break;\n    case schema::Type::UINT8: target.setUint8(0); break;\n    case schema::Type::UINT16: target.setUint16(0); break;\n    case schema::Type::UINT32: target.setUint32(0); break;\n    case schema::Type::UINT64: target.setUint64(0); break;\n    case schema::Type::FLOAT32: target.setFloat32(0); break;\n    case schema::Type::FLOAT64: target.setFloat64(0); break;\n    case schema::Type::ENUM: target.setEnum(0); break;\n    case schema::Type::INTERFACE: target.setInterface(); break;\n\n    // Bit of a hack:  For Text/Data, we adopt a null orphan, which sets the field to null.\n    // TODO(cleanup):  Create a cleaner way to do this.\n    case schema::Type::TEXT: target.adoptText(Orphan<Text>()); break;\n    case schema::Type::DATA: target.adoptData(Orphan<Data>()); break;\n    case schema::Type::STRUCT: target.initStruct(); break;\n    case schema::Type::LIST: target.initList(); break;\n    case schema::Type::ANY_POINTER: target.initAnyPointer(); break;\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::compileType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2467-2474",
    "snippet": "bool NodeTranslator::compileType(Expression::Reader source, schema::Type::Builder target,\n                                 ImplicitParams implicitMethodParams) {\n  KJ_IF_MAYBE(decl, compileDeclExpression(source, implicitMethodParams)) {\n    return decl->compileAsType(errorReporter, target);\n  } else {\n    return false;\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);",
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "decl->compileAsType",
          "args": [
            "errorReporter",
            "target"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nbool NodeTranslator::compileType(Expression::Reader source, schema::Type::Builder target,\n                                 ImplicitParams implicitMethodParams) {\n  KJ_IF_MAYBE(decl, compileDeclExpression(source, implicitMethodParams)) {\n    return decl->compileAsType(errorReporter, target);\n  } else {\n    return false;\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::compileDecl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2456-2465",
    "snippet": "kj::Maybe<NodeTranslator::Resolver::ResolveResult> NodeTranslator::compileDecl(\n    uint64_t scopeId, uint scopeParameterCount, Resolver& resolver, ErrorReporter& errorReporter,\n    Expression::Reader expression, schema::Brand::Builder brandBuilder) {\n  auto scope = kj::refcounted<BrandScope>(errorReporter, scopeId, scopeParameterCount, resolver);\n  KJ_IF_MAYBE(decl, scope->compileDeclExpression(expression, resolver, noImplicitParams())) {\n    return decl->asResolveResult(scope->getScopeId(), brandBuilder);\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "decl->asResolveResult",
          "args": [
            "scope->getScopeId()",
            "brandBuilder"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scope->getScopeId",
          "args": [],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "decl",
            "scope->compileDeclExpression(expression, resolver, noImplicitParams())"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "scope->compileDeclExpression",
          "args": [
            "expression",
            "resolver",
            "noImplicitParams()"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "noImplicitParams",
          "args": [],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "noImplicitParams",
          "container": "NodeTranslator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.h",
          "lines": "225-227",
          "snippet": "static inline ImplicitParams noImplicitParams() {\n    return { 0, List<Declaration::BrandParameter>::Reader() };\n  }",
          "includes": [
            "#include \"error-reporter.h\"",
            "#include <kj/one-of.h>",
            "#include <kj/vector.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/orphan.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error-reporter.h\"\n#include <kj/one-of.h>\n#include <kj/vector.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/orphan.h>\n\nNodeTranslator {\n  static inline ImplicitParams noImplicitParams() {\n      return { 0, List<Declaration::BrandParameter>::Reader() };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<BrandScope>",
          "args": [
            "errorReporter",
            "scopeId",
            "scopeParameterCount",
            "resolver"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nkj::Maybe<NodeTranslator::Resolver::ResolveResult> NodeTranslator::compileDecl(\n    uint64_t scopeId, uint scopeParameterCount, Resolver& resolver, ErrorReporter& errorReporter,\n    Expression::Reader expression, schema::Brand::Builder brandBuilder) {\n  auto scope = kj::refcounted<BrandScope>(errorReporter, scopeId, scopeParameterCount, resolver);\n  KJ_IF_MAYBE(decl, scope->compileDeclExpression(expression, resolver, noImplicitParams())) {\n    return decl->asResolveResult(scope->getScopeId(), brandBuilder);\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::compileDeclExpression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2450-2454",
    "snippet": "kj::Maybe<NodeTranslator::BrandedDecl>\nNodeTranslator::compileDeclExpression(\n    Expression::Reader source, ImplicitParams implicitMethodParams) {\n  return localBrand->compileDeclExpression(source, resolver, implicitMethodParams);\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);",
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "localBrand->compileDeclExpression",
          "args": [
            "source",
            "resolver",
            "implicitMethodParams"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\nkj::Maybe<NodeTranslator::BrandedDecl>\nNodeTranslator::compileDeclExpression(\n    Expression::Reader source, ImplicitParams implicitMethodParams) {\n  return localBrand->compileDeclExpression(source, resolver, implicitMethodParams);\n}"
  },
  {
    "function_name": "expressionString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2444-2446",
    "snippet": "static kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "expressionStringTree",
          "args": [],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expressionStringTree",
          "args": [
            "name"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "expressionStringTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2395-2442",
          "snippet": "static kj::StringTree expressionStringTree(Expression::Reader exp) {\n  switch (exp.which()) {\n    case Expression::UNKNOWN:\n      return kj::strTree(\"<parse error>\");\n    case Expression::POSITIVE_INT:\n      return kj::strTree(exp.getPositiveInt());\n    case Expression::NEGATIVE_INT:\n      return kj::strTree('-', exp.getNegativeInt());\n    case Expression::FLOAT:\n      return kj::strTree(exp.getFloat());\n    case Expression::STRING:\n      return stringLiteral(exp.getString());\n    case Expression::BINARY:\n      return binaryLiteral(exp.getBinary());\n    case Expression::RELATIVE_NAME:\n      return kj::strTree(exp.getRelativeName().getValue());\n    case Expression::ABSOLUTE_NAME:\n      return kj::strTree('.', exp.getAbsoluteName().getValue());\n    case Expression::IMPORT:\n      return kj::strTree(\"import \", stringLiteral(exp.getImport().getValue()));\n\n    case Expression::LIST: {\n      auto list = exp.getList();\n      auto parts = kj::heapArrayBuilder<kj::StringTree>(list.size());\n      for (auto element: list) {\n        parts.add(expressionStringTree(element));\n      }\n      return kj::strTree(\"[ \", kj::StringTree(parts.finish(), \", \"), \" ]\");\n    }\n\n    case Expression::TUPLE:\n      return tupleLiteral(exp.getTuple());\n\n    case Expression::APPLICATION: {\n      auto app = exp.getApplication();\n      return kj::strTree(expressionStringTree(app.getFunction()),\n                         '(', tupleLiteral(app.getParams()), ')');\n    }\n\n    case Expression::MEMBER: {\n      auto member = exp.getMember();\n      return kj::strTree(expressionStringTree(member.getParent()), '.',\n                         member.getName().getValue());\n    }\n  }\n\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto list = interfaceBuilder.initMethods(methods.size());",
            "static kj::StringTree expressionStringTree(Expression::Reader exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nauto list = interfaceBuilder.initMethods(methods.size());\nstatic kj::StringTree expressionStringTree(Expression::Reader exp);\n\nstatic kj::StringTree expressionStringTree(Expression::Reader exp) {\n  switch (exp.which()) {\n    case Expression::UNKNOWN:\n      return kj::strTree(\"<parse error>\");\n    case Expression::POSITIVE_INT:\n      return kj::strTree(exp.getPositiveInt());\n    case Expression::NEGATIVE_INT:\n      return kj::strTree('-', exp.getNegativeInt());\n    case Expression::FLOAT:\n      return kj::strTree(exp.getFloat());\n    case Expression::STRING:\n      return stringLiteral(exp.getString());\n    case Expression::BINARY:\n      return binaryLiteral(exp.getBinary());\n    case Expression::RELATIVE_NAME:\n      return kj::strTree(exp.getRelativeName().getValue());\n    case Expression::ABSOLUTE_NAME:\n      return kj::strTree('.', exp.getAbsoluteName().getValue());\n    case Expression::IMPORT:\n      return kj::strTree(\"import \", stringLiteral(exp.getImport().getValue()));\n\n    case Expression::LIST: {\n      auto list = exp.getList();\n      auto parts = kj::heapArrayBuilder<kj::StringTree>(list.size());\n      for (auto element: list) {\n        parts.add(expressionStringTree(element));\n      }\n      return kj::strTree(\"[ \", kj::StringTree(parts.finish(), \", \"), \" ]\");\n    }\n\n    case Expression::TUPLE:\n      return tupleLiteral(exp.getTuple());\n\n    case Expression::APPLICATION: {\n      auto app = exp.getApplication();\n      return kj::strTree(expressionStringTree(app.getFunction()),\n                         '(', tupleLiteral(app.getParams()), ')');\n    }\n\n    case Expression::MEMBER: {\n      auto member = exp.getMember();\n      return kj::strTree(expressionStringTree(member.getParent()), '.',\n                         member.getName().getValue());\n    }\n  }\n\n  KJ_UNREACHABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\n\nstatic kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}"
  },
  {
    "function_name": "expressionStringTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2395-2442",
    "snippet": "static kj::StringTree expressionStringTree(Expression::Reader exp) {\n  switch (exp.which()) {\n    case Expression::UNKNOWN:\n      return kj::strTree(\"<parse error>\");\n    case Expression::POSITIVE_INT:\n      return kj::strTree(exp.getPositiveInt());\n    case Expression::NEGATIVE_INT:\n      return kj::strTree('-', exp.getNegativeInt());\n    case Expression::FLOAT:\n      return kj::strTree(exp.getFloat());\n    case Expression::STRING:\n      return stringLiteral(exp.getString());\n    case Expression::BINARY:\n      return binaryLiteral(exp.getBinary());\n    case Expression::RELATIVE_NAME:\n      return kj::strTree(exp.getRelativeName().getValue());\n    case Expression::ABSOLUTE_NAME:\n      return kj::strTree('.', exp.getAbsoluteName().getValue());\n    case Expression::IMPORT:\n      return kj::strTree(\"import \", stringLiteral(exp.getImport().getValue()));\n\n    case Expression::LIST: {\n      auto list = exp.getList();\n      auto parts = kj::heapArrayBuilder<kj::StringTree>(list.size());\n      for (auto element: list) {\n        parts.add(expressionStringTree(element));\n      }\n      return kj::strTree(\"[ \", kj::StringTree(parts.finish(), \", \"), \" ]\");\n    }\n\n    case Expression::TUPLE:\n      return tupleLiteral(exp.getTuple());\n\n    case Expression::APPLICATION: {\n      auto app = exp.getApplication();\n      return kj::strTree(expressionStringTree(app.getFunction()),\n                         '(', tupleLiteral(app.getParams()), ')');\n    }\n\n    case Expression::MEMBER: {\n      auto member = exp.getMember();\n      return kj::strTree(expressionStringTree(member.getParent()), '.',\n                         member.getName().getValue());\n    }\n  }\n\n  KJ_UNREACHABLE;\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "auto list = interfaceBuilder.initMethods(methods.size());",
      "static kj::StringTree expressionStringTree(Expression::Reader exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "expressionStringTree(member.getParent())",
            "'.'",
            "member.getName().getValue()"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getParent",
          "args": [],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getMember",
          "args": [],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "expressionStringTree(app.getFunction())",
            "'('",
            "tupleLiteral(app.getParams())",
            "')'"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tupleLiteral",
          "args": [
            "app.getParams()"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "tupleLiteral",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2383-2393",
          "snippet": "static kj::StringTree tupleLiteral(List<Expression::Param>::Reader params) {\n  auto parts = kj::heapArrayBuilder<kj::StringTree>(params.size());\n  for (auto param: params) {\n    auto part = expressionStringTree(param.getValue());\n    if (param.isNamed()) {\n      part = kj::strTree(param.getNamed().getValue(), \" = \", kj::mv(part));\n    }\n    parts.add(kj::mv(part));\n  }\n  return kj::strTree(\"( \", kj::StringTree(parts.finish(), \", \"), \" )\");\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Array<BrandedDecl> params;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Array<BrandedDecl> params;\n\nstatic kj::StringTree tupleLiteral(List<Expression::Param>::Reader params) {\n  auto parts = kj::heapArrayBuilder<kj::StringTree>(params.size());\n  for (auto param: params) {\n    auto part = expressionStringTree(param.getValue());\n    if (param.isNamed()) {\n      part = kj::strTree(param.getNamed().getValue(), \" = \", kj::mv(part));\n    }\n    parts.add(kj::mv(part));\n  }\n  return kj::strTree(\"( \", kj::StringTree(parts.finish(), \", \"), \" )\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "app.getParams",
          "args": [],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "app.getFunction",
          "args": [],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getApplication",
          "args": [],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getTuple",
          "args": [],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"[ \"",
            "kj::StringTree(parts.finish(), \", \")",
            "\" ]\""
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "parts.finish()",
            "\", \""
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.finish",
          "args": [],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parts.add",
          "args": [
            "expressionStringTree(element)"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<kj::StringTree>",
          "args": [
            "list.size()"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list.size",
          "args": [],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp.getList",
          "args": [],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"import \"",
            "stringLiteral(exp.getImport().getValue())"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringLiteral",
          "args": [
            "exp.getImport().getValue()"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "stringLiteral",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2335-2366",
          "snippet": "static kj::StringTree stringLiteral(kj::StringPtr chars) {\n  // TODO(cleanup): This code keeps coming up. Put somewhere common?\n\n  kj::Vector<char> escaped(chars.size());\n\n  for (char c: chars) {\n    switch (c) {\n      case '\\a': escaped.addAll(kj::StringPtr(\"\\\\a\")); break;\n      case '\\b': escaped.addAll(kj::StringPtr(\"\\\\b\")); break;\n      case '\\f': escaped.addAll(kj::StringPtr(\"\\\\f\")); break;\n      case '\\n': escaped.addAll(kj::StringPtr(\"\\\\n\")); break;\n      case '\\r': escaped.addAll(kj::StringPtr(\"\\\\r\")); break;\n      case '\\t': escaped.addAll(kj::StringPtr(\"\\\\t\")); break;\n      case '\\v': escaped.addAll(kj::StringPtr(\"\\\\v\")); break;\n      case '\\'': escaped.addAll(kj::StringPtr(\"\\\\\\'\")); break;\n      case '\\\"': escaped.addAll(kj::StringPtr(\"\\\\\\\"\")); break;\n      case '\\\\': escaped.addAll(kj::StringPtr(\"\\\\\\\\\")); break;\n      default:\n        if (c < 0x20) {\n          escaped.add('\\\\');\n          escaped.add('x');\n          uint8_t c2 = c;\n          escaped.add(HEXDIGITS[c2 / 16]);\n          escaped.add(HEXDIGITS[c2 % 16]);\n        } else {\n          escaped.add(c);\n        }\n        break;\n    }\n  }\n  return kj::strTree('\"', escaped, '\"');\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char HEXDIGITS[] = \"0123456789abcdef\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic const char HEXDIGITS[] = \"0123456789abcdef\";\n\nstatic kj::StringTree stringLiteral(kj::StringPtr chars) {\n  // TODO(cleanup): This code keeps coming up. Put somewhere common?\n\n  kj::Vector<char> escaped(chars.size());\n\n  for (char c: chars) {\n    switch (c) {\n      case '\\a': escaped.addAll(kj::StringPtr(\"\\\\a\")); break;\n      case '\\b': escaped.addAll(kj::StringPtr(\"\\\\b\")); break;\n      case '\\f': escaped.addAll(kj::StringPtr(\"\\\\f\")); break;\n      case '\\n': escaped.addAll(kj::StringPtr(\"\\\\n\")); break;\n      case '\\r': escaped.addAll(kj::StringPtr(\"\\\\r\")); break;\n      case '\\t': escaped.addAll(kj::StringPtr(\"\\\\t\")); break;\n      case '\\v': escaped.addAll(kj::StringPtr(\"\\\\v\")); break;\n      case '\\'': escaped.addAll(kj::StringPtr(\"\\\\\\'\")); break;\n      case '\\\"': escaped.addAll(kj::StringPtr(\"\\\\\\\"\")); break;\n      case '\\\\': escaped.addAll(kj::StringPtr(\"\\\\\\\\\")); break;\n      default:\n        if (c < 0x20) {\n          escaped.add('\\\\');\n          escaped.add('x');\n          uint8_t c2 = c;\n          escaped.add(HEXDIGITS[c2 / 16]);\n          escaped.add(HEXDIGITS[c2 % 16]);\n        } else {\n          escaped.add(c);\n        }\n        break;\n    }\n  }\n  return kj::strTree('\"', escaped, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp.getImport",
          "args": [],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getImport",
          "args": [],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "'.'",
            "exp.getAbsoluteName().getValue()"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getAbsoluteName",
          "args": [],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getAbsoluteName",
          "args": [],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "exp.getRelativeName().getValue()"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRelativeName",
          "args": [],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRelativeName",
          "args": [],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binaryLiteral",
          "args": [
            "exp.getBinary()"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "binaryLiteral",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2368-2379",
          "snippet": "static kj::StringTree binaryLiteral(Data::Reader data) {\n  kj::Vector<char> escaped(data.size() * 3);\n\n  for (byte b: data) {\n    escaped.add(HEXDIGITS[b % 16]);\n    escaped.add(HEXDIGITS[b / 16]);\n    escaped.add(' ');\n  }\n\n  escaped.removeLast();\n  return kj::strTree(\"0x\\\"\", escaped, '\"');\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char HEXDIGITS[] = \"0123456789abcdef\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic const char HEXDIGITS[] = \"0123456789abcdef\";\n\nstatic kj::StringTree binaryLiteral(Data::Reader data) {\n  kj::Vector<char> escaped(data.size() * 3);\n\n  for (byte b: data) {\n    escaped.add(HEXDIGITS[b % 16]);\n    escaped.add(HEXDIGITS[b / 16]);\n    escaped.add(' ');\n  }\n\n  escaped.removeLast();\n  return kj::strTree(\"0x\\\"\", escaped, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp.getBinary",
          "args": [],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getString",
          "args": [],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "exp.getFloat()"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getFloat",
          "args": [],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "'-'",
            "exp.getNegativeInt()"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getNegativeInt",
          "args": [],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "exp.getPositiveInt()"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getPositiveInt",
          "args": [],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"<parse error>\""
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.which",
          "args": [],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nauto list = interfaceBuilder.initMethods(methods.size());\nstatic kj::StringTree expressionStringTree(Expression::Reader exp);\n\nstatic kj::StringTree expressionStringTree(Expression::Reader exp) {\n  switch (exp.which()) {\n    case Expression::UNKNOWN:\n      return kj::strTree(\"<parse error>\");\n    case Expression::POSITIVE_INT:\n      return kj::strTree(exp.getPositiveInt());\n    case Expression::NEGATIVE_INT:\n      return kj::strTree('-', exp.getNegativeInt());\n    case Expression::FLOAT:\n      return kj::strTree(exp.getFloat());\n    case Expression::STRING:\n      return stringLiteral(exp.getString());\n    case Expression::BINARY:\n      return binaryLiteral(exp.getBinary());\n    case Expression::RELATIVE_NAME:\n      return kj::strTree(exp.getRelativeName().getValue());\n    case Expression::ABSOLUTE_NAME:\n      return kj::strTree('.', exp.getAbsoluteName().getValue());\n    case Expression::IMPORT:\n      return kj::strTree(\"import \", stringLiteral(exp.getImport().getValue()));\n\n    case Expression::LIST: {\n      auto list = exp.getList();\n      auto parts = kj::heapArrayBuilder<kj::StringTree>(list.size());\n      for (auto element: list) {\n        parts.add(expressionStringTree(element));\n      }\n      return kj::strTree(\"[ \", kj::StringTree(parts.finish(), \", \"), \" ]\");\n    }\n\n    case Expression::TUPLE:\n      return tupleLiteral(exp.getTuple());\n\n    case Expression::APPLICATION: {\n      auto app = exp.getApplication();\n      return kj::strTree(expressionStringTree(app.getFunction()),\n                         '(', tupleLiteral(app.getParams()), ')');\n    }\n\n    case Expression::MEMBER: {\n      auto member = exp.getMember();\n      return kj::strTree(expressionStringTree(member.getParent()), '.',\n                         member.getName().getValue());\n    }\n  }\n\n  KJ_UNREACHABLE;\n}"
  },
  {
    "function_name": "tupleLiteral",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2383-2393",
    "snippet": "static kj::StringTree tupleLiteral(List<Expression::Param>::Reader params) {\n  auto parts = kj::heapArrayBuilder<kj::StringTree>(params.size());\n  for (auto param: params) {\n    auto part = expressionStringTree(param.getValue());\n    if (param.isNamed()) {\n      part = kj::strTree(param.getNamed().getValue(), \" = \", kj::mv(part));\n    }\n    parts.add(kj::mv(part));\n  }\n  return kj::strTree(\"( \", kj::StringTree(parts.finish(), \", \"), \" )\");\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Array<BrandedDecl> params;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"( \"",
            "kj::StringTree(parts.finish(), \", \")",
            "\" )\""
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "parts.finish()",
            "\", \""
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.finish",
          "args": [],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parts.add",
          "args": [
            "kj::mv(part)"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "part"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "param.getNamed().getValue()",
            "\" = \"",
            "kj::mv(part)"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "part"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getNamed",
          "args": [],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getNamed",
          "args": [],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.isNamed",
          "args": [],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expressionStringTree",
          "args": [
            "param.getValue()"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "expressionStringTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2395-2442",
          "snippet": "static kj::StringTree expressionStringTree(Expression::Reader exp) {\n  switch (exp.which()) {\n    case Expression::UNKNOWN:\n      return kj::strTree(\"<parse error>\");\n    case Expression::POSITIVE_INT:\n      return kj::strTree(exp.getPositiveInt());\n    case Expression::NEGATIVE_INT:\n      return kj::strTree('-', exp.getNegativeInt());\n    case Expression::FLOAT:\n      return kj::strTree(exp.getFloat());\n    case Expression::STRING:\n      return stringLiteral(exp.getString());\n    case Expression::BINARY:\n      return binaryLiteral(exp.getBinary());\n    case Expression::RELATIVE_NAME:\n      return kj::strTree(exp.getRelativeName().getValue());\n    case Expression::ABSOLUTE_NAME:\n      return kj::strTree('.', exp.getAbsoluteName().getValue());\n    case Expression::IMPORT:\n      return kj::strTree(\"import \", stringLiteral(exp.getImport().getValue()));\n\n    case Expression::LIST: {\n      auto list = exp.getList();\n      auto parts = kj::heapArrayBuilder<kj::StringTree>(list.size());\n      for (auto element: list) {\n        parts.add(expressionStringTree(element));\n      }\n      return kj::strTree(\"[ \", kj::StringTree(parts.finish(), \", \"), \" ]\");\n    }\n\n    case Expression::TUPLE:\n      return tupleLiteral(exp.getTuple());\n\n    case Expression::APPLICATION: {\n      auto app = exp.getApplication();\n      return kj::strTree(expressionStringTree(app.getFunction()),\n                         '(', tupleLiteral(app.getParams()), ')');\n    }\n\n    case Expression::MEMBER: {\n      auto member = exp.getMember();\n      return kj::strTree(expressionStringTree(member.getParent()), '.',\n                         member.getName().getValue());\n    }\n  }\n\n  KJ_UNREACHABLE;\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "auto list = interfaceBuilder.initMethods(methods.size());",
            "static kj::StringTree expressionStringTree(Expression::Reader exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nauto list = interfaceBuilder.initMethods(methods.size());\nstatic kj::StringTree expressionStringTree(Expression::Reader exp);\n\nstatic kj::StringTree expressionStringTree(Expression::Reader exp) {\n  switch (exp.which()) {\n    case Expression::UNKNOWN:\n      return kj::strTree(\"<parse error>\");\n    case Expression::POSITIVE_INT:\n      return kj::strTree(exp.getPositiveInt());\n    case Expression::NEGATIVE_INT:\n      return kj::strTree('-', exp.getNegativeInt());\n    case Expression::FLOAT:\n      return kj::strTree(exp.getFloat());\n    case Expression::STRING:\n      return stringLiteral(exp.getString());\n    case Expression::BINARY:\n      return binaryLiteral(exp.getBinary());\n    case Expression::RELATIVE_NAME:\n      return kj::strTree(exp.getRelativeName().getValue());\n    case Expression::ABSOLUTE_NAME:\n      return kj::strTree('.', exp.getAbsoluteName().getValue());\n    case Expression::IMPORT:\n      return kj::strTree(\"import \", stringLiteral(exp.getImport().getValue()));\n\n    case Expression::LIST: {\n      auto list = exp.getList();\n      auto parts = kj::heapArrayBuilder<kj::StringTree>(list.size());\n      for (auto element: list) {\n        parts.add(expressionStringTree(element));\n      }\n      return kj::strTree(\"[ \", kj::StringTree(parts.finish(), \", \"), \" ]\");\n    }\n\n    case Expression::TUPLE:\n      return tupleLiteral(exp.getTuple());\n\n    case Expression::APPLICATION: {\n      auto app = exp.getApplication();\n      return kj::strTree(expressionStringTree(app.getFunction()),\n                         '(', tupleLiteral(app.getParams()), ')');\n    }\n\n    case Expression::MEMBER: {\n      auto member = exp.getMember();\n      return kj::strTree(expressionStringTree(member.getParent()), '.',\n                         member.getName().getValue());\n    }\n  }\n\n  KJ_UNREACHABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "param.getValue",
          "args": [],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<kj::StringTree>",
          "args": [
            "params.size()"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Array<BrandedDecl> params;\n\nstatic kj::StringTree tupleLiteral(List<Expression::Param>::Reader params) {\n  auto parts = kj::heapArrayBuilder<kj::StringTree>(params.size());\n  for (auto param: params) {\n    auto part = expressionStringTree(param.getValue());\n    if (param.isNamed()) {\n      part = kj::strTree(param.getNamed().getValue(), \" = \", kj::mv(part));\n    }\n    parts.add(kj::mv(part));\n  }\n  return kj::strTree(\"( \", kj::StringTree(parts.finish(), \", \"), \" )\");\n}"
  },
  {
    "function_name": "binaryLiteral",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2368-2379",
    "snippet": "static kj::StringTree binaryLiteral(Data::Reader data) {\n  kj::Vector<char> escaped(data.size() * 3);\n\n  for (byte b: data) {\n    escaped.add(HEXDIGITS[b % 16]);\n    escaped.add(HEXDIGITS[b / 16]);\n    escaped.add(' ');\n  }\n\n  escaped.removeLast();\n  return kj::strTree(\"0x\\\"\", escaped, '\"');\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char HEXDIGITS[] = \"0123456789abcdef\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"0x\\\"\"",
            "escaped",
            "'\"'"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escaped.removeLast",
          "args": [],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "removeLast",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "364-367",
          "snippet": "void removeLast() {\n    KJ_IREQUIRE(pos > ptr, \"No elements present to remove.\");\n    kj::dtor(*--pos);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  void removeLast() {\n      KJ_IREQUIRE(pos > ptr, \"No elements present to remove.\");\n      kj::dtor(*--pos);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "escaped.add",
          "args": [
            "' '"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic const char HEXDIGITS[] = \"0123456789abcdef\";\n\nstatic kj::StringTree binaryLiteral(Data::Reader data) {\n  kj::Vector<char> escaped(data.size() * 3);\n\n  for (byte b: data) {\n    escaped.add(HEXDIGITS[b % 16]);\n    escaped.add(HEXDIGITS[b / 16]);\n    escaped.add(' ');\n  }\n\n  escaped.removeLast();\n  return kj::strTree(\"0x\\\"\", escaped, '\"');\n}"
  },
  {
    "function_name": "stringLiteral",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2335-2366",
    "snippet": "static kj::StringTree stringLiteral(kj::StringPtr chars) {\n  // TODO(cleanup): This code keeps coming up. Put somewhere common?\n\n  kj::Vector<char> escaped(chars.size());\n\n  for (char c: chars) {\n    switch (c) {\n      case '\\a': escaped.addAll(kj::StringPtr(\"\\\\a\")); break;\n      case '\\b': escaped.addAll(kj::StringPtr(\"\\\\b\")); break;\n      case '\\f': escaped.addAll(kj::StringPtr(\"\\\\f\")); break;\n      case '\\n': escaped.addAll(kj::StringPtr(\"\\\\n\")); break;\n      case '\\r': escaped.addAll(kj::StringPtr(\"\\\\r\")); break;\n      case '\\t': escaped.addAll(kj::StringPtr(\"\\\\t\")); break;\n      case '\\v': escaped.addAll(kj::StringPtr(\"\\\\v\")); break;\n      case '\\'': escaped.addAll(kj::StringPtr(\"\\\\\\'\")); break;\n      case '\\\"': escaped.addAll(kj::StringPtr(\"\\\\\\\"\")); break;\n      case '\\\\': escaped.addAll(kj::StringPtr(\"\\\\\\\\\")); break;\n      default:\n        if (c < 0x20) {\n          escaped.add('\\\\');\n          escaped.add('x');\n          uint8_t c2 = c;\n          escaped.add(HEXDIGITS[c2 / 16]);\n          escaped.add(HEXDIGITS[c2 % 16]);\n        } else {\n          escaped.add(c);\n        }\n        break;\n    }\n  }\n  return kj::strTree('\"', escaped, '\"');\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char HEXDIGITS[] = \"0123456789abcdef\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "'\"'",
            "escaped",
            "'\"'"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "escaped.add",
          "args": [
            "c"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "escaped.addAll",
          "args": [
            "kj::StringPtr(\"\\\\\\\\\")"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "357-359",
          "snippet": "void addAll(Container&& container) {\n    addAll(container.begin(), container.end());\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  void addAll(Container&& container) {\n      addAll(container.begin(), container.end());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::StringPtr",
          "args": [
            "\"\\\\\\\\\""
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chars.size",
          "args": [],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic const char HEXDIGITS[] = \"0123456789abcdef\";\n\nstatic kj::StringTree stringLiteral(kj::StringPtr chars) {\n  // TODO(cleanup): This code keeps coming up. Put somewhere common?\n\n  kj::Vector<char> escaped(chars.size());\n\n  for (char c: chars) {\n    switch (c) {\n      case '\\a': escaped.addAll(kj::StringPtr(\"\\\\a\")); break;\n      case '\\b': escaped.addAll(kj::StringPtr(\"\\\\b\")); break;\n      case '\\f': escaped.addAll(kj::StringPtr(\"\\\\f\")); break;\n      case '\\n': escaped.addAll(kj::StringPtr(\"\\\\n\")); break;\n      case '\\r': escaped.addAll(kj::StringPtr(\"\\\\r\")); break;\n      case '\\t': escaped.addAll(kj::StringPtr(\"\\\\t\")); break;\n      case '\\v': escaped.addAll(kj::StringPtr(\"\\\\v\")); break;\n      case '\\'': escaped.addAll(kj::StringPtr(\"\\\\\\'\")); break;\n      case '\\\"': escaped.addAll(kj::StringPtr(\"\\\\\\\"\")); break;\n      case '\\\\': escaped.addAll(kj::StringPtr(\"\\\\\\\\\")); break;\n      default:\n        if (c < 0x20) {\n          escaped.add('\\\\');\n          escaped.add('x');\n          uint8_t c2 = c;\n          escaped.add(HEXDIGITS[c2 / 16]);\n          escaped.add(HEXDIGITS[c2 % 16]);\n        } else {\n          escaped.add(c);\n        }\n        break;\n    }\n  }\n  return kj::strTree('\"', escaped, '\"');\n}"
  },
  {
    "function_name": "NodeTranslator::compileParamList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2259-2327",
    "snippet": "uint64_t NodeTranslator::compileParamList(\n    kj::StringPtr methodName, uint16_t ordinal, bool isResults,\n    Declaration::ParamList::Reader paramList,\n    List<Declaration::BrandParameter>::Reader implicitParams,\n    InitBrandFunc&& initBrand) {\n  switch (paramList.which()) {\n    case Declaration::ParamList::NAMED_LIST: {\n      auto newStruct = orphanage.newOrphan<schema::Node>();\n      auto builder = newStruct.get();\n      auto parent = wipNode.getReader();\n\n      kj::String typeName = kj::str(methodName, isResults ? \"$Results\" : \"$Params\");\n\n      builder.setId(generateMethodParamsId(parent.getId(), ordinal, isResults));\n      builder.setDisplayName(kj::str(parent.getDisplayName(), '.', typeName));\n      builder.setDisplayNamePrefixLength(builder.getDisplayName().size() - typeName.size());\n      builder.setIsGeneric(parent.getIsGeneric() || implicitParams.size() > 0);\n      builder.setScopeId(0);  // detached struct type\n\n      builder.initStruct();\n\n      // Note that the struct we create here has a brand parameter list mirrioring the method's\n      // implicit parameter list. Of course, fields inside the struct using the method's implicit\n      // params as types actually need to refer to them as regular params, so we create an\n      // ImplicitParams with a scopeId here.\n      StructTranslator(*this, ImplicitParams { builder.getId(), implicitParams })\n          .translate(paramList.getNamedList(), builder);\n      uint64_t id = builder.getId();\n      paramStructs.add(kj::mv(newStruct));\n\n      auto brand = localBrand->push(builder.getId(), implicitParams.size());\n\n      if (implicitParams.size() > 0) {\n        auto implicitDecls = kj::heapArrayBuilder<BrandedDecl>(implicitParams.size());\n        auto implicitBuilder = builder.initParameters(implicitParams.size());\n\n        for (auto i: kj::indices(implicitParams)) {\n          auto param = implicitParams[i];\n          implicitDecls.add(BrandedDecl::implicitMethodParam(i));\n          implicitBuilder[i].setName(param.getName());\n        }\n\n        brand->setParams(implicitDecls.finish(), Declaration::STRUCT, Expression::Reader());\n      }\n\n      brand->compile(initBrand);\n      return id;\n    }\n    case Declaration::ParamList::TYPE:\n      KJ_IF_MAYBE(target, compileDeclExpression(\n          paramList.getType(), ImplicitParams { 0, implicitParams })) {\n        KJ_IF_MAYBE(kind, target->getKind()) {\n          if (*kind == Declaration::STRUCT) {\n            return target->getIdAndFillBrand(kj::fwd<InitBrandFunc>(initBrand));\n          } else {\n            errorReporter.addErrorOn(\n                paramList.getType(),\n                kj::str(\"'\", expressionString(paramList.getType()), \"' is not a struct type.\"));\n          }\n        } else {\n          // A variable?\n          target->addError(errorReporter,\n              \"Cannot use generic parameter as whole input or output of a method. Instead, \"\n              \"use a parameter/result list containing a field with this type.\");\n          return 0;\n        }\n      }\n      return 0;\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "kj::Array<BrandedDecl> params;",
      "auto list = interfaceBuilder.initMethods(methods.size());",
      "uint i = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "target->addError",
          "args": [
            "errorReporter",
            "\"Cannot use generic parameter as whole input or output of a method. Instead, \"\n              \"use a parameter/result list containing a field with this type.\""
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "588-590",
          "snippet": "inline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\ninline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "paramList.getType()",
            "kj::str(\"'\", expressionString(paramList.getType()), \"' is not a struct type.\")"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "expressionString(paramList.getType())",
            "\"' is not a struct type.\""
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expressionString",
          "args": [
            "paramList.getType()"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "expressionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2444-2446",
          "snippet": "static kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kj::String expressionString(Expression::Reader name);",
            "static kj::String expressionString(Expression::Reader name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\n\nstatic kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}"
        }
      },
      {
        "call_info": {
          "callee": "paramList.getType",
          "args": [],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "target->getIdAndFillBrand",
          "args": [
            "kj::fwd<InitBrandFunc>(initBrand)"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<InitBrandFunc>",
          "args": [
            "initBrand"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "kind",
            "target->getKind()"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "target->getKind",
          "args": [],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "getKind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "77-77",
          "snippet": "Declaration::Which getKind() { return kind; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nDeclaration::Which getKind() { return kind; }"
        }
      },
      {
        "call_info": {
          "callee": "compileDeclExpression",
          "args": [
            "paramList.getType()",
            "ImplicitParams { 0, implicitParams }"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::compileDeclExpression",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2450-2454",
          "snippet": "kj::Maybe<NodeTranslator::BrandedDecl>\nNodeTranslator::compileDeclExpression(\n    Expression::Reader source, ImplicitParams implicitMethodParams) {\n  return localBrand->compileDeclExpression(source, resolver, implicitMethodParams);\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);",
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\nkj::Maybe<NodeTranslator::BrandedDecl>\nNodeTranslator::compileDeclExpression(\n    Expression::Reader source, ImplicitParams implicitMethodParams) {\n  return localBrand->compileDeclExpression(source, resolver, implicitMethodParams);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brand->compile",
          "args": [
            "initBrand"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "compile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "733-745",
          "snippet": "void compile(InitBrandFunc&& initBrand) {\n    kj::Vector<BrandScope*> levels;\n    BrandScope* ptr = this;\n    for (;;) {\n      if (ptr->params.size() > 0 || (ptr->inherited && ptr->leafParamCount > 0)) {\n        levels.add(ptr);\n      }\n      KJ_IF_MAYBE(p, ptr->parent) {\n        ptr = *p;\n      } else {\n        break;\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "uint leafParamCount;",
            "bool inherited;",
            "kj::Array<BrandedDecl> params;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint leafParamCount;\nbool inherited;\nkj::Array<BrandedDecl> params;\n\nvoid compile(InitBrandFunc&& initBrand) {\n    kj::Vector<BrandScope*> levels;\n    BrandScope* ptr = this;\n    for (;;) {\n      if (ptr->params.size() > 0 || (ptr->inherited && ptr->leafParamCount > 0)) {\n        levels.add(ptr);\n      }\n      KJ_IF_MAYBE(p, ptr->parent) {\n        ptr = *p;\n      } else {\n        break;\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "brand->setParams",
          "args": [
            "implicitDecls.finish()",
            "Declaration::STRUCT",
            "Expression::Reader()"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "implicitDecls.finish",
          "args": [],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "implicitBuilder[i].setName",
          "args": [
            "param.getName()"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getName",
          "args": [],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "implicitDecls.add",
          "args": [
            "BrandedDecl::implicitMethodParam(i)"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BrandedDecl::implicitMethodParam",
          "args": [
            "i"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "implicitMethodParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "543-547",
          "snippet": "static BrandedDecl implicitMethodParam(uint index) {\n    // Get a BrandedDecl referring to an implicit method parameter.\n    // (As a hack, we internally represent this as a ResolvedParameter. Sorry.)\n    return BrandedDecl(Resolver::ResolvedParameter { 0, index }, Expression::Reader());\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\n\nstatic BrandedDecl implicitMethodParam(uint index) {\n    // Get a BrandedDecl referring to an implicit method parameter.\n    // (As a hack, we internally represent this as a ResolvedParameter. Sorry.)\n    return BrandedDecl(Resolver::ResolvedParameter { 0, index }, Expression::Reader());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "implicitParams"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initParameters",
          "args": [
            "implicitParams.size()"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "implicitParams.size",
          "args": [],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<BrandedDecl>",
          "args": [
            "implicitParams.size()"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "localBrand->push",
          "args": [
            "builder.getId()",
            "implicitParams.size()"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getId",
          "args": [],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "newStruct"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StructTranslator",
          "args": [
            "paramList.getNamedList()",
            "builder"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "StructTranslator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1668-1670",
          "snippet": "explicit StructTranslator(NodeTranslator& translator, ImplicitParams implicitMethodParams)\n      : translator(translator), errorReporter(translator.errorReporter),\n        implicitMethodParams(implicitMethodParams) {}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nexplicit StructTranslator(NodeTranslator& translator, ImplicitParams implicitMethodParams)\n      : translator(translator), errorReporter(translator.errorReporter),\n        implicitMethodParams(implicitMethodParams) {}"
        }
      },
      {
        "call_info": {
          "callee": "paramList.getNamedList",
          "args": [],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initStruct",
          "args": [],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setScopeId",
          "args": [
            "0"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setIsGeneric",
          "args": [
            "parent.getIsGeneric() || implicitParams.size() > 0"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.getIsGeneric",
          "args": [],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setDisplayNamePrefixLength",
          "args": [
            "builder.getDisplayName().size() - typeName.size()"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.getDisplayName",
          "args": [],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "builder.setDisplayName",
          "args": [
            "kj::str(parent.getDisplayName(), '.', typeName)"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "parent.getDisplayName()",
            "'.'",
            "typeName"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setId",
          "args": [
            "generateMethodParamsId(parent.getId(), ordinal, isResults)"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generateMethodParamsId",
          "args": [
            "parent.getId()",
            "ordinal",
            "isResults"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "generateMethodParamsId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "110-135",
          "snippet": "uint64_t generateMethodParamsId(uint64_t parentId, uint16_t methodOrdinal, bool isResults) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID, the method ordinal, and a\n  // boolean indicating whether this is the params or the results, and then taking the first 8\n  // bytes.\n\n  kj::byte bytes[sizeof(uint64_t) + sizeof(uint16_t) + 1];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    bytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n  for (uint i = 0; i < sizeof(uint16_t); i++) {\n    bytes[sizeof(uint64_t) + i] = (methodOrdinal >> (i * 8)) & 0xff;\n  }\n  bytes[sizeof(bytes) - 1] = isResults;\n\n  Md5 md5;\n  md5.update(bytes);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nuint64_t generateMethodParamsId(uint64_t parentId, uint16_t methodOrdinal, bool isResults) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID, the method ordinal, and a\n  // boolean indicating whether this is the params or the results, and then taking the first 8\n  // bytes.\n\n  kj::byte bytes[sizeof(uint64_t) + sizeof(uint16_t) + 1];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    bytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n  for (uint i = 0; i < sizeof(uint16_t); i++) {\n    bytes[sizeof(uint64_t) + i] = (methodOrdinal >> (i * 8)) & 0xff;\n  }\n  bytes[sizeof(bytes) - 1] = isResults;\n\n  Md5 md5;\n  md5.update(bytes);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "methodName",
            "isResults ? \"$Results\" : \"$Params\""
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wipNode.getReader",
          "args": [],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newStruct.get",
          "args": [],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<schema::Node>",
          "args": [],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paramList.which",
          "args": [],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nkj::Array<BrandedDecl> params;\nauto list = interfaceBuilder.initMethods(methods.size());\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nuint64_t NodeTranslator::compileParamList(\n    kj::StringPtr methodName, uint16_t ordinal, bool isResults,\n    Declaration::ParamList::Reader paramList,\n    List<Declaration::BrandParameter>::Reader implicitParams,\n    InitBrandFunc&& initBrand) {\n  switch (paramList.which()) {\n    case Declaration::ParamList::NAMED_LIST: {\n      auto newStruct = orphanage.newOrphan<schema::Node>();\n      auto builder = newStruct.get();\n      auto parent = wipNode.getReader();\n\n      kj::String typeName = kj::str(methodName, isResults ? \"$Results\" : \"$Params\");\n\n      builder.setId(generateMethodParamsId(parent.getId(), ordinal, isResults));\n      builder.setDisplayName(kj::str(parent.getDisplayName(), '.', typeName));\n      builder.setDisplayNamePrefixLength(builder.getDisplayName().size() - typeName.size());\n      builder.setIsGeneric(parent.getIsGeneric() || implicitParams.size() > 0);\n      builder.setScopeId(0);  // detached struct type\n\n      builder.initStruct();\n\n      // Note that the struct we create here has a brand parameter list mirrioring the method's\n      // implicit parameter list. Of course, fields inside the struct using the method's implicit\n      // params as types actually need to refer to them as regular params, so we create an\n      // ImplicitParams with a scopeId here.\n      StructTranslator(*this, ImplicitParams { builder.getId(), implicitParams })\n          .translate(paramList.getNamedList(), builder);\n      uint64_t id = builder.getId();\n      paramStructs.add(kj::mv(newStruct));\n\n      auto brand = localBrand->push(builder.getId(), implicitParams.size());\n\n      if (implicitParams.size() > 0) {\n        auto implicitDecls = kj::heapArrayBuilder<BrandedDecl>(implicitParams.size());\n        auto implicitBuilder = builder.initParameters(implicitParams.size());\n\n        for (auto i: kj::indices(implicitParams)) {\n          auto param = implicitParams[i];\n          implicitDecls.add(BrandedDecl::implicitMethodParam(i));\n          implicitBuilder[i].setName(param.getName());\n        }\n\n        brand->setParams(implicitDecls.finish(), Declaration::STRUCT, Expression::Reader());\n      }\n\n      brand->compile(initBrand);\n      return id;\n    }\n    case Declaration::ParamList::TYPE:\n      KJ_IF_MAYBE(target, compileDeclExpression(\n          paramList.getType(), ImplicitParams { 0, implicitParams })) {\n        KJ_IF_MAYBE(kind, target->getKind()) {\n          if (*kind == Declaration::STRUCT) {\n            return target->getIdAndFillBrand(kj::fwd<InitBrandFunc>(initBrand));\n          } else {\n            errorReporter.addErrorOn(\n                paramList.getType(),\n                kj::str(\"'\", expressionString(paramList.getType()), \"' is not a struct type.\"));\n          }\n        } else {\n          // A variable?\n          target->addError(errorReporter,\n              \"Cannot use generic parameter as whole input or output of a method. Instead, \"\n              \"use a parameter/result list containing a field with this type.\");\n          return 0;\n        }\n      }\n      return 0;\n  }"
  },
  {
    "function_name": "NodeTranslator::compileInterface",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2171-2197",
    "snippet": "void NodeTranslator::compileInterface(Declaration::Interface::Reader decl,\n                                      List<Declaration>::Reader members,\n                                      schema::Node::Builder builder) {\n  auto interfaceBuilder = builder.initInterface();\n\n  auto superclassesDecl = decl.getSuperclasses();\n  auto superclassesBuilder = interfaceBuilder.initSuperclasses(superclassesDecl.size());\n  for (uint i: kj::indices(superclassesDecl)) {\n    auto superclass = superclassesDecl[i];\n\n    KJ_IF_MAYBE(decl, compileDeclExpression(superclass, noImplicitParams())) {\n      KJ_IF_MAYBE(kind, decl->getKind()) {\n        if (*kind == Declaration::INTERFACE) {\n          auto s = superclassesBuilder[i];\n          s.setId(decl->getIdAndFillBrand([&]() { return s.initBrand(); }));\n        } else {\n          decl->addError(errorReporter, kj::str(\n            \"'\", decl->toString(), \"' is not an interface.\"));\n        }\n      } else {\n        // A variable?\n        decl->addError(errorReporter, kj::str(\n            \"'\", decl->toString(), \"' is an unbound generic parameter. Currently we don't support \"\n            \"extending these.\"));\n      }\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint i = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "decl->addError",
          "args": [
            "errorReporter",
            "kj::str(\n            \"'\", decl->toString(), \"' is an unbound generic parameter. Currently we don't support \"\n            \"extending these.\")"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "588-590",
          "snippet": "inline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\ninline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "decl->toString()",
            "\"' is an unbound generic parameter. Currently we don't support \"\n            \"extending these.\""
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->toString",
          "args": [],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3153-3153",
          "snippet": "inline ::kj::StringTree toString() const { return asReader().toString(); }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline ::kj::StringTree toString() const { return asReader().toString(); }"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "decl->toString()",
            "\"' is not an interface.\""
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.setId",
          "args": [
            "decl->getIdAndFillBrand([&]() { return s.initBrand(); })"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl->getIdAndFillBrand",
          "args": [
            "[&]() { return s.initBrand(); }"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.initBrand",
          "args": [],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "kind",
            "decl->getKind()"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "decl->getKind",
          "args": [],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "getKind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "77-77",
          "snippet": "Declaration::Which getKind() { return kind; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nDeclaration::Which getKind() { return kind; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "superclassesDecl"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "interfaceBuilder.initSuperclasses",
          "args": [
            "superclassesDecl.size()"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "superclassesDecl.size",
          "args": [],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.getSuperclasses",
          "args": [],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initInterface",
          "args": [],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid NodeTranslator::compileInterface(Declaration::Interface::Reader decl,\n                                      List<Declaration>::Reader members,\n                                      schema::Node::Builder builder) {\n  auto interfaceBuilder = builder.initInterface();\n\n  auto superclassesDecl = decl.getSuperclasses();\n  auto superclassesBuilder = interfaceBuilder.initSuperclasses(superclassesDecl.size());\n  for (uint i: kj::indices(superclassesDecl)) {\n    auto superclass = superclassesDecl[i];\n\n    KJ_IF_MAYBE(decl, compileDeclExpression(superclass, noImplicitParams())) {\n      KJ_IF_MAYBE(kind, decl->getKind()) {\n        if (*kind == Declaration::INTERFACE) {\n          auto s = superclassesBuilder[i];\n          s.setId(decl->getIdAndFillBrand([&]() { return s.initBrand(); }));\n        } else {\n          decl->addError(errorReporter, kj::str(\n            \"'\", decl->toString(), \"' is not an interface.\"));\n        }\n      } else {\n        // A variable?\n        decl->addError(errorReporter, kj::str(\n            \"'\", decl->toString(), \"' is an unbound generic parameter. Currently we don't support \"\n            \"extending these.\"));\n      }\n    }\n  }"
  },
  {
    "function_name": "NodeTranslator::compileStruct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2162-2165",
    "snippet": "void NodeTranslator::compileStruct(Void decl, List<Declaration>::Reader members,\n                                   schema::Node::Builder builder) {\n  StructTranslator(*this, noImplicitParams()).translate(decl, members, builder);\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StructTranslator",
          "args": [
            "decl",
            "members",
            "builder"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StructTranslator",
          "args": [
            "*this",
            "noImplicitParams()"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "StructTranslator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1668-1670",
          "snippet": "explicit StructTranslator(NodeTranslator& translator, ImplicitParams implicitMethodParams)\n      : translator(translator), errorReporter(translator.errorReporter),\n        implicitMethodParams(implicitMethodParams) {}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nexplicit StructTranslator(NodeTranslator& translator, ImplicitParams implicitMethodParams)\n      : translator(translator), errorReporter(translator.errorReporter),\n        implicitMethodParams(implicitMethodParams) {}"
        }
      },
      {
        "call_info": {
          "callee": "noImplicitParams",
          "args": [],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "noImplicitParams",
          "container": "NodeTranslator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.h",
          "lines": "225-227",
          "snippet": "static inline ImplicitParams noImplicitParams() {\n    return { 0, List<Declaration::BrandParameter>::Reader() };\n  }",
          "includes": [
            "#include \"error-reporter.h\"",
            "#include <kj/one-of.h>",
            "#include <kj/vector.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/orphan.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error-reporter.h\"\n#include <kj/one-of.h>\n#include <kj/vector.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/orphan.h>\n\nNodeTranslator {\n  static inline ImplicitParams noImplicitParams() {\n      return { 0, List<Declaration::BrandParameter>::Reader() };\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nvoid NodeTranslator::compileStruct(Void decl, List<Declaration>::Reader members,\n                                   schema::Node::Builder builder) {\n  StructTranslator(*this, noImplicitParams()).translate(decl, members, builder);\n}"
  },
  {
    "function_name": "translateInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2029-2159",
    "snippet": "void translateInternal(MemberInfo& root, schema::Node::Builder builder) {\n    auto structBuilder = builder.initStruct();\n\n    // Go through each member in ordinal order, building each member schema.\n    DuplicateOrdinalDetector dupDetector(errorReporter);\n    for (auto& entry: membersByOrdinal) {\n      MemberInfo& member = *entry.second;\n\n      if (member.declId.isOrdinal()) {\n        dupDetector.check(member.declId.getOrdinal());\n      }\n\n      schema::Field::Builder fieldBuilder = member.getSchema();\n      fieldBuilder.getOrdinal().setExplicit(entry.first);\n\n      switch (member.declKind) {\n        case Declaration::FIELD: {\n          auto slot = fieldBuilder.initSlot();\n          auto typeBuilder = slot.initType();\n          if (translator.compileType(member.fieldType, typeBuilder, implicitMethodParams)) {\n            if (member.hasDefaultValue) {\n              translator.compileBootstrapValue(member.fieldDefaultValue,\n                                               typeBuilder, slot.initDefaultValue());\n              slot.setHadExplicitDefault(true);\n            } else {\n              translator.compileDefaultDefaultValue(typeBuilder, slot.initDefaultValue());\n            }\n          } else {\n            translator.compileDefaultDefaultValue(typeBuilder, slot.initDefaultValue());\n          }\n\n          int lgSize = -1;\n          switch (typeBuilder.which()) {\n            case schema::Type::VOID: lgSize = -1; break;\n            case schema::Type::BOOL: lgSize = 0; break;\n            case schema::Type::INT8: lgSize = 3; break;\n            case schema::Type::INT16: lgSize = 4; break;\n            case schema::Type::INT32: lgSize = 5; break;\n            case schema::Type::INT64: lgSize = 6; break;\n            case schema::Type::UINT8: lgSize = 3; break;\n            case schema::Type::UINT16: lgSize = 4; break;\n            case schema::Type::UINT32: lgSize = 5; break;\n            case schema::Type::UINT64: lgSize = 6; break;\n            case schema::Type::FLOAT32: lgSize = 5; break;\n            case schema::Type::FLOAT64: lgSize = 6; break;\n\n            case schema::Type::TEXT: lgSize = -2; break;\n            case schema::Type::DATA: lgSize = -2; break;\n            case schema::Type::LIST: lgSize = -2; break;\n            case schema::Type::ENUM: lgSize = 4; break;\n            case schema::Type::STRUCT: lgSize = -2; break;\n            case schema::Type::INTERFACE: lgSize = -2; break;\n            case schema::Type::ANY_POINTER: lgSize = -2; break;\n          }\n\n          if (lgSize == -2) {\n            // pointer\n            slot.setOffset(member.fieldScope->addPointer());\n          } else if (lgSize == -1) {\n            // void\n            member.fieldScope->addVoid();\n            slot.setOffset(0);\n          } else {\n            slot.setOffset(member.fieldScope->addData(lgSize));\n          }\n          break;\n        }\n\n        case Declaration::UNION:\n          if (!member.unionScope->addDiscriminant()) {\n            errorReporter.addErrorOn(member.declId.getOrdinal(),\n                \"Union ordinal, if specified, must be greater than no more than one of its \"\n                \"member ordinals (i.e. there can only be one field retroactively unionized).\");\n          }\n          break;\n\n        case Declaration::GROUP:\n          KJ_FAIL_ASSERT(\"Groups don't have ordinals.\");\n          break;\n\n        default:\n          KJ_FAIL_ASSERT(\"Unexpected member type.\");\n          break;\n      }\n    }\n\n    // OK, we should have built all the members.  Now go through and make sure the discriminant\n    // offsets have been copied over to the schemas and annotations have been applied.\n    root.finishGroup();\n    for (auto member: allMembers) {\n      kj::StringPtr targetsFlagName;\n      if (member->isParam) {\n        targetsFlagName = \"targetsParam\";\n      } else {\n        switch (member->declKind) {\n          case Declaration::FIELD:\n            targetsFlagName = \"targetsField\";\n            break;\n\n          case Declaration::UNION:\n            member->finishGroup();\n            targetsFlagName = \"targetsUnion\";\n            break;\n\n          case Declaration::GROUP:\n            member->finishGroup();\n            targetsFlagName = \"targetsGroup\";\n            break;\n\n          default:\n            KJ_FAIL_ASSERT(\"Unexpected member type.\");\n            break;\n        }\n      }\n\n      member->getSchema().adoptAnnotations(translator.compileAnnotationApplications(\n          member->declAnnotations, targetsFlagName));\n    }\n\n    // And fill in the sizes.\n    structBuilder.setDataWordCount(layout.getTop().dataWordCount);\n    structBuilder.setPointerCount(layout.getTop().pointerCount);\n    structBuilder.setPreferredListEncoding(schema::ElementSize::INLINE_COMPOSITE);\n\n    for (auto& group: translator.groups) {\n      auto groupBuilder = group.get().getStruct();\n      groupBuilder.setDataWordCount(structBuilder.getDataWordCount());\n      groupBuilder.setPointerCount(structBuilder.getPointerCount());\n      groupBuilder.setPreferredListEncoding(structBuilder.getPreferredListEncoding());\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);",
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "std::multimap<uint, MemberInfo*> membersByOrdinal;",
      "kj::Vector<MemberInfo*> allMembers;",
      "uint i = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "groupBuilder.setPreferredListEncoding",
          "args": [
            "structBuilder.getPreferredListEncoding()"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structBuilder.getPreferredListEncoding",
          "args": [],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groupBuilder.setPointerCount",
          "args": [
            "structBuilder.getPointerCount()"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structBuilder.getPointerCount",
          "args": [],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groupBuilder.setDataWordCount",
          "args": [
            "structBuilder.getDataWordCount()"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structBuilder.getDataWordCount",
          "args": [],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group.get",
          "args": [],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "structBuilder.setPreferredListEncoding",
          "args": [
            "schema::ElementSize::INLINE_COMPOSITE"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structBuilder.setPointerCount",
          "args": [
            "layout.getTop().pointerCount"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layout.getTop",
          "args": [],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structBuilder.setDataWordCount",
          "args": [
            "layout.getTop().dataWordCount"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layout.getTop",
          "args": [],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member->getSchema",
          "args": [
            "translator.compileAnnotationApplications(\n          member->declAnnotations, targetsFlagName)"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "translator.compileAnnotationApplications",
          "args": [
            "member->declAnnotations",
            "targetsFlagName"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member->getSchema",
          "args": [],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unexpected member type.\""
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member->finishGroup",
          "args": [],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "finishGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1828-1842",
          "snippet": "void finishGroup() {\n      if (unionScope != nullptr) {\n        unionScope->addDiscriminant();  // if it hasn't happened already\n        auto structNode = node.getStruct();\n        structNode.setDiscriminantCount(unionDiscriminantCount);\n        structNode.setDiscriminantOffset(KJ_ASSERT_NONNULL(unionScope->discriminantOffset));\n      }\n\n      if (parent != nullptr) {\n        uint64_t groupId = generateGroupId(parent->node.getId(), index);\n        node.setId(groupId);\n        node.setScopeId(parent->node.getId());\n        getSchema().initGroup().setTypeId(groupId);\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);",
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nvoid finishGroup() {\n      if (unionScope != nullptr) {\n        unionScope->addDiscriminant();  // if it hasn't happened already\n        auto structNode = node.getStruct();\n        structNode.setDiscriminantCount(unionDiscriminantCount);\n        structNode.setDiscriminantOffset(KJ_ASSERT_NONNULL(unionScope->discriminantOffset));\n      }\n\n      if (parent != nullptr) {\n        uint64_t groupId = generateGroupId(parent->node.getId(), index);\n        node.setId(groupId);\n        node.setScopeId(parent->node.getId());\n        getSchema().initGroup().setTypeId(groupId);\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Unexpected member type.\""
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Groups don't have ordinals.\""
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "member.declId.getOrdinal()",
            "\"Union ordinal, if specified, must be greater than no more than one of its \"\n                \"member ordinals (i.e. there can only be one field retroactively unionized).\""
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "member.declId.getOrdinal",
          "args": [],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "486-486",
          "snippet": "inline uint16_t getOrdinal() const { return ordinal; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint16_t getOrdinal() const { return ordinal; }"
        }
      },
      {
        "call_info": {
          "callee": "member.unionScope->addDiscriminant",
          "args": [],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "addDiscriminant",
          "container": "Union",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "257-264",
          "snippet": "bool addDiscriminant() {\n      if (discriminantOffset == nullptr) {\n        discriminantOffset = parent.addData(4);  // 2^4 = 16 bits\n        return true;\n      } else {\n        return false;\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  bool addDiscriminant() {\n        if (discriminantOffset == nullptr) {\n          discriminantOffset = parent.addData(4);  // 2^4 = 16 bits\n          return true;\n        } else {\n          return false;\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot.setOffset",
          "args": [
            "member.fieldScope->addData(lgSize)"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.fieldScope->addData",
          "args": [
            "lgSize"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.setOffset",
          "args": [
            "0"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.fieldScope->addVoid",
          "args": [],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "addVoid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "430-435",
          "snippet": "void addVoid() override {\n      if (!hasMembers) {\n        hasMembers = true;\n        parent.newGroupAddingFirstMember();\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nvoid addVoid() override {\n      if (!hasMembers) {\n        hasMembers = true;\n        parent.newGroupAddingFirstMember();\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "slot.setOffset",
          "args": [
            "member.fieldScope->addPointer()"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.fieldScope->addPointer",
          "args": [],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "addPointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "478-487",
          "snippet": "uint addPointer() override {\n      addVoid();\n\n      if (parentPointerLocationUsage < parent.pointerLocations.size()) {\n        return parent.pointerLocations[parentPointerLocationUsage++];\n      } else {\n        parentPointerLocationUsage++;\n        return parent.addNewPointerLocation();\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nuint addPointer() override {\n      addVoid();\n\n      if (parentPointerLocationUsage < parent.pointerLocations.size()) {\n        return parent.pointerLocations[parentPointerLocationUsage++];\n      } else {\n        parentPointerLocationUsage++;\n        return parent.addNewPointerLocation();\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "typeBuilder.which",
          "args": [],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "translator.compileDefaultDefaultValue",
          "args": [
            "typeBuilder",
            "slot.initDefaultValue()"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.initDefaultValue",
          "args": [],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "translator.compileDefaultDefaultValue",
          "args": [
            "typeBuilder",
            "slot.initDefaultValue()"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.initDefaultValue",
          "args": [],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.setHadExplicitDefault",
          "args": [
            "true"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "translator.compileBootstrapValue",
          "args": [
            "member.fieldDefaultValue",
            "typeBuilder",
            "slot.initDefaultValue()"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.initDefaultValue",
          "args": [],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "translator.compileType",
          "args": [
            "member.fieldType",
            "typeBuilder",
            "implicitMethodParams"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.initType",
          "args": [],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldBuilder.initSlot",
          "args": [],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fieldBuilder.getOrdinal",
          "args": [
            "entry.first"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "451-461",
          "snippet": "uint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nuint getOrdinal(StructSchema::Field field) {\n  auto proto = field.getProto();\n  if (proto.getOrdinal().isExplicit()) {\n    return proto.getOrdinal().getExplicit();\n  }\n\n  KJ_ASSERT(proto.isGroup());\n\n  auto group = field.getType().asStruct();\n  return getOrdinal(group.getFields()[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dupDetector.check",
          "args": [
            "member.declId.getOrdinal()"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "check",
          "container": "TextChecker",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/fuzz-test.c++",
          "lines": "199-205",
          "snippet": "static uint check(ReaderOrBuilder& message) {\n    uint result = 0;\n    for (auto c: message.template getRoot<Text>()) {\n      result += c;\n    }\n    return result;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <kj/test.h>",
            "#include \"serialize.h\"",
            "#include \"message.h\"",
            "#include <capnp/test-import2.capnp.h>",
            "#include <capnp/test-import.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <kj/test.h>\n#include \"serialize.h\"\n#include \"message.h\"\n#include <capnp/test-import2.capnp.h>\n#include <capnp/test-import.capnp.h>\n\nTextChecker {\n  static uint check(ReaderOrBuilder& message) {\n      uint result = 0;\n      for (auto c: message.template getRoot<Text>()) {\n        result += c;\n      }\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "member.declId.isOrdinal",
          "args": [],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initStruct",
          "args": [],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nstd::multimap<uint, MemberInfo*> membersByOrdinal;\nkj::Vector<MemberInfo*> allMembers;\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid translateInternal(MemberInfo& root, schema::Node::Builder builder) {\n    auto structBuilder = builder.initStruct();\n\n    // Go through each member in ordinal order, building each member schema.\n    DuplicateOrdinalDetector dupDetector(errorReporter);\n    for (auto& entry: membersByOrdinal) {\n      MemberInfo& member = *entry.second;\n\n      if (member.declId.isOrdinal()) {\n        dupDetector.check(member.declId.getOrdinal());\n      }\n\n      schema::Field::Builder fieldBuilder = member.getSchema();\n      fieldBuilder.getOrdinal().setExplicit(entry.first);\n\n      switch (member.declKind) {\n        case Declaration::FIELD: {\n          auto slot = fieldBuilder.initSlot();\n          auto typeBuilder = slot.initType();\n          if (translator.compileType(member.fieldType, typeBuilder, implicitMethodParams)) {\n            if (member.hasDefaultValue) {\n              translator.compileBootstrapValue(member.fieldDefaultValue,\n                                               typeBuilder, slot.initDefaultValue());\n              slot.setHadExplicitDefault(true);\n            } else {\n              translator.compileDefaultDefaultValue(typeBuilder, slot.initDefaultValue());\n            }\n          } else {\n            translator.compileDefaultDefaultValue(typeBuilder, slot.initDefaultValue());\n          }\n\n          int lgSize = -1;\n          switch (typeBuilder.which()) {\n            case schema::Type::VOID: lgSize = -1; break;\n            case schema::Type::BOOL: lgSize = 0; break;\n            case schema::Type::INT8: lgSize = 3; break;\n            case schema::Type::INT16: lgSize = 4; break;\n            case schema::Type::INT32: lgSize = 5; break;\n            case schema::Type::INT64: lgSize = 6; break;\n            case schema::Type::UINT8: lgSize = 3; break;\n            case schema::Type::UINT16: lgSize = 4; break;\n            case schema::Type::UINT32: lgSize = 5; break;\n            case schema::Type::UINT64: lgSize = 6; break;\n            case schema::Type::FLOAT32: lgSize = 5; break;\n            case schema::Type::FLOAT64: lgSize = 6; break;\n\n            case schema::Type::TEXT: lgSize = -2; break;\n            case schema::Type::DATA: lgSize = -2; break;\n            case schema::Type::LIST: lgSize = -2; break;\n            case schema::Type::ENUM: lgSize = 4; break;\n            case schema::Type::STRUCT: lgSize = -2; break;\n            case schema::Type::INTERFACE: lgSize = -2; break;\n            case schema::Type::ANY_POINTER: lgSize = -2; break;\n          }\n\n          if (lgSize == -2) {\n            // pointer\n            slot.setOffset(member.fieldScope->addPointer());\n          } else if (lgSize == -1) {\n            // void\n            member.fieldScope->addVoid();\n            slot.setOffset(0);\n          } else {\n            slot.setOffset(member.fieldScope->addData(lgSize));\n          }\n          break;\n        }\n\n        case Declaration::UNION:\n          if (!member.unionScope->addDiscriminant()) {\n            errorReporter.addErrorOn(member.declId.getOrdinal(),\n                \"Union ordinal, if specified, must be greater than no more than one of its \"\n                \"member ordinals (i.e. there can only be one field retroactively unionized).\");\n          }\n          break;\n\n        case Declaration::GROUP:\n          KJ_FAIL_ASSERT(\"Groups don't have ordinals.\");\n          break;\n\n        default:\n          KJ_FAIL_ASSERT(\"Unexpected member type.\");\n          break;\n      }\n    }\n\n    // OK, we should have built all the members.  Now go through and make sure the discriminant\n    // offsets have been copied over to the schemas and annotations have been applied.\n    root.finishGroup();\n    for (auto member: allMembers) {\n      kj::StringPtr targetsFlagName;\n      if (member->isParam) {\n        targetsFlagName = \"targetsParam\";\n      } else {\n        switch (member->declKind) {\n          case Declaration::FIELD:\n            targetsFlagName = \"targetsField\";\n            break;\n\n          case Declaration::UNION:\n            member->finishGroup();\n            targetsFlagName = \"targetsUnion\";\n            break;\n\n          case Declaration::GROUP:\n            member->finishGroup();\n            targetsFlagName = \"targetsGroup\";\n            break;\n\n          default:\n            KJ_FAIL_ASSERT(\"Unexpected member type.\");\n            break;\n        }\n      }\n\n      member->getSchema().adoptAnnotations(translator.compileAnnotationApplications(\n          member->declAnnotations, targetsFlagName));\n    }\n\n    // And fill in the sizes.\n    structBuilder.setDataWordCount(layout.getTop().dataWordCount);\n    structBuilder.setPointerCount(layout.getTop().pointerCount);\n    structBuilder.setPreferredListEncoding(schema::ElementSize::INLINE_COMPOSITE);\n\n    for (auto& group: translator.groups) {\n      auto groupBuilder = group.get().getStruct();\n      groupBuilder.setDataWordCount(structBuilder.getDataWordCount());\n      groupBuilder.setPointerCount(structBuilder.getPointerCount());\n      groupBuilder.setPreferredListEncoding(structBuilder.getPreferredListEncoding());\n    }\n  }"
  },
  {
    "function_name": "newGroupNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2013-2027",
    "snippet": "schema::Node::Builder newGroupNode(schema::Node::Reader parent, kj::StringPtr name) {\n    auto orphan = translator.orphanage.newOrphan<schema::Node>();\n    auto node = orphan.get();\n\n    // We'll set the ID and scope ID later.\n    node.setDisplayName(kj::str(parent.getDisplayName(), '.', name));\n    node.setDisplayNamePrefixLength(node.getDisplayName().size() - name.size());\n    node.setIsGeneric(parent.getIsGeneric());\n    node.initStruct().setIsGroup(true);\n\n    // The remaining contents of node.struct will be filled in later.\n\n    translator.groups.add(kj::mv(orphan));\n    return node;\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "translator.groups.add",
          "args": [
            "kj::mv(orphan)"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "orphan"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.initStruct",
          "args": [
            "true"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.initStruct",
          "args": [],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.setIsGeneric",
          "args": [
            "parent.getIsGeneric()"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.getIsGeneric",
          "args": [],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.setDisplayNamePrefixLength",
          "args": [
            "node.getDisplayName().size() - name.size()"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.size",
          "args": [],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "node.getDisplayName",
          "args": [],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "node.setDisplayName",
          "args": [
            "kj::str(parent.getDisplayName(), '.', name)"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "parent.getDisplayName()",
            "'.'",
            "name"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan.get",
          "args": [],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "translator.orphanage.newOrphan<schema::Node>",
          "args": [],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\n\nschema::Node::Builder newGroupNode(schema::Node::Reader parent, kj::StringPtr name) {\n    auto orphan = translator.orphanage.newOrphan<schema::Node>();\n    auto node = orphan.get();\n\n    // We'll set the ID and scope ID later.\n    node.setDisplayName(kj::str(parent.getDisplayName(), '.', name));\n    node.setDisplayNamePrefixLength(node.getDisplayName().size() - name.size());\n    node.setIsGeneric(parent.getIsGeneric());\n    node.initStruct().setIsGroup(true);\n\n    // The remaining contents of node.struct will be filled in later.\n\n    translator.groups.add(kj::mv(orphan));\n    return node;\n  }"
  },
  {
    "function_name": "traverseParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "2002-2011",
    "snippet": "void traverseParams(List<Declaration::Param>::Reader params, MemberInfo& parent,\n                      StructLayout::StructOrGroup& layout) {\n    for (uint i: kj::indices(params)) {\n      auto param = params[i];\n      parent.childCount++;\n      MemberInfo* memberInfo = &arena.allocate<MemberInfo>(parent, i, param, layout, false);\n      allMembers.add(memberInfo);\n      membersByOrdinal.insert(std::make_pair(i, memberInfo));\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "kj::Array<BrandedDecl> params;",
      "std::multimap<uint, MemberInfo*> membersByOrdinal;",
      "kj::Vector<MemberInfo*> allMembers;",
      "uint i = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "membersByOrdinal.insert",
          "args": [
            "std::make_pair(i, memberInfo)"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "i",
            "memberInfo"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allMembers.add",
          "args": [
            "memberInfo"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arena.allocate<MemberInfo>",
          "args": [
            "parent",
            "i",
            "param",
            "layout",
            "false"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "params"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nkj::Array<BrandedDecl> params;\nstd::multimap<uint, MemberInfo*> membersByOrdinal;\nkj::Vector<MemberInfo*> allMembers;\nuint i = 0;\n\nvoid traverseParams(List<Declaration::Param>::Reader params, MemberInfo& parent,\n                      StructLayout::StructOrGroup& layout) {\n    for (uint i: kj::indices(params)) {\n      auto param = params[i];\n      parent.childCount++;\n      MemberInfo* memberInfo = &arena.allocate<MemberInfo>(parent, i, param, layout, false);\n      allMembers.add(memberInfo);\n      membersByOrdinal.insert(std::make_pair(i, memberInfo));\n    }\n  }"
  },
  {
    "function_name": "traverseTopOrGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1934-2000",
    "snippet": "void traverseTopOrGroup(List<Declaration>::Reader members, MemberInfo& parent,\n                          StructLayout::StructOrGroup& layout) {\n    uint codeOrder = 0;\n\n    for (auto member: members) {\n      kj::Maybe<uint> ordinal;\n      MemberInfo* memberInfo = nullptr;\n\n      switch (member.which()) {\n        case Declaration::FIELD: {\n          parent.childCount++;\n          memberInfo = &arena.allocate<MemberInfo>(\n              parent, codeOrder++, member, layout, false);\n          allMembers.add(memberInfo);\n          ordinal = member.getId().getOrdinal().getValue();\n          break;\n        }\n\n        case Declaration::UNION: {\n          StructLayout::Union& unionLayout = arena.allocate<StructLayout::Union>(layout);\n\n          uint independentSubCodeOrder = 0;\n          uint* subCodeOrder = &independentSubCodeOrder;\n          if (member.getName().getValue() == \"\") {\n            memberInfo = &parent;\n            subCodeOrder = &codeOrder;\n          } else {\n            parent.childCount++;\n            memberInfo = &arena.allocate<MemberInfo>(\n                parent, codeOrder++, member,\n                newGroupNode(parent.node, member.getName().getValue()),\n                false);\n            allMembers.add(memberInfo);\n          }\n          memberInfo->unionScope = &unionLayout;\n          traverseUnion(member, member.getNestedDecls(), *memberInfo, unionLayout, *subCodeOrder);\n          if (member.getId().isOrdinal()) {\n            ordinal = member.getId().getOrdinal().getValue();\n          }\n          break;\n        }\n\n        case Declaration::GROUP:\n          parent.childCount++;\n          memberInfo = &arena.allocate<MemberInfo>(\n              parent, codeOrder++, member,\n              newGroupNode(parent.node, member.getName().getValue()),\n              false);\n          allMembers.add(memberInfo);\n\n          // Members of the group are laid out just like they were members of the parent, so we\n          // just pass along the parent layout.\n          traverseGroup(member.getNestedDecls(), *memberInfo, layout);\n\n          // No ordinal for groups.\n          break;\n\n        default:\n          // Ignore others.\n          break;\n      }\n\n      KJ_IF_MAYBE(o, ordinal) {\n        membersByOrdinal.insert(std::make_pair(*o, memberInfo));\n      }\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "std::multimap<uint, MemberInfo*> membersByOrdinal;",
      "kj::Vector<MemberInfo*> allMembers;",
      "uint codeOrder = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "membersByOrdinal.insert",
          "args": [
            "std::make_pair(*o, memberInfo)"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "*o",
            "memberInfo"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traverseGroup",
          "args": [
            "member.getNestedDecls()",
            "*memberInfo",
            "layout"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "traverseGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1924-1932",
          "snippet": "void traverseGroup(List<Declaration>::Reader members, MemberInfo& parent,\n                     StructLayout::StructOrGroup& layout) {\n    if (members.size() < 1) {\n      errorReporter.addError(parent.startByte, parent.endByte,\n                             \"Group must have at least one member.\");\n    }\n\n    traverseTopOrGroup(members, parent, layout);\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid traverseGroup(List<Declaration>::Reader members, MemberInfo& parent,\n                     StructLayout::StructOrGroup& layout) {\n    if (members.size() < 1) {\n      errorReporter.addError(parent.startByte, parent.endByte,\n                             \"Group must have at least one member.\");\n    }\n\n    traverseTopOrGroup(members, parent, layout);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "member.getNestedDecls",
          "args": [],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allMembers.add",
          "args": [
            "memberInfo"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arena.allocate<MemberInfo>",
          "args": [
            "parent",
            "codeOrder++",
            "member",
            "newGroupNode(parent.node, member.getName().getValue())",
            "false"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newGroupNode",
          "args": [
            "parent.node",
            "member.getName().getValue()"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "newGroupNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2013-2027",
          "snippet": "schema::Node::Builder newGroupNode(schema::Node::Reader parent, kj::StringPtr name) {\n    auto orphan = translator.orphanage.newOrphan<schema::Node>();\n    auto node = orphan.get();\n\n    // We'll set the ID and scope ID later.\n    node.setDisplayName(kj::str(parent.getDisplayName(), '.', name));\n    node.setDisplayNamePrefixLength(node.getDisplayName().size() - name.size());\n    node.setIsGeneric(parent.getIsGeneric());\n    node.initStruct().setIsGroup(true);\n\n    // The remaining contents of node.struct will be filled in later.\n\n    translator.groups.add(kj::mv(orphan));\n    return node;\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "static kj::String expressionString(Expression::Reader name);",
            "static kj::String expressionString(Expression::Reader name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\n\nschema::Node::Builder newGroupNode(schema::Node::Reader parent, kj::StringPtr name) {\n    auto orphan = translator.orphanage.newOrphan<schema::Node>();\n    auto node = orphan.get();\n\n    // We'll set the ID and scope ID later.\n    node.setDisplayName(kj::str(parent.getDisplayName(), '.', name));\n    node.setDisplayNamePrefixLength(node.getDisplayName().size() - name.size());\n    node.setIsGeneric(parent.getIsGeneric());\n    node.initStruct().setIsGroup(true);\n\n    // The remaining contents of node.struct will be filled in later.\n\n    translator.groups.add(kj::mv(orphan));\n    return node;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getId",
          "args": [],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "traverseUnion",
          "args": [
            "member",
            "member.getNestedDecls()",
            "*memberInfo",
            "unionLayout",
            "*subCodeOrder"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getNestedDecls",
          "args": [],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<MemberInfo>",
          "args": [
            "parent",
            "codeOrder++",
            "member",
            "newGroupNode(parent.node, member.getName().getValue())",
            "false"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<StructLayout::Union>",
          "args": [
            "layout"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<MemberInfo>",
          "args": [
            "parent",
            "codeOrder++",
            "member",
            "layout",
            "false"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.which",
          "args": [],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nstd::multimap<uint, MemberInfo*> membersByOrdinal;\nkj::Vector<MemberInfo*> allMembers;\nuint codeOrder = 0;\n\nvoid traverseTopOrGroup(List<Declaration>::Reader members, MemberInfo& parent,\n                          StructLayout::StructOrGroup& layout) {\n    uint codeOrder = 0;\n\n    for (auto member: members) {\n      kj::Maybe<uint> ordinal;\n      MemberInfo* memberInfo = nullptr;\n\n      switch (member.which()) {\n        case Declaration::FIELD: {\n          parent.childCount++;\n          memberInfo = &arena.allocate<MemberInfo>(\n              parent, codeOrder++, member, layout, false);\n          allMembers.add(memberInfo);\n          ordinal = member.getId().getOrdinal().getValue();\n          break;\n        }\n\n        case Declaration::UNION: {\n          StructLayout::Union& unionLayout = arena.allocate<StructLayout::Union>(layout);\n\n          uint independentSubCodeOrder = 0;\n          uint* subCodeOrder = &independentSubCodeOrder;\n          if (member.getName().getValue() == \"\") {\n            memberInfo = &parent;\n            subCodeOrder = &codeOrder;\n          } else {\n            parent.childCount++;\n            memberInfo = &arena.allocate<MemberInfo>(\n                parent, codeOrder++, member,\n                newGroupNode(parent.node, member.getName().getValue()),\n                false);\n            allMembers.add(memberInfo);\n          }\n          memberInfo->unionScope = &unionLayout;\n          traverseUnion(member, member.getNestedDecls(), *memberInfo, unionLayout, *subCodeOrder);\n          if (member.getId().isOrdinal()) {\n            ordinal = member.getId().getOrdinal().getValue();\n          }\n          break;\n        }\n\n        case Declaration::GROUP:\n          parent.childCount++;\n          memberInfo = &arena.allocate<MemberInfo>(\n              parent, codeOrder++, member,\n              newGroupNode(parent.node, member.getName().getValue()),\n              false);\n          allMembers.add(memberInfo);\n\n          // Members of the group are laid out just like they were members of the parent, so we\n          // just pass along the parent layout.\n          traverseGroup(member.getNestedDecls(), *memberInfo, layout);\n\n          // No ordinal for groups.\n          break;\n\n        default:\n          // Ignore others.\n          break;\n      }\n\n      KJ_IF_MAYBE(o, ordinal) {\n        membersByOrdinal.insert(std::make_pair(*o, memberInfo));\n      }\n    }\n  }"
  },
  {
    "function_name": "traverseGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1924-1932",
    "snippet": "void traverseGroup(List<Declaration>::Reader members, MemberInfo& parent,\n                     StructLayout::StructOrGroup& layout) {\n    if (members.size() < 1) {\n      errorReporter.addError(parent.startByte, parent.endByte,\n                             \"Group must have at least one member.\");\n    }\n\n    traverseTopOrGroup(members, parent, layout);\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "traverseTopOrGroup",
          "args": [
            "members",
            "parent",
            "layout"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorReporter.addError",
          "args": [
            "parent.startByte",
            "parent.endByte",
            "\"Group must have at least one member.\""
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": "TestFailingErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/lexer-test.c++",
          "lines": "32-34",
          "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"../message.h\"",
            "#include \"lexer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"../message.h\"\n#include \"lexer.h\"\n\nTestFailingErrorReporter {\n  void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n      KJ_FAIL_EXPECT(\"Parse failed.\", startByte, endByte, message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "members.size",
          "args": [],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid traverseGroup(List<Declaration>::Reader members, MemberInfo& parent,\n                     StructLayout::StructOrGroup& layout) {\n    if (members.size() < 1) {\n      errorReporter.addError(parent.startByte, parent.endByte,\n                             \"Group must have at least one member.\");\n    }\n\n    traverseTopOrGroup(members, parent, layout);\n  }"
  },
  {
    "function_name": "traverseUnion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1852-1922",
    "snippet": "void traverseUnion(const Declaration::Reader& decl,\n                     List<Declaration>::Reader members, MemberInfo& parent,\n                     StructLayout::Union& layout, uint& codeOrder) {\n    if (members.size() < 2) {\n      errorReporter.addErrorOn(decl, \"Union must have at least two members.\");\n    }\n\n    for (auto member: members) {\n      kj::Maybe<uint> ordinal;\n      MemberInfo* memberInfo = nullptr;\n\n      switch (member.which()) {\n        case Declaration::FIELD: {\n          parent.childCount++;\n          // For layout purposes, pretend this field is enclosed in a one-member group.\n          StructLayout::Group& singletonGroup =\n              arena.allocate<StructLayout::Group>(layout);\n          memberInfo = &arena.allocate<MemberInfo>(parent, codeOrder++, member, singletonGroup,\n                                                   true);\n          allMembers.add(memberInfo);\n          ordinal = member.getId().getOrdinal().getValue();\n          break;\n        }\n\n        case Declaration::UNION:\n          if (member.getName().getValue() == \"\") {\n            errorReporter.addErrorOn(member, \"Unions cannot contain unnamed unions.\");\n          } else {\n            parent.childCount++;\n\n            // For layout purposes, pretend this union is enclosed in a one-member group.\n            StructLayout::Group& singletonGroup =\n                arena.allocate<StructLayout::Group>(layout);\n            StructLayout::Union& unionLayout = arena.allocate<StructLayout::Union>(singletonGroup);\n\n            memberInfo = &arena.allocate<MemberInfo>(\n                parent, codeOrder++, member,\n                newGroupNode(parent.node, member.getName().getValue()),\n                true);\n            allMembers.add(memberInfo);\n            memberInfo->unionScope = &unionLayout;\n            uint subCodeOrder = 0;\n            traverseUnion(member, member.getNestedDecls(), *memberInfo, unionLayout, subCodeOrder);\n            if (member.getId().isOrdinal()) {\n              ordinal = member.getId().getOrdinal().getValue();\n            }\n          }\n          break;\n\n        case Declaration::GROUP: {\n          parent.childCount++;\n          StructLayout::Group& group = arena.allocate<StructLayout::Group>(layout);\n          memberInfo = &arena.allocate<MemberInfo>(\n              parent, codeOrder++, member,\n              newGroupNode(parent.node, member.getName().getValue()),\n              true);\n          allMembers.add(memberInfo);\n          traverseGroup(member.getNestedDecls(), *memberInfo, group);\n          break;\n        }\n\n        default:\n          // Ignore others.\n          break;\n      }\n\n      KJ_IF_MAYBE(o, ordinal) {\n        membersByOrdinal.insert(std::make_pair(*o, memberInfo));\n      }\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "std::multimap<uint, MemberInfo*> membersByOrdinal;",
      "kj::Vector<MemberInfo*> allMembers;",
      "uint codeOrder = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "membersByOrdinal.insert",
          "args": [
            "std::make_pair(*o, memberInfo)"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "*o",
            "memberInfo"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traverseGroup",
          "args": [
            "member.getNestedDecls()",
            "*memberInfo",
            "group"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "traverseGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1924-1932",
          "snippet": "void traverseGroup(List<Declaration>::Reader members, MemberInfo& parent,\n                     StructLayout::StructOrGroup& layout) {\n    if (members.size() < 1) {\n      errorReporter.addError(parent.startByte, parent.endByte,\n                             \"Group must have at least one member.\");\n    }\n\n    traverseTopOrGroup(members, parent, layout);\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid traverseGroup(List<Declaration>::Reader members, MemberInfo& parent,\n                     StructLayout::StructOrGroup& layout) {\n    if (members.size() < 1) {\n      errorReporter.addError(parent.startByte, parent.endByte,\n                             \"Group must have at least one member.\");\n    }\n\n    traverseTopOrGroup(members, parent, layout);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "member.getNestedDecls",
          "args": [],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allMembers.add",
          "args": [
            "memberInfo"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arena.allocate<MemberInfo>",
          "args": [
            "parent",
            "codeOrder++",
            "member",
            "newGroupNode(parent.node, member.getName().getValue())",
            "true"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newGroupNode",
          "args": [
            "parent.node",
            "member.getName().getValue()"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "newGroupNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2013-2027",
          "snippet": "schema::Node::Builder newGroupNode(schema::Node::Reader parent, kj::StringPtr name) {\n    auto orphan = translator.orphanage.newOrphan<schema::Node>();\n    auto node = orphan.get();\n\n    // We'll set the ID and scope ID later.\n    node.setDisplayName(kj::str(parent.getDisplayName(), '.', name));\n    node.setDisplayNamePrefixLength(node.getDisplayName().size() - name.size());\n    node.setIsGeneric(parent.getIsGeneric());\n    node.initStruct().setIsGroup(true);\n\n    // The remaining contents of node.struct will be filled in later.\n\n    translator.groups.add(kj::mv(orphan));\n    return node;\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "static kj::String expressionString(Expression::Reader name);",
            "static kj::String expressionString(Expression::Reader name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\n\nschema::Node::Builder newGroupNode(schema::Node::Reader parent, kj::StringPtr name) {\n    auto orphan = translator.orphanage.newOrphan<schema::Node>();\n    auto node = orphan.get();\n\n    // We'll set the ID and scope ID later.\n    node.setDisplayName(kj::str(parent.getDisplayName(), '.', name));\n    node.setDisplayNamePrefixLength(node.getDisplayName().size() - name.size());\n    node.setIsGeneric(parent.getIsGeneric());\n    node.initStruct().setIsGroup(true);\n\n    // The remaining contents of node.struct will be filled in later.\n\n    translator.groups.add(kj::mv(orphan));\n    return node;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<StructLayout::Group>",
          "args": [
            "layout"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getId",
          "args": [],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "traverseUnion",
          "args": [
            "member",
            "member.getNestedDecls()",
            "*memberInfo",
            "unionLayout",
            "subCodeOrder"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getNestedDecls",
          "args": [],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<MemberInfo>",
          "args": [
            "parent",
            "codeOrder++",
            "member",
            "newGroupNode(parent.node, member.getName().getValue())",
            "true"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<StructLayout::Union>",
          "args": [
            "singletonGroup"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<StructLayout::Group>",
          "args": [
            "layout"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "member",
            "\"Unions cannot contain unnamed unions.\""
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.getName",
          "args": [],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<MemberInfo>",
          "args": [
            "parent",
            "codeOrder++",
            "member",
            "singletonGroup",
            "true"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena.allocate<StructLayout::Group>",
          "args": [
            "layout"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.which",
          "args": [],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "members.size",
          "args": [],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nstd::multimap<uint, MemberInfo*> membersByOrdinal;\nkj::Vector<MemberInfo*> allMembers;\nuint codeOrder = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid traverseUnion(const Declaration::Reader& decl,\n                     List<Declaration>::Reader members, MemberInfo& parent,\n                     StructLayout::Union& layout, uint& codeOrder) {\n    if (members.size() < 2) {\n      errorReporter.addErrorOn(decl, \"Union must have at least two members.\");\n    }\n\n    for (auto member: members) {\n      kj::Maybe<uint> ordinal;\n      MemberInfo* memberInfo = nullptr;\n\n      switch (member.which()) {\n        case Declaration::FIELD: {\n          parent.childCount++;\n          // For layout purposes, pretend this field is enclosed in a one-member group.\n          StructLayout::Group& singletonGroup =\n              arena.allocate<StructLayout::Group>(layout);\n          memberInfo = &arena.allocate<MemberInfo>(parent, codeOrder++, member, singletonGroup,\n                                                   true);\n          allMembers.add(memberInfo);\n          ordinal = member.getId().getOrdinal().getValue();\n          break;\n        }\n\n        case Declaration::UNION:\n          if (member.getName().getValue() == \"\") {\n            errorReporter.addErrorOn(member, \"Unions cannot contain unnamed unions.\");\n          } else {\n            parent.childCount++;\n\n            // For layout purposes, pretend this union is enclosed in a one-member group.\n            StructLayout::Group& singletonGroup =\n                arena.allocate<StructLayout::Group>(layout);\n            StructLayout::Union& unionLayout = arena.allocate<StructLayout::Union>(singletonGroup);\n\n            memberInfo = &arena.allocate<MemberInfo>(\n                parent, codeOrder++, member,\n                newGroupNode(parent.node, member.getName().getValue()),\n                true);\n            allMembers.add(memberInfo);\n            memberInfo->unionScope = &unionLayout;\n            uint subCodeOrder = 0;\n            traverseUnion(member, member.getNestedDecls(), *memberInfo, unionLayout, subCodeOrder);\n            if (member.getId().isOrdinal()) {\n              ordinal = member.getId().getOrdinal().getValue();\n            }\n          }\n          break;\n\n        case Declaration::GROUP: {\n          parent.childCount++;\n          StructLayout::Group& group = arena.allocate<StructLayout::Group>(layout);\n          memberInfo = &arena.allocate<MemberInfo>(\n              parent, codeOrder++, member,\n              newGroupNode(parent.node, member.getName().getValue()),\n              true);\n          allMembers.add(memberInfo);\n          traverseGroup(member.getNestedDecls(), *memberInfo, group);\n          break;\n        }\n\n        default:\n          // Ignore others.\n          break;\n      }\n\n      KJ_IF_MAYBE(o, ordinal) {\n        membersByOrdinal.insert(std::make_pair(*o, memberInfo));\n      }\n    }\n  }"
  },
  {
    "function_name": "finishGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1828-1842",
    "snippet": "void finishGroup() {\n      if (unionScope != nullptr) {\n        unionScope->addDiscriminant();  // if it hasn't happened already\n        auto structNode = node.getStruct();\n        structNode.setDiscriminantCount(unionDiscriminantCount);\n        structNode.setDiscriminantOffset(KJ_ASSERT_NONNULL(unionScope->discriminantOffset));\n      }\n\n      if (parent != nullptr) {\n        uint64_t groupId = generateGroupId(parent->node.getId(), index);\n        node.setId(groupId);\n        node.setScopeId(parent->node.getId());\n        getSchema().initGroup().setTypeId(groupId);\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);",
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getSchema",
          "args": [
            "groupId"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getSchema",
          "args": [],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      },
      {
        "call_info": {
          "callee": "node.setScopeId",
          "args": [
            "parent->node.getId()"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent->node.getId",
          "args": [],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "node.setId",
          "args": [
            "groupId"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generateGroupId",
          "args": [
            "parent->node.getId()",
            "index"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "generateGroupId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "85-108",
          "snippet": "uint64_t generateGroupId(uint64_t parentId, uint16_t groupIndex) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID and the group index, and\n  // then taking the first 8 bytes.\n\n  kj::byte bytes[sizeof(uint64_t) + sizeof(uint16_t)];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    bytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n  for (uint i = 0; i < sizeof(uint16_t); i++) {\n    bytes[sizeof(uint64_t) + i] = (groupIndex >> (i * 8)) & 0xff;\n  }\n\n  Md5 md5;\n  md5.update(bytes);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nuint64_t generateGroupId(uint64_t parentId, uint16_t groupIndex) {\n  // Compute ID by MD5 hashing the concatenation of the parent ID and the group index, and\n  // then taking the first 8 bytes.\n\n  kj::byte bytes[sizeof(uint64_t) + sizeof(uint16_t)];\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    bytes[i] = (parentId >> (i * 8)) & 0xff;\n  }\n  for (uint i = 0; i < sizeof(uint16_t); i++) {\n    bytes[sizeof(uint64_t) + i] = (groupIndex >> (i * 8)) & 0xff;\n  }\n\n  Md5 md5;\n  md5.update(bytes);\n\n  kj::ArrayPtr<const kj::byte> resultBytes = md5.finish();\n\n  uint64_t result = 0;\n  for (uint i = 0; i < sizeof(uint64_t); i++) {\n    result = (result << 8) | resultBytes[i];\n  }\n\n  return result | (1ull << 63);\n}"
        }
      },
      {
        "call_info": {
          "callee": "structNode.setDiscriminantOffset",
          "args": [
            "KJ_ASSERT_NONNULL(unionScope->discriminantOffset)"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "unionScope->discriminantOffset"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structNode.setDiscriminantCount",
          "args": [
            "unionDiscriminantCount"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node.getStruct",
          "args": [],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unionScope->addDiscriminant",
          "args": [],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "addDiscriminant",
          "container": "Union",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "257-264",
          "snippet": "bool addDiscriminant() {\n      if (discriminantOffset == nullptr) {\n        discriminantOffset = parent.addData(4);  // 2^4 = 16 bits\n        return true;\n      } else {\n        return false;\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  bool addDiscriminant() {\n        if (discriminantOffset == nullptr) {\n          discriminantOffset = parent.addData(4);  // 2^4 = 16 bits\n          return true;\n        } else {\n          return false;\n        }\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nvoid finishGroup() {\n      if (unionScope != nullptr) {\n        unionScope->addDiscriminant();  // if it hasn't happened already\n        auto structNode = node.getStruct();\n        structNode.setDiscriminantCount(unionDiscriminantCount);\n        structNode.setDiscriminantOffset(KJ_ASSERT_NONNULL(unionScope->discriminantOffset));\n      }\n\n      if (parent != nullptr) {\n        uint64_t groupId = generateGroupId(parent->node.getId(), index);\n        node.setId(groupId);\n        node.setScopeId(parent->node.getId());\n        getSchema().initGroup().setTypeId(groupId);\n      }\n    }"
  },
  {
    "function_name": "translate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1680-1685",
    "snippet": "void translate(List<Declaration::Param>::Reader params, schema::Node::Builder builder) {\n    // Build a struct from a method param / result list.\n    MemberInfo root(builder);\n    traverseParams(params, root, layout.getTop());\n    translateInternal(root, builder);\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Array<BrandedDecl> params;",
      "auto list = interfaceBuilder.initMethods(methods.size());"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "translateInternal",
          "args": [
            "root",
            "builder"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traverseParams",
          "args": [
            "params",
            "root",
            "layout.getTop()"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "traverseParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2002-2011",
          "snippet": "void traverseParams(List<Declaration::Param>::Reader params, MemberInfo& parent,\n                      StructLayout::StructOrGroup& layout) {\n    for (uint i: kj::indices(params)) {\n      auto param = params[i];\n      parent.childCount++;\n      MemberInfo* memberInfo = &arena.allocate<MemberInfo>(parent, i, param, layout, false);\n      allMembers.add(memberInfo);\n      membersByOrdinal.insert(std::make_pair(i, memberInfo));\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "kj::Array<BrandedDecl> params;",
            "std::multimap<uint, MemberInfo*> membersByOrdinal;",
            "kj::Vector<MemberInfo*> allMembers;",
            "uint i = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nkj::Array<BrandedDecl> params;\nstd::multimap<uint, MemberInfo*> membersByOrdinal;\nkj::Vector<MemberInfo*> allMembers;\nuint i = 0;\n\nvoid traverseParams(List<Declaration::Param>::Reader params, MemberInfo& parent,\n                      StructLayout::StructOrGroup& layout) {\n    for (uint i: kj::indices(params)) {\n      auto param = params[i];\n      parent.childCount++;\n      MemberInfo* memberInfo = &arena.allocate<MemberInfo>(parent, i, param, layout, false);\n      allMembers.add(memberInfo);\n      membersByOrdinal.insert(std::make_pair(i, memberInfo));\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "layout.getTop",
          "args": [],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Array<BrandedDecl> params;\nauto list = interfaceBuilder.initMethods(methods.size());\n\nvoid translate(List<Declaration::Param>::Reader params, schema::Node::Builder builder) {\n    // Build a struct from a method param / result list.\n    MemberInfo root(builder);\n    traverseParams(params, root, layout.getTop());\n    translateInternal(root, builder);\n  }"
  },
  {
    "function_name": "translate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1673-1678",
    "snippet": "void translate(Void decl, List<Declaration>::Reader members, schema::Node::Builder builder) {\n    // Build the member-info-by-ordinal map.\n    MemberInfo root(builder);\n    traverseTopOrGroup(members, root, layout.getTop());\n    translateInternal(root, builder);\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "translateInternal",
          "args": [
            "root",
            "builder"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "traverseTopOrGroup",
          "args": [
            "members",
            "root",
            "layout.getTop()"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layout.getTop",
          "args": [],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nvoid translate(Void decl, List<Declaration>::Reader members, schema::Node::Builder builder) {\n    // Build the member-info-by-ordinal map.\n    MemberInfo root(builder);\n    traverseTopOrGroup(members, root, layout.getTop());\n    translateInternal(root, builder);\n  }"
  },
  {
    "function_name": "StructTranslator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1668-1670",
    "snippet": "explicit StructTranslator(NodeTranslator& translator, ImplicitParams implicitMethodParams)\n      : translator(translator), errorReporter(translator.errorReporter),\n        implicitMethodParams(implicitMethodParams) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nexplicit StructTranslator(NodeTranslator& translator, ImplicitParams implicitMethodParams)\n      : translator(translator), errorReporter(translator.errorReporter),\n        implicitMethodParams(implicitMethodParams) {}"
  },
  {
    "function_name": "NodeTranslator::compileEnum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1631-1662",
    "snippet": "void NodeTranslator::compileEnum(Void decl,\n                                 List<Declaration>::Reader members,\n                                 schema::Node::Builder builder) {\n  // maps ordinal -> (code order, declaration)\n  std::multimap<uint, std::pair<uint, Declaration::Reader>> enumerants;\n\n  uint codeOrder = 0;\n  for (auto member: members) {\n    if (member.isEnumerant()) {\n      enumerants.insert(\n          std::make_pair(member.getId().getOrdinal().getValue(),\n                         std::make_pair(codeOrder++, member)));\n    }\n  }\n\n  auto list = builder.initEnum().initEnumerants(enumerants.size());\n  uint i = 0;\n  DuplicateOrdinalDetector dupDetector(errorReporter);\n\n  for (auto& entry: enumerants) {\n    uint codeOrder = entry.second.first;\n    Declaration::Reader enumerantDecl = entry.second.second;\n\n    dupDetector.check(enumerantDecl.getId().getOrdinal());\n\n    auto enumerantBuilder = list[i++];\n    enumerantBuilder.setName(enumerantDecl.getName().getValue());\n    enumerantBuilder.setCodeOrder(codeOrder);\n    enumerantBuilder.adoptAnnotations(compileAnnotationApplications(\n        enumerantDecl.getAnnotations(), \"targetsEnumerant\"));\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint codeOrder = 0;",
      "auto list = interfaceBuilder.initMethods(methods.size());",
      "uint i = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enumerantBuilder.adoptAnnotations",
          "args": [
            "compileAnnotationApplications(\n        enumerantDecl.getAnnotations(), \"targetsEnumerant\")"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileAnnotationApplications",
          "args": [
            "enumerantDecl.getAnnotations()",
            "\"targetsEnumerant\""
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerantDecl.getAnnotations",
          "args": [],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerantBuilder.setCodeOrder",
          "args": [
            "codeOrder"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerantBuilder.setName",
          "args": [
            "enumerantDecl.getName().getValue()"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerantDecl.getName",
          "args": [],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerantDecl.getName",
          "args": [],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dupDetector.check",
          "args": [
            "enumerantDecl.getId().getOrdinal()"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "check",
          "container": "TextChecker",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/fuzz-test.c++",
          "lines": "199-205",
          "snippet": "static uint check(ReaderOrBuilder& message) {\n    uint result = 0;\n    for (auto c: message.template getRoot<Text>()) {\n      result += c;\n    }\n    return result;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <kj/test.h>",
            "#include \"serialize.h\"",
            "#include \"message.h\"",
            "#include <capnp/test-import2.capnp.h>",
            "#include <capnp/test-import.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <kj/test.h>\n#include \"serialize.h\"\n#include \"message.h\"\n#include <capnp/test-import2.capnp.h>\n#include <capnp/test-import.capnp.h>\n\nTextChecker {\n  static uint check(ReaderOrBuilder& message) {\n      uint result = 0;\n      for (auto c: message.template getRoot<Text>()) {\n        result += c;\n      }\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "enumerantDecl.getId",
          "args": [],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "builder.initEnum",
          "args": [
            "enumerants.size()"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerants.size",
          "args": [],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initEnum",
          "args": [],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerants.insert",
          "args": [
            "std::make_pair(member.getId().getOrdinal().getValue(),\n                         std::make_pair(codeOrder++, member))"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "member.getId().getOrdinal().getValue()",
            "std::make_pair(codeOrder++, member)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "codeOrder++",
            "member"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "member.isEnumerant",
          "args": [],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint codeOrder = 0;\nauto list = interfaceBuilder.initMethods(methods.size());\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid NodeTranslator::compileEnum(Void decl,\n                                 List<Declaration>::Reader members,\n                                 schema::Node::Builder builder) {\n  // maps ordinal -> (code order, declaration)\n  std::multimap<uint, std::pair<uint, Declaration::Reader>> enumerants;\n\n  uint codeOrder = 0;\n  for (auto member: members) {\n    if (member.isEnumerant()) {\n      enumerants.insert(\n          std::make_pair(member.getId().getOrdinal().getValue(),\n                         std::make_pair(codeOrder++, member)));\n    }\n  }\n\n  auto list = builder.initEnum().initEnumerants(enumerants.size());\n  uint i = 0;\n  DuplicateOrdinalDetector dupDetector(errorReporter);\n\n  for (auto& entry: enumerants) {\n    uint codeOrder = entry.second.first;\n    Declaration::Reader enumerantDecl = entry.second.second;\n\n    dupDetector.check(enumerantDecl.getId().getOrdinal());\n\n    auto enumerantBuilder = list[i++];\n    enumerantBuilder.setName(enumerantDecl.getName().getValue());\n    enumerantBuilder.setCodeOrder(codeOrder);\n    enumerantBuilder.adoptAnnotations(compileAnnotationApplications(\n        enumerantDecl.getAnnotations(), \"targetsEnumerant\"));\n  }\n}"
  },
  {
    "function_name": "check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1605-1623",
    "snippet": "void check(LocatedInteger::Reader ordinal) {\n    if (ordinal.getValue() < expectedOrdinal) {\n      errorReporter.addErrorOn(ordinal, \"Duplicate ordinal number.\");\n      KJ_IF_MAYBE(last, lastOrdinalLocation) {\n        errorReporter.addErrorOn(\n            *last, kj::str(\"Ordinal @\", last->getValue(), \" originally used here.\"));\n        // Don't report original again.\n        lastOrdinalLocation = nullptr;\n      }\n    } else if (ordinal.getValue() > expectedOrdinal) {\n      errorReporter.addErrorOn(ordinal,\n          kj::str(\"Skipped ordinal @\", expectedOrdinal, \".  Ordinals must be sequential with no \"\n                  \"holes.\"));\n      expectedOrdinal = ordinal.getValue() + 1;\n    } else {\n      ++expectedOrdinal;\n      lastOrdinalLocation = ordinal;\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ordinal.getValue",
          "args": [],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "ordinal",
            "kj::str(\"Skipped ordinal @\", expectedOrdinal, \".  Ordinals must be sequential with no \"\n                  \"holes.\")"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Skipped ordinal @\"",
            "expectedOrdinal",
            "\".  Ordinals must be sequential with no \"\n                  \"holes.\""
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ordinal.getValue",
          "args": [],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Ordinal @\"",
            "last->getValue()",
            "\" originally used here.\""
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last->getValue",
          "args": [],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ordinal.getValue",
          "args": [],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid check(LocatedInteger::Reader ordinal) {\n    if (ordinal.getValue() < expectedOrdinal) {\n      errorReporter.addErrorOn(ordinal, \"Duplicate ordinal number.\");\n      KJ_IF_MAYBE(last, lastOrdinalLocation) {\n        errorReporter.addErrorOn(\n            *last, kj::str(\"Ordinal @\", last->getValue(), \" originally used here.\"));\n        // Don't report original again.\n        lastOrdinalLocation = nullptr;\n      }\n    } else if (ordinal.getValue() > expectedOrdinal) {\n      errorReporter.addErrorOn(ordinal,\n          kj::str(\"Skipped ordinal @\", expectedOrdinal, \".  Ordinals must be sequential with no \"\n                  \"holes.\"));\n      expectedOrdinal = ordinal.getValue() + 1;\n    } else {\n      ++expectedOrdinal;\n      lastOrdinalLocation = ordinal;\n    }\n  }"
  },
  {
    "function_name": "DuplicateOrdinalDetector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1603-1603",
    "snippet": "DuplicateOrdinalDetector(ErrorReporter& errorReporter): errorReporter(errorReporter) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nDuplicateOrdinalDetector(ErrorReporter& errorReporter): errorReporter(errorReporter) {}"
  },
  {
    "function_name": "NodeTranslator::compileAnnotation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1585-1599",
    "snippet": "void NodeTranslator::compileAnnotation(Declaration::Annotation::Reader decl,\n                                       schema::Node::Annotation::Builder builder) {\n  compileType(decl.getType(), builder.initType(), noImplicitParams());\n\n  // Dynamically copy over the values of all of the \"targets\" members.\n  DynamicStruct::Reader src = decl;\n  DynamicStruct::Builder dst = builder;\n  for (auto srcField: src.getSchema().getFields()) {\n    kj::StringPtr fieldName = srcField.getProto().getName();\n    if (fieldName.startsWith(\"targets\")) {\n      auto dstField = dst.getSchema().getFieldByName(fieldName);\n      dst.set(dstField, src.get(srcField));\n    }\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dst.set",
          "args": [
            "dstField",
            "src.get(srcField)"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "872-874",
          "snippet": "static inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline void set(PointerBuilder builder, AnyList::Reader value) {\n    builder.setList(value._reader);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "src.get",
          "args": [
            "srcField"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "dst.getSchema",
          "args": [
            "fieldName"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst.getSchema",
          "args": [],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      },
      {
        "call_info": {
          "callee": "fieldName.startsWith",
          "args": [
            "\"targets\""
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcField.getProto",
          "args": [],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "compileType",
          "args": [
            "decl.getType()",
            "builder.initType()",
            "noImplicitParams()"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "noImplicitParams",
          "args": [],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "noImplicitParams",
          "container": "NodeTranslator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.h",
          "lines": "225-227",
          "snippet": "static inline ImplicitParams noImplicitParams() {\n    return { 0, List<Declaration::BrandParameter>::Reader() };\n  }",
          "includes": [
            "#include \"error-reporter.h\"",
            "#include <kj/one-of.h>",
            "#include <kj/vector.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/orphan.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error-reporter.h\"\n#include <kj/one-of.h>\n#include <kj/vector.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/orphan.h>\n\nNodeTranslator {\n  static inline ImplicitParams noImplicitParams() {\n      return { 0, List<Declaration::BrandParameter>::Reader() };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initType",
          "args": [],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getType",
          "args": [],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nvoid NodeTranslator::compileAnnotation(Declaration::Annotation::Reader decl,\n                                       schema::Node::Annotation::Builder builder) {\n  compileType(decl.getType(), builder.initType(), noImplicitParams());\n\n  // Dynamically copy over the values of all of the \"targets\" members.\n  DynamicStruct::Reader src = decl;\n  DynamicStruct::Builder dst = builder;\n  for (auto srcField: src.getSchema().getFields()) {\n    kj::StringPtr fieldName = srcField.getProto().getName();\n    if (fieldName.startsWith(\"targets\")) {\n      auto dstField = dst.getSchema().getFieldByName(fieldName);\n      dst.set(dstField, src.get(srcField));\n    }\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::compileConst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1577-1583",
    "snippet": "void NodeTranslator::compileConst(Declaration::Const::Reader decl,\n                                  schema::Node::Const::Builder builder) {\n  auto typeBuilder = builder.initType();\n  if (compileType(decl.getType(), typeBuilder, noImplicitParams())) {\n    compileBootstrapValue(decl.getValue(), typeBuilder.asReader(), builder.initValue());\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compileBootstrapValue",
          "args": [
            "decl.getValue()",
            "typeBuilder.asReader()",
            "builder.initValue()"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.initValue",
          "args": [],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeBuilder.asReader",
          "args": [],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "asReader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3149-3149",
          "snippet": "inline Reader asReader() const { return *this; }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline Reader asReader() const { return *this; }"
        }
      },
      {
        "call_info": {
          "callee": "decl.getValue",
          "args": [],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileType",
          "args": [
            "decl.getType()",
            "typeBuilder",
            "noImplicitParams()"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "noImplicitParams",
          "args": [],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "noImplicitParams",
          "container": "NodeTranslator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.h",
          "lines": "225-227",
          "snippet": "static inline ImplicitParams noImplicitParams() {\n    return { 0, List<Declaration::BrandParameter>::Reader() };\n  }",
          "includes": [
            "#include \"error-reporter.h\"",
            "#include <kj/one-of.h>",
            "#include <kj/vector.h>",
            "#include <capnp/dynamic.h>",
            "#include <capnp/schema.capnp.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/orphan.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"error-reporter.h\"\n#include <kj/one-of.h>\n#include <kj/vector.h>\n#include <capnp/dynamic.h>\n#include <capnp/schema.capnp.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/orphan.h>\n\nNodeTranslator {\n  static inline ImplicitParams noImplicitParams() {\n      return { 0, List<Declaration::BrandParameter>::Reader() };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.getType",
          "args": [],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "builder.initType",
          "args": [],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nvoid NodeTranslator::compileConst(Declaration::Const::Reader decl,\n                                  schema::Node::Const::Builder builder) {\n  auto typeBuilder = builder.initType();\n  if (compileType(decl.getType(), typeBuilder, noImplicitParams())) {\n    compileBootstrapValue(decl.getValue(), typeBuilder.asReader(), builder.initValue());\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::DuplicateNameDetector::check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1437-1575",
    "snippet": "void NodeTranslator::DuplicateNameDetector::check(\n    List<Declaration>::Reader nestedDecls, Declaration::Which parentKind) {\n  for (auto decl: nestedDecls) {\n    {\n      auto name = decl.getName();\n      auto nameText = name.getValue();\n      auto insertResult = names.insert(std::make_pair(nameText, name));\n      if (!insertResult.second) {\n        if (nameText.size() == 0 && decl.isUnion()) {\n          errorReporter.addErrorOn(\n              name, kj::str(\"An unnamed union is already defined in this scope.\"));\n          errorReporter.addErrorOn(\n              insertResult.first->second, kj::str(\"Previously defined here.\"));\n        } else {\n          errorReporter.addErrorOn(\n              name, kj::str(\"'\", nameText, \"' is already defined in this scope.\"));\n          errorReporter.addErrorOn(\n              insertResult.first->second, kj::str(\"'\", nameText, \"' previously defined here.\"));\n        }\n      }\n\n      switch (decl.which()) {\n        case Declaration::USING: {\n          kj::StringPtr targetName = getExpressionTargetName(decl.getUsing().getTarget());\n          if (targetName.size() > 0 && targetName[0] >= 'a' && targetName[0] <= 'z') {\n            // Target starts with lower-case letter, so alias should too.\n            if (nameText.size() > 0 && (nameText[0] < 'a' || nameText[0] > 'z')) {\n              errorReporter.addErrorOn(name,\n                  \"Non-type names must begin with a lower-case letter.\");\n            }\n          } else {\n            // Target starts with capital or is not named (probably, an import). Require\n            // capitalization.\n            if (nameText.size() > 0 && (nameText[0] < 'A' || nameText[0] > 'Z')) {\n              errorReporter.addErrorOn(name,\n                  \"Type names must begin with a capital letter.\");\n            }\n          }\n          break;\n        }\n\n        case Declaration::ENUM:\n        case Declaration::STRUCT:\n        case Declaration::INTERFACE:\n          if (nameText.size() > 0 && (nameText[0] < 'A' || nameText[0] > 'Z')) {\n            errorReporter.addErrorOn(name,\n                \"Type names must begin with a capital letter.\");\n          }\n          break;\n\n        case Declaration::CONST:\n        case Declaration::ANNOTATION:\n        case Declaration::ENUMERANT:\n        case Declaration::METHOD:\n        case Declaration::FIELD:\n        case Declaration::UNION:\n        case Declaration::GROUP:\n          if (nameText.size() > 0 && (nameText[0] < 'a' || nameText[0] > 'z')) {\n            errorReporter.addErrorOn(name,\n                \"Non-type names must begin with a lower-case letter.\");\n          }\n          break;\n\n        default:\n          KJ_ASSERT(nameText.size() == 0, \"Don't know what naming rules to enforce for node type.\",\n                    (uint)decl.which());\n          break;\n      }\n\n      if (nameText.findFirst('_') != nullptr) {\n        errorReporter.addErrorOn(name,\n            \"Cap'n Proto declaration names should use camelCase and must not contain \"\n            \"underscores. (Code generators may convert names to the appropriate style for the \"\n            \"target language.)\");\n      }\n    }\n\n    switch (decl.which()) {\n      case Declaration::USING:\n      case Declaration::CONST:\n      case Declaration::ENUM:\n      case Declaration::STRUCT:\n      case Declaration::INTERFACE:\n      case Declaration::ANNOTATION:\n        switch (parentKind) {\n          case Declaration::FILE:\n          case Declaration::STRUCT:\n          case Declaration::INTERFACE:\n            // OK.\n            break;\n          default:\n            errorReporter.addErrorOn(decl, \"This kind of declaration doesn't belong here.\");\n            break;\n        }\n        break;\n\n      case Declaration::ENUMERANT:\n        if (parentKind != Declaration::ENUM) {\n          errorReporter.addErrorOn(decl, \"Enumerants can only appear in enums.\");\n        }\n        break;\n      case Declaration::METHOD:\n        if (parentKind != Declaration::INTERFACE) {\n          errorReporter.addErrorOn(decl, \"Methods can only appear in interfaces.\");\n        }\n        break;\n      case Declaration::FIELD:\n      case Declaration::UNION:\n      case Declaration::GROUP:\n        switch (parentKind) {\n          case Declaration::STRUCT:\n          case Declaration::UNION:\n          case Declaration::GROUP:\n            // OK.\n            break;\n          default:\n            errorReporter.addErrorOn(decl, \"This declaration can only appear in structs.\");\n            break;\n        }\n\n        // Struct members may have nested decls.  We need to check those here, because no one else\n        // is going to do it.\n        if (decl.getName().getValue().size() == 0) {\n          // Unnamed union.  Check members as if they are in the same scope.\n          check(decl.getNestedDecls(), decl.which());\n        } else {\n          // Children are in their own scope.\n          DuplicateNameDetector(errorReporter)\n              .check(decl.getNestedDecls(), decl.which());\n        }\n\n        break;\n\n      default:\n        errorReporter.addErrorOn(decl, \"This kind of declaration doesn't belong here.\");\n        break;\n    }\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "decl",
            "\"This kind of declaration doesn't belong here.\""
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DuplicateNameDetector",
          "args": [
            "decl.getNestedDecls()",
            "decl.which()"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.which",
          "args": [],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DuplicateNameDetector",
          "args": [
            "errorReporter"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "DuplicateNameDetector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1363-1364",
          "snippet": "inline explicit DuplicateNameDetector(ErrorReporter& errorReporter)\n      : errorReporter(errorReporter) {}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\ninline explicit DuplicateNameDetector(ErrorReporter& errorReporter)\n      : errorReporter(errorReporter) {}"
        }
      },
      {
        "call_info": {
          "callee": "decl.which",
          "args": [],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getName",
          "args": [],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getName",
          "args": [],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getName",
          "args": [],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.which",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nameText.findFirst",
          "args": [
            "'_'"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "findFirst",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "182-182",
          "snippet": "inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "nameText.size() == 0",
            "\"Don't know what naming rules to enforce for node type.\"",
            "(uint)decl.which()"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.which",
          "args": [],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nameText.size",
          "args": [],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getExpressionTargetName",
          "args": [
            "decl.getUsing().getTarget()"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "getExpressionTargetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1421-1435",
          "snippet": "static kj::StringPtr getExpressionTargetName(Expression::Reader exp) {\n  kj::StringPtr targetName;\n  switch (exp.which()) {\n    case Expression::ABSOLUTE_NAME:\n      return exp.getAbsoluteName().getValue();\n    case Expression::RELATIVE_NAME:\n      return exp.getRelativeName().getValue();\n    case Expression::APPLICATION:\n      return getExpressionTargetName(exp.getApplication().getFunction());\n    case Expression::MEMBER:\n      return exp.getMember().getName().getValue();\n    default:\n      return nullptr;\n  }\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kj::StringTree expressionStringTree(Expression::Reader exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::StringTree expressionStringTree(Expression::Reader exp);\n\nstatic kj::StringPtr getExpressionTargetName(Expression::Reader exp) {\n  kj::StringPtr targetName;\n  switch (exp.which()) {\n    case Expression::ABSOLUTE_NAME:\n      return exp.getAbsoluteName().getValue();\n    case Expression::RELATIVE_NAME:\n      return exp.getRelativeName().getValue();\n    case Expression::APPLICATION:\n      return getExpressionTargetName(exp.getApplication().getFunction());\n    case Expression::MEMBER:\n      return exp.getMember().getName().getValue();\n    default:\n      return nullptr;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.getUsing",
          "args": [],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getUsing",
          "args": [],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.which",
          "args": [],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "nameText",
            "\"' previously defined here.\""
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "nameText",
            "\"' is already defined in this scope.\""
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Previously defined here.\""
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "decl.isUnion",
          "args": [],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "names.insert",
          "args": [
            "std::make_pair(nameText, name)"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "nameText",
            "name"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.getValue",
          "args": [],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getName",
          "args": [],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid NodeTranslator::DuplicateNameDetector::check(\n    List<Declaration>::Reader nestedDecls, Declaration::Which parentKind) {\n  for (auto decl: nestedDecls) {\n    {\n      auto name = decl.getName();\n      auto nameText = name.getValue();\n      auto insertResult = names.insert(std::make_pair(nameText, name));\n      if (!insertResult.second) {\n        if (nameText.size() == 0 && decl.isUnion()) {\n          errorReporter.addErrorOn(\n              name, kj::str(\"An unnamed union is already defined in this scope.\"));\n          errorReporter.addErrorOn(\n              insertResult.first->second, kj::str(\"Previously defined here.\"));\n        } else {\n          errorReporter.addErrorOn(\n              name, kj::str(\"'\", nameText, \"' is already defined in this scope.\"));\n          errorReporter.addErrorOn(\n              insertResult.first->second, kj::str(\"'\", nameText, \"' previously defined here.\"));\n        }\n      }\n\n      switch (decl.which()) {\n        case Declaration::USING: {\n          kj::StringPtr targetName = getExpressionTargetName(decl.getUsing().getTarget());\n          if (targetName.size() > 0 && targetName[0] >= 'a' && targetName[0] <= 'z') {\n            // Target starts with lower-case letter, so alias should too.\n            if (nameText.size() > 0 && (nameText[0] < 'a' || nameText[0] > 'z')) {\n              errorReporter.addErrorOn(name,\n                  \"Non-type names must begin with a lower-case letter.\");\n            }\n          } else {\n            // Target starts with capital or is not named (probably, an import). Require\n            // capitalization.\n            if (nameText.size() > 0 && (nameText[0] < 'A' || nameText[0] > 'Z')) {\n              errorReporter.addErrorOn(name,\n                  \"Type names must begin with a capital letter.\");\n            }\n          }\n          break;\n        }\n\n        case Declaration::ENUM:\n        case Declaration::STRUCT:\n        case Declaration::INTERFACE:\n          if (nameText.size() > 0 && (nameText[0] < 'A' || nameText[0] > 'Z')) {\n            errorReporter.addErrorOn(name,\n                \"Type names must begin with a capital letter.\");\n          }\n          break;\n\n        case Declaration::CONST:\n        case Declaration::ANNOTATION:\n        case Declaration::ENUMERANT:\n        case Declaration::METHOD:\n        case Declaration::FIELD:\n        case Declaration::UNION:\n        case Declaration::GROUP:\n          if (nameText.size() > 0 && (nameText[0] < 'a' || nameText[0] > 'z')) {\n            errorReporter.addErrorOn(name,\n                \"Non-type names must begin with a lower-case letter.\");\n          }\n          break;\n\n        default:\n          KJ_ASSERT(nameText.size() == 0, \"Don't know what naming rules to enforce for node type.\",\n                    (uint)decl.which());\n          break;\n      }\n\n      if (nameText.findFirst('_') != nullptr) {\n        errorReporter.addErrorOn(name,\n            \"Cap'n Proto declaration names should use camelCase and must not contain \"\n            \"underscores. (Code generators may convert names to the appropriate style for the \"\n            \"target language.)\");\n      }\n    }\n\n    switch (decl.which()) {\n      case Declaration::USING:\n      case Declaration::CONST:\n      case Declaration::ENUM:\n      case Declaration::STRUCT:\n      case Declaration::INTERFACE:\n      case Declaration::ANNOTATION:\n        switch (parentKind) {\n          case Declaration::FILE:\n          case Declaration::STRUCT:\n          case Declaration::INTERFACE:\n            // OK.\n            break;\n          default:\n            errorReporter.addErrorOn(decl, \"This kind of declaration doesn't belong here.\");\n            break;\n        }\n        break;\n\n      case Declaration::ENUMERANT:\n        if (parentKind != Declaration::ENUM) {\n          errorReporter.addErrorOn(decl, \"Enumerants can only appear in enums.\");\n        }\n        break;\n      case Declaration::METHOD:\n        if (parentKind != Declaration::INTERFACE) {\n          errorReporter.addErrorOn(decl, \"Methods can only appear in interfaces.\");\n        }\n        break;\n      case Declaration::FIELD:\n      case Declaration::UNION:\n      case Declaration::GROUP:\n        switch (parentKind) {\n          case Declaration::STRUCT:\n          case Declaration::UNION:\n          case Declaration::GROUP:\n            // OK.\n            break;\n          default:\n            errorReporter.addErrorOn(decl, \"This declaration can only appear in structs.\");\n            break;\n        }\n\n        // Struct members may have nested decls.  We need to check those here, because no one else\n        // is going to do it.\n        if (decl.getName().getValue().size() == 0) {\n          // Unnamed union.  Check members as if they are in the same scope.\n          check(decl.getNestedDecls(), decl.which());\n        } else {\n          // Children are in their own scope.\n          DuplicateNameDetector(errorReporter)\n              .check(decl.getNestedDecls(), decl.which());\n        }\n\n        break;\n\n      default:\n        errorReporter.addErrorOn(decl, \"This kind of declaration doesn't belong here.\");\n        break;\n    }\n  }\n}"
  },
  {
    "function_name": "getExpressionTargetName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1421-1435",
    "snippet": "static kj::StringPtr getExpressionTargetName(Expression::Reader exp) {\n  kj::StringPtr targetName;\n  switch (exp.which()) {\n    case Expression::ABSOLUTE_NAME:\n      return exp.getAbsoluteName().getValue();\n    case Expression::RELATIVE_NAME:\n      return exp.getRelativeName().getValue();\n    case Expression::APPLICATION:\n      return getExpressionTargetName(exp.getApplication().getFunction());\n    case Expression::MEMBER:\n      return exp.getMember().getName().getValue();\n    default:\n      return nullptr;\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static kj::StringTree expressionStringTree(Expression::Reader exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp.getMember",
          "args": [],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getMember",
          "args": [],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getMember",
          "args": [],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getApplication",
          "args": [],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getApplication",
          "args": [],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRelativeName",
          "args": [],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getRelativeName",
          "args": [],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getAbsoluteName",
          "args": [],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.getAbsoluteName",
          "args": [],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.which",
          "args": [],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::StringTree expressionStringTree(Expression::Reader exp);\n\nstatic kj::StringPtr getExpressionTargetName(Expression::Reader exp) {\n  kj::StringPtr targetName;\n  switch (exp.which()) {\n    case Expression::ABSOLUTE_NAME:\n      return exp.getAbsoluteName().getValue();\n    case Expression::RELATIVE_NAME:\n      return exp.getRelativeName().getValue();\n    case Expression::APPLICATION:\n      return getExpressionTargetName(exp.getApplication().getFunction());\n    case Expression::MEMBER:\n      return exp.getMember().getName().getValue();\n    default:\n      return nullptr;\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::compileNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1372-1419",
    "snippet": "void NodeTranslator::compileNode(Declaration::Reader decl, schema::Node::Builder builder) {\n  DuplicateNameDetector(errorReporter)\n      .check(decl.getNestedDecls(), decl.which());\n\n  auto genericParams = decl.getParameters();\n  if (genericParams.size() > 0) {\n    auto paramsBuilder = builder.initParameters(genericParams.size());\n    for (auto i: kj::indices(genericParams)) {\n      paramsBuilder[i].setName(genericParams[i].getName());\n    }\n  }\n\n  builder.setIsGeneric(localBrand->isGeneric());\n\n  kj::StringPtr targetsFlagName;\n\n  switch (decl.which()) {\n    case Declaration::FILE:\n      targetsFlagName = \"targetsFile\";\n      break;\n    case Declaration::CONST:\n      compileConst(decl.getConst(), builder.initConst());\n      targetsFlagName = \"targetsConst\";\n      break;\n    case Declaration::ANNOTATION:\n      compileAnnotation(decl.getAnnotation(), builder.initAnnotation());\n      targetsFlagName = \"targetsAnnotation\";\n      break;\n    case Declaration::ENUM:\n      compileEnum(decl.getEnum(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsEnum\";\n      break;\n    case Declaration::STRUCT:\n      compileStruct(decl.getStruct(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsStruct\";\n      break;\n    case Declaration::INTERFACE:\n      compileInterface(decl.getInterface(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsInterface\";\n      break;\n\n    default:\n      KJ_FAIL_REQUIRE(\"This Declaration is not a node.\");\n      break;\n  }\n\n  builder.adoptAnnotations(compileAnnotationApplications(decl.getAnnotations(), targetsFlagName));\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint i = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "builder.adoptAnnotations",
          "args": [
            "compileAnnotationApplications(decl.getAnnotations(), targetsFlagName)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileAnnotationApplications",
          "args": [
            "decl.getAnnotations()",
            "targetsFlagName"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getAnnotations",
          "args": [],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"This Declaration is not a node.\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileInterface",
          "args": [
            "decl.getInterface()",
            "decl.getNestedDecls()",
            "builder"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getInterface",
          "args": [],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileStruct",
          "args": [
            "decl.getStruct()",
            "decl.getNestedDecls()",
            "builder"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::compileStruct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2162-2165",
          "snippet": "void NodeTranslator::compileStruct(Void decl, List<Declaration>::Reader members,\n                                   schema::Node::Builder builder) {\n  StructTranslator(*this, noImplicitParams()).translate(decl, members, builder);\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nvoid NodeTranslator::compileStruct(Void decl, List<Declaration>::Reader members,\n                                   schema::Node::Builder builder) {\n  StructTranslator(*this, noImplicitParams()).translate(decl, members, builder);\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getStruct",
          "args": [],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileEnum",
          "args": [
            "decl.getEnum()",
            "decl.getNestedDecls()",
            "builder"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getEnum",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileAnnotation",
          "args": [
            "decl.getAnnotation()",
            "builder.initAnnotation()"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::compileAnnotation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1585-1599",
          "snippet": "void NodeTranslator::compileAnnotation(Declaration::Annotation::Reader decl,\n                                       schema::Node::Annotation::Builder builder) {\n  compileType(decl.getType(), builder.initType(), noImplicitParams());\n\n  // Dynamically copy over the values of all of the \"targets\" members.\n  DynamicStruct::Reader src = decl;\n  DynamicStruct::Builder dst = builder;\n  for (auto srcField: src.getSchema().getFields()) {\n    kj::StringPtr fieldName = srcField.getProto().getName();\n    if (fieldName.startsWith(\"targets\")) {\n      auto dstField = dst.getSchema().getFieldByName(fieldName);\n      dst.set(dstField, src.get(srcField));\n    }\n  }\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nvoid NodeTranslator::compileAnnotation(Declaration::Annotation::Reader decl,\n                                       schema::Node::Annotation::Builder builder) {\n  compileType(decl.getType(), builder.initType(), noImplicitParams());\n\n  // Dynamically copy over the values of all of the \"targets\" members.\n  DynamicStruct::Reader src = decl;\n  DynamicStruct::Builder dst = builder;\n  for (auto srcField: src.getSchema().getFields()) {\n    kj::StringPtr fieldName = srcField.getProto().getName();\n    if (fieldName.startsWith(\"targets\")) {\n      auto dstField = dst.getSchema().getFieldByName(fieldName);\n      dst.set(dstField, src.get(srcField));\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initAnnotation",
          "args": [],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getAnnotation",
          "args": [],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compileConst",
          "args": [
            "decl.getConst()",
            "builder.initConst()"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::compileConst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1577-1583",
          "snippet": "void NodeTranslator::compileConst(Declaration::Const::Reader decl,\n                                  schema::Node::Const::Builder builder) {\n  auto typeBuilder = builder.initType();\n  if (compileType(decl.getType(), typeBuilder, noImplicitParams())) {\n    compileBootstrapValue(decl.getValue(), typeBuilder.asReader(), builder.initValue());\n  }\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nvoid NodeTranslator::compileConst(Declaration::Const::Reader decl,\n                                  schema::Node::Const::Builder builder) {\n  auto typeBuilder = builder.initType();\n  if (compileType(decl.getType(), typeBuilder, noImplicitParams())) {\n    compileBootstrapValue(decl.getValue(), typeBuilder.asReader(), builder.initValue());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initConst",
          "args": [],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getConst",
          "args": [],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.which",
          "args": [],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder.setIsGeneric",
          "args": [
            "localBrand->isGeneric()"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localBrand->isGeneric",
          "args": [],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "paramsBuilder[i].setName",
          "args": [
            "genericParams[i].getName()"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genericParams[i].getName",
          "args": [],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "genericParams"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.initParameters",
          "args": [
            "genericParams.size()"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genericParams.size",
          "args": [],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decl.getParameters",
          "args": [],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DuplicateNameDetector",
          "args": [
            "decl.getNestedDecls()",
            "decl.which()"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.which",
          "args": [],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getNestedDecls",
          "args": [],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DuplicateNameDetector",
          "args": [
            "errorReporter"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "DuplicateNameDetector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1363-1364",
          "snippet": "inline explicit DuplicateNameDetector(ErrorReporter& errorReporter)\n      : errorReporter(errorReporter) {}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\ninline explicit DuplicateNameDetector(ErrorReporter& errorReporter)\n      : errorReporter(errorReporter) {}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid NodeTranslator::compileNode(Declaration::Reader decl, schema::Node::Builder builder) {\n  DuplicateNameDetector(errorReporter)\n      .check(decl.getNestedDecls(), decl.which());\n\n  auto genericParams = decl.getParameters();\n  if (genericParams.size() > 0) {\n    auto paramsBuilder = builder.initParameters(genericParams.size());\n    for (auto i: kj::indices(genericParams)) {\n      paramsBuilder[i].setName(genericParams[i].getName());\n    }\n  }\n\n  builder.setIsGeneric(localBrand->isGeneric());\n\n  kj::StringPtr targetsFlagName;\n\n  switch (decl.which()) {\n    case Declaration::FILE:\n      targetsFlagName = \"targetsFile\";\n      break;\n    case Declaration::CONST:\n      compileConst(decl.getConst(), builder.initConst());\n      targetsFlagName = \"targetsConst\";\n      break;\n    case Declaration::ANNOTATION:\n      compileAnnotation(decl.getAnnotation(), builder.initAnnotation());\n      targetsFlagName = \"targetsAnnotation\";\n      break;\n    case Declaration::ENUM:\n      compileEnum(decl.getEnum(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsEnum\";\n      break;\n    case Declaration::STRUCT:\n      compileStruct(decl.getStruct(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsStruct\";\n      break;\n    case Declaration::INTERFACE:\n      compileInterface(decl.getInterface(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsInterface\";\n      break;\n\n    default:\n      KJ_FAIL_REQUIRE(\"This Declaration is not a node.\");\n      break;\n  }\n\n  builder.adoptAnnotations(compileAnnotationApplications(decl.getAnnotations(), targetsFlagName));\n}"
  },
  {
    "function_name": "DuplicateNameDetector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1363-1364",
    "snippet": "inline explicit DuplicateNameDetector(ErrorReporter& errorReporter)\n      : errorReporter(errorReporter) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\ninline explicit DuplicateNameDetector(ErrorReporter& errorReporter)\n      : errorReporter(errorReporter) {}"
  },
  {
    "function_name": "NodeTranslator::finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1350-1359",
    "snippet": "NodeTranslator::NodeSet NodeTranslator::finish() {\n  // Careful about iteration here:  compileFinalValue() may actually add more elements to\n  // `unfinishedValues`, invalidating iterators in the process.\n  for (size_t i = 0; i < unfinishedValues.size(); i++) {\n    auto& value = unfinishedValues[i];\n    compileValue(value.source, value.type, value.typeScope, value.target, false);\n  }\n\n  return getBootstrapNode();\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "uint i = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getBootstrapNode",
          "args": [],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::getBootstrapNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1335-1348",
          "snippet": "NodeTranslator::NodeSet NodeTranslator::getBootstrapNode() {\n  auto nodeReader = wipNode.getReader();\n  if (nodeReader.isInterface()) {\n    return NodeSet {\n      nodeReader,\n      KJ_MAP(g, paramStructs) { return g.getReader(); }\n    };\n  } else {\n    return NodeSet {\n      nodeReader,\n      KJ_MAP(g, groups) { return g.getReader(); }\n    };\n  }\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::NodeSet NodeTranslator::getBootstrapNode() {\n  auto nodeReader = wipNode.getReader();\n  if (nodeReader.isInterface()) {\n    return NodeSet {\n      nodeReader,\n      KJ_MAP(g, paramStructs) { return g.getReader(); }\n    };\n  } else {\n    return NodeSet {\n      nodeReader,\n      KJ_MAP(g, groups) { return g.getReader(); }\n    };\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compileValue",
          "args": [
            "value.source",
            "value.type",
            "value.typeScope",
            "value.target",
            "false"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unfinishedValues.size",
          "args": [],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nuint i = 0;\n\nNodeTranslator::NodeSet NodeTranslator::finish() {\n  // Careful about iteration here:  compileFinalValue() may actually add more elements to\n  // `unfinishedValues`, invalidating iterators in the process.\n  for (size_t i = 0; i < unfinishedValues.size(); i++) {\n    auto& value = unfinishedValues[i];\n    compileValue(value.source, value.type, value.typeScope, value.target, false);\n  }\n\n  return getBootstrapNode();\n}"
  },
  {
    "function_name": "NodeTranslator::getBootstrapNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1335-1348",
    "snippet": "NodeTranslator::NodeSet NodeTranslator::getBootstrapNode() {\n  auto nodeReader = wipNode.getReader();\n  if (nodeReader.isInterface()) {\n    return NodeSet {\n      nodeReader,\n      KJ_MAP(g, paramStructs) { return g.getReader(); }\n    };\n  } else {\n    return NodeSet {\n      nodeReader,\n      KJ_MAP(g, groups) { return g.getReader(); }\n    };\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return g.getReader",
          "args": [],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "g",
            "groups"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return g.getReader",
          "args": [],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "g",
            "paramStructs"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeReader.isInterface",
          "args": [],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wipNode.getReader",
          "args": [],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::NodeSet NodeTranslator::getBootstrapNode() {\n  auto nodeReader = wipNode.getReader();\n  if (nodeReader.isInterface()) {\n    return NodeSet {\n      nodeReader,\n      KJ_MAP(g, paramStructs) { return g.getReader(); }\n    };\n  } else {\n    return NodeSet {\n      nodeReader,\n      KJ_MAP(g, groups) { return g.getReader(); }\n    };\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::~NodeTranslator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1333-1333",
    "snippet": "NodeTranslator::~NodeTranslator() noexcept(false) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::~NodeTranslator() noexcept(false) {}"
  },
  {
    "function_name": "NodeTranslator::NodeTranslator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1319-1331",
    "snippet": "NodeTranslator::NodeTranslator(\n    Resolver& resolver, ErrorReporter& errorReporter,\n    const Declaration::Reader& decl, Orphan<schema::Node> wipNodeParam,\n    bool compileAnnotations)\n    : resolver(resolver), errorReporter(errorReporter),\n      orphanage(Orphanage::getForMessageContaining(wipNodeParam.get())),\n      compileAnnotations(compileAnnotations),\n      localBrand(kj::refcounted<BrandScope>(\n          errorReporter, wipNodeParam.getReader().getId(),\n          decl.getParameters().size(), resolver)),\n      wipNode(kj::mv(wipNodeParam)) {\n  compileNode(decl, wipNode.get());\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "compileNode",
          "args": [
            "decl",
            "wipNode.get()"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::compileNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1372-1419",
          "snippet": "void NodeTranslator::compileNode(Declaration::Reader decl, schema::Node::Builder builder) {\n  DuplicateNameDetector(errorReporter)\n      .check(decl.getNestedDecls(), decl.which());\n\n  auto genericParams = decl.getParameters();\n  if (genericParams.size() > 0) {\n    auto paramsBuilder = builder.initParameters(genericParams.size());\n    for (auto i: kj::indices(genericParams)) {\n      paramsBuilder[i].setName(genericParams[i].getName());\n    }\n  }\n\n  builder.setIsGeneric(localBrand->isGeneric());\n\n  kj::StringPtr targetsFlagName;\n\n  switch (decl.which()) {\n    case Declaration::FILE:\n      targetsFlagName = \"targetsFile\";\n      break;\n    case Declaration::CONST:\n      compileConst(decl.getConst(), builder.initConst());\n      targetsFlagName = \"targetsConst\";\n      break;\n    case Declaration::ANNOTATION:\n      compileAnnotation(decl.getAnnotation(), builder.initAnnotation());\n      targetsFlagName = \"targetsAnnotation\";\n      break;\n    case Declaration::ENUM:\n      compileEnum(decl.getEnum(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsEnum\";\n      break;\n    case Declaration::STRUCT:\n      compileStruct(decl.getStruct(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsStruct\";\n      break;\n    case Declaration::INTERFACE:\n      compileInterface(decl.getInterface(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsInterface\";\n      break;\n\n    default:\n      KJ_FAIL_REQUIRE(\"This Declaration is not a node.\");\n      break;\n  }\n\n  builder.adoptAnnotations(compileAnnotationApplications(decl.getAnnotations(), targetsFlagName));\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint i = 0;",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nvoid NodeTranslator::compileNode(Declaration::Reader decl, schema::Node::Builder builder) {\n  DuplicateNameDetector(errorReporter)\n      .check(decl.getNestedDecls(), decl.which());\n\n  auto genericParams = decl.getParameters();\n  if (genericParams.size() > 0) {\n    auto paramsBuilder = builder.initParameters(genericParams.size());\n    for (auto i: kj::indices(genericParams)) {\n      paramsBuilder[i].setName(genericParams[i].getName());\n    }\n  }\n\n  builder.setIsGeneric(localBrand->isGeneric());\n\n  kj::StringPtr targetsFlagName;\n\n  switch (decl.which()) {\n    case Declaration::FILE:\n      targetsFlagName = \"targetsFile\";\n      break;\n    case Declaration::CONST:\n      compileConst(decl.getConst(), builder.initConst());\n      targetsFlagName = \"targetsConst\";\n      break;\n    case Declaration::ANNOTATION:\n      compileAnnotation(decl.getAnnotation(), builder.initAnnotation());\n      targetsFlagName = \"targetsAnnotation\";\n      break;\n    case Declaration::ENUM:\n      compileEnum(decl.getEnum(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsEnum\";\n      break;\n    case Declaration::STRUCT:\n      compileStruct(decl.getStruct(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsStruct\";\n      break;\n    case Declaration::INTERFACE:\n      compileInterface(decl.getInterface(), decl.getNestedDecls(), builder);\n      targetsFlagName = \"targetsInterface\";\n      break;\n\n    default:\n      KJ_FAIL_REQUIRE(\"This Declaration is not a node.\");\n      break;\n  }\n\n  builder.adoptAnnotations(compileAnnotationApplications(decl.getAnnotations(), targetsFlagName));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wipNode.get",
          "args": [],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "wipNodeParam"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<BrandScope>",
          "args": [
            "errorReporter",
            "wipNodeParam.getReader().getId()",
            "decl.getParameters().size()",
            "resolver"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getParameters",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getParameters",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wipNodeParam.getReader",
          "args": [],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wipNodeParam.getReader",
          "args": [],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Orphanage::getForMessageContaining",
          "args": [
            "wipNodeParam.get()"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "Orphanage::getForMessageContaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/orphan.h",
          "lines": "279-281",
          "snippet": "Orphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}",
          "includes": [
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n\nOrphanage Orphanage::getForMessageContaining(BuilderType builder) {\n  return Orphanage(GetInnerBuilder<FromBuilder<BuilderType>>::apply(builder).getArena());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nNodeTranslator::NodeTranslator(\n    Resolver& resolver, ErrorReporter& errorReporter,\n    const Declaration::Reader& decl, Orphan<schema::Node> wipNodeParam,\n    bool compileAnnotations)\n    : resolver(resolver), errorReporter(errorReporter),\n      orphanage(Orphanage::getForMessageContaining(wipNodeParam.get())),\n      compileAnnotations(compileAnnotations),\n      localBrand(kj::refcounted<BrandScope>(\n          errorReporter, wipNodeParam.getReader().getId(),\n          decl.getParameters().size(), resolver)),\n      wipNode(kj::mv(wipNodeParam)) {\n  compileNode(decl, wipNode.get());\n}"
  },
  {
    "function_name": "NodeTranslator::BrandScope::compileDeclExpression",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1193-1244",
    "snippet": "kj::Maybe<NodeTranslator::BrandedDecl> NodeTranslator::BrandScope::compileDeclExpression(\n    Expression::Reader source, Resolver& resolver,\n    ImplicitParams implicitMethodParams) {\n  switch (source.which()) {\n    case Expression::UNKNOWN:\n      // Error reported earlier.\n      return nullptr;\n\n    case Expression::POSITIVE_INT:\n    case Expression::NEGATIVE_INT:\n    case Expression::FLOAT:\n    case Expression::STRING:\n    case Expression::BINARY:\n    case Expression::LIST:\n    case Expression::TUPLE:\n      errorReporter.addErrorOn(source, \"Expected name.\");\n      return nullptr;\n\n    case Expression::RELATIVE_NAME: {\n      auto name = source.getRelativeName();\n      auto nameValue = name.getValue();\n\n      // Check implicit method params first.\n      for (auto i: kj::indices(implicitMethodParams.params)) {\n        if (implicitMethodParams.params[i].getName() == nameValue) {\n          if (implicitMethodParams.scopeId == 0) {\n            return BrandedDecl::implicitMethodParam(i);\n          } else {\n            return BrandedDecl(Resolver::ResolvedParameter {\n                implicitMethodParams.scopeId, static_cast<uint16_t>(i) },\n                Expression::Reader());\n          }\n        }\n      }\n\n      KJ_IF_MAYBE(r, resolver.resolve(nameValue)) {\n        return interpretResolve(resolver, *r, source);\n      } else {\n        errorReporter.addErrorOn(name, kj::str(\"Not defined: \", nameValue));\n        return nullptr;\n      }\n    }\n\n    case Expression::ABSOLUTE_NAME: {\n      auto name = source.getAbsoluteName();\n      KJ_IF_MAYBE(r, resolver.getTopScope().resolver->resolveMember(name.getValue())) {\n        return interpretResolve(resolver, *r, source);\n      } else {\n        errorReporter.addErrorOn(name, kj::str(\"Not defined: \", name.getValue()));\n        return nullptr;\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);",
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "kj::Array<BrandedDecl> params;",
      "static kj::String expressionString(Expression::Reader name);",
      "static kj::String expressionString(Expression::Reader name);",
      "uint i = 0;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "name",
            "kj::str(\"Not defined: \", name.getValue())"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Not defined: \"",
            "name.getValue()"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.getValue",
          "args": [],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interpretResolve",
          "args": [
            "resolver",
            "*r",
            "source"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::BrandScope::interpretResolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1028-1041",
          "snippet": "NodeTranslator::BrandedDecl NodeTranslator::BrandScope::interpretResolve(\n    Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source) {\n  if (result.is<Resolver::ResolvedDecl>()) {\n    auto& decl = result.get<Resolver::ResolvedDecl>();\n\n    auto scope = pop(decl.scopeId);\n    KJ_IF_MAYBE(brand, decl.brand) {\n      scope = scope->evaluateBrand(resolver, decl, brand->getScopes());\n    } else {\n      scope = scope->push(decl.id, decl.genericParamCount);\n    }\n\n    return BrandedDecl(decl, kj::mv(scope), source);\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\nNodeTranslator::BrandedDecl NodeTranslator::BrandScope::interpretResolve(\n    Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source) {\n  if (result.is<Resolver::ResolvedDecl>()) {\n    auto& decl = result.get<Resolver::ResolvedDecl>();\n\n    auto scope = pop(decl.scopeId);\n    KJ_IF_MAYBE(brand, decl.brand) {\n      scope = scope->evaluateBrand(resolver, decl, brand->getScopes());\n    } else {\n      scope = scope->push(decl.id, decl.genericParamCount);\n    }\n\n    return BrandedDecl(decl, kj::mv(scope), source);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "r",
            "resolver.getTopScope().resolver->resolveMember(name.getValue())"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "resolver.getTopScope",
          "args": [
            "name.getValue()"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.getValue",
          "args": [],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.getTopScope",
          "args": [],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source.getAbsoluteName",
          "args": [],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"Not defined: \"",
            "nameValue"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolve",
          "args": [
            "nameValue"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BrandedDecl",
          "args": [
            "Resolver::ResolvedParameter {\n                implicitMethodParams.scopeId, static_cast<uint16_t>(i) }",
            "Expression::Reader()"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "BrandedDecl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "537-540",
          "snippet": "inline BrandedDecl(Resolver::ResolvedParameter variable, Expression::Reader source)\n      : source(source) {\n    body.init<Resolver::ResolvedParameter>(kj::mv(variable));\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\ninline BrandedDecl(Resolver::ResolvedParameter variable, Expression::Reader source)\n      : source(source) {\n    body.init<Resolver::ResolvedParameter>(kj::mv(variable));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint16_t>",
          "args": [
            "i"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BrandedDecl::implicitMethodParam",
          "args": [
            "i"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "implicitMethodParam",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "543-547",
          "snippet": "static BrandedDecl implicitMethodParam(uint index) {\n    // Get a BrandedDecl referring to an implicit method parameter.\n    // (As a hack, we internally represent this as a ResolvedParameter. Sorry.)\n    return BrandedDecl(Resolver::ResolvedParameter { 0, index }, Expression::Reader());\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\n\nstatic BrandedDecl implicitMethodParam(uint index) {\n    // Get a BrandedDecl referring to an implicit method parameter.\n    // (As a hack, we internally represent this as a ResolvedParameter. Sorry.)\n    return BrandedDecl(Resolver::ResolvedParameter { 0, index }, Expression::Reader());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "implicitMethodParams.params[i].getName",
          "args": [],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::indices",
          "args": [
            "implicitMethodParams.params"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "650-656",
          "snippet": "inline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Range<size_t> indices(T&& container) {\n  // Shortcut for iterating over the indices of a container:\n  //\n  //     for (size_t i: kj::indices(myArray)) { handle(myArray[i]); }\n\n  return range<size_t>(0, kj::size(container));\n}"
        }
      },
      {
        "call_info": {
          "callee": "name.getValue",
          "args": [],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source.getRelativeName",
          "args": [],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source.which",
          "args": [],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> compileDeclExpression(\n      Expression::Reader source, Resolver& resolver,\n      ImplicitParams implicitMethodParams);\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nkj::Array<BrandedDecl> params;\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\nuint i = 0;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nkj::Maybe<NodeTranslator::BrandedDecl> NodeTranslator::BrandScope::compileDeclExpression(\n    Expression::Reader source, Resolver& resolver,\n    ImplicitParams implicitMethodParams) {\n  switch (source.which()) {\n    case Expression::UNKNOWN:\n      // Error reported earlier.\n      return nullptr;\n\n    case Expression::POSITIVE_INT:\n    case Expression::NEGATIVE_INT:\n    case Expression::FLOAT:\n    case Expression::STRING:\n    case Expression::BINARY:\n    case Expression::LIST:\n    case Expression::TUPLE:\n      errorReporter.addErrorOn(source, \"Expected name.\");\n      return nullptr;\n\n    case Expression::RELATIVE_NAME: {\n      auto name = source.getRelativeName();\n      auto nameValue = name.getValue();\n\n      // Check implicit method params first.\n      for (auto i: kj::indices(implicitMethodParams.params)) {\n        if (implicitMethodParams.params[i].getName() == nameValue) {\n          if (implicitMethodParams.scopeId == 0) {\n            return BrandedDecl::implicitMethodParam(i);\n          } else {\n            return BrandedDecl(Resolver::ResolvedParameter {\n                implicitMethodParams.scopeId, static_cast<uint16_t>(i) },\n                Expression::Reader());\n          }\n        }\n      }\n\n      KJ_IF_MAYBE(r, resolver.resolve(nameValue)) {\n        return interpretResolve(resolver, *r, source);\n      } else {\n        errorReporter.addErrorOn(name, kj::str(\"Not defined: \", nameValue));\n        return nullptr;\n      }\n    }\n\n    case Expression::ABSOLUTE_NAME: {\n      auto name = source.getAbsoluteName();\n      KJ_IF_MAYBE(r, resolver.getTopScope().resolver->resolveMember(name.getValue())) {\n        return interpretResolve(resolver, *r, source);\n      } else {\n        errorReporter.addErrorOn(name, kj::str(\"Not defined: \", name.getValue()));\n        return nullptr;\n      }\n    }"
  },
  {
    "function_name": "NodeTranslator::BrandScope::decompileType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1110-1188",
    "snippet": "NodeTranslator::BrandedDecl NodeTranslator::BrandScope::decompileType(\n    Resolver& resolver, schema::Type::Reader type) {\n  auto builtin = [&](Declaration::Which which) -> BrandedDecl {\n    auto decl = resolver.resolveBuiltin(which);\n    return BrandedDecl(decl,\n        evaluateBrand(resolver, decl, List<schema::Brand::Scope>::Reader()),\n        Expression::Reader());\n  };\n\n  switch (type.which()) {\n    case schema::Type::VOID:    return builtin(Declaration::BUILTIN_VOID);\n    case schema::Type::BOOL:    return builtin(Declaration::BUILTIN_BOOL);\n    case schema::Type::INT8:    return builtin(Declaration::BUILTIN_INT8);\n    case schema::Type::INT16:   return builtin(Declaration::BUILTIN_INT16);\n    case schema::Type::INT32:   return builtin(Declaration::BUILTIN_INT32);\n    case schema::Type::INT64:   return builtin(Declaration::BUILTIN_INT64);\n    case schema::Type::UINT8:   return builtin(Declaration::BUILTIN_U_INT8);\n    case schema::Type::UINT16:  return builtin(Declaration::BUILTIN_U_INT16);\n    case schema::Type::UINT32:  return builtin(Declaration::BUILTIN_U_INT32);\n    case schema::Type::UINT64:  return builtin(Declaration::BUILTIN_U_INT64);\n    case schema::Type::FLOAT32: return builtin(Declaration::BUILTIN_FLOAT32);\n    case schema::Type::FLOAT64: return builtin(Declaration::BUILTIN_FLOAT64);\n    case schema::Type::TEXT:    return builtin(Declaration::BUILTIN_TEXT);\n    case schema::Type::DATA:    return builtin(Declaration::BUILTIN_DATA);\n\n    case schema::Type::ENUM: {\n      auto enumType = type.getEnum();\n      Resolver::ResolvedDecl decl = resolver.resolveId(enumType.getTypeId());\n      return BrandedDecl(decl,\n          evaluateBrand(resolver, decl, enumType.getBrand().getScopes()),\n          Expression::Reader());\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = type.getInterface();\n      Resolver::ResolvedDecl decl = resolver.resolveId(interfaceType.getTypeId());\n      return BrandedDecl(decl,\n          evaluateBrand(resolver, decl, interfaceType.getBrand().getScopes()),\n          Expression::Reader());\n    }\n\n    case schema::Type::STRUCT: {\n      auto structType = type.getStruct();\n      Resolver::ResolvedDecl decl = resolver.resolveId(structType.getTypeId());\n      return BrandedDecl(decl,\n          evaluateBrand(resolver, decl, structType.getBrand().getScopes()),\n          Expression::Reader());\n    }\n\n    case schema::Type::LIST: {\n      auto elementType = decompileType(resolver, type.getList().getElementType());\n      return KJ_ASSERT_NONNULL(builtin(Declaration::BUILTIN_LIST)\n          .applyParams(kj::heapArray(&elementType, 1), Expression::Reader()));\n    }\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = type.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return builtin(Declaration::BUILTIN_ANY_POINTER);\n\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          auto id = param.getScopeId();\n          uint index = param.getParameterIndex();\n          KJ_IF_MAYBE(binding, lookupParameter(resolver, id, index)) {\n            return *binding;\n          } else {\n            return BrandedDecl(Resolver::ResolvedParameter {id, index}, Expression::Reader());\n          }\n        }\n\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          KJ_FAIL_ASSERT(\"Alias pointed to implicit method type parameter?\");\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);",
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Alias pointed to implicit method type parameter?\""
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BrandedDecl",
          "args": [
            "Resolver::ResolvedParameter {id, index}",
            "Expression::Reader()"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "BrandedDecl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "537-540",
          "snippet": "inline BrandedDecl(Resolver::ResolvedParameter variable, Expression::Reader source)\n      : source(source) {\n    body.init<Resolver::ResolvedParameter>(kj::mv(variable));\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\ninline BrandedDecl(Resolver::ResolvedParameter variable, Expression::Reader source)\n      : source(source) {\n    body.init<Resolver::ResolvedParameter>(kj::mv(variable));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getParameterIndex",
          "args": [],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getScopeId",
          "args": [],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "anyPointer.getParameter",
          "args": [],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_ANY_POINTER"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.which",
          "args": [],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getAnyPointer",
          "args": [],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "builtin(Declaration::BUILTIN_LIST)\n          .applyParams(kj::heapArray(&elementType, 1), Expression::Reader())"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "kj::heapArray(&elementType, 1)",
            "Expression::Reader()"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray",
          "args": [
            "&elementType",
            "1"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "688-693",
          "snippet": "Array<T>\nheapArray(Iterator begin, Iterator end) {\n  ArrayBuilder<T> builder = heapArrayBuilder<T>(end - begin);\n  builder.addAll(begin, end);\n  return builder.finish();\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArray<T>\nheapArray(Iterator begin, Iterator end) {\n  ArrayBuilder<T> builder = heapArrayBuilder<T>(end - begin);\n  builder.addAll(begin, end);\n  return builder.finish();\n}"
        }
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_LIST"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decompileType",
          "args": [
            "resolver",
            "type.getList().getElementType()"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluateBrand",
          "args": [
            "resolver",
            "decl",
            "structType.getBrand().getScopes()"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getBrand",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getBrand",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveId",
          "args": [
            "structType.getTypeId()"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structType.getTypeId",
          "args": [],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluateBrand",
          "args": [
            "resolver",
            "decl",
            "interfaceType.getBrand().getScopes()"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceType.getBrand",
          "args": [],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceType.getBrand",
          "args": [],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveId",
          "args": [
            "interfaceType.getTypeId()"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interfaceType.getTypeId",
          "args": [],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluateBrand",
          "args": [
            "resolver",
            "decl",
            "enumType.getBrand().getScopes()"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getBrand",
          "args": [],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getBrand",
          "args": [],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveId",
          "args": [
            "enumType.getTypeId()"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumType.getTypeId",
          "args": [],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_DATA"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_TEXT"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_FLOAT64"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_FLOAT32"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_U_INT64"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_U_INT32"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_U_INT16"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_U_INT8"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_INT64"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_INT32"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_INT16"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_INT8"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_BOOL"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builtin",
          "args": [
            "Declaration::BUILTIN_VOID"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluateBrand",
          "args": [
            "resolver",
            "decl",
            "List<schema::Brand::Scope>::Reader()"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "List<schema::Brand::Scope>::Reader",
          "args": [],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveBuiltin",
          "args": [
            "which"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\n\nNodeTranslator::BrandedDecl NodeTranslator::BrandScope::decompileType(\n    Resolver& resolver, schema::Type::Reader type) {\n  auto builtin = [&](Declaration::Which which) -> BrandedDecl {\n    auto decl = resolver.resolveBuiltin(which);\n    return BrandedDecl(decl,\n        evaluateBrand(resolver, decl, List<schema::Brand::Scope>::Reader()),\n        Expression::Reader());\n  };\n\n  switch (type.which()) {\n    case schema::Type::VOID:    return builtin(Declaration::BUILTIN_VOID);\n    case schema::Type::BOOL:    return builtin(Declaration::BUILTIN_BOOL);\n    case schema::Type::INT8:    return builtin(Declaration::BUILTIN_INT8);\n    case schema::Type::INT16:   return builtin(Declaration::BUILTIN_INT16);\n    case schema::Type::INT32:   return builtin(Declaration::BUILTIN_INT32);\n    case schema::Type::INT64:   return builtin(Declaration::BUILTIN_INT64);\n    case schema::Type::UINT8:   return builtin(Declaration::BUILTIN_U_INT8);\n    case schema::Type::UINT16:  return builtin(Declaration::BUILTIN_U_INT16);\n    case schema::Type::UINT32:  return builtin(Declaration::BUILTIN_U_INT32);\n    case schema::Type::UINT64:  return builtin(Declaration::BUILTIN_U_INT64);\n    case schema::Type::FLOAT32: return builtin(Declaration::BUILTIN_FLOAT32);\n    case schema::Type::FLOAT64: return builtin(Declaration::BUILTIN_FLOAT64);\n    case schema::Type::TEXT:    return builtin(Declaration::BUILTIN_TEXT);\n    case schema::Type::DATA:    return builtin(Declaration::BUILTIN_DATA);\n\n    case schema::Type::ENUM: {\n      auto enumType = type.getEnum();\n      Resolver::ResolvedDecl decl = resolver.resolveId(enumType.getTypeId());\n      return BrandedDecl(decl,\n          evaluateBrand(resolver, decl, enumType.getBrand().getScopes()),\n          Expression::Reader());\n    }\n\n    case schema::Type::INTERFACE: {\n      auto interfaceType = type.getInterface();\n      Resolver::ResolvedDecl decl = resolver.resolveId(interfaceType.getTypeId());\n      return BrandedDecl(decl,\n          evaluateBrand(resolver, decl, interfaceType.getBrand().getScopes()),\n          Expression::Reader());\n    }\n\n    case schema::Type::STRUCT: {\n      auto structType = type.getStruct();\n      Resolver::ResolvedDecl decl = resolver.resolveId(structType.getTypeId());\n      return BrandedDecl(decl,\n          evaluateBrand(resolver, decl, structType.getBrand().getScopes()),\n          Expression::Reader());\n    }\n\n    case schema::Type::LIST: {\n      auto elementType = decompileType(resolver, type.getList().getElementType());\n      return KJ_ASSERT_NONNULL(builtin(Declaration::BUILTIN_LIST)\n          .applyParams(kj::heapArray(&elementType, 1), Expression::Reader()));\n    }\n\n    case schema::Type::ANY_POINTER: {\n      auto anyPointer = type.getAnyPointer();\n      switch (anyPointer.which()) {\n        case schema::Type::AnyPointer::UNCONSTRAINED:\n          return builtin(Declaration::BUILTIN_ANY_POINTER);\n\n        case schema::Type::AnyPointer::PARAMETER: {\n          auto param = anyPointer.getParameter();\n          auto id = param.getScopeId();\n          uint index = param.getParameterIndex();\n          KJ_IF_MAYBE(binding, lookupParameter(resolver, id, index)) {\n            return *binding;\n          } else {\n            return BrandedDecl(Resolver::ResolvedParameter {id, index}, Expression::Reader());\n          }\n        }\n\n        case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER:\n          KJ_FAIL_ASSERT(\"Alias pointed to implicit method type parameter?\");\n      }\n\n      KJ_UNREACHABLE;\n    }\n  }"
  },
  {
    "function_name": "NodeTranslator::BrandScope::evaluateBrand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1051-1100",
    "snippet": "kj::Own<NodeTranslator::BrandScope> NodeTranslator::BrandScope::evaluateBrand(\n    Resolver& resolver, Resolver::ResolvedDecl decl,\n    List<schema::Brand::Scope>::Reader brand, uint index) {\n  auto result = kj::refcounted<BrandScope>(errorReporter, decl.id);\n  result->leafParamCount = decl.genericParamCount;\n\n  // Fill in `params`.\n  if (index < brand.size()) {\n    auto nextScope = brand[index];\n    if (decl.id == nextScope.getScopeId()) {\n      // Initialize our parameters.\n\n      switch (nextScope.which()) {\n        case schema::Brand::Scope::BIND: {\n          auto bindings = nextScope.getBind();\n          auto params = kj::heapArrayBuilder<BrandedDecl>(bindings.size());\n          for (auto binding: bindings) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND: {\n                // Build an AnyPointer-equivalent.\n                auto anyPointerDecl = resolver.resolveBuiltin(Declaration::BUILTIN_ANY_POINTER);\n                params.add(BrandedDecl(anyPointerDecl,\n                    kj::refcounted<BrandScope>(errorReporter, anyPointerDecl.scopeId),\n                    Expression::Reader()));\n                break;\n              }\n\n              case schema::Brand::Binding::TYPE:\n                // Reverse this schema::Type back into a BrandedDecl.\n                params.add(decompileType(resolver, binding.getType()));\n                break;\n            }\n          }\n          result->params = params.finish();\n          break;\n        }\n\n        case schema::Brand::Scope::INHERIT:\n          KJ_IF_MAYBE(p, getParams(decl.id)) {\n            result->params = kj::heapArray(*p);\n          } else {\n            result->inherited = true;\n          }\n          break;\n      }\n\n      // Parent should start one level deeper in the list.\n      ++index;\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);",
      "uint leafParamCount;",
      "bool inherited;",
      "kj::Array<BrandedDecl> params;",
      "auto list = interfaceBuilder.initMethods(methods.size());",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapArray",
          "args": [
            "*p"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "p",
            "getParams(decl.id)"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "getParams",
          "args": [
            "decl.id"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "getParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "716-730",
          "snippet": "kj::Maybe<kj::ArrayPtr<BrandedDecl>> getParams(uint64_t scopeId) {\n    // Returns null if params at the requested scope should be inherited from the client scope.\n\n    if (scopeId == leafId) {\n      if (inherited) {\n        return nullptr;\n      } else {\n        return params.asPtr();\n      }\n    } else KJ_IF_MAYBE(p, parent) {\n      return p->get()->getParams(scopeId);\n    } else {\n      KJ_FAIL_REQUIRE(\"scope is not a parent\");\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "uint64_t leafId;",
            "bool inherited;",
            "kj::Array<BrandedDecl> params;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint64_t leafId;\nbool inherited;\nkj::Array<BrandedDecl> params;\n\nkj::Maybe<kj::ArrayPtr<BrandedDecl>> getParams(uint64_t scopeId) {\n    // Returns null if params at the requested scope should be inherited from the client scope.\n\n    if (scopeId == leafId) {\n      if (inherited) {\n        return nullptr;\n      } else {\n        return params.asPtr();\n      }\n    } else KJ_IF_MAYBE(p, parent) {\n      return p->get()->getParams(scopeId);\n    } else {\n      KJ_FAIL_REQUIRE(\"scope is not a parent\");\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.finish",
          "args": [],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.add",
          "args": [
            "decompileType(resolver, binding.getType())"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decompileType",
          "args": [
            "resolver",
            "binding.getType()"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binding.getType",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "BrandedDecl",
          "args": [
            "anyPointerDecl",
            "kj::refcounted<BrandScope>(errorReporter, anyPointerDecl.scopeId)",
            "Expression::Reader()"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "BrandedDecl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "531-536",
          "snippet": "inline BrandedDecl(Resolver::ResolvedDecl decl,\n                     kj::Own<NodeTranslator::BrandScope>&& brand,\n                     Expression::Reader source)\n      : brand(kj::mv(brand)), source(source) {\n    body.init<Resolver::ResolvedDecl>(kj::mv(decl));\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\ninline BrandedDecl(Resolver::ResolvedDecl decl,\n                     kj::Own<NodeTranslator::BrandScope>&& brand,\n                     Expression::Reader source)\n      : brand(kj::mv(brand)), source(source) {\n    body.init<Resolver::ResolvedDecl>(kj::mv(decl));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<BrandScope>",
          "args": [
            "errorReporter",
            "anyPointerDecl.scopeId"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveBuiltin",
          "args": [
            "Declaration::BUILTIN_ANY_POINTER"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binding.which",
          "args": [],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<BrandedDecl>",
          "args": [
            "bindings.size()"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bindings.size",
          "args": [],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nextScope.getBind",
          "args": [],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextScope.which",
          "args": [],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nextScope.getScopeId",
          "args": [],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<BrandScope>",
          "args": [
            "errorReporter",
            "decl.id"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\nuint leafParamCount;\nbool inherited;\nkj::Array<BrandedDecl> params;\nauto list = interfaceBuilder.initMethods(methods.size());\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nkj::Own<NodeTranslator::BrandScope> NodeTranslator::BrandScope::evaluateBrand(\n    Resolver& resolver, Resolver::ResolvedDecl decl,\n    List<schema::Brand::Scope>::Reader brand, uint index) {\n  auto result = kj::refcounted<BrandScope>(errorReporter, decl.id);\n  result->leafParamCount = decl.genericParamCount;\n\n  // Fill in `params`.\n  if (index < brand.size()) {\n    auto nextScope = brand[index];\n    if (decl.id == nextScope.getScopeId()) {\n      // Initialize our parameters.\n\n      switch (nextScope.which()) {\n        case schema::Brand::Scope::BIND: {\n          auto bindings = nextScope.getBind();\n          auto params = kj::heapArrayBuilder<BrandedDecl>(bindings.size());\n          for (auto binding: bindings) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND: {\n                // Build an AnyPointer-equivalent.\n                auto anyPointerDecl = resolver.resolveBuiltin(Declaration::BUILTIN_ANY_POINTER);\n                params.add(BrandedDecl(anyPointerDecl,\n                    kj::refcounted<BrandScope>(errorReporter, anyPointerDecl.scopeId),\n                    Expression::Reader()));\n                break;\n              }\n\n              case schema::Brand::Binding::TYPE:\n                // Reverse this schema::Type back into a BrandedDecl.\n                params.add(decompileType(resolver, binding.getType()));\n                break;\n            }\n          }\n          result->params = params.finish();\n          break;\n        }\n\n        case schema::Brand::Scope::INHERIT:\n          KJ_IF_MAYBE(p, getParams(decl.id)) {\n            result->params = kj::heapArray(*p);\n          } else {\n            result->inherited = true;\n          }\n          break;\n      }\n\n      // Parent should start one level deeper in the list.\n      ++index;\n    }\n  }"
  },
  {
    "function_name": "NodeTranslator::BrandScope::interpretResolve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1028-1041",
    "snippet": "NodeTranslator::BrandedDecl NodeTranslator::BrandScope::interpretResolve(\n    Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source) {\n  if (result.is<Resolver::ResolvedDecl>()) {\n    auto& decl = result.get<Resolver::ResolvedDecl>();\n\n    auto scope = pop(decl.scopeId);\n    KJ_IF_MAYBE(brand, decl.brand) {\n      scope = scope->evaluateBrand(resolver, decl, brand->getScopes());\n    } else {\n      scope = scope->push(decl.id, decl.genericParamCount);\n    }\n\n    return BrandedDecl(decl, kj::mv(scope), source);\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BrandedDecl",
          "args": [
            "decl",
            "kj::mv(scope)",
            "source"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "BrandedDecl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "531-536",
          "snippet": "inline BrandedDecl(Resolver::ResolvedDecl decl,\n                     kj::Own<NodeTranslator::BrandScope>&& brand,\n                     Expression::Reader source)\n      : brand(kj::mv(brand)), source(source) {\n    body.init<Resolver::ResolvedDecl>(kj::mv(decl));\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\ninline BrandedDecl(Resolver::ResolvedDecl decl,\n                     kj::Own<NodeTranslator::BrandScope>&& brand,\n                     Expression::Reader source)\n      : brand(kj::mv(brand)), source(source) {\n    body.init<Resolver::ResolvedDecl>(kj::mv(decl));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "scope"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scope->push",
          "args": [
            "decl.id",
            "decl.genericParamCount"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scope->evaluateBrand",
          "args": [
            "resolver",
            "decl",
            "brand->getScopes()"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brand->getScopes",
          "args": [],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "brand",
            "decl.brand"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "pop",
          "args": [
            "decl.scopeId"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.get<Resolver::ResolvedDecl>",
          "args": [],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.is<Resolver::ResolvedDecl>",
          "args": [],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\nNodeTranslator::BrandedDecl NodeTranslator::BrandScope::interpretResolve(\n    Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source) {\n  if (result.is<Resolver::ResolvedDecl>()) {\n    auto& decl = result.get<Resolver::ResolvedDecl>();\n\n    auto scope = pop(decl.scopeId);\n    KJ_IF_MAYBE(brand, decl.brand) {\n      scope = scope->evaluateBrand(resolver, decl, brand->getScopes());\n    } else {\n      scope = scope->push(decl.id, decl.genericParamCount);\n    }\n\n    return BrandedDecl(decl, kj::mv(scope), source);\n  }"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::toDebugString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1018-1026",
    "snippet": "kj::String NodeTranslator::BrandedDecl::toDebugString() {\n  if (body.is<Resolver::ResolvedParameter>()) {\n    auto variable = body.get<Resolver::ResolvedParameter>();\n    return kj::str(\"varibale(\", variable.id, \", \", variable.index, \")\");\n  } else {\n    auto decl = body.get<Resolver::ResolvedDecl>();\n    return kj::str(\"decl(\", decl.id, \", \", (uint)decl.kind, \"')\");\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"decl(\"",
            "decl.id",
            "\", \"",
            "(uint)decl.kind",
            "\"')\""
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.get<Resolver::ResolvedDecl>",
          "args": [],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"varibale(\"",
            "variable.id",
            "\", \"",
            "variable.index",
            "\")\""
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.is<Resolver::ResolvedParameter>",
          "args": [],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\n\nkj::String NodeTranslator::BrandedDecl::toDebugString() {\n  if (body.is<Resolver::ResolvedParameter>()) {\n    auto variable = body.get<Resolver::ResolvedParameter>();\n    return kj::str(\"varibale(\", variable.id, \", \", variable.index, \")\");\n  } else {\n    auto decl = body.get<Resolver::ResolvedDecl>();\n    return kj::str(\"decl(\", decl.id, \", \", (uint)decl.kind, \"')\");\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::toString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "1014-1016",
    "snippet": "kj::String NodeTranslator::BrandedDecl::toString() {\n  return expressionString(source);\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "expressionString",
          "args": [
            "source"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "expressionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "2444-2446",
          "snippet": "static kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kj::String expressionString(Expression::Reader name);",
            "static kj::String expressionString(Expression::Reader name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstatic kj::String expressionString(Expression::Reader name);\nstatic kj::String expressionString(Expression::Reader name);\n\nstatic kj::String expressionString(Expression::Reader name) {\n  return expressionStringTree(name).flatten();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\nkj::String NodeTranslator::BrandedDecl::toString() {\n  return expressionString(source);\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::asResolveResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "996-1010",
    "snippet": "NodeTranslator::Resolver::ResolveResult NodeTranslator::BrandedDecl::asResolveResult(\n    uint64_t scopeId, schema::Brand::Builder brandBuilder) {\n  auto result = body;\n  if (result.is<Resolver::ResolvedDecl>()) {\n    // May need to compile our context as the \"brand\".\n\n    result.get<Resolver::ResolvedDecl>().scopeId = scopeId;\n\n    getIdAndFillBrand([&]() {\n      result.get<Resolver::ResolvedDecl>().brand = brandBuilder.asReader();\n      return brandBuilder;\n    });\n  }\n  return result;\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getIdAndFillBrand",
          "args": [
            "[&]() {\n      result.get<Resolver::ResolvedDecl>().brand = brandBuilder.asReader();\n      return brandBuilder;\n    }"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::BrandedDecl::getIdAndFillBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "859-864",
          "snippet": "uint64_t NodeTranslator::BrandedDecl::getIdAndFillBrand(InitBrandFunc&& initBrand) {\n  KJ_REQUIRE(body.is<Resolver::ResolvedDecl>());\n\n  brand->compile(kj::fwd<InitBrandFunc>(initBrand));\n  return body.get<Resolver::ResolvedDecl>().id;\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t NodeTranslator::BrandedDecl::getIdAndFillBrand(InitBrandFunc&& initBrand) {\n  KJ_REQUIRE(body.is<Resolver::ResolvedDecl>());\n\n  brand->compile(kj::fwd<InitBrandFunc>(initBrand));\n  return body.get<Resolver::ResolvedDecl>().id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brandBuilder.asReader",
          "args": [],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "asReader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3149-3149",
          "snippet": "inline Reader asReader() const { return *this; }",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline Reader asReader() const { return *this; }"
        }
      },
      {
        "call_info": {
          "callee": "result.get<Resolver::ResolvedDecl>",
          "args": [],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.is<Resolver::ResolvedDecl>",
          "args": [],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::Resolver::ResolveResult NodeTranslator::BrandedDecl::asResolveResult(\n    uint64_t scopeId, schema::Brand::Builder brandBuilder) {\n  auto result = body;\n  if (result.is<Resolver::ResolvedDecl>()) {\n    // May need to compile our context as the \"brand\".\n\n    result.get<Resolver::ResolvedDecl>().scopeId = scopeId;\n\n    getIdAndFillBrand([&]() {\n      result.get<Resolver::ResolvedDecl>().brand = brandBuilder.asReader();\n      return brandBuilder;\n    });\n  }\n  return result;\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::compileAsType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "886-979",
    "snippet": "bool NodeTranslator::BrandedDecl::compileAsType(\n    ErrorReporter& errorReporter, schema::Type::Builder target) {\n  KJ_IF_MAYBE(kind, getKind()) {\n    switch (*kind) {\n      case Declaration::ENUM: {\n        auto enum_ = target.initEnum();\n        enum_.setTypeId(getIdAndFillBrand([&]() { return enum_.initBrand(); }));\n        return true;\n      }\n\n      case Declaration::STRUCT: {\n        auto struct_ = target.initStruct();\n        struct_.setTypeId(getIdAndFillBrand([&]() { return struct_.initBrand(); }));\n        return true;\n      }\n\n      case Declaration::INTERFACE: {\n        auto interface = target.initInterface();\n        interface.setTypeId(getIdAndFillBrand([&]() { return interface.initBrand(); }));\n        return true;\n      }\n\n      case Declaration::BUILTIN_LIST: {\n        auto elementType = target.initList().initElementType();\n\n        KJ_IF_MAYBE(param, getListParam()) {\n          if (!param->compileAsType(errorReporter, elementType)) {\n            return false;\n          }\n        } else {\n          addError(errorReporter, \"'List' requires exactly one parameter.\");\n          return false;\n        }\n\n        if (elementType.isAnyPointer()) {\n          addError(errorReporter, \"'List(AnyPointer)' is not supported.\");\n          // Seeing List(AnyPointer) later can mess things up, so change the type to Void.\n          elementType.setVoid();\n          return false;\n        }\n\n        return true;\n      }\n\n      case Declaration::BUILTIN_VOID: target.setVoid(); return true;\n      case Declaration::BUILTIN_BOOL: target.setBool(); return true;\n      case Declaration::BUILTIN_INT8: target.setInt8(); return true;\n      case Declaration::BUILTIN_INT16: target.setInt16(); return true;\n      case Declaration::BUILTIN_INT32: target.setInt32(); return true;\n      case Declaration::BUILTIN_INT64: target.setInt64(); return true;\n      case Declaration::BUILTIN_U_INT8: target.setUint8(); return true;\n      case Declaration::BUILTIN_U_INT16: target.setUint16(); return true;\n      case Declaration::BUILTIN_U_INT32: target.setUint32(); return true;\n      case Declaration::BUILTIN_U_INT64: target.setUint64(); return true;\n      case Declaration::BUILTIN_FLOAT32: target.setFloat32(); return true;\n      case Declaration::BUILTIN_FLOAT64: target.setFloat64(); return true;\n      case Declaration::BUILTIN_TEXT: target.setText(); return true;\n      case Declaration::BUILTIN_DATA: target.setData(); return true;\n\n      case Declaration::BUILTIN_OBJECT:\n        addError(errorReporter,\n            \"As of Cap'n Proto 0.4, 'Object' has been renamed to 'AnyPointer'.  Sorry for the \"\n            \"inconvenience, and thanks for being an early adopter.  :)\");\n        // no break\n      case Declaration::BUILTIN_ANY_POINTER:\n        target.initAnyPointer().initUnconstrained().setAnyKind();\n        return true;\n      case Declaration::BUILTIN_ANY_STRUCT:\n        target.initAnyPointer().initUnconstrained().setStruct();\n        return true;\n      case Declaration::BUILTIN_ANY_LIST:\n        target.initAnyPointer().initUnconstrained().setList();\n        return true;\n      case Declaration::BUILTIN_CAPABILITY:\n        target.initAnyPointer().initUnconstrained().setCapability();\n        return true;\n\n      case Declaration::FILE:\n      case Declaration::USING:\n      case Declaration::CONST:\n      case Declaration::ENUMERANT:\n      case Declaration::FIELD:\n      case Declaration::UNION:\n      case Declaration::GROUP:\n      case Declaration::METHOD:\n      case Declaration::ANNOTATION:\n      case Declaration::NAKED_ID:\n      case Declaration::NAKED_ANNOTATION:\n        addError(errorReporter, kj::str(\"'\", toString(), \"' is not a type.\"));\n        return false;\n    }\n\n    KJ_UNREACHABLE;\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addError",
          "args": [
            "errorReporter",
            "kj::str(\"'\", toString(), \"' is not a type.\")"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "588-590",
          "snippet": "inline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\ninline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "\"'\"",
            "toString()",
            "\"' is not a type.\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::BrandedDecl::toString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "1014-1016",
          "snippet": "kj::String NodeTranslator::BrandedDecl::toString() {\n  return expressionString(source);\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\nkj::String NodeTranslator::BrandedDecl::toString() {\n  return expressionString(source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initAnyPointer",
          "args": [],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setData",
          "args": [],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setText",
          "args": [],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setFloat64",
          "args": [],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setFloat32",
          "args": [],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setUint64",
          "args": [],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setUint32",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setUint16",
          "args": [],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setUint8",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInt64",
          "args": [],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInt32",
          "args": [],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInt16",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setInt8",
          "args": [],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setBool",
          "args": [],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setVoid",
          "args": [],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.setVoid",
          "args": [],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementType.isAnyPointer",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param->compileAsType",
          "args": [
            "errorReporter",
            "elementType"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initList",
          "args": [],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initList",
          "args": [],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "interface.setTypeId",
          "args": [
            "getIdAndFillBrand([&]() { return interface.initBrand(); })"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getIdAndFillBrand",
          "args": [
            "[&]() { return interface.initBrand(); }"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "NodeTranslator::BrandedDecl::getIdAndFillBrand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "859-864",
          "snippet": "uint64_t NodeTranslator::BrandedDecl::getIdAndFillBrand(InitBrandFunc&& initBrand) {\n  KJ_REQUIRE(body.is<Resolver::ResolvedDecl>());\n\n  brand->compile(kj::fwd<InitBrandFunc>(initBrand));\n  return body.get<Resolver::ResolvedDecl>().id;\n}",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t NodeTranslator::BrandedDecl::getIdAndFillBrand(InitBrandFunc&& initBrand) {\n  KJ_REQUIRE(body.is<Resolver::ResolvedDecl>());\n\n  brand->compile(kj::fwd<InitBrandFunc>(initBrand));\n  return body.get<Resolver::ResolvedDecl>().id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface.initBrand",
          "args": [],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initInterface",
          "args": [],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_.setTypeId",
          "args": [
            "getIdAndFillBrand([&]() { return struct_.initBrand(); })"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_.initBrand",
          "args": [],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initStruct",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_.setTypeId",
          "args": [
            "getIdAndFillBrand([&]() { return enum_.initBrand(); })"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enum_.initBrand",
          "args": [],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.initEnum",
          "args": [],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nbool NodeTranslator::BrandedDecl::compileAsType(\n    ErrorReporter& errorReporter, schema::Type::Builder target) {\n  KJ_IF_MAYBE(kind, getKind()) {\n    switch (*kind) {\n      case Declaration::ENUM: {\n        auto enum_ = target.initEnum();\n        enum_.setTypeId(getIdAndFillBrand([&]() { return enum_.initBrand(); }));\n        return true;\n      }\n\n      case Declaration::STRUCT: {\n        auto struct_ = target.initStruct();\n        struct_.setTypeId(getIdAndFillBrand([&]() { return struct_.initBrand(); }));\n        return true;\n      }\n\n      case Declaration::INTERFACE: {\n        auto interface = target.initInterface();\n        interface.setTypeId(getIdAndFillBrand([&]() { return interface.initBrand(); }));\n        return true;\n      }\n\n      case Declaration::BUILTIN_LIST: {\n        auto elementType = target.initList().initElementType();\n\n        KJ_IF_MAYBE(param, getListParam()) {\n          if (!param->compileAsType(errorReporter, elementType)) {\n            return false;\n          }\n        } else {\n          addError(errorReporter, \"'List' requires exactly one parameter.\");\n          return false;\n        }\n\n        if (elementType.isAnyPointer()) {\n          addError(errorReporter, \"'List(AnyPointer)' is not supported.\");\n          // Seeing List(AnyPointer) later can mess things up, so change the type to Void.\n          elementType.setVoid();\n          return false;\n        }\n\n        return true;\n      }\n\n      case Declaration::BUILTIN_VOID: target.setVoid(); return true;\n      case Declaration::BUILTIN_BOOL: target.setBool(); return true;\n      case Declaration::BUILTIN_INT8: target.setInt8(); return true;\n      case Declaration::BUILTIN_INT16: target.setInt16(); return true;\n      case Declaration::BUILTIN_INT32: target.setInt32(); return true;\n      case Declaration::BUILTIN_INT64: target.setInt64(); return true;\n      case Declaration::BUILTIN_U_INT8: target.setUint8(); return true;\n      case Declaration::BUILTIN_U_INT16: target.setUint16(); return true;\n      case Declaration::BUILTIN_U_INT32: target.setUint32(); return true;\n      case Declaration::BUILTIN_U_INT64: target.setUint64(); return true;\n      case Declaration::BUILTIN_FLOAT32: target.setFloat32(); return true;\n      case Declaration::BUILTIN_FLOAT64: target.setFloat64(); return true;\n      case Declaration::BUILTIN_TEXT: target.setText(); return true;\n      case Declaration::BUILTIN_DATA: target.setData(); return true;\n\n      case Declaration::BUILTIN_OBJECT:\n        addError(errorReporter,\n            \"As of Cap'n Proto 0.4, 'Object' has been renamed to 'AnyPointer'.  Sorry for the \"\n            \"inconvenience, and thanks for being an early adopter.  :)\");\n        // no break\n      case Declaration::BUILTIN_ANY_POINTER:\n        target.initAnyPointer().initUnconstrained().setAnyKind();\n        return true;\n      case Declaration::BUILTIN_ANY_STRUCT:\n        target.initAnyPointer().initUnconstrained().setStruct();\n        return true;\n      case Declaration::BUILTIN_ANY_LIST:\n        target.initAnyPointer().initUnconstrained().setList();\n        return true;\n      case Declaration::BUILTIN_CAPABILITY:\n        target.initAnyPointer().initUnconstrained().setCapability();\n        return true;\n\n      case Declaration::FILE:\n      case Declaration::USING:\n      case Declaration::CONST:\n      case Declaration::ENUMERANT:\n      case Declaration::FIELD:\n      case Declaration::UNION:\n      case Declaration::GROUP:\n      case Declaration::METHOD:\n      case Declaration::ANNOTATION:\n      case Declaration::NAKED_ID:\n      case Declaration::NAKED_ANNOTATION:\n        addError(errorReporter, kj::str(\"'\", toString(), \"' is not a type.\"));\n        return false;\n    }\n\n    KJ_UNREACHABLE;\n  }"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::asVariable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "880-884",
    "snippet": "NodeTranslator::Resolver::ResolvedParameter NodeTranslator::BrandedDecl::asVariable() {\n  KJ_REQUIRE(body.is<Resolver::ResolvedParameter>());\n\n  return body.get<Resolver::ResolvedParameter>();\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "body.get<Resolver::ResolvedParameter>",
          "args": [],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "body.is<Resolver::ResolvedParameter>()"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.is<Resolver::ResolvedParameter>",
          "args": [],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::Resolver::ResolvedParameter NodeTranslator::BrandedDecl::asVariable() {\n  KJ_REQUIRE(body.is<Resolver::ResolvedParameter>());\n\n  return body.get<Resolver::ResolvedParameter>();\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::getListParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "866-878",
    "snippet": "kj::Maybe<NodeTranslator::BrandedDecl&> NodeTranslator::BrandedDecl::getListParam() {\n  KJ_REQUIRE(body.is<Resolver::ResolvedDecl>());\n\n  auto& decl = body.get<Resolver::ResolvedDecl>();\n  KJ_REQUIRE(decl.kind == Declaration::BUILTIN_LIST);\n\n  auto params = KJ_ASSERT_NONNULL(brand->getParams(decl.id));\n  if (params.size() != 1) {\n    return nullptr;\n  } else {\n    return params[0];\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Array<BrandedDecl> params;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "brand->getParams(decl.id)"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brand->getParams",
          "args": [
            "decl.id"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "getParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "716-730",
          "snippet": "kj::Maybe<kj::ArrayPtr<BrandedDecl>> getParams(uint64_t scopeId) {\n    // Returns null if params at the requested scope should be inherited from the client scope.\n\n    if (scopeId == leafId) {\n      if (inherited) {\n        return nullptr;\n      } else {\n        return params.asPtr();\n      }\n    } else KJ_IF_MAYBE(p, parent) {\n      return p->get()->getParams(scopeId);\n    } else {\n      KJ_FAIL_REQUIRE(\"scope is not a parent\");\n    }\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "uint64_t leafId;",
            "bool inherited;",
            "kj::Array<BrandedDecl> params;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint64_t leafId;\nbool inherited;\nkj::Array<BrandedDecl> params;\n\nkj::Maybe<kj::ArrayPtr<BrandedDecl>> getParams(uint64_t scopeId) {\n    // Returns null if params at the requested scope should be inherited from the client scope.\n\n    if (scopeId == leafId) {\n      if (inherited) {\n        return nullptr;\n      } else {\n        return params.asPtr();\n      }\n    } else KJ_IF_MAYBE(p, parent) {\n      return p->get()->getParams(scopeId);\n    } else {\n      KJ_FAIL_REQUIRE(\"scope is not a parent\");\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "decl.kind == Declaration::BUILTIN_LIST"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.get<Resolver::ResolvedDecl>",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "body.is<Resolver::ResolvedDecl>()"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.is<Resolver::ResolvedDecl>",
          "args": [],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Array<BrandedDecl> params;\n\nkj::Maybe<NodeTranslator::BrandedDecl&> NodeTranslator::BrandedDecl::getListParam() {\n  KJ_REQUIRE(body.is<Resolver::ResolvedDecl>());\n\n  auto& decl = body.get<Resolver::ResolvedDecl>();\n  KJ_REQUIRE(decl.kind == Declaration::BUILTIN_LIST);\n\n  auto params = KJ_ASSERT_NONNULL(brand->getParams(decl.id));\n  if (params.size() != 1) {\n    return nullptr;\n  } else {\n    return params[0];\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::getIdAndFillBrand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "859-864",
    "snippet": "uint64_t NodeTranslator::BrandedDecl::getIdAndFillBrand(InitBrandFunc&& initBrand) {\n  KJ_REQUIRE(body.is<Resolver::ResolvedDecl>());\n\n  brand->compile(kj::fwd<InitBrandFunc>(initBrand));\n  return body.get<Resolver::ResolvedDecl>().id;\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "body.get<Resolver::ResolvedDecl>",
          "args": [],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "brand->compile",
          "args": [
            "kj::fwd<InitBrandFunc>(initBrand)"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "compile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "733-745",
          "snippet": "void compile(InitBrandFunc&& initBrand) {\n    kj::Vector<BrandScope*> levels;\n    BrandScope* ptr = this;\n    for (;;) {\n      if (ptr->params.size() > 0 || (ptr->inherited && ptr->leafParamCount > 0)) {\n        levels.add(ptr);\n      }\n      KJ_IF_MAYBE(p, ptr->parent) {\n        ptr = *p;\n      } else {\n        break;\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "uint leafParamCount;",
            "bool inherited;",
            "kj::Array<BrandedDecl> params;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint leafParamCount;\nbool inherited;\nkj::Array<BrandedDecl> params;\n\nvoid compile(InitBrandFunc&& initBrand) {\n    kj::Vector<BrandScope*> levels;\n    BrandScope* ptr = this;\n    for (;;) {\n      if (ptr->params.size() > 0 || (ptr->inherited && ptr->leafParamCount > 0)) {\n        levels.add(ptr);\n      }\n      KJ_IF_MAYBE(p, ptr->parent) {\n        ptr = *p;\n      } else {\n        break;\n      }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<InitBrandFunc>",
          "args": [
            "initBrand"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "body.is<Resolver::ResolvedDecl>()"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.is<Resolver::ResolvedDecl>",
          "args": [],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t NodeTranslator::BrandedDecl::getIdAndFillBrand(InitBrandFunc&& initBrand) {\n  KJ_REQUIRE(body.is<Resolver::ResolvedDecl>());\n\n  brand->compile(kj::fwd<InitBrandFunc>(initBrand));\n  return body.get<Resolver::ResolvedDecl>().id;\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::getKind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "850-856",
    "snippet": "kj::Maybe<Declaration::Which> NodeTranslator::BrandedDecl::getKind() {\n  if (body.is<Resolver::ResolvedParameter>()) {\n    return nullptr;\n  } else {\n    return body.get<Resolver::ResolvedDecl>().kind;\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "body.get<Resolver::ResolvedDecl>",
          "args": [],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "body.is<Resolver::ResolvedParameter>",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<Declaration::Which> NodeTranslator::BrandedDecl::getKind() {\n  if (body.is<Resolver::ResolvedParameter>()) {\n    return nullptr;\n  } else {\n    return body.get<Resolver::ResolvedDecl>().kind;\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::getMember",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "839-848",
    "snippet": "kj::Maybe<NodeTranslator::BrandedDecl> NodeTranslator::BrandedDecl::getMember(\n    kj::StringPtr memberName, Expression::Reader subSource) {\n  if (body.is<Resolver::ResolvedParameter>()) {\n    return nullptr;\n  } else KJ_IF_MAYBE(r, body.get<Resolver::ResolvedDecl>().resolver->resolveMember(memberName)) {\n    return brand->interpretResolve(*body.get<Resolver::ResolvedDecl>().resolver, *r, subSource);\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brand->interpretResolve",
          "args": [
            "*body.get<Resolver::ResolvedDecl>().resolver",
            "*r",
            "subSource"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.get<Resolver::ResolvedDecl>",
          "args": [],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "r",
            "body.get<Resolver::ResolvedDecl>().resolver->resolveMember(memberName)"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "body.get<Resolver::ResolvedDecl>",
          "args": [
            "memberName"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "body.is<Resolver::ResolvedParameter>",
          "args": [],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<NodeTranslator::BrandedDecl> NodeTranslator::BrandedDecl::getMember(\n    kj::StringPtr memberName, Expression::Reader subSource) {\n  if (body.is<Resolver::ResolvedParameter>()) {\n    return nullptr;\n  } else KJ_IF_MAYBE(r, body.get<Resolver::ResolvedDecl>().resolver->resolveMember(memberName)) {\n    return brand->interpretResolve(*body.get<Resolver::ResolvedDecl>().resolver, *r, subSource);\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::applyParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "824-837",
    "snippet": "kj::Maybe<NodeTranslator::BrandedDecl> NodeTranslator::BrandedDecl::applyParams(\n    kj::Array<BrandedDecl> params, Expression::Reader subSource) {\n  if (body.is<Resolver::ResolvedParameter>()) {\n    return nullptr;\n  } else {\n    return brand->setParams(kj::mv(params), body.get<Resolver::ResolvedDecl>().kind, subSource)\n        .map([&](kj::Own<BrandScope>& scope) {\n      BrandedDecl result = *this;\n      result.brand = kj::mv(scope);\n      result.source = subSource;\n      return result;\n    });\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "kj::Array<BrandedDecl> params;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brand->setParams",
          "args": [
            "[&](kj::Own<BrandScope>& scope) {\n      BrandedDecl result = *this;\n      result.brand = kj::mv(scope);\n      result.source = subSource;\n      return result;\n    }"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "scope"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brand->setParams",
          "args": [
            "kj::mv(params)",
            "body.get<Resolver::ResolvedDecl>().kind",
            "subSource"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.get<Resolver::ResolvedDecl>",
          "args": [],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "params"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.is<Resolver::ResolvedParameter>",
          "args": [],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nkj::Array<BrandedDecl> params;\n\nkj::Maybe<NodeTranslator::BrandedDecl> NodeTranslator::BrandedDecl::applyParams(\n    kj::Array<BrandedDecl> params, Expression::Reader subSource) {\n  if (body.is<Resolver::ResolvedParameter>()) {\n    return nullptr;\n  } else {\n    return brand->setParams(kj::mv(params), body.get<Resolver::ResolvedDecl>().kind, subSource)\n        .map([&](kj::Own<BrandScope>& scope) {\n      BrandedDecl result = *this;\n      result.brand = kj::mv(scope);\n      result.source = subSource;\n      return result;\n    });\n  }\n}"
  },
  {
    "function_name": "NodeTranslator::BrandedDecl::BrandedDecl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "807-813",
    "snippet": "NodeTranslator::BrandedDecl::BrandedDecl(BrandedDecl& other)\n    : body(other.body),\n      source(other.source) {\n  if (body.is<Resolver::ResolvedDecl>()) {\n    brand = kj::addRef(*other.brand);\n  }\n}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*other.brand"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "body.is<Resolver::ResolvedDecl>",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "is",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "61-63",
          "snippet": "bool is() const {\n    return tag == typeIndex<T>();\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  bool is() const {\n      return tag == typeIndex<T>();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\nNodeTranslator::BrandedDecl::BrandedDecl(BrandedDecl& other)\n    : body(other.body),\n      source(other.source) {\n  if (body.is<Resolver::ResolvedDecl>()) {\n    brand = kj::addRef(*other.brand);\n  }\n}"
  },
  {
    "function_name": "BrandScope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "800-801",
    "snippet": "BrandScope(ErrorReporter& errorReporter, uint64_t scopeId)\n      : errorReporter(errorReporter), leafId(scopeId), leafParamCount(0), inherited(false) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint64_t leafId;",
      "uint leafParamCount;",
      "bool inherited;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\nuint leafParamCount;\nbool inherited;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nBrandScope(ErrorReporter& errorReporter, uint64_t scopeId)\n      : errorReporter(errorReporter), leafId(scopeId), leafParamCount(0), inherited(false) {}"
  },
  {
    "function_name": "BrandScope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "792-799",
    "snippet": "BrandScope(BrandScope& base, kj::Array<BrandedDecl> params)\n      : errorReporter(base.errorReporter),\n        leafId(base.leafId), leafParamCount(base.leafParamCount),\n        inherited(false), params(kj::mv(params)) {\n    KJ_IF_MAYBE(p, base.parent) {\n      parent = kj::addRef(**p);\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "uint64_t leafId;",
      "uint leafParamCount;",
      "bool inherited;",
      "kj::Array<BrandedDecl> params;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "**p"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "p",
            "base.parent"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "params"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint64_t leafId;\nuint leafParamCount;\nbool inherited;\nkj::Array<BrandedDecl> params;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nBrandScope(BrandScope& base, kj::Array<BrandedDecl> params)\n      : errorReporter(base.errorReporter),\n        leafId(base.leafId), leafParamCount(base.leafParamCount),\n        inherited(false), params(kj::mv(params)) {\n    KJ_IF_MAYBE(p, base.parent) {\n      parent = kj::addRef(**p);\n    }\n  }"
  },
  {
    "function_name": "BrandScope",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "788-791",
    "snippet": "BrandScope(kj::Own<NodeTranslator::BrandScope> parent, uint64_t leafId, uint leafParamCount)\n      : errorReporter(parent->errorReporter),\n        parent(kj::mv(parent)), leafId(leafId), leafParamCount(leafParamCount),\n        inherited(false) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "uint64_t leafId;",
      "uint leafParamCount;",
      "bool inherited;",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "parent"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint64_t leafId;\nuint leafParamCount;\nbool inherited;\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nBrandScope(kj::Own<NodeTranslator::BrandScope> parent, uint64_t leafId, uint leafParamCount)\n      : errorReporter(parent->errorReporter),\n        parent(kj::mv(parent)), leafId(leafId), leafParamCount(leafParamCount),\n        inherited(false) {}"
  },
  {
    "function_name": "getScopeId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "778-778",
    "snippet": "inline uint64_t getScopeId() { return leafId; }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint64_t leafId;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
  },
  {
    "function_name": "compile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "733-745",
    "snippet": "void compile(InitBrandFunc&& initBrand) {\n    kj::Vector<BrandScope*> levels;\n    BrandScope* ptr = this;\n    for (;;) {\n      if (ptr->params.size() > 0 || (ptr->inherited && ptr->leafParamCount > 0)) {\n        levels.add(ptr);\n      }\n      KJ_IF_MAYBE(p, ptr->parent) {\n        ptr = *p;\n      } else {\n        break;\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "uint leafParamCount;",
      "bool inherited;",
      "kj::Array<BrandedDecl> params;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "p",
            "ptr->parent"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "levels.add",
          "args": [
            "ptr"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr->params.size",
          "args": [],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint leafParamCount;\nbool inherited;\nkj::Array<BrandedDecl> params;\n\nvoid compile(InitBrandFunc&& initBrand) {\n    kj::Vector<BrandScope*> levels;\n    BrandScope* ptr = this;\n    for (;;) {\n      if (ptr->params.size() > 0 || (ptr->inherited && ptr->leafParamCount > 0)) {\n        levels.add(ptr);\n      }\n      KJ_IF_MAYBE(p, ptr->parent) {\n        ptr = *p;\n      } else {\n        break;\n      }\n    }"
  },
  {
    "function_name": "getParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "716-730",
    "snippet": "kj::Maybe<kj::ArrayPtr<BrandedDecl>> getParams(uint64_t scopeId) {\n    // Returns null if params at the requested scope should be inherited from the client scope.\n\n    if (scopeId == leafId) {\n      if (inherited) {\n        return nullptr;\n      } else {\n        return params.asPtr();\n      }\n    } else KJ_IF_MAYBE(p, parent) {\n      return p->get()->getParams(scopeId);\n    } else {\n      KJ_FAIL_REQUIRE(\"scope is not a parent\");\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "uint64_t leafId;",
      "bool inherited;",
      "kj::Array<BrandedDecl> params;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"scope is not a parent\""
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->get",
          "args": [
            "scopeId"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "AdapterPromiseNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "631-634",
          "snippet": "void get(ExceptionOrValue& output) noexcept override {\n    KJ_IREQUIRE(!isWaiting());\n    output.as<T>() = kj::mv(result);\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "AdapterPromiseNode {\n  void get(ExceptionOrValue& output) noexcept override {\n      KJ_IREQUIRE(!isWaiting());\n      output.as<T>() = kj::mv(result);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "p->get",
          "args": [],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "p",
            "parent"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "params.asPtr",
          "args": [],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "asPtr",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "313-315",
          "snippet": "inline ArrayPtr<const T> asPtr() const {\n    return arrayPtr(ptr, pos);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  inline ArrayPtr<const T> asPtr() const {\n      return arrayPtr(ptr, pos);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint64_t leafId;\nbool inherited;\nkj::Array<BrandedDecl> params;\n\nkj::Maybe<kj::ArrayPtr<BrandedDecl>> getParams(uint64_t scopeId) {\n    // Returns null if params at the requested scope should be inherited from the client scope.\n\n    if (scopeId == leafId) {\n      if (inherited) {\n        return nullptr;\n      } else {\n        return params.asPtr();\n      }\n    } else KJ_IF_MAYBE(p, parent) {\n      return p->get()->getParams(scopeId);\n    } else {\n      KJ_FAIL_REQUIRE(\"scope is not a parent\");\n    }\n  }"
  },
  {
    "function_name": "kj::Maybe<BrandedDecl> lookupParameter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "605-714",
    "snippet": "class NodeTranslator::BrandScope: public kj::Refcounted {\n  // Tracks the brand parameter bindings affecting the current scope. For example, if we are\n  // interpreting the type expression \"Foo(Text).Bar\", we would start with the current scopes\n  // BrandScope, create a new child BrandScope representing \"Foo\", add the \"(Text)\" parameter\n  // bindings to it, then create a further child scope for \"Bar\". Thus the BrandScope for Bar\n  // knows that Foo's parameter list has been bound to \"(Text)\".\n  //\n  // TODO(cleanup): This is too complicated to live here. We should refactor this class and\n  //   BrandedDecl out into their own file, independent of NodeTranslator.\n\npublic:\n  BrandScope(ErrorReporter& errorReporter, uint64_t startingScopeId,\n             uint startingScopeParamCount, Resolver& startingScope)\n      : errorReporter(errorReporter), parent(nullptr), leafId(startingScopeId),\n        leafParamCount(startingScopeParamCount), inherited(true) {\n    // Create all lexical parent scopes, all with no brand bindings.\n    KJ_IF_MAYBE(p, startingScope.getParent()) {\n      parent = kj::refcounted<BrandScope>(\n          errorReporter, p->id, p->genericParamCount, *p->resolver);\n    }\n  }\n\n  bool isGeneric() {\n    if (leafParamCount > 0) return true;\n\n    KJ_IF_MAYBE(p, parent) {\n      return p->get()->isGeneric();\n    } else {\n      return false;\n    }\n  }\n\n  kj::Own<BrandScope> push(uint64_t typeId, uint paramCount) {\n    return kj::refcounted<BrandScope>(kj::addRef(*this), typeId, paramCount);\n  }\n\n  kj::Maybe<kj::Own<BrandScope>> setParams(\n      kj::Array<BrandedDecl> params, Declaration::Which genericType, Expression::Reader source) {\n    if (this->params.size() != 0) {\n      errorReporter.addErrorOn(source, \"Double-application of generic parameters.\");\n      return nullptr;\n    } else if (params.size() > leafParamCount) {\n      if (leafParamCount == 0) {\n        errorReporter.addErrorOn(source, \"Declaration does not accept generic parameters.\");\n      } else {\n        errorReporter.addErrorOn(source, \"Too many generic parameters.\");\n      }\n      return nullptr;\n    } else if (params.size() < leafParamCount) {\n      errorReporter.addErrorOn(source, \"Not enough generic parameters.\");\n      return nullptr;\n    } else {\n      if (genericType != Declaration::BUILTIN_LIST) {\n        for (auto& param: params) {\n          KJ_IF_MAYBE(kind, param.getKind()) {\n            switch (*kind) {\n              case Declaration::BUILTIN_LIST:\n              case Declaration::BUILTIN_TEXT:\n              case Declaration::BUILTIN_DATA:\n              case Declaration::BUILTIN_ANY_POINTER:\n              case Declaration::STRUCT:\n              case Declaration::INTERFACE:\n                break;\n\n              default:\n                param.addError(errorReporter,\n                    \"Sorry, only pointer types can be used as generic parameters.\");\n                break;\n            }\n          }\n        }\n      }\n\n      return kj::refcounted<BrandScope>(*this, kj::mv(params));\n    }\n  }\n\n  kj::Own<BrandScope> pop(uint64_t newLeafId) {\n    if (leafId == newLeafId) {\n      return kj::addRef(*this);\n    }\n    KJ_IF_MAYBE(p, parent) {\n      return (*p)->pop(newLeafId);\n    } else {\n      // Looks like we're moving into a whole top-level scope.\n      return kj::refcounted<BrandScope>(errorReporter, newLeafId);\n    }\n  }\n\n  kj::Maybe<BrandedDecl> lookupParameter(Resolver& resolver, uint64_t scopeId, uint index) {\n    // Returns null if the param should be inherited from the client scope.\n\n    if (scopeId == leafId) {\n      if (index < params.size()) {\n        return params[index];\n      } else if (inherited) {\n        return nullptr;\n      } else {\n        // Unbound and not inherited, so return AnyPointer.\n        auto decl = resolver.resolveBuiltin(Declaration::BUILTIN_ANY_POINTER);\n        return BrandedDecl(decl,\n            evaluateBrand(resolver, decl, List<schema::Brand::Scope>::Reader()),\n            Expression::Reader());\n      }\n    } else KJ_IF_MAYBE(p, parent) {\n      return p->get()->lookupParameter(resolver, scopeId, index);\n    } else {\n      KJ_FAIL_REQUIRE(\"scope is not a parent\");\n    }\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);",
      "BrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);",
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "uint64_t leafId;",
      "uint leafParamCount;",
      "bool inherited;",
      "kj::Array<BrandedDecl> params;",
      "auto list = interfaceBuilder.initMethods(methods.size());",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"scope is not a parent\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->get",
          "args": [
            "resolver",
            "scopeId",
            "index"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p->get",
          "args": [],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "p",
            "parent"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "BrandedDecl",
          "args": [
            "decl",
            "evaluateBrand(resolver, decl, List<schema::Brand::Scope>::Reader())",
            "Expression::Reader()"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "BrandedDecl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "531-536",
          "snippet": "inline BrandedDecl(Resolver::ResolvedDecl decl,\n                     kj::Own<NodeTranslator::BrandScope>&& brand,\n                     Expression::Reader source)\n      : brand(kj::mv(brand)), source(source) {\n    body.init<Resolver::ResolvedDecl>(kj::mv(decl));\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\ninline BrandedDecl(Resolver::ResolvedDecl decl,\n                     kj::Own<NodeTranslator::BrandScope>&& brand,\n                     Expression::Reader source)\n      : brand(kj::mv(brand)), source(source) {\n    body.init<Resolver::ResolvedDecl>(kj::mv(decl));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluateBrand",
          "args": [
            "resolver",
            "decl",
            "List<schema::Brand::Scope>::Reader()"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "List<schema::Brand::Scope>::Reader",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolver.resolveBuiltin",
          "args": [
            "Declaration::BUILTIN_ANY_POINTER"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "return kj::refcounted<BrandScope>",
          "args": [
            "errorReporter",
            "newLeafId"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "newLeafId"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<BrandScope>",
          "args": [
            "*this",
            "kj::mv(params)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "params"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.addError",
          "args": [
            "errorReporter",
            "\"Sorry, only pointer types can be used as generic parameters.\""
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "addError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "588-590",
          "snippet": "inline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
            "DuplicateOrdinalDetector dupDetector(errorReporter);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\ninline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "param.getKind",
          "args": [],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "getKind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "77-77",
          "snippet": "Declaration::Which getKind() { return kind; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nDeclaration::Which getKind() { return kind; }"
        }
      },
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "source",
            "\"Not enough generic parameters.\""
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<BrandScope>",
          "args": [
            "kj::addRef(*this)",
            "typeId",
            "paramCount"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::refcounted<BrandScope>",
          "args": [
            "errorReporter",
            "p->id",
            "p->genericParamCount",
            "*p->resolver"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "startingScope.getParent",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\nBrandedDecl decompileType(Resolver& resolver, schema::Type::Reader type);\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint64_t leafId;\nuint leafParamCount;\nbool inherited;\nkj::Array<BrandedDecl> params;\nauto list = interfaceBuilder.initMethods(methods.size());\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\nclass NodeTranslator::BrandScope: public kj::Refcounted {\n  // Tracks the brand parameter bindings affecting the current scope. For example, if we are\n  // interpreting the type expression \"Foo(Text).Bar\", we would start with the current scopes\n  // BrandScope, create a new child BrandScope representing \"Foo\", add the \"(Text)\" parameter\n  // bindings to it, then create a further child scope for \"Bar\". Thus the BrandScope for Bar\n  // knows that Foo's parameter list has been bound to \"(Text)\".\n  //\n  // TODO(cleanup): This is too complicated to live here. We should refactor this class and\n  //   BrandedDecl out into their own file, independent of NodeTranslator.\n\npublic:\n  BrandScope(ErrorReporter& errorReporter, uint64_t startingScopeId,\n             uint startingScopeParamCount, Resolver& startingScope)\n      : errorReporter(errorReporter), parent(nullptr), leafId(startingScopeId),\n        leafParamCount(startingScopeParamCount), inherited(true) {\n    // Create all lexical parent scopes, all with no brand bindings.\n    KJ_IF_MAYBE(p, startingScope.getParent()) {\n      parent = kj::refcounted<BrandScope>(\n          errorReporter, p->id, p->genericParamCount, *p->resolver);\n    }\n  }\n\n  bool isGeneric() {\n    if (leafParamCount > 0) return true;\n\n    KJ_IF_MAYBE(p, parent) {\n      return p->get()->isGeneric();\n    } else {\n      return false;\n    }\n  }\n\n  kj::Own<BrandScope> push(uint64_t typeId, uint paramCount) {\n    return kj::refcounted<BrandScope>(kj::addRef(*this), typeId, paramCount);\n  }\n\n  kj::Maybe<kj::Own<BrandScope>> setParams(\n      kj::Array<BrandedDecl> params, Declaration::Which genericType, Expression::Reader source) {\n    if (this->params.size() != 0) {\n      errorReporter.addErrorOn(source, \"Double-application of generic parameters.\");\n      return nullptr;\n    } else if (params.size() > leafParamCount) {\n      if (leafParamCount == 0) {\n        errorReporter.addErrorOn(source, \"Declaration does not accept generic parameters.\");\n      } else {\n        errorReporter.addErrorOn(source, \"Too many generic parameters.\");\n      }\n      return nullptr;\n    } else if (params.size() < leafParamCount) {\n      errorReporter.addErrorOn(source, \"Not enough generic parameters.\");\n      return nullptr;\n    } else {\n      if (genericType != Declaration::BUILTIN_LIST) {\n        for (auto& param: params) {\n          KJ_IF_MAYBE(kind, param.getKind()) {\n            switch (*kind) {\n              case Declaration::BUILTIN_LIST:\n              case Declaration::BUILTIN_TEXT:\n              case Declaration::BUILTIN_DATA:\n              case Declaration::BUILTIN_ANY_POINTER:\n              case Declaration::STRUCT:\n              case Declaration::INTERFACE:\n                break;\n\n              default:\n                param.addError(errorReporter,\n                    \"Sorry, only pointer types can be used as generic parameters.\");\n                break;\n            }\n          }\n        }\n      }\n\n      return kj::refcounted<BrandScope>(*this, kj::mv(params));\n    }\n  }\n\n  kj::Own<BrandScope> pop(uint64_t newLeafId) {\n    if (leafId == newLeafId) {\n      return kj::addRef(*this);\n    }\n    KJ_IF_MAYBE(p, parent) {\n      return (*p)->pop(newLeafId);\n    } else {\n      // Looks like we're moving into a whole top-level scope.\n      return kj::refcounted<BrandScope>(errorReporter, newLeafId);\n    }\n  }\n\n  kj::Maybe<BrandedDecl> lookupParameter(Resolver& resolver, uint64_t scopeId, uint index) {\n    // Returns null if the param should be inherited from the client scope.\n\n    if (scopeId == leafId) {\n      if (index < params.size()) {\n        return params[index];\n      } else if (inherited) {\n        return nullptr;\n      } else {\n        // Unbound and not inherited, so return AnyPointer.\n        auto decl = resolver.resolveBuiltin(Declaration::BUILTIN_ANY_POINTER);\n        return BrandedDecl(decl,\n            evaluateBrand(resolver, decl, List<schema::Brand::Scope>::Reader()),\n            Expression::Reader());\n      }\n    } else KJ_IF_MAYBE(p, parent) {\n      return p->get()->lookupParameter(resolver, scopeId, index);\n    } else {\n      KJ_FAIL_REQUIRE(\"scope is not a parent\");\n    }\n  }"
  },
  {
    "function_name": "addError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "588-590",
    "snippet": "inline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);",
      "DuplicateOrdinalDetector dupDetector(errorReporter);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errorReporter.addErrorOn",
          "args": [
            "source",
            "message"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "addErrorOn",
          "container": "ErrorReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/error-reporter.h",
          "lines": "47-52",
          "snippet": "inline void addErrorOn(T&& decl, kj::StringPtr message) {\n    // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n    // of the Cap'n Proto types defined in `grammar.capnp` do.\n\n    addError(decl.getStartByte(), decl.getEndByte(), message);\n  }",
          "includes": [
            "#include <kj/vector.h>",
            "#include <kj/exception.h>",
            "#include <kj/string.h>",
            "#include \"../common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/vector.h>\n#include <kj/exception.h>\n#include <kj/string.h>\n#include \"../common.h\"\n\nErrorReporter {\n  inline void addErrorOn(T&& decl, kj::StringPtr message) {\n      // Works for any `T` that defines `getStartByte()` and `getEndByte()` methods, which many\n      // of the Cap'n Proto types defined in `grammar.capnp` do.\n  \n      addError(decl.getStartByte(), decl.getEndByte(), message);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\nDuplicateOrdinalDetector dupDetector(errorReporter);\n\ninline void addError(ErrorReporter& errorReporter, kj::StringPtr message) {\n    errorReporter.addErrorOn(source, message);\n  }"
  },
  {
    "function_name": "implicitMethodParam",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "543-547",
    "snippet": "static BrandedDecl implicitMethodParam(uint index) {\n    // Get a BrandedDecl referring to an implicit method parameter.\n    // (As a hack, we internally represent this as a ResolvedParameter. Sorry.)\n    return BrandedDecl(Resolver::ResolvedParameter { 0, index }, Expression::Reader());\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BrandedDecl",
          "args": [
            "Resolver::ResolvedParameter { 0, index }",
            "Expression::Reader()"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "BrandedDecl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "537-540",
          "snippet": "inline BrandedDecl(Resolver::ResolvedParameter variable, Expression::Reader source)\n      : source(source) {\n    body.init<Resolver::ResolvedParameter>(kj::mv(variable));\n  }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\ninline BrandedDecl(Resolver::ResolvedParameter variable, Expression::Reader source)\n      : source(source) {\n    body.init<Resolver::ResolvedParameter>(kj::mv(variable));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "Expression::Reader",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Own<NodeTranslator::BrandScope> evaluateBrand(\n      Resolver& resolver, Resolver::ResolvedDecl decl,\n      List<schema::Brand::Scope>::Reader brand, uint index = 0);\n\nstatic BrandedDecl implicitMethodParam(uint index) {\n    // Get a BrandedDecl referring to an implicit method parameter.\n    // (As a hack, we internally represent this as a ResolvedParameter. Sorry.)\n    return BrandedDecl(Resolver::ResolvedParameter { 0, index }, Expression::Reader());\n  }"
  },
  {
    "function_name": "BrandedDecl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "541-541",
    "snippet": "inline BrandedDecl(decltype(nullptr)) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\ninline BrandedDecl(decltype(nullptr)) {}"
  },
  {
    "function_name": "BrandedDecl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "537-540",
    "snippet": "inline BrandedDecl(Resolver::ResolvedParameter variable, Expression::Reader source)\n      : source(source) {\n    body.init<Resolver::ResolvedParameter>(kj::mv(variable));\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "body.init<Resolver::ResolvedParameter>",
          "args": [
            "kj::mv(variable)"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "variable"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\ninline BrandedDecl(Resolver::ResolvedParameter variable, Expression::Reader source)\n      : source(source) {\n    body.init<Resolver::ResolvedParameter>(kj::mv(variable));\n  }"
  },
  {
    "function_name": "BrandedDecl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "531-536",
    "snippet": "inline BrandedDecl(Resolver::ResolvedDecl decl,\n                     kj::Own<NodeTranslator::BrandScope>&& brand,\n                     Expression::Reader source)\n      : brand(kj::mv(brand)), source(source) {\n    body.init<Resolver::ResolvedDecl>(kj::mv(decl));\n  }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "NodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "body.init<Resolver::ResolvedDecl>",
          "args": [
            "kj::mv(decl)"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/pointer-helpers.h",
          "lines": "51-53",
          "snippet": "static inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"layout.h\"\n\nstatic inline typename T::Builder init(PointerBuilder builder) {\n    return typename T::Builder(builder.initStruct(structSize<T>()));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "decl"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "brand"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nNodeTranslator::BrandedDecl interpretResolve(\n      Resolver& resolver, Resolver::ResolveResult& result, Expression::Reader source);\n\ninline BrandedDecl(Resolver::ResolvedDecl decl,\n                     kj::Own<NodeTranslator::BrandScope>&& brand,\n                     Expression::Reader source)\n      : brand(kj::mv(brand)), source(source) {\n    body.init<Resolver::ResolvedDecl>(kj::mv(decl));\n  }"
  },
  {
    "function_name": "tryExpandData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "489-513",
    "snippet": "bool tryExpandData(uint oldLgSize, uint oldOffset, uint expansionFactor) override {\n      if (oldLgSize + expansionFactor > 6 ||\n          (oldOffset & ((1 << expansionFactor) - 1)) != 0) {\n        // Expansion is not possible because the new size is too large or the offset is not\n        // properly-aligned.\n      }\n\n      for (uint i = 0; i < parentDataLocationUsage.size(); i++) {\n        auto& location = parent.dataLocations[i];\n        if (location.lgSize >= oldLgSize &&\n            oldOffset >> (location.lgSize - oldLgSize) == location.offset) {\n          // The location we're trying to expand is a subset of this data location.\n          auto& usage = parentDataLocationUsage[i];\n\n          // Adjust the offset to be only within this location.\n          uint localOldOffset = oldOffset - (location.offset << (location.lgSize - oldLgSize));\n\n          // Try to expand.\n          return usage.tryExpand(*this, location, oldLgSize, localOldOffset, expansionFactor);\n        }\n      }\n\n      KJ_FAIL_ASSERT(\"Tried to expand field that was never allocated.\");\n      return false;\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "uint i = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Tried to expand field that was never allocated.\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage.tryExpand",
          "args": [
            "*this",
            "location",
            "oldLgSize",
            "localOldOffset",
            "expansionFactor"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "tryExpand",
          "container": "Group",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "374-386",
          "snippet": "bool tryExpand(Group& group, Union::DataLocation& location,\n                     uint oldLgSize, uint oldOffset, uint expansionFactor) {\n        if (oldOffset == 0 && lgSizeUsed == oldLgSize) {\n          // This location contains exactly the requested data, so just expand the whole thing.\n          return tryExpandUsage(group, location, oldLgSize + expansionFactor);\n        } else {\n          // This location contains the requested data plus other stuff.  Therefore the data cannot\n          // possibly expand past the end of the space we've already marked used without either\n          // overlapping with something else or breaking alignment rules.  We only have to combine\n          // it with holes.\n          return holes.tryExpand(oldLgSize, oldOffset, expansionFactor);\n        }\n      }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nGroup {\n  bool tryExpand(Group& group, Union::DataLocation& location,\n                       uint oldLgSize, uint oldOffset, uint expansionFactor) {\n          if (oldOffset == 0 && lgSizeUsed == oldLgSize) {\n            // This location contains exactly the requested data, so just expand the whole thing.\n            return tryExpandUsage(group, location, oldLgSize + expansionFactor);\n          } else {\n            // This location contains the requested data plus other stuff.  Therefore the data cannot\n            // possibly expand past the end of the space we've already marked used without either\n            // overlapping with something else or breaking alignment rules.  We only have to combine\n            // it with holes.\n            return holes.tryExpand(oldLgSize, oldOffset, expansionFactor);\n          }\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parentDataLocationUsage.size",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint i = 0;\n\nbool tryExpandData(uint oldLgSize, uint oldOffset, uint expansionFactor) override {\n      if (oldLgSize + expansionFactor > 6 ||\n          (oldOffset & ((1 << expansionFactor) - 1)) != 0) {\n        // Expansion is not possible because the new size is too large or the offset is not\n        // properly-aligned.\n      }\n\n      for (uint i = 0; i < parentDataLocationUsage.size(); i++) {\n        auto& location = parent.dataLocations[i];\n        if (location.lgSize >= oldLgSize &&\n            oldOffset >> (location.lgSize - oldLgSize) == location.offset) {\n          // The location we're trying to expand is a subset of this data location.\n          auto& usage = parentDataLocationUsage[i];\n\n          // Adjust the offset to be only within this location.\n          uint localOldOffset = oldOffset - (location.offset << (location.lgSize - oldLgSize));\n\n          // Try to expand.\n          return usage.tryExpand(*this, location, oldLgSize, localOldOffset, expansionFactor);\n        }\n      }\n\n      KJ_FAIL_ASSERT(\"Tried to expand field that was never allocated.\");\n      return false;\n    }"
  },
  {
    "function_name": "addPointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "478-487",
    "snippet": "uint addPointer() override {\n      addVoid();\n\n      if (parentPointerLocationUsage < parent.pointerLocations.size()) {\n        return parent.pointerLocations[parentPointerLocationUsage++];\n      } else {\n        parentPointerLocationUsage++;\n        return parent.addNewPointerLocation();\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent.addNewPointerLocation",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "addNewPointerLocation",
          "container": "Union",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "245-249",
          "snippet": "uint addNewPointerLocation() {\n      // Add a whole new pointer location to the union with the given size.\n\n      return pointerLocations.add(parent.addPointer());\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  uint addNewPointerLocation() {\n        // Add a whole new pointer location to the union with the given size.\n  \n        return pointerLocations.add(parent.addPointer());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent.pointerLocations.size",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addVoid",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "addVoid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "430-435",
          "snippet": "void addVoid() override {\n      if (!hasMembers) {\n        hasMembers = true;\n        parent.newGroupAddingFirstMember();\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nvoid addVoid() override {\n      if (!hasMembers) {\n        hasMembers = true;\n        parent.newGroupAddingFirstMember();\n      }\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nuint addPointer() override {\n      addVoid();\n\n      if (parentPointerLocationUsage < parent.pointerLocations.size()) {\n        return parent.pointerLocations[parentPointerLocationUsage++];\n      } else {\n        parentPointerLocationUsage++;\n        return parent.addNewPointerLocation();\n      }\n    }"
  },
  {
    "function_name": "addData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "437-476",
    "snippet": "uint addData(uint lgSize) override {\n      addVoid();\n\n      uint bestSize = kj::maxValue;\n      kj::Maybe<uint> bestLocation = nullptr;\n\n      for (uint i = 0; i < parent.dataLocations.size(); i++) {\n        // If we haven't seen this DataLocation yet, add a corresponding DataLocationUsage.\n        if (parentDataLocationUsage.size() == i) {\n          parentDataLocationUsage.add();\n        }\n\n        auto& usage = parentDataLocationUsage[i];\n        KJ_IF_MAYBE(hole, usage.smallestHoleAtLeast(parent.dataLocations[i], lgSize)) {\n          if (*hole < bestSize) {\n            bestSize = *hole;\n            bestLocation = i;\n          }\n        }\n      }\n\n      KJ_IF_MAYBE(best, bestLocation) {\n        return parentDataLocationUsage[*best].allocateFromHole(\n            *this, parent.dataLocations[*best], lgSize);\n      }\n\n      // There are no holes at all in the union big enough to fit this field.  Go back through all\n      // of the locations and attempt to expand them to fit.\n      for (uint i = 0; i < parent.dataLocations.size(); i++) {\n        KJ_IF_MAYBE(result, parentDataLocationUsage[i].tryAllocateByExpanding(\n            *this, parent.dataLocations[i], lgSize)) {\n          return *result;\n        }\n      }\n\n      // Couldn't find any space in the existing locations, so add a new one.\n      uint result = parent.addNewDataLocation(lgSize);\n      parentDataLocationUsage.add(lgSize);\n      return result;\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
      "uint i = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parentDataLocationUsage.add",
          "args": [
            "lgSize"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent.addNewDataLocation",
          "args": [
            "lgSize"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "addNewDataLocation",
          "container": "Union",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "237-243",
          "snippet": "uint addNewDataLocation(uint lgSize) {\n      // Add a whole new data location to the union with the given size.\n\n      uint offset = parent.addData(lgSize);\n      dataLocations.add(DataLocation { lgSize, offset });\n      return offset;\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  uint addNewDataLocation(uint lgSize) {\n        // Add a whole new data location to the union with the given size.\n  \n        uint offset = parent.addData(lgSize);\n        dataLocations.add(DataLocation { lgSize, offset });\n        return offset;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "result",
            "parentDataLocationUsage[i].tryAllocateByExpanding(\n            *this, parent.dataLocations[i], lgSize)"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "parentDataLocationUsage[i].tryAllocateByExpanding",
          "args": [
            "*this",
            "parent.dataLocations[i]",
            "lgSize"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent.dataLocations.size",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parentDataLocationUsage[*best].allocateFromHole",
          "args": [
            "*this",
            "parent.dataLocations[*best]",
            "lgSize"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage.smallestHoleAtLeast",
          "args": [
            "parent.dataLocations[i]",
            "lgSize"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parentDataLocationUsage.add",
          "args": [],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addVoid",
          "args": [],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "addVoid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "430-435",
          "snippet": "void addVoid() override {\n      if (!hasMembers) {\n        hasMembers = true;\n        parent.newGroupAddingFirstMember();\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nvoid addVoid() override {\n      if (!hasMembers) {\n        hasMembers = true;\n        parent.newGroupAddingFirstMember();\n      }\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint i = 0;\n\nuint addData(uint lgSize) override {\n      addVoid();\n\n      uint bestSize = kj::maxValue;\n      kj::Maybe<uint> bestLocation = nullptr;\n\n      for (uint i = 0; i < parent.dataLocations.size(); i++) {\n        // If we haven't seen this DataLocation yet, add a corresponding DataLocationUsage.\n        if (parentDataLocationUsage.size() == i) {\n          parentDataLocationUsage.add();\n        }\n\n        auto& usage = parentDataLocationUsage[i];\n        KJ_IF_MAYBE(hole, usage.smallestHoleAtLeast(parent.dataLocations[i], lgSize)) {\n          if (*hole < bestSize) {\n            bestSize = *hole;\n            bestLocation = i;\n          }\n        }\n      }\n\n      KJ_IF_MAYBE(best, bestLocation) {\n        return parentDataLocationUsage[*best].allocateFromHole(\n            *this, parent.dataLocations[*best], lgSize);\n      }\n\n      // There are no holes at all in the union big enough to fit this field.  Go back through all\n      // of the locations and attempt to expand them to fit.\n      for (uint i = 0; i < parent.dataLocations.size(); i++) {\n        KJ_IF_MAYBE(result, parentDataLocationUsage[i].tryAllocateByExpanding(\n            *this, parent.dataLocations[i], lgSize)) {\n          return *result;\n        }\n      }\n\n      // Couldn't find any space in the existing locations, so add a new one.\n      uint result = parent.addNewDataLocation(lgSize);\n      parentDataLocationUsage.add(lgSize);\n      return result;\n    }"
  },
  {
    "function_name": "addVoid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "430-435",
    "snippet": "void addVoid() override {\n      if (!hasMembers) {\n        hasMembers = true;\n        parent.newGroupAddingFirstMember();\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent.newGroupAddingFirstMember",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "newGroupAddingFirstMember",
          "container": "Union",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "251-255",
          "snippet": "void newGroupAddingFirstMember() {\n      if (++groupCount == 2) {\n        addDiscriminant();\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nUnion {\n  void newGroupAddingFirstMember() {\n        if (++groupCount == 2) {\n          addDiscriminant();\n        }\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nvoid addVoid() override {\n      if (!hasMembers) {\n        hasMembers = true;\n        parent.newGroupAddingFirstMember();\n      }\n    }"
  },
  {
    "function_name": "Group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "427-427",
    "snippet": "inline Group(Union& parent): parent(parent) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\ninline Group(Union& parent): parent(parent) {}"
  },
  {
    "function_name": "tryExpandUsage",
    "container": "Group",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "401-413",
    "snippet": "bool tryExpandUsage(Group& group, Union::DataLocation& location, uint desiredUsage) {\n        if (desiredUsage > location.lgSize) {\n          // Need to expand the underlying slot.\n          if (!location.tryExpandTo(group.parent, desiredUsage)) {\n            return false;\n          }\n        }\n\n        // Underlying slot is big enough, so expand our size and update holes.\n        holes.addHolesAtEnd(lgSizeUsed, 1, desiredUsage);\n        lgSizeUsed = desiredUsage;\n        return true;\n      }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "holes.addHolesAtEnd",
          "args": [
            "lgSizeUsed",
            "1",
            "desiredUsage"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "location.tryExpandTo",
          "args": [
            "group.parent",
            "desiredUsage"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "tryExpandTo",
          "container": "Union::DataLocation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "215-225",
          "snippet": "bool tryExpandTo(Union& u, uint newLgSize) {\n        if (newLgSize <= lgSize) {\n          return true;\n        } else if (u.parent.tryExpandData(lgSize, offset, newLgSize - lgSize)) {\n          offset >>= (newLgSize - lgSize);\n          lgSize = newLgSize;\n          return true;\n        } else {\n          return false;\n        }\n      }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  DataLocation {\n    bool tryExpandTo(Union& u, uint newLgSize) {\n            if (newLgSize <= lgSize) {\n              return true;\n            } else if (u.parent.tryExpandData(lgSize, offset, newLgSize - lgSize)) {\n              offset >>= (newLgSize - lgSize);\n              lgSize = newLgSize;\n              return true;\n            } else {\n              return false;\n            }\n          }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nGroup {\n  bool tryExpandUsage(Group& group, Union::DataLocation& location, uint desiredUsage) {\n          if (desiredUsage > location.lgSize) {\n            // Need to expand the underlying slot.\n            if (!location.tryExpandTo(group.parent, desiredUsage)) {\n              return false;\n            }\n          }\n  \n          // Underlying slot is big enough, so expand our size and update holes.\n          holes.addHolesAtEnd(lgSizeUsed, 1, desiredUsage);\n          lgSizeUsed = desiredUsage;\n          return true;\n        }\n}"
  },
  {
    "function_name": "tryExpand",
    "container": "Group",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "374-386",
    "snippet": "bool tryExpand(Group& group, Union::DataLocation& location,\n                     uint oldLgSize, uint oldOffset, uint expansionFactor) {\n        if (oldOffset == 0 && lgSizeUsed == oldLgSize) {\n          // This location contains exactly the requested data, so just expand the whole thing.\n          return tryExpandUsage(group, location, oldLgSize + expansionFactor);\n        } else {\n          // This location contains the requested data plus other stuff.  Therefore the data cannot\n          // possibly expand past the end of the space we've already marked used without either\n          // overlapping with something else or breaking alignment rules.  We only have to combine\n          // it with holes.\n          return holes.tryExpand(oldLgSize, oldOffset, expansionFactor);\n        }\n      }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tryExpandUsage",
          "args": [
            "group",
            "location",
            "oldLgSize + expansionFactor"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "tryExpandUsage",
          "container": "Group",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "401-413",
          "snippet": "bool tryExpandUsage(Group& group, Union::DataLocation& location, uint desiredUsage) {\n        if (desiredUsage > location.lgSize) {\n          // Need to expand the underlying slot.\n          if (!location.tryExpandTo(group.parent, desiredUsage)) {\n            return false;\n          }\n        }\n\n        // Underlying slot is big enough, so expand our size and update holes.\n        holes.addHolesAtEnd(lgSizeUsed, 1, desiredUsage);\n        lgSizeUsed = desiredUsage;\n        return true;\n      }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nGroup {\n  bool tryExpandUsage(Group& group, Union::DataLocation& location, uint desiredUsage) {\n          if (desiredUsage > location.lgSize) {\n            // Need to expand the underlying slot.\n            if (!location.tryExpandTo(group.parent, desiredUsage)) {\n              return false;\n            }\n          }\n  \n          // Underlying slot is big enough, so expand our size and update holes.\n          holes.addHolesAtEnd(lgSizeUsed, 1, desiredUsage);\n          lgSizeUsed = desiredUsage;\n          return true;\n        }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nGroup {\n  bool tryExpand(Group& group, Union::DataLocation& location,\n                       uint oldLgSize, uint oldOffset, uint expansionFactor) {\n          if (oldOffset == 0 && lgSizeUsed == oldLgSize) {\n            // This location contains exactly the requested data, so just expand the whole thing.\n            return tryExpandUsage(group, location, oldLgSize + expansionFactor);\n          } else {\n            // This location contains the requested data plus other stuff.  Therefore the data cannot\n            // possibly expand past the end of the space we've already marked used without either\n            // overlapping with something else or breaking alignment rules.  We only have to combine\n            // it with holes.\n            return holes.tryExpand(oldLgSize, oldOffset, expansionFactor);\n          }\n        }\n}"
  },
  {
    "function_name": "addDiscriminant",
    "container": "Union",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "257-264",
    "snippet": "bool addDiscriminant() {\n      if (discriminantOffset == nullptr) {\n        discriminantOffset = parent.addData(4);  // 2^4 = 16 bits\n        return true;\n      } else {\n        return false;\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent.addData",
          "args": [
            "4"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  bool addDiscriminant() {\n        if (discriminantOffset == nullptr) {\n          discriminantOffset = parent.addData(4);  // 2^4 = 16 bits\n          return true;\n        } else {\n          return false;\n        }\n      }\n}"
  },
  {
    "function_name": "newGroupAddingFirstMember",
    "container": "Union",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "251-255",
    "snippet": "void newGroupAddingFirstMember() {\n      if (++groupCount == 2) {\n        addDiscriminant();\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addDiscriminant",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "addDiscriminant",
          "container": "Union",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "257-264",
          "snippet": "bool addDiscriminant() {\n      if (discriminantOffset == nullptr) {\n        discriminantOffset = parent.addData(4);  // 2^4 = 16 bits\n        return true;\n      } else {\n        return false;\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  bool addDiscriminant() {\n        if (discriminantOffset == nullptr) {\n          discriminantOffset = parent.addData(4);  // 2^4 = 16 bits\n          return true;\n        } else {\n          return false;\n        }\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nUnion {\n  void newGroupAddingFirstMember() {\n        if (++groupCount == 2) {\n          addDiscriminant();\n        }\n      }\n}"
  },
  {
    "function_name": "addNewPointerLocation",
    "container": "Union",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "245-249",
    "snippet": "uint addNewPointerLocation() {\n      // Add a whole new pointer location to the union with the given size.\n\n      return pointerLocations.add(parent.addPointer());\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pointerLocations.add",
          "args": [
            "parent.addPointer()"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent.addPointer",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "addPointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "478-487",
          "snippet": "uint addPointer() override {\n      addVoid();\n\n      if (parentPointerLocationUsage < parent.pointerLocations.size()) {\n        return parent.pointerLocations[parentPointerLocationUsage++];\n      } else {\n        parentPointerLocationUsage++;\n        return parent.addNewPointerLocation();\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nuint addPointer() override {\n      addVoid();\n\n      if (parentPointerLocationUsage < parent.pointerLocations.size()) {\n        return parent.pointerLocations[parentPointerLocationUsage++];\n      } else {\n        parentPointerLocationUsage++;\n        return parent.addNewPointerLocation();\n      }\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  uint addNewPointerLocation() {\n        // Add a whole new pointer location to the union with the given size.\n  \n        return pointerLocations.add(parent.addPointer());\n      }\n}"
  },
  {
    "function_name": "addNewDataLocation",
    "container": "Union",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "237-243",
    "snippet": "uint addNewDataLocation(uint lgSize) {\n      // Add a whole new data location to the union with the given size.\n\n      uint offset = parent.addData(lgSize);\n      dataLocations.add(DataLocation { lgSize, offset });\n      return offset;\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dataLocations.add",
          "args": [
            "DataLocation { lgSize, offset }"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent.addData",
          "args": [
            "lgSize"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  uint addNewDataLocation(uint lgSize) {\n        // Add a whole new data location to the union with the given size.\n  \n        uint offset = parent.addData(lgSize);\n        dataLocations.add(DataLocation { lgSize, offset });\n        return offset;\n      }\n}"
  },
  {
    "function_name": "Union",
    "container": "Union",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "234-234",
    "snippet": "inline Union(StructOrGroup& parent): parent(parent) {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  inline Union(StructOrGroup& parent): parent(parent) {}\n}"
  },
  {
    "function_name": "tryExpandTo",
    "container": "Union::DataLocation",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "215-225",
    "snippet": "bool tryExpandTo(Union& u, uint newLgSize) {\n        if (newLgSize <= lgSize) {\n          return true;\n        } else if (u.parent.tryExpandData(lgSize, offset, newLgSize - lgSize)) {\n          offset >>= (newLgSize - lgSize);\n          lgSize = newLgSize;\n          return true;\n        } else {\n          return false;\n        }\n      }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "u.parent.tryExpandData",
          "args": [
            "lgSize",
            "offset",
            "newLgSize - lgSize"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "tryExpandData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "489-513",
          "snippet": "bool tryExpandData(uint oldLgSize, uint oldOffset, uint expansionFactor) override {\n      if (oldLgSize + expansionFactor > 6 ||\n          (oldOffset & ((1 << expansionFactor) - 1)) != 0) {\n        // Expansion is not possible because the new size is too large or the offset is not\n        // properly-aligned.\n      }\n\n      for (uint i = 0; i < parentDataLocationUsage.size(); i++) {\n        auto& location = parent.dataLocations[i];\n        if (location.lgSize >= oldLgSize &&\n            oldOffset >> (location.lgSize - oldLgSize) == location.offset) {\n          // The location we're trying to expand is a subset of this data location.\n          auto& usage = parentDataLocationUsage[i];\n\n          // Adjust the offset to be only within this location.\n          uint localOldOffset = oldOffset - (location.offset << (location.lgSize - oldLgSize));\n\n          // Try to expand.\n          return usage.tryExpand(*this, location, oldLgSize, localOldOffset, expansionFactor);\n        }\n      }\n\n      KJ_FAIL_ASSERT(\"Tried to expand field that was never allocated.\");\n      return false;\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;",
            "uint i = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\nuint i = 0;\n\nbool tryExpandData(uint oldLgSize, uint oldOffset, uint expansionFactor) override {\n      if (oldLgSize + expansionFactor > 6 ||\n          (oldOffset & ((1 << expansionFactor) - 1)) != 0) {\n        // Expansion is not possible because the new size is too large or the offset is not\n        // properly-aligned.\n      }\n\n      for (uint i = 0; i < parentDataLocationUsage.size(); i++) {\n        auto& location = parent.dataLocations[i];\n        if (location.lgSize >= oldLgSize &&\n            oldOffset >> (location.lgSize - oldLgSize) == location.offset) {\n          // The location we're trying to expand is a subset of this data location.\n          auto& usage = parentDataLocationUsage[i];\n\n          // Adjust the offset to be only within this location.\n          uint localOldOffset = oldOffset - (location.offset << (location.lgSize - oldLgSize));\n\n          // Try to expand.\n          return usage.tryExpand(*this, location, oldLgSize, localOldOffset, expansionFactor);\n        }\n      }\n\n      KJ_FAIL_ASSERT(\"Tried to expand field that was never allocated.\");\n      return false;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nUnion {\n  DataLocation {\n    bool tryExpandTo(Union& u, uint newLgSize) {\n            if (newLgSize <= lgSize) {\n              return true;\n            } else if (u.parent.tryExpandData(lgSize, offset, newLgSize - lgSize)) {\n              offset >>= (newLgSize - lgSize);\n              lgSize = newLgSize;\n              return true;\n            } else {\n              return false;\n            }\n          }\n  }\n}"
  },
  {
    "function_name": "tryExpandData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "202-204",
    "snippet": "bool tryExpandData(uint oldLgSize, uint oldOffset, uint expansionFactor) override {\n      return holes.tryExpand(oldLgSize, oldOffset, expansionFactor);\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "holes.tryExpand",
          "args": [
            "oldLgSize",
            "oldOffset",
            "expansionFactor"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "tryExpand",
          "container": "HoleSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "116-139",
          "snippet": "bool tryExpand(UIntType oldLgSize, uint oldOffset, uint expansionFactor) {\n      // Try to expand the value at the given location by combining it with subsequent holes, so\n      // as to expand the location to be 2^expansionFactor times the size that it started as.\n      // (In other words, the new lgSize is oldLgSize + expansionFactor.)\n\n      if (expansionFactor == 0) {\n        // No expansion requested.\n        return true;\n      }\n      if (holes[oldLgSize] != oldOffset + 1) {\n        // The space immediately after the location is not a hole.\n        return false;\n      }\n\n      // We can expand the location by one factor by combining it with a hole.  Try to further\n      // expand from there to the number of factors requested.\n      if (tryExpand(oldLgSize + 1, oldOffset >> 1, expansionFactor - 1)) {\n        // Success.  Consume the hole.\n        holes[oldLgSize] = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nHoleSet {\n  bool tryExpand(UIntType oldLgSize, uint oldOffset, uint expansionFactor) {\n        // Try to expand the value at the given location by combining it with subsequent holes, so\n        // as to expand the location to be 2^expansionFactor times the size that it started as.\n        // (In other words, the new lgSize is oldLgSize + expansionFactor.)\n  \n        if (expansionFactor == 0) {\n          // No expansion requested.\n          return true;\n        }\n        if (holes[oldLgSize] != oldOffset + 1) {\n          // The space immediately after the location is not a hole.\n          return false;\n        }\n  \n        // We can expand the location by one factor by combining it with a hole.  Try to further\n        // expand from there to the number of factors requested.\n        if (tryExpand(oldLgSize + 1, oldOffset >> 1, expansionFactor - 1)) {\n          // Success.  Consume the hole.\n          holes[oldLgSize] = 0;\n          return true;\n        } else {\n          return false;\n        }\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nbool tryExpandData(uint oldLgSize, uint oldOffset, uint expansionFactor) override {\n      return holes.tryExpand(oldLgSize, oldOffset, expansionFactor);\n    }"
  },
  {
    "function_name": "addPointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "179-200",
    "snippet": "struct Top: public StructOrGroup {\n    uint dataWordCount = 0;\n    uint pointerCount = 0;\n    // Size of the struct so far.\n\n    HoleSet<uint> holes;\n\n    void addVoid() override {}\n\n    uint addData(uint lgSize) override {\n      KJ_IF_MAYBE(hole, holes.tryAllocate(lgSize)) {\n        return *hole;\n      } else {\n        uint offset = dataWordCount++ << (6 - lgSize);\n        holes.addHolesAtEnd(lgSize, offset + 1);\n        return offset;\n      }\n    }\n\n    uint addPointer() override {\n      return pointerCount++;\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "holes.addHolesAtEnd",
          "args": [
            "lgSize",
            "offset + 1"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "addHolesAtEnd",
          "container": "HoleSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "99-114",
          "snippet": "void addHolesAtEnd(UIntType lgSize, UIntType offset,\n                       UIntType limitLgSize = sizeof(holes) / sizeof(holes[0])) {\n      // Add new holes of progressively larger sizes in the range [lgSize, limitLgSize) starting\n      // from the given offset.  The idea is that you just allocated an lgSize-sized field from\n      // an limitLgSize-sized space, such as a newly-added word on the end of the data segment.\n\n      KJ_DREQUIRE(limitLgSize <= kj::size(holes));\n\n      while (lgSize < limitLgSize) {\n        KJ_DREQUIRE(holes[lgSize] == 0);\n        KJ_DREQUIRE(offset % 2 == 1);\n        holes[lgSize] = offset;\n        ++lgSize;\n        offset = (offset + 1) / 2;\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nHoleSet {\n  void addHolesAtEnd(UIntType lgSize, UIntType offset,\n                         UIntType limitLgSize = sizeof(holes) / sizeof(holes[0])) {\n        // Add new holes of progressively larger sizes in the range [lgSize, limitLgSize) starting\n        // from the given offset.  The idea is that you just allocated an lgSize-sized field from\n        // an limitLgSize-sized space, such as a newly-added word on the end of the data segment.\n  \n        KJ_DREQUIRE(limitLgSize <= kj::size(holes));\n  \n        while (lgSize < limitLgSize) {\n          KJ_DREQUIRE(holes[lgSize] == 0);\n          KJ_DREQUIRE(offset % 2 == 1);\n          holes[lgSize] = offset;\n          ++lgSize;\n          offset = (offset + 1) / 2;\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "hole",
            "holes.tryAllocate(lgSize)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "holes.tryAllocate",
          "args": [
            "lgSize"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "tryAllocate",
          "container": "HoleSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "70-90",
          "snippet": "kj::Maybe<UIntType> tryAllocate(UIntType lgSize) {\n      // Try to find space for a field of size 2^lgSize within the set of holes.  If found,\n      // remove it from the holes, and return its offset (as a multiple of its size).  If there\n      // is no such space, returns zero (no hole can be at offset zero, as explained above).\n\n      if (lgSize >= kj::size(holes)) {\n        return nullptr;\n      } else if (holes[lgSize] != 0) {\n        UIntType result = holes[lgSize];\n        holes[lgSize] = 0;\n        return result;\n      } else {\n        KJ_IF_MAYBE(next, tryAllocate(lgSize + 1)) {\n          UIntType result = *next * 2;\n          holes[lgSize] = result + 1;\n          return result;\n        } else {\n          return nullptr;\n        }\n      }\n    }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nHoleSet {\n  kj::Maybe<UIntType> tryAllocate(UIntType lgSize) {\n        // Try to find space for a field of size 2^lgSize within the set of holes.  If found,\n        // remove it from the holes, and return its offset (as a multiple of its size).  If there\n        // is no such space, returns zero (no hole can be at offset zero, as explained above).\n  \n        if (lgSize >= kj::size(holes)) {\n          return nullptr;\n        } else if (holes[lgSize] != 0) {\n          UIntType result = holes[lgSize];\n          holes[lgSize] = 0;\n          return result;\n        } else {\n          KJ_IF_MAYBE(next, tryAllocate(lgSize + 1)) {\n            UIntType result = *next * 2;\n            holes[lgSize] = result + 1;\n            return result;\n          } else {\n            return nullptr;\n          }\n        }\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nstruct Top: public StructOrGroup {\n    uint dataWordCount = 0;\n    uint pointerCount = 0;\n    // Size of the struct so far.\n\n    HoleSet<uint> holes;\n\n    void addVoid() override {}\n\n    uint addData(uint lgSize) override {\n      KJ_IF_MAYBE(hole, holes.tryAllocate(lgSize)) {\n        return *hole;\n      } else {\n        uint offset = dataWordCount++ << (6 - lgSize);\n        holes.addHolesAtEnd(lgSize, offset + 1);\n        return offset;\n      }\n    }\n\n    uint addPointer() override {\n      return pointerCount++;\n    }"
  },
  {
    "function_name": "getFirstWordUsed",
    "container": "HoleSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "152-164",
    "snippet": "uint getFirstWordUsed() {\n      // Computes the lg of the amount of space used in the first word of the section.\n\n      // If there is a 32-bit hole with a 32-bit offset, no more than the first 32 bits are used.\n      // If no more than the first 32 bits are used, and there is a 16-bit hole with a 16-bit\n      // offset, then no more than the first 16 bits are used.  And so on.\n      for (uint i = kj::size(holes); i > 0; i--) {\n        if (holes[i - 1] != 1) {\n          return i;\n        }\n      }\n      return 0;\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint i = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "holes"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint i = 0;\n\nHoleSet {\n  uint getFirstWordUsed() {\n        // Computes the lg of the amount of space used in the first word of the section.\n  \n        // If there is a 32-bit hole with a 32-bit offset, no more than the first 32 bits are used.\n        // If no more than the first 32 bits are used, and there is a 16-bit hole with a 16-bit\n        // offset, then no more than the first 16 bits are used.  And so on.\n        for (uint i = kj::size(holes); i > 0; i--) {\n          if (holes[i - 1] != 1) {\n            return i;\n          }\n        }\n        return 0;\n      }\n}"
  },
  {
    "function_name": "smallestAtLeast",
    "container": "HoleSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "141-150",
    "snippet": "kj::Maybe<uint> smallestAtLeast(uint size) {\n      // Return the size of the smallest hole that is equal to or larger than the given size.\n\n      for (uint i = size; i < kj::size(holes); i++) {\n        if (holes[i] != 0) {\n          return i;\n        }\n      }\n      return nullptr;\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint i = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "holes"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint i = 0;\n\nHoleSet {\n  kj::Maybe<uint> smallestAtLeast(uint size) {\n        // Return the size of the smallest hole that is equal to or larger than the given size.\n  \n        for (uint i = size; i < kj::size(holes); i++) {\n          if (holes[i] != 0) {\n            return i;\n          }\n        }\n        return nullptr;\n      }\n}"
  },
  {
    "function_name": "tryExpand",
    "container": "HoleSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "116-139",
    "snippet": "bool tryExpand(UIntType oldLgSize, uint oldOffset, uint expansionFactor) {\n      // Try to expand the value at the given location by combining it with subsequent holes, so\n      // as to expand the location to be 2^expansionFactor times the size that it started as.\n      // (In other words, the new lgSize is oldLgSize + expansionFactor.)\n\n      if (expansionFactor == 0) {\n        // No expansion requested.\n        return true;\n      }\n      if (holes[oldLgSize] != oldOffset + 1) {\n        // The space immediately after the location is not a hole.\n        return false;\n      }\n\n      // We can expand the location by one factor by combining it with a hole.  Try to further\n      // expand from there to the number of factors requested.\n      if (tryExpand(oldLgSize + 1, oldOffset >> 1, expansionFactor - 1)) {\n        // Success.  Consume the hole.\n        holes[oldLgSize] = 0;\n        return true;\n      } else {\n        return false;\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tryExpand",
          "args": [
            "oldLgSize + 1",
            "oldOffset >> 1",
            "expansionFactor - 1"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "tryExpandUsage",
          "container": "Group",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "401-413",
          "snippet": "bool tryExpandUsage(Group& group, Union::DataLocation& location, uint desiredUsage) {\n        if (desiredUsage > location.lgSize) {\n          // Need to expand the underlying slot.\n          if (!location.tryExpandTo(group.parent, desiredUsage)) {\n            return false;\n          }\n        }\n\n        // Underlying slot is big enough, so expand our size and update holes.\n        holes.addHolesAtEnd(lgSizeUsed, 1, desiredUsage);\n        lgSizeUsed = desiredUsage;\n        return true;\n      }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nkj::Maybe<kj::Own<NodeTranslator::BrandScope>> parent;\n\nGroup {\n  bool tryExpandUsage(Group& group, Union::DataLocation& location, uint desiredUsage) {\n          if (desiredUsage > location.lgSize) {\n            // Need to expand the underlying slot.\n            if (!location.tryExpandTo(group.parent, desiredUsage)) {\n              return false;\n            }\n          }\n  \n          // Underlying slot is big enough, so expand our size and update holes.\n          holes.addHolesAtEnd(lgSizeUsed, 1, desiredUsage);\n          lgSizeUsed = desiredUsage;\n          return true;\n        }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nHoleSet {\n  bool tryExpand(UIntType oldLgSize, uint oldOffset, uint expansionFactor) {\n        // Try to expand the value at the given location by combining it with subsequent holes, so\n        // as to expand the location to be 2^expansionFactor times the size that it started as.\n        // (In other words, the new lgSize is oldLgSize + expansionFactor.)\n  \n        if (expansionFactor == 0) {\n          // No expansion requested.\n          return true;\n        }\n        if (holes[oldLgSize] != oldOffset + 1) {\n          // The space immediately after the location is not a hole.\n          return false;\n        }\n  \n        // We can expand the location by one factor by combining it with a hole.  Try to further\n        // expand from there to the number of factors requested.\n        if (tryExpand(oldLgSize + 1, oldOffset >> 1, expansionFactor - 1)) {\n          // Success.  Consume the hole.\n          holes[oldLgSize] = 0;\n          return true;\n        } else {\n          return false;\n        }\n      }\n}"
  },
  {
    "function_name": "addHolesAtEnd",
    "container": "HoleSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "99-114",
    "snippet": "void addHolesAtEnd(UIntType lgSize, UIntType offset,\n                       UIntType limitLgSize = sizeof(holes) / sizeof(holes[0])) {\n      // Add new holes of progressively larger sizes in the range [lgSize, limitLgSize) starting\n      // from the given offset.  The idea is that you just allocated an lgSize-sized field from\n      // an limitLgSize-sized space, such as a newly-added word on the end of the data segment.\n\n      KJ_DREQUIRE(limitLgSize <= kj::size(holes));\n\n      while (lgSize < limitLgSize) {\n        KJ_DREQUIRE(holes[lgSize] == 0);\n        KJ_DREQUIRE(offset % 2 == 1);\n        holes[lgSize] = offset;\n        ++lgSize;\n        offset = (offset + 1) / 2;\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "offset % 2 == 1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "holes[lgSize] == 0"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "limitLgSize <= kj::size(holes)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "holes"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nHoleSet {\n  void addHolesAtEnd(UIntType lgSize, UIntType offset,\n                         UIntType limitLgSize = sizeof(holes) / sizeof(holes[0])) {\n        // Add new holes of progressively larger sizes in the range [lgSize, limitLgSize) starting\n        // from the given offset.  The idea is that you just allocated an lgSize-sized field from\n        // an limitLgSize-sized space, such as a newly-added word on the end of the data segment.\n  \n        KJ_DREQUIRE(limitLgSize <= kj::size(holes));\n  \n        while (lgSize < limitLgSize) {\n          KJ_DREQUIRE(holes[lgSize] == 0);\n          KJ_DREQUIRE(offset % 2 == 1);\n          holes[lgSize] = offset;\n          ++lgSize;\n          offset = (offset + 1) / 2;\n        }\n      }\n}"
  },
  {
    "function_name": "assertHoleAndAllocate",
    "container": "HoleSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "92-97",
    "snippet": "uint assertHoleAndAllocate(UIntType lgSize) {\n      KJ_ASSERT(holes[lgSize] != 0);\n      uint result = holes[lgSize];\n      holes[lgSize] = 0;\n      return result;\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "holes[lgSize] != 0"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nHoleSet {\n  uint assertHoleAndAllocate(UIntType lgSize) {\n        KJ_ASSERT(holes[lgSize] != 0);\n        uint result = holes[lgSize];\n        holes[lgSize] = 0;\n        return result;\n      }\n}"
  },
  {
    "function_name": "tryAllocate",
    "container": "HoleSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "70-90",
    "snippet": "kj::Maybe<UIntType> tryAllocate(UIntType lgSize) {\n      // Try to find space for a field of size 2^lgSize within the set of holes.  If found,\n      // remove it from the holes, and return its offset (as a multiple of its size).  If there\n      // is no such space, returns zero (no hole can be at offset zero, as explained above).\n\n      if (lgSize >= kj::size(holes)) {\n        return nullptr;\n      } else if (holes[lgSize] != 0) {\n        UIntType result = holes[lgSize];\n        holes[lgSize] = 0;\n        return result;\n      } else {\n        KJ_IF_MAYBE(next, tryAllocate(lgSize + 1)) {\n          UIntType result = *next * 2;\n          holes[lgSize] = result + 1;\n          return result;\n        } else {\n          return nullptr;\n        }\n      }\n    }",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "next",
            "tryAllocate(lgSize + 1)"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "holes"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      }
    ],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nHoleSet {\n  kj::Maybe<UIntType> tryAllocate(UIntType lgSize) {\n        // Try to find space for a field of size 2^lgSize within the set of holes.  If found,\n        // remove it from the holes, and return its offset (as a multiple of its size).  If there\n        // is no such space, returns zero (no hole can be at offset zero, as explained above).\n  \n        if (lgSize >= kj::size(holes)) {\n          return nullptr;\n        } else if (holes[lgSize] != 0) {\n          UIntType result = holes[lgSize];\n          holes[lgSize] = 0;\n          return result;\n        } else {\n          KJ_IF_MAYBE(next, tryAllocate(lgSize + 1)) {\n            UIntType result = *next * 2;\n            holes[lgSize] = result + 1;\n            return result;\n          } else {\n            return nullptr;\n          }\n        }\n      }\n}"
  },
  {
    "function_name": "HoleSet",
    "container": "HoleSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
    "lines": "39-39",
    "snippet": "inline HoleSet(): holes{0, 0, 0, 0, 0, 0} {}",
    "includes": [
      "#include <map>",
      "#include <set>",
      "#include <kj/arena.h>",
      "#include <kj/debug.h>",
      "#include \"parser.h\"      // only for generateGroupId()",
      "#include \"node-translator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nHoleSet {\n  inline HoleSet(): holes{0, 0, 0, 0, 0, 0} {}\n}"
  }
]