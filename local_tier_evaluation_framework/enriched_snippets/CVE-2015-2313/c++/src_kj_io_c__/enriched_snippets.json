[
  {
    "function_name": "FdOutputStream::write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "283-340",
    "snippet": "void FdOutputStream::write(ArrayPtr<const ArrayPtr<const byte>> pieces) {\n#if _WIN32\n  // Windows has no reasonable writev(). It has WriteFileGather, but this call has the unreasonable\n  // restriction that each segment must be page-aligned. So, fall back to write().\n\n  for (auto piece: pieces) {\n    write(piece.begin(), piece.size());\n  }\n\n#else\n  // Apparently, there is a maximum number of iovecs allowed per call.  I don't understand why.\n  // Also, most platforms define IOV_MAX but Linux defines only UIO_MAXIOV.  Unfortunately, Solaris\n  // defines a constant UIO_MAXIOV with a different meaning, so we check for IOV_MAX first.\n#if !defined(IOV_MAX) && defined(UIO_MAXIOV)\n#define IOV_MAX UIO_MAXIOV\n#endif\n  while (pieces.size() > IOV_MAX) {\n    write(pieces.slice(0, IOV_MAX));\n    pieces = pieces.slice(IOV_MAX, pieces.size());\n  }\n\n  KJ_STACK_ARRAY(struct iovec, iov, pieces.size(), 16, 128);\n\n  for (uint i = 0; i < pieces.size(); i++) {\n    // writev() interface is not const-correct.  :(\n    iov[i].iov_base = const_cast<byte*>(pieces[i].begin());\n    iov[i].iov_len = pieces[i].size();\n  }\n\n  struct iovec* current = iov.begin();\n\n  // Advance past any leading empty buffers so that a write full of only empty buffers does not\n  // cause a syscall at all.\n  while (current < iov.end() && current->iov_len == 0) {\n    ++current;\n  }\n\n  while (current < iov.end()) {\n    // Issue the write.\n    ssize_t n = 0;\n    KJ_SYSCALL(n = ::writev(fd, current, iov.end() - current), fd);\n    KJ_ASSERT(n > 0, \"writev() returned zero.\");\n\n    // Advance past all buffers that were fully-written.\n    while (current < iov.end() && static_cast<size_t>(n) >= current->iov_len) {\n      n -= current->iov_len;\n      ++current;\n    }\n\n    // If we only partially-wrote one of the buffers, adjust the pointer and size to include only\n    // the unwritten part.\n    if (n > 0) {\n      current->iov_base = reinterpret_cast<byte*>(current->iov_base) + n;\n      current->iov_len -= n;\n    }\n  }\n#endif\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [
      "#define IOV_MAX UIO_MAXIOV"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "current->iov_base"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<size_t>",
          "args": [
            "n"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov.end",
          "args": [],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n > 0",
            "\"writev() returned zero.\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = ::writev(fd, current, iov.end() - current)",
            "fd"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::writev",
          "args": [
            "fd",
            "current",
            "iov.end() - current"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov.begin",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pieces[i].size",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<byte*>",
          "args": [
            "pieces[i].begin()"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pieces.slice",
          "args": [
            "IOV_MAX",
            "pieces.size()"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "pieces.slice(0, IOV_MAX)"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "OutputStream::write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
          "lines": "59-63",
          "snippet": "void OutputStream::write(ArrayPtr<const ArrayPtr<const byte>> pieces) {\n  for (auto piece: pieces) {\n    write(piece.begin(), piece.size());\n  }\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <algorithm>",
            "#include \"miniposix.h\"",
            "#include \"debug.h\"",
            "#include \"io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid OutputStream::write(ArrayPtr<const ArrayPtr<const byte>> pieces) {\n  for (auto piece: pieces) {\n    write(piece.begin(), piece.size());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\n#define IOV_MAX UIO_MAXIOV\n\nvoid FdOutputStream::write(ArrayPtr<const ArrayPtr<const byte>> pieces) {\n#if _WIN32\n  // Windows has no reasonable writev(). It has WriteFileGather, but this call has the unreasonable\n  // restriction that each segment must be page-aligned. So, fall back to write().\n\n  for (auto piece: pieces) {\n    write(piece.begin(), piece.size());\n  }\n\n#else\n  // Apparently, there is a maximum number of iovecs allowed per call.  I don't understand why.\n  // Also, most platforms define IOV_MAX but Linux defines only UIO_MAXIOV.  Unfortunately, Solaris\n  // defines a constant UIO_MAXIOV with a different meaning, so we check for IOV_MAX first.\n#if !defined(IOV_MAX) && defined(UIO_MAXIOV)\n#define IOV_MAX UIO_MAXIOV\n#endif\n  while (pieces.size() > IOV_MAX) {\n    write(pieces.slice(0, IOV_MAX));\n    pieces = pieces.slice(IOV_MAX, pieces.size());\n  }\n\n  KJ_STACK_ARRAY(struct iovec, iov, pieces.size(), 16, 128);\n\n  for (uint i = 0; i < pieces.size(); i++) {\n    // writev() interface is not const-correct.  :(\n    iov[i].iov_base = const_cast<byte*>(pieces[i].begin());\n    iov[i].iov_len = pieces[i].size();\n  }\n\n  struct iovec* current = iov.begin();\n\n  // Advance past any leading empty buffers so that a write full of only empty buffers does not\n  // cause a syscall at all.\n  while (current < iov.end() && current->iov_len == 0) {\n    ++current;\n  }\n\n  while (current < iov.end()) {\n    // Issue the write.\n    ssize_t n = 0;\n    KJ_SYSCALL(n = ::writev(fd, current, iov.end() - current), fd);\n    KJ_ASSERT(n > 0, \"writev() returned zero.\");\n\n    // Advance past all buffers that were fully-written.\n    while (current < iov.end() && static_cast<size_t>(n) >= current->iov_len) {\n      n -= current->iov_len;\n      ++current;\n    }\n\n    // If we only partially-wrote one of the buffers, adjust the pointer and size to include only\n    // the unwritten part.\n    if (n > 0) {\n      current->iov_base = reinterpret_cast<byte*>(current->iov_base) + n;\n      current->iov_len -= n;\n    }\n  }\n#endif\n}"
  },
  {
    "function_name": "FdOutputStream::write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "271-281",
    "snippet": "void FdOutputStream::write(const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n\n  while (size > 0) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::write(fd, pos, size), fd);\n    KJ_ASSERT(n > 0, \"write() returned zero.\");\n    pos += n;\n    size -= n;\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "n > 0",
            "\"write() returned zero.\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = miniposix::write(fd, pos, size)",
            "fd"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "miniposix::write",
          "args": [
            "fd",
            "pos",
            "size"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "buffer"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid FdOutputStream::write(const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n\n  while (size > 0) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::write(fd, pos, size), fd);\n    KJ_ASSERT(n > 0, \"write() returned zero.\");\n    pos += n;\n    size -= n;\n  }\n}"
  },
  {
    "function_name": "FdOutputStream::~FdOutputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "269-269",
    "snippet": "FdOutputStream::~FdOutputStream() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nFdOutputStream::~FdOutputStream() noexcept(false) {}"
  },
  {
    "function_name": "FdInputStream::tryRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "252-267",
    "snippet": "size_t FdInputStream::tryRead(void* buffer, size_t minBytes, size_t maxBytes) {\n  byte* pos = reinterpret_cast<byte*>(buffer);\n  byte* min = pos + minBytes;\n  byte* max = pos + maxBytes;\n\n  while (pos < min) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::read(fd, pos, max - pos), fd);\n    if (n == 0) {\n      break;\n    }\n    pos += n;\n  }\n\n  return pos - reinterpret_cast<byte*>(buffer);\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "buffer"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = miniposix::read(fd, pos, max - pos)",
            "fd"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "miniposix::read",
          "args": [
            "fd",
            "pos",
            "max - pos"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "51-53",
          "snippet": "inline ssize_t read(int fd, void* buffer, size_t size) {\n  return ::_read(fd, buffer, size);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline ssize_t read(int fd, void* buffer, size_t size) {\n  return ::_read(fd, buffer, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "buffer"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nsize_t FdInputStream::tryRead(void* buffer, size_t minBytes, size_t maxBytes) {\n  byte* pos = reinterpret_cast<byte*>(buffer);\n  byte* min = pos + minBytes;\n  byte* max = pos + maxBytes;\n\n  while (pos < min) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::read(fd, pos, max - pos), fd);\n    if (n == 0) {\n      break;\n    }\n    pos += n;\n  }\n\n  return pos - reinterpret_cast<byte*>(buffer);\n}"
  },
  {
    "function_name": "FdInputStream::~FdInputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "250-250",
    "snippet": "FdInputStream::~FdInputStream() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nFdInputStream::~FdInputStream() noexcept(false) {}"
  },
  {
    "function_name": "AutoCloseFd::~AutoCloseFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "237-248",
    "snippet": "AutoCloseFd::~AutoCloseFd() noexcept(false) {\n  if (fd >= 0) {\n    unwindDetector.catchExceptionsIfUnwinding([&]() {\n      // Don't use SYSCALL() here because close() should not be repeated on EINTR.\n      if (miniposix::close(fd) < 0) {\n        KJ_FAIL_SYSCALL(\"close\", errno, fd) {\n          break;\n        }\n      }\n    });\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unwindDetector.catchExceptionsIfUnwinding",
          "args": [
            "[&]() {\n      // Don't use SYSCALL() here because close() should not be repeated on EINTR.\n      if (miniposix::close(fd) < 0) {\n        KJ_FAIL_SYSCALL(\"close\", errno, fd) {\n          break;\n        }\n      }\n    }"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"close\"",
            "errno",
            "fd"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "miniposix::close",
          "args": [
            "fd"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nAutoCloseFd::~AutoCloseFd() noexcept(false) {\n  if (fd >= 0) {\n    unwindDetector.catchExceptionsIfUnwinding([&]() {\n      // Don't use SYSCALL() here because close() should not be repeated on EINTR.\n      if (miniposix::close(fd) < 0) {\n        KJ_FAIL_SYSCALL(\"close\", errno, fd) {\n          break;\n        }\n      }\n    });\n  }\n}"
  },
  {
    "function_name": "ArrayOutputStream::write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "223-233",
    "snippet": "void ArrayOutputStream::write(const void* src, size_t size) {\n  if (src == fillPos) {\n    // Oh goody, the caller wrote directly into our buffer.\n    fillPos += size;\n  } else {\n    KJ_REQUIRE(size <= (size_t)(array.end() - fillPos),\n            \"ArrayOutputStream's backing array was not large enough for the data written.\");\n    memcpy(fillPos, src, size);\n    fillPos += size;\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fillPos",
            "src",
            "size"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "size <= (size_t)(array.end() - fillPos)",
            "\"ArrayOutputStream's backing array was not large enough for the data written.\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array.end",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid ArrayOutputStream::write(const void* src, size_t size) {\n  if (src == fillPos) {\n    // Oh goody, the caller wrote directly into our buffer.\n    fillPos += size;\n  } else {\n    KJ_REQUIRE(size <= (size_t)(array.end() - fillPos),\n            \"ArrayOutputStream's backing array was not large enough for the data written.\");\n    memcpy(fillPos, src, size);\n    fillPos += size;\n  }\n}"
  },
  {
    "function_name": "ArrayOutputStream::getWriteBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "219-221",
    "snippet": "ArrayPtr<byte> ArrayOutputStream::getWriteBuffer() {\n  return arrayPtr(fillPos, array.end());\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arrayPtr",
          "args": [
            "fillPos",
            "array.end()"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array.end",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayPtr<byte> ArrayOutputStream::getWriteBuffer() {\n  return arrayPtr(fillPos, array.end());\n}"
  },
  {
    "function_name": "ArrayOutputStream::~ArrayOutputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "217-217",
    "snippet": "ArrayOutputStream::~ArrayOutputStream() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayOutputStream::~ArrayOutputStream() noexcept(false) {}"
  },
  {
    "function_name": "ArrayOutputStream::ArrayOutputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "216-216",
    "snippet": "ArrayOutputStream::ArrayOutputStream(ArrayPtr<byte> array): array(array), fillPos(array.begin()) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array.begin",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayOutputStream::ArrayOutputStream(ArrayPtr<byte> array): array(array), fillPos(array.begin()) {}"
  },
  {
    "function_name": "ArrayInputStream::skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "206-212",
    "snippet": "void ArrayInputStream::skip(size_t bytes) {\n  KJ_REQUIRE(array.size() >= bytes, \"ArrayInputStream ended prematurely.\") {\n    bytes = array.size();\n    break;\n  }\n  array = array.slice(bytes, array.size());\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array.slice",
          "args": [
            "bytes",
            "array.size()"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "array.size",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "array.size() >= bytes",
            "\"ArrayInputStream ended prematurely.\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid ArrayInputStream::skip(size_t bytes) {\n  KJ_REQUIRE(array.size() >= bytes, \"ArrayInputStream ended prematurely.\") {\n    bytes = array.size();\n    break;\n  }\n  array = array.slice(bytes, array.size());\n}"
  },
  {
    "function_name": "ArrayInputStream::tryRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "199-204",
    "snippet": "size_t ArrayInputStream::tryRead(void* dst, size_t minBytes, size_t maxBytes) {\n  size_t n = std::min(maxBytes, array.size());\n  memcpy(dst, array.begin(), n);\n  array = array.slice(n, array.size());\n  return n;\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array.slice",
          "args": [
            "n",
            "array.size()"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "array.size",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "array.begin()",
            "n"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array.begin",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "maxBytes",
            "array.size()"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nsize_t ArrayInputStream::tryRead(void* dst, size_t minBytes, size_t maxBytes) {\n  size_t n = std::min(maxBytes, array.size());\n  memcpy(dst, array.begin(), n);\n  array = array.slice(n, array.size());\n  return n;\n}"
  },
  {
    "function_name": "ArrayInputStream::tryGetReadBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "195-197",
    "snippet": "ArrayPtr<const byte> ArrayInputStream::tryGetReadBuffer() {\n  return array;\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayPtr<const byte> ArrayInputStream::tryGetReadBuffer() {\n  return array;\n}"
  },
  {
    "function_name": "ArrayInputStream::~ArrayInputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "193-193",
    "snippet": "ArrayInputStream::~ArrayInputStream() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayInputStream::~ArrayInputStream() noexcept(false) {}"
  },
  {
    "function_name": "ArrayInputStream::ArrayInputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "192-192",
    "snippet": "ArrayInputStream::ArrayInputStream(ArrayPtr<const byte> array): array(array) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayInputStream::ArrayInputStream(ArrayPtr<const byte> array): array(array) {}"
  },
  {
    "function_name": "BufferedOutputStreamWrapper::write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "161-188",
    "snippet": "void BufferedOutputStreamWrapper::write(const void* src, size_t size) {\n  if (src == bufferPos) {\n    // Oh goody, the caller wrote directly into our buffer.\n    bufferPos += size;\n  } else {\n    size_t available = buffer.end() - bufferPos;\n\n    if (size <= available) {\n      memcpy(bufferPos, src, size);\n      bufferPos += size;\n    } else if (size <= buffer.size()) {\n      // Too much for this buffer, but not a full buffer's worth, so we'll go ahead and copy.\n      memcpy(bufferPos, src, available);\n      inner.write(buffer.begin(), buffer.size());\n\n      size -= available;\n      src = reinterpret_cast<const byte*>(src) + available;\n\n      memcpy(buffer.begin(), src, size);\n      bufferPos = buffer.begin() + size;\n    } else {\n      // Writing so much data that we might as well write directly to avoid a copy.\n      inner.write(buffer.begin(), bufferPos - buffer.begin());\n      bufferPos = buffer.begin();\n      inner.write(src, size);\n    }\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner.write",
          "args": [
            "src",
            "size"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer.begin()",
            "src",
            "size"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "src"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bufferPos",
            "src",
            "available"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bufferPos",
            "src",
            "size"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.end",
          "args": [],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid BufferedOutputStreamWrapper::write(const void* src, size_t size) {\n  if (src == bufferPos) {\n    // Oh goody, the caller wrote directly into our buffer.\n    bufferPos += size;\n  } else {\n    size_t available = buffer.end() - bufferPos;\n\n    if (size <= available) {\n      memcpy(bufferPos, src, size);\n      bufferPos += size;\n    } else if (size <= buffer.size()) {\n      // Too much for this buffer, but not a full buffer's worth, so we'll go ahead and copy.\n      memcpy(bufferPos, src, available);\n      inner.write(buffer.begin(), buffer.size());\n\n      size -= available;\n      src = reinterpret_cast<const byte*>(src) + available;\n\n      memcpy(buffer.begin(), src, size);\n      bufferPos = buffer.begin() + size;\n    } else {\n      // Writing so much data that we might as well write directly to avoid a copy.\n      inner.write(buffer.begin(), bufferPos - buffer.begin());\n      bufferPos = buffer.begin();\n      inner.write(src, size);\n    }\n  }\n}"
  },
  {
    "function_name": "BufferedOutputStreamWrapper::getWriteBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "157-159",
    "snippet": "ArrayPtr<byte> BufferedOutputStreamWrapper::getWriteBuffer() {\n  return arrayPtr(bufferPos, buffer.end());\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arrayPtr",
          "args": [
            "bufferPos",
            "buffer.end()"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.end",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayPtr<byte> BufferedOutputStreamWrapper::getWriteBuffer() {\n  return arrayPtr(bufferPos, buffer.end());\n}"
  },
  {
    "function_name": "BufferedOutputStreamWrapper::flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "150-155",
    "snippet": "void BufferedOutputStreamWrapper::flush() {\n  if (bufferPos > buffer.begin()) {\n    inner.write(buffer.begin(), bufferPos - buffer.begin());\n    bufferPos = buffer.begin();\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inner.write",
          "args": [
            "buffer.begin()",
            "bufferPos - buffer.begin()"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid BufferedOutputStreamWrapper::flush() {\n  if (bufferPos > buffer.begin()) {\n    inner.write(buffer.begin(), bufferPos - buffer.begin());\n    bufferPos = buffer.begin();\n  }\n}"
  },
  {
    "function_name": "BufferedOutputStreamWrapper::~BufferedOutputStreamWrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "144-148",
    "snippet": "BufferedOutputStreamWrapper::~BufferedOutputStreamWrapper() noexcept(false) {\n  unwindDetector.catchExceptionsIfUnwinding([&]() {\n    flush();\n  });\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unwindDetector.catchExceptionsIfUnwinding",
          "args": [
            "[&]() {\n    flush();\n  }"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "BufferedOutputStreamWrapper::flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
          "lines": "150-155",
          "snippet": "void BufferedOutputStreamWrapper::flush() {\n  if (bufferPos > buffer.begin()) {\n    inner.write(buffer.begin(), bufferPos - buffer.begin());\n    bufferPos = buffer.begin();\n  }\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <algorithm>",
            "#include \"miniposix.h\"",
            "#include \"debug.h\"",
            "#include \"io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid BufferedOutputStreamWrapper::flush() {\n  if (bufferPos > buffer.begin()) {\n    inner.write(buffer.begin(), bufferPos - buffer.begin());\n    bufferPos = buffer.begin();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nBufferedOutputStreamWrapper::~BufferedOutputStreamWrapper() noexcept(false) {\n  unwindDetector.catchExceptionsIfUnwinding([&]() {\n    flush();\n  });\n}"
  },
  {
    "function_name": "BufferedOutputStreamWrapper::BufferedOutputStreamWrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "138-142",
    "snippet": "BufferedOutputStreamWrapper::BufferedOutputStreamWrapper(OutputStream& inner, ArrayPtr<byte> buffer)\n    : inner(inner),\n      ownedBuffer(buffer == nullptr ? heapArray<byte>(8192) : nullptr),\n      buffer(buffer == nullptr ? ownedBuffer : buffer),\n      bufferPos(this->buffer.begin()) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->buffer.begin",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArray<byte>",
          "args": [
            "8192"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nBufferedOutputStreamWrapper::BufferedOutputStreamWrapper(OutputStream& inner, ArrayPtr<byte> buffer)\n    : inner(inner),\n      ownedBuffer(buffer == nullptr ? heapArray<byte>(8192) : nullptr),\n      buffer(buffer == nullptr ? ownedBuffer : buffer),\n      bufferPos(this->buffer.begin()) {}"
  },
  {
    "function_name": "BufferedInputStreamWrapper::skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "119-134",
    "snippet": "void BufferedInputStreamWrapper::skip(size_t bytes) {\n  if (bytes <= bufferAvailable.size()) {\n    bufferAvailable = bufferAvailable.slice(bytes, bufferAvailable.size());\n  } else {\n    bytes -= bufferAvailable.size();\n    if (bytes <= buffer.size()) {\n      // Read the next buffer-full.\n      size_t n = inner.read(buffer.begin(), bytes, buffer.size());\n      bufferAvailable = buffer.slice(bytes, n);\n    } else {\n      // Forward large skip to the underlying stream.\n      bufferAvailable = nullptr;\n      inner.skip(bytes - bufferAvailable.size());\n    }\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner.skip",
          "args": [
            "bytes - bufferAvailable.size()"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "skip",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "68-71",
          "snippet": "void skip(size_t bytes) override {\n    KJ_ASSERT(bytes <= data.size() - readPos, \"Overran end of stream.\");\n    readPos += bytes;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void skip(size_t bytes) override {\n      KJ_ASSERT(bytes <= data.size() - readPos, \"Overran end of stream.\");\n      readPos += bytes;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bufferAvailable.size",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.slice",
          "args": [
            "bytes",
            "n"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inner.read",
          "args": [
            "buffer.begin()",
            "bytes",
            "buffer.size()"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "51-53",
          "snippet": "inline ssize_t read(int fd, void* buffer, size_t size) {\n  return ::_read(fd, buffer, size);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline ssize_t read(int fd, void* buffer, size_t size) {\n  return ::_read(fd, buffer, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid BufferedInputStreamWrapper::skip(size_t bytes) {\n  if (bytes <= bufferAvailable.size()) {\n    bufferAvailable = bufferAvailable.slice(bytes, bufferAvailable.size());\n  } else {\n    bytes -= bufferAvailable.size();\n    if (bytes <= buffer.size()) {\n      // Read the next buffer-full.\n      size_t n = inner.read(buffer.begin(), bytes, buffer.size());\n      bufferAvailable = buffer.slice(bytes, n);\n    } else {\n      // Forward large skip to the underlying stream.\n      bufferAvailable = nullptr;\n      inner.skip(bytes - bufferAvailable.size());\n    }\n  }\n}"
  },
  {
    "function_name": "BufferedInputStreamWrapper::tryRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "88-117",
    "snippet": "size_t BufferedInputStreamWrapper::tryRead(void* dst, size_t minBytes, size_t maxBytes) {\n  if (minBytes <= bufferAvailable.size()) {\n    // Serve from current buffer.\n    size_t n = std::min(bufferAvailable.size(), maxBytes);\n    memcpy(dst, bufferAvailable.begin(), n);\n    bufferAvailable = bufferAvailable.slice(n, bufferAvailable.size());\n    return n;\n  } else {\n    // Copy current available into destination.\n    memcpy(dst, bufferAvailable.begin(), bufferAvailable.size());\n    size_t fromFirstBuffer = bufferAvailable.size();\n\n    dst = reinterpret_cast<byte*>(dst) + fromFirstBuffer;\n    minBytes -= fromFirstBuffer;\n    maxBytes -= fromFirstBuffer;\n\n    if (maxBytes <= buffer.size()) {\n      // Read the next buffer-full.\n      size_t n = inner.read(buffer.begin(), minBytes, buffer.size());\n      size_t fromSecondBuffer = std::min(n, maxBytes);\n      memcpy(dst, buffer.begin(), fromSecondBuffer);\n      bufferAvailable = buffer.slice(fromSecondBuffer, n);\n      return fromFirstBuffer + fromSecondBuffer;\n    } else {\n      // Forward large read to the underlying stream.\n      bufferAvailable = nullptr;\n      return fromFirstBuffer + inner.read(dst, minBytes, maxBytes);\n    }\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inner.read",
          "args": [
            "dst",
            "minBytes",
            "maxBytes"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "51-53",
          "snippet": "inline ssize_t read(int fd, void* buffer, size_t size) {\n  return ::_read(fd, buffer, size);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline ssize_t read(int fd, void* buffer, size_t size) {\n  return ::_read(fd, buffer, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.slice",
          "args": [
            "fromSecondBuffer",
            "n"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "buffer.begin()",
            "fromSecondBuffer"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "n",
            "maxBytes"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "dst"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "bufferAvailable.begin()",
            "bufferAvailable.size()"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "bufferAvailable.begin()",
            "n"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nsize_t BufferedInputStreamWrapper::tryRead(void* dst, size_t minBytes, size_t maxBytes) {\n  if (minBytes <= bufferAvailable.size()) {\n    // Serve from current buffer.\n    size_t n = std::min(bufferAvailable.size(), maxBytes);\n    memcpy(dst, bufferAvailable.begin(), n);\n    bufferAvailable = bufferAvailable.slice(n, bufferAvailable.size());\n    return n;\n  } else {\n    // Copy current available into destination.\n    memcpy(dst, bufferAvailable.begin(), bufferAvailable.size());\n    size_t fromFirstBuffer = bufferAvailable.size();\n\n    dst = reinterpret_cast<byte*>(dst) + fromFirstBuffer;\n    minBytes -= fromFirstBuffer;\n    maxBytes -= fromFirstBuffer;\n\n    if (maxBytes <= buffer.size()) {\n      // Read the next buffer-full.\n      size_t n = inner.read(buffer.begin(), minBytes, buffer.size());\n      size_t fromSecondBuffer = std::min(n, maxBytes);\n      memcpy(dst, buffer.begin(), fromSecondBuffer);\n      bufferAvailable = buffer.slice(fromSecondBuffer, n);\n      return fromFirstBuffer + fromSecondBuffer;\n    } else {\n      // Forward large read to the underlying stream.\n      bufferAvailable = nullptr;\n      return fromFirstBuffer + inner.read(dst, minBytes, maxBytes);\n    }\n  }\n}"
  },
  {
    "function_name": "BufferedInputStreamWrapper::tryGetReadBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "79-86",
    "snippet": "ArrayPtr<const byte> BufferedInputStreamWrapper::tryGetReadBuffer() {\n  if (bufferAvailable.size() == 0) {\n    size_t n = inner.tryRead(buffer.begin(), 1, buffer.size());\n    bufferAvailable = buffer.slice(0, n);\n  }\n\n  return bufferAvailable;\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer.slice",
          "args": [
            "0",
            "n"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inner.tryRead",
          "args": [
            "buffer.begin()",
            "1",
            "buffer.size()"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "TestInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-test.c++",
          "lines": "156-162",
          "snippet": "size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n    size_t amount = lazy ? minBytes : maxBytes;\n    memcpy(buffer, pos, amount);\n    pos += amount;\n    return amount;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/miniposix.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <kj/miniposix.h>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n\nTestInputStream {\n  size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n      size_t amount = lazy ? minBytes : maxBytes;\n      memcpy(buffer, pos, amount);\n      pos += amount;\n      return amount;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.begin",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayPtr<const byte> BufferedInputStreamWrapper::tryGetReadBuffer() {\n  if (bufferAvailable.size() == 0) {\n    size_t n = inner.tryRead(buffer.begin(), 1, buffer.size());\n    bufferAvailable = buffer.slice(0, n);\n  }\n\n  return bufferAvailable;\n}"
  },
  {
    "function_name": "BufferedInputStreamWrapper::~BufferedInputStreamWrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "77-77",
    "snippet": "BufferedInputStreamWrapper::~BufferedInputStreamWrapper() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nBufferedInputStreamWrapper::~BufferedInputStreamWrapper() noexcept(false) {}"
  },
  {
    "function_name": "BufferedInputStreamWrapper::BufferedInputStreamWrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "73-75",
    "snippet": "BufferedInputStreamWrapper::BufferedInputStreamWrapper(InputStream& inner, ArrayPtr<byte> buffer)\n    : inner(inner), ownedBuffer(buffer == nullptr ? heapArray<byte>(8192) : nullptr),\n      buffer(buffer == nullptr ? ownedBuffer : buffer) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heapArray<byte>",
          "args": [
            "8192"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nBufferedInputStreamWrapper::BufferedInputStreamWrapper(InputStream& inner, ArrayPtr<byte> buffer)\n    : inner(inner), ownedBuffer(buffer == nullptr ? heapArray<byte>(8192) : nullptr),\n      buffer(buffer == nullptr ? ownedBuffer : buffer) {}"
  },
  {
    "function_name": "BufferedInputStream::getReadBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "65-69",
    "snippet": "ArrayPtr<const byte> BufferedInputStream::getReadBuffer() {\n  auto result = tryGetReadBuffer();\n  KJ_REQUIRE(result.size() > 0, \"Premature EOF\");\n  return result;\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "result.size() > 0",
            "\"Premature EOF\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.size",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tryGetReadBuffer",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayInputStream::tryGetReadBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
          "lines": "195-197",
          "snippet": "ArrayPtr<const byte> ArrayInputStream::tryGetReadBuffer() {\n  return array;\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <algorithm>",
            "#include \"miniposix.h\"",
            "#include \"debug.h\"",
            "#include \"io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayPtr<const byte> ArrayInputStream::tryGetReadBuffer() {\n  return array;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nArrayPtr<const byte> BufferedInputStream::getReadBuffer() {\n  auto result = tryGetReadBuffer();\n  KJ_REQUIRE(result.size() > 0, \"Premature EOF\");\n  return result;\n}"
  },
  {
    "function_name": "OutputStream::write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "59-63",
    "snippet": "void OutputStream::write(ArrayPtr<const ArrayPtr<const byte>> pieces) {\n  for (auto piece: pieces) {\n    write(piece.begin(), piece.size());\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "piece.begin()",
            "piece.size()"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "FdOutputStream::write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
          "lines": "271-281",
          "snippet": "void FdOutputStream::write(const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n\n  while (size > 0) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::write(fd, pos, size), fd);\n    KJ_ASSERT(n > 0, \"write() returned zero.\");\n    pos += n;\n    size -= n;\n  }\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <algorithm>",
            "#include \"miniposix.h\"",
            "#include \"debug.h\"",
            "#include \"io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid FdOutputStream::write(const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n\n  while (size > 0) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::write(fd, pos, size), fd);\n    KJ_ASSERT(n > 0, \"write() returned zero.\");\n    pos += n;\n    size -= n;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "piece.size",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "piece.begin",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid OutputStream::write(ArrayPtr<const ArrayPtr<const byte>> pieces) {\n  for (auto piece: pieces) {\n    write(piece.begin(), piece.size());\n  }\n}"
  },
  {
    "function_name": "InputStream::skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "50-57",
    "snippet": "void InputStream::skip(size_t bytes) {\n  char scratch[8192];\n  while (bytes > 0) {\n    size_t amount = std::min(bytes, sizeof(scratch));\n    read(scratch, amount);\n    bytes -= amount;\n  }\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "scratch",
            "amount"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "InputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "66-66",
          "snippet": "inline void read(void* buffer, size_t bytes) { read(buffer, bytes, bytes); }",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nInputStream {\n  inline void read(void* buffer, size_t bytes) { read(buffer, bytes, bytes); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "bytes",
            "sizeof(scratch)"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid InputStream::skip(size_t bytes) {\n  char scratch[8192];\n  while (bytes > 0) {\n    size_t amount = std::min(bytes, sizeof(scratch));\n    read(scratch, amount);\n    bytes -= amount;\n  }\n}"
  },
  {
    "function_name": "InputStream::read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "40-48",
    "snippet": "size_t InputStream::read(void* buffer, size_t minBytes, size_t maxBytes) {\n  size_t n = tryRead(buffer, minBytes, maxBytes);\n  KJ_REQUIRE(n >= minBytes, \"Premature EOF\") {\n    // Pretend we read zeros from the input.\n    memset(reinterpret_cast<byte*>(buffer) + n, 0, minBytes - n);\n    return minBytes;\n  }\n  return n;\n}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "reinterpret_cast<byte*>(buffer) + n",
            "0",
            "minBytes - n"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "buffer"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "n >= minBytes",
            "\"Premature EOF\""
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryRead",
          "args": [
            "buffer",
            "minBytes",
            "maxBytes"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "FdInputStream::tryRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
          "lines": "252-267",
          "snippet": "size_t FdInputStream::tryRead(void* buffer, size_t minBytes, size_t maxBytes) {\n  byte* pos = reinterpret_cast<byte*>(buffer);\n  byte* min = pos + minBytes;\n  byte* max = pos + maxBytes;\n\n  while (pos < min) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::read(fd, pos, max - pos), fd);\n    if (n == 0) {\n      break;\n    }\n    pos += n;\n  }\n\n  return pos - reinterpret_cast<byte*>(buffer);\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <algorithm>",
            "#include \"miniposix.h\"",
            "#include \"debug.h\"",
            "#include \"io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nsize_t FdInputStream::tryRead(void* buffer, size_t minBytes, size_t maxBytes) {\n  byte* pos = reinterpret_cast<byte*>(buffer);\n  byte* min = pos + minBytes;\n  byte* max = pos + maxBytes;\n\n  while (pos < min) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::read(fd, pos, max - pos), fd);\n    if (n == 0) {\n      break;\n    }\n    pos += n;\n  }\n\n  return pos - reinterpret_cast<byte*>(buffer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nsize_t InputStream::read(void* buffer, size_t minBytes, size_t maxBytes) {\n  size_t n = tryRead(buffer, minBytes, maxBytes);\n  KJ_REQUIRE(n >= minBytes, \"Premature EOF\") {\n    // Pretend we read zeros from the input.\n    memset(reinterpret_cast<byte*>(buffer) + n, 0, minBytes - n);\n    return minBytes;\n  }\n  return n;\n}"
  },
  {
    "function_name": "BufferedOutputStream::~BufferedOutputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "38-38",
    "snippet": "BufferedOutputStream::~BufferedOutputStream() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nBufferedOutputStream::~BufferedOutputStream() noexcept(false) {}"
  },
  {
    "function_name": "BufferedInputStream::~BufferedInputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "37-37",
    "snippet": "BufferedInputStream::~BufferedInputStream() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nBufferedInputStream::~BufferedInputStream() noexcept(false) {}"
  },
  {
    "function_name": "OutputStream::~OutputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "36-36",
    "snippet": "OutputStream::~OutputStream() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nOutputStream::~OutputStream() noexcept(false) {}"
  },
  {
    "function_name": "InputStream::~InputStream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
    "lines": "35-35",
    "snippet": "InputStream::~InputStream() noexcept(false) {}",
    "includes": [
      "#include <sys/uio.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include <algorithm>",
      "#include \"miniposix.h\"",
      "#include \"debug.h\"",
      "#include \"io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nInputStream::~InputStream() noexcept(false) {}"
  }
]