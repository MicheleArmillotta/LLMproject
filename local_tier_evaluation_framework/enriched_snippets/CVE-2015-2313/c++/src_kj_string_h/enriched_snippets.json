[
  {
    "function_name": "strArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "345-499",
    "snippet": "String strArray(T&& arr, const char* delim) {\n  size_t delimLen = strlen(delim);\n  KJ_STACK_ARRAY(decltype(_::STR * arr[0]), pieces, kj::size(arr), 8, 32);\n  size_t size = 0;\n  for (size_t i = 0; i < kj::size(arr); i++) {\n    if (i > 0) size += delimLen;\n    pieces[i] = _::STR * arr[i];\n    size += pieces[i].size();\n  }\n\n  String result = heapString(size);\n  char* pos = result.begin();\n  for (size_t i = 0; i < kj::size(arr); i++) {\n    if (i > 0) {\n      memcpy(pos, delim, delimLen);\n      pos += delimLen;\n    }\n    pos = _::fill(pos, pieces[i]);\n  }\n  return result;\n}\n\nnamespace _ {  // private\n\ntemplate <typename T>\ninline String Stringifier::operator*(ArrayPtr<T> arr) const {\n  return strArray(arr, \", \");\n}\n\ntemplate <typename T>\ninline String Stringifier::operator*(const Array<T>& arr) const {\n  return strArray(arr, \", \");\n}\n\n}  // namespace _ (private)\n\n#define KJ_STRINGIFY(...) operator*(::kj::_::Stringifier, __VA_ARGS__)\n// Defines a stringifier for a custom type.  Example:\n//\n//    class Foo {...};\n//    inline StringPtr KJ_STRINGIFY(const Foo& foo) { return foo.name(); }\n//\n// This allows Foo to be passed to str().\n//\n// The function should be declared either in the same namespace as the target type or in the global\n// namespace.  It can return any type which is an iterable container of chars.\n\n// =======================================================================================\n// Inline implementation details.\n\ninline StringPtr::StringPtr(const String& value): content(value.begin(), value.size() + 1) {}\n\ninline StringPtr::operator ArrayPtr<const char>() const {\n  return content.slice(0, content.size() - 1);\n}\n\ninline ArrayPtr<const char> StringPtr::asArray() const {\n  return content.slice(0, content.size() - 1);\n}\n\ninline bool StringPtr::operator==(const StringPtr& other) const {\n  return content.size() == other.content.size() &&\n      memcmp(content.begin(), other.content.begin(), content.size() - 1) == 0;\n}\n\ninline bool StringPtr::operator<(const StringPtr& other) const {\n  bool shorter = content.size() < other.content.size();\n  int cmp = memcmp(content.begin(), other.content.begin(),\n                   shorter ? content.size() : other.content.size());\n  return cmp < 0 || (cmp == 0 && shorter);\n}\n\ninline StringPtr StringPtr::slice(size_t start) const {\n  return StringPtr(content.slice(start, content.size()));\n}\ninline ArrayPtr<const char> StringPtr::slice(size_t start, size_t end) const {\n  return content.slice(start, end);\n}\n\ninline bool StringPtr::startsWith(const StringPtr& other) const {\n  return other.content.size() <= content.size() &&\n      memcmp(content.begin(), other.content.begin(), other.size()) == 0;\n}\ninline bool StringPtr::endsWith(const StringPtr& other) const {\n  return other.content.size() <= content.size() &&\n      memcmp(end() - other.size(), other.content.begin(), other.size()) == 0;\n}\n\ninline Maybe<size_t> StringPtr::findFirst(char c) const {\n  const char* pos = reinterpret_cast<const char*>(memchr(content.begin(), c, size()));\n  if (pos == nullptr) {\n    return nullptr;\n  } else {\n    return pos - content.begin();\n  }\n}\n\ninline Maybe<size_t> StringPtr::findLast(char c) const {\n  for (size_t i = size(); i > 0; --i) {\n    if (content[i-1] == c) {\n      return i-1;\n    }\n  }\n  return nullptr;\n}\n\ninline String::operator ArrayPtr<char>() {\n  return content == nullptr ? ArrayPtr<char>(nullptr) : content.slice(0, content.size() - 1);\n}\ninline String::operator ArrayPtr<const char>() const {\n  return content == nullptr ? ArrayPtr<const char>(nullptr) : content.slice(0, content.size() - 1);\n}\n\ninline ArrayPtr<char> String::asArray() {\n  return content == nullptr ? ArrayPtr<char>(nullptr) : content.slice(0, content.size() - 1);\n}\ninline ArrayPtr<const char> String::asArray() const {\n  return content == nullptr ? ArrayPtr<const char>(nullptr) : content.slice(0, content.size() - 1);\n}\n\ninline const char* String::cStr() const { return content == nullptr ? \"\" : content.begin(); }\n\ninline size_t String::size() const { return content == nullptr ? 0 : content.size() - 1; }\n\ninline char String::operator[](size_t index) const { return content[index]; }\ninline char& String::operator[](size_t index) { return content[index]; }\n\ninline char* String::begin() { return content == nullptr ? nullptr : content.begin(); }\ninline char* String::end() { return content == nullptr ? nullptr : content.end() - 1; }\ninline const char* String::begin() const { return content == nullptr ? nullptr : content.begin(); }\ninline const char* String::end() const { return content == nullptr ? nullptr : content.end() - 1; }\n\ninline String::String(char* value, size_t size, const ArrayDisposer& disposer)\n    : content(value, size + 1, disposer) {\n  KJ_IREQUIRE(value[size] == '\\0', \"String must be NUL-terminated.\");\n}\n\ninline String::String(Array<char> buffer): content(kj::mv(buffer)) {\n  KJ_IREQUIRE(content.size() > 0 && content.back() == '\\0', \"String must be NUL-terminated.\");\n}\n\ninline String heapString(const char* value) {\n  return heapString(value, strlen(value));\n}\ninline String heapString(StringPtr value) {\n  return heapString(value.begin(), value.size());\n}\ninline String heapString(const String& value) {\n  return heapString(value.begin(), value.size());\n}\ninline String heapString(ArrayPtr<const char> value) {\n  return heapString(value.begin(), value.size());\n}\n\n}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "value.begin()",
            "value.size()"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "42-47",
          "snippet": "String heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(const char* value, size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  memcpy(buffer, value, size);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "86-86",
          "snippet": "inline size_t size() const { return content.size() - 1; }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline size_t size() const { return content.size() - 1; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.begin",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "content.size() > 0 && content.back() == '\\0'",
            "\"String must be NUL-terminated.\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.back",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "buffer"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "value[size] == '\\0'",
            "\"String must be NUL-terminated.\""
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.end",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.slice",
          "args": [
            "0",
            "content.size() - 1"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "178-180",
          "snippet": "inline ArrayPtr<const char> slice(size_t start, size_t end) const {\n    return StringPtr(*this).slice(start, end);\n  }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline ArrayPtr<const char> slice(size_t start, size_t end) const {\n      return StringPtr(*this).slice(start, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ArrayPtr<const char>",
          "args": [
            "nullptr"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayPtr",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1121-1121",
          "snippet": "inline constexpr ArrayPtr(T (&native)[size]): ptr(native), size_(size) {}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline constexpr ArrayPtr(T (&native)[size]): ptr(native), size_(size) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "memchr(content.begin(), c, size())"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "content.begin()",
            "c",
            "size()"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "end() - other.size()",
            "other.content.begin()",
            "other.size()"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "content.begin()",
            "other.content.begin()",
            "other.size()"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "content.slice(start, content.size())"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "content.begin()",
            "other.content.begin()",
            "shorter ? content.size() : other.content.size()"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "content.begin()",
            "other.content.begin()",
            "content.size() - 1"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n  for",
          "args": [
            "size_t i = 0; i < kj::size(arr); i++) {\n    if (i > 0) size += delimLen;\n    pieces[i] = _::STR * arr[i];\n    size += pieces[i].size();\n  }\n\n  String result = heapString(size);\n  char* pos = result.begin();\n  for (size_t i = 0; i < kj::size(arr); i++) {\n    if (i > 0) {\n      memcpy(pos, delim, delimLen);\n      pos += delimLen;\n    }\n    pos = _::fill(pos, pieces[i]);\n  }\n  return result;\n}\n\nnamespace _ {  // private\n\ntemplate <typename T>\ninline String Stringifier::operator*(ArrayPtr<T> arr) const {\n  return strArray(arr, \", \");\n}\n\ntemplate <typename T>\ninline String Stringifier::operator*(const Array<T>& arr) const {\n  return strArray(arr, \", \");\n}\n\n}  // namespace _ (private)\n\n#define KJ_STRINGIFY(...) operator*(::kj::_::Stringifier, __VA_ARGS__)\n// Defines a stringifier for a custom type.  Example:\n//\n//    class Foo {...};\n//    inline StringPtr KJ_STRINGIFY(const Foo& foo) { return foo.name(); }\n//\n// This allows Foo to be passed to str().\n//\n// The function should be declared either in the same namespace as the target type or in the global\n// namespace.  It can return any type which is an iterable container of chars.\n\n// =======================================================================================\n// Inline implementation details.\n\ninline StringPtr::StringPtr(const String& value"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n  for",
          "args": [
            "size_t i = 0; i < kj::size(arr); i++) {\n    if (i > 0) {\n      memcpy(pos, delim, delimLen);\n      pos += delimLen;\n    }\n    pos = _::fill(pos, pieces[i]);\n  }\n  return result;\n}\n\nnamespace_ {  // private\n\ntemplate <typename T>\ninline String Stringifier::operator*(ArrayPtr<T> arr) const {\n  return strArray(arr, \", \");\n}\n\ntemplate <typename T>\ninline String Stringifier::operator*(const Array<T>& arr) const {\n  return strArray(arr, \", \");\n}\n\n}  // namespace _ (private)\n\n#define KJ_STRINGIFY(..."
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "arr",
            "\", \""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Stringifier::operator*",
          "args": [
            "constArray<T>& arr"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "Stringifier::operator*",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "343-347",
          "snippet": "CappedArray<char, kDoubleToBufferSize> Stringifier::operator*(double f) const {\n  CappedArray<char, kDoubleToBufferSize> result;\n  result.setSize(strlen(DoubleToBuffer(f, result.begin())));\n  return result;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nCappedArray<char, kDoubleToBufferSize> Stringifier::operator*(double f) const {\n  CappedArray<char, kDoubleToBufferSize> result;\n  result.setSize(strlen(DoubleToBuffer(f, result.begin())));\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "arr",
            "\", \""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_::fill",
          "args": [
            "pos",
            "pieces[i]"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pos",
            "delim",
            "delimLen"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "i > 0"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "if",
          "container": "RpcPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1516-1518",
          "snippet": "else if (state.is<Resolved>()) {\n        return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcPipeline {\n  else if (state.is<Resolved>()) {\n          return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "delim"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString strArray(T&& arr, const char* delim) {\n  size_t delimLen = strlen(delim);\n  KJ_STACK_ARRAY(decltype(_::STR * arr[0]), pieces, kj::size(arr), 8, 32);\n  size_t size = 0;\n  for (size_t i = 0; i < kj::size(arr); i++) {\n    if (i > 0) size += delimLen;\n    pieces[i] = _::STR * arr[i];\n    size += pieces[i].size();\n  }\n\n  String result = heapString(size);\n  char* pos = result.begin();\n  for (size_t i = 0; i < kj::size(arr); i++) {\n    if (i > 0) {\n      memcpy(pos, delim, delimLen);\n      pos += delimLen;\n    }\n    pos = _::fill(pos, pieces[i]);\n  }\n  return result;\n}\n\nnamespace _ {  // private\n\ntemplate <typename T>\ninline String Stringifier::operator*(ArrayPtr<T> arr) const {\n  return strArray(arr, \", \");\n}\n\ntemplate <typename T>\ninline String Stringifier::operator*(const Array<T>& arr) const {\n  return strArray(arr, \", \");\n}\n\n}  // namespace _ (private)\n\n#define KJ_STRINGIFY(...) operator*(::kj::_::Stringifier, __VA_ARGS__)\n// Defines a stringifier for a custom type.  Example:\n//\n//    class Foo {...};\n//    inline StringPtr KJ_STRINGIFY(const Foo& foo) { return foo.name(); }\n//\n// This allows Foo to be passed to str().\n//\n// The function should be declared either in the same namespace as the target type or in the global\n// namespace.  It can return any type which is an iterable container of chars.\n\n// =======================================================================================\n// Inline implementation details.\n\ninline StringPtr::StringPtr(const String& value): content(value.begin(), value.size() + 1) {}\n\ninline StringPtr::operator ArrayPtr<const char>() const {\n  return content.slice(0, content.size() - 1);\n}\n\ninline ArrayPtr<const char> StringPtr::asArray() const {\n  return content.slice(0, content.size() - 1);\n}\n\ninline bool StringPtr::operator==(const StringPtr& other) const {\n  return content.size() == other.content.size() &&\n      memcmp(content.begin(), other.content.begin(), content.size() - 1) == 0;\n}\n\ninline bool StringPtr::operator<(const StringPtr& other) const {\n  bool shorter = content.size() < other.content.size();\n  int cmp = memcmp(content.begin(), other.content.begin(),\n                   shorter ? content.size() : other.content.size());\n  return cmp < 0 || (cmp == 0 && shorter);\n}\n\ninline StringPtr StringPtr::slice(size_t start) const {\n  return StringPtr(content.slice(start, content.size()));\n}\ninline ArrayPtr<const char> StringPtr::slice(size_t start, size_t end) const {\n  return content.slice(start, end);\n}\n\ninline bool StringPtr::startsWith(const StringPtr& other) const {\n  return other.content.size() <= content.size() &&\n      memcmp(content.begin(), other.content.begin(), other.size()) == 0;\n}\ninline bool StringPtr::endsWith(const StringPtr& other) const {\n  return other.content.size() <= content.size() &&\n      memcmp(end() - other.size(), other.content.begin(), other.size()) == 0;\n}\n\ninline Maybe<size_t> StringPtr::findFirst(char c) const {\n  const char* pos = reinterpret_cast<const char*>(memchr(content.begin(), c, size()));\n  if (pos == nullptr) {\n    return nullptr;\n  } else {\n    return pos - content.begin();\n  }\n}\n\ninline Maybe<size_t> StringPtr::findLast(char c) const {\n  for (size_t i = size(); i > 0; --i) {\n    if (content[i-1] == c) {\n      return i-1;\n    }\n  }\n  return nullptr;\n}\n\ninline String::operator ArrayPtr<char>() {\n  return content == nullptr ? ArrayPtr<char>(nullptr) : content.slice(0, content.size() - 1);\n}\ninline String::operator ArrayPtr<const char>() const {\n  return content == nullptr ? ArrayPtr<const char>(nullptr) : content.slice(0, content.size() - 1);\n}\n\ninline ArrayPtr<char> String::asArray() {\n  return content == nullptr ? ArrayPtr<char>(nullptr) : content.slice(0, content.size() - 1);\n}\ninline ArrayPtr<const char> String::asArray() const {\n  return content == nullptr ? ArrayPtr<const char>(nullptr) : content.slice(0, content.size() - 1);\n}\n\ninline const char* String::cStr() const { return content == nullptr ? \"\" : content.begin(); }\n\ninline size_t String::size() const { return content == nullptr ? 0 : content.size() - 1; }\n\ninline char String::operator[](size_t index) const { return content[index]; }\ninline char& String::operator[](size_t index) { return content[index]; }\n\ninline char* String::begin() { return content == nullptr ? nullptr : content.begin(); }\ninline char* String::end() { return content == nullptr ? nullptr : content.end() - 1; }\ninline const char* String::begin() const { return content == nullptr ? nullptr : content.begin(); }\ninline const char* String::end() const { return content == nullptr ? nullptr : content.end() - 1; }\n\ninline String::String(char* value, size_t size, const ArrayDisposer& disposer)\n    : content(value, size + 1, disposer) {\n  KJ_IREQUIRE(value[size] == '\\0', \"String must be NUL-terminated.\");\n}\n\ninline String::String(Array<char> buffer): content(kj::mv(buffer)) {\n  KJ_IREQUIRE(content.size() > 0 && content.back() == '\\0', \"String must be NUL-terminated.\");\n}\n\ninline String heapString(const char* value) {\n  return heapString(value, strlen(value));\n}\ninline String heapString(StringPtr value) {\n  return heapString(value.begin(), value.size());\n}\ninline String heapString(const String& value) {\n  return heapString(value.begin(), value.size());\n}\ninline String heapString(ArrayPtr<const char> value) {\n  return heapString(value.begin(), value.size());\n}\n\n}"
  },
  {
    "function_name": "str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "341-341",
    "snippet": "inline String str(String&& s) { return mv(s); }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "s"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
  },
  {
    "function_name": "str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "331-339",
    "snippet": "String str(Params&&... params) {\n  // Magic function which builds a string from a bunch of arbitrary values.  Example:\n  //     str(1, \" / \", 2, \" = \", 0.5)\n  // returns:\n  //     \"1 / 2 = 0.5\"\n  // To teach `str` how to stringify a type, see `Stringifier`.\n\n  return _::concat(toCharSequence(kj::fwd<Params>(params))...);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::concat",
          "args": [
            "toCharSequence(kj::fwd<Params>(params))..."
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "concat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "245-247",
          "snippet": "inline String concat(String&& arr) {\n  return kj::mv(arr);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String concat(String&& arr) {\n  return kj::mv(arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "toCharSequence",
          "args": [
            "kj::fwd<Params>(params)"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "toCharSequence",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "312-322",
          "snippet": "auto toCharSequence(T&& value) -> decltype(_::STR * kj::fwd<T>(value)) {\n  // Returns an iterable of chars that represent a textual representation of the value, suitable\n  // for debugging.\n  //\n  // Most users should use str() instead, but toCharSequence() may occasionally be useful to avoid\n  // heap allocation overhead that str() implies.\n  //\n  // To specialize this function for your type, see KJ_STRINGIFY.\n\n  return _::STR * kj::fwd<T>(value);\n}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nauto toCharSequence(T&& value) -> decltype(_::STR * kj::fwd<T>(value)) {\n  // Returns an iterable of chars that represent a textual representation of the value, suitable\n  // for debugging.\n  //\n  // Most users should use str() instead, but toCharSequence() may occasionally be useful to avoid\n  // heap allocation overhead that str() implies.\n  //\n  // To specialize this function for your type, see KJ_STRINGIFY.\n\n  return _::STR * kj::fwd<T>(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString str(Params&&... params) {\n  // Magic function which builds a string from a bunch of arbitrary values.  Example:\n  //     str(1, \" / \", 2, \" = \", 0.5)\n  // returns:\n  //     \"1 / 2 = 0.5\"\n  // To teach `str` how to stringify a type, see `Stringifier`.\n\n  return _::concat(toCharSequence(kj::fwd<Params>(params))...);\n}"
  },
  {
    "function_name": "toCharSequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "312-322",
    "snippet": "auto toCharSequence(T&& value) -> decltype(_::STR * kj::fwd<T>(value)) {\n  // Returns an iterable of chars that represent a textual representation of the value, suitable\n  // for debugging.\n  //\n  // Most users should use str() instead, but toCharSequence() may occasionally be useful to avoid\n  // heap allocation overhead that str() implies.\n  //\n  // To specialize this function for your type, see KJ_STRINGIFY.\n\n  return _::STR * kj::fwd<T>(value);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<T>",
          "args": [
            "value"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::fwd<T>",
          "args": [
            "value"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nauto toCharSequence(T&& value) -> decltype(_::STR * kj::fwd<T>(value)) {\n  // Returns an iterable of chars that represent a textual representation of the value, suitable\n  // for debugging.\n  //\n  // Most users should use str() instead, but toCharSequence() may occasionally be useful to avoid\n  // heap allocation overhead that str() implies.\n  //\n  // To specialize this function for your type, see KJ_STRINGIFY.\n\n  return _::STR * kj::fwd<T>(value);\n}"
  },
  {
    "function_name": "concat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "245-247",
    "snippet": "inline String concat(String&& arr) {\n  return kj::mv(arr);\n}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "arr"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String concat(String&& arr) {\n  return kj::mv(arr);\n}"
  },
  {
    "function_name": "concat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "236-243",
    "snippet": "String concat(Params&&... params) {\n  // Concatenate a bunch of containers into a single Array.  The containers can be anything that\n  // is iterable and whose elements can be converted to `char`.\n\n  String result = heapString(sum({params.size()...}));\n  fill(result.begin(), kj::fwd<Params>(params)...);\n  return result;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "result.begin()",
            "kj::fwd<Params>(params)..."
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "StringTree::fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string-tree.h",
          "lines": "168-171",
          "snippet": "inline void StringTree::fill(char* pos, size_t branchIndex) {\n  KJ_IREQUIRE(pos == text.end() && branchIndex == branches.size(),\n              kj::str(text.end() - pos, ' ', branches.size() - branchIndex).cStr());\n}",
          "includes": [
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n\ninline void StringTree::fill(char* pos, size_t branchIndex) {\n  KJ_IREQUIRE(pos == text.end() && branchIndex == branches.size(),\n              kj::str(text.end() - pos, ' ', branches.size() - branchIndex).cStr());\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "sum({params.size()...})"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sum",
          "args": [
            "{params.size()...}"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "209-215",
          "snippet": "inline size_t sum(std::initializer_list<size_t> nums) {\n  size_t result = 0;\n  for (auto num: nums) {\n    result += num;\n  }\n  return result;\n}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline size_t sum(std::initializer_list<size_t> nums) {\n  size_t result = 0;\n  for (auto num: nums) {\n    result += num;\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "86-86",
          "snippet": "inline size_t size() const { return content.size() - 1; }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline size_t size() const { return content.size() - 1; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString concat(Params&&... params) {\n  // Concatenate a bunch of containers into a single Array.  The containers can be anything that\n  // is iterable and whose elements can be converted to `char`.\n\n  String result = heapString(sum({params.size()...}));\n  fill(result.begin(), kj::fwd<Params>(params)...);\n  return result;\n}"
  },
  {
    "function_name": "sum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "209-215",
    "snippet": "inline size_t sum(std::initializer_list<size_t> nums) {\n  size_t result = 0;\n  for (auto num: nums) {\n    result += num;\n  }\n  return result;\n}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline size_t sum(std::initializer_list<size_t> nums) {\n  size_t result = 0;\n  for (auto num: nums) {\n    result += num;\n  }\n  return result;\n}"
  },
  {
    "function_name": "findLast",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "183-183",
    "snippet": "inline Maybe<size_t> findLast(char c) const { return StringPtr(*this).findLast(c); }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "c"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findLast(char c) const { return StringPtr(*this).findLast(c); }\n}"
  },
  {
    "function_name": "findFirst",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "182-182",
    "snippet": "inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "c"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }\n}"
  },
  {
    "function_name": "slice",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "178-180",
    "snippet": "inline ArrayPtr<const char> slice(size_t start, size_t end) const {\n    return StringPtr(*this).slice(start, end);\n  }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "start",
            "end"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "61-61",
          "snippet": "inline StringPtr(const char* begin, const char* end): StringPtr(begin, end - begin) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(const char* begin, const char* end): StringPtr(begin, end - begin) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline ArrayPtr<const char> slice(size_t start, size_t end) const {\n      return StringPtr(*this).slice(start, end);\n    }\n}"
  },
  {
    "function_name": "slice",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "177-177",
    "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "start"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
  },
  {
    "function_name": "endsWith",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "175-175",
    "snippet": "inline bool endsWith(const StringPtr& other) const { return StringPtr(*this).endsWith(other); }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "other"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool endsWith(const StringPtr& other) const { return StringPtr(*this).endsWith(other); }\n}"
  },
  {
    "function_name": "startsWith",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "174-174",
    "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "other"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "116-116",
          "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
  },
  {
    "function_name": "asBytes",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "148-148",
    "snippet": "inline ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asArray",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "AncillaryMessage::asArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.h",
          "lines": "501-503",
          "snippet": "inline ArrayPtr<const T> AncillaryMessage::asArray() {\n  return arrayPtr(reinterpret_cast<const T*>(data.begin()), data.size() / sizeof(T));\n}",
          "includes": [
            "#include \"time.h\"",
            "#include \"thread.h\"",
            "#include \"function.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"time.h\"\n#include \"thread.h\"\n#include \"function.h\"\n#include \"async.h\"\n\ninline ArrayPtr<const T> AncillaryMessage::asArray() {\n  return arrayPtr(reinterpret_cast<const T*>(data.begin()), data.size() / sizeof(T));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }\n}"
  },
  {
    "function_name": "asBytes",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "147-147",
    "snippet": "inline ArrayPtr<byte> asBytes() { return asArray().asBytes(); }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asArray",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "AncillaryMessage::asArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.h",
          "lines": "501-503",
          "snippet": "inline ArrayPtr<const T> AncillaryMessage::asArray() {\n  return arrayPtr(reinterpret_cast<const T*>(data.begin()), data.size() / sizeof(T));\n}",
          "includes": [
            "#include \"time.h\"",
            "#include \"thread.h\"",
            "#include \"function.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"time.h\"\n#include \"thread.h\"\n#include \"function.h\"\n#include \"async.h\"\n\ninline ArrayPtr<const T> AncillaryMessage::asArray() {\n  return arrayPtr(reinterpret_cast<const T*>(data.begin()), data.size() / sizeof(T));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline ArrayPtr<byte> asBytes() { return asArray().asBytes(); }\n}"
  },
  {
    "function_name": "String",
    "container": "String",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "137-137",
    "snippet": "inline String(decltype(nullptr)): content(nullptr) {}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline String(decltype(nullptr)): content(nullptr) {}\n}"
  },
  {
    "function_name": "StringPtr",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "116-116",
    "snippet": "inline StringPtr(ArrayPtr<const char> content): content(content) {}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(ArrayPtr<const char> content): content(content) {}\n}"
  },
  {
    "function_name": "size",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "86-86",
    "snippet": "inline size_t size() const { return content.size() - 1; }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline size_t size() const { return content.size() - 1; }\n}"
  },
  {
    "function_name": "asBytes",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "80-80",
    "snippet": "inline ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "asArray",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "AncillaryMessage::asArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.h",
          "lines": "501-503",
          "snippet": "inline ArrayPtr<const T> AncillaryMessage::asArray() {\n  return arrayPtr(reinterpret_cast<const T*>(data.begin()), data.size() / sizeof(T));\n}",
          "includes": [
            "#include \"time.h\"",
            "#include \"thread.h\"",
            "#include \"function.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"time.h\"\n#include \"thread.h\"\n#include \"function.h\"\n#include \"async.h\"\n\ninline ArrayPtr<const T> AncillaryMessage::asArray() {\n  return arrayPtr(reinterpret_cast<const T*>(data.begin()), data.size() / sizeof(T));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }\n}"
  },
  {
    "function_name": "StringPtr",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "66-66",
    "snippet": "inline StringPtr(const T& t): StringPtr(t.c_str()) {}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "t.c_str",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(const T& t): StringPtr(t.c_str()) {}\n}"
  },
  {
    "function_name": "StringPtr",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "61-61",
    "snippet": "inline StringPtr(const char* begin, const char* end): StringPtr(begin, end - begin) {}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(const char* begin, const char* end): StringPtr(begin, end - begin) {}\n}"
  },
  {
    "function_name": "StringPtr",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "58-60",
    "snippet": "inline StringPtr(const char* value, size_t size): content(value, size + 1) {\n    KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n  }",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IREQUIRE",
          "args": [
            "value[size] == '\\0'",
            "\"StringPtr must be NUL-terminated.\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(const char* value, size_t size): content(value, size + 1) {\n      KJ_IREQUIRE(value[size] == '\\0', \"StringPtr must be NUL-terminated.\");\n    }\n}"
  },
  {
    "function_name": "StringPtr",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "57-57",
    "snippet": "inline StringPtr(const char* value): content(value, strlen(value) + 1) {}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "value"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(const char* value): content(value, strlen(value) + 1) {}\n}"
  },
  {
    "function_name": "StringPtr",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "56-56",
    "snippet": "inline StringPtr(decltype(nullptr)): content(\"\", 1) {}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(decltype(nullptr)): content(\"\", 1) {}\n}"
  },
  {
    "function_name": "StringPtr",
    "container": "StringPtr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
    "lines": "55-55",
    "snippet": "inline StringPtr(): content(\"\", 1) {}",
    "includes": [
      "#include <string.h>",
      "#include \"array.h\"",
      "#include <initializer_list>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(): content(\"\", 1) {}\n}"
  }
]