[
  {
    "function_name": "ModuleLoader::loadModule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "337-339",
    "snippet": "kj::Maybe<Module&> ModuleLoader::loadModule(kj::StringPtr localName, kj::StringPtr sourceName) {\n  return impl->loadModule(localName, sourceName);\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl->loadModule",
          "args": [
            "localName",
            "sourceName"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::Maybe<Module&> ModuleLoader::loadModule(kj::StringPtr localName, kj::StringPtr sourceName) {\n  return impl->loadModule(localName, sourceName);\n}"
  },
  {
    "function_name": "ModuleLoader::addImportPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "335-335",
    "snippet": "void ModuleLoader::addImportPath(kj::String path) { impl->addImportPath(kj::mv(path)); }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "impl->addImportPath",
          "args": [
            "kj::mv(path)"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "addImportPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
          "lines": "220-222",
          "snippet": "void addImportPath(kj::String path) {\n    searchPath.add(kj::heapString(kj::mv(path)));\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/mutex.h>",
            "#include <kj/vector.h>",
            "#include \"parser.h\"",
            "#include \"lexer.h\"",
            "#include \"module-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nvoid addImportPath(kj::String path) {\n    searchPath.add(kj::heapString(kj::mv(path)));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "path"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nvoid ModuleLoader::addImportPath(kj::String path) { impl->addImportPath(kj::mv(path)); }"
  },
  {
    "function_name": "ModuleLoader::~ModuleLoader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "333-333",
    "snippet": "ModuleLoader::~ModuleLoader() noexcept(false) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nModuleLoader::~ModuleLoader() noexcept(false) {}"
  },
  {
    "function_name": "ModuleLoader::ModuleLoader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "331-332",
    "snippet": "ModuleLoader::ModuleLoader(GlobalErrorReporter& errorReporter)\n    : impl(kj::heap<Impl>(errorReporter)) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<Impl>",
          "args": [
            "errorReporter"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nModuleLoader::ModuleLoader(GlobalErrorReporter& errorReporter)\n    : impl(kj::heap<Impl>(errorReporter)) {}"
  },
  {
    "function_name": "ModuleLoader::Impl::loadModuleFromSearchPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "316-327",
    "snippet": "kj::Maybe<Module&> ModuleLoader::Impl::loadModuleFromSearchPath(kj::StringPtr sourceName) {\n  for (auto& search: searchPath) {\n    kj::String candidate = kj::str(search, \"/\", sourceName);\n    char* end = canonicalizePath(candidate.begin() + (candidate[0] == '/'));\n\n    KJ_IF_MAYBE(module, loadModule(\n        kj::heapString(candidate.slice(0, end - candidate.begin())), sourceName)) {\n      return *module;\n    }\n  }\n  return nullptr;\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "module",
            "loadModule(\n        kj::heapString(candidate.slice(0, end - candidate.begin())), sourceName)"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/parser.c++",
          "lines": "982-1016",
          "snippet": "KJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }",
          "includes": [
            "#include <windows.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/debug.h>",
            "#include <capnp/dynamic.h>",
            "#include \"md5.h\"",
            "#include \"parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <windows.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/debug.h>\n#include <capnp/dynamic.h>\n#include \"md5.h\"\n#include \"parser.h\"\n\nKJ_IF_MAYBE(target, maybeTarget) {\n            if (target->value == \"*\") {\n              // Set all.\n              if (targets.value.size() > 1) {\n                errorReporter.addError(target->startByte, target->endByte,\n                    \"Wildcard should not be specified together with other targets.\");\n              }\n\n              for (auto field: dynamicBuilder.getSchema().getFields()) {\n                if (field.getProto().getName().startsWith(\"targets\")) {\n                  dynamicBuilder.set(field, true);\n                }\n              }\n            } else {\n              if (target->value.size() == 0 || target->value.size() >= 32 ||\n                  target->value[0] < 'a' || target->value[0] > 'z') {\n                errorReporter.addError(target->startByte, target->endByte,\n                                       \"Not a valid annotation target.\");\n              } else {\n                char buffer[64];\n                strcpy(buffer, \"targets\");\n                strcat(buffer, target->value.cStr());\n                buffer[strlen(\"targets\")] += 'A' - 'a';\n                KJ_IF_MAYBE(field, dynamicBuilder.getSchema().findFieldByName(buffer)) {\n                  if (dynamicBuilder.get(*field).as<bool>()) {\n                    errorReporter.addError(target->startByte, target->endByte,\n                                           \"Duplicate target specification.\");\n                  }\n                  dynamicBuilder.set(*field, true);\n                } else {\n                  errorReporter.addError(target->startByte, target->endByte,\n                                         \"Not a valid annotation target.\");\n                }\n              }\n            }"
        }
      },
      {
        "call_info": {
          "callee": "loadModule",
          "args": [
            "kj::heapString(candidate.slice(0, end - candidate.begin()))",
            "sourceName"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ModuleLoader::loadModule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
          "lines": "337-339",
          "snippet": "kj::Maybe<Module&> ModuleLoader::loadModule(kj::StringPtr localName, kj::StringPtr sourceName) {\n  return impl->loadModule(localName, sourceName);\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/mutex.h>",
            "#include <kj/vector.h>",
            "#include \"parser.h\"",
            "#include \"lexer.h\"",
            "#include \"module-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::Maybe<Module&> ModuleLoader::loadModule(kj::StringPtr localName, kj::StringPtr sourceName) {\n  return impl->loadModule(localName, sourceName);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "candidate.slice(0, end - candidate.begin())"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "candidate.slice",
          "args": [
            "0",
            "end - candidate.begin()"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "candidate.begin",
          "args": [],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "candidate.begin() + (candidate[0] == '/')"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "search",
            "\"/\"",
            "sourceName"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::Maybe<Module&> ModuleLoader::Impl::loadModuleFromSearchPath(kj::StringPtr sourceName) {\n  for (auto& search: searchPath) {\n    kj::String candidate = kj::str(search, \"/\", sourceName);\n    char* end = canonicalizePath(candidate.begin() + (candidate[0] == '/'));\n\n    KJ_IF_MAYBE(module, loadModule(\n        kj::heapString(candidate.slice(0, end - candidate.begin())), sourceName)) {\n      return *module;\n    }\n  }\n  return nullptr;\n}"
  },
  {
    "function_name": "ModuleLoader::Impl::loadModule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "293-314",
    "snippet": "kj::Maybe<Module&> ModuleLoader::Impl::loadModule(\n    kj::StringPtr localName, kj::StringPtr sourceName) {\n  kj::String canonicalLocalName = canonicalizePath(localName);\n  kj::String canonicalSourceName = canonicalizePath(sourceName);\n\n  auto iter = modules.find(canonicalLocalName);\n  if (iter != modules.end()) {\n    // Return existing file.\n    return *iter->second;\n  }\n\n  if (access(canonicalLocalName.cStr(), F_OK) < 0) {\n    // No such file.\n    return nullptr;\n  }\n\n  auto module = kj::heap<ModuleImpl>(\n      *this, kj::mv(canonicalLocalName), kj::mv(canonicalSourceName));\n  auto& result = *module;\n  modules.insert(std::make_pair(result.getLocalName(), kj::mv(module)));\n  return result;\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modules.insert",
          "args": [
            "std::make_pair(result.getLocalName(), kj::mv(module))"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "result.getLocalName()",
            "kj::mv(module)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "module"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getLocalName",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "getLocalName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
          "lines": "239-241",
          "snippet": "kj::StringPtr getLocalName() {\n    return localName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/mutex.h>",
            "#include <kj/vector.h>",
            "#include \"parser.h\"",
            "#include \"lexer.h\"",
            "#include \"module-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::StringPtr getLocalName() {\n    return localName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<ModuleImpl>",
          "args": [
            "*this",
            "kj::mv(canonicalLocalName)",
            "kj::mv(canonicalSourceName)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "canonicalSourceName"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "canonicalLocalName"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "canonicalLocalName.cStr()",
            "F_OK"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalLocalName.cStr",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modules.end",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modules.find",
          "args": [
            "canonicalLocalName"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "sourceName"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "localName"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::Maybe<Module&> ModuleLoader::Impl::loadModule(\n    kj::StringPtr localName, kj::StringPtr sourceName) {\n  kj::String canonicalLocalName = canonicalizePath(localName);\n  kj::String canonicalSourceName = canonicalizePath(sourceName);\n\n  auto iter = modules.find(canonicalLocalName);\n  if (iter != modules.end()) {\n    // Return existing file.\n    return *iter->second;\n  }\n\n  if (access(canonicalLocalName.cStr(), F_OK) < 0) {\n    // No such file.\n    return nullptr;\n  }\n\n  auto module = kj::heap<ModuleImpl>(\n      *this, kj::mv(canonicalLocalName), kj::mv(canonicalSourceName));\n  auto& result = *module;\n  modules.insert(std::make_pair(result.getLocalName(), kj::mv(module)));\n  return result;\n}"
  },
  {
    "function_name": "hadErrors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "278-280",
    "snippet": "bool hadErrors() override {\n    return loader.getErrorReporter().hadErrors();\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loader.getErrorReporter",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loader.getErrorReporter",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nbool hadErrors() override {\n    return loader.getErrorReporter().hadErrors();\n  }"
  },
  {
    "function_name": "addError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "270-276",
    "snippet": "void addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    auto& lines = *KJ_REQUIRE_NONNULL(lineBreaks,\n        \"Can't report errors until loadContent() is called.\");\n\n    loader.getErrorReporter().addError(\n        localName, lines.toSourcePos(startByte), lines.toSourcePos(endByte), message);\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loader.getErrorReporter",
          "args": [
            "localName",
            "lines.toSourcePos(startByte)",
            "lines.toSourcePos(endByte)",
            "message"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.toSourcePos",
          "args": [
            "endByte"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lines.toSourcePos",
          "args": [
            "startByte"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loader.getErrorReporter",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE_NONNULL",
          "args": [
            "lineBreaks",
            "\"Can't report errors until loadContent() is called.\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nvoid addError(uint32_t startByte, uint32_t endByte, kj::StringPtr message) override {\n    auto& lines = *KJ_REQUIRE_NONNULL(lineBreaks,\n        \"Can't report errors until loadContent() is called.\");\n\n    loader.getErrorReporter().addError(\n        localName, lines.toSourcePos(startByte), lines.toSourcePos(endByte), message);\n  }"
  },
  {
    "function_name": "importRelative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "262-268",
    "snippet": "kj::Maybe<Module&> importRelative(kj::StringPtr importPath) override {\n    if (importPath.size() > 0 && importPath[0] == '/') {\n      return loader.loadModuleFromSearchPath(importPath.slice(1));\n    } else {\n      return loader.loadModule(catPath(localName, importPath), catPath(sourceName, importPath));\n    }\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loader.loadModule",
          "args": [
            "catPath(localName, importPath)",
            "catPath(sourceName, importPath)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "catPath",
          "args": [
            "sourceName",
            "importPath"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "catPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
          "lines": "200-211",
          "snippet": "kj::String catPath(kj::StringPtr base, kj::StringPtr add) {\n  if (add.size() > 0 && add[0] == '/') {\n    return kj::heapString(add);\n  }\n\n  const char* pos = base.end();\n  while (pos > base.begin() && pos[-1] != '/') {\n    --pos;\n  }\n\n  return kj::str(base.slice(0, pos - base.begin()), add);\n}",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/mutex.h>",
            "#include <kj/vector.h>",
            "#include \"parser.h\"",
            "#include \"lexer.h\"",
            "#include \"module-loader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::String catPath(kj::StringPtr base, kj::StringPtr add) {\n  if (add.size() > 0 && add[0] == '/') {\n    return kj::heapString(add);\n  }\n\n  const char* pos = base.end();\n  while (pos > base.begin() && pos[-1] != '/') {\n    --pos;\n  }\n\n  return kj::str(base.slice(0, pos - base.begin()), add);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loader.loadModuleFromSearchPath",
          "args": [
            "importPath.slice(1)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "importPath.slice",
          "args": [
            "1"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "importPath.size",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::Maybe<Module&> importRelative(kj::StringPtr importPath) override {\n    if (importPath.size() > 0 && importPath[0] == '/') {\n      return loader.loadModuleFromSearchPath(importPath.slice(1));\n    } else {\n      return loader.loadModule(catPath(localName, importPath), catPath(sourceName, importPath));\n    }\n  }"
  },
  {
    "function_name": "loadContent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "247-260",
    "snippet": "Orphan<ParsedFile> loadContent(Orphanage orphanage) override {\n    kj::Array<const char> content = mmapForRead(localName);\n\n    lineBreaks = nullptr;  // In case loadContent() is called multiple times.\n    lineBreaks = lineBreaksSpace.construct(content);\n\n    MallocMessageBuilder lexedBuilder;\n    auto statements = lexedBuilder.initRoot<LexedStatements>();\n    lex(content, statements, *this);\n\n    auto parsed = orphanage.newOrphan<ParsedFile>();\n    parseFile(statements.getStatements(), parsed.get(), *this);\n    return parsed;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parseFile",
          "args": [
            "statements.getStatements()",
            "parsed.get()",
            "*this"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsed.get",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "statements.getStatements",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanage.newOrphan<ParsedFile>",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lex",
          "args": [
            "content",
            "statements",
            "*this"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lexedBuilder.initRoot<LexedStatements>",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lineBreaksSpace.construct",
          "args": [
            "content"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "558-560",
          "snippet": "static void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nstatic void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "mmapForRead",
          "args": [
            "localName"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nOrphan<ParsedFile> loadContent(Orphanage orphanage) override {\n    kj::Array<const char> content = mmapForRead(localName);\n\n    lineBreaks = nullptr;  // In case loadContent() is called multiple times.\n    lineBreaks = lineBreaksSpace.construct(content);\n\n    MallocMessageBuilder lexedBuilder;\n    auto statements = lexedBuilder.initRoot<LexedStatements>();\n    lex(content, statements, *this);\n\n    auto parsed = orphanage.newOrphan<ParsedFile>();\n    parseFile(statements.getStatements(), parsed.get(), *this);\n    return parsed;\n  }"
  },
  {
    "function_name": "getSourceName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "243-245",
    "snippet": "kj::StringPtr getSourceName() override {\n    return sourceName;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::StringPtr getSourceName() override {\n    return sourceName;\n  }"
  },
  {
    "function_name": "getLocalName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "239-241",
    "snippet": "kj::StringPtr getLocalName() {\n    return localName;\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::StringPtr getLocalName() {\n    return localName;\n  }"
  },
  {
    "function_name": "ModuleImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "236-237",
    "snippet": "ModuleImpl(ModuleLoader::Impl& loader, kj::String localName, kj::String sourceName)\n      : loader(loader), localName(kj::mv(localName)), sourceName(kj::mv(sourceName)) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sourceName"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "localName"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nModuleImpl(ModuleLoader::Impl& loader, kj::String localName, kj::String sourceName)\n      : loader(loader), localName(kj::mv(localName)), sourceName(kj::mv(sourceName)) {}"
  },
  {
    "function_name": "addImportPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "220-222",
    "snippet": "void addImportPath(kj::String path) {\n    searchPath.add(kj::heapString(kj::mv(path)));\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "searchPath.add",
          "args": [
            "kj::heapString(kj::mv(path))"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "kj::mv(path)"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "path"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nvoid addImportPath(kj::String path) {\n    searchPath.add(kj::heapString(kj::mv(path)));\n  }"
  },
  {
    "function_name": "Impl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "218-218",
    "snippet": "Impl(GlobalErrorReporter& errorReporter): errorReporter(errorReporter) {}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nImpl(GlobalErrorReporter& errorReporter): errorReporter(errorReporter) {}"
  },
  {
    "function_name": "catPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "200-211",
    "snippet": "kj::String catPath(kj::StringPtr base, kj::StringPtr add) {\n  if (add.size() > 0 && add[0] == '/') {\n    return kj::heapString(add);\n  }\n\n  const char* pos = base.end();\n  while (pos > base.begin() && pos[-1] != '/') {\n    --pos;\n  }\n\n  return kj::str(base.slice(0, pos - base.begin()), add);\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "base.slice(0, pos - base.begin())",
            "add"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base.slice",
          "args": [
            "0",
            "pos - base.begin()"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "base.begin",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "base.end",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "add"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add.size",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::String catPath(kj::StringPtr base, kj::StringPtr add) {\n  if (add.size() > 0 && add[0] == '/') {\n    return kj::heapString(add);\n  }\n\n  const char* pos = base.end();\n  while (pos > base.begin() && pos[-1] != '/') {\n    --pos;\n  }\n\n  return kj::str(base.slice(0, pos - base.begin()), add);\n}"
  },
  {
    "function_name": "canonicalizePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "191-198",
    "snippet": "kj::String canonicalizePath(kj::StringPtr path) {\n  KJ_STACK_ARRAY(char, result, path.size() + 1, 128, 512);\n  strcpy(result.begin(), path.begin());\n\n  char* start = path.startsWith(\"/\") ? result.begin() + 1 : result.begin();\n  char* end = canonicalizePath(start);\n  return kj::heapString(result.slice(0, end - result.begin()));\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "result.slice(0, end - result.begin())"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.slice",
          "args": [
            "0",
            "end - result.begin()"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.begin",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canonicalizePath",
          "args": [
            "start"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.startsWith",
          "args": [
            "\"/\""
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "result.begin()",
            "path.begin()"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::String canonicalizePath(kj::StringPtr path) {\n  KJ_STACK_ARRAY(char, result, path.size() + 1, 128, 512);\n  strcpy(result.begin(), path.begin());\n\n  char* start = path.startsWith(\"/\") ? result.begin() + 1 : result.begin();\n  char* end = canonicalizePath(start);\n  return kj::heapString(result.slice(0, end - result.begin()));\n}"
  },
  {
    "function_name": "mmapForRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "62-110",
    "snippet": "kj::Array<const char> mmapForRead(kj::StringPtr filename) {\n  int fd;\n  // We already established that the file exists, so this should not fail.\n  KJ_SYSCALL(fd = open(filename.cStr(), O_RDONLY), filename);\n  kj::AutoCloseFd closer(fd);\n\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n\n  if (S_ISREG(stats.st_mode)) {\n    if (stats.st_size == 0) {\n      // mmap()ing zero bytes will fail.\n      return nullptr;\n    }\n\n    // Regular file.  Just mmap() it.\n#if _WIN32\n    HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n    KJ_ASSERT(handle != INVALID_HANDLE_VALUE);\n    HANDLE mappingHandle = CreateFileMapping(\n        handle, NULL, PAGE_READONLY, 0, stats.st_size, NULL);\n    KJ_ASSERT(mappingHandle != INVALID_HANDLE_VALUE);\n    KJ_DEFER(KJ_ASSERT(CloseHandle(mappingHandle)));\n    const void* mapping = MapViewOfFile(mappingHandle, FILE_MAP_READ, 0, 0, stats.st_size);\n#else  // _WIN32\n    const void* mapping = mmap(NULL, stats.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    if (mapping == MAP_FAILED) {\n      KJ_FAIL_SYSCALL(\"mmap\", errno, filename);\n    }\n#endif  // _WIN32, else\n\n    return kj::Array<const char>(\n        reinterpret_cast<const char*>(mapping), stats.st_size, mmapDisposer);\n  } else {\n    // This could be a stream of some sort, like a pipe.  Fall back to read().\n    // TODO(cleanup):  This does a lot of copies.  Not sure I care.\n    kj::Vector<char> data(8192);\n\n    char buffer[4096];\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = read(fd, buffer, sizeof(buffer)));\n      if (n == 0) break;\n      data.addAll(buffer, buffer + n);\n    }\n\n    return data.releaseAsArray();\n  }\n}",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data.releaseAsArray",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "releaseAsArray",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "66-72",
          "snippet": "inline Array<T> releaseAsArray() {\n    // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n    if (!builder.isFull()) {\n      setCapacity(size());\n    }\n    return builder.finish();\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline Array<T> releaseAsArray() {\n      // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n      if (!builder.isFull()) {\n        setCapacity(size());\n      }\n      return builder.finish();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.addAll",
          "args": [
            "buffer",
            "buffer + n"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "81-85",
          "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "n = read(fd, buffer, sizeof(buffer))"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncMessageReader::read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "66-81",
          "snippet": "kj::Promise<bool> AsyncMessageReader::read(kj::AsyncInputStream& inputStream,\n                                           kj::ArrayPtr<word> scratchSpace) {\n  return inputStream.tryRead(firstWord, sizeof(firstWord), sizeof(firstWord))\n      .then([this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  });\n}",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nkj::Promise<bool> AsyncMessageReader::read(kj::AsyncInputStream& inputStream,\n                                           kj::ArrayPtr<word> scratchSpace) {\n  return inputStream.tryRead(firstWord, sizeof(firstWord), sizeof(firstWord))\n      .then([this,&inputStream,scratchSpace](size_t n) mutable -> kj::Promise<bool> {\n    if (n == 0) {\n      return false;\n    } else if (n < sizeof(firstWord)) {\n      // EOF in first word.\n      KJ_FAIL_REQUIRE(\"Premature EOF.\") {\n        return false;\n      }\n    }\n\n    return readAfterFirstWord(inputStream, scratchSpace).then([]() { return true; });\n  });\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::Array<const char>",
          "args": [
            "reinterpret_cast<const char*>(mapping)",
            "stats.st_size",
            "mmapDisposer"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "Array",
          "container": "Array",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "146-147",
          "snippet": "inline Array(T* firstElement, size_t size, const ArrayDisposer& disposer)\n      : ptr(firstElement), size_(size), disposer(&disposer) {}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArray {\n  inline Array(T* firstElement, size_t size, const ArrayDisposer& disposer)\n        : ptr(firstElement), size_(size), disposer(&disposer) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const char*>",
          "args": [
            "mapping"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"mmap\"",
            "errno",
            "filename"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmap",
          "args": [
            "NULL",
            "stats.st_size",
            "PROT_READ",
            "MAP_SHARED",
            "fd",
            "0"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MapViewOfFile",
          "args": [
            "mappingHandle",
            "FILE_MAP_READ",
            "0",
            "0",
            "stats.st_size"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "KJ_ASSERT(CloseHandle(mappingHandle))"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "CloseHandle(mappingHandle)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "mappingHandle"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "mappingHandle != INVALID_HANDLE_VALUE"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileMapping",
          "args": [
            "handle",
            "NULL",
            "PAGE_READONLY",
            "0",
            "stats.st_size",
            "NULL"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "handle != INVALID_HANDLE_VALUE"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<HANDLE>",
          "args": [
            "_get_osfhandle(fd)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_get_osfhandle",
          "args": [
            "fd"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "stats.st_mode"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fstat(fd, &stats)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&stats"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fd = open(filename.cStr(), O_RDONLY)",
            "filename"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename.cStr()",
            "O_RDONLY"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.cStr",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nkj::Array<const char> mmapForRead(kj::StringPtr filename) {\n  int fd;\n  // We already established that the file exists, so this should not fail.\n  KJ_SYSCALL(fd = open(filename.cStr(), O_RDONLY), filename);\n  kj::AutoCloseFd closer(fd);\n\n  struct stat stats;\n  KJ_SYSCALL(fstat(fd, &stats));\n\n  if (S_ISREG(stats.st_mode)) {\n    if (stats.st_size == 0) {\n      // mmap()ing zero bytes will fail.\n      return nullptr;\n    }\n\n    // Regular file.  Just mmap() it.\n#if _WIN32\n    HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd));\n    KJ_ASSERT(handle != INVALID_HANDLE_VALUE);\n    HANDLE mappingHandle = CreateFileMapping(\n        handle, NULL, PAGE_READONLY, 0, stats.st_size, NULL);\n    KJ_ASSERT(mappingHandle != INVALID_HANDLE_VALUE);\n    KJ_DEFER(KJ_ASSERT(CloseHandle(mappingHandle)));\n    const void* mapping = MapViewOfFile(mappingHandle, FILE_MAP_READ, 0, 0, stats.st_size);\n#else  // _WIN32\n    const void* mapping = mmap(NULL, stats.st_size, PROT_READ, MAP_SHARED, fd, 0);\n    if (mapping == MAP_FAILED) {\n      KJ_FAIL_SYSCALL(\"mmap\", errno, filename);\n    }\n#endif  // _WIN32, else\n\n    return kj::Array<const char>(\n        reinterpret_cast<const char*>(mapping), stats.st_size, mmapDisposer);\n  } else {\n    // This could be a stream of some sort, like a pipe.  Fall back to read().\n    // TODO(cleanup):  This does a lot of copies.  Not sure I care.\n    kj::Vector<char> data(8192);\n\n    char buffer[4096];\n    for (;;) {\n      ssize_t n;\n      KJ_SYSCALL(n = read(fd, buffer, sizeof(buffer)));\n      if (n == 0) break;\n      data.addAll(buffer, buffer + n);\n    }\n\n    return data.releaseAsArray();\n  }\n}"
  },
  {
    "function_name": "disposeImpl",
    "container": "MmapDisposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/module-loader.c++",
    "lines": "50-57",
    "snippet": "void disposeImpl(void* firstElement, size_t elementSize, size_t elementCount,\n                   size_t capacity, void (*destroyElement)(void*)) const {\n#if _WIN32\n    KJ_ASSERT(UnmapViewOfFile(firstElement));\n#else\n    munmap(firstElement, elementSize * elementCount);\n#endif\n  }",
    "includes": [
      "#include <sys/mman.h>",
      "#include <windows.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <map>",
      "#include <capnp/message.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include <kj/mutex.h>",
      "#include <kj/vector.h>",
      "#include \"parser.h\"",
      "#include \"lexer.h\"",
      "#include \"module-loader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "munmap",
          "args": [
            "firstElement",
            "elementSize * elementCount"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "UnmapViewOfFile(firstElement)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnmapViewOfFile",
          "args": [
            "firstElement"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <map>\n#include <capnp/message.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/mutex.h>\n#include <kj/vector.h>\n#include \"parser.h\"\n#include \"lexer.h\"\n#include \"module-loader.h\"\n\nMmapDisposer {\n  void disposeImpl(void* firstElement, size_t elementSize, size_t elementCount,\n                     size_t capacity, void (*destroyElement)(void*)) const {\n  #if _WIN32\n      KJ_ASSERT(UnmapViewOfFile(firstElement));\n  #else\n      munmap(firstElement, elementSize * elementCount);\n  #endif\n    }\n}"
  }
]