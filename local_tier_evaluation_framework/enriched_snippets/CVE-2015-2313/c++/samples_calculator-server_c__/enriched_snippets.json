[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "190-215",
    "snippet": "int main(int argc, const char* argv[]) {\n  if (argc != 2) {\n    std::cerr << \"usage: \" << argv[0] << \" ADDRESS[:PORT]\\n\"\n        \"Runs the server bound to the given address/port.\\n\"\n        \"ADDRESS may be '*' to bind to all local addresses.\\n\"\n        \":PORT may be omitted to choose a port automatically.\" << std::endl;\n    return 1;\n  }\n\n  // Set up a server.\n  capnp::EzRpcServer server(kj::heap<CalculatorImpl>(), argv[1]);\n\n  // Write the port number to stdout, in case it was chosen automatically.\n  auto& waitScope = server.getWaitScope();\n  uint port = server.getPort().wait(waitScope);\n  if (port == 0) {\n    // The address format \"unix:/path/to/socket\" opens a unix domain socket,\n    // in which case the port will be zero.\n    std::cout << \"Listening on Unix socket...\" << std::endl;\n  } else {\n    std::cout << \"Listening on port \" << port << \"...\" << std::endl;\n  }\n\n  // Run forever, accepting connections and handling requests.\n  kj::NEVER_DONE.wait(waitScope);\n}",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::NEVER_DONE.wait",
          "args": [
            "waitScope"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getPort",
          "args": [
            "waitScope"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getPort",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "getPort",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "863-865",
          "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server.getWaitScope",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nint main(int argc, const char* argv[]) {\n  if (argc != 2) {\n    std::cerr << \"usage: \" << argv[0] << \" ADDRESS[:PORT]\\n\"\n        \"Runs the server bound to the given address/port.\\n\"\n        \"ADDRESS may be '*' to bind to all local addresses.\\n\"\n        \":PORT may be omitted to choose a port automatically.\" << std::endl;\n    return 1;\n  }\n\n  // Set up a server.\n  capnp::EzRpcServer server(kj::heap<CalculatorImpl>(), argv[1]);\n\n  // Write the port number to stdout, in case it was chosen automatically.\n  auto& waitScope = server.getWaitScope();\n  uint port = server.getPort().wait(waitScope);\n  if (port == 0) {\n    // The address format \"unix:/path/to/socket\" opens a unix domain socket,\n    // in which case the port will be zero.\n    std::cout << \"Listening on Unix socket...\" << std::endl;\n  } else {\n    std::cout << \"Listening on port \" << port << \"...\" << std::endl;\n  }\n\n  // Run forever, accepting connections and handling requests.\n  kj::NEVER_DONE.wait(waitScope);\n}"
  },
  {
    "function_name": "getOperator",
    "container": "CalculatorImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "183-187",
    "snippet": "kj::Promise<void> getOperator(GetOperatorContext context) override {\n    context.getResults().setFunc(kj::heap<OperatorImpl>(\n        context.getParams().getOp()));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<OperatorImpl>(\n        context.getParams().getOp())"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<OperatorImpl>",
          "args": [
            "context.getParams().getOp()"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nCalculatorImpl {\n  kj::Promise<void> getOperator(GetOperatorContext context) override {\n      context.getResults().setFunc(kj::heap<OperatorImpl>(\n          context.getParams().getOp()));\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "defFunction",
    "container": "CalculatorImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "176-181",
    "snippet": "kj::Promise<void> defFunction(DefFunctionContext context) override {\n    auto params = context.getParams();\n    context.getResults().setFunc(kj::heap<FunctionImpl>(\n        params.getParamCount(), params.getBody()));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<FunctionImpl>(\n        params.getParamCount(), params.getBody())"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<FunctionImpl>",
          "args": [
            "params.getParamCount()",
            "params.getBody()"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.getBody",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "params.getParamCount",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nCalculatorImpl {\n  kj::Promise<void> defFunction(DefFunctionContext context) override {\n      auto params = context.getParams();\n      context.getResults().setFunc(kj::heap<FunctionImpl>(\n          params.getParamCount(), params.getBody()));\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "evaluate",
    "container": "CalculatorImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "169-174",
    "snippet": "kj::Promise<void> evaluate(EvaluateContext context) override {\n    return evaluateImpl(context.getParams().getExpression())\n        .then([context](double value) mutable {\n      context.getResults().setValue(kj::heap<ValueImpl>(value));\n    });\n  }",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evaluateImpl",
          "args": [
            "[context](double value) mutable {\n      context.getResults().setValue(kj::heap<ValueImpl>(value));\n    }"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "kj::heap<ValueImpl>(value)"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<ValueImpl>",
          "args": [
            "value"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "evaluateImpl",
          "args": [
            "context.getParams().getExpression()"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nCalculatorImpl {\n  kj::Promise<void> evaluate(EvaluateContext context) override {\n      return evaluateImpl(context.getParams().getExpression())\n          .then([context](double value) mutable {\n        context.getResults().setValue(kj::heap<ValueImpl>(value));\n      });\n    }\n}"
  },
  {
    "function_name": "call",
    "container": "OperatorImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "143-159",
    "snippet": "kj::Promise<void> call(CallContext context) {\n    auto params = context.getParams().getParams();\n    KJ_REQUIRE(params.size() == 2, \"Wrong number of parameters.\");\n\n    double result;\n    switch (op) {\n      case Calculator::Operator::ADD:     result = params[0] + params[1]; break;\n      case Calculator::Operator::SUBTRACT:result = params[0] - params[1]; break;\n      case Calculator::Operator::MULTIPLY:result = params[0] * params[1]; break;\n      case Calculator::Operator::DIVIDE:  result = params[0] / params[1]; break;\n      default:\n        KJ_FAIL_REQUIRE(\"Unknown operator.\");\n    }\n\n    context.getResults().setValue(result);\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "result"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Unknown operator.\""
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "params.size() == 2",
            "\"Wrong number of parameters.\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nOperatorImpl {\n  kj::Promise<void> call(CallContext context) {\n      auto params = context.getParams().getParams();\n      KJ_REQUIRE(params.size() == 2, \"Wrong number of parameters.\");\n  \n      double result;\n      switch (op) {\n        case Calculator::Operator::ADD:     result = params[0] + params[1]; break;\n        case Calculator::Operator::SUBTRACT:result = params[0] - params[1]; break;\n        case Calculator::Operator::MULTIPLY:result = params[0] * params[1]; break;\n        case Calculator::Operator::DIVIDE:  result = params[0] / params[1]; break;\n        default:\n          KJ_FAIL_REQUIRE(\"Unknown operator.\");\n      }\n  \n      context.getResults().setValue(result);\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "OperatorImpl",
    "container": "OperatorImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "141-141",
    "snippet": "OperatorImpl(Calculator::Operator op): op(op) {}",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nOperatorImpl {\n  OperatorImpl(Calculator::Operator op): op(op) {}\n}"
  },
  {
    "function_name": "call",
    "container": "FunctionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "118-126",
    "snippet": "kj::Promise<void> call(CallContext context) {\n    auto params = context.getParams().getParams();\n    KJ_REQUIRE(params.size() == paramCount, \"Wrong number of parameters.\");\n\n    return evaluateImpl(body.getRoot<Calculator::Expression>(), params)\n        .then([context](double value) mutable {\n      context.getResults().setValue(value);\n    });\n  }",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evaluateImpl",
          "args": [
            "[context](double value) mutable {\n      context.getResults().setValue(value);\n    }"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "value"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "evaluateImpl",
          "args": [
            "body.getRoot<Calculator::Expression>()",
            "params"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "body.getRoot<Calculator::Expression>",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "params.size() == paramCount",
            "\"Wrong number of parameters.\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nFunctionImpl {\n  kj::Promise<void> call(CallContext context) {\n      auto params = context.getParams().getParams();\n      KJ_REQUIRE(params.size() == paramCount, \"Wrong number of parameters.\");\n  \n      return evaluateImpl(body.getRoot<Calculator::Expression>(), params)\n          .then([context](double value) mutable {\n        context.getResults().setValue(value);\n      });\n    }\n}"
  },
  {
    "function_name": "FunctionImpl",
    "container": "FunctionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "113-116",
    "snippet": "FunctionImpl(uint paramCount, Calculator::Expression::Reader body)\n      : paramCount(paramCount) {\n    this->body.setRoot(body);\n  }",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->body.setRoot",
          "args": [
            "body"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nFunctionImpl {\n  FunctionImpl(uint paramCount, Calculator::Expression::Reader body)\n        : paramCount(paramCount) {\n      this->body.setRoot(body);\n    }\n}"
  },
  {
    "function_name": "read",
    "container": "ValueImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "99-102",
    "snippet": "kj::Promise<void> read(ReadContext context) {\n    context.getResults().setValue(value);\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "value"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nValueImpl {\n  kj::Promise<void> read(ReadContext context) {\n      context.getResults().setValue(value);\n      return kj::READY_NOW;\n    }\n}"
  },
  {
    "function_name": "ValueImpl",
    "container": "ValueImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "97-97",
    "snippet": "ValueImpl(double value): value(value) {}",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nValueImpl {\n  ValueImpl(double value): value(value) {}\n}"
  },
  {
    "function_name": "evaluateImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "41-91",
    "snippet": "kj::Promise<double> evaluateImpl(\n    Calculator::Expression::Reader expression,\n    capnp::List<double>::Reader params = capnp::List<double>::Reader()) {\n  // Implementation of CalculatorImpl::evaluate(), also shared by\n  // FunctionImpl::call().  In the latter case, `params` are the parameter\n  // values passed to the function; in the former case, `params` is just an\n  // empty list.\n\n  switch (expression.which()) {\n    case Calculator::Expression::LITERAL:\n      return expression.getLiteral();\n\n    case Calculator::Expression::PREVIOUS_RESULT:\n      return readValue(expression.getPreviousResult());\n\n    case Calculator::Expression::PARAMETER: {\n      KJ_REQUIRE(expression.getParameter() < params.size(),\n                 \"Parameter index out-of-range.\");\n      return params[expression.getParameter()];\n    }\n\n    case Calculator::Expression::CALL: {\n      auto call = expression.getCall();\n      auto func = call.getFunction();\n\n      // Evaluate each parameter.\n      kj::Array<kj::Promise<double>> paramPromises =\n          KJ_MAP(param, call.getParams()) {\n            return evaluateImpl(param, params);\n          };\n\n      // Join the array of promises into a promise for an array.\n      kj::Promise<kj::Array<double>> joinedParams =\n          kj::joinPromises(kj::mv(paramPromises));\n\n      // When the parameters are complete, call the function.\n      return joinedParams.then([func](kj::Array<double>&& paramValues) mutable {\n        auto request = func.callRequest();\n        request.setParams(paramValues);\n        return request.send().then(\n            [](capnp::Response<Calculator::Function::CallResults>&& result) {\n          return result.getValue();\n        });\n      });\n    }\n\n    default:\n      // Throw an exception.\n      KJ_FAIL_REQUIRE(\"Unknown expression type.\");\n  }\n}",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Unknown expression type.\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "joinedParams.then",
          "args": [
            "[func](kj::Array<double>&& paramValues) mutable {\n        auto request = func.callRequest();\n        request.setParams(paramValues);\n        return request.send().then(\n            [](capnp::Response<Calculator::Function::CallResults>&& result) {\n          return result.getValue();\n        });\n      }"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "[](capnp::Response<Calculator::Function::CallResults>&& result) {\n          return result.getValue();\n        }"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.getValue",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setParams",
          "args": [
            "paramValues"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func.callRequest",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::joinPromises",
          "args": [
            "kj::mv(paramPromises)"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "joinPromises",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "814-818",
          "snippet": "Promise<Array<T>> joinPromises(Array<Promise<T>>&& promises) {\n  return Promise<Array<T>>(false, kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size())));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "Promise<Array<T>> joinPromises(Array<Promise<T>>&& promises) {\n  return Promise<Array<T>>(false, kj::heap<_::ArrayJoinPromiseNode<T>>(\n      KJ_MAP(p, promises) { return kj::mv(p.node); },\n      heapArray<_::ExceptionOr<T>>(promises.size())));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paramPromises"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evaluateImpl",
          "args": [
            "param",
            "params"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "param",
            "call.getParams()"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getParams",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call.getFunction",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expression.getCall",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "getCall",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1325-1327",
          "snippet": "inline rpc::Call::Builder getCall() {\n      return callBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline rpc::Call::Builder getCall() {\n        return callBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expression.getParameter",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "expression.getParameter() < params.size()",
            "\"Parameter index out-of-range.\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "expression.getParameter",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readValue",
          "args": [
            "expression.getPreviousResult()"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expression.getPreviousResult",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expression.getLiteral",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expression.which",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capnp::List<double>::Reader",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nkj::Promise<double> evaluateImpl(\n    Calculator::Expression::Reader expression,\n    capnp::List<double>::Reader params = capnp::List<double>::Reader()) {\n  // Implementation of CalculatorImpl::evaluate(), also shared by\n  // FunctionImpl::call().  In the latter case, `params` are the parameter\n  // values passed to the function; in the former case, `params` is just an\n  // empty list.\n\n  switch (expression.which()) {\n    case Calculator::Expression::LITERAL:\n      return expression.getLiteral();\n\n    case Calculator::Expression::PREVIOUS_RESULT:\n      return readValue(expression.getPreviousResult());\n\n    case Calculator::Expression::PARAMETER: {\n      KJ_REQUIRE(expression.getParameter() < params.size(),\n                 \"Parameter index out-of-range.\");\n      return params[expression.getParameter()];\n    }\n\n    case Calculator::Expression::CALL: {\n      auto call = expression.getCall();\n      auto func = call.getFunction();\n\n      // Evaluate each parameter.\n      kj::Array<kj::Promise<double>> paramPromises =\n          KJ_MAP(param, call.getParams()) {\n            return evaluateImpl(param, params);\n          };\n\n      // Join the array of promises into a promise for an array.\n      kj::Promise<kj::Array<double>> joinedParams =\n          kj::joinPromises(kj::mv(paramPromises));\n\n      // When the parameters are complete, call the function.\n      return joinedParams.then([func](kj::Array<double>&& paramValues) mutable {\n        auto request = func.callRequest();\n        request.setParams(paramValues);\n        return request.send().then(\n            [](capnp::Response<Calculator::Function::CallResults>&& result) {\n          return result.getValue();\n        });\n      });\n    }\n\n    default:\n      // Throw an exception.\n      KJ_FAIL_REQUIRE(\"Unknown expression type.\");\n  }\n}"
  },
  {
    "function_name": "readValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-server.c++",
    "lines": "30-39",
    "snippet": "kj::Promise<double> readValue(Calculator::Value::Client value) {\n  // Helper function to asynchronously call read() on a Calculator::Value and\n  // return a promise for the result.  (In the future, the generated code might\n  // include something like this automatically.)\n\n  return value.readRequest().send()\n      .then([](capnp::Response<Calculator::Value::ReadResults> result) {\n    return result.getValue();\n  });\n}",
    "includes": [
      "#include <iostream>",
      "#include <capnp/message.h>",
      "#include <capnp/ez-rpc.h>",
      "#include <kj/debug.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value.readRequest",
          "args": [
            "[](capnp::Response<Calculator::Value::ReadResults> result) {\n    return result.getValue();\n  }"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.getValue",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.readRequest",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.readRequest",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <capnp/message.h>\n#include <capnp/ez-rpc.h>\n#include <kj/debug.h>\n#include \"calculator.capnp.h\"\n\nkj::Promise<double> readValue(Calculator::Value::Client value) {\n  // Helper function to asynchronously call read() on a Calculator::Value and\n  // return a promise for the result.  (In the future, the generated code might\n  // include something like this automatically.)\n\n  return value.readRequest().send()\n      .then([](capnp::Response<Calculator::Value::ReadResults> result) {\n    return result.getValue();\n  });\n}"
  }
]