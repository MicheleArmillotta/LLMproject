[
  {
    "function_name": "newBrokenRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "628-633",
    "snippet": "Request<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "hook"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook->message.getRoot<AnyPointer>",
          "args": [],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<BrokenRequest>",
          "args": [
            "kj::mv(reason)",
            "sizeHint"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reason"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nRequest<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}"
  },
  {
    "function_name": "newBrokenPipeline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "624-626",
    "snippet": "kj::Own<PipelineHook> newBrokenPipeline(kj::Exception&& reason) {\n  return kj::refcounted<BrokenPipeline>(kj::mv(reason));\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<BrokenPipeline>",
          "args": [
            "kj::mv(reason)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reason"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<PipelineHook> newBrokenPipeline(kj::Exception&& reason) {\n  return kj::refcounted<BrokenPipeline>(kj::mv(reason));\n}"
  },
  {
    "function_name": "newBrokenCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "620-622",
    "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<BrokenClient>",
          "args": [
            "kj::mv(reason)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reason"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
  },
  {
    "function_name": "newBrokenCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "616-618",
    "snippet": "kj::Own<ClientHook> newBrokenCap(kj::StringPtr reason) {\n  return kj::refcounted<BrokenClient>(reason);\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<BrokenClient>",
          "args": [
            "reason"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::StringPtr reason) {\n  return kj::refcounted<BrokenClient>(reason);\n}"
  },
  {
    "function_name": "BrokenPipeline::getPipelinedCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "610-612",
    "snippet": "kj::Own<ClientHook> BrokenPipeline::getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) {\n  return kj::refcounted<BrokenClient>(exception);\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<BrokenClient>",
          "args": [
            "exception"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> BrokenPipeline::getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) {\n  return kj::refcounted<BrokenClient>(exception);\n}"
  },
  {
    "function_name": "addRef",
    "container": "BrokenClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "598-600",
    "snippet": "kj::Own<ClientHook> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "whenMoreResolved",
    "container": "BrokenClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "594-596",
    "snippet": "kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n    return kj::Promise<kj::Own<ClientHook>>(kj::cp(exception));\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::Promise<kj::Own<ClientHook>>",
          "args": [
            "kj::cp(exception)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "exception"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n      return kj::Promise<kj::Own<ClientHook>>(kj::cp(exception));\n    }\n}"
  },
  {
    "function_name": "getResolved",
    "container": "BrokenClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "590-592",
    "snippet": "kj::Maybe<ClientHook&> getResolved() {\n    return nullptr;\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  kj::Maybe<ClientHook&> getResolved() {\n      return nullptr;\n    }\n}"
  },
  {
    "function_name": "call",
    "container": "BrokenClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "585-588",
    "snippet": "VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                              kj::Own<CallContextHook>&& context) override {\n    return VoidPromiseAndPipeline { kj::cp(exception), kj::refcounted<BrokenPipeline>(exception) };\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<BrokenPipeline>",
          "args": [
            "exception"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "exception"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                kj::Own<CallContextHook>&& context) override {\n      return VoidPromiseAndPipeline { kj::cp(exception), kj::refcounted<BrokenPipeline>(exception) };\n    }\n}"
  },
  {
    "function_name": "newCall",
    "container": "BrokenClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "580-583",
    "snippet": "Request<AnyPointer, AnyPointer> newCall(\n      uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n    return newBrokenRequest(kj::cp(exception), sizeHint);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newBrokenRequest",
          "args": [
            "kj::cp(exception)",
            "sizeHint"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "628-633",
          "snippet": "Request<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nRequest<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "exception"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  Request<AnyPointer, AnyPointer> newCall(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n      return newBrokenRequest(kj::cp(exception), sizeHint);\n    }\n}"
  },
  {
    "function_name": "BrokenClient",
    "container": "BrokenClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "577-578",
    "snippet": "BrokenClient(const kj::StringPtr description)\n      : exception(kj::Exception::Type::FAILED, \"\", 0, kj::str(description)) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "description"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  BrokenClient(const kj::StringPtr description)\n        : exception(kj::Exception::Type::FAILED, \"\", 0, kj::str(description)) {}\n}"
  },
  {
    "function_name": "BrokenClient",
    "container": "BrokenClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "576-576",
    "snippet": "BrokenClient(const kj::Exception& exception): exception(exception) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  BrokenClient(const kj::Exception& exception): exception(exception) {}\n}"
  },
  {
    "function_name": "send",
    "container": "BrokenRequest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "561-564",
    "snippet": "RemotePromise<AnyPointer> send() override {\n    return RemotePromise<AnyPointer>(kj::cp(exception),\n        AnyPointer::Pipeline(kj::refcounted<BrokenPipeline>(exception)));\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RemotePromise<AnyPointer>",
          "args": [
            "kj::cp(exception)",
            "AnyPointer::Pipeline(kj::refcounted<BrokenPipeline>(exception))"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "RemotePromise",
          "container": "RemotePromise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "53-55",
          "snippet": "inline RemotePromise(kj::Promise<Response<T>>&& promise, typename T::Pipeline&& pipeline)\n      : kj::Promise<Response<T>>(kj::mv(promise)),\n        T::Pipeline(kj::mv(pipeline)) {}",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRemotePromise {\n  inline RemotePromise(kj::Promise<Response<T>>&& promise, typename T::Pipeline&& pipeline)\n        : kj::Promise<Response<T>>(kj::mv(promise)),\n          T::Pipeline(kj::mv(pipeline)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AnyPointer::Pipeline",
          "args": [
            "kj::refcounted<BrokenPipeline>(exception)"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<BrokenPipeline>",
          "args": [
            "exception"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::cp",
          "args": [
            "exception"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "cp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "461-461",
          "snippet": "constexpr T cp(const T& t) noexcept { return t; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr T cp(const T& t) noexcept { return t; }"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenRequest {\n  RemotePromise<AnyPointer> send() override {\n      return RemotePromise<AnyPointer>(kj::cp(exception),\n          AnyPointer::Pipeline(kj::refcounted<BrokenPipeline>(exception)));\n    }\n}"
  },
  {
    "function_name": "BrokenRequest",
    "container": "BrokenRequest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "558-559",
    "snippet": "BrokenRequest(const kj::Exception& exception, kj::Maybe<MessageSize> sizeHint)\n      : exception(exception), message(firstSegmentSize(sizeHint)) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "firstSegmentSize",
          "args": [
            "sizeHint"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenRequest {\n  BrokenRequest(const kj::Exception& exception, kj::Maybe<MessageSize> sizeHint)\n        : exception(exception), message(firstSegmentSize(sizeHint)) {}\n}"
  },
  {
    "function_name": "addRef",
    "container": "BrokenPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "546-548",
    "snippet": "kj::Own<PipelineHook> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenPipeline {\n  kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "BrokenPipeline",
    "container": "BrokenPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "544-544",
    "snippet": "BrokenPipeline(const kj::Exception& exception): exception(exception) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenPipeline {\n  BrokenPipeline(const kj::Exception& exception): exception(exception) {}\n}"
  },
  {
    "function_name": "newLocalPromiseClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "534-536",
    "snippet": "kj::Own<ClientHook> newLocalPromiseClient(kj::Promise<kj::Own<ClientHook>>&& promise) {\n  return kj::refcounted<QueuedClient>(kj::mv(promise));\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<QueuedClient>",
          "args": [
            "kj::mv(promise)"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newLocalPromiseClient(kj::Promise<kj::Own<ClientHook>>&& promise) {\n  return kj::refcounted<QueuedClient>(kj::mv(promise));\n}"
  },
  {
    "function_name": "Capability::Client::makeLocalClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "530-532",
    "snippet": "kj::Own<ClientHook> Capability::Client::makeLocalClient(kj::Own<Capability::Server>&& server) {\n  return kj::refcounted<LocalClient>(kj::mv(server));\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<LocalClient>",
          "args": [
            "kj::mv(server)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "server"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> Capability::Client::makeLocalClient(kj::Own<Capability::Server>&& server) {\n  return kj::refcounted<LocalClient>(kj::mv(server));\n}"
  },
  {
    "function_name": "addRef",
    "container": "LocalClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "517-519",
    "snippet": "kj::Own<ClientHook> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalClient {\n  kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "whenMoreResolved",
    "container": "LocalClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "513-515",
    "snippet": "kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n    return nullptr;\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalClient {\n  kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n      return nullptr;\n    }\n}"
  },
  {
    "function_name": "getResolved",
    "container": "LocalClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "509-511",
    "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n    return nullptr;\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalClient {\n  kj::Maybe<ClientHook&> getResolved() override {\n      return nullptr;\n    }\n}"
  },
  {
    "function_name": "call",
    "container": "LocalClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "471-507",
    "snippet": "VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                              kj::Own<CallContextHook>&& context) override {\n    auto contextPtr = context.get();\n\n    // We don't want to actually dispatch the call synchronously, because we don't want the callee\n    // to have any side effects before the promise is returned to the caller.  This helps avoid\n    // race conditions.\n    //\n    // So, we do an evalLater() here.\n    //\n    // Note also that QueuedClient depends on this evalLater() to ensure that pipelined calls don't\n    // complete before 'whenMoreResolved()' promises resolve.\n    auto promise = kj::evalLater([this,interfaceId,methodId,contextPtr]() {\n      return server->dispatchCall(interfaceId, methodId,\n                                  CallContext<AnyPointer, AnyPointer>(*contextPtr));\n    }).attach(kj::addRef(*this));\n\n    // We have to fork this promise for the pipeline to receive a copy of the answer.\n    auto forked = promise.fork();\n\n    auto pipelinePromise = forked.addBranch().then(kj::mvCapture(context->addRef(),\n        [=](kj::Own<CallContextHook>&& context) -> kj::Own<PipelineHook> {\n          context->releaseParams();\n          return kj::refcounted<LocalPipeline>(kj::mv(context));\n        }));\n\n    auto tailPipelinePromise = context->onTailCall().then([](AnyPointer::Pipeline&& pipeline) {\n      return kj::mv(pipeline.hook);\n    });\n\n    pipelinePromise = pipelinePromise.exclusiveJoin(kj::mv(tailPipelinePromise));\n\n    auto completionPromise = forked.addBranch().attach(kj::mv(context));\n\n    return VoidPromiseAndPipeline { kj::mv(completionPromise),\n        kj::refcounted<QueuedPipeline>(kj::mv(pipelinePromise)) };\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<QueuedPipeline>",
          "args": [
            "kj::mv(pipelinePromise)"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipelinePromise"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "completionPromise"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [
            "kj::mv(context)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "context"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipelinePromise.exclusiveJoin",
          "args": [
            "kj::mv(tailPipelinePromise)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "tailPipelinePromise"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->onTailCall",
          "args": [
            "[](AnyPointer::Pipeline&& pipeline) {\n      return kj::mv(pipeline.hook);\n    }"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipeline.hook"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->onTailCall",
          "args": [],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "onTailCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "180-184",
          "snippet": "kj::Promise<AnyPointer::Pipeline> onTailCall() override {\n    auto paf = kj::newPromiseAndFulfiller<AnyPointer::Pipeline>();\n    tailCallPipelineFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;\n\nkj::Promise<AnyPointer::Pipeline> onTailCall() override {\n    auto paf = kj::newPromiseAndFulfiller<AnyPointer::Pipeline>();\n    tailCallPipelineFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [
            "kj::mvCapture(context->addRef(),\n        [=](kj::Own<CallContextHook>&& context) -> kj::Own<PipelineHook> {\n          context->releaseParams();\n          return kj::refcounted<LocalPipeline>(kj::mv(context));\n        })"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "context->addRef()",
            "[=](kj::Own<CallContextHook>&& context) -> kj::Own<PipelineHook> {\n          context->releaseParams();\n          return kj::refcounted<LocalPipeline>(kj::mv(context));\n        }"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<LocalPipeline>",
          "args": [
            "kj::mv(context)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "context"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->releaseParams",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->addRef",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "BrokenClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "598-600",
          "snippet": "kj::Own<ClientHook> addRef() override {\n    return kj::addRef(*this);\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.fork",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::evalLater",
          "args": [
            "kj::addRef(*this)"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->dispatchCall",
          "args": [
            "interfaceId",
            "methodId",
            "CallContext<AnyPointer, AnyPointer>(*contextPtr)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallContext<AnyPointer, AnyPointer>",
          "args": [
            "*contextPtr"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "CallContext<Params, Results>::CallContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "641-641",
          "snippet": "inline CallContext<Params, Results>::CallContext(CallContextHook& hook): hook(&hook) {}",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\ninline CallContext<Params, Results>::CallContext(CallContextHook& hook): hook(&hook) {}"
        }
      },
      {
        "call_info": {
          "callee": "context.get",
          "args": [],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalClient {\n  VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                kj::Own<CallContextHook>&& context) override {\n      auto contextPtr = context.get();\n  \n      // We don't want to actually dispatch the call synchronously, because we don't want the callee\n      // to have any side effects before the promise is returned to the caller.  This helps avoid\n      // race conditions.\n      //\n      // So, we do an evalLater() here.\n      //\n      // Note also that QueuedClient depends on this evalLater() to ensure that pipelined calls don't\n      // complete before 'whenMoreResolved()' promises resolve.\n      auto promise = kj::evalLater([this,interfaceId,methodId,contextPtr]() {\n        return server->dispatchCall(interfaceId, methodId,\n                                    CallContext<AnyPointer, AnyPointer>(*contextPtr));\n      }).attach(kj::addRef(*this));\n  \n      // We have to fork this promise for the pipeline to receive a copy of the answer.\n      auto forked = promise.fork();\n  \n      auto pipelinePromise = forked.addBranch().then(kj::mvCapture(context->addRef(),\n          [=](kj::Own<CallContextHook>&& context) -> kj::Own<PipelineHook> {\n            context->releaseParams();\n            return kj::refcounted<LocalPipeline>(kj::mv(context));\n          }));\n  \n      auto tailPipelinePromise = context->onTailCall().then([](AnyPointer::Pipeline&& pipeline) {\n        return kj::mv(pipeline.hook);\n      });\n  \n      pipelinePromise = pipelinePromise.exclusiveJoin(kj::mv(tailPipelinePromise));\n  \n      auto completionPromise = forked.addBranch().attach(kj::mv(context));\n  \n      return VoidPromiseAndPipeline { kj::mv(completionPromise),\n          kj::refcounted<QueuedPipeline>(kj::mv(pipelinePromise)) };\n    }\n}"
  },
  {
    "function_name": "newCall",
    "container": "LocalClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "463-469",
    "snippet": "Request<AnyPointer, AnyPointer> newCall(\n      uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n    auto hook = kj::heap<LocalRequest>(\n        interfaceId, methodId, sizeHint, kj::addRef(*this));\n    auto root = hook->message->getRoot<AnyPointer>();\n    return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Request<AnyPointer, AnyPointer>",
          "args": [
            "root",
            "kj::mv(hook)"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "628-633",
          "snippet": "Request<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nRequest<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "hook"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook->message->getRoot<AnyPointer>",
          "args": [],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<LocalRequest>",
          "args": [
            "interfaceId",
            "methodId",
            "sizeHint",
            "kj::addRef(*this)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalClient {\n  Request<AnyPointer, AnyPointer> newCall(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n      auto hook = kj::heap<LocalRequest>(\n          interfaceId, methodId, sizeHint, kj::addRef(*this));\n      auto root = hook->message->getRoot<AnyPointer>();\n      return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n    }\n}"
  },
  {
    "function_name": "LocalClient",
    "container": "LocalClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "460-461",
    "snippet": "LocalClient(kj::Own<Capability::Server>&& server)\n      : server(kj::mv(server)) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "server"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalClient {\n  LocalClient(kj::Own<Capability::Server>&& server)\n        : server(kj::mv(server)) {}\n}"
  },
  {
    "function_name": "getPipelinedCap",
    "container": "LocalPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "449-451",
    "snippet": "kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) {\n    return results.getPipelinedCap(ops);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalPipeline {\n  kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) {\n      return results.getPipelinedCap(ops);\n    }\n}"
  },
  {
    "function_name": "addRef",
    "container": "LocalPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "445-447",
    "snippet": "kj::Own<PipelineHook> addRef() {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalPipeline {\n  kj::Own<PipelineHook> addRef() {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "LocalPipeline",
    "container": "LocalPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "441-443",
    "snippet": "inline LocalPipeline(kj::Own<CallContextHook>&& contextParam)\n      : context(kj::mv(contextParam)),\n        results(context->getResults(MessageSize { 0, 0 })) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context->getResults",
          "args": [
            "MessageSize { 0, 0 }"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "contextParam"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalPipeline {\n  inline LocalPipeline(kj::Own<CallContextHook>&& contextParam)\n        : context(kj::mv(contextParam)),\n          results(context->getResults(MessageSize { 0, 0 })) {}\n}"
  },
  {
    "function_name": "QueuedPipeline::getPipelinedCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "424-434",
    "snippet": "kj::Own<ClientHook> QueuedPipeline::getPipelinedCap(kj::Array<PipelineOp>&& ops) {\n  KJ_IF_MAYBE(r, redirect) {\n    return r->get()->getPipelinedCap(kj::mv(ops));\n  } else {\n    auto clientPromise = promise.addBranch().then(kj::mvCapture(ops,\n        [](kj::Array<PipelineOp>&& ops, kj::Own<PipelineHook> pipeline) {\n          return pipeline->getPipelinedCap(kj::mv(ops));\n        }));\n\n    return kj::refcounted<QueuedClient>(kj::mv(clientPromise));\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::refcounted<QueuedClient>",
          "args": [
            "kj::mv(clientPromise)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "clientPromise"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.addBranch",
          "args": [
            "kj::mvCapture(ops,\n        [](kj::Array<PipelineOp>&& ops, kj::Own<PipelineHook> pipeline) {\n          return pipeline->getPipelinedCap(kj::mv(ops));\n        })"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "ops",
            "[](kj::Array<PipelineOp>&& ops, kj::Own<PipelineHook> pipeline) {\n          return pipeline->getPipelinedCap(kj::mv(ops));\n        }"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipeline->getPipelinedCap",
          "args": [
            "kj::mv(ops)"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "getPipelinedCap",
          "container": "LocalPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "449-451",
          "snippet": "kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) {\n    return results.getPipelinedCap(ops);\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalPipeline {\n  kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) {\n      return results.getPipelinedCap(ops);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "ops"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.addBranch",
          "args": [],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r->get",
          "args": [
            "kj::mv(ops)"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "475-477",
          "snippet": "static inline typename T::Client get(PointerBuilder builder) {\n    return typename T::Client(builder.getCapability());\n  }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nstatic inline typename T::Client get(PointerBuilder builder) {\n    return typename T::Client(builder.getCapability());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "ops"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->get",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "getReceivedCount",
          "container": "TestNetworkAdapter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "209-209",
          "snippet": "uint getReceivedCount() { return received; }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  uint getReceivedCount() { return received; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> QueuedPipeline::getPipelinedCap(kj::Array<PipelineOp>&& ops) {\n  KJ_IF_MAYBE(r, redirect) {\n    return r->get()->getPipelinedCap(kj::mv(ops));\n  } else {\n    auto clientPromise = promise.addBranch().then(kj::mvCapture(ops,\n        [](kj::Array<PipelineOp>&& ops, kj::Own<PipelineHook> pipeline) {\n          return pipeline->getPipelinedCap(kj::mv(ops));\n        }));\n\n    return kj::refcounted<QueuedClient>(kj::mv(clientPromise));\n  }"
  },
  {
    "function_name": "addRef",
    "container": "QueuedClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "387-389",
    "snippet": "kj::Own<ClientHook> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedClient {\n  kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "whenMoreResolved",
    "container": "QueuedClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "383-385",
    "snippet": "kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n    return promiseForClientResolution.addBranch();\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promiseForClientResolution.addBranch",
          "args": [],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedClient {\n  kj::Maybe<kj::Promise<kj::Own<ClientHook>>> whenMoreResolved() override {\n      return promiseForClientResolution.addBranch();\n    }\n}"
  },
  {
    "function_name": "getResolved",
    "container": "QueuedClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "375-381",
    "snippet": "kj::Maybe<ClientHook&> getResolved() override {\n    KJ_IF_MAYBE(inner, redirect) {\n      return **inner;\n    } else {\n      return nullptr;\n    }\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedClient {\n  kj::Maybe<ClientHook&> getResolved() override {\n      KJ_IF_MAYBE(inner, redirect) {\n        return **inner;\n      } else {\n        return nullptr;\n      }\n    }\n}"
  },
  {
    "function_name": "call",
    "container": "QueuedClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "321-373",
    "snippet": "VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                              kj::Own<CallContextHook>&& context) override {\n    // This is a bit complicated.  We need to initiate this call later on.  When we initiate the\n    // call, we'll get a void promise for its completion and a pipeline object.  Right now, we have\n    // to produce a similar void promise and pipeline that will eventually be chained to those.\n    // The problem is, these are two independent objects, but they both depend on the result of\n    // one future call.\n    //\n    // So, we need to set up a continuation that will initiate the call later, then we need to\n    // fork the promise for that continuation in order to send the completion promise and the\n    // pipeline to their respective places.\n    //\n    // TODO(perf):  Too much reference counting?  Can we do better?  Maybe a way to fork\n    //   Promise<Tuple<T, U>> into Tuple<Promise<T>, Promise<U>>?\n\n    struct CallResultHolder: public kj::Refcounted {\n      // Essentially acts as a refcounted \\VoidPromiseAndPipeline, so that we can create a promise\n      // for it and fork that promise.\n\n      VoidPromiseAndPipeline content;\n      // One branch of the fork will use content.promise, the other branch will use\n      // content.pipeline.  Neither branch will touch the other's piece.\n\n      inline CallResultHolder(VoidPromiseAndPipeline&& content): content(kj::mv(content)) {}\n\n      kj::Own<CallResultHolder> addRef() { return kj::addRef(*this); }\n    };\n\n    // Create a promise for the call initiation.\n    kj::ForkedPromise<kj::Own<CallResultHolder>> callResultPromise =\n        promiseForCallForwarding.addBranch().then(kj::mvCapture(context,\n        [=](kj::Own<CallContextHook>&& context, kj::Own<ClientHook>&& client){\n          return kj::refcounted<CallResultHolder>(\n              client->call(interfaceId, methodId, kj::mv(context)));\n        })).fork();\n\n    // Create a promise that extracts the pipeline from the call initiation, and construct our\n    // QueuedPipeline to chain to it.\n    auto pipelinePromise = callResultPromise.addBranch().then(\n        [](kj::Own<CallResultHolder>&& callResult){\n          return kj::mv(callResult->content.pipeline);\n        });\n    auto pipeline = kj::refcounted<QueuedPipeline>(kj::mv(pipelinePromise));\n\n    // Create a promise that simply chains to the void promise produced by the call initiation.\n    auto completionPromise = callResultPromise.addBranch().then(\n        [](kj::Own<CallResultHolder>&& callResult){\n          return kj::mv(callResult->content.promise);\n        });\n\n    // OK, now we can actually return our thing.\n    return VoidPromiseAndPipeline { kj::mv(completionPromise), kj::mv(pipeline) };\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipeline"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "completionPromise"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callResultPromise.addBranch",
          "args": [
            "[](kj::Own<CallResultHolder>&& callResult){\n          return kj::mv(callResult->content.promise);\n        }"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "callResult->content.promise"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callResultPromise.addBranch",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<QueuedPipeline>",
          "args": [
            "kj::mv(pipelinePromise)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipelinePromise"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callResultPromise.addBranch",
          "args": [
            "[](kj::Own<CallResultHolder>&& callResult){\n          return kj::mv(callResult->content.pipeline);\n        }"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "callResult->content.pipeline"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promiseForCallForwarding.addBranch",
          "args": [
            "kj::mvCapture(context,\n        [=](kj::Own<CallContextHook>&& context, kj::Own<ClientHook>&& client){\n          return kj::refcounted<CallResultHolder>(\n              client->call(interfaceId, methodId, kj::mv(context)));\n        })"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "context",
            "[=](kj::Own<CallContextHook>&& context, kj::Own<ClientHook>&& client){\n          return kj::refcounted<CallResultHolder>(\n              client->call(interfaceId, methodId, kj::mv(context)));\n        }"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<CallResultHolder>",
          "args": [
            "client->call(interfaceId, methodId, kj::mv(context))"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "context"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "content"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedClient {\n  VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                kj::Own<CallContextHook>&& context) override {\n      // This is a bit complicated.  We need to initiate this call later on.  When we initiate the\n      // call, we'll get a void promise for its completion and a pipeline object.  Right now, we have\n      // to produce a similar void promise and pipeline that will eventually be chained to those.\n      // The problem is, these are two independent objects, but they both depend on the result of\n      // one future call.\n      //\n      // So, we need to set up a continuation that will initiate the call later, then we need to\n      // fork the promise for that continuation in order to send the completion promise and the\n      // pipeline to their respective places.\n      //\n      // TODO(perf):  Too much reference counting?  Can we do better?  Maybe a way to fork\n      //   Promise<Tuple<T, U>> into Tuple<Promise<T>, Promise<U>>?\n  \n      struct CallResultHolder: public kj::Refcounted {\n        // Essentially acts as a refcounted \\VoidPromiseAndPipeline, so that we can create a promise\n        // for it and fork that promise.\n  \n        VoidPromiseAndPipeline content;\n        // One branch of the fork will use content.promise, the other branch will use\n        // content.pipeline.  Neither branch will touch the other's piece.\n  \n        inline CallResultHolder(VoidPromiseAndPipeline&& content): content(kj::mv(content)) {}\n  \n        kj::Own<CallResultHolder> addRef() { return kj::addRef(*this); }\n      };\n  \n      // Create a promise for the call initiation.\n      kj::ForkedPromise<kj::Own<CallResultHolder>> callResultPromise =\n          promiseForCallForwarding.addBranch().then(kj::mvCapture(context,\n          [=](kj::Own<CallContextHook>&& context, kj::Own<ClientHook>&& client){\n            return kj::refcounted<CallResultHolder>(\n                client->call(interfaceId, methodId, kj::mv(context)));\n          })).fork();\n  \n      // Create a promise that extracts the pipeline from the call initiation, and construct our\n      // QueuedPipeline to chain to it.\n      auto pipelinePromise = callResultPromise.addBranch().then(\n          [](kj::Own<CallResultHolder>&& callResult){\n            return kj::mv(callResult->content.pipeline);\n          });\n      auto pipeline = kj::refcounted<QueuedPipeline>(kj::mv(pipelinePromise));\n  \n      // Create a promise that simply chains to the void promise produced by the call initiation.\n      auto completionPromise = callResultPromise.addBranch().then(\n          [](kj::Own<CallResultHolder>&& callResult){\n            return kj::mv(callResult->content.promise);\n          });\n  \n      // OK, now we can actually return our thing.\n      return VoidPromiseAndPipeline { kj::mv(completionPromise), kj::mv(pipeline) };\n    }\n}"
  },
  {
    "function_name": "newCall",
    "container": "QueuedClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "313-319",
    "snippet": "Request<AnyPointer, AnyPointer> newCall(\n      uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n    auto hook = kj::heap<LocalRequest>(\n        interfaceId, methodId, sizeHint, kj::addRef(*this));\n    auto root = hook->message->getRoot<AnyPointer>();\n    return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Request<AnyPointer, AnyPointer>",
          "args": [
            "root",
            "kj::mv(hook)"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "628-633",
          "snippet": "Request<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nRequest<AnyPointer, AnyPointer> newBrokenRequest(\n    kj::Exception&& reason, kj::Maybe<MessageSize> sizeHint) {\n  auto hook = kj::heap<BrokenRequest>(kj::mv(reason), sizeHint);\n  auto root = hook->message.getRoot<AnyPointer>();\n  return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "hook"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook->message->getRoot<AnyPointer>",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<LocalRequest>",
          "args": [
            "interfaceId",
            "methodId",
            "sizeHint",
            "kj::addRef(*this)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedClient {\n  Request<AnyPointer, AnyPointer> newCall(\n        uint64_t interfaceId, uint16_t methodId, kj::Maybe<MessageSize> sizeHint) override {\n      auto hook = kj::heap<LocalRequest>(\n          interfaceId, methodId, sizeHint, kj::addRef(*this));\n      auto root = hook->message->getRoot<AnyPointer>();\n      return Request<AnyPointer, AnyPointer>(root, kj::mv(hook));\n    }\n}"
  },
  {
    "function_name": "QueuedClient",
    "container": "QueuedClient",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "303-311",
    "snippet": "QueuedClient(kj::Promise<kj::Own<ClientHook>>&& promiseParam)\n      : promise(promiseParam.fork()),\n        selfResolutionOp(promise.addBranch().then([this](kj::Own<ClientHook>&& inner) {\n          redirect = kj::mv(inner);\n        }, [this](kj::Exception&& exception) {\n          redirect = newBrokenCap(kj::mv(exception));\n        }).eagerlyEvaluate(nullptr)),\n        promiseForCallForwarding(promise.addBranch().fork()),\n        promiseForClientResolution(promise.addBranch().fork()) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.addBranch",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promise.addBranch",
          "args": [
            "nullptr"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.addBranch",
          "args": [
            "[this](kj::Own<ClientHook>&& inner) {\n          redirect = kj::mv(inner);\n        }",
            "[this](kj::Exception&& exception) {\n          redirect = newBrokenCap(kj::mv(exception));\n        }"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inner"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promiseParam.fork",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedClient {\n  QueuedClient(kj::Promise<kj::Own<ClientHook>>&& promiseParam)\n        : promise(promiseParam.fork()),\n          selfResolutionOp(promise.addBranch().then([this](kj::Own<ClientHook>&& inner) {\n            redirect = kj::mv(inner);\n          }, [this](kj::Exception&& exception) {\n            redirect = newBrokenCap(kj::mv(exception));\n          }).eagerlyEvaluate(nullptr)),\n          promiseForCallForwarding(promise.addBranch().fork()),\n          promiseForClientResolution(promise.addBranch().fork()) {}\n}"
  },
  {
    "function_name": "getPipelinedCap",
    "container": "QueuedPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "278-284",
    "snippet": "kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) override {\n    auto copy = kj::heapArrayBuilder<PipelineOp>(ops.size());\n    for (auto& op: ops) {\n      copy.add(op);\n    }\n    return getPipelinedCap(copy.finish());\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getPipelinedCap",
          "args": [
            "copy.finish()"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "BrokenPipeline::getPipelinedCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "610-612",
          "snippet": "kj::Own<ClientHook> BrokenPipeline::getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) {\n  return kj::refcounted<BrokenClient>(exception);\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> BrokenPipeline::getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) {\n  return kj::refcounted<BrokenClient>(exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy.finish",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy.add",
          "args": [
            "op"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<PipelineOp>",
          "args": [
            "ops.size()"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops.size",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "540-540",
          "snippet": "inline uint size() const { return builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nBuilder {\n  inline uint size() const { return builder.size() / ELEMENTS; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedPipeline {\n  kj::Own<ClientHook> getPipelinedCap(kj::ArrayPtr<const PipelineOp> ops) override {\n      auto copy = kj::heapArrayBuilder<PipelineOp>(ops.size());\n      for (auto& op: ops) {\n        copy.add(op);\n      }\n      return getPipelinedCap(copy.finish());\n    }\n}"
  },
  {
    "function_name": "addRef",
    "container": "QueuedPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "274-276",
    "snippet": "kj::Own<PipelineHook> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedPipeline {\n  kj::Own<PipelineHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
  },
  {
    "function_name": "QueuedPipeline",
    "container": "QueuedPipeline",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "266-272",
    "snippet": "QueuedPipeline(kj::Promise<kj::Own<PipelineHook>>&& promiseParam)\n      : promise(promiseParam.fork()),\n        selfResolutionOp(promise.addBranch().then([this](kj::Own<PipelineHook>&& inner) {\n          redirect = kj::mv(inner);\n        }, [this](kj::Exception&& exception) {\n          redirect = newBrokenPipeline(kj::mv(exception));\n        }).eagerlyEvaluate(nullptr)) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise.addBranch",
          "args": [
            "nullptr"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.addBranch",
          "args": [
            "[this](kj::Own<PipelineHook>&& inner) {\n          redirect = kj::mv(inner);\n        }",
            "[this](kj::Exception&& exception) {\n          redirect = newBrokenPipeline(kj::mv(exception));\n        }"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newBrokenPipeline",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenPipeline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "624-626",
          "snippet": "kj::Own<PipelineHook> newBrokenPipeline(kj::Exception&& reason) {\n  return kj::refcounted<BrokenPipeline>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<PipelineHook> newBrokenPipeline(kj::Exception&& reason) {\n  return kj::refcounted<BrokenPipeline>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "inner"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.addBranch",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "promiseParam.fork",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nQueuedPipeline {\n  QueuedPipeline(kj::Promise<kj::Own<PipelineHook>>&& promiseParam)\n        : promise(promiseParam.fork()),\n          selfResolutionOp(promise.addBranch().then([this](kj::Own<PipelineHook>&& inner) {\n            redirect = kj::mv(inner);\n          }, [this](kj::Exception&& exception) {\n            redirect = newBrokenPipeline(kj::mv(exception));\n          }).eagerlyEvaluate(nullptr)) {}\n}"
  },
  {
    "function_name": "send",
    "container": "LocalRequest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "207-241",
    "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
      "kj::Maybe<Response<AnyPointer>> response;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RemotePromise<AnyPointer>",
          "args": [
            "kj::mv(promise)",
            "AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline))"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "RemotePromise",
          "container": "RemotePromise",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "53-55",
          "snippet": "inline RemotePromise(kj::Promise<Response<T>>&& promise, typename T::Pipeline&& pipeline)\n      : kj::Promise<Response<T>>(kj::mv(promise)),\n        T::Pipeline(kj::mv(pipeline)) {}",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRemotePromise {\n  inline RemotePromise(kj::Promise<Response<T>>&& promise, typename T::Pipeline&& pipeline)\n        : kj::Promise<Response<T>>(kj::mv(promise)),\n          T::Pipeline(kj::mv(pipeline)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AnyPointer::Pipeline",
          "args": [
            "kj::mv(promiseAndPipeline.pipeline)"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promiseAndPipeline.pipeline"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [
            "kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    })"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "context",
            "[](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "KJ_ASSERT_NONNULL(context->response)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "context->response"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->getResults",
          "args": [
            "MessageSize { 0, 0 }"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "addBranch",
          "container": "ForkHub",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "396-398",
          "snippet": "Promise<_::UnfixVoid<T>> addBranch() {\n    return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n  }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ForkHub {\n  Promise<_::UnfixVoid<T>> addBranch() {\n      return Promise<_::UnfixVoid<T>>(false, kj::heap<ForkBranch<T>>(addRef(*this)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [
            "[](kj::Exception&&) {}"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [
            "kj::mv(cancelPaf.promise)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cancelPaf.promise"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forked.addBranch",
          "args": [
            "kj::addRef(*context)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*context"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "promiseAndPipeline.promise.fork",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client->call",
          "args": [
            "interfaceId",
            "methodId",
            "kj::addRef(*context)"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "call",
          "container": "BrokenClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "585-588",
          "snippet": "VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                              kj::Own<CallContextHook>&& context) override {\n    return VoidPromiseAndPipeline { kj::cp(exception), kj::refcounted<BrokenPipeline>(exception) };\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  VoidPromiseAndPipeline call(uint64_t interfaceId, uint16_t methodId,\n                                kj::Own<CallContextHook>&& context) override {\n      return VoidPromiseAndPipeline { kj::cp(exception), kj::refcounted<BrokenPipeline>(exception) };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<LocalCallContext>",
          "args": [
            "kj::mv(message)",
            "client->addRef()",
            "kj::mv(cancelPaf.fulfiller)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cancelPaf.fulfiller"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client->addRef",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "BrokenClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "598-600",
          "snippet": "kj::Own<ClientHook> addRef() override {\n    return kj::addRef(*this);\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "message"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<void>",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "message.get() != nullptr",
            "\"Already called send() on this request.\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.get",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
  },
  {
    "function_name": "LocalRequest",
    "container": "LocalRequest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "202-205",
    "snippet": "inline LocalRequest(uint64_t interfaceId, uint16_t methodId,\n                      kj::Maybe<MessageSize> sizeHint, kj::Own<ClientHook> client)\n      : message(kj::heap<MallocMessageBuilder>(firstSegmentSize(sizeHint))),\n        interfaceId(interfaceId), methodId(methodId), client(kj::mv(client)) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "client"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<MallocMessageBuilder>",
          "args": [
            "firstSegmentSize(sizeHint)"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "firstSegmentSize",
          "args": [
            "sizeHint"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalRequest {\n  inline LocalRequest(uint64_t interfaceId, uint16_t methodId,\n                        kj::Maybe<MessageSize> sizeHint, kj::Own<ClientHook> client)\n        : message(kj::heap<MallocMessageBuilder>(firstSegmentSize(sizeHint))),\n          interfaceId(interfaceId), methodId(methodId), client(kj::mv(client)) {}\n}"
  },
  {
    "function_name": "addRef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "188-190",
    "snippet": "kj::Own<CallContextHook> addRef() override {\n    return kj::addRef(*this);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::addRef",
          "args": [
            "*this"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/refcount.h",
          "lines": "85-92",
          "snippet": "Own<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}",
          "includes": [
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"memory.h\"\n\nOwn<T> addRef(T& object) {\n  // Return a new reference to `object`, which must subclass Refcounted and have been allocated\n  // using `kj::refcounted<>()`.  It is suggested that subclasses implement a non-static addRef()\n  // method which wraps this and returns the appropriate type.\n\n  KJ_IREQUIRE(object.Refcounted::refcount > 0, \"Object not allocated with kj::refcounted().\");\n  return Refcounted::addRefInternal(&object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<CallContextHook> addRef() override {\n    return kj::addRef(*this);\n  }"
  },
  {
    "function_name": "allowCancellation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "185-187",
    "snippet": "void allowCancellation() override {\n    cancelAllowedFulfiller->fulfill();\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Own<kj::PromiseFulfiller<void>> cancelAllowedFulfiller;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancelAllowedFulfiller->fulfill",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "fulfill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.c++",
          "lines": "68-72",
          "snippet": "void fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }",
          "includes": [
            "#include <poll.h>",
            "#include <sys/eventfd.h>",
            "#include <sys/signalfd.h>",
            "#include <sys/epoll.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <chrono>",
            "#include <set>",
            "#include <limits>",
            "#include <inttypes.h>",
            "#include <errno.h>",
            "#include <setjmp.h>",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <poll.h>\n#include <sys/eventfd.h>\n#include <sys/signalfd.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <chrono>\n#include <set>\n#include <limits>\n#include <inttypes.h>\n#include <errno.h>\n#include <setjmp.h>\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n\nvoid fulfill() {\n    fulfiller.fulfill();\n    port.timers->timers.erase(pos);\n    pos = port.timers->timers.end();\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<kj::PromiseFulfiller<void>> cancelAllowedFulfiller;\n\nvoid allowCancellation() override {\n    cancelAllowedFulfiller->fulfill();\n  }"
  },
  {
    "function_name": "onTailCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "180-184",
    "snippet": "kj::Promise<AnyPointer::Pipeline> onTailCall() override {\n    auto paf = kj::newPromiseAndFulfiller<AnyPointer::Pipeline>();\n    tailCallPipelineFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.promise"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "paf.fulfiller"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::newPromiseAndFulfiller<AnyPointer::Pipeline>",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "newPromiseAndFulfiller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "946-955",
          "snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "PromiseFulfillerPair<T> newPromiseAndFulfiller() {\n  auto wrapper = _::WeakFulfiller<T>::make();\n\n  Own<_::PromiseNode> intermediate(\n      heap<_::AdapterPromiseNode<_::FixVoid<T>, _::PromiseAndFulfillerAdapter<T>>>(*wrapper));\n  Promise<_::JoinPromises<T>> promise(false,\n      _::maybeChain(kj::mv(intermediate), implicitCast<T*>(nullptr)));\n\n  return PromiseFulfillerPair<T> { kj::mv(promise), kj::mv(wrapper) };\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;\n\nkj::Promise<AnyPointer::Pipeline> onTailCall() override {\n    auto paf = kj::newPromiseAndFulfiller<AnyPointer::Pipeline>();\n    tailCallPipelineFulfiller = kj::mv(paf.fulfiller);\n    return kj::mv(paf.promise);\n  }"
  },
  {
    "function_name": "directTailCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "169-179",
    "snippet": "ClientHook::VoidPromiseAndPipeline directTailCall(kj::Own<RequestHook>&& request) override {\n    KJ_REQUIRE(response == nullptr, \"Can't call tailCall() after initializing the results struct.\");\n\n    auto promise = request->send();\n\n    auto voidPromise = promise.then([this](Response<AnyPointer>&& tailResponse) {\n      response = kj::mv(tailResponse);\n    });\n\n    return { kj::mv(voidPromise), PipelineHook::from(kj::mv(promise)) };\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
      "kj::Maybe<Response<AnyPointer>> response;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PipelineHook::from",
          "args": [
            "kj::mv(promise)"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "from",
          "container": "RequestHook",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "354-356",
          "snippet": "inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n    return kj::mv(request.hook);\n  }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nRequestHook {\n  inline static kj::Own<RequestHook> from(Request<T, U>&& request) {\n      return kj::mv(request.hook);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "promise"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "voidPromise"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "promise.then",
          "args": [
            "[this](Response<AnyPointer>&& tailResponse) {\n      response = kj::mv(tailResponse);\n    }"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "tailResponse"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request->send",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "BrokenRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "561-564",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    return RemotePromise<AnyPointer>(kj::cp(exception),\n        AnyPointer::Pipeline(kj::refcounted<BrokenPipeline>(exception)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenRequest {\n  RemotePromise<AnyPointer> send() override {\n      return RemotePromise<AnyPointer>(kj::cp(exception),\n          AnyPointer::Pipeline(kj::refcounted<BrokenPipeline>(exception)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "response == nullptr",
            "\"Can't call tailCall() after initializing the results struct.\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nClientHook::VoidPromiseAndPipeline directTailCall(kj::Own<RequestHook>&& request) override {\n    KJ_REQUIRE(response == nullptr, \"Can't call tailCall() after initializing the results struct.\");\n\n    auto promise = request->send();\n\n    auto voidPromise = promise.then([this](Response<AnyPointer>&& tailResponse) {\n      response = kj::mv(tailResponse);\n    });\n\n    return { kj::mv(voidPromise), PipelineHook::from(kj::mv(promise)) };\n  }"
  },
  {
    "function_name": "tailCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "162-168",
    "snippet": "kj::Promise<void> tailCall(kj::Own<RequestHook>&& request) override {\n    auto result = directTailCall(kj::mv(request));\n    KJ_IF_MAYBE(f, tailCallPipelineFulfiller) {\n      f->get()->fulfill(AnyPointer::Pipeline(kj::mv(result.pipeline)));\n    }\n    return kj::mv(result.promise);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
      "kj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result.promise"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->get",
          "args": [
            "AnyPointer::Pipeline(kj::mv(result.pipeline))"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "475-477",
          "snippet": "static inline typename T::Client get(PointerBuilder builder) {\n    return typename T::Client(builder.getCapability());\n  }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nstatic inline typename T::Client get(PointerBuilder builder) {\n    return typename T::Client(builder.getCapability());\n  }"
        }
      },
      {
        "call_info": {
          "callee": "AnyPointer::Pipeline",
          "args": [
            "kj::mv(result.pipeline)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "Pipeline",
          "container": "AnyPointer::Pipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "243-243",
          "snippet": "inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Pipeline {\n    inline explicit Pipeline(kj::Own<PipelineHook>&& hook): hook(kj::mv(hook)) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result.pipeline"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->get",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": "QuestionRef",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1289-1289",
          "snippet": "inline QuestionId getId() const { return id; }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nQuestionRef {\n  inline QuestionId getId() const { return id; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "directTailCall",
          "args": [
            "kj::mv(request)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<kj::Own<kj::PromiseFulfiller<AnyPointer::Pipeline>>> tailCallPipelineFulfiller;\n\nkj::Promise<void> tailCall(kj::Own<RequestHook>&& request) override {\n    auto result = directTailCall(kj::mv(request));\n    KJ_IF_MAYBE(f, tailCallPipelineFulfiller) {\n      f->get()->fulfill(AnyPointer::Pipeline(kj::mv(result.pipeline)));\n    }\n    return kj::mv(result.promise);\n  }"
  },
  {
    "function_name": "getResults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "154-161",
    "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<Response<AnyPointer>> response;",
      "AnyPointer::Builder responseBuilder = nullptr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Response<AnyPointer>",
          "args": [
            "responseBuilder.asReader()",
            "kj::mv(localResponse)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "Response",
          "container": "Response",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "130-131",
          "snippet": "inline Response(typename Results::Reader reader, kj::Own<ResponseHook>&& hook)\n      : Results::Reader(reader), hook(kj::mv(hook)) {}",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nResponse {\n  inline Response(typename Results::Reader reader, kj::Own<ResponseHook>&& hook)\n        : Results::Reader(reader), hook(kj::mv(hook)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "localResponse"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "responseBuilder.asReader",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "asReader",
          "container": "Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.h",
          "lines": "538-538",
          "snippet": "inline Reader asReader() { return Reader(builder.asReader()); }",
          "includes": [
            "#include \"pointer-helpers.h\"",
            "#include \"any.h\"",
            "#include <kj/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pointer-helpers.h\"\n#include \"any.h\"\n#include <kj/async.h>\n\nBuilder {\n  inline Reader asReader() { return Reader(builder.asReader()); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "localResponse->message.getRoot<AnyPointer>",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::refcounted<LocalResponse>",
          "args": [
            "sizeHint"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
  },
  {
    "function_name": "releaseParams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "137-153",
    "snippet": "class LocalCallContext final: public CallContextHook, public kj::Refcounted {\npublic:\n  LocalCallContext(kj::Own<MallocMessageBuilder>&& request, kj::Own<ClientHook> clientRef,\n                   kj::Own<kj::PromiseFulfiller<void>> cancelAllowedFulfiller)\n      : request(kj::mv(request)), clientRef(kj::mv(clientRef)),\n        cancelAllowedFulfiller(kj::mv(cancelAllowedFulfiller)) {}\n\n  AnyPointer::Reader getParams() override {\n    KJ_IF_MAYBE(r, request) {\n      return r->get()->getRoot<AnyPointer>();\n    } else {\n      KJ_FAIL_REQUIRE(\"Can't call getParams() after releaseParams().\");\n    }\n  }\n  void releaseParams() override {\n    request = nullptr;\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
      "kj::Own<ClientHook> clientRef;",
      "kj::Own<kj::PromiseFulfiller<void>> cancelAllowedFulfiller;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Can't call getParams() after releaseParams().\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->get",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "getReceivedCount",
          "container": "TestNetworkAdapter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-test.c++",
          "lines": "209-209",
          "snippet": "uint getReceivedCount() { return received; }",
          "includes": [
            "#include <queue>",
            "#include <map>",
            "#include <capnp/rpc.capnp.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"schema.h\"",
            "#include \"test-util.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <queue>\n#include <map>\n#include <capnp/rpc.capnp.h>\n#include <kj/compat/gtest.h>\n#include <kj/string-tree.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"schema.h\"\n#include \"test-util.h\"\n#include \"rpc.h\"\n\nTestNetworkAdapter {\n  uint getReceivedCount() { return received; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cancelAllowedFulfiller"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "clientRef"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "request"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Own<ClientHook> clientRef;\nkj::Own<kj::PromiseFulfiller<void>> cancelAllowedFulfiller;\n\nclass LocalCallContext final: public CallContextHook, public kj::Refcounted {\npublic:\n  LocalCallContext(kj::Own<MallocMessageBuilder>&& request, kj::Own<ClientHook> clientRef,\n                   kj::Own<kj::PromiseFulfiller<void>> cancelAllowedFulfiller)\n      : request(kj::mv(request)), clientRef(kj::mv(clientRef)),\n        cancelAllowedFulfiller(kj::mv(cancelAllowedFulfiller)) {}\n\n  AnyPointer::Reader getParams() override {\n    KJ_IF_MAYBE(r, request) {\n      return r->get()->getRoot<AnyPointer>();\n    } else {\n      KJ_FAIL_REQUIRE(\"Can't call getParams() after releaseParams().\");\n    }\n  }\n  void releaseParams() override {\n    request = nullptr;\n  }"
  },
  {
    "function_name": "LocalResponse",
    "container": "LocalResponse",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "131-132",
    "snippet": "LocalResponse(kj::Maybe<MessageSize> sizeHint)\n      : message(firstSegmentSize(sizeHint)) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "firstSegmentSize",
          "args": [
            "sizeHint"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nLocalResponse {\n  LocalResponse(kj::Maybe<MessageSize> sizeHint)\n        : message(firstSegmentSize(sizeHint)) {}\n}"
  },
  {
    "function_name": "firstSegmentSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "121-127",
    "snippet": "static inline uint firstSegmentSize(kj::Maybe<MessageSize> sizeHint) {\n  KJ_IF_MAYBE(s, sizeHint) {\n    return s->wordCount;\n  } else {\n    return SUGGESTED_FIRST_SEGMENT_WORDS;\n  }\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nstatic inline uint firstSegmentSize(kj::Maybe<MessageSize> sizeHint) {\n  KJ_IF_MAYBE(s, sizeHint) {\n    return s->wordCount;\n  } else {\n    return SUGGESTED_FIRST_SEGMENT_WORDS;\n  }\n}"
  },
  {
    "function_name": "ClientHook::whenResolved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "109-116",
    "snippet": "kj::Promise<void> ClientHook::whenResolved() {\n  KJ_IF_MAYBE(promise, whenMoreResolved()) {\n    return promise->then([](kj::Own<ClientHook>&& resolution) {\n      return resolution->whenResolved();\n    });\n  } else {\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "promise->then",
          "args": [
            "[](kj::Own<ClientHook>&& resolution) {\n      return resolution->whenResolved();\n    }"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resolution->whenResolved",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Promise<void> ClientHook::whenResolved() {\n  KJ_IF_MAYBE(promise, whenMoreResolved()) {\n    return promise->then([](kj::Own<ClientHook>&& resolution) {\n      return resolution->whenResolved();\n    });\n  } else {\n    return kj::READY_NOW;\n  }"
  },
  {
    "function_name": "ResponseHook::~ResponseHook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "107-107",
    "snippet": "ResponseHook::~ResponseHook() noexcept(false) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nResponseHook::~ResponseHook() noexcept(false) {}"
  },
  {
    "function_name": "Capability::Server::internalUnimplemented",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "98-105",
    "snippet": "kj::Promise<void> Capability::Server::internalUnimplemented(\n    const char* interfaceName, const char* methodName, uint64_t typeId, uint16_t methodId) {\n  KJ_UNIMPLEMENTED(\"Method not implemented.\", interfaceName, typeId, methodName, methodId) {\n    // Recoverable exception will be caught by promise framework.\n    break;\n  }\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Method not implemented.\"",
            "interfaceName",
            "typeId",
            "methodName",
            "methodId"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Promise<void> Capability::Server::internalUnimplemented(\n    const char* interfaceName, const char* methodName, uint64_t typeId, uint16_t methodId) {\n  KJ_UNIMPLEMENTED(\"Method not implemented.\", interfaceName, typeId, methodName, methodId) {\n    // Recoverable exception will be caught by promise framework.\n    break;\n  }\n  return kj::READY_NOW;\n}"
  },
  {
    "function_name": "Capability::Server::internalUnimplemented",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "89-96",
    "snippet": "kj::Promise<void> Capability::Server::internalUnimplemented(\n    const char* interfaceName, uint64_t typeId, uint16_t methodId) {\n  KJ_UNIMPLEMENTED(\"Method not implemented.\", interfaceName, typeId, methodId) {\n    // Recoverable exception will be caught by promise framework.\n    break;\n  }\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Method not implemented.\"",
            "interfaceName",
            "typeId",
            "methodId"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Promise<void> Capability::Server::internalUnimplemented(\n    const char* interfaceName, uint64_t typeId, uint16_t methodId) {\n  KJ_UNIMPLEMENTED(\"Method not implemented.\", interfaceName, typeId, methodId) {\n    // Recoverable exception will be caught by promise framework.\n    break;\n  }\n  return kj::READY_NOW;\n}"
  },
  {
    "function_name": "Capability::Server::internalUnimplemented",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "75-87",
    "snippet": "kj::Promise<void> Capability::Server::internalUnimplemented(\n    const char* actualInterfaceName, uint64_t requestedTypeId) {\n  KJ_UNIMPLEMENTED(\"Requested interface not implemented.\", actualInterfaceName, requestedTypeId) {\n    // Recoverable exception will be caught by promise framework.\n\n    // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n    // a bug that exists in both Clang and GCC:\n    //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n    //   http://llvm.org/bugs/show_bug.cgi?id=12286\n    break;\n  }\n  return kj::READY_NOW;\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Requested interface not implemented.\"",
            "actualInterfaceName",
            "requestedTypeId"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Promise<void> Capability::Server::internalUnimplemented(\n    const char* actualInterfaceName, uint64_t requestedTypeId) {\n  KJ_UNIMPLEMENTED(\"Requested interface not implemented.\", actualInterfaceName, requestedTypeId) {\n    // Recoverable exception will be caught by promise framework.\n\n    // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n    // a bug that exists in both Clang and GCC:\n    //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n    //   http://llvm.org/bugs/show_bug.cgi?id=12286\n    break;\n  }\n  return kj::READY_NOW;\n}"
  },
  {
    "function_name": "Capability::Client::Client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "72-73",
    "snippet": "Capability::Client::Client(kj::Exception&& exception)\n    : hook(newBrokenCap(kj::mv(exception))) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nCapability::Client::Client(kj::Exception&& exception)\n    : hook(newBrokenCap(kj::mv(exception))) {}"
  },
  {
    "function_name": "Capability::Client::Client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "69-70",
    "snippet": "Capability::Client::Client(decltype(nullptr))\n    : hook(newBrokenCap(\"Called null capability.\")) {}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "newBrokenCap",
          "args": [
            "\"Called null capability.\""
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "newBrokenCap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "620-622",
          "snippet": "kj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Own<ClientHook> newBrokenCap(kj::Exception&& reason) {\n  return kj::refcounted<BrokenClient>(kj::mv(reason));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nCapability::Client::Client(decltype(nullptr))\n    : hook(newBrokenCap(\"Called null capability.\")) {}"
  },
  {
    "function_name": "MessageReader::initCapTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "62-65",
    "snippet": "void MessageReader::initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>> capTable) {\n  setGlobalBrokenCapFactoryForLayoutCpp(brokenCapFactory);\n  arena()->initCapTable(kj::mv(capTable));\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena",
          "args": [
            "kj::mv(capTable)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "capTable"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setGlobalBrokenCapFactoryForLayoutCpp",
          "args": [
            "brokenCapFactory"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "setGlobalBrokenCapFactoryForLayoutCpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "41-45",
          "snippet": "void setGlobalBrokenCapFactoryForLayoutCpp(BrokenCapFactory& factory) {\n  // Called from capability.c++ when the capability API is used, to make sure that layout.c++\n  // is ready for it.  May be called multiple times but always with the same value.\n  __atomic_store_n(&brokenCapFactory, &factory, __ATOMIC_RELAXED);\n}",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid setGlobalBrokenCapFactoryForLayoutCpp(BrokenCapFactory& factory) {\n  // Called from capability.c++ when the capability API is used, to make sure that layout.c++\n  // is ready for it.  May be called multiple times but always with the same value.\n  __atomic_store_n(&brokenCapFactory, &factory, __ATOMIC_RELAXED);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nvoid MessageReader::initCapTable(kj::Array<kj::Maybe<kj::Own<ClientHook>>> capTable) {\n  setGlobalBrokenCapFactoryForLayoutCpp(brokenCapFactory);\n  arena()->initCapTable(kj::mv(capTable));\n}"
  },
  {
    "function_name": "ClientHook::ClientHook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "58-60",
    "snippet": "ClientHook::ClientHook() {\n  setGlobalBrokenCapFactoryForLayoutCpp(brokenCapFactory);\n}",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setGlobalBrokenCapFactoryForLayoutCpp",
          "args": [
            "brokenCapFactory"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "setGlobalBrokenCapFactoryForLayoutCpp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/layout.c++",
          "lines": "41-45",
          "snippet": "void setGlobalBrokenCapFactoryForLayoutCpp(BrokenCapFactory& factory) {\n  // Called from capability.c++ when the capability API is used, to make sure that layout.c++\n  // is ready for it.  May be called multiple times but always with the same value.\n  __atomic_store_n(&brokenCapFactory, &factory, __ATOMIC_RELAXED);\n}",
          "includes": [
            "#include \"capability.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include \"arena.h\"",
            "#include <kj/debug.h>",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"arena.h\"\n#include <kj/debug.h>\n#include \"layout.h\"\n\nvoid setGlobalBrokenCapFactoryForLayoutCpp(BrokenCapFactory& factory) {\n  // Called from capability.c++ when the capability API is used, to make sure that layout.c++\n  // is ready for it.  May be called multiple times but always with the same value.\n  __atomic_store_n(&brokenCapFactory, &factory, __ATOMIC_RELAXED);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nClientHook::ClientHook() {\n  setGlobalBrokenCapFactoryForLayoutCpp(brokenCapFactory);\n}"
  },
  {
    "function_name": "newBrokenCap",
    "container": "BrokenCapFactoryImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
    "lines": "49-51",
    "snippet": "kj::Own<ClientHook> newBrokenCap(kj::StringPtr description) override {\n    return capnp::newBrokenCap(description);\n  }",
    "includes": [
      "#include \"generated-header-support.h\"",
      "#include <map>",
      "#include <kj/vector.h>",
      "#include <kj/debug.h>",
      "#include <kj/refcount.h>",
      "#include \"arena.h\"",
      "#include \"message.h\"",
      "#include \"capability.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenCapFactoryImpl {\n  kj::Own<ClientHook> newBrokenCap(kj::StringPtr description) override {\n      return capnp::newBrokenCap(description);\n    }\n}"
  }
]