[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc-test.c++",
    "lines": "47-69",
    "snippet": "TEST(EzRpc, DeprecatedNames) {\n  EzRpcServer server(\"localhost\");\n  int callCount = 0;\n  server.exportCap(\"cap1\", kj::heap<TestInterfaceImpl>(callCount));\n  server.exportCap(\"cap2\", kj::heap<TestCallOrderImpl>());\n\n  EzRpcClient client(\"localhost\", server.getPort().wait(server.getWaitScope()));\n\n  auto cap = client.importCap<test::TestInterface>(\"cap1\");\n  auto request = cap.fooRequest();\n  request.setI(123);\n  request.setJ(true);\n\n  EXPECT_EQ(0, callCount);\n  auto response = request.send().wait(server.getWaitScope());\n  EXPECT_EQ(\"foo\", response.getX());\n  EXPECT_EQ(1, callCount);\n\n  EXPECT_EQ(0, client.importCap(\"cap2\").castAs<test::TestCallOrder>()\n      .getCallSequenceRequest().send().wait(server.getWaitScope()).getN());\n  EXPECT_EQ(1, client.importCap(\"cap2\").castAs<test::TestCallOrder>()\n      .getCallSequenceRequest().send().wait(server.getWaitScope()).getN());\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"test-util.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "client.importCap(\"cap2\").castAs<test::TestCallOrder>()\n      .getCallSequenceRequest().send().wait(server.getWaitScope()).getN()"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [
            "server.getWaitScope()"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getWaitScope",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [
            "\"cap2\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "client.importCap(\"cap2\").castAs<test::TestCallOrder>()\n      .getCallSequenceRequest().send().wait(server.getWaitScope()).getN()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [
            "server.getWaitScope()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getWaitScope",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap",
          "args": [
            "\"cap2\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "callCount"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response.getX()"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getX",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "server.getWaitScope()"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server.getWaitScope",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setJ",
          "args": [
            "true"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setI",
          "args": [
            "123"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.fooRequest",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.importCap<test::TestInterface>",
          "args": [
            "\"cap1\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getPort",
          "args": [
            "server.getWaitScope()"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getWaitScope",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getPort",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "getPort",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "863-865",
          "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server.exportCap",
          "args": [
            "\"cap2\"",
            "kj::heap<TestCallOrderImpl>()"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<TestCallOrderImpl>",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server.exportCap",
          "args": [
            "\"cap1\"",
            "kj::heap<TestInterfaceImpl>(callCount)"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include \"ez-rpc.h\"\n\nTEST(EzRpc, DeprecatedNames) {\n  EzRpcServer server(\"localhost\");\n  int callCount = 0;\n  server.exportCap(\"cap1\", kj::heap<TestInterfaceImpl>(callCount));\n  server.exportCap(\"cap2\", kj::heap<TestCallOrderImpl>());\n\n  EzRpcClient client(\"localhost\", server.getPort().wait(server.getWaitScope()));\n\n  auto cap = client.importCap<test::TestInterface>(\"cap1\");\n  auto request = cap.fooRequest();\n  request.setI(123);\n  request.setJ(true);\n\n  EXPECT_EQ(0, callCount);\n  auto response = request.send().wait(server.getWaitScope());\n  EXPECT_EQ(\"foo\", response.getX());\n  EXPECT_EQ(1, callCount);\n\n  EXPECT_EQ(0, client.importCap(\"cap2\").castAs<test::TestCallOrder>()\n      .getCallSequenceRequest().send().wait(server.getWaitScope()).getN());\n  EXPECT_EQ(1, client.importCap(\"cap2\").castAs<test::TestCallOrder>()\n      .getCallSequenceRequest().send().wait(server.getWaitScope()).getN());\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/ez-rpc-test.c++",
    "lines": "30-45",
    "snippet": "TEST(EzRpc, Basic) {\n  int callCount = 0;\n  EzRpcServer server(kj::heap<TestInterfaceImpl>(callCount), \"localhost\");\n\n  EzRpcClient client(\"localhost\", server.getPort().wait(server.getWaitScope()));\n\n  auto cap = client.getMain<test::TestInterface>();\n  auto request = cap.fooRequest();\n  request.setI(123);\n  request.setJ(true);\n\n  EXPECT_EQ(0, callCount);\n  auto response = request.send().wait(server.getWaitScope());\n  EXPECT_EQ(\"foo\", response.getX());\n  EXPECT_EQ(1, callCount);\n}",
    "includes": [
      "#include <kj/compat/gtest.h>",
      "#include \"test-util.h\"",
      "#include \"ez-rpc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "1",
            "callCount"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "\"foo\"",
            "response.getX()"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getX",
          "args": [],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "server.getWaitScope()"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server.getWaitScope",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "0",
            "callCount"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setJ",
          "args": [
            "true"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setI",
          "args": [
            "123"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap.fooRequest",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getMain<test::TestInterface>",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "getMain",
          "container": "EvolutionTestMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "846-854",
          "snippet": "kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"(unknown version)\",\n        \"Integration test / fuzzer which randomly modifies schemas is backwards-compatible ways \"\n        \"and verifies that they do actually remain compatible.\")\n        .addOptionWithArg({\"seed\"}, KJ_BIND_METHOD(*this, setSeed), \"<num>\",\n            \"Set random number seed to <num>.  By default, time() is used.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nEvolutionTestMain {\n  kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"(unknown version)\",\n          \"Integration test / fuzzer which randomly modifies schemas is backwards-compatible ways \"\n          \"and verifies that they do actually remain compatible.\")\n          .addOptionWithArg({\"seed\"}, KJ_BIND_METHOD(*this, setSeed), \"<num>\",\n              \"Set random number seed to <num>.  By default, time() is used.\")\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "server.getPort",
          "args": [
            "server.getWaitScope()"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getWaitScope",
          "args": [],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server.getPort",
          "args": [],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "getPort",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "863-865",
          "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<TestInterfaceImpl>",
          "args": [
            "callCount"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include \"ez-rpc.h\"\n\nTEST(EzRpc, Basic) {\n  int callCount = 0;\n  EzRpcServer server(kj::heap<TestInterfaceImpl>(callCount), \"localhost\");\n\n  EzRpcClient client(\"localhost\", server.getPort().wait(server.getWaitScope()));\n\n  auto cap = client.getMain<test::TestInterface>();\n  auto request = cap.fooRequest();\n  request.setI(123);\n  request.setJ(true);\n\n  EXPECT_EQ(0, callCount);\n  auto response = request.send().wait(server.getWaitScope());\n  EXPECT_EQ(\"foo\", response.getX());\n  EXPECT_EQ(1, callCount);\n}"
  }
]