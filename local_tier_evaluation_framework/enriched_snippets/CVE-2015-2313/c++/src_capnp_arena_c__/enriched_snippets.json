[
  {
    "function_name": "BuilderArena::dropCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "313-318",
    "snippet": "void BuilderArena::dropCap(uint index) {\n  KJ_ASSERT(index < capTable.size(), \"Invalid capability descriptor in message.\") {\n    return;\n  }\n  capTable[index] = nullptr;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "index < capTable.size()",
            "\"Invalid capability descriptor in message.\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capTable.size",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nvoid BuilderArena::dropCap(uint index) {\n  KJ_ASSERT(index < capTable.size(), \"Invalid capability descriptor in message.\") {\n    return;\n  }\n  capTable[index] = nullptr;\n}"
  },
  {
    "function_name": "BuilderArena::injectCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "305-311",
    "snippet": "uint BuilderArena::injectCap(kj::Own<ClientHook>&& cap) {\n  // TODO(perf):  Detect if the cap is already on the table and reuse the index?  Perhaps this\n  //   doesn't happen enough to be worth the effort.\n  uint result = capTable.size();\n  capTable.add(kj::mv(cap));\n  return result;\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capTable.add",
          "args": [
            "kj::mv(cap)"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "cap"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capTable.size",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nuint BuilderArena::injectCap(kj::Own<ClientHook>&& cap) {\n  // TODO(perf):  Detect if the cap is already on the table and reuse the index?  Perhaps this\n  //   doesn't happen enough to be worth the effort.\n  uint result = capTable.size();\n  capTable.add(kj::mv(cap));\n  return result;\n}"
  },
  {
    "function_name": "BuilderArena::extractCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "297-303",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> BuilderArena::extractCap(uint index) {\n  if (index < capTable.size()) {\n    return capTable[index].map([](kj::Own<ClientHook>& cap) { return cap->addRef(); });\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capTable[index].map",
          "args": [
            "[](kj::Own<ClientHook>& cap) { return cap->addRef(); }"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1083-1089",
          "snippet": "auto map(Func&& f) -> Maybe<decltype(f(instance<T&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(*ptr);\n    }\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto map(Func&& f) -> Maybe<decltype(f(instance<T&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(*ptr);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "cap->addRef",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "BrokenClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "598-600",
          "snippet": "kj::Own<ClientHook> addRef() override {\n    return kj::addRef(*this);\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "capTable.size",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nkj::Maybe<kj::Own<ClientHook>> BuilderArena::extractCap(uint index) {\n  if (index < capTable.size()) {\n    return capTable[index].map([](kj::Own<ClientHook>& cap) { return cap->addRef(); });\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "BuilderArena::reportReadLimitReached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "290-294",
    "snippet": "void BuilderArena::reportReadLimitReached() {\n  KJ_FAIL_ASSERT(\"Read limit reached for BuilderArena, but it should have been unlimited.\") {\n    return;\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"Read limit reached for BuilderArena, but it should have been unlimited.\""
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nvoid BuilderArena::reportReadLimitReached() {\n  KJ_FAIL_ASSERT(\"Read limit reached for BuilderArena, but it should have been unlimited.\") {\n    return;\n  }\n}"
  },
  {
    "function_name": "BuilderArena::getSegmentsForOutput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "238-267",
    "snippet": "kj::ArrayPtr<const kj::ArrayPtr<const word>> BuilderArena::getSegmentsForOutput() {\n  // Although this is a read-only method, we shouldn't need to lock a mutex here because if this\n  // is called multiple times simultaneously, we should only be overwriting the array with the\n  // exact same data.  If the number or size of segments is actually changing due to an activity\n  // in another thread, then the caller has a problem regardless of locking here.\n\n  KJ_IF_MAYBE(segmentState, moreSegments) {\n    KJ_DASSERT(segmentState->get()->forOutput.size() == segmentState->get()->builders.size() + 1,\n        \"segmentState->forOutput wasn't resized correctly when the last builder was added.\",\n        segmentState->get()->forOutput.size(), segmentState->get()->builders.size());\n\n    kj::ArrayPtr<kj::ArrayPtr<const word>> result(\n        &segmentState->get()->forOutput[0], segmentState->get()->forOutput.size());\n    uint i = 0;\n    result[i++] = segment0.currentlyAllocated();\n    for (auto& builder: segmentState->get()->builders) {\n      result[i++] = builder->currentlyAllocated();\n    }\n    return result;\n  } else {\n    if (segment0.getArena() == nullptr) {\n      // We haven't actually allocated any segments yet.\n      return nullptr;\n    } else {\n      // We have only one segment so far.\n      segment0ForOutput = segment0.currentlyAllocated();\n      return kj::arrayPtr(&segment0ForOutput, 1);\n    }\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "&segment0ForOutput",
            "1"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment0.currentlyAllocated",
          "args": [],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "segment0.getArena() == nullptr"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "if",
          "container": "RpcPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1516-1518",
          "snippet": "else if (state.is<Resolved>()) {\n        return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcPipeline {\n  else if (state.is<Resolved>()) {\n          return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment0.getArena",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder->currentlyAllocated",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segmentState->get",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment0.currentlyAllocated",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "segmentState->get()->forOutput.size() == segmentState->get()->builders.size() + 1",
            "\"segmentState->forOutput wasn't resized correctly when the last builder was added.\"",
            "segmentState->get()->forOutput.size()",
            "segmentState->get()->builders.size()"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nkj::ArrayPtr<const kj::ArrayPtr<const word>> BuilderArena::getSegmentsForOutput() {\n  // Although this is a read-only method, we shouldn't need to lock a mutex here because if this\n  // is called multiple times simultaneously, we should only be overwriting the array with the\n  // exact same data.  If the number or size of segments is actually changing due to an activity\n  // in another thread, then the caller has a problem regardless of locking here.\n\n  KJ_IF_MAYBE(segmentState, moreSegments) {\n    KJ_DASSERT(segmentState->get()->forOutput.size() == segmentState->get()->builders.size() + 1,\n        \"segmentState->forOutput wasn't resized correctly when the last builder was added.\",\n        segmentState->get()->forOutput.size(), segmentState->get()->builders.size());\n\n    kj::ArrayPtr<kj::ArrayPtr<const word>> result(\n        &segmentState->get()->forOutput[0], segmentState->get()->forOutput.size());\n    uint i = 0;\n    result[i++] = segment0.currentlyAllocated();\n    for (auto& builder: segmentState->get()->builders) {\n      result[i++] = builder->currentlyAllocated();\n    }\n    return result;\n  } else {\n    if (segment0.getArena() == nullptr) {\n      // We haven't actually allocated any segments yet.\n      return nullptr;\n    } else {\n      // We have only one segment so far.\n      segment0ForOutput = segment0.currentlyAllocated();\n      return kj::arrayPtr(&segment0ForOutput, 1);\n    }\n  }\n}"
  },
  {
    "function_name": "BuilderArena::allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "168-204",
    "snippet": "BuilderArena::AllocateResult BuilderArena::allocate(WordCount amount) {\n  if (segment0.getArena() == nullptr) {\n    // We're allocating the first segment.\n    kj::ArrayPtr<word> ptr = message->allocateSegment(amount / WORDS);\n\n    // Re-allocate segment0 in-place.  This is a bit of a hack, but we have not returned any\n    // pointers to this segment yet, so it should be fine.\n    kj::dtor(segment0);\n    kj::ctor(segment0, this, SegmentId(0), ptr, &this->dummyLimiter);\n\n    segmentWithSpace = &segment0;\n    return AllocateResult { &segment0, segment0.allocate(amount) };\n  } else {\n    if (segmentWithSpace != nullptr) {\n      // Check if there is space in an existing segment.\n      // TODO(perf):  Check for available space in more than just the last segment.  We don't\n      //   want this to be O(n), though, so we'll need to maintain some sort of table.  Complicating\n      //   matters, we want SegmentBuilders::allocate() to be fast, so we can't update any such\n      //   table when allocation actually happens.  Instead, we could have a priority queue based\n      //   on the last-known available size, and then re-check the size when we pop segments off it\n      //   and shove them to the back of the queue if they have become too small.\n      word* attempt = segmentWithSpace->allocate(amount);\n      if (attempt != nullptr) {\n        return AllocateResult { segmentWithSpace, attempt };\n      }\n    }\n\n    // Need to allocate a new segment.\n    SegmentBuilder* result = addSegmentInternal(message->allocateSegment(amount / WORDS));\n\n    // Check this new segment first the next time we need to allocate.\n    segmentWithSpace = result;\n\n    // Allocating from the new segment is guaranteed to succeed since we made it big enough.\n    return AllocateResult { result, result->allocate(amount) };\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result->allocate",
          "args": [
            "amount"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addSegmentInternal",
          "args": [
            "message->allocateSegment(amount / WORDS)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->allocateSegment",
          "args": [
            "amount / WORDS"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "allocateSegment",
          "container": "TestInitMessageBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/message-test.c++",
          "lines": "55-60",
          "snippet": "kj::ArrayPtr<word> allocateSegment(uint minimumSize) override {\n    auto array = kj::heapArray<word>(minimumSize);\n    memset(array.begin(), 0, array.asBytes().size());\n    allocations.add(kj::mv(array));\n    return allocations.back();\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/array.h>",
            "#include \"test-util.h\"",
            "#include \"message.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/array.h>\n#include \"test-util.h\"\n#include \"message.h\"\n\nTestInitMessageBuilder {\n  kj::ArrayPtr<word> allocateSegment(uint minimumSize) override {\n      auto array = kj::heapArray<word>(minimumSize);\n      memset(array.begin(), 0, array.asBytes().size());\n      allocations.add(kj::mv(array));\n      return allocations.back();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segmentWithSpace->allocate",
          "args": [
            "amount"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment0.allocate",
          "args": [
            "amount"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::ctor",
          "args": [
            "segment0",
            "this",
            "SegmentId(0)",
            "ptr",
            "&this->dummyLimiter"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SegmentId",
          "args": [
            "0"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::dtor",
          "args": [
            "segment0"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "dtor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "738-740",
          "snippet": "inline void dtor(T& location) {\n  location.~T();\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline void dtor(T& location) {\n  location.~T();\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment0.getArena",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nBuilderArena::AllocateResult BuilderArena::allocate(WordCount amount) {\n  if (segment0.getArena() == nullptr) {\n    // We're allocating the first segment.\n    kj::ArrayPtr<word> ptr = message->allocateSegment(amount / WORDS);\n\n    // Re-allocate segment0 in-place.  This is a bit of a hack, but we have not returned any\n    // pointers to this segment yet, so it should be fine.\n    kj::dtor(segment0);\n    kj::ctor(segment0, this, SegmentId(0), ptr, &this->dummyLimiter);\n\n    segmentWithSpace = &segment0;\n    return AllocateResult { &segment0, segment0.allocate(amount) };\n  } else {\n    if (segmentWithSpace != nullptr) {\n      // Check if there is space in an existing segment.\n      // TODO(perf):  Check for available space in more than just the last segment.  We don't\n      //   want this to be O(n), though, so we'll need to maintain some sort of table.  Complicating\n      //   matters, we want SegmentBuilders::allocate() to be fast, so we can't update any such\n      //   table when allocation actually happens.  Instead, we could have a priority queue based\n      //   on the last-known available size, and then re-check the size when we pop segments off it\n      //   and shove them to the back of the queue if they have become too small.\n      word* attempt = segmentWithSpace->allocate(amount);\n      if (attempt != nullptr) {\n        return AllocateResult { segmentWithSpace, attempt };\n      }\n    }\n\n    // Need to allocate a new segment.\n    SegmentBuilder* result = addSegmentInternal(message->allocateSegment(amount / WORDS));\n\n    // Check this new segment first the next time we need to allocate.\n    segmentWithSpace = result;\n\n    // Allocating from the new segment is guaranteed to succeed since we made it big enough.\n    return AllocateResult { result, result->allocate(amount) };\n  }\n}"
  },
  {
    "function_name": "BuilderArena::~BuilderArena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "152-152",
    "snippet": "BuilderArena::~BuilderArena() noexcept(false) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nBuilderArena::~BuilderArena() noexcept(false) {}"
  },
  {
    "function_name": "BuilderArena::BuilderArena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "126-150",
    "snippet": "BuilderArena::BuilderArena(MessageBuilder* message,\n                           kj::ArrayPtr<MessageBuilder::SegmentInit> segments)\n    : message(message),\n      segment0(this, SegmentId(0), segments[0].space, &this->dummyLimiter, segments[0].wordsUsed) {\n  if (segments.size() > 1) {\n    kj::Vector<kj::Own<SegmentBuilder>> builders(segments.size() - 1);\n\n    uint i = 1;\n    for (auto& segment: segments.slice(1, segments.size())) {\n      builders.add(kj::heap<SegmentBuilder>(\n          this, SegmentId(i++), segment.space, &this->dummyLimiter, segment.wordsUsed));\n    }\n\n    kj::Vector<kj::ArrayPtr<const word>> forOutput;\n    forOutput.resize(segments.size());\n\n    segmentWithSpace = builders.back();\n\n    this->moreSegments = kj::heap<MultiSegmentState>(\n        MultiSegmentState { kj::mv(builders), kj::mv(forOutput) });\n\n  } else {\n    segmentWithSpace = &segment0;\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<MultiSegmentState>",
          "args": [
            "MultiSegmentState { kj::mv(builders), kj::mv(forOutput) }"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "forOutput"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "builders"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builders.back",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forOutput.resize",
          "args": [
            "segments.size()"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "96-104",
          "snippet": "inline void resize(size_t size) {\n    if (size > builder.capacity()) grow(size);\n    while (builder.size() < size) {\n      builder.add(T());\n    }\n    while (builder.size() > size) {\n      builder.removeLast();\n    }\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void resize(size_t size) {\n      if (size > builder.capacity()) grow(size);\n      while (builder.size() < size) {\n        builder.add(T());\n      }\n      while (builder.size() > size) {\n        builder.removeLast();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segments.size",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "builders.add",
          "args": [
            "kj::heap<SegmentBuilder>(\n          this, SegmentId(i++), segment.space, &this->dummyLimiter, segment.wordsUsed)"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heap<SegmentBuilder>",
          "args": [
            "this",
            "SegmentId(i++)",
            "segment.space",
            "&this->dummyLimiter",
            "segment.wordsUsed"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SegmentId",
          "args": [
            "i++"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segments.slice",
          "args": [
            "1",
            "segments.size()"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SegmentId",
          "args": [
            "0"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nBuilderArena::BuilderArena(MessageBuilder* message,\n                           kj::ArrayPtr<MessageBuilder::SegmentInit> segments)\n    : message(message),\n      segment0(this, SegmentId(0), segments[0].space, &this->dummyLimiter, segments[0].wordsUsed) {\n  if (segments.size() > 1) {\n    kj::Vector<kj::Own<SegmentBuilder>> builders(segments.size() - 1);\n\n    uint i = 1;\n    for (auto& segment: segments.slice(1, segments.size())) {\n      builders.add(kj::heap<SegmentBuilder>(\n          this, SegmentId(i++), segment.space, &this->dummyLimiter, segment.wordsUsed));\n    }\n\n    kj::Vector<kj::ArrayPtr<const word>> forOutput;\n    forOutput.resize(segments.size());\n\n    segmentWithSpace = builders.back();\n\n    this->moreSegments = kj::heap<MultiSegmentState>(\n        MultiSegmentState { kj::mv(builders), kj::mv(forOutput) });\n\n  } else {\n    segmentWithSpace = &segment0;\n  }\n}"
  },
  {
    "function_name": "BuilderArena::BuilderArena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "123-124",
    "snippet": "BuilderArena::BuilderArena(MessageBuilder* message)\n    : message(message), segment0(nullptr, SegmentId(0), nullptr, nullptr) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SegmentId",
          "args": [
            "0"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nBuilderArena::BuilderArena(MessageBuilder* message)\n    : message(message), segment0(nullptr, SegmentId(0), nullptr, nullptr) {}"
  },
  {
    "function_name": "ReaderArena::extractCap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "112-118",
    "snippet": "kj::Maybe<kj::Own<ClientHook>> ReaderArena::extractCap(uint index) {\n  if (index < capTable.size()) {\n    return capTable[index].map([](kj::Own<ClientHook>& cap) { return cap->addRef(); });\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capTable[index].map",
          "args": [
            "[](kj::Own<ClientHook>& cap) { return cap->addRef(); }"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1083-1089",
          "snippet": "auto map(Func&& f) -> Maybe<decltype(f(instance<T&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(*ptr);\n    }\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto map(Func&& f) -> Maybe<decltype(f(instance<T&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(*ptr);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "cap->addRef",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "addRef",
          "container": "BrokenClient",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "598-600",
          "snippet": "kj::Own<ClientHook> addRef() override {\n    return kj::addRef(*this);\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nBrokenClient {\n  kj::Own<ClientHook> addRef() override {\n      return kj::addRef(*this);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "capTable.size",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nkj::Maybe<kj::Own<ClientHook>> ReaderArena::extractCap(uint index) {\n  if (index < capTable.size()) {\n    return capTable[index].map([](kj::Own<ClientHook>& cap) { return cap->addRef(); });\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "ReaderArena::reportReadLimitReached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "105-109",
    "snippet": "void ReaderArena::reportReadLimitReached() {\n  KJ_FAIL_REQUIRE(\"Exceeded message traversal limit.  See capnp::ReaderOptions.\") {\n    return;\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Exceeded message traversal limit.  See capnp::ReaderOptions.\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nvoid ReaderArena::reportReadLimitReached() {\n  KJ_FAIL_REQUIRE(\"Exceeded message traversal limit.  See capnp::ReaderOptions.\") {\n    return;\n  }\n}"
  },
  {
    "function_name": "ReaderArena::~ReaderArena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "65-65",
    "snippet": "ReaderArena::~ReaderArena() noexcept(false) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nReaderArena::~ReaderArena() noexcept(false) {}"
  },
  {
    "function_name": "ReaderArena::ReaderArena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "60-63",
    "snippet": "ReaderArena::ReaderArena(MessageReader* message)\n    : message(message),\n      readLimiter(message->getOptions().traversalLimitInWords * WORDS),\n      segment0(this, SegmentId(0), message->getSegment(0), &readLimiter) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message->getSegment",
          "args": [
            "0"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "getSegment",
          "container": "AsyncMessageReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async.c++",
          "lines": "40-47",
          "snippet": "kj::ArrayPtr<const word> getSegment(uint id) override {\n    if (id >= segmentCount()) {\n      return nullptr;\n    } else {\n      uint32_t size = id == 0 ? segment0Size() : moreSizes[id - 1].get();\n      return kj::arrayPtr(segmentStarts[id], size);\n    }\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n\nAsyncMessageReader {\n  kj::ArrayPtr<const word> getSegment(uint id) override {\n      if (id >= segmentCount()) {\n        return nullptr;\n      } else {\n        uint32_t size = id == 0 ? segment0Size() : moreSizes[id - 1].get();\n        return kj::arrayPtr(segmentStarts[id], size);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SegmentId",
          "args": [
            "0"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message->getOptions",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nReaderArena::ReaderArena(MessageReader* message)\n    : message(message),\n      readLimiter(message->getOptions().traversalLimitInWords * WORDS),\n      segment0(this, SegmentId(0), message->getSegment(0), &readLimiter) {}"
  },
  {
    "function_name": "SegmentBuilder::throwNotWritable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "51-56",
    "snippet": "void SegmentBuilder::throwNotWritable() {\n  KJ_FAIL_REQUIRE(\n      \"Tried to form a Builder to an external data segment referenced by the MessageBuilder.  \"\n      \"When you use Orphanage::reference*(), you are not allowed to obtain Builders to the \"\n      \"referenced data, only Readers, because that data is const.\");\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Tried to form a Builder to an external data segment referenced by the MessageBuilder.  \"\n      \"When you use Orphanage::reference*(), you are not allowed to obtain Builders to the \"\n      \"referenced data, only Readers, because that data is const.\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nvoid SegmentBuilder::throwNotWritable() {\n  KJ_FAIL_REQUIRE(\n      \"Tried to form a Builder to an external data segment referenced by the MessageBuilder.  \"\n      \"When you use Orphanage::reference*(), you are not allowed to obtain Builders to the \"\n      \"referenced data, only Readers, because that data is const.\");\n}"
  },
  {
    "function_name": "ReadLimiter::unread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "40-49",
    "snippet": "void ReadLimiter::unread(WordCount64 amount) {\n  // Be careful not to overflow here.  Since ReadLimiter has no thread-safety, it's possible that\n  // the limit value was not updated correctly for one or more reads, and therefore unread() could\n  // overflow it even if it is only unreading bytes that were actually read.\n  uint64_t oldValue = limit;\n  uint64_t newValue = oldValue + amount / WORDS;\n  if (newValue > oldValue) {\n    limit = newValue;\n  }\n}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nvoid ReadLimiter::unread(WordCount64 amount) {\n  // Be careful not to overflow here.  Since ReadLimiter has no thread-safety, it's possible that\n  // the limit value was not updated correctly for one or more reads, and therefore unread() could\n  // overflow it even if it is only unreading bytes that were actually read.\n  uint64_t oldValue = limit;\n  uint64_t newValue = oldValue + amount / WORDS;\n  if (newValue > oldValue) {\n    limit = newValue;\n  }\n}"
  },
  {
    "function_name": "Arena::~Arena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/arena.c++",
    "lines": "38-38",
    "snippet": "Arena::~Arena() noexcept(false) {}",
    "includes": [
      "#include \"capability.h\"",
      "#include <stdio.h>",
      "#include <string.h>",
      "#include <vector>",
      "#include <kj/refcount.h>",
      "#include <kj/debug.h>",
      "#include \"message.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"capability.h\"\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <kj/refcount.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"arena.h\"\n\nArena::~Arena() noexcept(false) {}"
  }
]