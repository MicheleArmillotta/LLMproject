[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-client.c++",
    "lines": "42-367",
    "snippet": "int main(int argc, const char* argv[]) {\n  if (argc != 2) {\n    std::cerr << \"usage: \" << argv[0] << \" HOST:PORT\\n\"\n        \"Connects to the Calculator server at the given address and \"\n        \"does some RPCs.\" << std::endl;\n    return 1;\n  }\n\n  capnp::EzRpcClient client(argv[1]);\n  Calculator::Client calculator = client.getMain<Calculator>();\n\n  // Keep an eye on `waitScope`.  Whenever you see it used is a place where we\n  // stop and wait for the server to respond.  If a line of code does not use\n  // `waitScope`, then it does not block!\n  auto& waitScope = client.getWaitScope();\n\n  {\n    // Make a request that just evaluates the literal value 123.\n    //\n    // What's interesting here is that evaluate() returns a \"Value\", which is\n    // another interface and therefore points back to an object living on the\n    // server.  We then have to call read() on that object to read it.\n    // However, even though we are making two RPC's, this block executes in\n    // *one* network round trip because of promise pipelining:  we do not wait\n    // for the first call to complete before we send the second call to the\n    // server.\n\n    std::cout << \"Evaluating a literal... \";\n    std::cout.flush();\n\n    // Set up the request.\n    auto request = calculator.evaluateRequest();\n    request.getExpression().setLiteral(123);\n\n    // Send it, which returns a promise for the result (without blocking).\n    auto evalPromise = request.send();\n\n    // Using the promise, create a pipelined request to call read() on the\n    // returned object, and then send that.\n    auto readPromise = evalPromise.getValue().readRequest().send();\n\n    // Now that we've sent all the requests, wait for the response.  Until this\n    // point, we haven't waited at all!\n    auto response = readPromise.wait(waitScope);\n    KJ_ASSERT(response.getValue() == 123);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  {\n    // Make a request to evaluate 123 + 45 - 67.\n    //\n    // The Calculator interface requires that we first call getOperator() to\n    // get the addition and subtraction functions, then call evaluate() to use\n    // them.  But, once again, we can get both functions, call evaluate(), and\n    // then read() the result -- four RPCs -- in the time of *one* network\n    // round trip, because of promise pipelining.\n\n    std::cout << \"Using add and subtract... \";\n    std::cout.flush();\n\n    Calculator::Function::Client add = nullptr;\n    Calculator::Function::Client subtract = nullptr;\n\n    {\n      // Get the \"add\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::ADD);\n      add = request.send().getFunc();\n    }\n\n    {\n      // Get the \"subtract\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::SUBTRACT);\n      subtract = request.send().getFunc();\n    }\n\n    // Build the request to evaluate 123 + 45 - 67.\n    auto request = calculator.evaluateRequest();\n\n    auto subtractCall = request.getExpression().initCall();\n    subtractCall.setFunction(subtract);\n    auto subtractParams = subtractCall.initParams(2);\n    subtractParams[1].setLiteral(67);\n\n    auto addCall = subtractParams[0].initCall();\n    addCall.setFunction(add);\n    auto addParams = addCall.initParams(2);\n    addParams[0].setLiteral(123);\n    addParams[1].setLiteral(45);\n\n    // Send the evaluate() request, read() the result, and wait for read() to\n    // finish.\n    auto evalPromise = request.send();\n    auto readPromise = evalPromise.getValue().readRequest().send();\n\n    auto response = readPromise.wait(waitScope);\n    KJ_ASSERT(response.getValue() == 101);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  {\n    // Make a request to evaluate 4 * 6, then use the result in two more\n    // requests that add 3 and 5.\n    //\n    // Since evaluate() returns its result wrapped in a `Value`, we can pass\n    // that `Value` back to the server in subsequent requests before the first\n    // `evaluate()` has actually returned.  Thus, this example again does only\n    // one network round trip.\n\n    std::cout << \"Pipelining eval() calls... \";\n    std::cout.flush();\n\n    Calculator::Function::Client add = nullptr;\n    Calculator::Function::Client multiply = nullptr;\n\n    {\n      // Get the \"add\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::ADD);\n      add = request.send().getFunc();\n    }\n\n    {\n      // Get the \"multiply\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::MULTIPLY);\n      multiply = request.send().getFunc();\n    }\n\n    // Build the request to evaluate 4 * 6\n    auto request = calculator.evaluateRequest();\n\n    auto multiplyCall = request.getExpression().initCall();\n    multiplyCall.setFunction(multiply);\n    auto multiplyParams = multiplyCall.initParams(2);\n    multiplyParams[0].setLiteral(4);\n    multiplyParams[1].setLiteral(6);\n\n    auto multiplyResult = request.send().getValue();\n\n    // Use the result in two calls that add 3 and add 5.\n\n    auto add3Request = calculator.evaluateRequest();\n    auto add3Call = add3Request.getExpression().initCall();\n    add3Call.setFunction(add);\n    auto add3Params = add3Call.initParams(2);\n    add3Params[0].setPreviousResult(multiplyResult);\n    add3Params[1].setLiteral(3);\n    auto add3Promise = add3Request.send().getValue().readRequest().send();\n\n    auto add5Request = calculator.evaluateRequest();\n    auto add5Call = add5Request.getExpression().initCall();\n    add5Call.setFunction(add);\n    auto add5Params = add5Call.initParams(2);\n    add5Params[0].setPreviousResult(multiplyResult);\n    add5Params[1].setLiteral(5);\n    auto add5Promise = add5Request.send().getValue().readRequest().send();\n\n    // Now wait for the results.\n    KJ_ASSERT(add3Promise.wait(waitScope).getValue() == 27);\n    KJ_ASSERT(add5Promise.wait(waitScope).getValue() == 29);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  {\n    // Our calculator interface supports defining functions.  Here we use it\n    // to define two functions and then make calls to them as follows:\n    //\n    //   f(x, y) = x * 100 + y\n    //   g(x) = f(x, x + 1) * 2;\n    //   f(12, 34)\n    //   g(21)\n    //\n    // Once again, the whole thing takes only one network round trip.\n\n    std::cout << \"Defining functions... \";\n    std::cout.flush();\n\n    Calculator::Function::Client add = nullptr;\n    Calculator::Function::Client multiply = nullptr;\n    Calculator::Function::Client f = nullptr;\n    Calculator::Function::Client g = nullptr;\n\n    {\n      // Get the \"add\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::ADD);\n      add = request.send().getFunc();\n    }\n\n    {\n      // Get the \"multiply\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::MULTIPLY);\n      multiply = request.send().getFunc();\n    }\n\n    {\n      // Define f.\n      auto request = calculator.defFunctionRequest();\n      request.setParamCount(2);\n\n      {\n        // Build the function body.\n        auto addCall = request.getBody().initCall();\n        addCall.setFunction(add);\n        auto addParams = addCall.initParams(2);\n        addParams[1].setParameter(1);  // y\n\n        auto multiplyCall = addParams[0].initCall();\n        multiplyCall.setFunction(multiply);\n        auto multiplyParams = multiplyCall.initParams(2);\n        multiplyParams[0].setParameter(0);  // x\n        multiplyParams[1].setLiteral(100);\n      }\n\n      f = request.send().getFunc();\n    }\n\n    {\n      // Define g.\n      auto request = calculator.defFunctionRequest();\n      request.setParamCount(1);\n\n      {\n        // Build the function body.\n        auto multiplyCall = request.getBody().initCall();\n        multiplyCall.setFunction(multiply);\n        auto multiplyParams = multiplyCall.initParams(2);\n        multiplyParams[1].setLiteral(2);\n\n        auto fCall = multiplyParams[0].initCall();\n        fCall.setFunction(f);\n        auto fParams = fCall.initParams(2);\n        fParams[0].setParameter(0);\n\n        auto addCall = fParams[1].initCall();\n        addCall.setFunction(add);\n        auto addParams = addCall.initParams(2);\n        addParams[0].setParameter(0);\n        addParams[1].setLiteral(1);\n      }\n\n      g = request.send().getFunc();\n    }\n\n    // OK, we've defined all our functions.  Now create our eval requests.\n\n    // f(12, 34)\n    auto fEvalRequest = calculator.evaluateRequest();\n    auto fCall = fEvalRequest.initExpression().initCall();\n    fCall.setFunction(f);\n    auto fParams = fCall.initParams(2);\n    fParams[0].setLiteral(12);\n    fParams[1].setLiteral(34);\n    auto fEvalPromise = fEvalRequest.send().getValue().readRequest().send();\n\n    // g(21)\n    auto gEvalRequest = calculator.evaluateRequest();\n    auto gCall = gEvalRequest.initExpression().initCall();\n    gCall.setFunction(g);\n    gCall.initParams(1)[0].setLiteral(21);\n    auto gEvalPromise = gEvalRequest.send().getValue().readRequest().send();\n\n    // Wait for the results.\n    KJ_ASSERT(fEvalPromise.wait(waitScope).getValue() == 1234);\n    KJ_ASSERT(gEvalPromise.wait(waitScope).getValue() == 4244);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  {\n    // Make a request that will call back to a function defined locally.\n    //\n    // Specifically, we will compute 2^(4 + 5).  However, exponent is not\n    // defined by the Calculator server.  So, we'll implement the Function\n    // interface locally and pass it to the server for it to use when\n    // evaluating the expression.\n    //\n    // This example requires two network round trips to complete, because the\n    // server calls back to the client once before finishing.  In this\n    // particular case, this could potentially be optimized by using a tail\n    // call on the server side -- see CallContext::tailCall().  However, to\n    // keep the example simpler, we haven't implemented this optimization in\n    // the sample server.\n\n    std::cout << \"Using a callback... \";\n    std::cout.flush();\n\n    Calculator::Function::Client add = nullptr;\n\n    {\n      // Get the \"add\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::ADD);\n      add = request.send().getFunc();\n    }\n\n    // Build the eval request for 2^(4+5).\n    auto request = calculator.evaluateRequest();\n\n    auto powCall = request.getExpression().initCall();\n    powCall.setFunction(kj::heap<PowerFunction>());\n    auto powParams = powCall.initParams(2);\n    powParams[0].setLiteral(2);\n\n    auto addCall = powParams[1].initCall();\n    addCall.setFunction(add);\n    auto addParams = addCall.initParams(2);\n    addParams[0].setLiteral(4);\n    addParams[1].setLiteral(5);\n\n    // Send the request and wait.\n    auto response = request.send().getValue().readRequest()\n                           .send().wait(waitScope);\n    KJ_ASSERT(response.getValue() == 512);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  return 0;\n}",
    "includes": [
      "#include <iostream>",
      "#include <math.h>",
      "#include <kj/debug.h>",
      "#include <capnp/ez-rpc.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "response.getValue() == 512"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getValue",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [
            "waitScope"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1329-1364",
          "snippet": "RemotePromise<AnyPointer> send() override {\n      if (!connectionState->connection.is<Connected>()) {\n        // Connection is broken.\n        const kj::Exception& e = connectionState->connection.get<Disconnected>();\n        return RemotePromise<AnyPointer>(\n            kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n            AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n      }\n\n      KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n        // Whoops, this capability has been redirected while we were building the request!\n        // We'll have to make a new request and do a copy.  Ick.\n\n        auto replacement = redirect->get()->newCall(\n            callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n        replacement.set(paramsBuilder);\n        return replacement.send();\n      } else {\n        auto sendResult = sendInternal(false);\n\n        auto forkedPromise = sendResult.promise.fork();\n\n        // The pipeline must get notified of resolution before the app does to maintain ordering.\n        auto pipeline = kj::refcounted<RpcPipeline>(\n            *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n\n        auto appPromise = forkedPromise.addBranch().then(\n            [=](kj::Own<RpcResponse>&& response) {\n              auto reader = response->getResults();\n              return Response<AnyPointer>(reader, kj::mv(response));\n            });\n\n        return RemotePromise<AnyPointer>(\n            kj::mv(appPromise),\n            AnyPointer::Pipeline(kj::mv(pipeline)));\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<IncomingRpcMessage>> request;",
            "kj::Maybe<kj::Own<RpcServerResponse>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nkj::Maybe<kj::Own<IncomingRpcMessage>> request;\nkj::Maybe<kj::Own<RpcServerResponse>> response;\n\nRpcRequest {\n  RemotePromise<AnyPointer> send() override {\n        if (!connectionState->connection.is<Connected>()) {\n          // Connection is broken.\n          const kj::Exception& e = connectionState->connection.get<Disconnected>();\n          return RemotePromise<AnyPointer>(\n              kj::Promise<Response<AnyPointer>>(kj::cp(e)),\n              AnyPointer::Pipeline(newBrokenPipeline(kj::cp(e))));\n        }\n  \n        KJ_IF_MAYBE(redirect, target->writeTarget(callBuilder.getTarget())) {\n          // Whoops, this capability has been redirected while we were building the request!\n          // We'll have to make a new request and do a copy.  Ick.\n  \n          auto replacement = redirect->get()->newCall(\n              callBuilder.getInterfaceId(), callBuilder.getMethodId(), paramsBuilder.targetSize());\n          replacement.set(paramsBuilder);\n          return replacement.send();\n        } else {\n          auto sendResult = sendInternal(false);\n  \n          auto forkedPromise = sendResult.promise.fork();\n  \n          // The pipeline must get notified of resolution before the app does to maintain ordering.\n          auto pipeline = kj::refcounted<RpcPipeline>(\n              *connectionState, kj::mv(sendResult.questionRef), forkedPromise.addBranch());\n  \n          auto appPromise = forkedPromise.addBranch().then(\n              [=](kj::Own<RpcResponse>&& response) {\n                auto reader = response->getResults();\n                return Response<AnyPointer>(reader, kj::mv(response));\n              });\n  \n          return RemotePromise<AnyPointer>(\n              kj::mv(appPromise),\n              AnyPointer::Pipeline(kj::mv(pipeline)));\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.send",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "83-95",
          "snippet": "void send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nvoid send() override {\n    network.previousWrite = KJ_ASSERT_NONNULL(network.previousWrite, \"already shut down\")\n        .then([&]() {\n      // Note that if the write fails, all further writes will be skipped due to the exception.\n      // We never actually handle this exception because we assume the read end will fail as well\n      // and it's cleaner to handle the failure there.\n      return writeMessage(network.stream, message);\n    }).attach(kj::addRef(*this))\n      // Note that it's important that the eagerlyEvaluate() come *after* the attach() because\n      // otherwise the message (and any capabilities in it) will not be released until a new\n      // message is written! (Kenton once spent all afternoon tracking this down...)\n      .eagerlyEvaluate(nullptr);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "addParams[1].setLiteral",
          "args": [
            "5"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addParams[0].setLiteral",
          "args": [
            "4"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCall.initParams",
          "args": [
            "2"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCall.setFunction",
          "args": [
            "add"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powParams[1].initCall",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powParams[0].setLiteral",
          "args": [
            "2"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powCall.initParams",
          "args": [
            "2"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "powCall.setFunction",
          "args": [
            "kj::heap<PowerFunction>()"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<PowerFunction>",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "321-328",
          "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "request.getExpression",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getExpression",
          "args": [],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.evaluateRequest",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setOp",
          "args": [
            "Calculator::Operator::ADD"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.getOperatorRequest",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::cout.flush",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "flush",
          "container": "MockExceptionCallback",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/debug-test.c++",
          "lines": "108-127",
          "snippet": "void flush() {\n    if (outputPipe != -1) {\n      const char* pos = &*text.begin();\n      const char* end = pos + text.size();\n\n      while (pos < end) {\n        miniposix::ssize_t n = miniposix::write(outputPipe, pos, end - pos);\n        if (n < 0) {\n          if (errno == EINTR) {\n            continue;\n          } else {\n            break;  // Give up on error.\n          }\n        }\n        pos += n;\n      }\n\n      text.clear();\n    }\n  }",
          "includes": [
            "#include <sys/wait.h>",
            "#include \"miniposix.h\"",
            "#include <exception>",
            "#include <string.h>",
            "#include <errno.h>",
            "#include <signal.h>",
            "#include <stdio.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include \"exception.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/wait.h>\n#include \"miniposix.h\"\n#include <exception>\n#include <string.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include \"exception.h\"\n#include \"debug.h\"\n\nMockExceptionCallback {\n  void flush() {\n      if (outputPipe != -1) {\n        const char* pos = &*text.begin();\n        const char* end = pos + text.size();\n  \n        while (pos < end) {\n          miniposix::ssize_t n = miniposix::write(outputPipe, pos, end - pos);\n          if (n < 0) {\n            if (errno == EINTR) {\n              continue;\n            } else {\n              break;  // Give up on error.\n            }\n          }\n          pos += n;\n        }\n  \n        text.clear();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "gEvalPromise.wait(waitScope).getValue() == 4244"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gEvalPromise.wait",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "DummyEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-test.c++",
          "lines": "666-666",
          "snippet": "bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"debug.h\"\n#include \"async.h\"\n\nDummyEventPort {\n  bool wait() override { KJ_FAIL_ASSERT(\"Nothing to wait for.\"); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gEvalPromise.wait",
          "args": [
            "waitScope"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "fEvalPromise.wait(waitScope).getValue() == 1234"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fEvalPromise.wait",
          "args": [
            "waitScope"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gCall.initParams",
          "args": [
            "21"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gCall.initParams",
          "args": [
            "1"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gCall.setFunction",
          "args": [
            "g"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gEvalRequest.initExpression",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gEvalRequest.initExpression",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.evaluateRequest",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fParams[1].setLiteral",
          "args": [
            "34"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fParams[0].setLiteral",
          "args": [
            "12"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fCall.initParams",
          "args": [
            "2"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fCall.setFunction",
          "args": [
            "f"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fEvalRequest.initExpression",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fEvalRequest.initExpression",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.evaluateRequest",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addParams[1].setLiteral",
          "args": [
            "1"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addParams[0].setParameter",
          "args": [
            "0"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCall.initParams",
          "args": [
            "2"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCall.setFunction",
          "args": [
            "add"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fParams[1].initCall",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fParams[0].setParameter",
          "args": [
            "0"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fCall.initParams",
          "args": [
            "2"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fCall.setFunction",
          "args": [
            "f"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyParams[0].initCall",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyParams[1].setLiteral",
          "args": [
            "2"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyCall.initParams",
          "args": [
            "2"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyCall.setFunction",
          "args": [
            "multiply"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getBody",
          "args": [],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "getBody",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc-twoparty.c++",
          "lines": "106-108",
          "snippet": "AnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }",
          "includes": [
            "#include <kj/debug.h>",
            "#include \"serialize-async.h\"",
            "#include \"rpc-twoparty.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/debug.h>\n#include \"serialize-async.h\"\n#include \"rpc-twoparty.h\"\n\nAnyPointer::Reader getBody() override {\n    return message->getRoot<AnyPointer>();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "request.setParamCount",
          "args": [
            "1"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.defFunctionRequest",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyParams[1].setLiteral",
          "args": [
            "100"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyParams[0].setParameter",
          "args": [
            "0"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyCall.initParams",
          "args": [
            "2"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyCall.setFunction",
          "args": [
            "multiply"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addParams[0].initCall",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addParams[1].setParameter",
          "args": [
            "1"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCall.initParams",
          "args": [
            "2"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCall.setFunction",
          "args": [
            "add"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setParamCount",
          "args": [
            "2"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.defFunctionRequest",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setOp",
          "args": [
            "Calculator::Operator::MULTIPLY"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.getOperatorRequest",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setOp",
          "args": [
            "Calculator::Operator::ADD"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.getOperatorRequest",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "add5Promise.wait(waitScope).getValue() == 29"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add5Promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "add3Promise.wait(waitScope).getValue() == 27"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add3Promise.wait",
          "args": [
            "waitScope"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add5Params[1].setLiteral",
          "args": [
            "5"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add5Params[0].setPreviousResult",
          "args": [
            "multiplyResult"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add5Call.initParams",
          "args": [
            "2"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add5Call.setFunction",
          "args": [
            "add"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add5Request.getExpression",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add5Request.getExpression",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.evaluateRequest",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add3Params[1].setLiteral",
          "args": [
            "3"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add3Params[0].setPreviousResult",
          "args": [
            "multiplyResult"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add3Call.initParams",
          "args": [
            "2"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add3Call.setFunction",
          "args": [
            "add"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add3Request.getExpression",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add3Request.getExpression",
          "args": [],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.evaluateRequest",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyParams[1].setLiteral",
          "args": [
            "6"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyParams[0].setLiteral",
          "args": [
            "4"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyCall.initParams",
          "args": [
            "2"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "multiplyCall.setFunction",
          "args": [
            "multiply"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getExpression",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getExpression",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.evaluateRequest",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setOp",
          "args": [
            "Calculator::Operator::MULTIPLY"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.getOperatorRequest",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setOp",
          "args": [
            "Calculator::Operator::ADD"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.getOperatorRequest",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "response.getValue() == 101"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getValue",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readPromise.wait",
          "args": [
            "waitScope"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalPromise.getValue",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalPromise.getValue",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalPromise.getValue",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addParams[1].setLiteral",
          "args": [
            "45"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addParams[0].setLiteral",
          "args": [
            "123"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCall.initParams",
          "args": [
            "2"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addCall.setFunction",
          "args": [
            "add"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subtractParams[0].initCall",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subtractParams[1].setLiteral",
          "args": [
            "67"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subtractCall.initParams",
          "args": [
            "2"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "subtractCall.setFunction",
          "args": [
            "subtract"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getExpression",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getExpression",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.evaluateRequest",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setOp",
          "args": [
            "Calculator::Operator::SUBTRACT"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.getOperatorRequest",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.setOp",
          "args": [
            "Calculator::Operator::ADD"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.getOperatorRequest",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "response.getValue() == 123"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "response.getValue",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readPromise.wait",
          "args": [
            "waitScope"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalPromise.getValue",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalPromise.getValue",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evalPromise.getValue",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getExpression",
          "args": [
            "123"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getExpression",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calculator.evaluateRequest",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getWaitScope",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client.getMain<Calculator>",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "getMain",
          "container": "EvolutionTestMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/evolution-test.c++",
          "lines": "846-854",
          "snippet": "kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"(unknown version)\",\n        \"Integration test / fuzzer which randomly modifies schemas is backwards-compatible ways \"\n        \"and verifies that they do actually remain compatible.\")\n        .addOptionWithArg({\"seed\"}, KJ_BIND_METHOD(*this, setSeed), \"<num>\",\n            \"Set random number seed to <num>.  By default, time() is used.\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }",
          "includes": [
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/main.h>",
            "#include <time.h>",
            "#include <stdlib.h>",
            "#include <kj/debug.h>",
            "#include <kj/function.h>",
            "#include \"compiler.h\"",
            "#include <capnp/pretty-print.h>",
            "#include <capnp/message.h>",
            "#include <capnp/schema-loader.h>",
            "#include <capnp/compiler/grammar.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <kj/io.h>\n#include <kj/main.h>\n#include <time.h>\n#include <stdlib.h>\n#include <kj/debug.h>\n#include <kj/function.h>\n#include \"compiler.h\"\n#include <capnp/pretty-print.h>\n#include <capnp/message.h>\n#include <capnp/schema-loader.h>\n#include <capnp/compiler/grammar.capnp.h>\n\nEvolutionTestMain {\n  kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"(unknown version)\",\n          \"Integration test / fuzzer which randomly modifies schemas is backwards-compatible ways \"\n          \"and verifies that they do actually remain compatible.\")\n          .addOptionWithArg({\"seed\"}, KJ_BIND_METHOD(*this, setSeed), \"<num>\",\n              \"Set random number seed to <num>.  By default, time() is used.\")\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <math.h>\n#include <kj/debug.h>\n#include <capnp/ez-rpc.h>\n#include \"calculator.capnp.h\"\n\nint main(int argc, const char* argv[]) {\n  if (argc != 2) {\n    std::cerr << \"usage: \" << argv[0] << \" HOST:PORT\\n\"\n        \"Connects to the Calculator server at the given address and \"\n        \"does some RPCs.\" << std::endl;\n    return 1;\n  }\n\n  capnp::EzRpcClient client(argv[1]);\n  Calculator::Client calculator = client.getMain<Calculator>();\n\n  // Keep an eye on `waitScope`.  Whenever you see it used is a place where we\n  // stop and wait for the server to respond.  If a line of code does not use\n  // `waitScope`, then it does not block!\n  auto& waitScope = client.getWaitScope();\n\n  {\n    // Make a request that just evaluates the literal value 123.\n    //\n    // What's interesting here is that evaluate() returns a \"Value\", which is\n    // another interface and therefore points back to an object living on the\n    // server.  We then have to call read() on that object to read it.\n    // However, even though we are making two RPC's, this block executes in\n    // *one* network round trip because of promise pipelining:  we do not wait\n    // for the first call to complete before we send the second call to the\n    // server.\n\n    std::cout << \"Evaluating a literal... \";\n    std::cout.flush();\n\n    // Set up the request.\n    auto request = calculator.evaluateRequest();\n    request.getExpression().setLiteral(123);\n\n    // Send it, which returns a promise for the result (without blocking).\n    auto evalPromise = request.send();\n\n    // Using the promise, create a pipelined request to call read() on the\n    // returned object, and then send that.\n    auto readPromise = evalPromise.getValue().readRequest().send();\n\n    // Now that we've sent all the requests, wait for the response.  Until this\n    // point, we haven't waited at all!\n    auto response = readPromise.wait(waitScope);\n    KJ_ASSERT(response.getValue() == 123);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  {\n    // Make a request to evaluate 123 + 45 - 67.\n    //\n    // The Calculator interface requires that we first call getOperator() to\n    // get the addition and subtraction functions, then call evaluate() to use\n    // them.  But, once again, we can get both functions, call evaluate(), and\n    // then read() the result -- four RPCs -- in the time of *one* network\n    // round trip, because of promise pipelining.\n\n    std::cout << \"Using add and subtract... \";\n    std::cout.flush();\n\n    Calculator::Function::Client add = nullptr;\n    Calculator::Function::Client subtract = nullptr;\n\n    {\n      // Get the \"add\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::ADD);\n      add = request.send().getFunc();\n    }\n\n    {\n      // Get the \"subtract\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::SUBTRACT);\n      subtract = request.send().getFunc();\n    }\n\n    // Build the request to evaluate 123 + 45 - 67.\n    auto request = calculator.evaluateRequest();\n\n    auto subtractCall = request.getExpression().initCall();\n    subtractCall.setFunction(subtract);\n    auto subtractParams = subtractCall.initParams(2);\n    subtractParams[1].setLiteral(67);\n\n    auto addCall = subtractParams[0].initCall();\n    addCall.setFunction(add);\n    auto addParams = addCall.initParams(2);\n    addParams[0].setLiteral(123);\n    addParams[1].setLiteral(45);\n\n    // Send the evaluate() request, read() the result, and wait for read() to\n    // finish.\n    auto evalPromise = request.send();\n    auto readPromise = evalPromise.getValue().readRequest().send();\n\n    auto response = readPromise.wait(waitScope);\n    KJ_ASSERT(response.getValue() == 101);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  {\n    // Make a request to evaluate 4 * 6, then use the result in two more\n    // requests that add 3 and 5.\n    //\n    // Since evaluate() returns its result wrapped in a `Value`, we can pass\n    // that `Value` back to the server in subsequent requests before the first\n    // `evaluate()` has actually returned.  Thus, this example again does only\n    // one network round trip.\n\n    std::cout << \"Pipelining eval() calls... \";\n    std::cout.flush();\n\n    Calculator::Function::Client add = nullptr;\n    Calculator::Function::Client multiply = nullptr;\n\n    {\n      // Get the \"add\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::ADD);\n      add = request.send().getFunc();\n    }\n\n    {\n      // Get the \"multiply\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::MULTIPLY);\n      multiply = request.send().getFunc();\n    }\n\n    // Build the request to evaluate 4 * 6\n    auto request = calculator.evaluateRequest();\n\n    auto multiplyCall = request.getExpression().initCall();\n    multiplyCall.setFunction(multiply);\n    auto multiplyParams = multiplyCall.initParams(2);\n    multiplyParams[0].setLiteral(4);\n    multiplyParams[1].setLiteral(6);\n\n    auto multiplyResult = request.send().getValue();\n\n    // Use the result in two calls that add 3 and add 5.\n\n    auto add3Request = calculator.evaluateRequest();\n    auto add3Call = add3Request.getExpression().initCall();\n    add3Call.setFunction(add);\n    auto add3Params = add3Call.initParams(2);\n    add3Params[0].setPreviousResult(multiplyResult);\n    add3Params[1].setLiteral(3);\n    auto add3Promise = add3Request.send().getValue().readRequest().send();\n\n    auto add5Request = calculator.evaluateRequest();\n    auto add5Call = add5Request.getExpression().initCall();\n    add5Call.setFunction(add);\n    auto add5Params = add5Call.initParams(2);\n    add5Params[0].setPreviousResult(multiplyResult);\n    add5Params[1].setLiteral(5);\n    auto add5Promise = add5Request.send().getValue().readRequest().send();\n\n    // Now wait for the results.\n    KJ_ASSERT(add3Promise.wait(waitScope).getValue() == 27);\n    KJ_ASSERT(add5Promise.wait(waitScope).getValue() == 29);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  {\n    // Our calculator interface supports defining functions.  Here we use it\n    // to define two functions and then make calls to them as follows:\n    //\n    //   f(x, y) = x * 100 + y\n    //   g(x) = f(x, x + 1) * 2;\n    //   f(12, 34)\n    //   g(21)\n    //\n    // Once again, the whole thing takes only one network round trip.\n\n    std::cout << \"Defining functions... \";\n    std::cout.flush();\n\n    Calculator::Function::Client add = nullptr;\n    Calculator::Function::Client multiply = nullptr;\n    Calculator::Function::Client f = nullptr;\n    Calculator::Function::Client g = nullptr;\n\n    {\n      // Get the \"add\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::ADD);\n      add = request.send().getFunc();\n    }\n\n    {\n      // Get the \"multiply\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::MULTIPLY);\n      multiply = request.send().getFunc();\n    }\n\n    {\n      // Define f.\n      auto request = calculator.defFunctionRequest();\n      request.setParamCount(2);\n\n      {\n        // Build the function body.\n        auto addCall = request.getBody().initCall();\n        addCall.setFunction(add);\n        auto addParams = addCall.initParams(2);\n        addParams[1].setParameter(1);  // y\n\n        auto multiplyCall = addParams[0].initCall();\n        multiplyCall.setFunction(multiply);\n        auto multiplyParams = multiplyCall.initParams(2);\n        multiplyParams[0].setParameter(0);  // x\n        multiplyParams[1].setLiteral(100);\n      }\n\n      f = request.send().getFunc();\n    }\n\n    {\n      // Define g.\n      auto request = calculator.defFunctionRequest();\n      request.setParamCount(1);\n\n      {\n        // Build the function body.\n        auto multiplyCall = request.getBody().initCall();\n        multiplyCall.setFunction(multiply);\n        auto multiplyParams = multiplyCall.initParams(2);\n        multiplyParams[1].setLiteral(2);\n\n        auto fCall = multiplyParams[0].initCall();\n        fCall.setFunction(f);\n        auto fParams = fCall.initParams(2);\n        fParams[0].setParameter(0);\n\n        auto addCall = fParams[1].initCall();\n        addCall.setFunction(add);\n        auto addParams = addCall.initParams(2);\n        addParams[0].setParameter(0);\n        addParams[1].setLiteral(1);\n      }\n\n      g = request.send().getFunc();\n    }\n\n    // OK, we've defined all our functions.  Now create our eval requests.\n\n    // f(12, 34)\n    auto fEvalRequest = calculator.evaluateRequest();\n    auto fCall = fEvalRequest.initExpression().initCall();\n    fCall.setFunction(f);\n    auto fParams = fCall.initParams(2);\n    fParams[0].setLiteral(12);\n    fParams[1].setLiteral(34);\n    auto fEvalPromise = fEvalRequest.send().getValue().readRequest().send();\n\n    // g(21)\n    auto gEvalRequest = calculator.evaluateRequest();\n    auto gCall = gEvalRequest.initExpression().initCall();\n    gCall.setFunction(g);\n    gCall.initParams(1)[0].setLiteral(21);\n    auto gEvalPromise = gEvalRequest.send().getValue().readRequest().send();\n\n    // Wait for the results.\n    KJ_ASSERT(fEvalPromise.wait(waitScope).getValue() == 1234);\n    KJ_ASSERT(gEvalPromise.wait(waitScope).getValue() == 4244);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  {\n    // Make a request that will call back to a function defined locally.\n    //\n    // Specifically, we will compute 2^(4 + 5).  However, exponent is not\n    // defined by the Calculator server.  So, we'll implement the Function\n    // interface locally and pass it to the server for it to use when\n    // evaluating the expression.\n    //\n    // This example requires two network round trips to complete, because the\n    // server calls back to the client once before finishing.  In this\n    // particular case, this could potentially be optimized by using a tail\n    // call on the server side -- see CallContext::tailCall().  However, to\n    // keep the example simpler, we haven't implemented this optimization in\n    // the sample server.\n\n    std::cout << \"Using a callback... \";\n    std::cout.flush();\n\n    Calculator::Function::Client add = nullptr;\n\n    {\n      // Get the \"add\" function from the server.\n      auto request = calculator.getOperatorRequest();\n      request.setOp(Calculator::Operator::ADD);\n      add = request.send().getFunc();\n    }\n\n    // Build the eval request for 2^(4+5).\n    auto request = calculator.evaluateRequest();\n\n    auto powCall = request.getExpression().initCall();\n    powCall.setFunction(kj::heap<PowerFunction>());\n    auto powParams = powCall.initParams(2);\n    powParams[0].setLiteral(2);\n\n    auto addCall = powParams[1].initCall();\n    addCall.setFunction(add);\n    auto addParams = addCall.initParams(2);\n    addParams[0].setLiteral(4);\n    addParams[1].setLiteral(5);\n\n    // Send the request and wait.\n    auto response = request.send().getValue().readRequest()\n                           .send().wait(waitScope);\n    KJ_ASSERT(response.getValue() == 512);\n\n    std::cout << \"PASS\" << std::endl;\n  }\n\n  return 0;\n}"
  },
  {
    "function_name": "call",
    "container": "PowerFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/samples/calculator-client.c++",
    "lines": "34-39",
    "snippet": "kj::Promise<void> call(CallContext context) {\n    auto params = context.getParams().getParams();\n    KJ_REQUIRE(params.size() == 2, \"Wrong number of parameters.\");\n    context.getResults().setValue(pow(params[0], params[1]));\n    return kj::READY_NOW;\n  }",
    "includes": [
      "#include <iostream>",
      "#include <math.h>",
      "#include <kj/debug.h>",
      "#include <capnp/ez-rpc.h>",
      "#include \"calculator.capnp.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [
            "pow(params[0], params[1])"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "154-161",
          "snippet": "AnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<Response<AnyPointer>> response;",
            "AnyPointer::Builder responseBuilder = nullptr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<Response<AnyPointer>> response;\nAnyPointer::Builder responseBuilder = nullptr;\n\nAnyPointer::Builder getResults(kj::Maybe<MessageSize> sizeHint) override {\n    if (response == nullptr) {\n      auto localResponse = kj::refcounted<LocalResponse>(sizeHint);\n      responseBuilder = localResponse->message.getRoot<AnyPointer>();\n      response = Response<AnyPointer>(responseBuilder.asReader(), kj::mv(localResponse));\n    }\n    return responseBuilder;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "params[0]",
            "params[1]"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getResults",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "getResults",
          "container": "LocallyRedirectedRpcResponse",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1644-1646",
          "snippet": "AnyPointer::Reader getResults() override {\n      return message.getRoot<AnyPointer>();\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nLocallyRedirectedRpcResponse {\n  AnyPointer::Reader getResults() override {\n        return message.getRoot<AnyPointer>();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "params.size() == 2",
            "\"Wrong number of parameters.\""
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context.getParams",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iostream>\n#include <math.h>\n#include <kj/debug.h>\n#include <capnp/ez-rpc.h>\n#include \"calculator.capnp.h\"\n\nPowerFunction {\n  kj::Promise<void> call(CallContext context) {\n      auto params = context.getParams().getParams();\n      KJ_REQUIRE(params.size() == 2, \"Wrong number of parameters.\");\n      context.getResults().setValue(pow(params[0], params[1]));\n      return kj::READY_NOW;\n    }\n}"
  }
]