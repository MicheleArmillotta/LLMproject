[
  {
    "function_name": "runCatchingExceptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "457-479",
    "snippet": "Maybe<Exception> runCatchingExceptions(Runnable& runnable) noexcept {\n#if KJ_NO_EXCEPTIONS\n  RecoverableExceptionCatcher catcher;\n  runnable.run();\n  return mv(catcher.caught);\n#else\n  try {\n    runnable.run();\n    return nullptr;\n  } catch (Exception& e) {\n    return kj::mv(e);\n  } catch (std::bad_alloc& e) {\n    return Exception(Exception::Type::OVERLOADED,\n                     \"(unknown)\", -1, str(\"std::bad_alloc: \", e.what()));\n  } catch (std::exception& e) {\n    return Exception(Exception::Type::FAILED,\n                     \"(unknown)\", -1, str(\"std::exception: \", e.what()));\n  } catch (...) {\n    return Exception(Exception::Type::FAILED,\n                     \"(unknown)\", -1, str(\"Unknown non-KJ exception.\"));\n  }\n#endif\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::Type::FAILED",
            "\"(unknown)\"",
            "-1",
            "str(\"Unknown non-KJ exception.\")"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "Exception::Exception",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "192-196",
          "snippet": "Exception::Exception(Type type, String file, int line, String description) noexcept\n    : ownFile(kj::mv(file)), file(ownFile.cStr()), line(line), type(type),\n      description(mv(description)) {\n  traceCount = kj::getStackTrace(trace).size();\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nException::Exception(Type type, String file, int line, String description) noexcept\n    : ownFile(kj::mv(file)), file(ownFile.cStr()), line(line), type(type),\n      description(mv(description)) {\n  traceCount = kj::getStackTrace(trace).size();\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"Unknown non-KJ exception.\""
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"std::exception: \"",
            "e.what()"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"std::bad_alloc: \"",
            "e.what()"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "e"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runnable.run",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "run",
          "container": "RunnableImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "257-259",
          "snippet": "void run() override {\n    func();\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nRunnableImpl {\n  void run() override {\n      func();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "catcher.caught"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nMaybe<Exception> runCatchingExceptions(Runnable& runnable) noexcept {\n#if KJ_NO_EXCEPTIONS\n  RecoverableExceptionCatcher catcher;\n  runnable.run();\n  return mv(catcher.caught);\n#else\n  try {\n    runnable.run();\n    return nullptr;\n  } catch (Exception& e) {\n    return kj::mv(e);\n  } catch (std::bad_alloc& e) {\n    return Exception(Exception::Type::OVERLOADED,\n                     \"(unknown)\", -1, str(\"std::bad_alloc: \", e.what()));\n  } catch (std::exception& e) {\n    return Exception(Exception::Type::FAILED,\n                     \"(unknown)\", -1, str(\"std::exception: \", e.what()));\n  } catch (...) {\n    return Exception(Exception::Type::FAILED,\n                     \"(unknown)\", -1, str(\"Unknown non-KJ exception.\"));\n  }\n#endif\n}"
  },
  {
    "function_name": "onRecoverableException",
    "container": "RecoverableExceptionCatcher",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "446-452",
    "snippet": "void onRecoverableException(Exception&& exception) override {\n    if (caught == nullptr) {\n      caught = mv(exception);\n    } else {\n      // TODO(someday):  Consider it a secondary fault?\n    }\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "exception"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nRecoverableExceptionCatcher {\n  void onRecoverableException(Exception&& exception) override {\n      if (caught == nullptr) {\n        caught = mv(exception);\n      } else {\n        // TODO(someday):  Consider it a secondary fault?\n      }\n    }\n}"
  },
  {
    "function_name": "UnwindDetector::catchExceptionsAsSecondaryFaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "430-435",
    "snippet": "void UnwindDetector::catchExceptionsAsSecondaryFaults(_::Runnable& runnable) const {\n  // TODO(someday):  Attach the secondary exception to whatever primary exception is causing\n  //   the unwind.  For now we just drop it on the floor as this is probably fine most of the\n  //   time.\n  runCatchingExceptions(runnable);\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "runCatchingExceptions",
          "args": [
            "runnable"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid UnwindDetector::catchExceptionsAsSecondaryFaults(_::Runnable& runnable) const {\n  // TODO(someday):  Attach the secondary exception to whatever primary exception is causing\n  //   the unwind.  For now we just drop it on the floor as this is probably fine most of the\n  //   time.\n  runCatchingExceptions(runnable);\n}"
  },
  {
    "function_name": "UnwindDetector::isUnwinding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "426-428",
    "snippet": "bool UnwindDetector::isUnwinding() const {\n  return _::uncaughtExceptionCount() > uncaughtCount;\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::uncaughtExceptionCount",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "uncaughtExceptionCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "412-416",
          "snippet": "uint uncaughtExceptionCount() {\n  // Since the above doesn't work, fall back to uncaught_exception(). This will produce incorrect\n  // results in very obscure cases that Cap'n Proto doesn't really rely on anyway.\n  return std::uncaught_exception();\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nuint uncaughtExceptionCount() {\n  // Since the above doesn't work, fall back to uncaught_exception(). This will produce incorrect\n  // results in very obscure cases that Cap'n Proto doesn't really rely on anyway.\n  return std::uncaught_exception();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nbool UnwindDetector::isUnwinding() const {\n  return _::uncaughtExceptionCount() > uncaughtCount;\n}"
  },
  {
    "function_name": "UnwindDetector::UnwindDetector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "424-424",
    "snippet": "UnwindDetector::UnwindDetector(): uncaughtCount(_::uncaughtExceptionCount()) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_::uncaughtExceptionCount",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "uncaughtExceptionCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "412-416",
          "snippet": "uint uncaughtExceptionCount() {\n  // Since the above doesn't work, fall back to uncaught_exception(). This will produce incorrect\n  // results in very obscure cases that Cap'n Proto doesn't really rely on anyway.\n  return std::uncaught_exception();\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nuint uncaughtExceptionCount() {\n  // Since the above doesn't work, fall back to uncaught_exception(). This will produce incorrect\n  // results in very obscure cases that Cap'n Proto doesn't really rely on anyway.\n  return std::uncaught_exception();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nUnwindDetector::UnwindDetector(): uncaughtCount(_::uncaughtExceptionCount()) {}"
  },
  {
    "function_name": "uncaughtExceptionCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "412-416",
    "snippet": "uint uncaughtExceptionCount() {\n  // Since the above doesn't work, fall back to uncaught_exception(). This will produce incorrect\n  // results in very obscure cases that Cap'n Proto doesn't really rely on anyway.\n  return std::uncaught_exception();\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::uncaught_exception",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nuint uncaughtExceptionCount() {\n  // Since the above doesn't work, fall back to uncaught_exception(). This will produce incorrect\n  // results in very obscure cases that Cap'n Proto doesn't really rely on anyway.\n  return std::uncaught_exception();\n}"
  },
  {
    "function_name": "uncaughtExceptionCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "407-409",
    "snippet": "uint uncaughtExceptionCount() {\n  return *reinterpret_cast<uint*>(_getptd() + (sizeof(void*) == 8 ? 0x100 : 0x90));\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<uint*>",
          "args": [
            "_getptd() + (sizeof(void*) == 8 ? 0x100 : 0x90)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_getptd",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nuint uncaughtExceptionCount() {\n  return *reinterpret_cast<uint*>(_getptd() + (sizeof(void*) == 8 ? 0x100 : 0x90));\n}"
  },
  {
    "function_name": "uncaughtExceptionCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "392-396",
    "snippet": "uint uncaughtExceptionCount() {\n  // TODO(perf):  Use __cxa_get_globals_fast()?  Requires that __cxa_get_globals() has been called\n  //   from somewhere.\n  return __cxa_get_globals()->uncaughtExceptions;\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cxa_get_globals",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nuint uncaughtExceptionCount() {\n  // TODO(perf):  Use __cxa_get_globals_fast()?  Requires that __cxa_get_globals() has been called\n  //   from somewhere.\n  return __cxa_get_globals()->uncaughtExceptions;\n}"
  },
  {
    "function_name": "throwRecoverableException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "353-355",
    "snippet": "void throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwRecoverableException(kj::Exception&& exception) {\n  getExceptionCallback().onRecoverableException(kj::mv(exception));\n}"
  },
  {
    "function_name": "throwFatalException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "348-351",
    "snippet": "void throwFatalException(kj::Exception&& exception) {\n  getExceptionCallback().onFatalException(kj::mv(exception));\n  abort();\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "abortRead",
          "container": "AsyncIoStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.h",
          "lines": "69-69",
          "snippet": "virtual void abortRead() {}",
          "includes": [
            "#include \"time.h\"",
            "#include \"thread.h\"",
            "#include \"function.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"time.h\"\n#include \"thread.h\"\n#include \"function.h\"\n#include \"async.h\"\n\nAsyncIoStream {\n  virtual void abortRead() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [
            "kj::mv(exception)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid throwFatalException(kj::Exception&& exception) {\n  getExceptionCallback().onFatalException(kj::mv(exception));\n  abort();\n}"
  },
  {
    "function_name": "logException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "329-339",
    "snippet": "void logException(LogSeverity severity, Exception&& e) {\n    // We intentionally go back to the top exception callback on the stack because we don't want to\n    // bypass whatever log processing is in effect.\n    //\n    // We intentionally don't log the context since it should get re-added by the exception callback\n    // anyway.\n    getExceptionCallback().logMessage(severity, e.getFile(), e.getLine(), 0, str(\n        e.getType(), e.getDescription() == nullptr ? \"\" : \": \", e.getDescription(),\n        e.getStackTrace().size() > 0 ? \"\\nstack: \" : \"\", strArray(e.getStackTrace(), \" \"),\n        stringifyStackTrace(e.getStackTrace()), \"\\n\"));\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [
            "severity",
            "e.getFile()",
            "e.getLine()",
            "0",
            "str(\n        e.getType(), e.getDescription() == nullptr ? \"\" : \": \", e.getDescription(),\n        e.getStackTrace().size() > 0 ? \"\\nstack: \" : \"\", strArray(e.getStackTrace(), \" \"),\n        stringifyStackTrace(e.getStackTrace()), \"\\n\")"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "e.getType()",
            "e.getDescription() == nullptr ? \"\" : \": \"",
            "e.getDescription()",
            "e.getStackTrace().size() > 0 ? \"\\nstack: \" : \"\"",
            "strArray(e.getStackTrace(), \" \")",
            "stringifyStackTrace(e.getStackTrace())",
            "\"\\n\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringifyStackTrace",
          "args": [
            "e.getStackTrace()"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "stringifyStackTrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "63-140",
          "snippet": "String stringifyStackTrace(ArrayPtr<void* const> trace) {\n#if (__linux__ || __APPLE__) && !__ANDROID__ && defined(KJ_DEBUG)\n  // We want to generate a human-readable stack trace.\n\n  // TODO(someday):  It would be really great if we could avoid farming out to another process\n  //   and do this all in-process, but that may involve onerous requirements like large library\n  //   dependencies or using -rdynamic.\n\n  // The environment manipulation is not thread-safe, so lock a mutex.  This could still be\n  // problematic if another thread is manipulating the environment in unrelated code, but there's\n  // not much we can do about that.  This is debug-only anyway and only an issue when LD_PRELOAD\n  // is in use.\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&mutex);\n  KJ_DEFER(pthread_mutex_unlock(&mutex));\n\n  // Don't heapcheck / intercept syscalls.\n  const char* preload = getenv(\"LD_PRELOAD\");\n  String oldPreload;\n  if (preload != nullptr) {\n    oldPreload = heapString(preload);\n    unsetenv(\"LD_PRELOAD\");\n  }\n  KJ_DEFER(if (oldPreload != nullptr) { setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); });\n\n  String lines[8];\n  FILE* p = nullptr;\n\n#if __linux__\n  // Get executable name from /proc/self/exe, then pass it and the stack trace to addr2line to\n  // get file/line pairs.\n  char exe[512];\n  ssize_t n = readlink(\"/proc/self/exe\", exe, sizeof(exe));\n  if (n < 0 || n >= static_cast<ssize_t>(sizeof(exe))) {\n    return nullptr;\n  }\n  exe[n] = '\\0';\n\n  p = popen(str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr(), \"r\");\n#elif __APPLE__\n  // The Mac OS X equivalent of addr2line is atos.\n  // (Internally, it uses the private CoreSymbolication.framework library.)\n  p = popen(str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr(), \"r\");\n#endif\n\n  if (p == nullptr) {\n    return nullptr;\n  }\n\n  char line[512];\n  size_t i = 0;\n  while (i < kj::size(lines) && fgets(line, sizeof(line), p) != nullptr) {\n    // Don't include exception-handling infrastructure in stack trace.\n    // addr2line output matches file names; atos output matches symbol names.\n    if (i == 0 &&\n        (strstr(line, \"kj/common.c++\") != nullptr ||\n         strstr(line, \"kj/exception.\") != nullptr ||\n         strstr(line, \"kj/debug.\") != nullptr ||\n         strstr(line, \"kj::Exception\") != nullptr ||\n         strstr(line, \"kj::_::Debug\") != nullptr)) {\n      continue;\n    }\n\n    size_t len = strlen(line);\n    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n    lines[i++] = str(\"\\n\", line, \": called here\");\n  }\n\n  // Skip remaining input.\n  while (fgets(line, sizeof(line), p) != nullptr) {}\n\n  pclose(p);\n\n  return strArray(arrayPtr(lines, i), \"\");\n#else\n  return nullptr;\n#endif\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nString stringifyStackTrace(ArrayPtr<void* const> trace) {\n#if (__linux__ || __APPLE__) && !__ANDROID__ && defined(KJ_DEBUG)\n  // We want to generate a human-readable stack trace.\n\n  // TODO(someday):  It would be really great if we could avoid farming out to another process\n  //   and do this all in-process, but that may involve onerous requirements like large library\n  //   dependencies or using -rdynamic.\n\n  // The environment manipulation is not thread-safe, so lock a mutex.  This could still be\n  // problematic if another thread is manipulating the environment in unrelated code, but there's\n  // not much we can do about that.  This is debug-only anyway and only an issue when LD_PRELOAD\n  // is in use.\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&mutex);\n  KJ_DEFER(pthread_mutex_unlock(&mutex));\n\n  // Don't heapcheck / intercept syscalls.\n  const char* preload = getenv(\"LD_PRELOAD\");\n  String oldPreload;\n  if (preload != nullptr) {\n    oldPreload = heapString(preload);\n    unsetenv(\"LD_PRELOAD\");\n  }\n  KJ_DEFER(if (oldPreload != nullptr) { setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); });\n\n  String lines[8];\n  FILE* p = nullptr;\n\n#if __linux__\n  // Get executable name from /proc/self/exe, then pass it and the stack trace to addr2line to\n  // get file/line pairs.\n  char exe[512];\n  ssize_t n = readlink(\"/proc/self/exe\", exe, sizeof(exe));\n  if (n < 0 || n >= static_cast<ssize_t>(sizeof(exe))) {\n    return nullptr;\n  }\n  exe[n] = '\\0';\n\n  p = popen(str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr(), \"r\");\n#elif __APPLE__\n  // The Mac OS X equivalent of addr2line is atos.\n  // (Internally, it uses the private CoreSymbolication.framework library.)\n  p = popen(str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr(), \"r\");\n#endif\n\n  if (p == nullptr) {\n    return nullptr;\n  }\n\n  char line[512];\n  size_t i = 0;\n  while (i < kj::size(lines) && fgets(line, sizeof(line), p) != nullptr) {\n    // Don't include exception-handling infrastructure in stack trace.\n    // addr2line output matches file names; atos output matches symbol names.\n    if (i == 0 &&\n        (strstr(line, \"kj/common.c++\") != nullptr ||\n         strstr(line, \"kj/exception.\") != nullptr ||\n         strstr(line, \"kj/debug.\") != nullptr ||\n         strstr(line, \"kj::Exception\") != nullptr ||\n         strstr(line, \"kj::_::Debug\") != nullptr)) {\n      continue;\n    }\n\n    size_t len = strlen(line);\n    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n    lines[i++] = str(\"\\n\", line, \": called here\");\n  }\n\n  // Skip remaining input.\n  while (fgets(line, sizeof(line), p) != nullptr) {}\n\n  pclose(p);\n\n  return strArray(arrayPtr(lines, i), \"\");\n#else\n  return nullptr;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "e.getStackTrace",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "getStackTrace",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "82-82",
          "snippet": "ArrayPtr<void* const> getStackTrace() const { return arrayPtr(trace, traceCount); }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  ArrayPtr<void* const> getStackTrace() const { return arrayPtr(trace, traceCount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "e.getStackTrace()",
            "\" \""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.getDescription",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "getDescription",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "81-81",
          "snippet": "StringPtr getDescription() const { return description; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  StringPtr getDescription() const { return description; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e.getType",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "80-80",
          "snippet": "Type getType() const { return type; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  Type getType() const { return type; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e.getLine",
          "args": [],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "getLine",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "79-79",
          "snippet": "int getLine() const { return line; }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  int getLine() const { return line; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e.getFile",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid logException(LogSeverity severity, Exception&& e) {\n    // We intentionally go back to the top exception callback on the stack because we don't want to\n    // bypass whatever log processing is in effect.\n    //\n    // We intentionally don't log the context since it should get re-added by the exception callback\n    // anyway.\n    getExceptionCallback().logMessage(severity, e.getFile(), e.getLine(), 0, str(\n        e.getType(), e.getDescription() == nullptr ? \"\" : \": \", e.getDescription(),\n        e.getStackTrace().size() > 0 ? \"\\nstack: \" : \"\", strArray(e.getStackTrace(), \" \"),\n        stringifyStackTrace(e.getStackTrace()), \"\\n\"));\n  }"
  },
  {
    "function_name": "logMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "311-326",
    "snippet": "void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                  String&& text) override {\n    text = str(kj::repeat('_', contextDepth), file, \":\", line, \": \", severity, \": \",\n               mv(text), '\\n');\n\n    StringPtr textPtr = text;\n\n    while (text != nullptr) {\n      miniposix::ssize_t n = miniposix::write(STDERR_FILENO, textPtr.begin(), textPtr.size());\n      if (n <= 0) {\n        // stderr is broken.  Give up.\n        return;\n      }\n      textPtr = textPtr.slice(n);\n    }\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "textPtr.slice",
          "args": [
            "n"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "miniposix::write",
          "args": [
            "STDERR_FILENO",
            "textPtr.begin()",
            "textPtr.size()"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "textPtr.size",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "textPtr.begin",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "kj::repeat('_', contextDepth)",
            "file",
            "\":\"",
            "line",
            "\": \"",
            "severity",
            "\": \"",
            "mv(text)",
            "'\\n'"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "text"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::repeat",
          "args": [
            "'_'",
            "contextDepth"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "repeat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "703-708",
          "snippet": "inline constexpr Repeat<Decay<T>> repeat(T&& value, size_t count) {\n  // Returns a fake iterable which contains `count` repeats of `value`.  Useful for e.g. creating\n  // a bunch of spaces:  `kj::repeat(' ', indent * 2)`\n\n  return Repeat<Decay<T>>(value, count);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr Repeat<Decay<T>> repeat(T&& value, size_t count) {\n  // Returns a fake iterable which contains `count` repeats of `value`.  Useful for e.g. creating\n  // a bunch of spaces:  `kj::repeat(' ', indent * 2)`\n\n  return Repeat<Decay<T>>(value, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                  String&& text) override {\n    text = str(kj::repeat('_', contextDepth), file, \":\", line, \": \", severity, \": \",\n               mv(text), '\\n');\n\n    StringPtr textPtr = text;\n\n    while (text != nullptr) {\n      miniposix::ssize_t n = miniposix::write(STDERR_FILENO, textPtr.begin(), textPtr.size());\n      if (n <= 0) {\n        // stderr is broken.  Give up.\n        return;\n      }\n      textPtr = textPtr.slice(n);\n    }\n  }"
  },
  {
    "function_name": "onFatalException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "303-309",
    "snippet": "void onFatalException(Exception&& exception) override {\n#if KJ_NO_EXCEPTIONS\n    logException(LogSeverity::FATAL, mv(exception));\n#else\n    throw ExceptionImpl(mv(exception));\n#endif\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExceptionImpl",
          "args": [
            "mv(exception)"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ExceptionImpl",
          "container": "ExceptionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "229-231",
          "snippet": "ExceptionImpl(const ExceptionImpl& other): Exception(other) {\n    // No need to copy whatBuffer since it's just to hold the return value of what().\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nExceptionImpl {\n  ExceptionImpl(const ExceptionImpl& other): Exception(other) {\n      // No need to copy whatBuffer since it's just to hold the return value of what().\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "exception"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logException",
          "args": [
            "LogSeverity::FATAL",
            "mv(exception)"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "logException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "329-339",
          "snippet": "void logException(LogSeverity severity, Exception&& e) {\n    // We intentionally go back to the top exception callback on the stack because we don't want to\n    // bypass whatever log processing is in effect.\n    //\n    // We intentionally don't log the context since it should get re-added by the exception callback\n    // anyway.\n    getExceptionCallback().logMessage(severity, e.getFile(), e.getLine(), 0, str(\n        e.getType(), e.getDescription() == nullptr ? \"\" : \": \", e.getDescription(),\n        e.getStackTrace().size() > 0 ? \"\\nstack: \" : \"\", strArray(e.getStackTrace(), \" \"),\n        stringifyStackTrace(e.getStackTrace()), \"\\n\"));\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid logException(LogSeverity severity, Exception&& e) {\n    // We intentionally go back to the top exception callback on the stack because we don't want to\n    // bypass whatever log processing is in effect.\n    //\n    // We intentionally don't log the context since it should get re-added by the exception callback\n    // anyway.\n    getExceptionCallback().logMessage(severity, e.getFile(), e.getLine(), 0, str(\n        e.getType(), e.getDescription() == nullptr ? \"\" : \": \", e.getDescription(),\n        e.getStackTrace().size() > 0 ? \"\\nstack: \" : \"\", strArray(e.getStackTrace(), \" \"),\n        stringifyStackTrace(e.getStackTrace()), \"\\n\"));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "exception"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid onFatalException(Exception&& exception) override {\n#if KJ_NO_EXCEPTIONS\n    logException(LogSeverity::FATAL, mv(exception));\n#else\n    throw ExceptionImpl(mv(exception));\n#endif\n  }"
  },
  {
    "function_name": "onRecoverableException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "286-301",
    "snippet": "void onRecoverableException(Exception&& exception) override {\n#if KJ_NO_EXCEPTIONS\n    logException(LogSeverity::ERROR, mv(exception));\n#else\n    if (std::uncaught_exception()) {\n      // Bad time to throw an exception.  Just log instead.\n      //\n      // TODO(someday): We should really compare uncaughtExceptionCount() against the count at\n      //   the innermost runCatchingExceptions() frame in this thread to tell if exceptions are\n      //   being caught correctly.\n      logException(LogSeverity::ERROR, mv(exception));\n    } else {\n      throw ExceptionImpl(mv(exception));\n    }\n#endif\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExceptionImpl",
          "args": [
            "mv(exception)"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ExceptionImpl",
          "container": "ExceptionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "229-231",
          "snippet": "ExceptionImpl(const ExceptionImpl& other): Exception(other) {\n    // No need to copy whatBuffer since it's just to hold the return value of what().\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nExceptionImpl {\n  ExceptionImpl(const ExceptionImpl& other): Exception(other) {\n      // No need to copy whatBuffer since it's just to hold the return value of what().\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "exception"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logException",
          "args": [
            "LogSeverity::ERROR",
            "mv(exception)"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "logException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "329-339",
          "snippet": "void logException(LogSeverity severity, Exception&& e) {\n    // We intentionally go back to the top exception callback on the stack because we don't want to\n    // bypass whatever log processing is in effect.\n    //\n    // We intentionally don't log the context since it should get re-added by the exception callback\n    // anyway.\n    getExceptionCallback().logMessage(severity, e.getFile(), e.getLine(), 0, str(\n        e.getType(), e.getDescription() == nullptr ? \"\" : \": \", e.getDescription(),\n        e.getStackTrace().size() > 0 ? \"\\nstack: \" : \"\", strArray(e.getStackTrace(), \" \"),\n        stringifyStackTrace(e.getStackTrace()), \"\\n\"));\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid logException(LogSeverity severity, Exception&& e) {\n    // We intentionally go back to the top exception callback on the stack because we don't want to\n    // bypass whatever log processing is in effect.\n    //\n    // We intentionally don't log the context since it should get re-added by the exception callback\n    // anyway.\n    getExceptionCallback().logMessage(severity, e.getFile(), e.getLine(), 0, str(\n        e.getType(), e.getDescription() == nullptr ? \"\" : \": \", e.getDescription(),\n        e.getStackTrace().size() > 0 ? \"\\nstack: \" : \"\", strArray(e.getStackTrace(), \" \"),\n        stringifyStackTrace(e.getStackTrace()), \"\\n\"));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "exception"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::uncaught_exception",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "exception"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid onRecoverableException(Exception&& exception) override {\n#if KJ_NO_EXCEPTIONS\n    logException(LogSeverity::ERROR, mv(exception));\n#else\n    if (std::uncaught_exception()) {\n      // Bad time to throw an exception.  Just log instead.\n      //\n      // TODO(someday): We should really compare uncaughtExceptionCount() against the count at\n      //   the innermost runCatchingExceptions() frame in this thread to tell if exceptions are\n      //   being caught correctly.\n      logException(LogSeverity::ERROR, mv(exception));\n    } else {\n      throw ExceptionImpl(mv(exception));\n    }\n#endif\n  }"
  },
  {
    "function_name": "RootExceptionCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "284-284",
    "snippet": "RootExceptionCallback(): ExceptionCallback(*this) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nRootExceptionCallback(): ExceptionCallback(*this) {}"
  },
  {
    "function_name": "ExceptionCallback::logMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "277-280",
    "snippet": "void ExceptionCallback::logMessage(\n    LogSeverity severity, const char* file, int line, int contextDepth, String&& text) {\n  next.logMessage(severity, file, line, contextDepth, mv(text));\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next.logMessage",
          "args": [
            "severity",
            "file",
            "line",
            "contextDepth",
            "mv(text)"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "logMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "311-326",
          "snippet": "void logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                  String&& text) override {\n    text = str(kj::repeat('_', contextDepth), file, \":\", line, \": \", severity, \": \",\n               mv(text), '\\n');\n\n    StringPtr textPtr = text;\n\n    while (text != nullptr) {\n      miniposix::ssize_t n = miniposix::write(STDERR_FILENO, textPtr.begin(), textPtr.size());\n      if (n <= 0) {\n        // stderr is broken.  Give up.\n        return;\n      }\n      textPtr = textPtr.slice(n);\n    }\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid logMessage(LogSeverity severity, const char* file, int line, int contextDepth,\n                  String&& text) override {\n    text = str(kj::repeat('_', contextDepth), file, \":\", line, \": \", severity, \": \",\n               mv(text), '\\n');\n\n    StringPtr textPtr = text;\n\n    while (text != nullptr) {\n      miniposix::ssize_t n = miniposix::write(STDERR_FILENO, textPtr.begin(), textPtr.size());\n      if (n <= 0) {\n        // stderr is broken.  Give up.\n        return;\n      }\n      textPtr = textPtr.slice(n);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "text"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid ExceptionCallback::logMessage(\n    LogSeverity severity, const char* file, int line, int contextDepth, String&& text) {\n  next.logMessage(severity, file, line, contextDepth, mv(text));\n}"
  },
  {
    "function_name": "ExceptionCallback::onFatalException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "273-275",
    "snippet": "void ExceptionCallback::onFatalException(Exception&& exception) {\n  next.onFatalException(mv(exception));\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next.onFatalException",
          "args": [
            "mv(exception)"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "onFatalException",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "303-309",
          "snippet": "void onFatalException(Exception&& exception) override {\n#if KJ_NO_EXCEPTIONS\n    logException(LogSeverity::FATAL, mv(exception));\n#else\n    throw ExceptionImpl(mv(exception));\n#endif\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid onFatalException(Exception&& exception) override {\n#if KJ_NO_EXCEPTIONS\n    logException(LogSeverity::FATAL, mv(exception));\n#else\n    throw ExceptionImpl(mv(exception));\n#endif\n  }"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "exception"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid ExceptionCallback::onFatalException(Exception&& exception) {\n  next.onFatalException(mv(exception));\n}"
  },
  {
    "function_name": "ExceptionCallback::onRecoverableException",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "269-271",
    "snippet": "void ExceptionCallback::onRecoverableException(Exception&& exception) {\n  next.onRecoverableException(mv(exception));\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next.onRecoverableException",
          "args": [
            "mv(exception)"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "onRecoverableException",
          "container": "RecoverableExceptionCatcher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "446-452",
          "snippet": "void onRecoverableException(Exception&& exception) override {\n    if (caught == nullptr) {\n      caught = mv(exception);\n    } else {\n      // TODO(someday):  Consider it a secondary fault?\n    }\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nRecoverableExceptionCatcher {\n  void onRecoverableException(Exception&& exception) override {\n      if (caught == nullptr) {\n        caught = mv(exception);\n      } else {\n        // TODO(someday):  Consider it a secondary fault?\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "exception"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid ExceptionCallback::onRecoverableException(Exception&& exception) {\n  next.onRecoverableException(mv(exception));\n}"
  },
  {
    "function_name": "ExceptionCallback::~ExceptionCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "263-267",
    "snippet": "ExceptionCallback::~ExceptionCallback() noexcept(false) {\n  if (&next != this) {\n    threadLocalCallback = &next;\n  }\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nExceptionCallback::~ExceptionCallback() noexcept(false) {\n  if (&next != this) {\n    threadLocalCallback = &next;\n  }\n}"
  },
  {
    "function_name": "ExceptionCallback::ExceptionCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "261-261",
    "snippet": "ExceptionCallback::ExceptionCallback(ExceptionCallback& next): next(next) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nExceptionCallback::ExceptionCallback(ExceptionCallback& next): next(next) {}"
  },
  {
    "function_name": "ExceptionCallback::ExceptionCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "252-259",
    "snippet": "ExceptionCallback::ExceptionCallback(): next(getExceptionCallback()) {\n  char stackVar;\n  ptrdiff_t offset = reinterpret_cast<char*>(this) - &stackVar;\n  KJ_ASSERT(offset < 65536 && offset > -65536,\n            \"ExceptionCallback must be allocated on the stack.\");\n\n  threadLocalCallback = this;\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "offset < 65536 && offset > -65536",
            "\"ExceptionCallback must be allocated on the stack.\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "this"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getExceptionCallback",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nExceptionCallback::ExceptionCallback(): next(getExceptionCallback()) {\n  char stackVar;\n  ptrdiff_t offset = reinterpret_cast<char*>(this) - &stackVar;\n  KJ_ASSERT(offset < 65536 && offset > -65536,\n            \"ExceptionCallback must be allocated on the stack.\");\n\n  threadLocalCallback = this;\n}"
  },
  {
    "function_name": "ExceptionImpl",
    "container": "ExceptionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "229-231",
    "snippet": "ExceptionImpl(const ExceptionImpl& other): Exception(other) {\n    // No need to copy whatBuffer since it's just to hold the return value of what().\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nExceptionImpl {\n  ExceptionImpl(const ExceptionImpl& other): Exception(other) {\n      // No need to copy whatBuffer since it's just to hold the return value of what().\n    }\n}"
  },
  {
    "function_name": "ExceptionImpl",
    "container": "ExceptionImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "228-228",
    "snippet": "inline ExceptionImpl(Exception&& other): Exception(mv(other)) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "other"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nExceptionImpl {\n  inline ExceptionImpl(Exception&& other): Exception(mv(other)) {}\n}"
  },
  {
    "function_name": "Exception::wrapContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "222-224",
    "snippet": "void Exception::wrapContext(const char* file, int line, String&& description) {\n  context = heap<Context>(file, line, mv(description), mv(context));\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<Context>",
          "args": [
            "file",
            "line",
            "mv(description)",
            "mv(context)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "context"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "description"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nvoid Exception::wrapContext(const char* file, int line, String&& description) {\n  context = heap<Context>(file, line, mv(description), mv(context));\n}"
  },
  {
    "function_name": "Exception::Context::Context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "215-220",
    "snippet": "Exception::Context::Context(const Context& other) noexcept\n    : file(other.file), line(other.line), description(str(other.description)) {\n  KJ_IF_MAYBE(n, other.next) {\n    next = heap(**n);\n  }\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap",
          "args": [
            "**n"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "n",
            "other.next"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "171-175",
          "snippet": "KJ_IF_MAYBE(c, contextPtr) {\n      contextText[contextDepth++] =\n          str(c->file, \":\", c->line, \": context: \", c->description, \"\\n\");\n      contextPtr = c->next;\n    }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nKJ_IF_MAYBE(c, contextPtr) {\n      contextText[contextDepth++] =\n          str(c->file, \":\", c->line, \": context: \", c->description, \"\\n\");\n      contextPtr = c->next;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "other.description"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "destroyObject",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.h",
          "lines": "129-131",
          "snippet": "static void destroyObject(void* pointer) {\n    dtor(*reinterpret_cast<T*>(pointer));\n  }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nArena {\n  static void destroyObject(void* pointer) {\n      dtor(*reinterpret_cast<T*>(pointer));\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nException::Context::Context(const Context& other) noexcept\n    : file(other.file), line(other.line), description(str(other.description)) {\n  KJ_IF_MAYBE(n, other.next) {\n    next = heap(**n);\n  }\n}"
  },
  {
    "function_name": "Exception::~Exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "213-213",
    "snippet": "Exception::~Exception() noexcept {}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nException::~Exception() noexcept {}"
  },
  {
    "function_name": "Exception::Exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "198-211",
    "snippet": "Exception::Exception(const Exception& other) noexcept\n    : file(other.file), line(other.line), type(other.type),\n      description(heapString(other.description)), traceCount(other.traceCount) {\n  if (file == other.ownFile.cStr()) {\n    ownFile = heapString(other.ownFile);\n    file = ownFile.cStr();\n  }\n\n  memcpy(trace, other.trace, sizeof(trace[0]) * traceCount);\n\n  KJ_IF_MAYBE(c, other.context) {\n    context = heap(**c);\n  }\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap",
          "args": [
            "**c"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "c",
            "other.context"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "171-175",
          "snippet": "KJ_IF_MAYBE(c, contextPtr) {\n      contextText[contextDepth++] =\n          str(c->file, \":\", c->line, \": context: \", c->description, \"\\n\");\n      contextPtr = c->next;\n    }",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nKJ_IF_MAYBE(c, contextPtr) {\n      contextText[contextDepth++] =\n          str(c->file, \":\", c->line, \": context: \", c->description, \"\\n\");\n      contextPtr = c->next;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "trace",
            "other.trace",
            "sizeof(trace[0]) * traceCount"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ownFile.cStr",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "other.ownFile"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "other.ownFile.cStr",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nException::Exception(const Exception& other) noexcept\n    : file(other.file), line(other.line), type(other.type),\n      description(heapString(other.description)), traceCount(other.traceCount) {\n  if (file == other.ownFile.cStr()) {\n    ownFile = heapString(other.ownFile);\n    file = ownFile.cStr();\n  }\n\n  memcpy(trace, other.trace, sizeof(trace[0]) * traceCount);\n\n  KJ_IF_MAYBE(c, other.context) {\n    context = heap(**c);\n  }\n}"
  },
  {
    "function_name": "Exception::Exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "192-196",
    "snippet": "Exception::Exception(Type type, String file, int line, String description) noexcept\n    : ownFile(kj::mv(file)), file(ownFile.cStr()), line(line), type(type),\n      description(mv(description)) {\n  traceCount = kj::getStackTrace(trace).size();\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::getStackTrace",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "getStackTrace",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "82-82",
          "snippet": "ArrayPtr<void* const> getStackTrace() const { return arrayPtr(trace, traceCount); }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  ArrayPtr<void* const> getStackTrace() const { return arrayPtr(trace, traceCount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::getStackTrace",
          "args": [
            "trace"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "getStackTrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "55-61",
          "snippet": "ArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [
            "#define KJ_HAS_BACKTRACE 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\n#define KJ_HAS_BACKTRACE 1\n\nArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "description"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ownFile.cStr",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "file"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nException::Exception(Type type, String file, int line, String description) noexcept\n    : ownFile(kj::mv(file)), file(ownFile.cStr()), line(line), type(type),\n      description(mv(description)) {\n  traceCount = kj::getStackTrace(trace).size();\n}"
  },
  {
    "function_name": "Exception::Exception",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "187-190",
    "snippet": "Exception::Exception(Type type, const char* file, int line, String description) noexcept\n    : file(file), line(line), type(type), description(mv(description)) {\n  traceCount = kj::getStackTrace(trace).size();\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::getStackTrace",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "getStackTrace",
          "container": "Exception",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.h",
          "lines": "82-82",
          "snippet": "ArrayPtr<void* const> getStackTrace() const { return arrayPtr(trace, traceCount); }",
          "includes": [
            "#include \"string.h\"",
            "#include \"array.h\"",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n#include \"array.h\"\n#include \"memory.h\"\n\nException {\n  ArrayPtr<void* const> getStackTrace() const { return arrayPtr(trace, traceCount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::getStackTrace",
          "args": [
            "trace"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "getStackTrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
          "lines": "55-61",
          "snippet": "ArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}",
          "includes": [
            "#include <pthread.h>",
            "#include <stdio.h>",
            "#include <execinfo.h>",
            "#include <new>",
            "#include <exception>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"threadlocal.h\"",
            "#include \"debug.h\"",
            "#include \"string.h\"",
            "#include \"exception.h\""
          ],
          "macros_used": [
            "#define KJ_HAS_BACKTRACE 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\n#define KJ_HAS_BACKTRACE 1\n\nArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "description"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nException::Exception(Type type, const char* file, int line, String description) noexcept\n    : file(file), line(line), type(type), description(mv(description)) {\n  traceCount = kj::getStackTrace(trace).size();\n}"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "171-175",
    "snippet": "KJ_IF_MAYBE(c, contextPtr) {\n      contextText[contextDepth++] =\n          str(c->file, \":\", c->line, \": context: \", c->description, \"\\n\");\n      contextPtr = c->next;\n    }",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str",
          "args": [
            "c->file",
            "\":\"",
            "c->line",
            "\": context: \"",
            "c->description",
            "\"\\n\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nKJ_IF_MAYBE(c, contextPtr) {\n      contextText[contextDepth++] =\n          str(c->file, \":\", c->line, \": context: \", c->description, \"\\n\");\n      contextPtr = c->next;\n    }"
  },
  {
    "function_name": "KJ_STRINGIFY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "153-164",
    "snippet": "String KJ_STRINGIFY(const Exception& e) {\n  uint contextDepth = 0;\n\n  Maybe<const Exception::Context&> contextPtr = e.getContext();\n  for (;;) {\n    KJ_IF_MAYBE(c, contextPtr) {\n      ++contextDepth;\n      contextPtr = c->next;\n    } else {\n      break;\n    }\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e.getContext",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "Disembargo::Pipeline::getContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.capnp.h",
          "lines": "3925-3927",
          "snippet": "inline Disembargo::Context::Pipeline Disembargo::Pipeline::getContext() {\n  return Disembargo::Context::Pipeline(_typeless.noop());\n}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline Disembargo::Context::Pipeline Disembargo::Pipeline::getContext() {\n  return Disembargo::Context::Pipeline(_typeless.noop());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nString KJ_STRINGIFY(const Exception& e) {\n  uint contextDepth = 0;\n\n  Maybe<const Exception::Context&> contextPtr = e.getContext();\n  for (;;) {\n    KJ_IF_MAYBE(c, contextPtr) {\n      ++contextDepth;\n      contextPtr = c->next;\n    } else {\n      break;\n    }\n  }"
  },
  {
    "function_name": "KJ_STRINGIFY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "142-151",
    "snippet": "StringPtr KJ_STRINGIFY(Exception::Type type) {\n  static const char* TYPE_STRINGS[] = {\n    \"failed\",\n    \"overloaded\",\n    \"disconnected\",\n    \"unimplemented\"\n  };\n\n  return TYPE_STRINGS[static_cast<uint>(type)];\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<uint>",
          "args": [
            "type"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nStringPtr KJ_STRINGIFY(Exception::Type type) {\n  static const char* TYPE_STRINGS[] = {\n    \"failed\",\n    \"overloaded\",\n    \"disconnected\",\n    \"unimplemented\"\n  };\n\n  return TYPE_STRINGS[static_cast<uint>(type)];\n}"
  },
  {
    "function_name": "stringifyStackTrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "63-140",
    "snippet": "String stringifyStackTrace(ArrayPtr<void* const> trace) {\n#if (__linux__ || __APPLE__) && !__ANDROID__ && defined(KJ_DEBUG)\n  // We want to generate a human-readable stack trace.\n\n  // TODO(someday):  It would be really great if we could avoid farming out to another process\n  //   and do this all in-process, but that may involve onerous requirements like large library\n  //   dependencies or using -rdynamic.\n\n  // The environment manipulation is not thread-safe, so lock a mutex.  This could still be\n  // problematic if another thread is manipulating the environment in unrelated code, but there's\n  // not much we can do about that.  This is debug-only anyway and only an issue when LD_PRELOAD\n  // is in use.\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&mutex);\n  KJ_DEFER(pthread_mutex_unlock(&mutex));\n\n  // Don't heapcheck / intercept syscalls.\n  const char* preload = getenv(\"LD_PRELOAD\");\n  String oldPreload;\n  if (preload != nullptr) {\n    oldPreload = heapString(preload);\n    unsetenv(\"LD_PRELOAD\");\n  }\n  KJ_DEFER(if (oldPreload != nullptr) { setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); });\n\n  String lines[8];\n  FILE* p = nullptr;\n\n#if __linux__\n  // Get executable name from /proc/self/exe, then pass it and the stack trace to addr2line to\n  // get file/line pairs.\n  char exe[512];\n  ssize_t n = readlink(\"/proc/self/exe\", exe, sizeof(exe));\n  if (n < 0 || n >= static_cast<ssize_t>(sizeof(exe))) {\n    return nullptr;\n  }\n  exe[n] = '\\0';\n\n  p = popen(str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr(), \"r\");\n#elif __APPLE__\n  // The Mac OS X equivalent of addr2line is atos.\n  // (Internally, it uses the private CoreSymbolication.framework library.)\n  p = popen(str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr(), \"r\");\n#endif\n\n  if (p == nullptr) {\n    return nullptr;\n  }\n\n  char line[512];\n  size_t i = 0;\n  while (i < kj::size(lines) && fgets(line, sizeof(line), p) != nullptr) {\n    // Don't include exception-handling infrastructure in stack trace.\n    // addr2line output matches file names; atos output matches symbol names.\n    if (i == 0 &&\n        (strstr(line, \"kj/common.c++\") != nullptr ||\n         strstr(line, \"kj/exception.\") != nullptr ||\n         strstr(line, \"kj/debug.\") != nullptr ||\n         strstr(line, \"kj::Exception\") != nullptr ||\n         strstr(line, \"kj::_::Debug\") != nullptr)) {\n      continue;\n    }\n\n    size_t len = strlen(line);\n    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n    lines[i++] = str(\"\\n\", line, \": called here\");\n  }\n\n  // Skip remaining input.\n  while (fgets(line, sizeof(line), p) != nullptr) {}\n\n  pclose(p);\n\n  return strArray(arrayPtr(lines, i), \"\");\n#else\n  return nullptr;\n#endif\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "arrayPtr(lines, i)",
            "\"\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arrayPtr",
          "args": [
            "lines",
            "i"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pclose",
          "args": [
            "p"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "p"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"\\n\"",
            "line",
            "\": called here\""
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"kj::_::Debug\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"kj::Exception\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"kj/debug.\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"kj/exception.\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\"kj/common.c++\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "p"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::size",
          "args": [
            "lines"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr()",
            "\"r\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "destroy",
          "container": "OneOf",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/one-of.h",
          "lines": "115-117",
          "snippet": "void destroy() {\n    doAll(destroyVariant<Variants>()...);\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOneOf {\n  void destroy() {\n      doAll(destroyVariant<Variants>()...);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"xcrun atos -p \"",
            "getpid()",
            "' '",
            "strArray(trace, \" \")"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "trace",
            "\" \""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "popen",
          "args": [
            "str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr()",
            "\"r\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"addr2line -e \"",
            "exe",
            "' '",
            "strArray(trace, \" \")"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "trace",
            "\" \""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<ssize_t>",
          "args": [
            "sizeof(exe)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readlink",
          "args": [
            "\"/proc/self/exe\"",
            "exe",
            "sizeof(exe)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "if (oldPreload != nullptr){ setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); }"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"LD_PRELOAD\"",
            "oldPreload.cStr()",
            "true"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oldPreload.cStr",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "oldPreload != nullptr"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "if",
          "container": "RpcPipeline",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1516-1518",
          "snippet": "else if (state.is<Resolved>()) {\n        return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n      }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcPipeline {\n  else if (state.is<Resolved>()) {\n          return state.get<Resolved>()->getResults().getPipelinedCap(ops);\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unsetenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "preload"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LD_PRELOAD\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "pthread_mutex_unlock(&mutex)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&mutex"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&mutex"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nString stringifyStackTrace(ArrayPtr<void* const> trace) {\n#if (__linux__ || __APPLE__) && !__ANDROID__ && defined(KJ_DEBUG)\n  // We want to generate a human-readable stack trace.\n\n  // TODO(someday):  It would be really great if we could avoid farming out to another process\n  //   and do this all in-process, but that may involve onerous requirements like large library\n  //   dependencies or using -rdynamic.\n\n  // The environment manipulation is not thread-safe, so lock a mutex.  This could still be\n  // problematic if another thread is manipulating the environment in unrelated code, but there's\n  // not much we can do about that.  This is debug-only anyway and only an issue when LD_PRELOAD\n  // is in use.\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  pthread_mutex_lock(&mutex);\n  KJ_DEFER(pthread_mutex_unlock(&mutex));\n\n  // Don't heapcheck / intercept syscalls.\n  const char* preload = getenv(\"LD_PRELOAD\");\n  String oldPreload;\n  if (preload != nullptr) {\n    oldPreload = heapString(preload);\n    unsetenv(\"LD_PRELOAD\");\n  }\n  KJ_DEFER(if (oldPreload != nullptr) { setenv(\"LD_PRELOAD\", oldPreload.cStr(), true); });\n\n  String lines[8];\n  FILE* p = nullptr;\n\n#if __linux__\n  // Get executable name from /proc/self/exe, then pass it and the stack trace to addr2line to\n  // get file/line pairs.\n  char exe[512];\n  ssize_t n = readlink(\"/proc/self/exe\", exe, sizeof(exe));\n  if (n < 0 || n >= static_cast<ssize_t>(sizeof(exe))) {\n    return nullptr;\n  }\n  exe[n] = '\\0';\n\n  p = popen(str(\"addr2line -e \", exe, ' ', strArray(trace, \" \")).cStr(), \"r\");\n#elif __APPLE__\n  // The Mac OS X equivalent of addr2line is atos.\n  // (Internally, it uses the private CoreSymbolication.framework library.)\n  p = popen(str(\"xcrun atos -p \", getpid(), ' ', strArray(trace, \" \")).cStr(), \"r\");\n#endif\n\n  if (p == nullptr) {\n    return nullptr;\n  }\n\n  char line[512];\n  size_t i = 0;\n  while (i < kj::size(lines) && fgets(line, sizeof(line), p) != nullptr) {\n    // Don't include exception-handling infrastructure in stack trace.\n    // addr2line output matches file names; atos output matches symbol names.\n    if (i == 0 &&\n        (strstr(line, \"kj/common.c++\") != nullptr ||\n         strstr(line, \"kj/exception.\") != nullptr ||\n         strstr(line, \"kj/debug.\") != nullptr ||\n         strstr(line, \"kj::Exception\") != nullptr ||\n         strstr(line, \"kj::_::Debug\") != nullptr)) {\n      continue;\n    }\n\n    size_t len = strlen(line);\n    if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';\n    lines[i++] = str(\"\\n\", line, \": called here\");\n  }\n\n  // Skip remaining input.\n  while (fgets(line, sizeof(line), p) != nullptr) {}\n\n  pclose(p);\n\n  return strArray(arrayPtr(lines, i), \"\");\n#else\n  return nullptr;\n#endif\n}"
  },
  {
    "function_name": "getStackTrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "55-61",
    "snippet": "ArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [
      "#define KJ_HAS_BACKTRACE 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "space.slice",
          "args": [
            "0",
            "backtrace(space.begin(), space.size())"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "backtrace",
          "args": [
            "space.begin()",
            "space.size()"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space.size",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "space.begin",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\n#define KJ_HAS_BACKTRACE 1\n\nArrayPtr<void* const> getStackTrace(ArrayPtr<void*> space) {\n#ifndef KJ_HAS_BACKTRACE\n  return nullptr;\n#else\n  return space.slice(0, backtrace(space.begin(), space.size()));\n#endif\n}"
  },
  {
    "function_name": "KJ_STRINGIFY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/exception.c++",
    "lines": "43-53",
    "snippet": "StringPtr KJ_STRINGIFY(LogSeverity severity) {\n  static const char* SEVERITY_STRINGS[] = {\n    \"info\",\n    \"warning\",\n    \"error\",\n    \"fatal\",\n    \"debug\"\n  };\n\n  return SEVERITY_STRINGS[static_cast<uint>(severity)];\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <stdio.h>",
      "#include <execinfo.h>",
      "#include <new>",
      "#include <exception>",
      "#include <stdlib.h>",
      "#include \"miniposix.h\"",
      "#include \"threadlocal.h\"",
      "#include \"debug.h\"",
      "#include \"string.h\"",
      "#include \"exception.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<uint>",
          "args": [
            "severity"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <stdio.h>\n#include <execinfo.h>\n#include <new>\n#include <exception>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"threadlocal.h\"\n#include \"debug.h\"\n#include \"string.h\"\n#include \"exception.h\"\n\nStringPtr KJ_STRINGIFY(LogSeverity severity) {\n  static const char* SEVERITY_STRINGS[] = {\n    \"info\",\n    \"warning\",\n    \"error\",\n    \"fatal\",\n    \"debug\"\n  };\n\n  return SEVERITY_STRINGS[static_cast<uint>(severity)];\n}"
  }
]