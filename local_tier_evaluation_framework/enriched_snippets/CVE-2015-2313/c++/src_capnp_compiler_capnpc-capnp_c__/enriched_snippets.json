[
  {
    "function_name": "run",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "654-675",
    "snippet": "kj::MainBuilder::Validity run() {\n    ReaderOptions options;\n    options.traversalLimitInWords = 1 << 30;  // Don't limit.\n    StreamFdMessageReader reader(STDIN_FILENO, options);\n    auto request = reader.getRoot<schema::CodeGeneratorRequest>();\n\n    for (auto node: request.getNodes()) {\n      schemaLoader.load(node);\n    }\n\n    kj::FdOutputStream rawOut(STDOUT_FILENO);\n    kj::BufferedOutputStreamWrapper out(rawOut);\n\n    for (auto requestedFile: request.getRequestedFiles()) {\n      genFile(schemaLoader.get(requestedFile.getId())).visit(\n          [&](kj::ArrayPtr<const char> text) {\n            out.write(text.begin(), text.size());\n          });\n    }\n\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "genFile",
          "args": [
            "[&](kj::ArrayPtr<const char> text) {\n            out.write(text.begin(), text.size());\n          }"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "genFile",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "643-652",
          "snippet": "kj::StringTree genFile(Schema file) {\n    auto proto = file.getProto();\n    KJ_REQUIRE(proto.isFile(), \"Expected a file node.\", (uint)proto.which());\n\n    return kj::strTree(\n      \"# \", proto.getDisplayName(), \"\\n\",\n      \"@0x\", kj::hex(proto.getId()), \";\\n\",\n      KJ_MAP(ann, proto.getAnnotations()) { return genAnnotation(ann, file, \"\", \";\\n\"); },\n      genNestedDecls(file, Indent(0)));\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genFile(Schema file) {\n      auto proto = file.getProto();\n      KJ_REQUIRE(proto.isFile(), \"Expected a file node.\", (uint)proto.which());\n  \n      return kj::strTree(\n        \"# \", proto.getDisplayName(), \"\\n\",\n        \"@0x\", kj::hex(proto.getId()), \";\\n\",\n        KJ_MAP(ann, proto.getAnnotations()) { return genAnnotation(ann, file, \"\", \";\\n\"); },\n        genNestedDecls(file, Indent(0)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "out.write",
          "args": [
            "text.begin()",
            "text.size()"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.size",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "text.begin",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "requestedFile.getId()"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "requestedFile.getId",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "request.getRequestedFiles",
          "args": [],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaLoader.load",
          "args": [
            "node"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request.getNodes",
          "args": [],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getRoot<schema::CodeGeneratorRequest>",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::MainBuilder::Validity run() {\n      ReaderOptions options;\n      options.traversalLimitInWords = 1 << 30;  // Don't limit.\n      StreamFdMessageReader reader(STDIN_FILENO, options);\n      auto request = reader.getRoot<schema::CodeGeneratorRequest>();\n  \n      for (auto node: request.getNodes()) {\n        schemaLoader.load(node);\n      }\n  \n      kj::FdOutputStream rawOut(STDOUT_FILENO);\n      kj::BufferedOutputStreamWrapper out(rawOut);\n  \n      for (auto requestedFile: request.getRequestedFiles()) {\n        genFile(schemaLoader.get(requestedFile.getId())).visit(\n            [&](kj::ArrayPtr<const char> text) {\n              out.write(text.begin(), text.size());\n            });\n      }\n  \n      return true;\n    }\n}"
  },
  {
    "function_name": "genFile",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "643-652",
    "snippet": "kj::StringTree genFile(Schema file) {\n    auto proto = file.getProto();\n    KJ_REQUIRE(proto.isFile(), \"Expected a file node.\", (uint)proto.which());\n\n    return kj::strTree(\n      \"# \", proto.getDisplayName(), \"\\n\",\n      \"@0x\", kj::hex(proto.getId()), \";\\n\",\n      KJ_MAP(ann, proto.getAnnotations()) { return genAnnotation(ann, file, \"\", \";\\n\"); },\n      genNestedDecls(file, Indent(0)));\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"# \"",
            "proto.getDisplayName()",
            "\"\\n\"",
            "\"@0x\"",
            "kj::hex(proto.getId())",
            "\";\\n\"",
            "KJ_MAP(ann, proto.getAnnotations()){ return genAnnotation(ann, file, \"\", \";\\n\"); }",
            "genNestedDecls(file, Indent(0))"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genNestedDecls",
          "args": [
            "file",
            "Indent(0)"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "genNestedDecls",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "636-641",
          "snippet": "kj::StringTree genNestedDecls(Schema schema, Indent indent) {\n    uint64_t id = schema.getProto().getId();\n    return kj::strTree(KJ_MAP(nested, schema.getProto().getNestedNodes()) {\n      return genDecl(schemaLoader.get(nested.getId()), nested.getName(), id, indent);\n    });\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genNestedDecls(Schema schema, Indent indent) {\n      uint64_t id = schema.getProto().getId();\n      return kj::strTree(KJ_MAP(nested, schema.getProto().getNestedNodes()) {\n        return genDecl(schemaLoader.get(nested.getId()), nested.getName(), id, indent);\n      });\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Indent",
          "args": [
            "0"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "Iterator",
          "container": "Indent::Iterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "66-66",
          "snippet": "inline Iterator(uint i): i(i) {}",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Iterator {\n    inline Iterator(uint i): i(i) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "genAnnotation",
          "args": [
            "ann",
            "file",
            "\"\"",
            "\";\\n\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "ann",
            "proto.getAnnotations()"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getAnnotations",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "proto.getId()"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getId",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getDisplayName",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "proto.isFile()",
            "\"Expected a file node.\"",
            "(uint)proto.which()"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.which",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.isFile",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.getProto",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genFile(Schema file) {\n      auto proto = file.getProto();\n      KJ_REQUIRE(proto.isFile(), \"Expected a file node.\", (uint)proto.which());\n  \n      return kj::strTree(\n        \"# \", proto.getDisplayName(), \"\\n\",\n        \"@0x\", kj::hex(proto.getId()), \";\\n\",\n        KJ_MAP(ann, proto.getAnnotations()) { return genAnnotation(ann, file, \"\", \";\\n\"); },\n        genNestedDecls(file, Indent(0)));\n    }\n}"
  },
  {
    "function_name": "genNestedDecls",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "636-641",
    "snippet": "kj::StringTree genNestedDecls(Schema schema, Indent indent) {\n    uint64_t id = schema.getProto().getId();\n    return kj::strTree(KJ_MAP(nested, schema.getProto().getNestedNodes()) {\n      return genDecl(schemaLoader.get(nested.getId()), nested.getName(), id, indent);\n    });\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "KJ_MAP(nested, schema.getProto().getNestedNodes()){\n      return genDecl(schemaLoader.get(nested.getId()), nested.getName(), id, indent);\n    }"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genDecl",
          "args": [
            "schemaLoader.get(nested.getId())",
            "nested.getName()",
            "id",
            "indent"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "genDecl",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "523-634",
          "snippet": "kj::StringTree genDecl(Schema schema, Text::Reader name, uint64_t scopeId, Indent indent) {\n    auto proto = schema.getProto();\n    if (proto.getScopeId() != scopeId) {\n      // This appears to be an alias for something declared elsewhere.\n      KJ_FAIL_REQUIRE(\"Aliases not implemented.\");\n    }\n\n    switch (proto.which()) {\n      case schema::Node::FILE:\n        KJ_FAIL_REQUIRE(\"Encountered nested file node.\");\n        break;\n      case schema::Node::STRUCT: {\n        auto structProto = proto.getStruct();\n        return kj::strTree(\n            indent, \"struct \", name,\n            \" @0x\", kj::hex(proto.getId()), genGenericParams(schema),\n            genAnnotations(schema), \" {  # \",\n            structProto.getDataWordCount() * 8, \" bytes, \",\n            structProto.getPointerCount(), \" ptrs\",\n            structProto.getPreferredListEncoding() == schema::ElementSize::INLINE_COMPOSITE\n                ? kj::strTree()\n                : kj::strTree(\", packed as \",\n                              elementSizeName(structProto.getPreferredListEncoding())),\n            \"\\n\",\n            genStructFields(schema.asStruct(), indent.next()),\n            genNestedDecls(schema, indent.next()),\n            indent, \"}\\n\");\n      }\n      case schema::Node::ENUM: {\n        return kj::strTree(\n            indent, \"enum \", name, \" @0x\", kj::hex(proto.getId()), genAnnotations(schema), \" {\\n\",\n            KJ_MAP(enumerant, sortByCodeOrder(schema.asEnum().getEnumerants())) {\n              return kj::strTree(indent.next(), enumerant.getProto().getName(), \" @\",\n                                 enumerant.getIndex(),\n                                 genAnnotations(enumerant.getProto().getAnnotations(), schema),\n                                 \";\\n\");\n            },\n            genNestedDecls(schema, indent.next()),\n            indent, \"}\\n\");\n      }\n      case schema::Node::INTERFACE: {\n        auto interface = schema.asInterface();\n        return kj::strTree(\n            indent, \"interface \", name, \" @0x\", kj::hex(proto.getId()), genGenericParams(schema),\n            genSuperclasses(interface),\n            genAnnotations(schema), \" {\\n\",\n            KJ_MAP(method, sortByCodeOrder(interface.getMethods())) {\n              auto methodProto = method.getProto();\n\n              auto implicits = methodProto.getImplicitParameters();\n              kj::StringTree implicitsStr;\n              if (implicits.size() > 0) {\n                implicitsStr = kj::strTree(\n                    \"[\", kj::StringTree(KJ_MAP(implicit, implicits) {\n                      return kj::strTree(implicit.getName());\n                    }, \", \"), \"] \");\n              }\n\n              auto params = schemaLoader.get(methodProto.getParamStructType()).asStruct();\n              auto results = schemaLoader.get(methodProto.getResultStructType()).asStruct();\n              return kj::strTree(\n                  indent.next(), methodProto.getName(),\n                  \" @\", method.getIndex(), \" \", kj::mv(implicitsStr),\n                  genParamList(interface, params, methodProto.getParamBrand(), method), \" -> \",\n                  genParamList(interface, results, methodProto.getResultBrand(), method),\n                  genAnnotations(methodProto.getAnnotations(), interface), \";\\n\");\n            },\n            genNestedDecls(schema, indent.next()),\n            indent, \"}\\n\");\n      }\n      case schema::Node::CONST: {\n        auto constProto = proto.getConst();\n        return kj::strTree(\n            indent, \"const \", name, \" @0x\", kj::hex(proto.getId()), \" :\",\n            genType(constProto.getType(), schema, nullptr), \" = \",\n            genValue(schema.asConst().getType(), constProto.getValue()),\n            genAnnotations(schema), \";\\n\");\n      }\n      case schema::Node::ANNOTATION: {\n        auto annotationProto = proto.getAnnotation();\n\n        kj::Vector<kj::String> targets(8);\n        bool targetsAll = true;\n\n        auto dynamic = toDynamic(annotationProto);\n        for (auto field: dynamic.getSchema().getFields()) {\n          auto fieldName = field.getProto().getName();\n          if (fieldName.startsWith(\"targets\")) {\n            if (dynamic.get(field).as<bool>()) {\n              auto target = kj::str(fieldName.slice(strlen(\"targets\")));\n              target[0] = target[0] - 'A' + 'a';\n              targets.add(kj::mv(target));\n            } else {\n              targetsAll = false;\n            }\n          }\n        }\n\n        if (targetsAll) {\n          targets = kj::Vector<kj::String>(1);\n          targets.add(kj::heapString(\"*\"));\n        }\n\n        return kj::strTree(\n            indent, \"annotation \", name, \" @0x\", kj::hex(proto.getId()),\n            \" (\", strArray(targets, \", \"), \") :\",\n            genType(annotationProto.getType(), schema, nullptr), genAnnotations(schema), \";\\n\");\n      }\n    }\n\n    return kj::strTree();\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genDecl(Schema schema, Text::Reader name, uint64_t scopeId, Indent indent) {\n      auto proto = schema.getProto();\n      if (proto.getScopeId() != scopeId) {\n        // This appears to be an alias for something declared elsewhere.\n        KJ_FAIL_REQUIRE(\"Aliases not implemented.\");\n      }\n  \n      switch (proto.which()) {\n        case schema::Node::FILE:\n          KJ_FAIL_REQUIRE(\"Encountered nested file node.\");\n          break;\n        case schema::Node::STRUCT: {\n          auto structProto = proto.getStruct();\n          return kj::strTree(\n              indent, \"struct \", name,\n              \" @0x\", kj::hex(proto.getId()), genGenericParams(schema),\n              genAnnotations(schema), \" {  # \",\n              structProto.getDataWordCount() * 8, \" bytes, \",\n              structProto.getPointerCount(), \" ptrs\",\n              structProto.getPreferredListEncoding() == schema::ElementSize::INLINE_COMPOSITE\n                  ? kj::strTree()\n                  : kj::strTree(\", packed as \",\n                                elementSizeName(structProto.getPreferredListEncoding())),\n              \"\\n\",\n              genStructFields(schema.asStruct(), indent.next()),\n              genNestedDecls(schema, indent.next()),\n              indent, \"}\\n\");\n        }\n        case schema::Node::ENUM: {\n          return kj::strTree(\n              indent, \"enum \", name, \" @0x\", kj::hex(proto.getId()), genAnnotations(schema), \" {\\n\",\n              KJ_MAP(enumerant, sortByCodeOrder(schema.asEnum().getEnumerants())) {\n                return kj::strTree(indent.next(), enumerant.getProto().getName(), \" @\",\n                                   enumerant.getIndex(),\n                                   genAnnotations(enumerant.getProto().getAnnotations(), schema),\n                                   \";\\n\");\n              },\n              genNestedDecls(schema, indent.next()),\n              indent, \"}\\n\");\n        }\n        case schema::Node::INTERFACE: {\n          auto interface = schema.asInterface();\n          return kj::strTree(\n              indent, \"interface \", name, \" @0x\", kj::hex(proto.getId()), genGenericParams(schema),\n              genSuperclasses(interface),\n              genAnnotations(schema), \" {\\n\",\n              KJ_MAP(method, sortByCodeOrder(interface.getMethods())) {\n                auto methodProto = method.getProto();\n  \n                auto implicits = methodProto.getImplicitParameters();\n                kj::StringTree implicitsStr;\n                if (implicits.size() > 0) {\n                  implicitsStr = kj::strTree(\n                      \"[\", kj::StringTree(KJ_MAP(implicit, implicits) {\n                        return kj::strTree(implicit.getName());\n                      }, \", \"), \"] \");\n                }\n  \n                auto params = schemaLoader.get(methodProto.getParamStructType()).asStruct();\n                auto results = schemaLoader.get(methodProto.getResultStructType()).asStruct();\n                return kj::strTree(\n                    indent.next(), methodProto.getName(),\n                    \" @\", method.getIndex(), \" \", kj::mv(implicitsStr),\n                    genParamList(interface, params, methodProto.getParamBrand(), method), \" -> \",\n                    genParamList(interface, results, methodProto.getResultBrand(), method),\n                    genAnnotations(methodProto.getAnnotations(), interface), \";\\n\");\n              },\n              genNestedDecls(schema, indent.next()),\n              indent, \"}\\n\");\n        }\n        case schema::Node::CONST: {\n          auto constProto = proto.getConst();\n          return kj::strTree(\n              indent, \"const \", name, \" @0x\", kj::hex(proto.getId()), \" :\",\n              genType(constProto.getType(), schema, nullptr), \" = \",\n              genValue(schema.asConst().getType(), constProto.getValue()),\n              genAnnotations(schema), \";\\n\");\n        }\n        case schema::Node::ANNOTATION: {\n          auto annotationProto = proto.getAnnotation();\n  \n          kj::Vector<kj::String> targets(8);\n          bool targetsAll = true;\n  \n          auto dynamic = toDynamic(annotationProto);\n          for (auto field: dynamic.getSchema().getFields()) {\n            auto fieldName = field.getProto().getName();\n            if (fieldName.startsWith(\"targets\")) {\n              if (dynamic.get(field).as<bool>()) {\n                auto target = kj::str(fieldName.slice(strlen(\"targets\")));\n                target[0] = target[0] - 'A' + 'a';\n                targets.add(kj::mv(target));\n              } else {\n                targetsAll = false;\n              }\n            }\n          }\n  \n          if (targetsAll) {\n            targets = kj::Vector<kj::String>(1);\n            targets.add(kj::heapString(\"*\"));\n          }\n  \n          return kj::strTree(\n              indent, \"annotation \", name, \" @0x\", kj::hex(proto.getId()),\n              \" (\", strArray(targets, \", \"), \") :\",\n              genType(annotationProto.getType(), schema, nullptr), genAnnotations(schema), \";\\n\");\n        }\n      }\n  \n      return kj::strTree();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested.getName",
          "args": [],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "nested.getId()"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "nested.getId",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "nested",
            "schema.getProto().getNestedNodes()"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genNestedDecls(Schema schema, Indent indent) {\n      uint64_t id = schema.getProto().getId();\n      return kj::strTree(KJ_MAP(nested, schema.getProto().getNestedNodes()) {\n        return genDecl(schemaLoader.get(nested.getId()), nested.getName(), id, indent);\n      });\n    }\n}"
  },
  {
    "function_name": "genDecl",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "523-634",
    "snippet": "kj::StringTree genDecl(Schema schema, Text::Reader name, uint64_t scopeId, Indent indent) {\n    auto proto = schema.getProto();\n    if (proto.getScopeId() != scopeId) {\n      // This appears to be an alias for something declared elsewhere.\n      KJ_FAIL_REQUIRE(\"Aliases not implemented.\");\n    }\n\n    switch (proto.which()) {\n      case schema::Node::FILE:\n        KJ_FAIL_REQUIRE(\"Encountered nested file node.\");\n        break;\n      case schema::Node::STRUCT: {\n        auto structProto = proto.getStruct();\n        return kj::strTree(\n            indent, \"struct \", name,\n            \" @0x\", kj::hex(proto.getId()), genGenericParams(schema),\n            genAnnotations(schema), \" {  # \",\n            structProto.getDataWordCount() * 8, \" bytes, \",\n            structProto.getPointerCount(), \" ptrs\",\n            structProto.getPreferredListEncoding() == schema::ElementSize::INLINE_COMPOSITE\n                ? kj::strTree()\n                : kj::strTree(\", packed as \",\n                              elementSizeName(structProto.getPreferredListEncoding())),\n            \"\\n\",\n            genStructFields(schema.asStruct(), indent.next()),\n            genNestedDecls(schema, indent.next()),\n            indent, \"}\\n\");\n      }\n      case schema::Node::ENUM: {\n        return kj::strTree(\n            indent, \"enum \", name, \" @0x\", kj::hex(proto.getId()), genAnnotations(schema), \" {\\n\",\n            KJ_MAP(enumerant, sortByCodeOrder(schema.asEnum().getEnumerants())) {\n              return kj::strTree(indent.next(), enumerant.getProto().getName(), \" @\",\n                                 enumerant.getIndex(),\n                                 genAnnotations(enumerant.getProto().getAnnotations(), schema),\n                                 \";\\n\");\n            },\n            genNestedDecls(schema, indent.next()),\n            indent, \"}\\n\");\n      }\n      case schema::Node::INTERFACE: {\n        auto interface = schema.asInterface();\n        return kj::strTree(\n            indent, \"interface \", name, \" @0x\", kj::hex(proto.getId()), genGenericParams(schema),\n            genSuperclasses(interface),\n            genAnnotations(schema), \" {\\n\",\n            KJ_MAP(method, sortByCodeOrder(interface.getMethods())) {\n              auto methodProto = method.getProto();\n\n              auto implicits = methodProto.getImplicitParameters();\n              kj::StringTree implicitsStr;\n              if (implicits.size() > 0) {\n                implicitsStr = kj::strTree(\n                    \"[\", kj::StringTree(KJ_MAP(implicit, implicits) {\n                      return kj::strTree(implicit.getName());\n                    }, \", \"), \"] \");\n              }\n\n              auto params = schemaLoader.get(methodProto.getParamStructType()).asStruct();\n              auto results = schemaLoader.get(methodProto.getResultStructType()).asStruct();\n              return kj::strTree(\n                  indent.next(), methodProto.getName(),\n                  \" @\", method.getIndex(), \" \", kj::mv(implicitsStr),\n                  genParamList(interface, params, methodProto.getParamBrand(), method), \" -> \",\n                  genParamList(interface, results, methodProto.getResultBrand(), method),\n                  genAnnotations(methodProto.getAnnotations(), interface), \";\\n\");\n            },\n            genNestedDecls(schema, indent.next()),\n            indent, \"}\\n\");\n      }\n      case schema::Node::CONST: {\n        auto constProto = proto.getConst();\n        return kj::strTree(\n            indent, \"const \", name, \" @0x\", kj::hex(proto.getId()), \" :\",\n            genType(constProto.getType(), schema, nullptr), \" = \",\n            genValue(schema.asConst().getType(), constProto.getValue()),\n            genAnnotations(schema), \";\\n\");\n      }\n      case schema::Node::ANNOTATION: {\n        auto annotationProto = proto.getAnnotation();\n\n        kj::Vector<kj::String> targets(8);\n        bool targetsAll = true;\n\n        auto dynamic = toDynamic(annotationProto);\n        for (auto field: dynamic.getSchema().getFields()) {\n          auto fieldName = field.getProto().getName();\n          if (fieldName.startsWith(\"targets\")) {\n            if (dynamic.get(field).as<bool>()) {\n              auto target = kj::str(fieldName.slice(strlen(\"targets\")));\n              target[0] = target[0] - 'A' + 'a';\n              targets.add(kj::mv(target));\n            } else {\n              targetsAll = false;\n            }\n          }\n        }\n\n        if (targetsAll) {\n          targets = kj::Vector<kj::String>(1);\n          targets.add(kj::heapString(\"*\"));\n        }\n\n        return kj::strTree(\n            indent, \"annotation \", name, \" @0x\", kj::hex(proto.getId()),\n            \" (\", strArray(targets, \", \"), \") :\",\n            genType(annotationProto.getType(), schema, nullptr), genAnnotations(schema), \";\\n\");\n      }\n    }\n\n    return kj::strTree();\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "strTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string-tree.h",
          "lines": "206-208",
          "snippet": "StringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}",
          "includes": [
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n\nStringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent",
            "\"annotation \"",
            "name",
            "\" @0x\"",
            "kj::hex(proto.getId())",
            "\" (\"",
            "strArray(targets, \", \")",
            "\") :\"",
            "genType(annotationProto.getType(), schema, nullptr)",
            "genAnnotations(schema)",
            "\";\\n\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genAnnotations",
          "args": [
            "schema"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "genAnnotations",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "393-396",
          "snippet": "kj::StringTree genAnnotations(Schema schema) {\n    auto proto = schema.getProto();\n    return genAnnotations(proto.getAnnotations(), schemaLoader.get(proto.getScopeId()));\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genAnnotations(Schema schema) {\n      auto proto = schema.getProto();\n      return genAnnotations(proto.getAnnotations(), schemaLoader.get(proto.getScopeId()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "genType",
          "args": [
            "annotationProto.getType()",
            "schema",
            "nullptr"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "genType",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "196-261",
          "snippet": "kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                         kj::Maybe<InterfaceSchema::Method> method) {\n    switch (type.which()) {\n      case schema::Type::VOID: return kj::strTree(\"Void\");\n      case schema::Type::BOOL: return kj::strTree(\"Bool\");\n      case schema::Type::INT8: return kj::strTree(\"Int8\");\n      case schema::Type::INT16: return kj::strTree(\"Int16\");\n      case schema::Type::INT32: return kj::strTree(\"Int32\");\n      case schema::Type::INT64: return kj::strTree(\"Int64\");\n      case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n      case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n      case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n      case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n      case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n      case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n      case schema::Type::TEXT: return kj::strTree(\"Text\");\n      case schema::Type::DATA: return kj::strTree(\"Data\");\n      case schema::Type::LIST:\n        return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n      case schema::Type::ENUM:\n        return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                        type.getEnum().getBrand(), method);\n      case schema::Type::STRUCT:\n        return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                        type.getStruct().getBrand(), method);\n      case schema::Type::INTERFACE:\n        return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                        type.getInterface().getBrand(), method);\n      case schema::Type::ANY_POINTER: {\n        auto anyPointer = type.getAnyPointer();\n        switch (anyPointer.which()) {\n          case schema::Type::AnyPointer::UNCONSTRAINED:\n            switch (anyPointer.getUnconstrained().which()) {\n              case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                return kj::strTree(\"AnyStruct\");\n              case schema::Type::AnyPointer::Unconstrained::LIST:\n                return kj::strTree(\"AnyList\");\n              case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                return kj::strTree(\"Capability\");\n            }\n            KJ_UNREACHABLE;\n          case schema::Type::AnyPointer::PARAMETER: {\n            auto param = anyPointer.getParameter();\n            auto scopeProto = scope.getProto();\n            auto targetScopeId = param.getScopeId();\n            while (scopeProto.getId() != targetScopeId) {\n              scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n            }\n            auto params = scopeProto.getParameters();\n            KJ_REQUIRE(param.getParameterIndex() < params.size());\n            return kj::strTree(params[param.getParameterIndex()].getName());\n          }\n          case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n            auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n            uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n            KJ_REQUIRE(index < params.size());\n            return kj::strTree(params[index].getName());\n          }\n        }\n        KJ_UNREACHABLE;\n      }\n    }\n    return kj::strTree();\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                           kj::Maybe<InterfaceSchema::Method> method) {\n      switch (type.which()) {\n        case schema::Type::VOID: return kj::strTree(\"Void\");\n        case schema::Type::BOOL: return kj::strTree(\"Bool\");\n        case schema::Type::INT8: return kj::strTree(\"Int8\");\n        case schema::Type::INT16: return kj::strTree(\"Int16\");\n        case schema::Type::INT32: return kj::strTree(\"Int32\");\n        case schema::Type::INT64: return kj::strTree(\"Int64\");\n        case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n        case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n        case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n        case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n        case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n        case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n        case schema::Type::TEXT: return kj::strTree(\"Text\");\n        case schema::Type::DATA: return kj::strTree(\"Data\");\n        case schema::Type::LIST:\n          return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n        case schema::Type::ENUM:\n          return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                          type.getEnum().getBrand(), method);\n        case schema::Type::STRUCT:\n          return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                          type.getStruct().getBrand(), method);\n        case schema::Type::INTERFACE:\n          return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                          type.getInterface().getBrand(), method);\n        case schema::Type::ANY_POINTER: {\n          auto anyPointer = type.getAnyPointer();\n          switch (anyPointer.which()) {\n            case schema::Type::AnyPointer::UNCONSTRAINED:\n              switch (anyPointer.getUnconstrained().which()) {\n                case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                  return kj::strTree(\"AnyPointer\");\n                case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                  return kj::strTree(\"AnyStruct\");\n                case schema::Type::AnyPointer::Unconstrained::LIST:\n                  return kj::strTree(\"AnyList\");\n                case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                  return kj::strTree(\"Capability\");\n              }\n              KJ_UNREACHABLE;\n            case schema::Type::AnyPointer::PARAMETER: {\n              auto param = anyPointer.getParameter();\n              auto scopeProto = scope.getProto();\n              auto targetScopeId = param.getScopeId();\n              while (scopeProto.getId() != targetScopeId) {\n                scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n              }\n              auto params = scopeProto.getParameters();\n              KJ_REQUIRE(param.getParameterIndex() < params.size());\n              return kj::strTree(params[param.getParameterIndex()].getName());\n            }\n            case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n              auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n              uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n              KJ_REQUIRE(index < params.size());\n              return kj::strTree(params[index].getName());\n            }\n          }\n          KJ_UNREACHABLE;\n        }\n      }\n      return kj::strTree();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "annotationProto.getType",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "targets",
            "\", \""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "proto.getId()"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getId",
          "args": [],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "targets.add",
          "args": [
            "kj::heapString(\"*\")"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "\"*\""
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::Vector<kj::String>",
          "args": [
            "1"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "Vector",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "45-45",
          "snippet": "inline explicit Vector(size_t capacity): builder(heapArrayBuilder<T>(capacity)) {}",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline explicit Vector(size_t capacity): builder(heapArrayBuilder<T>(capacity)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "target"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::str",
          "args": [
            "fieldName.slice(strlen(\"targets\"))"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "341-341",
          "snippet": "inline String str(String&& s) { return mv(s); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\ninline String str(String&& s) { return mv(s); }"
        }
      },
      {
        "call_info": {
          "callee": "fieldName.slice",
          "args": [
            "strlen(\"targets\")"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"targets\""
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dynamic.get",
          "args": [],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynamic.get",
          "args": [
            "field"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "fieldName.startsWith",
          "args": [
            "\"targets\""
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "dynamic.getSchema",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "getSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "505-505",
          "snippet": "inline InterfaceSchema getSchema() const { return schema; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline InterfaceSchema getSchema() const { return schema; }"
        }
      },
      {
        "call_info": {
          "callee": "toDynamic",
          "args": [
            "annotationProto"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "toDynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "1246-1248",
          "snippet": "typename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ntypename DynamicTypeFor<FromServer<T>>::Client toDynamic(kj::Own<T>&& value) {\n  return typename FromServer<T>::Client(kj::mv(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getAnnotation",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent",
            "\"const \"",
            "name",
            "\" @0x\"",
            "kj::hex(proto.getId())",
            "\" :\"",
            "genType(constProto.getType(), schema, nullptr)",
            "\" = \"",
            "genValue(schema.asConst().getType(), constProto.getValue())",
            "genAnnotations(schema)",
            "\";\\n\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genValue",
          "args": [
            "schema.asConst().getType()",
            "constProto.getValue()"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "genValue",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "313-356",
          "snippet": "kj::StringTree genValue(Type type, schema::Value::Reader value) {\n    switch (value.which()) {\n      case schema::Value::VOID: return kj::strTree(\"void\");\n      case schema::Value::BOOL:\n        return kj::strTree(value.getBool() ? \"true\" : \"false\");\n      case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n      case schema::Value::INT16: return kj::strTree(value.getInt16());\n      case schema::Value::INT32: return kj::strTree(value.getInt32());\n      case schema::Value::INT64: return kj::strTree(value.getInt64());\n      case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n      case schema::Value::UINT16: return kj::strTree(value.getUint16());\n      case schema::Value::UINT32: return kj::strTree(value.getUint32());\n      case schema::Value::UINT64: return kj::strTree(value.getUint64());\n      case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n      case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n      case schema::Value::TEXT:\n        return kj::strTree(DynamicValue::Reader(value.getText()));\n      case schema::Value::DATA:\n        return kj::strTree(DynamicValue::Reader(value.getData()));\n      case schema::Value::LIST: {\n        auto listValue = value.getList().getAs<DynamicList>(type.asList());\n        return kj::strTree(listValue);\n      }\n      case schema::Value::ENUM: {\n        auto enumNode = type.asEnum().getProto();\n        auto enumerants = enumNode.getEnum().getEnumerants();\n        KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n        return kj::strTree(enumerants[value.getEnum()].getName());\n      }\n      case schema::Value::STRUCT: {\n        KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n        auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n        return kj::strTree(structValue);\n      }\n      case schema::Value::INTERFACE: {\n        return kj::strTree(\"\");\n      }\n      case schema::Value::ANY_POINTER: {\n        return kj::strTree(\"\");\n      }\n    }\n    return kj::strTree(\"\");\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genValue(Type type, schema::Value::Reader value) {\n      switch (value.which()) {\n        case schema::Value::VOID: return kj::strTree(\"void\");\n        case schema::Value::BOOL:\n          return kj::strTree(value.getBool() ? \"true\" : \"false\");\n        case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n        case schema::Value::INT16: return kj::strTree(value.getInt16());\n        case schema::Value::INT32: return kj::strTree(value.getInt32());\n        case schema::Value::INT64: return kj::strTree(value.getInt64());\n        case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n        case schema::Value::UINT16: return kj::strTree(value.getUint16());\n        case schema::Value::UINT32: return kj::strTree(value.getUint32());\n        case schema::Value::UINT64: return kj::strTree(value.getUint64());\n        case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n        case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n        case schema::Value::TEXT:\n          return kj::strTree(DynamicValue::Reader(value.getText()));\n        case schema::Value::DATA:\n          return kj::strTree(DynamicValue::Reader(value.getData()));\n        case schema::Value::LIST: {\n          auto listValue = value.getList().getAs<DynamicList>(type.asList());\n          return kj::strTree(listValue);\n        }\n        case schema::Value::ENUM: {\n          auto enumNode = type.asEnum().getProto();\n          auto enumerants = enumNode.getEnum().getEnumerants();\n          KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                  \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n          return kj::strTree(enumerants[value.getEnum()].getName());\n        }\n        case schema::Value::STRUCT: {\n          KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n          auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n          return kj::strTree(structValue);\n        }\n        case schema::Value::INTERFACE: {\n          return kj::strTree(\"\");\n        }\n        case schema::Value::ANY_POINTER: {\n          return kj::strTree(\"\");\n        }\n      }\n      return kj::strTree(\"\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "constProto.getValue",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.asConst",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "asConst",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1127-1129",
          "snippet": "inline ArrayPtr<const T> asConst() const {\n    return ArrayPtr<const T>(ptr, size_);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr<const T> asConst() const {\n      return ArrayPtr<const T>(ptr, size_);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "proto.getId()"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getConst",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent",
            "\"interface \"",
            "name",
            "\" @0x\"",
            "kj::hex(proto.getId())",
            "genGenericParams(schema)",
            "genSuperclasses(interface)",
            "genAnnotations(schema)",
            "\" {\\n\"",
            "KJ_MAP(method, sortByCodeOrder(interface.getMethods())){\n              auto methodProto = method.getProto();\n\n              auto implicits = methodProto.getImplicitParameters();\n              kj::StringTree implicitsStr;\n              if (implicits.size() > 0) {\n                implicitsStr = kj::strTree(\n                    \"[\", kj::StringTree(KJ_MAP(implicit, implicits) {\n                      return kj::strTree(implicit.getName());\n                    }, \", \"), \"] \");\n              }\n\n              auto params = schemaLoader.get(methodProto.getParamStructType()).asStruct();\n              auto results = schemaLoader.get(methodProto.getResultStructType()).asStruct();\n              return kj::strTree(\n                  indent.next(), methodProto.getName(),\n                  \" @\", method.getIndex(), \" \", kj::mv(implicitsStr),\n                  genParamList(interface, params, methodProto.getParamBrand(), method), \" -> \",\n                  genParamList(interface, results, methodProto.getResultBrand(), method),\n                  genAnnotations(methodProto.getAnnotations(), interface), \";\\n\");\n            }",
            "genNestedDecls(schema, indent.next())",
            "indent",
            "\"}\\n\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genNestedDecls",
          "args": [
            "schema",
            "indent.next()"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "genNestedDecls",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "636-641",
          "snippet": "kj::StringTree genNestedDecls(Schema schema, Indent indent) {\n    uint64_t id = schema.getProto().getId();\n    return kj::strTree(KJ_MAP(nested, schema.getProto().getNestedNodes()) {\n      return genDecl(schemaLoader.get(nested.getId()), nested.getName(), id, indent);\n    });\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genNestedDecls(Schema schema, Indent indent) {\n      uint64_t id = schema.getProto().getId();\n      return kj::strTree(KJ_MAP(nested, schema.getProto().getNestedNodes()) {\n        return genDecl(schemaLoader.get(nested.getId()), nested.getName(), id, indent);\n      });\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "indent.next",
          "args": [],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "59-61",
          "snippet": "Indent next() {\n    return Indent(amount + 2);\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Indent next() {\n      return Indent(amount + 2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent.next()",
            "methodProto.getName()",
            "\" @\"",
            "method.getIndex()",
            "\" \"",
            "kj::mv(implicitsStr)",
            "genParamList(interface, params, methodProto.getParamBrand(), method)",
            "\" -> \"",
            "genParamList(interface, results, methodProto.getResultBrand(), method)",
            "genAnnotations(methodProto.getAnnotations(), interface)",
            "\";\\n\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "methodProto.getAnnotations",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genParamList",
          "args": [
            "interface",
            "results",
            "methodProto.getResultBrand()",
            "method"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "genParamList",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "490-508",
          "snippet": "kj::StringTree genParamList(InterfaceSchema interface, StructSchema schema,\n                              schema::Brand::Reader brand, InterfaceSchema::Method method) {\n    if (schema.getProto().getScopeId() == 0) {\n      // A named parameter list.\n      return kj::strTree(\"(\", kj::StringTree(\n          KJ_MAP(field, schema.getFields()) {\n            auto proto = field.getProto();\n            auto slot = proto.getSlot();\n\n            return kj::strTree(\n                proto.getName(), \" :\", genType(slot.getType(), interface, nullptr),\n                isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                    kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n                genAnnotations(proto.getAnnotations(), interface));\n          }, \", \"), \")\");\n    } else {\n      return nodeName(schema, interface, brand, method);\n    }\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genParamList(InterfaceSchema interface, StructSchema schema,\n                                schema::Brand::Reader brand, InterfaceSchema::Method method) {\n      if (schema.getProto().getScopeId() == 0) {\n        // A named parameter list.\n        return kj::strTree(\"(\", kj::StringTree(\n            KJ_MAP(field, schema.getFields()) {\n              auto proto = field.getProto();\n              auto slot = proto.getSlot();\n  \n              return kj::strTree(\n                  proto.getName(), \" :\", genType(slot.getType(), interface, nullptr),\n                  isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                      kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n                  genAnnotations(proto.getAnnotations(), interface));\n            }, \", \"), \")\");\n      } else {\n        return nodeName(schema, interface, brand, method);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "methodProto.getResultBrand",
          "args": [],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "methodProto.getParamBrand",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "implicitsStr"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "method.getIndex",
          "args": [],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "getIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "487-487",
          "snippet": "inline uint getIndex() const { return ordinal; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint getIndex() const { return ordinal; }"
        }
      },
      {
        "call_info": {
          "callee": "methodProto.getName",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "methodProto.getResultStructType",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "methodProto.getParamStructType",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"[\"",
            "kj::StringTree(KJ_MAP(implicit, implicits) {\n                      return kj::strTree(implicit.getName());\n                    }, \", \")",
            "\"] \""
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "KJ_MAP(implicit, implicits){\n                      return kj::strTree(implicit.getName());\n                    }",
            "\", \""
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "implicit.getName()"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "implicit.getName",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "implicit",
            "implicits"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "implicits.size",
          "args": [],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "methodProto.getImplicitParameters",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "method",
            "sortByCodeOrder(interface.getMethods())"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sortByCodeOrder",
          "args": [
            "interface.getMethods()"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "sortByCodeOrder",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "420-424",
          "snippet": "kj::Array<decltype(kj::instance<MemberList>()[0])> sortByCodeOrder(MemberList&& list) {\n    auto sorted = KJ_MAP(item, list) { return item; };\n    std::sort(sorted.begin(), sorted.end(), OrderByCodeOrder());\n    return kj::mv(sorted);\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::Array<decltype(kj::instance<MemberList>()[0])> sortByCodeOrder(MemberList&& list) {\n      auto sorted = KJ_MAP(item, list) { return item; };\n      std::sort(sorted.begin(), sorted.end(), OrderByCodeOrder());\n      return kj::mv(sorted);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface.getMethods",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genSuperclasses",
          "args": [
            "interface"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "genSuperclasses",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "510-521",
          "snippet": "kj::StringTree genSuperclasses(InterfaceSchema interface) {\n    auto superclasses = interface.getProto().getInterface().getSuperclasses();\n    if (superclasses.size() == 0) {\n      return kj::strTree();\n    } else {\n      return kj::strTree(\" superclasses(\", kj::StringTree(\n          KJ_MAP(superclass, superclasses) {\n            return nodeName(schemaLoader.get(superclass.getId()), interface,\n                            superclass.getBrand(), nullptr);\n          }, \", \"), \")\");\n    }\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genSuperclasses(InterfaceSchema interface) {\n      auto superclasses = interface.getProto().getInterface().getSuperclasses();\n      if (superclasses.size() == 0) {\n        return kj::strTree();\n      } else {\n        return kj::strTree(\" superclasses(\", kj::StringTree(\n            KJ_MAP(superclass, superclasses) {\n              return nodeName(schemaLoader.get(superclass.getId()), interface,\n                              superclass.getBrand(), nullptr);\n            }, \", \"), \")\");\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "genGenericParams",
          "args": [
            "schema"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "genGenericParams",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "366-369",
          "snippet": "kj::StringTree genGenericParams(Schema schema) {\n    auto proto = schema.getProto();\n    return genGenericParams(proto.getParameters(), schemaLoader.get(proto.getScopeId()));\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genGenericParams(Schema schema) {\n      auto proto = schema.getProto();\n      return genGenericParams(proto.getParameters(), schemaLoader.get(proto.getScopeId()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "proto.getId()"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.asInterface",
          "args": [],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent",
            "\"enum \"",
            "name",
            "\" @0x\"",
            "kj::hex(proto.getId())",
            "genAnnotations(schema)",
            "\" {\\n\"",
            "KJ_MAP(enumerant, sortByCodeOrder(schema.asEnum().getEnumerants())){\n              return kj::strTree(indent.next(), enumerant.getProto().getName(), \" @\",\n                                 enumerant.getIndex(),\n                                 genAnnotations(enumerant.getProto().getAnnotations(), schema),\n                                 \";\\n\");\n            }",
            "genNestedDecls(schema, indent.next())",
            "indent",
            "\"}\\n\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent.next()",
            "enumerant.getProto().getName()",
            "\" @\"",
            "enumerant.getIndex()",
            "genAnnotations(enumerant.getProto().getAnnotations(), schema)",
            "\";\\n\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "enumerant",
            "sortByCodeOrder(schema.asEnum().getEnumerants())"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.asEnum",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.asEnum",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "proto.getId()"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent",
            "\"struct \"",
            "name",
            "\" @0x\"",
            "kj::hex(proto.getId())",
            "genGenericParams(schema)",
            "genAnnotations(schema)",
            "\" {  # \"",
            "structProto.getDataWordCount() * 8",
            "\" bytes, \"",
            "structProto.getPointerCount()",
            "\" ptrs\"",
            "structProto.getPreferredListEncoding() == schema::ElementSize::INLINE_COMPOSITE\n                ? kj::strTree()\n                : kj::strTree(\", packed as \",\n                              elementSizeName(structProto.getPreferredListEncoding()))",
            "\"\\n\"",
            "genStructFields(schema.asStruct(), indent.next())",
            "genNestedDecls(schema, indent.next())",
            "indent",
            "\"}\\n\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genStructFields",
          "args": [
            "schema.asStruct()",
            "indent.next()"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "genStructFields",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "426-454",
          "snippet": "kj::Array<kj::StringTree> genStructFields(StructSchema schema, Indent indent) {\n    // Slightly hacky:  We want to print in code order, but we also need to print the union in one\n    //   chunk.  Its fields should be together in code order anyway, but it's easier to simply\n    //   output the whole union in place of the first union field, and then output nothing for the\n    //   subsequent fields.\n\n    bool seenUnion = false;\n    return KJ_MAP(field, sortByCodeOrder(schema.getFields())) {\n      if (hasDiscriminantValue(field.getProto())) {\n        if (seenUnion) {\n          return kj::strTree();\n        } else {\n          seenUnion = true;\n          uint offset = schema.getProto().getStruct().getDiscriminantOffset();\n\n          // GCC 4.7.3 crashes if you inline unionFields.\n          auto unionFields = sortByCodeOrder(schema.getUnionFields());\n          return kj::strTree(\n              indent, \"union {  # tag bits [\", offset * 16, \", \", offset * 16 + 16, \")\\n\",\n              KJ_MAP(uField, unionFields) {\n                return genStructField(uField, schema, indent.next());\n              },\n              indent, \"}\\n\");\n        }\n      } else {\n        return genStructField(field, schema, indent);\n      }\n    };\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::Array<kj::StringTree> genStructFields(StructSchema schema, Indent indent) {\n      // Slightly hacky:  We want to print in code order, but we also need to print the union in one\n      //   chunk.  Its fields should be together in code order anyway, but it's easier to simply\n      //   output the whole union in place of the first union field, and then output nothing for the\n      //   subsequent fields.\n  \n      bool seenUnion = false;\n      return KJ_MAP(field, sortByCodeOrder(schema.getFields())) {\n        if (hasDiscriminantValue(field.getProto())) {\n          if (seenUnion) {\n            return kj::strTree();\n          } else {\n            seenUnion = true;\n            uint offset = schema.getProto().getStruct().getDiscriminantOffset();\n  \n            // GCC 4.7.3 crashes if you inline unionFields.\n            auto unionFields = sortByCodeOrder(schema.getUnionFields());\n            return kj::strTree(\n                indent, \"union {  # tag bits [\", offset * 16, \", \", offset * 16 + 16, \")\\n\",\n                KJ_MAP(uField, unionFields) {\n                  return genStructField(uField, schema, indent.next());\n                },\n                indent, \"}\\n\");\n          }\n        } else {\n          return genStructField(field, schema, indent);\n        }\n      };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema.asStruct",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\", packed as \"",
            "elementSizeName(structProto.getPreferredListEncoding())"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elementSizeName",
          "args": [
            "structProto.getPreferredListEncoding()"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structProto.getPreferredListEncoding",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structProto.getPreferredListEncoding",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structProto.getPointerCount",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "structProto.getDataWordCount",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::hex",
          "args": [
            "proto.getId()"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getStruct",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Encountered nested file node.\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.which",
          "args": [],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"Aliases not implemented.\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getScopeId",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genDecl(Schema schema, Text::Reader name, uint64_t scopeId, Indent indent) {\n      auto proto = schema.getProto();\n      if (proto.getScopeId() != scopeId) {\n        // This appears to be an alias for something declared elsewhere.\n        KJ_FAIL_REQUIRE(\"Aliases not implemented.\");\n      }\n  \n      switch (proto.which()) {\n        case schema::Node::FILE:\n          KJ_FAIL_REQUIRE(\"Encountered nested file node.\");\n          break;\n        case schema::Node::STRUCT: {\n          auto structProto = proto.getStruct();\n          return kj::strTree(\n              indent, \"struct \", name,\n              \" @0x\", kj::hex(proto.getId()), genGenericParams(schema),\n              genAnnotations(schema), \" {  # \",\n              structProto.getDataWordCount() * 8, \" bytes, \",\n              structProto.getPointerCount(), \" ptrs\",\n              structProto.getPreferredListEncoding() == schema::ElementSize::INLINE_COMPOSITE\n                  ? kj::strTree()\n                  : kj::strTree(\", packed as \",\n                                elementSizeName(structProto.getPreferredListEncoding())),\n              \"\\n\",\n              genStructFields(schema.asStruct(), indent.next()),\n              genNestedDecls(schema, indent.next()),\n              indent, \"}\\n\");\n        }\n        case schema::Node::ENUM: {\n          return kj::strTree(\n              indent, \"enum \", name, \" @0x\", kj::hex(proto.getId()), genAnnotations(schema), \" {\\n\",\n              KJ_MAP(enumerant, sortByCodeOrder(schema.asEnum().getEnumerants())) {\n                return kj::strTree(indent.next(), enumerant.getProto().getName(), \" @\",\n                                   enumerant.getIndex(),\n                                   genAnnotations(enumerant.getProto().getAnnotations(), schema),\n                                   \";\\n\");\n              },\n              genNestedDecls(schema, indent.next()),\n              indent, \"}\\n\");\n        }\n        case schema::Node::INTERFACE: {\n          auto interface = schema.asInterface();\n          return kj::strTree(\n              indent, \"interface \", name, \" @0x\", kj::hex(proto.getId()), genGenericParams(schema),\n              genSuperclasses(interface),\n              genAnnotations(schema), \" {\\n\",\n              KJ_MAP(method, sortByCodeOrder(interface.getMethods())) {\n                auto methodProto = method.getProto();\n  \n                auto implicits = methodProto.getImplicitParameters();\n                kj::StringTree implicitsStr;\n                if (implicits.size() > 0) {\n                  implicitsStr = kj::strTree(\n                      \"[\", kj::StringTree(KJ_MAP(implicit, implicits) {\n                        return kj::strTree(implicit.getName());\n                      }, \", \"), \"] \");\n                }\n  \n                auto params = schemaLoader.get(methodProto.getParamStructType()).asStruct();\n                auto results = schemaLoader.get(methodProto.getResultStructType()).asStruct();\n                return kj::strTree(\n                    indent.next(), methodProto.getName(),\n                    \" @\", method.getIndex(), \" \", kj::mv(implicitsStr),\n                    genParamList(interface, params, methodProto.getParamBrand(), method), \" -> \",\n                    genParamList(interface, results, methodProto.getResultBrand(), method),\n                    genAnnotations(methodProto.getAnnotations(), interface), \";\\n\");\n              },\n              genNestedDecls(schema, indent.next()),\n              indent, \"}\\n\");\n        }\n        case schema::Node::CONST: {\n          auto constProto = proto.getConst();\n          return kj::strTree(\n              indent, \"const \", name, \" @0x\", kj::hex(proto.getId()), \" :\",\n              genType(constProto.getType(), schema, nullptr), \" = \",\n              genValue(schema.asConst().getType(), constProto.getValue()),\n              genAnnotations(schema), \";\\n\");\n        }\n        case schema::Node::ANNOTATION: {\n          auto annotationProto = proto.getAnnotation();\n  \n          kj::Vector<kj::String> targets(8);\n          bool targetsAll = true;\n  \n          auto dynamic = toDynamic(annotationProto);\n          for (auto field: dynamic.getSchema().getFields()) {\n            auto fieldName = field.getProto().getName();\n            if (fieldName.startsWith(\"targets\")) {\n              if (dynamic.get(field).as<bool>()) {\n                auto target = kj::str(fieldName.slice(strlen(\"targets\")));\n                target[0] = target[0] - 'A' + 'a';\n                targets.add(kj::mv(target));\n              } else {\n                targetsAll = false;\n              }\n            }\n          }\n  \n          if (targetsAll) {\n            targets = kj::Vector<kj::String>(1);\n            targets.add(kj::heapString(\"*\"));\n          }\n  \n          return kj::strTree(\n              indent, \"annotation \", name, \" @0x\", kj::hex(proto.getId()),\n              \" (\", strArray(targets, \", \"), \") :\",\n              genType(annotationProto.getType(), schema, nullptr), genAnnotations(schema), \";\\n\");\n        }\n      }\n  \n      return kj::strTree();\n    }\n}"
  },
  {
    "function_name": "genSuperclasses",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "510-521",
    "snippet": "kj::StringTree genSuperclasses(InterfaceSchema interface) {\n    auto superclasses = interface.getProto().getInterface().getSuperclasses();\n    if (superclasses.size() == 0) {\n      return kj::strTree();\n    } else {\n      return kj::strTree(\" superclasses(\", kj::StringTree(\n          KJ_MAP(superclass, superclasses) {\n            return nodeName(schemaLoader.get(superclass.getId()), interface,\n                            superclass.getBrand(), nullptr);\n          }, \", \"), \")\");\n    }\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\" superclasses(\"",
            "kj::StringTree(\n          KJ_MAP(superclass, superclasses) {\n            return nodeName(schemaLoader.get(superclass.getId()), interface,\n                            superclass.getBrand(), nullptr);\n          }, \", \")",
            "\")\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "KJ_MAP(superclass, superclasses){\n            return nodeName(schemaLoader.get(superclass.getId()), interface,\n                            superclass.getBrand(), nullptr);\n          }",
            "\", \""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeName",
          "args": [
            "schemaLoader.get(superclass.getId())",
            "interface",
            "superclass.getBrand()",
            "nullptr"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "nodeName",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "117-194",
          "snippet": "kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                          kj::Maybe<InterfaceSchema::Method> method) {\n    kj::Vector<Schema> targetPath;\n    kj::Vector<Schema> scopeParts;\n\n    targetPath.add(target);\n\n    std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n    for (auto scopeBrand: brand.getScopes()) {\n      switch (scopeBrand.which()) {\n        case schema::Brand::Scope::BIND:\n          scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n          break;\n        case schema::Brand::Scope::INHERIT:\n          // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n          //   any bindings that are not inherited. This requires a way to determine which of our\n          //   parent scopes have a non-empty parameter list.\n          break;\n      }\n    }\n\n    {\n      Schema parent = target;\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        targetPath.add(parent);\n      }\n    }\n\n    {\n      Schema parent = scope;\n      scopeParts.add(parent);\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        scopeParts.add(parent);\n      }\n    }\n\n    // Remove common scope (unless it has been reparameterized).\n    // TODO(someday):  This is broken in that we aren't checking for shadowing.\n    while (!scopeParts.empty() && targetPath.size() > 1 &&\n           scopeParts.back() == targetPath.back() &&\n           scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n      scopeParts.removeLast();\n      targetPath.removeLast();\n    }\n\n    auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n    while (!targetPath.empty()) {\n      auto part = targetPath.back();\n      auto proto = part.getProto();\n      kj::StringTree partStr;\n      if (proto.getScopeId() == 0) {\n        partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n      } else {\n        partStr = kj::strTree(getUnqualifiedName(part));\n      }\n\n      auto iter = scopeBindings.find(proto.getId());\n      if (iter != scopeBindings.end()) {\n        auto bindings = KJ_MAP(binding, iter->second) {\n          switch (binding.which()) {\n            case schema::Brand::Binding::UNBOUND:\n              return kj::strTree(\"AnyPointer\");\n            case schema::Brand::Binding::TYPE:\n              return genType(binding.getType(), scope, method);\n          }\n          return kj::strTree(\"<unknown binding>\");\n        };\n        partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n      }\n\n      parts.add(kj::mv(partStr));\n      targetPath.removeLast();\n    }\n\n    return kj::StringTree(parts.finish(), \".\");\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                            kj::Maybe<InterfaceSchema::Method> method) {\n      kj::Vector<Schema> targetPath;\n      kj::Vector<Schema> scopeParts;\n  \n      targetPath.add(target);\n  \n      std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n      for (auto scopeBrand: brand.getScopes()) {\n        switch (scopeBrand.which()) {\n          case schema::Brand::Scope::BIND:\n            scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n            break;\n          case schema::Brand::Scope::INHERIT:\n            // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n            //   any bindings that are not inherited. This requires a way to determine which of our\n            //   parent scopes have a non-empty parameter list.\n            break;\n        }\n      }\n  \n      {\n        Schema parent = target;\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          targetPath.add(parent);\n        }\n      }\n  \n      {\n        Schema parent = scope;\n        scopeParts.add(parent);\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          scopeParts.add(parent);\n        }\n      }\n  \n      // Remove common scope (unless it has been reparameterized).\n      // TODO(someday):  This is broken in that we aren't checking for shadowing.\n      while (!scopeParts.empty() && targetPath.size() > 1 &&\n             scopeParts.back() == targetPath.back() &&\n             scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n        scopeParts.removeLast();\n        targetPath.removeLast();\n      }\n  \n      auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n      while (!targetPath.empty()) {\n        auto part = targetPath.back();\n        auto proto = part.getProto();\n        kj::StringTree partStr;\n        if (proto.getScopeId() == 0) {\n          partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n        } else {\n          partStr = kj::strTree(getUnqualifiedName(part));\n        }\n  \n        auto iter = scopeBindings.find(proto.getId());\n        if (iter != scopeBindings.end()) {\n          auto bindings = KJ_MAP(binding, iter->second) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Brand::Binding::TYPE:\n                return genType(binding.getType(), scope, method);\n            }\n            return kj::strTree(\"<unknown binding>\");\n          };\n          partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n        }\n  \n        parts.add(kj::mv(partStr));\n        targetPath.removeLast();\n      }\n  \n      return kj::StringTree(parts.finish(), \".\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "superclass.getBrand",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "superclass.getId()"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "superclass.getId",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "superclass",
            "superclasses"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "strTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string-tree.h",
          "lines": "206-208",
          "snippet": "StringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}",
          "includes": [
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n\nStringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "superclasses.size",
          "args": [],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "interface.getProto",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genSuperclasses(InterfaceSchema interface) {\n      auto superclasses = interface.getProto().getInterface().getSuperclasses();\n      if (superclasses.size() == 0) {\n        return kj::strTree();\n      } else {\n        return kj::strTree(\" superclasses(\", kj::StringTree(\n            KJ_MAP(superclass, superclasses) {\n              return nodeName(schemaLoader.get(superclass.getId()), interface,\n                              superclass.getBrand(), nullptr);\n            }, \", \"), \")\");\n      }\n    }\n}"
  },
  {
    "function_name": "genParamList",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "490-508",
    "snippet": "kj::StringTree genParamList(InterfaceSchema interface, StructSchema schema,\n                              schema::Brand::Reader brand, InterfaceSchema::Method method) {\n    if (schema.getProto().getScopeId() == 0) {\n      // A named parameter list.\n      return kj::strTree(\"(\", kj::StringTree(\n          KJ_MAP(field, schema.getFields()) {\n            auto proto = field.getProto();\n            auto slot = proto.getSlot();\n\n            return kj::strTree(\n                proto.getName(), \" :\", genType(slot.getType(), interface, nullptr),\n                isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                    kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n                genAnnotations(proto.getAnnotations(), interface));\n          }, \", \"), \")\");\n    } else {\n      return nodeName(schema, interface, brand, method);\n    }\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodeName",
          "args": [
            "schema",
            "interface",
            "brand",
            "method"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "nodeName",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "117-194",
          "snippet": "kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                          kj::Maybe<InterfaceSchema::Method> method) {\n    kj::Vector<Schema> targetPath;\n    kj::Vector<Schema> scopeParts;\n\n    targetPath.add(target);\n\n    std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n    for (auto scopeBrand: brand.getScopes()) {\n      switch (scopeBrand.which()) {\n        case schema::Brand::Scope::BIND:\n          scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n          break;\n        case schema::Brand::Scope::INHERIT:\n          // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n          //   any bindings that are not inherited. This requires a way to determine which of our\n          //   parent scopes have a non-empty parameter list.\n          break;\n      }\n    }\n\n    {\n      Schema parent = target;\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        targetPath.add(parent);\n      }\n    }\n\n    {\n      Schema parent = scope;\n      scopeParts.add(parent);\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        scopeParts.add(parent);\n      }\n    }\n\n    // Remove common scope (unless it has been reparameterized).\n    // TODO(someday):  This is broken in that we aren't checking for shadowing.\n    while (!scopeParts.empty() && targetPath.size() > 1 &&\n           scopeParts.back() == targetPath.back() &&\n           scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n      scopeParts.removeLast();\n      targetPath.removeLast();\n    }\n\n    auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n    while (!targetPath.empty()) {\n      auto part = targetPath.back();\n      auto proto = part.getProto();\n      kj::StringTree partStr;\n      if (proto.getScopeId() == 0) {\n        partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n      } else {\n        partStr = kj::strTree(getUnqualifiedName(part));\n      }\n\n      auto iter = scopeBindings.find(proto.getId());\n      if (iter != scopeBindings.end()) {\n        auto bindings = KJ_MAP(binding, iter->second) {\n          switch (binding.which()) {\n            case schema::Brand::Binding::UNBOUND:\n              return kj::strTree(\"AnyPointer\");\n            case schema::Brand::Binding::TYPE:\n              return genType(binding.getType(), scope, method);\n          }\n          return kj::strTree(\"<unknown binding>\");\n        };\n        partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n      }\n\n      parts.add(kj::mv(partStr));\n      targetPath.removeLast();\n    }\n\n    return kj::StringTree(parts.finish(), \".\");\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                            kj::Maybe<InterfaceSchema::Method> method) {\n      kj::Vector<Schema> targetPath;\n      kj::Vector<Schema> scopeParts;\n  \n      targetPath.add(target);\n  \n      std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n      for (auto scopeBrand: brand.getScopes()) {\n        switch (scopeBrand.which()) {\n          case schema::Brand::Scope::BIND:\n            scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n            break;\n          case schema::Brand::Scope::INHERIT:\n            // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n            //   any bindings that are not inherited. This requires a way to determine which of our\n            //   parent scopes have a non-empty parameter list.\n            break;\n        }\n      }\n  \n      {\n        Schema parent = target;\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          targetPath.add(parent);\n        }\n      }\n  \n      {\n        Schema parent = scope;\n        scopeParts.add(parent);\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          scopeParts.add(parent);\n        }\n      }\n  \n      // Remove common scope (unless it has been reparameterized).\n      // TODO(someday):  This is broken in that we aren't checking for shadowing.\n      while (!scopeParts.empty() && targetPath.size() > 1 &&\n             scopeParts.back() == targetPath.back() &&\n             scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n        scopeParts.removeLast();\n        targetPath.removeLast();\n      }\n  \n      auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n      while (!targetPath.empty()) {\n        auto part = targetPath.back();\n        auto proto = part.getProto();\n        kj::StringTree partStr;\n        if (proto.getScopeId() == 0) {\n          partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n        } else {\n          partStr = kj::strTree(getUnqualifiedName(part));\n        }\n  \n        auto iter = scopeBindings.find(proto.getId());\n        if (iter != scopeBindings.end()) {\n          auto bindings = KJ_MAP(binding, iter->second) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Brand::Binding::TYPE:\n                return genType(binding.getType(), scope, method);\n            }\n            return kj::strTree(\"<unknown binding>\");\n          };\n          partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n        }\n  \n        parts.add(kj::mv(partStr));\n        targetPath.removeLast();\n      }\n  \n      return kj::StringTree(parts.finish(), \".\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"(\"",
            "kj::StringTree(\n          KJ_MAP(field, schema.getFields()) {\n            auto proto = field.getProto();\n            auto slot = proto.getSlot();\n\n            return kj::strTree(\n                proto.getName(), \" :\", genType(slot.getType(), interface, nullptr),\n                isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                    kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n                genAnnotations(proto.getAnnotations(), interface));\n          }, \", \")",
            "\")\""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "KJ_MAP(field, schema.getFields()){\n            auto proto = field.getProto();\n            auto slot = proto.getSlot();\n\n            return kj::strTree(\n                proto.getName(), \" :\", genType(slot.getType(), interface, nullptr),\n                isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                    kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n                genAnnotations(proto.getAnnotations(), interface));\n          }",
            "\", \""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "proto.getName()",
            "\" :\"",
            "genType(slot.getType(), interface, nullptr)",
            "isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                    kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue()))",
            "genAnnotations(proto.getAnnotations(), interface)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genAnnotations",
          "args": [
            "proto.getAnnotations()",
            "interface"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "genAnnotations",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "390-392",
          "snippet": "kj::StringTree genAnnotations(List<schema::Annotation>::Reader list, Schema scope) {\n    return kj::strTree(KJ_MAP(ann, list) { return genAnnotation(ann, scope); });\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genAnnotations(List<schema::Annotation>::Reader list, Schema scope) {\n      return kj::strTree(KJ_MAP(ann, list) { return genAnnotation(ann, scope); });\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getAnnotations",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\" = \"",
            "genValue(field.getType(), slot.getDefaultValue())"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genValue",
          "args": [
            "field.getType()",
            "slot.getDefaultValue()"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "genValue",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "313-356",
          "snippet": "kj::StringTree genValue(Type type, schema::Value::Reader value) {\n    switch (value.which()) {\n      case schema::Value::VOID: return kj::strTree(\"void\");\n      case schema::Value::BOOL:\n        return kj::strTree(value.getBool() ? \"true\" : \"false\");\n      case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n      case schema::Value::INT16: return kj::strTree(value.getInt16());\n      case schema::Value::INT32: return kj::strTree(value.getInt32());\n      case schema::Value::INT64: return kj::strTree(value.getInt64());\n      case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n      case schema::Value::UINT16: return kj::strTree(value.getUint16());\n      case schema::Value::UINT32: return kj::strTree(value.getUint32());\n      case schema::Value::UINT64: return kj::strTree(value.getUint64());\n      case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n      case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n      case schema::Value::TEXT:\n        return kj::strTree(DynamicValue::Reader(value.getText()));\n      case schema::Value::DATA:\n        return kj::strTree(DynamicValue::Reader(value.getData()));\n      case schema::Value::LIST: {\n        auto listValue = value.getList().getAs<DynamicList>(type.asList());\n        return kj::strTree(listValue);\n      }\n      case schema::Value::ENUM: {\n        auto enumNode = type.asEnum().getProto();\n        auto enumerants = enumNode.getEnum().getEnumerants();\n        KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n        return kj::strTree(enumerants[value.getEnum()].getName());\n      }\n      case schema::Value::STRUCT: {\n        KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n        auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n        return kj::strTree(structValue);\n      }\n      case schema::Value::INTERFACE: {\n        return kj::strTree(\"\");\n      }\n      case schema::Value::ANY_POINTER: {\n        return kj::strTree(\"\");\n      }\n    }\n    return kj::strTree(\"\");\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genValue(Type type, schema::Value::Reader value) {\n      switch (value.which()) {\n        case schema::Value::VOID: return kj::strTree(\"void\");\n        case schema::Value::BOOL:\n          return kj::strTree(value.getBool() ? \"true\" : \"false\");\n        case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n        case schema::Value::INT16: return kj::strTree(value.getInt16());\n        case schema::Value::INT32: return kj::strTree(value.getInt32());\n        case schema::Value::INT64: return kj::strTree(value.getInt64());\n        case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n        case schema::Value::UINT16: return kj::strTree(value.getUint16());\n        case schema::Value::UINT32: return kj::strTree(value.getUint32());\n        case schema::Value::UINT64: return kj::strTree(value.getUint64());\n        case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n        case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n        case schema::Value::TEXT:\n          return kj::strTree(DynamicValue::Reader(value.getText()));\n        case schema::Value::DATA:\n          return kj::strTree(DynamicValue::Reader(value.getData()));\n        case schema::Value::LIST: {\n          auto listValue = value.getList().getAs<DynamicList>(type.asList());\n          return kj::strTree(listValue);\n        }\n        case schema::Value::ENUM: {\n          auto enumNode = type.asEnum().getProto();\n          auto enumerants = enumNode.getEnum().getEnumerants();\n          KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                  \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n          return kj::strTree(enumerants[value.getEnum()].getName());\n        }\n        case schema::Value::STRUCT: {\n          KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n          auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n          return kj::strTree(structValue);\n        }\n        case schema::Value::INTERFACE: {\n          return kj::strTree(\"\");\n        }\n        case schema::Value::ANY_POINTER: {\n          return kj::strTree(\"\");\n        }\n      }\n      return kj::strTree(\"\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot.getDefaultValue",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getType",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isEmptyValue",
          "args": [
            "slot.getDefaultValue()"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "isEmptyValue",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "288-311",
          "snippet": "bool isEmptyValue(schema::Value::Reader value) {\n    switch (value.which()) {\n      case schema::Value::VOID: return true;\n      case schema::Value::BOOL: return value.getBool() == false;\n      case schema::Value::INT8: return value.getInt8() == 0;\n      case schema::Value::INT16: return value.getInt16() == 0;\n      case schema::Value::INT32: return value.getInt32() == 0;\n      case schema::Value::INT64: return value.getInt64() == 0;\n      case schema::Value::UINT8: return value.getUint8() == 0;\n      case schema::Value::UINT16: return value.getUint16() == 0;\n      case schema::Value::UINT32: return value.getUint32() == 0;\n      case schema::Value::UINT64: return value.getUint64() == 0;\n      case schema::Value::FLOAT32: return value.getFloat32() == 0;\n      case schema::Value::FLOAT64: return value.getFloat64() == 0;\n      case schema::Value::TEXT: return !value.hasText();\n      case schema::Value::DATA: return !value.hasData();\n      case schema::Value::LIST: return !value.hasList();\n      case schema::Value::ENUM: return value.getEnum() == 0;\n      case schema::Value::STRUCT: return !value.hasStruct();\n      case schema::Value::INTERFACE: return true;\n      case schema::Value::ANY_POINTER: return true;\n    }\n    return true;\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  bool isEmptyValue(schema::Value::Reader value) {\n      switch (value.which()) {\n        case schema::Value::VOID: return true;\n        case schema::Value::BOOL: return value.getBool() == false;\n        case schema::Value::INT8: return value.getInt8() == 0;\n        case schema::Value::INT16: return value.getInt16() == 0;\n        case schema::Value::INT32: return value.getInt32() == 0;\n        case schema::Value::INT64: return value.getInt64() == 0;\n        case schema::Value::UINT8: return value.getUint8() == 0;\n        case schema::Value::UINT16: return value.getUint16() == 0;\n        case schema::Value::UINT32: return value.getUint32() == 0;\n        case schema::Value::UINT64: return value.getUint64() == 0;\n        case schema::Value::FLOAT32: return value.getFloat32() == 0;\n        case schema::Value::FLOAT64: return value.getFloat64() == 0;\n        case schema::Value::TEXT: return !value.hasText();\n        case schema::Value::DATA: return !value.hasData();\n        case schema::Value::LIST: return !value.hasList();\n        case schema::Value::ENUM: return value.getEnum() == 0;\n        case schema::Value::STRUCT: return !value.hasStruct();\n        case schema::Value::INTERFACE: return true;\n        case schema::Value::ANY_POINTER: return true;\n      }\n      return true;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot.getDefaultValue",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genType",
          "args": [
            "slot.getType()",
            "interface",
            "nullptr"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "genType",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "196-261",
          "snippet": "kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                         kj::Maybe<InterfaceSchema::Method> method) {\n    switch (type.which()) {\n      case schema::Type::VOID: return kj::strTree(\"Void\");\n      case schema::Type::BOOL: return kj::strTree(\"Bool\");\n      case schema::Type::INT8: return kj::strTree(\"Int8\");\n      case schema::Type::INT16: return kj::strTree(\"Int16\");\n      case schema::Type::INT32: return kj::strTree(\"Int32\");\n      case schema::Type::INT64: return kj::strTree(\"Int64\");\n      case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n      case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n      case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n      case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n      case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n      case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n      case schema::Type::TEXT: return kj::strTree(\"Text\");\n      case schema::Type::DATA: return kj::strTree(\"Data\");\n      case schema::Type::LIST:\n        return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n      case schema::Type::ENUM:\n        return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                        type.getEnum().getBrand(), method);\n      case schema::Type::STRUCT:\n        return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                        type.getStruct().getBrand(), method);\n      case schema::Type::INTERFACE:\n        return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                        type.getInterface().getBrand(), method);\n      case schema::Type::ANY_POINTER: {\n        auto anyPointer = type.getAnyPointer();\n        switch (anyPointer.which()) {\n          case schema::Type::AnyPointer::UNCONSTRAINED:\n            switch (anyPointer.getUnconstrained().which()) {\n              case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                return kj::strTree(\"AnyStruct\");\n              case schema::Type::AnyPointer::Unconstrained::LIST:\n                return kj::strTree(\"AnyList\");\n              case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                return kj::strTree(\"Capability\");\n            }\n            KJ_UNREACHABLE;\n          case schema::Type::AnyPointer::PARAMETER: {\n            auto param = anyPointer.getParameter();\n            auto scopeProto = scope.getProto();\n            auto targetScopeId = param.getScopeId();\n            while (scopeProto.getId() != targetScopeId) {\n              scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n            }\n            auto params = scopeProto.getParameters();\n            KJ_REQUIRE(param.getParameterIndex() < params.size());\n            return kj::strTree(params[param.getParameterIndex()].getName());\n          }\n          case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n            auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n            uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n            KJ_REQUIRE(index < params.size());\n            return kj::strTree(params[index].getName());\n          }\n        }\n        KJ_UNREACHABLE;\n      }\n    }\n    return kj::strTree();\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                           kj::Maybe<InterfaceSchema::Method> method) {\n      switch (type.which()) {\n        case schema::Type::VOID: return kj::strTree(\"Void\");\n        case schema::Type::BOOL: return kj::strTree(\"Bool\");\n        case schema::Type::INT8: return kj::strTree(\"Int8\");\n        case schema::Type::INT16: return kj::strTree(\"Int16\");\n        case schema::Type::INT32: return kj::strTree(\"Int32\");\n        case schema::Type::INT64: return kj::strTree(\"Int64\");\n        case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n        case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n        case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n        case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n        case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n        case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n        case schema::Type::TEXT: return kj::strTree(\"Text\");\n        case schema::Type::DATA: return kj::strTree(\"Data\");\n        case schema::Type::LIST:\n          return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n        case schema::Type::ENUM:\n          return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                          type.getEnum().getBrand(), method);\n        case schema::Type::STRUCT:\n          return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                          type.getStruct().getBrand(), method);\n        case schema::Type::INTERFACE:\n          return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                          type.getInterface().getBrand(), method);\n        case schema::Type::ANY_POINTER: {\n          auto anyPointer = type.getAnyPointer();\n          switch (anyPointer.which()) {\n            case schema::Type::AnyPointer::UNCONSTRAINED:\n              switch (anyPointer.getUnconstrained().which()) {\n                case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                  return kj::strTree(\"AnyPointer\");\n                case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                  return kj::strTree(\"AnyStruct\");\n                case schema::Type::AnyPointer::Unconstrained::LIST:\n                  return kj::strTree(\"AnyList\");\n                case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                  return kj::strTree(\"Capability\");\n              }\n              KJ_UNREACHABLE;\n            case schema::Type::AnyPointer::PARAMETER: {\n              auto param = anyPointer.getParameter();\n              auto scopeProto = scope.getProto();\n              auto targetScopeId = param.getScopeId();\n              while (scopeProto.getId() != targetScopeId) {\n                scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n              }\n              auto params = scopeProto.getParameters();\n              KJ_REQUIRE(param.getParameterIndex() < params.size());\n              return kj::strTree(params[param.getParameterIndex()].getName());\n            }\n            case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n              auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n              uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n              KJ_REQUIRE(index < params.size());\n              return kj::strTree(params[index].getName());\n            }\n          }\n          KJ_UNREACHABLE;\n        }\n      }\n      return kj::strTree();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getName",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getSlot",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "field",
            "schema.getFields()"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getFields",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genParamList(InterfaceSchema interface, StructSchema schema,\n                                schema::Brand::Reader brand, InterfaceSchema::Method method) {\n      if (schema.getProto().getScopeId() == 0) {\n        // A named parameter list.\n        return kj::strTree(\"(\", kj::StringTree(\n            KJ_MAP(field, schema.getFields()) {\n              auto proto = field.getProto();\n              auto slot = proto.getSlot();\n  \n              return kj::strTree(\n                  proto.getName(), \" :\", genType(slot.getType(), interface, nullptr),\n                  isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                      kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n                  genAnnotations(proto.getAnnotations(), interface));\n            }, \", \"), \")\");\n      } else {\n        return nodeName(schema, interface, brand, method);\n      }\n    }\n}"
  },
  {
    "function_name": "genStructField",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "456-488",
    "snippet": "kj::StringTree genStructField(StructSchema::Field field, Schema scope, Indent indent) {\n    auto proto = field.getProto();\n    switch (proto.which()) {\n      case schema::Field::SLOT: {\n        auto slot = proto.getSlot();\n        int size = typeSizeBits(slot.getType());\n        return kj::strTree(\n            indent, proto.getName(), \" @\", proto.getOrdinal().getExplicit(),\n            \" :\", genType(slot.getType(), scope, nullptr),\n            isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n            genAnnotations(proto.getAnnotations(), scope),\n            \";  # \", size == -1 ? kj::strTree(\"ptr[\", slot.getOffset(), \"]\")\n                                : kj::strTree(\"bits[\", slot.getOffset() * size, \", \",\n                                              (slot.getOffset() + 1) * size, \")\"),\n            hasDiscriminantValue(proto)\n                ? kj::strTree(\", union tag = \", proto.getDiscriminantValue()) : kj::strTree(),\n            \"\\n\");\n      }\n      case schema::Field::GROUP: {\n        auto group = field.getType().asStruct();\n        return kj::strTree(\n            indent, proto.getName(),\n            \" :group\", genAnnotations(proto.getAnnotations(), scope), \" {\",\n            hasDiscriminantValue(proto)\n                ? kj::strTree(\"  # union tag = \", proto.getDiscriminantValue()) : kj::strTree(),\n            \"\\n\",\n            genStructFields(group, indent.next()),\n            indent, \"}\\n\");\n      }\n    }\n    return kj::strTree();\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "strTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string-tree.h",
          "lines": "206-208",
          "snippet": "StringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}",
          "includes": [
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n\nStringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent",
            "proto.getName()",
            "\" :group\"",
            "genAnnotations(proto.getAnnotations(), scope)",
            "\" {\"",
            "hasDiscriminantValue(proto)\n                ? kj::strTree(\"  # union tag = \", proto.getDiscriminantValue()) : kj::strTree()",
            "\"\\n\"",
            "genStructFields(group, indent.next())",
            "indent",
            "\"}\\n\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genStructFields",
          "args": [
            "group",
            "indent.next()"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "genStructFields",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "426-454",
          "snippet": "kj::Array<kj::StringTree> genStructFields(StructSchema schema, Indent indent) {\n    // Slightly hacky:  We want to print in code order, but we also need to print the union in one\n    //   chunk.  Its fields should be together in code order anyway, but it's easier to simply\n    //   output the whole union in place of the first union field, and then output nothing for the\n    //   subsequent fields.\n\n    bool seenUnion = false;\n    return KJ_MAP(field, sortByCodeOrder(schema.getFields())) {\n      if (hasDiscriminantValue(field.getProto())) {\n        if (seenUnion) {\n          return kj::strTree();\n        } else {\n          seenUnion = true;\n          uint offset = schema.getProto().getStruct().getDiscriminantOffset();\n\n          // GCC 4.7.3 crashes if you inline unionFields.\n          auto unionFields = sortByCodeOrder(schema.getUnionFields());\n          return kj::strTree(\n              indent, \"union {  # tag bits [\", offset * 16, \", \", offset * 16 + 16, \")\\n\",\n              KJ_MAP(uField, unionFields) {\n                return genStructField(uField, schema, indent.next());\n              },\n              indent, \"}\\n\");\n        }\n      } else {\n        return genStructField(field, schema, indent);\n      }\n    };\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::Array<kj::StringTree> genStructFields(StructSchema schema, Indent indent) {\n      // Slightly hacky:  We want to print in code order, but we also need to print the union in one\n      //   chunk.  Its fields should be together in code order anyway, but it's easier to simply\n      //   output the whole union in place of the first union field, and then output nothing for the\n      //   subsequent fields.\n  \n      bool seenUnion = false;\n      return KJ_MAP(field, sortByCodeOrder(schema.getFields())) {\n        if (hasDiscriminantValue(field.getProto())) {\n          if (seenUnion) {\n            return kj::strTree();\n          } else {\n            seenUnion = true;\n            uint offset = schema.getProto().getStruct().getDiscriminantOffset();\n  \n            // GCC 4.7.3 crashes if you inline unionFields.\n            auto unionFields = sortByCodeOrder(schema.getUnionFields());\n            return kj::strTree(\n                indent, \"union {  # tag bits [\", offset * 16, \", \", offset * 16 + 16, \")\\n\",\n                KJ_MAP(uField, unionFields) {\n                  return genStructField(uField, schema, indent.next());\n                },\n                indent, \"}\\n\");\n          }\n        } else {\n          return genStructField(field, schema, indent);\n        }\n      };\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "indent.next",
          "args": [],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "59-61",
          "snippet": "Indent next() {\n    return Indent(amount + 2);\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Indent next() {\n      return Indent(amount + 2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"  # union tag = \"",
            "proto.getDiscriminantValue()"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getDiscriminantValue",
          "args": [],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hasDiscriminantValue",
          "args": [
            "proto"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "hasDiscriminantValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "50-52",
          "snippet": "bool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nbool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "genAnnotations",
          "args": [
            "proto.getAnnotations()",
            "scope"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "genAnnotations",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "390-392",
          "snippet": "kj::StringTree genAnnotations(List<schema::Annotation>::Reader list, Schema scope) {\n    return kj::strTree(KJ_MAP(ann, list) { return genAnnotation(ann, scope); });\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genAnnotations(List<schema::Annotation>::Reader list, Schema scope) {\n      return kj::strTree(KJ_MAP(ann, list) { return genAnnotation(ann, scope); });\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getAnnotations",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getName",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getType",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent",
            "proto.getName()",
            "\" @\"",
            "proto.getOrdinal().getExplicit()",
            "\" :\"",
            "genType(slot.getType(), scope, nullptr)",
            "isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue()))",
            "genAnnotations(proto.getAnnotations(), scope)",
            "\";  # \"",
            "size == -1 ? kj::strTree(\"ptr[\", slot.getOffset(), \"]\")\n                                : kj::strTree(\"bits[\", slot.getOffset() * size, \", \",\n                                              (slot.getOffset() + 1) * size, \")\")",
            "hasDiscriminantValue(proto)\n                ? kj::strTree(\", union tag = \", proto.getDiscriminantValue()) : kj::strTree()",
            "\"\\n\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\", union tag = \"",
            "proto.getDiscriminantValue()"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getDiscriminantValue",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"bits[\"",
            "slot.getOffset() * size",
            "\", \"",
            "(slot.getOffset() + 1) * size",
            "\")\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getOffset",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getOffset",
          "args": [],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"ptr[\"",
            "slot.getOffset()",
            "\"]\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot.getOffset",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getAnnotations",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\" = \"",
            "genValue(field.getType(), slot.getDefaultValue())"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genValue",
          "args": [
            "field.getType()",
            "slot.getDefaultValue()"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "genValue",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "313-356",
          "snippet": "kj::StringTree genValue(Type type, schema::Value::Reader value) {\n    switch (value.which()) {\n      case schema::Value::VOID: return kj::strTree(\"void\");\n      case schema::Value::BOOL:\n        return kj::strTree(value.getBool() ? \"true\" : \"false\");\n      case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n      case schema::Value::INT16: return kj::strTree(value.getInt16());\n      case schema::Value::INT32: return kj::strTree(value.getInt32());\n      case schema::Value::INT64: return kj::strTree(value.getInt64());\n      case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n      case schema::Value::UINT16: return kj::strTree(value.getUint16());\n      case schema::Value::UINT32: return kj::strTree(value.getUint32());\n      case schema::Value::UINT64: return kj::strTree(value.getUint64());\n      case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n      case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n      case schema::Value::TEXT:\n        return kj::strTree(DynamicValue::Reader(value.getText()));\n      case schema::Value::DATA:\n        return kj::strTree(DynamicValue::Reader(value.getData()));\n      case schema::Value::LIST: {\n        auto listValue = value.getList().getAs<DynamicList>(type.asList());\n        return kj::strTree(listValue);\n      }\n      case schema::Value::ENUM: {\n        auto enumNode = type.asEnum().getProto();\n        auto enumerants = enumNode.getEnum().getEnumerants();\n        KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n        return kj::strTree(enumerants[value.getEnum()].getName());\n      }\n      case schema::Value::STRUCT: {\n        KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n        auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n        return kj::strTree(structValue);\n      }\n      case schema::Value::INTERFACE: {\n        return kj::strTree(\"\");\n      }\n      case schema::Value::ANY_POINTER: {\n        return kj::strTree(\"\");\n      }\n    }\n    return kj::strTree(\"\");\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genValue(Type type, schema::Value::Reader value) {\n      switch (value.which()) {\n        case schema::Value::VOID: return kj::strTree(\"void\");\n        case schema::Value::BOOL:\n          return kj::strTree(value.getBool() ? \"true\" : \"false\");\n        case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n        case schema::Value::INT16: return kj::strTree(value.getInt16());\n        case schema::Value::INT32: return kj::strTree(value.getInt32());\n        case schema::Value::INT64: return kj::strTree(value.getInt64());\n        case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n        case schema::Value::UINT16: return kj::strTree(value.getUint16());\n        case schema::Value::UINT32: return kj::strTree(value.getUint32());\n        case schema::Value::UINT64: return kj::strTree(value.getUint64());\n        case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n        case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n        case schema::Value::TEXT:\n          return kj::strTree(DynamicValue::Reader(value.getText()));\n        case schema::Value::DATA:\n          return kj::strTree(DynamicValue::Reader(value.getData()));\n        case schema::Value::LIST: {\n          auto listValue = value.getList().getAs<DynamicList>(type.asList());\n          return kj::strTree(listValue);\n        }\n        case schema::Value::ENUM: {\n          auto enumNode = type.asEnum().getProto();\n          auto enumerants = enumNode.getEnum().getEnumerants();\n          KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                  \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n          return kj::strTree(enumerants[value.getEnum()].getName());\n        }\n        case schema::Value::STRUCT: {\n          KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n          auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n          return kj::strTree(structValue);\n        }\n        case schema::Value::INTERFACE: {\n          return kj::strTree(\"\");\n        }\n        case schema::Value::ANY_POINTER: {\n          return kj::strTree(\"\");\n        }\n      }\n      return kj::strTree(\"\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot.getDefaultValue",
          "args": [],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isEmptyValue",
          "args": [
            "slot.getDefaultValue()"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "isEmptyValue",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "288-311",
          "snippet": "bool isEmptyValue(schema::Value::Reader value) {\n    switch (value.which()) {\n      case schema::Value::VOID: return true;\n      case schema::Value::BOOL: return value.getBool() == false;\n      case schema::Value::INT8: return value.getInt8() == 0;\n      case schema::Value::INT16: return value.getInt16() == 0;\n      case schema::Value::INT32: return value.getInt32() == 0;\n      case schema::Value::INT64: return value.getInt64() == 0;\n      case schema::Value::UINT8: return value.getUint8() == 0;\n      case schema::Value::UINT16: return value.getUint16() == 0;\n      case schema::Value::UINT32: return value.getUint32() == 0;\n      case schema::Value::UINT64: return value.getUint64() == 0;\n      case schema::Value::FLOAT32: return value.getFloat32() == 0;\n      case schema::Value::FLOAT64: return value.getFloat64() == 0;\n      case schema::Value::TEXT: return !value.hasText();\n      case schema::Value::DATA: return !value.hasData();\n      case schema::Value::LIST: return !value.hasList();\n      case schema::Value::ENUM: return value.getEnum() == 0;\n      case schema::Value::STRUCT: return !value.hasStruct();\n      case schema::Value::INTERFACE: return true;\n      case schema::Value::ANY_POINTER: return true;\n    }\n    return true;\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  bool isEmptyValue(schema::Value::Reader value) {\n      switch (value.which()) {\n        case schema::Value::VOID: return true;\n        case schema::Value::BOOL: return value.getBool() == false;\n        case schema::Value::INT8: return value.getInt8() == 0;\n        case schema::Value::INT16: return value.getInt16() == 0;\n        case schema::Value::INT32: return value.getInt32() == 0;\n        case schema::Value::INT64: return value.getInt64() == 0;\n        case schema::Value::UINT8: return value.getUint8() == 0;\n        case schema::Value::UINT16: return value.getUint16() == 0;\n        case schema::Value::UINT32: return value.getUint32() == 0;\n        case schema::Value::UINT64: return value.getUint64() == 0;\n        case schema::Value::FLOAT32: return value.getFloat32() == 0;\n        case schema::Value::FLOAT64: return value.getFloat64() == 0;\n        case schema::Value::TEXT: return !value.hasText();\n        case schema::Value::DATA: return !value.hasData();\n        case schema::Value::LIST: return !value.hasList();\n        case schema::Value::ENUM: return value.getEnum() == 0;\n        case schema::Value::STRUCT: return !value.hasStruct();\n        case schema::Value::INTERFACE: return true;\n        case schema::Value::ANY_POINTER: return true;\n      }\n      return true;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "slot.getDefaultValue",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genType",
          "args": [
            "slot.getType()",
            "scope",
            "nullptr"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "genType",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "196-261",
          "snippet": "kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                         kj::Maybe<InterfaceSchema::Method> method) {\n    switch (type.which()) {\n      case schema::Type::VOID: return kj::strTree(\"Void\");\n      case schema::Type::BOOL: return kj::strTree(\"Bool\");\n      case schema::Type::INT8: return kj::strTree(\"Int8\");\n      case schema::Type::INT16: return kj::strTree(\"Int16\");\n      case schema::Type::INT32: return kj::strTree(\"Int32\");\n      case schema::Type::INT64: return kj::strTree(\"Int64\");\n      case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n      case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n      case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n      case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n      case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n      case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n      case schema::Type::TEXT: return kj::strTree(\"Text\");\n      case schema::Type::DATA: return kj::strTree(\"Data\");\n      case schema::Type::LIST:\n        return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n      case schema::Type::ENUM:\n        return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                        type.getEnum().getBrand(), method);\n      case schema::Type::STRUCT:\n        return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                        type.getStruct().getBrand(), method);\n      case schema::Type::INTERFACE:\n        return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                        type.getInterface().getBrand(), method);\n      case schema::Type::ANY_POINTER: {\n        auto anyPointer = type.getAnyPointer();\n        switch (anyPointer.which()) {\n          case schema::Type::AnyPointer::UNCONSTRAINED:\n            switch (anyPointer.getUnconstrained().which()) {\n              case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                return kj::strTree(\"AnyStruct\");\n              case schema::Type::AnyPointer::Unconstrained::LIST:\n                return kj::strTree(\"AnyList\");\n              case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                return kj::strTree(\"Capability\");\n            }\n            KJ_UNREACHABLE;\n          case schema::Type::AnyPointer::PARAMETER: {\n            auto param = anyPointer.getParameter();\n            auto scopeProto = scope.getProto();\n            auto targetScopeId = param.getScopeId();\n            while (scopeProto.getId() != targetScopeId) {\n              scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n            }\n            auto params = scopeProto.getParameters();\n            KJ_REQUIRE(param.getParameterIndex() < params.size());\n            return kj::strTree(params[param.getParameterIndex()].getName());\n          }\n          case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n            auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n            uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n            KJ_REQUIRE(index < params.size());\n            return kj::strTree(params[index].getName());\n          }\n        }\n        KJ_UNREACHABLE;\n      }\n    }\n    return kj::strTree();\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                           kj::Maybe<InterfaceSchema::Method> method) {\n      switch (type.which()) {\n        case schema::Type::VOID: return kj::strTree(\"Void\");\n        case schema::Type::BOOL: return kj::strTree(\"Bool\");\n        case schema::Type::INT8: return kj::strTree(\"Int8\");\n        case schema::Type::INT16: return kj::strTree(\"Int16\");\n        case schema::Type::INT32: return kj::strTree(\"Int32\");\n        case schema::Type::INT64: return kj::strTree(\"Int64\");\n        case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n        case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n        case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n        case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n        case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n        case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n        case schema::Type::TEXT: return kj::strTree(\"Text\");\n        case schema::Type::DATA: return kj::strTree(\"Data\");\n        case schema::Type::LIST:\n          return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n        case schema::Type::ENUM:\n          return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                          type.getEnum().getBrand(), method);\n        case schema::Type::STRUCT:\n          return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                          type.getStruct().getBrand(), method);\n        case schema::Type::INTERFACE:\n          return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                          type.getInterface().getBrand(), method);\n        case schema::Type::ANY_POINTER: {\n          auto anyPointer = type.getAnyPointer();\n          switch (anyPointer.which()) {\n            case schema::Type::AnyPointer::UNCONSTRAINED:\n              switch (anyPointer.getUnconstrained().which()) {\n                case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                  return kj::strTree(\"AnyPointer\");\n                case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                  return kj::strTree(\"AnyStruct\");\n                case schema::Type::AnyPointer::Unconstrained::LIST:\n                  return kj::strTree(\"AnyList\");\n                case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                  return kj::strTree(\"Capability\");\n              }\n              KJ_UNREACHABLE;\n            case schema::Type::AnyPointer::PARAMETER: {\n              auto param = anyPointer.getParameter();\n              auto scopeProto = scope.getProto();\n              auto targetScopeId = param.getScopeId();\n              while (scopeProto.getId() != targetScopeId) {\n                scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n              }\n              auto params = scopeProto.getParameters();\n              KJ_REQUIRE(param.getParameterIndex() < params.size());\n              return kj::strTree(params[param.getParameterIndex()].getName());\n            }\n            case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n              auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n              uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n              KJ_REQUIRE(index < params.size());\n              return kj::strTree(params[index].getName());\n            }\n          }\n          KJ_UNREACHABLE;\n        }\n      }\n      return kj::strTree();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getOrdinal",
          "args": [],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "getOrdinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "486-486",
          "snippet": "inline uint16_t getOrdinal() const { return ordinal; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline uint16_t getOrdinal() const { return ordinal; }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getName",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeSizeBits",
          "args": [
            "slot.getType()"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "typeSizeBits",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "263-286",
          "snippet": "int typeSizeBits(schema::Type::Reader type) {\n    switch (type.which()) {\n      case schema::Type::VOID: return 0;\n      case schema::Type::BOOL: return 1;\n      case schema::Type::INT8: return 8;\n      case schema::Type::INT16: return 16;\n      case schema::Type::INT32: return 32;\n      case schema::Type::INT64: return 64;\n      case schema::Type::UINT8: return 8;\n      case schema::Type::UINT16: return 16;\n      case schema::Type::UINT32: return 32;\n      case schema::Type::UINT64: return 64;\n      case schema::Type::FLOAT32: return 32;\n      case schema::Type::FLOAT64: return 64;\n      case schema::Type::TEXT: return -1;\n      case schema::Type::DATA: return -1;\n      case schema::Type::LIST: return -1;\n      case schema::Type::ENUM: return 16;\n      case schema::Type::STRUCT: return -1;\n      case schema::Type::INTERFACE: return -1;\n      case schema::Type::ANY_POINTER: return -1;\n    }\n    return 0;\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  int typeSizeBits(schema::Type::Reader type) {\n      switch (type.which()) {\n        case schema::Type::VOID: return 0;\n        case schema::Type::BOOL: return 1;\n        case schema::Type::INT8: return 8;\n        case schema::Type::INT16: return 16;\n        case schema::Type::INT32: return 32;\n        case schema::Type::INT64: return 64;\n        case schema::Type::UINT8: return 8;\n        case schema::Type::UINT16: return 16;\n        case schema::Type::UINT32: return 32;\n        case schema::Type::UINT64: return 64;\n        case schema::Type::FLOAT32: return 32;\n        case schema::Type::FLOAT64: return 64;\n        case schema::Type::TEXT: return -1;\n        case schema::Type::DATA: return -1;\n        case schema::Type::LIST: return -1;\n        case schema::Type::ENUM: return 16;\n        case schema::Type::STRUCT: return -1;\n        case schema::Type::INTERFACE: return -1;\n        case schema::Type::ANY_POINTER: return -1;\n      }\n      return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getSlot",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.which",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "field.getProto",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genStructField(StructSchema::Field field, Schema scope, Indent indent) {\n      auto proto = field.getProto();\n      switch (proto.which()) {\n        case schema::Field::SLOT: {\n          auto slot = proto.getSlot();\n          int size = typeSizeBits(slot.getType());\n          return kj::strTree(\n              indent, proto.getName(), \" @\", proto.getOrdinal().getExplicit(),\n              \" :\", genType(slot.getType(), scope, nullptr),\n              isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                  kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n              genAnnotations(proto.getAnnotations(), scope),\n              \";  # \", size == -1 ? kj::strTree(\"ptr[\", slot.getOffset(), \"]\")\n                                  : kj::strTree(\"bits[\", slot.getOffset() * size, \", \",\n                                                (slot.getOffset() + 1) * size, \")\"),\n              hasDiscriminantValue(proto)\n                  ? kj::strTree(\", union tag = \", proto.getDiscriminantValue()) : kj::strTree(),\n              \"\\n\");\n        }\n        case schema::Field::GROUP: {\n          auto group = field.getType().asStruct();\n          return kj::strTree(\n              indent, proto.getName(),\n              \" :group\", genAnnotations(proto.getAnnotations(), scope), \" {\",\n              hasDiscriminantValue(proto)\n                  ? kj::strTree(\"  # union tag = \", proto.getDiscriminantValue()) : kj::strTree(),\n              \"\\n\",\n              genStructFields(group, indent.next()),\n              indent, \"}\\n\");\n        }\n      }\n      return kj::strTree();\n    }\n}"
  },
  {
    "function_name": "genStructFields",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "426-454",
    "snippet": "kj::Array<kj::StringTree> genStructFields(StructSchema schema, Indent indent) {\n    // Slightly hacky:  We want to print in code order, but we also need to print the union in one\n    //   chunk.  Its fields should be together in code order anyway, but it's easier to simply\n    //   output the whole union in place of the first union field, and then output nothing for the\n    //   subsequent fields.\n\n    bool seenUnion = false;\n    return KJ_MAP(field, sortByCodeOrder(schema.getFields())) {\n      if (hasDiscriminantValue(field.getProto())) {\n        if (seenUnion) {\n          return kj::strTree();\n        } else {\n          seenUnion = true;\n          uint offset = schema.getProto().getStruct().getDiscriminantOffset();\n\n          // GCC 4.7.3 crashes if you inline unionFields.\n          auto unionFields = sortByCodeOrder(schema.getUnionFields());\n          return kj::strTree(\n              indent, \"union {  # tag bits [\", offset * 16, \", \", offset * 16 + 16, \")\\n\",\n              KJ_MAP(uField, unionFields) {\n                return genStructField(uField, schema, indent.next());\n              },\n              indent, \"}\\n\");\n        }\n      } else {\n        return genStructField(field, schema, indent);\n      }\n    };\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "genStructField",
          "args": [
            "field",
            "schema",
            "indent"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "genStructField",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "456-488",
          "snippet": "kj::StringTree genStructField(StructSchema::Field field, Schema scope, Indent indent) {\n    auto proto = field.getProto();\n    switch (proto.which()) {\n      case schema::Field::SLOT: {\n        auto slot = proto.getSlot();\n        int size = typeSizeBits(slot.getType());\n        return kj::strTree(\n            indent, proto.getName(), \" @\", proto.getOrdinal().getExplicit(),\n            \" :\", genType(slot.getType(), scope, nullptr),\n            isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n            genAnnotations(proto.getAnnotations(), scope),\n            \";  # \", size == -1 ? kj::strTree(\"ptr[\", slot.getOffset(), \"]\")\n                                : kj::strTree(\"bits[\", slot.getOffset() * size, \", \",\n                                              (slot.getOffset() + 1) * size, \")\"),\n            hasDiscriminantValue(proto)\n                ? kj::strTree(\", union tag = \", proto.getDiscriminantValue()) : kj::strTree(),\n            \"\\n\");\n      }\n      case schema::Field::GROUP: {\n        auto group = field.getType().asStruct();\n        return kj::strTree(\n            indent, proto.getName(),\n            \" :group\", genAnnotations(proto.getAnnotations(), scope), \" {\",\n            hasDiscriminantValue(proto)\n                ? kj::strTree(\"  # union tag = \", proto.getDiscriminantValue()) : kj::strTree(),\n            \"\\n\",\n            genStructFields(group, indent.next()),\n            indent, \"}\\n\");\n      }\n    }\n    return kj::strTree();\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genStructField(StructSchema::Field field, Schema scope, Indent indent) {\n      auto proto = field.getProto();\n      switch (proto.which()) {\n        case schema::Field::SLOT: {\n          auto slot = proto.getSlot();\n          int size = typeSizeBits(slot.getType());\n          return kj::strTree(\n              indent, proto.getName(), \" @\", proto.getOrdinal().getExplicit(),\n              \" :\", genType(slot.getType(), scope, nullptr),\n              isEmptyValue(slot.getDefaultValue()) ? kj::strTree(\"\") :\n                  kj::strTree(\" = \", genValue(field.getType(), slot.getDefaultValue())),\n              genAnnotations(proto.getAnnotations(), scope),\n              \";  # \", size == -1 ? kj::strTree(\"ptr[\", slot.getOffset(), \"]\")\n                                  : kj::strTree(\"bits[\", slot.getOffset() * size, \", \",\n                                                (slot.getOffset() + 1) * size, \")\"),\n              hasDiscriminantValue(proto)\n                  ? kj::strTree(\", union tag = \", proto.getDiscriminantValue()) : kj::strTree(),\n              \"\\n\");\n        }\n        case schema::Field::GROUP: {\n          auto group = field.getType().asStruct();\n          return kj::strTree(\n              indent, proto.getName(),\n              \" :group\", genAnnotations(proto.getAnnotations(), scope), \" {\",\n              hasDiscriminantValue(proto)\n                  ? kj::strTree(\"  # union tag = \", proto.getDiscriminantValue()) : kj::strTree(),\n              \"\\n\",\n              genStructFields(group, indent.next()),\n              indent, \"}\\n\");\n        }\n      }\n      return kj::strTree();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "indent",
            "\"union {  # tag bits [\"",
            "offset * 16",
            "\", \"",
            "offset * 16 + 16",
            "\")\\n\"",
            "KJ_MAP(uField, unionFields){\n                return genStructField(uField, schema, indent.next());\n              }",
            "indent",
            "\"}\\n\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indent.next",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "next",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "59-61",
          "snippet": "Indent next() {\n    return Indent(amount + 2);\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Indent next() {\n      return Indent(amount + 2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "uField",
            "unionFields"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sortByCodeOrder",
          "args": [
            "schema.getUnionFields()"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "sortByCodeOrder",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "420-424",
          "snippet": "kj::Array<decltype(kj::instance<MemberList>()[0])> sortByCodeOrder(MemberList&& list) {\n    auto sorted = KJ_MAP(item, list) { return item; };\n    std::sort(sorted.begin(), sorted.end(), OrderByCodeOrder());\n    return kj::mv(sorted);\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::Array<decltype(kj::instance<MemberList>()[0])> sortByCodeOrder(MemberList&& list) {\n      auto sorted = KJ_MAP(item, list) { return item; };\n      std::sort(sorted.begin(), sorted.end(), OrderByCodeOrder());\n      return kj::mv(sorted);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "schema.getUnionFields",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "strTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string-tree.h",
          "lines": "206-208",
          "snippet": "StringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}",
          "includes": [
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n\nStringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hasDiscriminantValue",
          "args": [
            "field.getProto()"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "hasDiscriminantValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "50-52",
          "snippet": "bool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nbool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "field",
            "sortByCodeOrder(schema.getFields())"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getFields",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::Array<kj::StringTree> genStructFields(StructSchema schema, Indent indent) {\n      // Slightly hacky:  We want to print in code order, but we also need to print the union in one\n      //   chunk.  Its fields should be together in code order anyway, but it's easier to simply\n      //   output the whole union in place of the first union field, and then output nothing for the\n      //   subsequent fields.\n  \n      bool seenUnion = false;\n      return KJ_MAP(field, sortByCodeOrder(schema.getFields())) {\n        if (hasDiscriminantValue(field.getProto())) {\n          if (seenUnion) {\n            return kj::strTree();\n          } else {\n            seenUnion = true;\n            uint offset = schema.getProto().getStruct().getDiscriminantOffset();\n  \n            // GCC 4.7.3 crashes if you inline unionFields.\n            auto unionFields = sortByCodeOrder(schema.getUnionFields());\n            return kj::strTree(\n                indent, \"union {  # tag bits [\", offset * 16, \", \", offset * 16 + 16, \")\\n\",\n                KJ_MAP(uField, unionFields) {\n                  return genStructField(uField, schema, indent.next());\n                },\n                indent, \"}\\n\");\n          }\n        } else {\n          return genStructField(field, schema, indent);\n        }\n      };\n    }\n}"
  },
  {
    "function_name": "sortByCodeOrder",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "420-424",
    "snippet": "kj::Array<decltype(kj::instance<MemberList>()[0])> sortByCodeOrder(MemberList&& list) {\n    auto sorted = KJ_MAP(item, list) { return item; };\n    std::sort(sorted.begin(), sorted.end(), OrderByCodeOrder());\n    return kj::mv(sorted);\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "sorted"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "sorted.begin()",
            "sorted.end()",
            "OrderByCodeOrder()"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OrderByCodeOrder",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sorted.end",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sorted.begin",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "76-76",
          "snippet": "inline Iterator begin() const { return Iterator(0); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "item",
            "list"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::instance<MemberList>",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::Array<decltype(kj::instance<MemberList>()[0])> sortByCodeOrder(MemberList&& list) {\n      auto sorted = KJ_MAP(item, list) { return item; };\n      std::sort(sorted.begin(), sorted.end(), OrderByCodeOrder());\n      return kj::mv(sorted);\n    }\n}"
  },
  {
    "function_name": "genAnnotations",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "393-396",
    "snippet": "kj::StringTree genAnnotations(Schema schema) {\n    auto proto = schema.getProto();\n    return genAnnotations(proto.getAnnotations(), schemaLoader.get(proto.getScopeId()));\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "proto.getScopeId()"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getScopeId",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getAnnotations",
          "args": [],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genAnnotations(Schema schema) {\n      auto proto = schema.getProto();\n      return genAnnotations(proto.getAnnotations(), schemaLoader.get(proto.getScopeId()));\n    }\n}"
  },
  {
    "function_name": "genAnnotations",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "390-392",
    "snippet": "kj::StringTree genAnnotations(List<schema::Annotation>::Reader list, Schema scope) {\n    return kj::strTree(KJ_MAP(ann, list) { return genAnnotation(ann, scope); });\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "KJ_MAP(ann, list){ return genAnnotation(ann, scope); }"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "ann",
            "list"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genAnnotations(List<schema::Annotation>::Reader list, Schema scope) {\n      return kj::strTree(KJ_MAP(ann, list) { return genAnnotation(ann, scope); });\n    }\n}"
  },
  {
    "function_name": "genAnnotation",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "371-388",
    "snippet": "kj::StringTree genAnnotation(schema::Annotation::Reader annotation,\n                               Schema scope,\n                               const char* prefix = \" \", const char* suffix = \"\") {\n    auto decl = schemaLoader.get(annotation.getId(), annotation.getBrand(), scope);\n    auto proto = decl.getProto();\n    KJ_REQUIRE(proto.isAnnotation());\n    auto annDecl = proto.getAnnotation();\n\n    auto value = genValue(schemaLoader.getType(annDecl.getType(), decl),\n                          annotation.getValue()).flatten();\n    if (value.startsWith(\"(\")) {\n      return kj::strTree(prefix, \"$\", nodeName(decl, scope, annotation.getBrand(), nullptr),\n                         value, suffix);\n    } else {\n      return kj::strTree(prefix, \"$\", nodeName(decl, scope, annotation.getBrand(), nullptr),\n                         \"(\", value, \")\", suffix);\n    }\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "prefix",
            "\"$\"",
            "nodeName(decl, scope, annotation.getBrand(), nullptr)",
            "\"(\"",
            "value",
            "\")\"",
            "suffix"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeName",
          "args": [
            "decl",
            "scope",
            "annotation.getBrand()",
            "nullptr"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "nodeName",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "117-194",
          "snippet": "kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                          kj::Maybe<InterfaceSchema::Method> method) {\n    kj::Vector<Schema> targetPath;\n    kj::Vector<Schema> scopeParts;\n\n    targetPath.add(target);\n\n    std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n    for (auto scopeBrand: brand.getScopes()) {\n      switch (scopeBrand.which()) {\n        case schema::Brand::Scope::BIND:\n          scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n          break;\n        case schema::Brand::Scope::INHERIT:\n          // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n          //   any bindings that are not inherited. This requires a way to determine which of our\n          //   parent scopes have a non-empty parameter list.\n          break;\n      }\n    }\n\n    {\n      Schema parent = target;\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        targetPath.add(parent);\n      }\n    }\n\n    {\n      Schema parent = scope;\n      scopeParts.add(parent);\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        scopeParts.add(parent);\n      }\n    }\n\n    // Remove common scope (unless it has been reparameterized).\n    // TODO(someday):  This is broken in that we aren't checking for shadowing.\n    while (!scopeParts.empty() && targetPath.size() > 1 &&\n           scopeParts.back() == targetPath.back() &&\n           scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n      scopeParts.removeLast();\n      targetPath.removeLast();\n    }\n\n    auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n    while (!targetPath.empty()) {\n      auto part = targetPath.back();\n      auto proto = part.getProto();\n      kj::StringTree partStr;\n      if (proto.getScopeId() == 0) {\n        partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n      } else {\n        partStr = kj::strTree(getUnqualifiedName(part));\n      }\n\n      auto iter = scopeBindings.find(proto.getId());\n      if (iter != scopeBindings.end()) {\n        auto bindings = KJ_MAP(binding, iter->second) {\n          switch (binding.which()) {\n            case schema::Brand::Binding::UNBOUND:\n              return kj::strTree(\"AnyPointer\");\n            case schema::Brand::Binding::TYPE:\n              return genType(binding.getType(), scope, method);\n          }\n          return kj::strTree(\"<unknown binding>\");\n        };\n        partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n      }\n\n      parts.add(kj::mv(partStr));\n      targetPath.removeLast();\n    }\n\n    return kj::StringTree(parts.finish(), \".\");\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                            kj::Maybe<InterfaceSchema::Method> method) {\n      kj::Vector<Schema> targetPath;\n      kj::Vector<Schema> scopeParts;\n  \n      targetPath.add(target);\n  \n      std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n      for (auto scopeBrand: brand.getScopes()) {\n        switch (scopeBrand.which()) {\n          case schema::Brand::Scope::BIND:\n            scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n            break;\n          case schema::Brand::Scope::INHERIT:\n            // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n            //   any bindings that are not inherited. This requires a way to determine which of our\n            //   parent scopes have a non-empty parameter list.\n            break;\n        }\n      }\n  \n      {\n        Schema parent = target;\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          targetPath.add(parent);\n        }\n      }\n  \n      {\n        Schema parent = scope;\n        scopeParts.add(parent);\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          scopeParts.add(parent);\n        }\n      }\n  \n      // Remove common scope (unless it has been reparameterized).\n      // TODO(someday):  This is broken in that we aren't checking for shadowing.\n      while (!scopeParts.empty() && targetPath.size() > 1 &&\n             scopeParts.back() == targetPath.back() &&\n             scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n        scopeParts.removeLast();\n        targetPath.removeLast();\n      }\n  \n      auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n      while (!targetPath.empty()) {\n        auto part = targetPath.back();\n        auto proto = part.getProto();\n        kj::StringTree partStr;\n        if (proto.getScopeId() == 0) {\n          partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n        } else {\n          partStr = kj::strTree(getUnqualifiedName(part));\n        }\n  \n        auto iter = scopeBindings.find(proto.getId());\n        if (iter != scopeBindings.end()) {\n          auto bindings = KJ_MAP(binding, iter->second) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Brand::Binding::TYPE:\n                return genType(binding.getType(), scope, method);\n            }\n            return kj::strTree(\"<unknown binding>\");\n          };\n          partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n        }\n  \n        parts.add(kj::mv(partStr));\n        targetPath.removeLast();\n      }\n  \n      return kj::StringTree(parts.finish(), \".\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "annotation.getBrand",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "prefix",
            "\"$\"",
            "nodeName(decl, scope, annotation.getBrand(), nullptr)",
            "value",
            "suffix"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getBrand",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.startsWith",
          "args": [
            "\"(\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "genValue",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genValue",
          "args": [
            "schemaLoader.getType(annDecl.getType(), decl)",
            "annotation.getValue()"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "genValue",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "313-356",
          "snippet": "kj::StringTree genValue(Type type, schema::Value::Reader value) {\n    switch (value.which()) {\n      case schema::Value::VOID: return kj::strTree(\"void\");\n      case schema::Value::BOOL:\n        return kj::strTree(value.getBool() ? \"true\" : \"false\");\n      case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n      case schema::Value::INT16: return kj::strTree(value.getInt16());\n      case schema::Value::INT32: return kj::strTree(value.getInt32());\n      case schema::Value::INT64: return kj::strTree(value.getInt64());\n      case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n      case schema::Value::UINT16: return kj::strTree(value.getUint16());\n      case schema::Value::UINT32: return kj::strTree(value.getUint32());\n      case schema::Value::UINT64: return kj::strTree(value.getUint64());\n      case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n      case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n      case schema::Value::TEXT:\n        return kj::strTree(DynamicValue::Reader(value.getText()));\n      case schema::Value::DATA:\n        return kj::strTree(DynamicValue::Reader(value.getData()));\n      case schema::Value::LIST: {\n        auto listValue = value.getList().getAs<DynamicList>(type.asList());\n        return kj::strTree(listValue);\n      }\n      case schema::Value::ENUM: {\n        auto enumNode = type.asEnum().getProto();\n        auto enumerants = enumNode.getEnum().getEnumerants();\n        KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n        return kj::strTree(enumerants[value.getEnum()].getName());\n      }\n      case schema::Value::STRUCT: {\n        KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n        auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n        return kj::strTree(structValue);\n      }\n      case schema::Value::INTERFACE: {\n        return kj::strTree(\"\");\n      }\n      case schema::Value::ANY_POINTER: {\n        return kj::strTree(\"\");\n      }\n    }\n    return kj::strTree(\"\");\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genValue(Type type, schema::Value::Reader value) {\n      switch (value.which()) {\n        case schema::Value::VOID: return kj::strTree(\"void\");\n        case schema::Value::BOOL:\n          return kj::strTree(value.getBool() ? \"true\" : \"false\");\n        case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n        case schema::Value::INT16: return kj::strTree(value.getInt16());\n        case schema::Value::INT32: return kj::strTree(value.getInt32());\n        case schema::Value::INT64: return kj::strTree(value.getInt64());\n        case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n        case schema::Value::UINT16: return kj::strTree(value.getUint16());\n        case schema::Value::UINT32: return kj::strTree(value.getUint32());\n        case schema::Value::UINT64: return kj::strTree(value.getUint64());\n        case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n        case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n        case schema::Value::TEXT:\n          return kj::strTree(DynamicValue::Reader(value.getText()));\n        case schema::Value::DATA:\n          return kj::strTree(DynamicValue::Reader(value.getData()));\n        case schema::Value::LIST: {\n          auto listValue = value.getList().getAs<DynamicList>(type.asList());\n          return kj::strTree(listValue);\n        }\n        case schema::Value::ENUM: {\n          auto enumNode = type.asEnum().getProto();\n          auto enumerants = enumNode.getEnum().getEnumerants();\n          KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                  \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n          return kj::strTree(enumerants[value.getEnum()].getName());\n        }\n        case schema::Value::STRUCT: {\n          KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n          auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n          return kj::strTree(structValue);\n        }\n        case schema::Value::INTERFACE: {\n          return kj::strTree(\"\");\n        }\n        case schema::Value::ANY_POINTER: {\n          return kj::strTree(\"\");\n        }\n      }\n      return kj::strTree(\"\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "annotation.getValue",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaLoader.getType",
          "args": [
            "annDecl.getType()",
            "decl"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annDecl.getType",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getAnnotation",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "proto.isAnnotation()"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.isAnnotation",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decl.getProto",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "annotation.getId()",
            "annotation.getBrand()",
            "scope"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getBrand",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "annotation.getId",
          "args": [],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genAnnotation(schema::Annotation::Reader annotation,\n                                 Schema scope,\n                                 const char* prefix = \" \", const char* suffix = \"\") {\n      auto decl = schemaLoader.get(annotation.getId(), annotation.getBrand(), scope);\n      auto proto = decl.getProto();\n      KJ_REQUIRE(proto.isAnnotation());\n      auto annDecl = proto.getAnnotation();\n  \n      auto value = genValue(schemaLoader.getType(annDecl.getType(), decl),\n                            annotation.getValue()).flatten();\n      if (value.startsWith(\"(\")) {\n        return kj::strTree(prefix, \"$\", nodeName(decl, scope, annotation.getBrand(), nullptr),\n                           value, suffix);\n      } else {\n        return kj::strTree(prefix, \"$\", nodeName(decl, scope, annotation.getBrand(), nullptr),\n                           \"(\", value, \")\", suffix);\n      }\n    }\n}"
  },
  {
    "function_name": "genGenericParams",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "366-369",
    "snippet": "kj::StringTree genGenericParams(Schema schema) {\n    auto proto = schema.getProto();\n    return genGenericParams(proto.getParameters(), schemaLoader.get(proto.getScopeId()));\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "proto.getScopeId()"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getScopeId",
          "args": [],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getParameters",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schema.getProto",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genGenericParams(Schema schema) {\n      auto proto = schema.getProto();\n      return genGenericParams(proto.getParameters(), schemaLoader.get(proto.getScopeId()));\n    }\n}"
  },
  {
    "function_name": "genGenericParams",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "358-365",
    "snippet": "kj::StringTree genGenericParams(List<schema::Node::Parameter>::Reader params, Schema scope) {\n    if (params.size() == 0) {\n      return kj::strTree();\n    }\n\n    return kj::strTree(\" (\", kj::StringTree(\n        KJ_MAP(param, params) { return kj::strTree(param.getName()); }, \", \"), ')');\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\" (\"",
            "kj::StringTree(\n        KJ_MAP(param, params) { return kj::strTree(param.getName()); }, \", \")",
            "')'"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "KJ_MAP(param, params){ return kj::strTree(param.getName()); }",
            "\", \""
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "param.getName()"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getName",
          "args": [],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "param",
            "params"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "strTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string-tree.h",
          "lines": "206-208",
          "snippet": "StringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}",
          "includes": [
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n\nStringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genGenericParams(List<schema::Node::Parameter>::Reader params, Schema scope) {\n      if (params.size() == 0) {\n        return kj::strTree();\n      }\n  \n      return kj::strTree(\" (\", kj::StringTree(\n          KJ_MAP(param, params) { return kj::strTree(param.getName()); }, \", \"), ')');\n    }\n}"
  },
  {
    "function_name": "genValue",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "313-356",
    "snippet": "kj::StringTree genValue(Type type, schema::Value::Reader value) {\n    switch (value.which()) {\n      case schema::Value::VOID: return kj::strTree(\"void\");\n      case schema::Value::BOOL:\n        return kj::strTree(value.getBool() ? \"true\" : \"false\");\n      case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n      case schema::Value::INT16: return kj::strTree(value.getInt16());\n      case schema::Value::INT32: return kj::strTree(value.getInt32());\n      case schema::Value::INT64: return kj::strTree(value.getInt64());\n      case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n      case schema::Value::UINT16: return kj::strTree(value.getUint16());\n      case schema::Value::UINT32: return kj::strTree(value.getUint32());\n      case schema::Value::UINT64: return kj::strTree(value.getUint64());\n      case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n      case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n      case schema::Value::TEXT:\n        return kj::strTree(DynamicValue::Reader(value.getText()));\n      case schema::Value::DATA:\n        return kj::strTree(DynamicValue::Reader(value.getData()));\n      case schema::Value::LIST: {\n        auto listValue = value.getList().getAs<DynamicList>(type.asList());\n        return kj::strTree(listValue);\n      }\n      case schema::Value::ENUM: {\n        auto enumNode = type.asEnum().getProto();\n        auto enumerants = enumNode.getEnum().getEnumerants();\n        KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n        return kj::strTree(enumerants[value.getEnum()].getName());\n      }\n      case schema::Value::STRUCT: {\n        KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n        auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n        return kj::strTree(structValue);\n      }\n      case schema::Value::INTERFACE: {\n        return kj::strTree(\"\");\n      }\n      case schema::Value::ANY_POINTER: {\n        return kj::strTree(\"\");\n      }\n    }\n    return kj::strTree(\"\");\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"\""
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "structValue"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getStruct",
          "args": [
            "type.asStruct()"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asStruct",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getStruct",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "type.which() == schema::Type::STRUCT",
            "\"type/value mismatch\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "enumerants[value.getEnum()].getName()"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerants[value.getEnum",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getEnum",
          "args": [],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "value.getEnum() < enumerants.size()",
            "\"Enum value out-of-range.\"",
            "value.getEnum()",
            "enumNode.getDisplayName()"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumNode.getDisplayName",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "value.getEnum",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumerants.size",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.getEnum",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumNode.getEnum",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enumNode.getEnum",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asEnum",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asEnum",
          "args": [],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "listValue"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getList",
          "args": [
            "type.asList()"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.asList",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getList",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "DynamicValue::Reader(value.getData())"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DynamicValue::Reader",
          "args": [
            "value.getData()"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "Reader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/grammar.capnp.h",
          "lines": "3113-3113",
          "snippet": "inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}",
          "includes": [
            "#include <capnp/generated-header-support.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/generated-header-support.h>\n\ninline explicit Reader(::capnp::_::StructReader base): _reader(base) {}"
        }
      },
      {
        "call_info": {
          "callee": "value.getData",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "DynamicValue::Reader(value.getText())"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getText",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getFloat64()"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getFloat64",
          "args": [],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getFloat32()"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getFloat32",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getUint64()"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getUint64",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getUint32()"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getUint32",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getUint16()"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getUint16",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "(uint)value.getUint8()"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getUint8",
          "args": [],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getInt64()"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getInt64",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getInt32()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getInt32",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getInt16()"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getInt16",
          "args": [],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "(int)value.getInt8()"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getInt8",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "value.getBool() ? \"true\" : \"false\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getBool",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"void\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.which",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genValue(Type type, schema::Value::Reader value) {\n      switch (value.which()) {\n        case schema::Value::VOID: return kj::strTree(\"void\");\n        case schema::Value::BOOL:\n          return kj::strTree(value.getBool() ? \"true\" : \"false\");\n        case schema::Value::INT8: return kj::strTree((int)value.getInt8());\n        case schema::Value::INT16: return kj::strTree(value.getInt16());\n        case schema::Value::INT32: return kj::strTree(value.getInt32());\n        case schema::Value::INT64: return kj::strTree(value.getInt64());\n        case schema::Value::UINT8: return kj::strTree((uint)value.getUint8());\n        case schema::Value::UINT16: return kj::strTree(value.getUint16());\n        case schema::Value::UINT32: return kj::strTree(value.getUint32());\n        case schema::Value::UINT64: return kj::strTree(value.getUint64());\n        case schema::Value::FLOAT32: return kj::strTree(value.getFloat32());\n        case schema::Value::FLOAT64: return kj::strTree(value.getFloat64());\n        case schema::Value::TEXT:\n          return kj::strTree(DynamicValue::Reader(value.getText()));\n        case schema::Value::DATA:\n          return kj::strTree(DynamicValue::Reader(value.getData()));\n        case schema::Value::LIST: {\n          auto listValue = value.getList().getAs<DynamicList>(type.asList());\n          return kj::strTree(listValue);\n        }\n        case schema::Value::ENUM: {\n          auto enumNode = type.asEnum().getProto();\n          auto enumerants = enumNode.getEnum().getEnumerants();\n          KJ_REQUIRE(value.getEnum() < enumerants.size(),\n                  \"Enum value out-of-range.\", value.getEnum(), enumNode.getDisplayName());\n          return kj::strTree(enumerants[value.getEnum()].getName());\n        }\n        case schema::Value::STRUCT: {\n          KJ_REQUIRE(type.which() == schema::Type::STRUCT, \"type/value mismatch\");\n          auto structValue = value.getStruct().getAs<DynamicStruct>(type.asStruct());\n          return kj::strTree(structValue);\n        }\n        case schema::Value::INTERFACE: {\n          return kj::strTree(\"\");\n        }\n        case schema::Value::ANY_POINTER: {\n          return kj::strTree(\"\");\n        }\n      }\n      return kj::strTree(\"\");\n    }\n}"
  },
  {
    "function_name": "isEmptyValue",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "288-311",
    "snippet": "bool isEmptyValue(schema::Value::Reader value) {\n    switch (value.which()) {\n      case schema::Value::VOID: return true;\n      case schema::Value::BOOL: return value.getBool() == false;\n      case schema::Value::INT8: return value.getInt8() == 0;\n      case schema::Value::INT16: return value.getInt16() == 0;\n      case schema::Value::INT32: return value.getInt32() == 0;\n      case schema::Value::INT64: return value.getInt64() == 0;\n      case schema::Value::UINT8: return value.getUint8() == 0;\n      case schema::Value::UINT16: return value.getUint16() == 0;\n      case schema::Value::UINT32: return value.getUint32() == 0;\n      case schema::Value::UINT64: return value.getUint64() == 0;\n      case schema::Value::FLOAT32: return value.getFloat32() == 0;\n      case schema::Value::FLOAT64: return value.getFloat64() == 0;\n      case schema::Value::TEXT: return !value.hasText();\n      case schema::Value::DATA: return !value.hasData();\n      case schema::Value::LIST: return !value.hasList();\n      case schema::Value::ENUM: return value.getEnum() == 0;\n      case schema::Value::STRUCT: return !value.hasStruct();\n      case schema::Value::INTERFACE: return true;\n      case schema::Value::ANY_POINTER: return true;\n    }\n    return true;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value.hasStruct",
          "args": [],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getEnum",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.hasList",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.hasData",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.hasText",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getFloat64",
          "args": [],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getFloat32",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getUint64",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getUint32",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getUint16",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getUint8",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getInt64",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getInt32",
          "args": [],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getInt16",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getInt8",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getBool",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.which",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  bool isEmptyValue(schema::Value::Reader value) {\n      switch (value.which()) {\n        case schema::Value::VOID: return true;\n        case schema::Value::BOOL: return value.getBool() == false;\n        case schema::Value::INT8: return value.getInt8() == 0;\n        case schema::Value::INT16: return value.getInt16() == 0;\n        case schema::Value::INT32: return value.getInt32() == 0;\n        case schema::Value::INT64: return value.getInt64() == 0;\n        case schema::Value::UINT8: return value.getUint8() == 0;\n        case schema::Value::UINT16: return value.getUint16() == 0;\n        case schema::Value::UINT32: return value.getUint32() == 0;\n        case schema::Value::UINT64: return value.getUint64() == 0;\n        case schema::Value::FLOAT32: return value.getFloat32() == 0;\n        case schema::Value::FLOAT64: return value.getFloat64() == 0;\n        case schema::Value::TEXT: return !value.hasText();\n        case schema::Value::DATA: return !value.hasData();\n        case schema::Value::LIST: return !value.hasList();\n        case schema::Value::ENUM: return value.getEnum() == 0;\n        case schema::Value::STRUCT: return !value.hasStruct();\n        case schema::Value::INTERFACE: return true;\n        case schema::Value::ANY_POINTER: return true;\n      }\n      return true;\n    }\n}"
  },
  {
    "function_name": "typeSizeBits",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "263-286",
    "snippet": "int typeSizeBits(schema::Type::Reader type) {\n    switch (type.which()) {\n      case schema::Type::VOID: return 0;\n      case schema::Type::BOOL: return 1;\n      case schema::Type::INT8: return 8;\n      case schema::Type::INT16: return 16;\n      case schema::Type::INT32: return 32;\n      case schema::Type::INT64: return 64;\n      case schema::Type::UINT8: return 8;\n      case schema::Type::UINT16: return 16;\n      case schema::Type::UINT32: return 32;\n      case schema::Type::UINT64: return 64;\n      case schema::Type::FLOAT32: return 32;\n      case schema::Type::FLOAT64: return 64;\n      case schema::Type::TEXT: return -1;\n      case schema::Type::DATA: return -1;\n      case schema::Type::LIST: return -1;\n      case schema::Type::ENUM: return 16;\n      case schema::Type::STRUCT: return -1;\n      case schema::Type::INTERFACE: return -1;\n      case schema::Type::ANY_POINTER: return -1;\n    }\n    return 0;\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  int typeSizeBits(schema::Type::Reader type) {\n      switch (type.which()) {\n        case schema::Type::VOID: return 0;\n        case schema::Type::BOOL: return 1;\n        case schema::Type::INT8: return 8;\n        case schema::Type::INT16: return 16;\n        case schema::Type::INT32: return 32;\n        case schema::Type::INT64: return 64;\n        case schema::Type::UINT8: return 8;\n        case schema::Type::UINT16: return 16;\n        case schema::Type::UINT32: return 32;\n        case schema::Type::UINT64: return 64;\n        case schema::Type::FLOAT32: return 32;\n        case schema::Type::FLOAT64: return 64;\n        case schema::Type::TEXT: return -1;\n        case schema::Type::DATA: return -1;\n        case schema::Type::LIST: return -1;\n        case schema::Type::ENUM: return 16;\n        case schema::Type::STRUCT: return -1;\n        case schema::Type::INTERFACE: return -1;\n        case schema::Type::ANY_POINTER: return -1;\n      }\n      return 0;\n    }\n}"
  },
  {
    "function_name": "genType",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "196-261",
    "snippet": "kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                         kj::Maybe<InterfaceSchema::Method> method) {\n    switch (type.which()) {\n      case schema::Type::VOID: return kj::strTree(\"Void\");\n      case schema::Type::BOOL: return kj::strTree(\"Bool\");\n      case schema::Type::INT8: return kj::strTree(\"Int8\");\n      case schema::Type::INT16: return kj::strTree(\"Int16\");\n      case schema::Type::INT32: return kj::strTree(\"Int32\");\n      case schema::Type::INT64: return kj::strTree(\"Int64\");\n      case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n      case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n      case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n      case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n      case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n      case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n      case schema::Type::TEXT: return kj::strTree(\"Text\");\n      case schema::Type::DATA: return kj::strTree(\"Data\");\n      case schema::Type::LIST:\n        return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n      case schema::Type::ENUM:\n        return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                        type.getEnum().getBrand(), method);\n      case schema::Type::STRUCT:\n        return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                        type.getStruct().getBrand(), method);\n      case schema::Type::INTERFACE:\n        return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                        type.getInterface().getBrand(), method);\n      case schema::Type::ANY_POINTER: {\n        auto anyPointer = type.getAnyPointer();\n        switch (anyPointer.which()) {\n          case schema::Type::AnyPointer::UNCONSTRAINED:\n            switch (anyPointer.getUnconstrained().which()) {\n              case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                return kj::strTree(\"AnyStruct\");\n              case schema::Type::AnyPointer::Unconstrained::LIST:\n                return kj::strTree(\"AnyList\");\n              case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                return kj::strTree(\"Capability\");\n            }\n            KJ_UNREACHABLE;\n          case schema::Type::AnyPointer::PARAMETER: {\n            auto param = anyPointer.getParameter();\n            auto scopeProto = scope.getProto();\n            auto targetScopeId = param.getScopeId();\n            while (scopeProto.getId() != targetScopeId) {\n              scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n            }\n            auto params = scopeProto.getParameters();\n            KJ_REQUIRE(param.getParameterIndex() < params.size());\n            return kj::strTree(params[param.getParameterIndex()].getName());\n          }\n          case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n            auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n            uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n            KJ_REQUIRE(index < params.size());\n            return kj::strTree(params[index].getName());\n          }\n        }\n        KJ_UNREACHABLE;\n      }\n    }\n    return kj::strTree();\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "strTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string-tree.h",
          "lines": "206-208",
          "snippet": "StringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}",
          "includes": [
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"string.h\"\n\nStringTree strTree(Params&&... params) {\n  return StringTree::concat(_::toStringTreeOrCharSequence(kj::fwd<Params>(params))...);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "params[index].getName()"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[index].getName",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "index < params.size()"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "anyPointer.getImplicitMethodParameter",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.getImplicitMethodParameter",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE_NONNULL",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE_NONNULL",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE_NONNULL",
          "args": [
            "method"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "params[param.getParameterIndex()].getName()"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[param.getParameterIndex",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getParameterIndex",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "param.getParameterIndex() < params.size()"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param.getParameterIndex",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeProto.getParameters",
          "args": [],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "param.getScopeId()"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "param.getScopeId",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "scopeProto.getId",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "scope.getProto",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "anyPointer.getParameter",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Capability\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"AnyList\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"AnyStruct\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"AnyPointer\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.getUnconstrained",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.getUnconstrained",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anyPointer.which",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getAnyPointer",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeName",
          "args": [
            "schemaLoader.get(type.getInterface().getTypeId())",
            "scope",
            "type.getInterface().getBrand()",
            "method"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "nodeName",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "117-194",
          "snippet": "kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                          kj::Maybe<InterfaceSchema::Method> method) {\n    kj::Vector<Schema> targetPath;\n    kj::Vector<Schema> scopeParts;\n\n    targetPath.add(target);\n\n    std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n    for (auto scopeBrand: brand.getScopes()) {\n      switch (scopeBrand.which()) {\n        case schema::Brand::Scope::BIND:\n          scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n          break;\n        case schema::Brand::Scope::INHERIT:\n          // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n          //   any bindings that are not inherited. This requires a way to determine which of our\n          //   parent scopes have a non-empty parameter list.\n          break;\n      }\n    }\n\n    {\n      Schema parent = target;\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        targetPath.add(parent);\n      }\n    }\n\n    {\n      Schema parent = scope;\n      scopeParts.add(parent);\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        scopeParts.add(parent);\n      }\n    }\n\n    // Remove common scope (unless it has been reparameterized).\n    // TODO(someday):  This is broken in that we aren't checking for shadowing.\n    while (!scopeParts.empty() && targetPath.size() > 1 &&\n           scopeParts.back() == targetPath.back() &&\n           scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n      scopeParts.removeLast();\n      targetPath.removeLast();\n    }\n\n    auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n    while (!targetPath.empty()) {\n      auto part = targetPath.back();\n      auto proto = part.getProto();\n      kj::StringTree partStr;\n      if (proto.getScopeId() == 0) {\n        partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n      } else {\n        partStr = kj::strTree(getUnqualifiedName(part));\n      }\n\n      auto iter = scopeBindings.find(proto.getId());\n      if (iter != scopeBindings.end()) {\n        auto bindings = KJ_MAP(binding, iter->second) {\n          switch (binding.which()) {\n            case schema::Brand::Binding::UNBOUND:\n              return kj::strTree(\"AnyPointer\");\n            case schema::Brand::Binding::TYPE:\n              return genType(binding.getType(), scope, method);\n          }\n          return kj::strTree(\"<unknown binding>\");\n        };\n        partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n      }\n\n      parts.add(kj::mv(partStr));\n      targetPath.removeLast();\n    }\n\n    return kj::StringTree(parts.finish(), \".\");\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                            kj::Maybe<InterfaceSchema::Method> method) {\n      kj::Vector<Schema> targetPath;\n      kj::Vector<Schema> scopeParts;\n  \n      targetPath.add(target);\n  \n      std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n      for (auto scopeBrand: brand.getScopes()) {\n        switch (scopeBrand.which()) {\n          case schema::Brand::Scope::BIND:\n            scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n            break;\n          case schema::Brand::Scope::INHERIT:\n            // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n            //   any bindings that are not inherited. This requires a way to determine which of our\n            //   parent scopes have a non-empty parameter list.\n            break;\n        }\n      }\n  \n      {\n        Schema parent = target;\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          targetPath.add(parent);\n        }\n      }\n  \n      {\n        Schema parent = scope;\n        scopeParts.add(parent);\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          scopeParts.add(parent);\n        }\n      }\n  \n      // Remove common scope (unless it has been reparameterized).\n      // TODO(someday):  This is broken in that we aren't checking for shadowing.\n      while (!scopeParts.empty() && targetPath.size() > 1 &&\n             scopeParts.back() == targetPath.back() &&\n             scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n        scopeParts.removeLast();\n        targetPath.removeLast();\n      }\n  \n      auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n      while (!targetPath.empty()) {\n        auto part = targetPath.back();\n        auto proto = part.getProto();\n        kj::StringTree partStr;\n        if (proto.getScopeId() == 0) {\n          partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n        } else {\n          partStr = kj::strTree(getUnqualifiedName(part));\n        }\n  \n        auto iter = scopeBindings.find(proto.getId());\n        if (iter != scopeBindings.end()) {\n          auto bindings = KJ_MAP(binding, iter->second) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Brand::Binding::TYPE:\n                return genType(binding.getType(), scope, method);\n            }\n            return kj::strTree(\"<unknown binding>\");\n          };\n          partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n        }\n  \n        parts.add(kj::mv(partStr));\n        targetPath.removeLast();\n      }\n  \n      return kj::StringTree(parts.finish(), \".\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getInterface",
          "args": [],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getStruct",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getEnum",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"List(\"",
            "genType(type.getList().getElementType(), scope, method)",
            "\")\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.getList",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Data\""
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Text\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Float64\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Float32\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"UInt64\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"UInt32\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"UInt16\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"UInt8\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Int64\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Int32\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Int16\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Int8\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Bool\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"Void\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type.which",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                           kj::Maybe<InterfaceSchema::Method> method) {\n      switch (type.which()) {\n        case schema::Type::VOID: return kj::strTree(\"Void\");\n        case schema::Type::BOOL: return kj::strTree(\"Bool\");\n        case schema::Type::INT8: return kj::strTree(\"Int8\");\n        case schema::Type::INT16: return kj::strTree(\"Int16\");\n        case schema::Type::INT32: return kj::strTree(\"Int32\");\n        case schema::Type::INT64: return kj::strTree(\"Int64\");\n        case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n        case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n        case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n        case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n        case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n        case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n        case schema::Type::TEXT: return kj::strTree(\"Text\");\n        case schema::Type::DATA: return kj::strTree(\"Data\");\n        case schema::Type::LIST:\n          return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n        case schema::Type::ENUM:\n          return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                          type.getEnum().getBrand(), method);\n        case schema::Type::STRUCT:\n          return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                          type.getStruct().getBrand(), method);\n        case schema::Type::INTERFACE:\n          return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                          type.getInterface().getBrand(), method);\n        case schema::Type::ANY_POINTER: {\n          auto anyPointer = type.getAnyPointer();\n          switch (anyPointer.which()) {\n            case schema::Type::AnyPointer::UNCONSTRAINED:\n              switch (anyPointer.getUnconstrained().which()) {\n                case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                  return kj::strTree(\"AnyPointer\");\n                case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                  return kj::strTree(\"AnyStruct\");\n                case schema::Type::AnyPointer::Unconstrained::LIST:\n                  return kj::strTree(\"AnyList\");\n                case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                  return kj::strTree(\"Capability\");\n              }\n              KJ_UNREACHABLE;\n            case schema::Type::AnyPointer::PARAMETER: {\n              auto param = anyPointer.getParameter();\n              auto scopeProto = scope.getProto();\n              auto targetScopeId = param.getScopeId();\n              while (scopeProto.getId() != targetScopeId) {\n                scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n              }\n              auto params = scopeProto.getParameters();\n              KJ_REQUIRE(param.getParameterIndex() < params.size());\n              return kj::strTree(params[param.getParameterIndex()].getName());\n            }\n            case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n              auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n              uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n              KJ_REQUIRE(index < params.size());\n              return kj::strTree(params[index].getName());\n            }\n          }\n          KJ_UNREACHABLE;\n        }\n      }\n      return kj::strTree();\n    }\n}"
  },
  {
    "function_name": "nodeName",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "117-194",
    "snippet": "kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                          kj::Maybe<InterfaceSchema::Method> method) {\n    kj::Vector<Schema> targetPath;\n    kj::Vector<Schema> scopeParts;\n\n    targetPath.add(target);\n\n    std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n    for (auto scopeBrand: brand.getScopes()) {\n      switch (scopeBrand.which()) {\n        case schema::Brand::Scope::BIND:\n          scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n          break;\n        case schema::Brand::Scope::INHERIT:\n          // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n          //   any bindings that are not inherited. This requires a way to determine which of our\n          //   parent scopes have a non-empty parameter list.\n          break;\n      }\n    }\n\n    {\n      Schema parent = target;\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        targetPath.add(parent);\n      }\n    }\n\n    {\n      Schema parent = scope;\n      scopeParts.add(parent);\n      while (parent.getProto().getScopeId() != 0) {\n        parent = schemaLoader.get(parent.getProto().getScopeId());\n        scopeParts.add(parent);\n      }\n    }\n\n    // Remove common scope (unless it has been reparameterized).\n    // TODO(someday):  This is broken in that we aren't checking for shadowing.\n    while (!scopeParts.empty() && targetPath.size() > 1 &&\n           scopeParts.back() == targetPath.back() &&\n           scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n      scopeParts.removeLast();\n      targetPath.removeLast();\n    }\n\n    auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n    while (!targetPath.empty()) {\n      auto part = targetPath.back();\n      auto proto = part.getProto();\n      kj::StringTree partStr;\n      if (proto.getScopeId() == 0) {\n        partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n      } else {\n        partStr = kj::strTree(getUnqualifiedName(part));\n      }\n\n      auto iter = scopeBindings.find(proto.getId());\n      if (iter != scopeBindings.end()) {\n        auto bindings = KJ_MAP(binding, iter->second) {\n          switch (binding.which()) {\n            case schema::Brand::Binding::UNBOUND:\n              return kj::strTree(\"AnyPointer\");\n            case schema::Brand::Binding::TYPE:\n              return genType(binding.getType(), scope, method);\n          }\n          return kj::strTree(\"<unknown binding>\");\n        };\n        partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n      }\n\n      parts.add(kj::mv(partStr));\n      targetPath.removeLast();\n    }\n\n    return kj::StringTree(parts.finish(), \".\");\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "parts.finish()",
            "\".\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parts.finish",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "targetPath.removeLast",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "removeLast",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "364-367",
          "snippet": "void removeLast() {\n    KJ_IREQUIRE(pos > ptr, \"No elements present to remove.\");\n    kj::dtor(*--pos);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  void removeLast() {\n      KJ_IREQUIRE(pos > ptr, \"No elements present to remove.\");\n      kj::dtor(*--pos);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parts.add",
          "args": [
            "kj::mv(partStr)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "ReusableObjects::ObjectSizeCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/null-common.h",
          "lines": "86-88",
          "snippet": "void add(size_t wordCount) {\n      maxSize = std::max(wordCount, maxSize);\n    }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nReusableObjects {\n  ObjectSizeCounter {\n    void add(size_t wordCount) {\n          maxSize = std::max(wordCount, maxSize);\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "partStr"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "kj::mv(partStr)",
            "\"(\"",
            "kj::StringTree(kj::mv(bindings), \", \")",
            "\")\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::StringTree",
          "args": [
            "kj::mv(bindings)",
            "\", \""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "bindings"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "partStr"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"<unknown binding>\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genType",
          "args": [
            "binding.getType()",
            "scope",
            "method"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "genType",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "196-261",
          "snippet": "kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                         kj::Maybe<InterfaceSchema::Method> method) {\n    switch (type.which()) {\n      case schema::Type::VOID: return kj::strTree(\"Void\");\n      case schema::Type::BOOL: return kj::strTree(\"Bool\");\n      case schema::Type::INT8: return kj::strTree(\"Int8\");\n      case schema::Type::INT16: return kj::strTree(\"Int16\");\n      case schema::Type::INT32: return kj::strTree(\"Int32\");\n      case schema::Type::INT64: return kj::strTree(\"Int64\");\n      case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n      case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n      case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n      case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n      case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n      case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n      case schema::Type::TEXT: return kj::strTree(\"Text\");\n      case schema::Type::DATA: return kj::strTree(\"Data\");\n      case schema::Type::LIST:\n        return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n      case schema::Type::ENUM:\n        return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                        type.getEnum().getBrand(), method);\n      case schema::Type::STRUCT:\n        return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                        type.getStruct().getBrand(), method);\n      case schema::Type::INTERFACE:\n        return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                        type.getInterface().getBrand(), method);\n      case schema::Type::ANY_POINTER: {\n        auto anyPointer = type.getAnyPointer();\n        switch (anyPointer.which()) {\n          case schema::Type::AnyPointer::UNCONSTRAINED:\n            switch (anyPointer.getUnconstrained().which()) {\n              case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                return kj::strTree(\"AnyStruct\");\n              case schema::Type::AnyPointer::Unconstrained::LIST:\n                return kj::strTree(\"AnyList\");\n              case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                return kj::strTree(\"Capability\");\n            }\n            KJ_UNREACHABLE;\n          case schema::Type::AnyPointer::PARAMETER: {\n            auto param = anyPointer.getParameter();\n            auto scopeProto = scope.getProto();\n            auto targetScopeId = param.getScopeId();\n            while (scopeProto.getId() != targetScopeId) {\n              scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n            }\n            auto params = scopeProto.getParameters();\n            KJ_REQUIRE(param.getParameterIndex() < params.size());\n            return kj::strTree(params[param.getParameterIndex()].getName());\n          }\n          case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n            auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n            uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n            KJ_REQUIRE(index < params.size());\n            return kj::strTree(params[index].getName());\n          }\n        }\n        KJ_UNREACHABLE;\n      }\n    }\n    return kj::strTree();\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree genType(schema::Type::Reader type, Schema scope,\n                           kj::Maybe<InterfaceSchema::Method> method) {\n      switch (type.which()) {\n        case schema::Type::VOID: return kj::strTree(\"Void\");\n        case schema::Type::BOOL: return kj::strTree(\"Bool\");\n        case schema::Type::INT8: return kj::strTree(\"Int8\");\n        case schema::Type::INT16: return kj::strTree(\"Int16\");\n        case schema::Type::INT32: return kj::strTree(\"Int32\");\n        case schema::Type::INT64: return kj::strTree(\"Int64\");\n        case schema::Type::UINT8: return kj::strTree(\"UInt8\");\n        case schema::Type::UINT16: return kj::strTree(\"UInt16\");\n        case schema::Type::UINT32: return kj::strTree(\"UInt32\");\n        case schema::Type::UINT64: return kj::strTree(\"UInt64\");\n        case schema::Type::FLOAT32: return kj::strTree(\"Float32\");\n        case schema::Type::FLOAT64: return kj::strTree(\"Float64\");\n        case schema::Type::TEXT: return kj::strTree(\"Text\");\n        case schema::Type::DATA: return kj::strTree(\"Data\");\n        case schema::Type::LIST:\n          return kj::strTree(\"List(\", genType(type.getList().getElementType(), scope, method), \")\");\n        case schema::Type::ENUM:\n          return nodeName(schemaLoader.get(type.getEnum().getTypeId()), scope,\n                          type.getEnum().getBrand(), method);\n        case schema::Type::STRUCT:\n          return nodeName(schemaLoader.get(type.getStruct().getTypeId()), scope,\n                          type.getStruct().getBrand(), method);\n        case schema::Type::INTERFACE:\n          return nodeName(schemaLoader.get(type.getInterface().getTypeId()), scope,\n                          type.getInterface().getBrand(), method);\n        case schema::Type::ANY_POINTER: {\n          auto anyPointer = type.getAnyPointer();\n          switch (anyPointer.which()) {\n            case schema::Type::AnyPointer::UNCONSTRAINED:\n              switch (anyPointer.getUnconstrained().which()) {\n                case schema::Type::AnyPointer::Unconstrained::ANY_KIND:\n                  return kj::strTree(\"AnyPointer\");\n                case schema::Type::AnyPointer::Unconstrained::STRUCT:\n                  return kj::strTree(\"AnyStruct\");\n                case schema::Type::AnyPointer::Unconstrained::LIST:\n                  return kj::strTree(\"AnyList\");\n                case schema::Type::AnyPointer::Unconstrained::CAPABILITY:\n                  return kj::strTree(\"Capability\");\n              }\n              KJ_UNREACHABLE;\n            case schema::Type::AnyPointer::PARAMETER: {\n              auto param = anyPointer.getParameter();\n              auto scopeProto = scope.getProto();\n              auto targetScopeId = param.getScopeId();\n              while (scopeProto.getId() != targetScopeId) {\n                scopeProto = schemaLoader.get(param.getScopeId()).getProto();\n              }\n              auto params = scopeProto.getParameters();\n              KJ_REQUIRE(param.getParameterIndex() < params.size());\n              return kj::strTree(params[param.getParameterIndex()].getName());\n            }\n            case schema::Type::AnyPointer::IMPLICIT_METHOD_PARAMETER: {\n              auto params = KJ_REQUIRE_NONNULL(method).getProto().getImplicitParameters();\n              uint index = anyPointer.getImplicitMethodParameter().getParameterIndex();\n              KJ_REQUIRE(index < params.size());\n              return kj::strTree(params[index].getName());\n            }\n          }\n          KJ_UNREACHABLE;\n        }\n      }\n      return kj::strTree();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "binding.getType",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "getType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "942-942",
          "snippet": "inline DynamicValue::Type getType() { return type; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\ninline DynamicValue::Type getType() { return type; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"AnyPointer\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binding.which",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "binding",
            "iter->second"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeBindings.end",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "77-77",
          "snippet": "inline Iterator end() const { return Iterator(amount); }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scopeBindings.find",
          "args": [
            "proto.getId()"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "ImportTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "191-202",
          "snippet": "kj::Maybe<T&> find(Id id) {\n    if (id < kj::size(low)) {\n      return low[id];\n    } else {\n      auto iter = high.find(id);\n      if (iter == high.end()) {\n        return nullptr;\n      } else {\n        return iter->second;\n      }\n    }\n  }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nImportTable {\n  kj::Maybe<T&> find(Id id) {\n      if (id < kj::size(low)) {\n        return low[id];\n      } else {\n        auto iter = high.find(id);\n        if (iter == high.end()) {\n          return nullptr;\n        } else {\n          return iter->second;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "proto.getId",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "getUnqualifiedName(part)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getUnqualifiedName",
          "args": [
            "part"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "getUnqualifiedName",
          "container": "CapnpcCapnpMain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "104-115",
          "snippet": "Text::Reader getUnqualifiedName(Schema schema) {\n    auto proto = schema.getProto();\n    KJ_CONTEXT(proto.getDisplayName());\n    auto parent = schemaLoader.get(proto.getScopeId());\n    for (auto nested: parent.getProto().getNestedNodes()) {\n      if (nested.getId() == proto.getId()) {\n        return nested.getName();\n      }\n    }\n    KJ_FAIL_REQUIRE(\"A schema Node's supposed scope did not contain the node as a NestedNode.\");\n    return \"(?)\";\n  }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  Text::Reader getUnqualifiedName(Schema schema) {\n      auto proto = schema.getProto();\n      KJ_CONTEXT(proto.getDisplayName());\n      auto parent = schemaLoader.get(proto.getScopeId());\n      for (auto nested: parent.getProto().getNestedNodes()) {\n        if (nested.getId() == proto.getId()) {\n          return nested.getName();\n        }\n      }\n      KJ_FAIL_REQUIRE(\"A schema Node's supposed scope did not contain the node as a NestedNode.\");\n      return \"(?)\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::strTree",
          "args": [
            "\"import \\\"/\"",
            "proto.getDisplayName()",
            "'\\\"'"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getDisplayName",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getScopeId",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "part.getProto",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "targetPath.back",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "targetPath.empty",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "53-53",
          "snippet": "inline bool empty() const { return size() == 0; }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline bool empty() const { return size() == 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<kj::StringTree>",
          "args": [
            "targetPath.size()"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "targetPath.size",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Indent",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "74-74",
          "snippet": "inline size_t size() const { return amount; }",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scopeBindings.count",
          "args": [
            "scopeParts.back().getProto().getId()"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeParts.back",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeParts.back",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeParts.back",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "targetPath.back",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeParts.back",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "parent.getProto().getScopeId()"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "scopeBrand.getBind",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scopeBrand.which",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brand.getScopes",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  kj::StringTree nodeName(Schema target, Schema scope, schema::Brand::Reader brand,\n                            kj::Maybe<InterfaceSchema::Method> method) {\n      kj::Vector<Schema> targetPath;\n      kj::Vector<Schema> scopeParts;\n  \n      targetPath.add(target);\n  \n      std::map<uint64_t, List<schema::Brand::Binding>::Reader> scopeBindings;\n      for (auto scopeBrand: brand.getScopes()) {\n        switch (scopeBrand.which()) {\n          case schema::Brand::Scope::BIND:\n            scopeBindings[scopeBrand.getScopeId()] = scopeBrand.getBind();\n            break;\n          case schema::Brand::Scope::INHERIT:\n            // TODO(someday): We need to pay attention to INHERIT and be sure to explicitly override\n            //   any bindings that are not inherited. This requires a way to determine which of our\n            //   parent scopes have a non-empty parameter list.\n            break;\n        }\n      }\n  \n      {\n        Schema parent = target;\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          targetPath.add(parent);\n        }\n      }\n  \n      {\n        Schema parent = scope;\n        scopeParts.add(parent);\n        while (parent.getProto().getScopeId() != 0) {\n          parent = schemaLoader.get(parent.getProto().getScopeId());\n          scopeParts.add(parent);\n        }\n      }\n  \n      // Remove common scope (unless it has been reparameterized).\n      // TODO(someday):  This is broken in that we aren't checking for shadowing.\n      while (!scopeParts.empty() && targetPath.size() > 1 &&\n             scopeParts.back() == targetPath.back() &&\n             scopeBindings.count(scopeParts.back().getProto().getId()) == 0) {\n        scopeParts.removeLast();\n        targetPath.removeLast();\n      }\n  \n      auto parts = kj::heapArrayBuilder<kj::StringTree>(targetPath.size());\n      while (!targetPath.empty()) {\n        auto part = targetPath.back();\n        auto proto = part.getProto();\n        kj::StringTree partStr;\n        if (proto.getScopeId() == 0) {\n          partStr = kj::strTree(\"import \\\"/\", proto.getDisplayName(), '\\\"');\n        } else {\n          partStr = kj::strTree(getUnqualifiedName(part));\n        }\n  \n        auto iter = scopeBindings.find(proto.getId());\n        if (iter != scopeBindings.end()) {\n          auto bindings = KJ_MAP(binding, iter->second) {\n            switch (binding.which()) {\n              case schema::Brand::Binding::UNBOUND:\n                return kj::strTree(\"AnyPointer\");\n              case schema::Brand::Binding::TYPE:\n                return genType(binding.getType(), scope, method);\n            }\n            return kj::strTree(\"<unknown binding>\");\n          };\n          partStr = kj::strTree(kj::mv(partStr), \"(\", kj::StringTree(kj::mv(bindings), \", \"), \")\");\n        }\n  \n        parts.add(kj::mv(partStr));\n        targetPath.removeLast();\n      }\n  \n      return kj::StringTree(parts.finish(), \".\");\n    }\n}"
  },
  {
    "function_name": "getUnqualifiedName",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "104-115",
    "snippet": "Text::Reader getUnqualifiedName(Schema schema) {\n    auto proto = schema.getProto();\n    KJ_CONTEXT(proto.getDisplayName());\n    auto parent = schemaLoader.get(proto.getScopeId());\n    for (auto nested: parent.getProto().getNestedNodes()) {\n      if (nested.getId() == proto.getId()) {\n        return nested.getName();\n      }\n    }\n    KJ_FAIL_REQUIRE(\"A schema Node's supposed scope did not contain the node as a NestedNode.\");\n    return \"(?)\";\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"A schema Node's supposed scope did not contain the node as a NestedNode.\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested.getName",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getId",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "getId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/compiler.c++",
          "lines": "75-75",
          "snippet": "uint64_t getId() { return id; }",
          "includes": [
            "#include \"md5.h\"",
            "#include \"node-translator.h\"",
            "#include <unordered_map>",
            "#include <set>",
            "#include <map>",
            "#include <capnp/message.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/arena.h>",
            "#include <kj/mutex.h>",
            "#include \"parser.h\"      // only for generateChildId()",
            "#include \"compiler.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"md5.h\"\n#include \"node-translator.h\"\n#include <unordered_map>\n#include <set>\n#include <map>\n#include <capnp/message.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/arena.h>\n#include <kj/mutex.h>\n#include \"parser.h\"      // only for generateChildId()\n#include \"compiler.h\"\n\nuint64_t getId() { return id; }"
        }
      },
      {
        "call_info": {
          "callee": "parent.getProto",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "getProto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema.h",
          "lines": "483-483",
          "snippet": "inline schema::Method::Reader getProto() const { return proto; }",
          "includes": [
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/schema.capnp.h>\n\ninline schema::Method::Reader getProto() const { return proto; }"
        }
      },
      {
        "call_info": {
          "callee": "schemaLoader.get",
          "args": [
            "proto.getScopeId()"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "868-871",
          "snippet": "static inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nstatic inline AnyList::Builder get(\n      PointerBuilder builder, const word* defaultValue = nullptr) {\n    return AnyList::Builder(builder.getListAnySize(defaultValue));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "proto.getScopeId",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "getScopeId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/node-translator.c++",
          "lines": "778-778",
          "snippet": "inline uint64_t getScopeId() { return leafId; }",
          "includes": [
            "#include <map>",
            "#include <set>",
            "#include <kj/arena.h>",
            "#include <kj/debug.h>",
            "#include \"parser.h\"      // only for generateGroupId()",
            "#include \"node-translator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t leafId;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <map>\n#include <set>\n#include <kj/arena.h>\n#include <kj/debug.h>\n#include \"parser.h\"      // only for generateGroupId()\n#include \"node-translator.h\"\n\nuint64_t leafId;\n\ninline uint64_t getScopeId() { return leafId; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_CONTEXT",
          "args": [
            "proto.getDisplayName()"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proto.getDisplayName",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "getDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/schema-parser.c++",
          "lines": "416-418",
          "snippet": "kj::StringPtr getDisplayName() const override {\n    return displayName;\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <errno.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include <kj/vector.h>",
            "#include <kj/mutex.h>",
            "#include <unordered_map>",
            "#include <capnp/compiler/parser.h>",
            "#include <capnp/compiler/grammar.capnp.h>",
            "#include <capnp/compiler/lexer.h>",
            "#include <capnp/compiler/lexer.capnp.h>",
            "#include <capnp/compiler/compiler.h>",
            "#include \"message.h\"",
            "#include \"schema-parser.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <windows.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include <kj/vector.h>\n#include <kj/mutex.h>\n#include <unordered_map>\n#include <capnp/compiler/parser.h>\n#include <capnp/compiler/grammar.capnp.h>\n#include <capnp/compiler/lexer.h>\n#include <capnp/compiler/lexer.capnp.h>\n#include <capnp/compiler/compiler.h>\n#include \"message.h\"\n#include \"schema-parser.h\"\n\nkj::StringPtr getDisplayName() const override {\n    return displayName;\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  Text::Reader getUnqualifiedName(Schema schema) {\n      auto proto = schema.getProto();\n      KJ_CONTEXT(proto.getDisplayName());\n      auto parent = schemaLoader.get(proto.getScopeId());\n      for (auto nested: parent.getProto().getNestedNodes()) {\n        if (nested.getId() == proto.getId()) {\n          return nested.getName();\n        }\n      }\n      KJ_FAIL_REQUIRE(\"A schema Node's supposed scope did not contain the node as a NestedNode.\");\n      return \"(?)\";\n    }\n}"
  },
  {
    "function_name": "getMain",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "90-98",
    "snippet": "kj::MainFunc getMain() {\n    return kj::MainBuilder(context, \"Cap'n Proto loopback plugin version \" VERSION,\n          \"This is a Cap'n Proto compiler plugin which \\\"de-compiles\\\" the schema back into \"\n          \"Cap'n Proto schema language format, with comments showing the offsets chosen by the \"\n          \"compiler.  This is meant to be run using the Cap'n Proto compiler, e.g.:\\n\"\n          \"    capnp compile -ocapnp foo.capnp\")\n        .callAfterParsing(KJ_BIND_METHOD(*this, run))\n        .build();\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [
      "#define VERSION \"(unknown)\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "KJ_BIND_METHOD(*this, run)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_BIND_METHOD",
          "args": [
            "*this",
            "run"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::MainBuilder",
          "args": [
            "context",
            "\"Cap'n Proto loopback plugin version \"VERSION",
            "\"This is a Cap'n Proto compiler plugin which \\\"de-compiles\\\" the schema back into \"\n          \"Cap'n Proto schema language format, with comments showing the offsets chosen by the \"\n          \"compiler.  This is meant to be run using the Cap'n Proto compiler, e.g.:\\n\"\n          \"    capnp compile -ocapnp foo.capnp\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\n#define VERSION \"(unknown)\"\n\nCapnpcCapnpMain {\n  kj::MainFunc getMain() {\n      return kj::MainBuilder(context, \"Cap'n Proto loopback plugin version \" VERSION,\n            \"This is a Cap'n Proto compiler plugin which \\\"de-compiles\\\" the schema back into \"\n            \"Cap'n Proto schema language format, with comments showing the offsets chosen by the \"\n            \"compiler.  This is meant to be run using the Cap'n Proto compiler, e.g.:\\n\"\n            \"    capnp compile -ocapnp foo.capnp\")\n          .callAfterParsing(KJ_BIND_METHOD(*this, run))\n          .build();\n    }\n}"
  },
  {
    "function_name": "CapnpcCapnpMain",
    "container": "CapnpcCapnpMain",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "88-88",
    "snippet": "CapnpcCapnpMain(kj::ProcessContext& context): context(context) {}",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nCapnpcCapnpMain {\n  CapnpcCapnpMain(kj::ProcessContext& context): context(context) {}\n}"
  },
  {
    "function_name": "KJ_STRINGIFY",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "80-82",
    "snippet": "inline Indent KJ_STRINGIFY(const Indent& indent) {\n  return indent;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\ninline Indent KJ_STRINGIFY(const Indent& indent) {\n  return indent;\n}"
  },
  {
    "function_name": "end",
    "container": "Indent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "77-77",
    "snippet": "inline Iterator end() const { return Iterator(amount); }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Iterator",
          "args": [
            "amount"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "Iterator",
          "container": "Indent::Iterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "66-66",
          "snippet": "inline Iterator(uint i): i(i) {}",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Iterator {\n    inline Iterator(uint i): i(i) {}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator end() const { return Iterator(amount); }\n}"
  },
  {
    "function_name": "begin",
    "container": "Indent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "76-76",
    "snippet": "inline Iterator begin() const { return Iterator(0); }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Iterator",
          "args": [
            "0"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "Iterator",
          "container": "Indent::Iterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "66-66",
          "snippet": "inline Iterator(uint i): i(i) {}",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Iterator {\n    inline Iterator(uint i): i(i) {}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Iterator begin() const { return Iterator(0); }\n}"
  },
  {
    "function_name": "size",
    "container": "Indent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "74-74",
    "snippet": "inline size_t size() const { return amount; }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline size_t size() const { return amount; }\n}"
  },
  {
    "function_name": "Iterator",
    "container": "Indent::Iterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "66-66",
    "snippet": "inline Iterator(uint i): i(i) {}",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Iterator {\n    inline Iterator(uint i): i(i) {}\n  }\n}"
  },
  {
    "function_name": "next",
    "container": "Indent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "59-61",
    "snippet": "Indent next() {\n    return Indent(amount + 2);\n  }",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Indent",
          "args": [
            "amount + 2"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "Iterator",
          "container": "Indent::Iterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
          "lines": "66-66",
          "snippet": "inline Iterator(uint i): i(i) {}",
          "includes": [
            "#include \"config.h\"",
            "#include <map>",
            "#include <algorithm>",
            "#include <kj/main.h>",
            "#include <unordered_map>",
            "#include <unistd.h>",
            "#include \"../dynamic.h\"",
            "#include \"../schema-loader.h\"",
            "#include <kj/vector.h>",
            "#include <kj/string-tree.h>",
            "#include <kj/io.h>",
            "#include <kj/debug.h>",
            "#include \"../serialize.h\"",
            "#include <capnp/schema.capnp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Iterator {\n    inline Iterator(uint i): i(i) {}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  Indent next() {\n      return Indent(amount + 2);\n    }\n}"
  },
  {
    "function_name": "Indent",
    "container": "Indent",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "57-57",
    "snippet": "inline Indent(int amount): amount(amount) {}",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nIndent {\n  inline Indent(int amount): amount(amount) {}\n}"
  },
  {
    "function_name": "hasDiscriminantValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/compiler/capnpc-capnp.c++",
    "lines": "50-52",
    "snippet": "bool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}",
    "includes": [
      "#include \"config.h\"",
      "#include <map>",
      "#include <algorithm>",
      "#include <kj/main.h>",
      "#include <unordered_map>",
      "#include <unistd.h>",
      "#include \"../dynamic.h\"",
      "#include \"../schema-loader.h\"",
      "#include <kj/vector.h>",
      "#include <kj/string-tree.h>",
      "#include <kj/io.h>",
      "#include <kj/debug.h>",
      "#include \"../serialize.h\"",
      "#include <capnp/schema.capnp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reader.getDiscriminantValue",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"config.h\"\n#include <map>\n#include <algorithm>\n#include <kj/main.h>\n#include <unordered_map>\n#include <unistd.h>\n#include \"../dynamic.h\"\n#include \"../schema-loader.h\"\n#include <kj/vector.h>\n#include <kj/string-tree.h>\n#include <kj/io.h>\n#include <kj/debug.h>\n#include \"../serialize.h\"\n#include <capnp/schema.capnp.h>\n\nbool hasDiscriminantValue(const schema::Field::Reader& reader) {\n  return reader.getDiscriminantValue() != schema::Field::NO_DISCRIMINANT;\n}"
  }
]