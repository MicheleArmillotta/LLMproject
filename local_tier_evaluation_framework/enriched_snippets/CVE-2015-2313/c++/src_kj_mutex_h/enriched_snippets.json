[
  {
    "function_name": "run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "338-340",
    "snippet": "void run() override {\n    lazy.value = func(lazy.space);\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func",
          "args": [
            "lazy.space"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nvoid run() override {\n    lazy.value = func(lazy.space);\n  }"
  },
  {
    "function_name": "InitImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "336-336",
    "snippet": "inline InitImpl(const Lazy<T>& lazy, Func&& func): lazy(lazy), func(kj::fwd<Func>(func)) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<Func>",
          "args": [
            "func"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\ninline InitImpl(const Lazy<T>& lazy, Func&& func): lazy(lazy), func(kj::fwd<Func>(func)) {}"
  },
  {
    "function_name": "MutexGuarded<T>::lockShared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "305-308",
    "snippet": "inline Locked<const T> MutexGuarded<T>::lockShared() const {\n  mutex.lock(_::Mutex::SHARED);\n  return Locked<const T>(mutex, value);\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Locked<const T>",
          "args": [
            "mutex",
            "value"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "Locked",
          "container": "Locked",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
          "lines": "203-203",
          "snippet": "inline Locked(_::Mutex& mutex, T& value): mutex(&mutex), ptr(&value) {}",
          "includes": [
            "#include <pthread.h>",
            "#include <inttypes.h>",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nLocked {\n  inline Locked(_::Mutex& mutex, T& value): mutex(&mutex), ptr(&value) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex.lock",
          "args": [
            "_::Mutex::SHARED"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\ninline Locked<const T> MutexGuarded<T>::lockShared() const {\n  mutex.lock(_::Mutex::SHARED);\n  return Locked<const T>(mutex, value);\n}"
  },
  {
    "function_name": "MutexGuarded<T>::lockExclusive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "299-302",
    "snippet": "inline Locked<T> MutexGuarded<T>::lockExclusive() const {\n  mutex.lock(_::Mutex::EXCLUSIVE);\n  return Locked<T>(mutex, value);\n}",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Locked<T>",
          "args": [
            "mutex",
            "value"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "Locked",
          "container": "Locked",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
          "lines": "203-203",
          "snippet": "inline Locked(_::Mutex& mutex, T& value): mutex(&mutex), ptr(&value) {}",
          "includes": [
            "#include <pthread.h>",
            "#include <inttypes.h>",
            "#include \"memory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nLocked {\n  inline Locked(_::Mutex& mutex, T& value): mutex(&mutex), ptr(&value) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex.lock",
          "args": [
            "_::Mutex::EXCLUSIVE"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\ninline Locked<T> MutexGuarded<T>::lockExclusive() const {\n  mutex.lock(_::Mutex::EXCLUSIVE);\n  return Locked<T>(mutex, value);\n}"
  },
  {
    "function_name": "MutexGuarded<T>::MutexGuarded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "295-296",
    "snippet": "inline MutexGuarded<T>::MutexGuarded(Params&&... params)\n    : value(kj::fwd<Params>(params)...) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\ninline MutexGuarded<T>::MutexGuarded(Params&&... params)\n    : value(kj::fwd<Params>(params)...) {}"
  },
  {
    "function_name": "Locked",
    "container": "Locked",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "203-203",
    "snippet": "inline Locked(_::Mutex& mutex, T& value): mutex(&mutex), ptr(&value) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nLocked {\n  inline Locked(_::Mutex& mutex, T& value): mutex(&mutex), ptr(&value) {}\n}"
  },
  {
    "function_name": "release",
    "container": "Locked",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "184-188",
    "snippet": "inline void release() {\n    if (mutex != nullptr) mutex->unlock(isConst<T>() ? _::Mutex::SHARED : _::Mutex::EXCLUSIVE);\n    mutex = nullptr;\n    ptr = nullptr;\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex->unlock",
          "args": [
            "isConst<T>() ? _::Mutex::SHARED : _::Mutex::EXCLUSIVE"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isConst<T>",
          "args": [],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "isConst",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "374-374",
          "snippet": "constexpr bool isConst() { return IsConst_<T>::value; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr bool isConst() { return IsConst_<T>::value; }"
        }
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nLocked {\n  inline void release() {\n      if (mutex != nullptr) mutex->unlock(isConst<T>() ? _::Mutex::SHARED : _::Mutex::EXCLUSIVE);\n      mutex = nullptr;\n      ptr = nullptr;\n    }\n}"
  },
  {
    "function_name": "Locked",
    "container": "Locked",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "167-170",
    "snippet": "inline Locked(Locked&& other): mutex(other.mutex), ptr(other.ptr) {\n    other.mutex = nullptr;\n    other.ptr = nullptr;\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nLocked {\n  inline Locked(Locked&& other): mutex(other.mutex), ptr(other.ptr) {\n      other.mutex = nullptr;\n      other.ptr = nullptr;\n    }\n}"
  },
  {
    "function_name": "Locked",
    "container": "Locked",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "166-166",
    "snippet": "inline Locked(): mutex(nullptr), ptr(nullptr) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nLocked {\n  inline Locked(): mutex(nullptr), ptr(nullptr) {}\n}"
  },
  {
    "function_name": "isInitialized",
    "container": "Once",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "115-122",
    "snippet": "inline bool isInitialized() noexcept {\n    // Fast path check to see if runOnce() would simply return immediately.\n#if KJ_USE_FUTEX\n    return __atomic_load_n(&futex, __ATOMIC_ACQUIRE) == INITIALIZED;\n#else\n    return __atomic_load_n(&state, __ATOMIC_ACQUIRE) == INITIALIZED;\n#endif\n  }",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [
      "#define KJ_USE_FUTEX 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__atomic_load_n",
          "args": [
            "&state",
            "__ATOMIC_ACQUIRE"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__atomic_load_n",
          "args": [
            "&futex",
            "__ATOMIC_ACQUIRE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\n#define KJ_USE_FUTEX 1\n\nOnce {\n  inline bool isInitialized() noexcept {\n      // Fast path check to see if runOnce() would simply return immediately.\n  #if KJ_USE_FUTEX\n      return __atomic_load_n(&futex, __ATOMIC_ACQUIRE) == INITIALIZED;\n  #else\n      return __atomic_load_n(&state, __ATOMIC_ACQUIRE) == INITIALIZED;\n  #endif\n    }\n}"
  },
  {
    "function_name": "Once",
    "container": "Once",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex.h",
    "lines": "96-97",
    "snippet": "inline Once(bool startInitialized = false)\n      : futex(startInitialized ? INITIALIZED : UNINITIALIZED) {}",
    "includes": [
      "#include <pthread.h>",
      "#include <inttypes.h>",
      "#include \"memory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <pthread.h>\n#include <inttypes.h>\n#include \"memory.h\"\n\nOnce {\n  inline Once(bool startInitialized = false)\n        : futex(startInitialized ? INITIALIZED : UNINITIALIZED) {}\n}"
  }
]