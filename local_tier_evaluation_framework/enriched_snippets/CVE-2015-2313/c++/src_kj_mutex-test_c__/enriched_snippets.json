[
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex-test.c++",
    "lines": "158-180",
    "snippet": "TEST(Mutex, LazyException) {\n  Lazy<uint> lazy;\n\n  auto exception = kj::runCatchingExceptions([&]() {\n    lazy.get([&](SpaceFor<uint>& space) -> Own<uint> {\n          KJ_FAIL_ASSERT(\"foo\") { break; }\n          return space.construct(123);\n        });\n  });\n  EXPECT_TRUE(exception != nullptr);\n\n  uint i = lazy.get([&](SpaceFor<uint>& space) -> Own<uint> {\n        return space.construct(456);\n      });\n\n  // Unfortunately, the results differ depending on whether exceptions are enabled.\n  // TODO(someday):  Fix this?  Does it matter?\n#if KJ_NO_EXCEPTIONS\n  EXPECT_EQ(123, i);\n#else\n  EXPECT_EQ(456, i);\n#endif\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456",
            "i"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123",
            "i"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lazy.get",
          "args": [
            "[&](SpaceFor<uint>& space) -> Own<uint> {\n        return space.construct(456);\n      }"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/tuple.h",
          "lines": "341-345",
          "snippet": "inline auto get(Tuple&& tuple) -> decltype(_::getImpl<index>(kj::fwd<Tuple>(tuple))) {\n  // Unpack and return the tuple element at the given index.  The index is specified as a template\n  // parameter, e.g. `kj::get<3>(myTuple)`.\n  return _::getImpl<index>(kj::fwd<Tuple>(tuple));\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\ninline auto get(Tuple&& tuple) -> decltype(_::getImpl<index>(kj::fwd<Tuple>(tuple))) {\n  // Unpack and return the tuple element at the given index.  The index is specified as a template\n  // parameter, e.g. `kj::get<3>(myTuple)`.\n  return _::getImpl<index>(kj::fwd<Tuple>(tuple));\n}"
        }
      },
      {
        "call_info": {
          "callee": "space.construct",
          "args": [
            "456"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "558-560",
          "snippet": "static void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nstatic void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_TRUE",
          "args": [
            "exception != nullptr"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n    lazy.get([&](SpaceFor<uint>& space) -> Own<uint> {\n          KJ_FAIL_ASSERT(\"foo\") { break; }\n          return space.construct(123);\n        });\n  }"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_ASSERT",
          "args": [
            "\"foo\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <pthread.h>\n#include <windows.h>\n#include <kj/compat/gtest.h>\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"mutex.h\"\n\nTEST(Mutex, LazyException) {\n  Lazy<uint> lazy;\n\n  auto exception = kj::runCatchingExceptions([&]() {\n    lazy.get([&](SpaceFor<uint>& space) -> Own<uint> {\n          KJ_FAIL_ASSERT(\"foo\") { break; }\n          return space.construct(123);\n        });\n  });\n  EXPECT_TRUE(exception != nullptr);\n\n  uint i = lazy.get([&](SpaceFor<uint>& space) -> Own<uint> {\n        return space.construct(456);\n      });\n\n  // Unfortunately, the results differ depending on whether exceptions are enabled.\n  // TODO(someday):  Fix this?  Does it matter?\n#if KJ_NO_EXCEPTIONS\n  EXPECT_EQ(123, i);\n#else\n  EXPECT_EQ(456, i);\n#endif\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex-test.c++",
    "lines": "133-156",
    "snippet": "TEST(Mutex, Lazy) {\n  Lazy<uint> lazy;\n  volatile bool initStarted = false;\n\n  Thread thread([&]() {\n    EXPECT_EQ(123u, lazy.get([&](SpaceFor<uint>& space) -> Own<uint> {\n      initStarted = true;\n      delay();\n      return space.construct(123);\n    }));\n  });\n\n  // Spin until the initializer has been entered in the thread.\n  while (!initStarted) {\n#if _WIN32\n    Sleep(0);\n#else\n    sched_yield();\n#endif\n  }\n\n  EXPECT_EQ(123u, lazy.get([](SpaceFor<uint>& space) { return space.construct(456); }));\n  EXPECT_EQ(123u, lazy.get([](SpaceFor<uint>& space) { return space.construct(789); }));\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123u",
            "lazy.get([](SpaceFor<uint>& space) { return space.construct(789); })"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lazy.get",
          "args": [
            "[](SpaceFor<uint>& space) { return space.construct(789); }"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/tuple.h",
          "lines": "341-345",
          "snippet": "inline auto get(Tuple&& tuple) -> decltype(_::getImpl<index>(kj::fwd<Tuple>(tuple))) {\n  // Unpack and return the tuple element at the given index.  The index is specified as a template\n  // parameter, e.g. `kj::get<3>(myTuple)`.\n  return _::getImpl<index>(kj::fwd<Tuple>(tuple));\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\ninline auto get(Tuple&& tuple) -> decltype(_::getImpl<index>(kj::fwd<Tuple>(tuple))) {\n  // Unpack and return the tuple element at the given index.  The index is specified as a template\n  // parameter, e.g. `kj::get<3>(myTuple)`.\n  return _::getImpl<index>(kj::fwd<Tuple>(tuple));\n}"
        }
      },
      {
        "call_info": {
          "callee": "space.construct",
          "args": [
            "789"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "construct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "558-560",
          "snippet": "static void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nstatic void construct(void* ptr) {\n    kj::ctor(*reinterpret_cast<T*>(ptr));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123u",
            "lazy.get([](SpaceFor<uint>& space) { return space.construct(456); })"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_yield",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sleep",
          "args": [
            "0"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123u",
            "lazy.get([&](SpaceFor<uint>& space) -> Own<uint> {\n      initStarted = true;\n      delay();\n      return space.construct(123);\n    })"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex-test.c++",
          "lines": "40-40",
          "snippet": "inline void delay() { usleep(10000); }",
          "includes": [
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <windows.h>",
            "#include <kj/compat/gtest.h>",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"mutex.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <pthread.h>\n#include <windows.h>\n#include <kj/compat/gtest.h>\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"mutex.h\"\n\ninline void delay() { usleep(10000); }"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <pthread.h>\n#include <windows.h>\n#include <kj/compat/gtest.h>\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"mutex.h\"\n\nTEST(Mutex, Lazy) {\n  Lazy<uint> lazy;\n  volatile bool initStarted = false;\n\n  Thread thread([&]() {\n    EXPECT_EQ(123u, lazy.get([&](SpaceFor<uint>& space) -> Own<uint> {\n      initStarted = true;\n      delay();\n      return space.construct(123);\n    }));\n  });\n\n  // Spin until the initializer has been entered in the thread.\n  while (!initStarted) {\n#if _WIN32\n    Sleep(0);\n#else\n    sched_yield();\n#endif\n  }\n\n  EXPECT_EQ(123u, lazy.get([](SpaceFor<uint>& space) { return space.construct(456); }));\n  EXPECT_EQ(123u, lazy.get([](SpaceFor<uint>& space) { return space.construct(789); }));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex-test.c++",
    "lines": "57-131",
    "snippet": "TEST(Mutex, MutexGuarded) {\n  MutexGuarded<uint> value(123);\n\n  {\n    Locked<uint> lock = value.lockExclusive();\n    EXPECT_EQ(123u, *lock);\n    EXPECT_EQ(123u, value.getAlreadyLockedExclusive());\n\n    Thread thread([&]() {\n      Locked<uint> threadLock = value.lockExclusive();\n      EXPECT_EQ(456u, *threadLock);\n      *threadLock = 789;\n    });\n\n    delay();\n    EXPECT_EQ(123u, *lock);\n    *lock = 456;\n    auto earlyRelease = kj::mv(lock);\n  }\n\n  EXPECT_EQ(789u, *value.lockExclusive());\n\n  {\n    auto rlock1 = value.lockShared();\n    EXPECT_EQ(789u, *rlock1);\n    EXPECT_EQ(789u, value.getAlreadyLockedShared());\n\n    {\n      auto rlock2 = value.lockShared();\n      EXPECT_EQ(789u, *rlock2);\n      auto rlock3 = value.lockShared();\n      EXPECT_EQ(789u, *rlock3);\n      auto rlock4 = value.lockShared();\n      EXPECT_EQ(789u, *rlock4);\n    }\n\n    Thread thread2([&]() {\n      Locked<uint> threadLock = value.lockExclusive();\n      *threadLock = 321;\n    });\n\n#if KJ_USE_FUTEX\n    // So, it turns out that pthread_rwlock on BSD \"prioritizes\" readers over writers.  The result\n    // is that if one thread tries to take multiple read locks, but another thread happens to\n    // request a write lock it between, you get a deadlock.  This seems to contradict the man pages\n    // and common sense, but this is how it is.  The futex-based implementation doesn't currently\n    // have this problem because it does not prioritize writers.  Perhaps it will in the future,\n    // but we'll leave this test here until then to make sure we notice the change.\n\n    delay();\n    EXPECT_EQ(789u, *rlock1);\n\n    {\n      auto rlock2 = value.lockShared();\n      EXPECT_EQ(789u, *rlock2);\n      auto rlock3 = value.lockShared();\n      EXPECT_EQ(789u, *rlock3);\n      auto rlock4 = value.lockShared();\n      EXPECT_EQ(789u, *rlock4);\n    }\n#endif\n\n    delay();\n    EXPECT_EQ(789u, *rlock1);\n    auto earlyRelease = kj::mv(rlock1);\n  }\n\n  EXPECT_EQ(321u, *value.lockExclusive());\n\n#if !_WIN32  // Not checked on win32.\n  EXPECT_DEBUG_ANY_THROW(value.getAlreadyLockedExclusive());\n  EXPECT_DEBUG_ANY_THROW(value.getAlreadyLockedShared());\n#endif\n  EXPECT_EQ(321u, value.getWithoutLock());\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [
      "#define EXPECT_DEBUG_ANY_THROW EXPECT_ANY_THROW"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "321u",
            "value.getWithoutLock()"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getWithoutLock",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_DEBUG_ANY_THROW",
          "args": [
            "value.getAlreadyLockedShared()"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getAlreadyLockedShared",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_DEBUG_ANY_THROW",
          "args": [
            "value.getAlreadyLockedExclusive()"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getAlreadyLockedExclusive",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "321u",
            "*value.lockExclusive()"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockExclusive",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "rlock1"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock1"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delay",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex-test.c++",
          "lines": "40-40",
          "snippet": "inline void delay() { usleep(10000); }",
          "includes": [
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <windows.h>",
            "#include <kj/compat/gtest.h>",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"mutex.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <pthread.h>\n#include <windows.h>\n#include <kj/compat/gtest.h>\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"mutex.h\"\n\ninline void delay() { usleep(10000); }"
        }
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock4"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockShared",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock3"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockShared",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock2"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockShared",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock1"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockExclusive",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock4"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockShared",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock3"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockShared",
          "args": [],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock2"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockShared",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "value.getAlreadyLockedShared()"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getAlreadyLockedShared",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*rlock1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockShared",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "789u",
            "*value.lockExclusive()"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockExclusive",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "lock"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123u",
            "*lock"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "456u",
            "*threadLock"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockExclusive",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123u",
            "value.getAlreadyLockedExclusive()"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.getAlreadyLockedExclusive",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXPECT_EQ",
          "args": [
            "123u",
            "*lock"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.lockExclusive",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <pthread.h>\n#include <windows.h>\n#include <kj/compat/gtest.h>\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"mutex.h\"\n\n#define EXPECT_DEBUG_ANY_THROW EXPECT_ANY_THROW\n\nTEST(Mutex, MutexGuarded) {\n  MutexGuarded<uint> value(123);\n\n  {\n    Locked<uint> lock = value.lockExclusive();\n    EXPECT_EQ(123u, *lock);\n    EXPECT_EQ(123u, value.getAlreadyLockedExclusive());\n\n    Thread thread([&]() {\n      Locked<uint> threadLock = value.lockExclusive();\n      EXPECT_EQ(456u, *threadLock);\n      *threadLock = 789;\n    });\n\n    delay();\n    EXPECT_EQ(123u, *lock);\n    *lock = 456;\n    auto earlyRelease = kj::mv(lock);\n  }\n\n  EXPECT_EQ(789u, *value.lockExclusive());\n\n  {\n    auto rlock1 = value.lockShared();\n    EXPECT_EQ(789u, *rlock1);\n    EXPECT_EQ(789u, value.getAlreadyLockedShared());\n\n    {\n      auto rlock2 = value.lockShared();\n      EXPECT_EQ(789u, *rlock2);\n      auto rlock3 = value.lockShared();\n      EXPECT_EQ(789u, *rlock3);\n      auto rlock4 = value.lockShared();\n      EXPECT_EQ(789u, *rlock4);\n    }\n\n    Thread thread2([&]() {\n      Locked<uint> threadLock = value.lockExclusive();\n      *threadLock = 321;\n    });\n\n#if KJ_USE_FUTEX\n    // So, it turns out that pthread_rwlock on BSD \"prioritizes\" readers over writers.  The result\n    // is that if one thread tries to take multiple read locks, but another thread happens to\n    // request a write lock it between, you get a deadlock.  This seems to contradict the man pages\n    // and common sense, but this is how it is.  The futex-based implementation doesn't currently\n    // have this problem because it does not prioritize writers.  Perhaps it will in the future,\n    // but we'll leave this test here until then to make sure we notice the change.\n\n    delay();\n    EXPECT_EQ(789u, *rlock1);\n\n    {\n      auto rlock2 = value.lockShared();\n      EXPECT_EQ(789u, *rlock2);\n      auto rlock3 = value.lockShared();\n      EXPECT_EQ(789u, *rlock3);\n      auto rlock4 = value.lockShared();\n      EXPECT_EQ(789u, *rlock4);\n    }\n#endif\n\n    delay();\n    EXPECT_EQ(789u, *rlock1);\n    auto earlyRelease = kj::mv(rlock1);\n  }\n\n  EXPECT_EQ(321u, *value.lockExclusive());\n\n#if !_WIN32  // Not checked on win32.\n  EXPECT_DEBUG_ANY_THROW(value.getAlreadyLockedExclusive());\n  EXPECT_DEBUG_ANY_THROW(value.getAlreadyLockedShared());\n#endif\n  EXPECT_EQ(321u, value.getWithoutLock());\n}"
  },
  {
    "function_name": "delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex-test.c++",
    "lines": "40-40",
    "snippet": "inline void delay() { usleep(10000); }",
    "includes": [
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10000"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <pthread.h>\n#include <windows.h>\n#include <kj/compat/gtest.h>\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"mutex.h\"\n\ninline void delay() { usleep(10000); }"
  },
  {
    "function_name": "delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/mutex-test.c++",
    "lines": "38-38",
    "snippet": "inline void delay() { Sleep(10); }",
    "includes": [
      "#include <unistd.h>",
      "#include <pthread.h>",
      "#include <windows.h>",
      "#include <kj/compat/gtest.h>",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"mutex.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Sleep",
          "args": [
            "10"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <pthread.h>\n#include <windows.h>\n#include <kj/compat/gtest.h>\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"mutex.h\"\n\ninline void delay() { Sleep(10); }"
  }
]