[
  {
    "function_name": "Disposer::dispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "386-388",
    "snippet": "void Disposer::dispose(T* object) const {\n  Dispose_<T>::dispose(object, *this);\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Dispose_<T>::dispose",
          "args": [
            "object",
            "*this"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "dispose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "380-382",
          "snippet": "static void dispose(T* object, const Disposer& disposer) {\n    disposer.disposeImpl(static_cast<void*>(object));\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic void dispose(T* object, const Disposer& disposer) {\n    disposer.disposeImpl(static_cast<void*>(object));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nvoid Disposer::dispose(T* object) const {\n  Dispose_<T>::dispose(object, *this);\n}"
  },
  {
    "function_name": "dispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "380-382",
    "snippet": "static void dispose(T* object, const Disposer& disposer) {\n    disposer.disposeImpl(static_cast<void*>(object));\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disposer.disposeImpl",
          "args": [
            "static_cast<void*>(object)"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "disposeImpl",
          "container": "HeapDisposer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "310-310",
          "snippet": "virtual void disposeImpl(void* pointer) const override { delete reinterpret_cast<T*>(pointer); }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nHeapDisposer {\n  virtual void disposeImpl(void* pointer) const override { delete reinterpret_cast<T*>(pointer); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<void*>",
          "args": [
            "object"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic void dispose(T* object, const Disposer& disposer) {\n    disposer.disposeImpl(static_cast<void*>(object));\n  }"
  },
  {
    "function_name": "dispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "371-376",
    "snippet": "static void dispose(T* object, const Disposer& disposer) {\n    // Note that dynamic_cast<void*> does not require RTTI to be enabled, because the offset to\n    // the top of the object is in the vtable -- as it obviously needs to be to correctly implement\n    // operator delete.\n    disposer.disposeImpl(dynamic_cast<void*>(object));\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disposer.disposeImpl",
          "args": [
            "dynamic_cast<void*>(object)"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "disposeImpl",
          "container": "HeapDisposer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "310-310",
          "snippet": "virtual void disposeImpl(void* pointer) const override { delete reinterpret_cast<T*>(pointer); }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nHeapDisposer {\n  virtual void disposeImpl(void* pointer) const override { delete reinterpret_cast<T*>(pointer); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dynamic_cast<void*>",
          "args": [
            "object"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic void dispose(T* object, const Disposer& disposer) {\n    // Note that dynamic_cast<void*> does not require RTTI to be enabled, because the offset to\n    // the top of the object is in the vtable -- as it obviously needs to be to correctly implement\n    // operator delete.\n    disposer.disposeImpl(dynamic_cast<void*>(object));\n  }"
  },
  {
    "function_name": "construct",
    "container": "SpaceFor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "355-358",
    "snippet": "Own<T> construct(Params&&... params) {\n    ctor(value, kj::fwd<Params>(params)...);\n    return Own<T>(&value, DestructorOnlyDisposer<T>::instance);\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Own<T>",
          "args": [
            "&value",
            "DestructorOnlyDisposer<T>::instance"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "Own",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "128-128",
          "snippet": "inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ctor",
          "args": [
            "value",
            "kj::fwd<Params>(params)..."
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "addAll",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "81-85",
          "snippet": "inline void addAll(Iterator begin, Iterator end) {\n    size_t needed = builder.size() + (end - begin);\n    if (needed > builder.capacity()) grow(needed);\n    builder.addAll(begin, end);\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void addAll(Iterator begin, Iterator end) {\n      size_t needed = builder.size() + (end - begin);\n      if (needed > builder.capacity()) grow(needed);\n      builder.addAll(begin, end);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nSpaceFor {\n  Own<T> construct(Params&&... params) {\n      ctor(value, kj::fwd<Params>(params)...);\n      return Own<T>(&value, DestructorOnlyDisposer<T>::instance);\n    }\n}"
  },
  {
    "function_name": "SpaceFor",
    "container": "SpaceFor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "351-351",
    "snippet": "inline SpaceFor() {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nSpaceFor {\n  inline SpaceFor() {}\n}"
  },
  {
    "function_name": "heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "331-339",
    "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Own<T2>",
          "args": [
            "new T2(kj::fwd<T>(orig))",
            "_::HeapDisposer<T2>::instance"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "Own",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "128-128",
          "snippet": "inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<T>",
          "args": [
            "orig"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
  },
  {
    "function_name": "heap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "321-328",
    "snippet": "Own<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Own<T>",
          "args": [
            "new T(kj::fwd<Params>(params)...)",
            "_::HeapDisposer<T>::instance"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "Own",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "128-128",
          "snippet": "inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::fwd<Params>",
          "args": [
            "params"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nOwn<T> heap(Params&&... params) {\n  // heap<T>(...) allocates a T on the heap, forwarding the parameters to its constructor.  The\n  // exact heap implementation is unspecified -- for now it is operator new, but you should not\n  // assume this.  (Since we know the object size at delete time, we could actually implement an\n  // allocator that is more efficient than operator new.)\n\n  return Own<T>(new T(kj::fwd<Params>(params)...), _::HeapDisposer<T>::instance);\n}"
  },
  {
    "function_name": "disposeImpl",
    "container": "HeapDisposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "310-310",
    "snippet": "virtual void disposeImpl(void* pointer) const override { delete reinterpret_cast<T*>(pointer); }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<T*>",
          "args": [
            "pointer"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nHeapDisposer {\n  virtual void disposeImpl(void* pointer) const override { delete reinterpret_cast<T*>(pointer); }\n}"
  },
  {
    "function_name": "map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "281-287",
    "snippet": "auto map(Func&& f) const -> Maybe<decltype(f(instance<const Own<T>&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(ptr);\n    }\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f",
          "args": [
            "ptr"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "Deferred",
          "container": "Deferred",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1261-1263",
          "snippet": "inline Deferred(Deferred&& other): func(kj::mv(other.func)), canceled(false) {\n    other.canceled = true;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nDeferred {\n  inline Deferred(Deferred&& other): func(kj::mv(other.func)), canceled(false) {\n      other.canceled = true;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance<const Own<T>&>",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nauto map(Func&& f) const -> Maybe<decltype(f(instance<const Own<T>&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(ptr);\n    }\n  }"
  },
  {
    "function_name": "map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "272-278",
    "snippet": "auto map(Func&& f) -> Maybe<decltype(f(instance<Own<T>&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(ptr);\n    }\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f",
          "args": [
            "ptr"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "Deferred",
          "container": "Deferred",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1261-1263",
          "snippet": "inline Deferred(Deferred&& other): func(kj::mv(other.func)), canceled(false) {\n    other.canceled = true;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nDeferred {\n  inline Deferred(Deferred&& other): func(kj::mv(other.func)), canceled(false) {\n      other.canceled = true;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "instance<Own<T>&>",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nauto map(Func&& f) -> Maybe<decltype(f(instance<Own<T>&>()))> {\n    if (ptr == nullptr) {\n      return nullptr;\n    } else {\n      return f(ptr);\n    }\n  }"
  },
  {
    "function_name": "Maybe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "246-246",
    "snippet": "inline Maybe(decltype(nullptr)) noexcept: ptr(nullptr) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\ninline Maybe(decltype(nullptr)) noexcept: ptr(nullptr) {}"
  },
  {
    "function_name": "Maybe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "244-244",
    "snippet": "inline Maybe(Maybe<Own<U>>&& other): ptr(mv(other.ptr)) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mv",
          "args": [
            "other.ptr"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\ninline Maybe(Maybe<Own<U>>&& other): ptr(mv(other.ptr)) {}"
  },
  {
    "function_name": "Maybe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "241-241",
    "snippet": "inline Maybe(Maybe&& other) noexcept: ptr(kj::mv(other.ptr)) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "other.ptr"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\ninline Maybe(Maybe&& other) noexcept: ptr(kj::mv(other.ptr)) {}"
  },
  {
    "function_name": "Maybe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "240-240",
    "snippet": "inline Maybe(Own<T>&& t) noexcept: ptr(kj::mv(t)) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "t"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\ninline Maybe(Own<T>&& t) noexcept: ptr(kj::mv(t)) {}"
  },
  {
    "function_name": "Maybe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "239-239",
    "snippet": "inline Maybe(): ptr(nullptr) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\ninline Maybe(): ptr(nullptr) {}"
  },
  {
    "function_name": "readMaybe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "228-228",
    "snippet": "OwnOwn<T> readMaybe(Maybe<Own<T>>&& maybe) { return OwnOwn<T>(kj::mv(maybe.ptr)); }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OwnOwn<T>",
          "args": [
            "kj::mv(maybe.ptr)"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "OwnOwn",
          "container": "OwnOwn",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "207-207",
          "snippet": "inline OwnOwn(Own<T>&& value) noexcept: value(kj::mv(value)) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwnOwn {\n  inline OwnOwn(Own<T>&& value) noexcept: value(kj::mv(value)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "maybe.ptr"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nOwnOwn<T> readMaybe(Maybe<Own<T>>&& maybe) { return OwnOwn<T>(kj::mv(maybe.ptr)); }"
  },
  {
    "function_name": "OwnOwn",
    "container": "OwnOwn",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "207-207",
    "snippet": "inline OwnOwn(Own<T>&& value) noexcept: value(kj::mv(value)) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "value"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nOwnOwn {\n  inline OwnOwn(Own<T>&& value) noexcept: value(kj::mv(value)) {}\n}"
  },
  {
    "function_name": "dispose",
    "container": "Own",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "187-195",
    "snippet": "inline void dispose() {\n    // Make sure that if an exception is thrown, we are left with a null ptr, so we won't possibly\n    // dispose again.\n    T* ptrCopy = ptr;\n    if (ptrCopy != nullptr) {\n      ptr = nullptr;\n      disposer->dispose(const_cast<RemoveConst<T>*>(ptrCopy));\n    }\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disposer->dispose",
          "args": [
            "const_cast<RemoveConst<T>*>(ptrCopy)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<RemoveConst<T>*>",
          "args": [
            "ptrCopy"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline void dispose() {\n      // Make sure that if an exception is thrown, we are left with a null ptr, so we won't possibly\n      // dispose again.\n      T* ptrCopy = ptr;\n      if (ptrCopy != nullptr) {\n        ptr = nullptr;\n        disposer->dispose(const_cast<RemoveConst<T>*>(ptrCopy));\n      }\n    }\n}"
  },
  {
    "function_name": "Own",
    "container": "Own",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "181-181",
    "snippet": "inline explicit Own(decltype(nullptr)): disposer(nullptr), ptr(nullptr) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline explicit Own(decltype(nullptr)): disposer(nullptr), ptr(nullptr) {}\n}"
  },
  {
    "function_name": "downcast",
    "container": "Own",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "154-166",
    "snippet": "Own<U> downcast() {\n    // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n    // actually point at an instance of U, the results are undefined (throws an exception in debug\n    // mode if RTTI is enabled, otherwise you're on your own).\n\n    Own<U> result;\n    if (ptr != nullptr) {\n      result.ptr = &kj::downcast<U>(*ptr);\n      result.disposer = disposer;\n      ptr = nullptr;\n    }\n    return result;\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::downcast<U>",
          "args": [
            "*ptr"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  Own<U> downcast() {\n      // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n      // actually point at an instance of U, the results are undefined (throws an exception in debug\n      // mode if RTTI is enabled, otherwise you're on your own).\n  \n      Own<U> result;\n      if (ptr != nullptr) {\n        result.ptr = &kj::downcast<U>(*ptr);\n        result.disposer = disposer;\n        ptr = nullptr;\n      }\n      return result;\n    }\n}"
  },
  {
    "function_name": "Own",
    "container": "Own",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "128-128",
    "snippet": "inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(T* ptr, const Disposer& disposer) noexcept: disposer(&disposer), ptr(ptr) {}\n}"
  },
  {
    "function_name": "Own",
    "container": "Own",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "122-127",
    "snippet": "inline Own(Own<U>&& other) noexcept\n      : disposer(other.disposer), ptr(other.ptr) {\n    static_assert(__is_polymorphic(T),\n        \"Casting owned pointers requires that the target type is polymorphic.\");\n    other.ptr = nullptr;\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__is_polymorphic",
          "args": [
            "T"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(Own<U>&& other) noexcept\n        : disposer(other.disposer), ptr(other.ptr) {\n      static_assert(__is_polymorphic(T),\n          \"Casting owned pointers requires that the target type is polymorphic.\");\n      other.ptr = nullptr;\n    }\n}"
  },
  {
    "function_name": "Own",
    "container": "Own",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "119-120",
    "snippet": "inline Own(Own<RemoveConstOrDisable<T>>&& other) noexcept\n      : disposer(other.disposer), ptr(other.ptr) { other.ptr = nullptr; }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(Own<RemoveConstOrDisable<T>>&& other) noexcept\n        : disposer(other.disposer), ptr(other.ptr) { other.ptr = nullptr; }\n}"
  },
  {
    "function_name": "Own",
    "container": "Own",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "117-118",
    "snippet": "inline Own(Own&& other) noexcept\n      : disposer(other.disposer), ptr(other.ptr) { other.ptr = nullptr; }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(Own&& other) noexcept\n        : disposer(other.disposer), ptr(other.ptr) { other.ptr = nullptr; }\n}"
  },
  {
    "function_name": "Own",
    "container": "Own",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "116-116",
    "snippet": "inline Own(): disposer(nullptr), ptr(nullptr) {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  inline Own(): disposer(nullptr), ptr(nullptr) {}\n}"
  },
  {
    "function_name": "disposeImpl",
    "container": "NullDisposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "92-92",
    "snippet": "void disposeImpl(void* pointer) const override {}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nNullDisposer {\n  void disposeImpl(void* pointer) const override {}\n}"
  },
  {
    "function_name": "disposeImpl",
    "container": "DestructorOnlyDisposer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
    "lines": "78-80",
    "snippet": "void disposeImpl(void* pointer) const override {\n    reinterpret_cast<T*>(pointer)->~T();\n  }",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<T*>",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<T*>",
          "args": [
            "pointer"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nDestructorOnlyDisposer {\n  void disposeImpl(void* pointer) const override {\n      reinterpret_cast<T*>(pointer)->~T();\n    }\n}"
  }
]