[
  {
    "function_name": "Arena::setDestructor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
    "lines": "159-165",
    "snippet": "void Arena::setDestructor(void* ptr, void (*destructor)(void*)) {\n  ObjectHeader* header = reinterpret_cast<ObjectHeader*>(ptr) - 1;\n  KJ_DASSERT(reinterpret_cast<uintptr_t>(header) % alignof(ObjectHeader) == 0);\n  header->destructor = destructor;\n  header->next = objectList;\n  objectList = header;\n}",
    "includes": [
      "#include <stdint.h>",
      "#include \"debug.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "reinterpret_cast<uintptr_t>(header) % alignof(ObjectHeader) == 0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<uintptr_t>",
          "args": [
            "header"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<ObjectHeader*>",
          "args": [
            "ptr"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\nvoid Arena::setDestructor(void* ptr, void (*destructor)(void*)) {\n  ObjectHeader* header = reinterpret_cast<ObjectHeader*>(ptr) - 1;\n  KJ_DASSERT(reinterpret_cast<uintptr_t>(header) % alignof(ObjectHeader) == 0);\n  header->destructor = destructor;\n  header->next = objectList;\n  objectList = header;\n}"
  },
  {
    "function_name": "Arena::copyString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
    "lines": "153-157",
    "snippet": "StringPtr Arena::copyString(StringPtr content) {\n  char* data = reinterpret_cast<char*>(allocateBytes(content.size() + 1, 1, false));\n  memcpy(data, content.cStr(), content.size() + 1);\n  return StringPtr(data, content.size());\n}",
    "includes": [
      "#include <stdint.h>",
      "#include \"debug.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringPtr",
          "args": [
            "data",
            "content.size()"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "StringPtr",
          "container": "StringPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "61-61",
          "snippet": "inline StringPtr(const char* begin, const char* end): StringPtr(begin, end - begin) {}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nStringPtr {\n  inline StringPtr(const char* begin, const char* end): StringPtr(begin, end - begin) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "content.size",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "content.cStr()",
            "content.size() + 1"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "content.cStr",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<char*>",
          "args": [
            "allocateBytes(content.size() + 1, 1, false)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocateBytes",
          "args": [
            "content.size() + 1",
            "1",
            "false"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\nStringPtr Arena::copyString(StringPtr content) {\n  char* data = reinterpret_cast<char*>(allocateBytes(content.size() + 1, 1, false));\n  memcpy(data, content.cStr(), content.size() + 1);\n  return StringPtr(data, content.size());\n}"
  },
  {
    "function_name": "alignTo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
    "lines": "82-88",
    "snippet": "inline size_t alignTo(size_t s, uint alignment) {\n  // Round the pointer up to the next aligned value.\n\n  KJ_DASSERT(isPowerOfTwo(alignment), alignment);\n  size_t mask = alignment - 1;\n  return (s + mask) & ~mask;\n}",
    "includes": [
      "#include <stdint.h>",
      "#include \"debug.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "isPowerOfTwo(alignment)",
            "alignment"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isPowerOfTwo",
          "args": [
            "alignment"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "isPowerOfTwo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
          "lines": "69-71",
          "snippet": "constexpr bool isPowerOfTwo(size_t value) {\n  return (value & (value - 1)) == 0;\n}",
          "includes": [
            "#include <stdint.h>",
            "#include \"debug.h\"",
            "#include \"arena.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\nconstexpr bool isPowerOfTwo(size_t value) {\n  return (value & (value - 1)) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\ninline size_t alignTo(size_t s, uint alignment) {\n  // Round the pointer up to the next aligned value.\n\n  KJ_DASSERT(isPowerOfTwo(alignment), alignment);\n  size_t mask = alignment - 1;\n  return (s + mask) & ~mask;\n}"
  },
  {
    "function_name": "isPowerOfTwo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
    "lines": "69-71",
    "snippet": "constexpr bool isPowerOfTwo(size_t value) {\n  return (value & (value - 1)) == 0;\n}",
    "includes": [
      "#include <stdint.h>",
      "#include \"debug.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\nconstexpr bool isPowerOfTwo(size_t value) {\n  return (value & (value - 1)) == 0;\n}"
  },
  {
    "function_name": "Arena::cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
    "lines": "52-65",
    "snippet": "void Arena::cleanup() {\n  while (objectList != nullptr) {\n    void* ptr = objectList + 1;\n    auto destructor = objectList->destructor;\n    objectList = objectList->next;\n    destructor(ptr);\n  }\n\n  while (chunkList != nullptr) {\n    void* ptr = chunkList;\n    chunkList = chunkList->next;\n    operator delete(ptr);\n  }\n}",
    "includes": [
      "#include <stdint.h>",
      "#include \"debug.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destructor",
          "args": [
            "ptr"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\nvoid Arena::cleanup() {\n  while (objectList != nullptr) {\n    void* ptr = objectList + 1;\n    auto destructor = objectList->destructor;\n    objectList = objectList->next;\n    destructor(ptr);\n  }\n\n  while (chunkList != nullptr) {\n    void* ptr = chunkList;\n    chunkList = chunkList->next;\n    operator delete(ptr);\n  }\n}"
  },
  {
    "function_name": "Arena::~Arena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
    "lines": "44-50",
    "snippet": "Arena::~Arena() noexcept(false) {\n  // Run cleanup() explicitly, but if it throws an exception, make sure to run it again as part of\n  // unwind.  The second call will not throw because destructors are required to guard against\n  // exceptions when already unwinding.\n  KJ_ON_SCOPE_FAILURE(cleanup());\n  cleanup();\n}",
    "includes": [
      "#include <stdint.h>",
      "#include \"debug.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ON_SCOPE_FAILURE",
          "args": [
            "cleanup()"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\nArena::~Arena() noexcept(false) {\n  // Run cleanup() explicitly, but if it throws an exception, make sure to run it again as part of\n  // unwind.  The second call will not throw because destructors are required to guard against\n  // exceptions when already unwinding.\n  KJ_ON_SCOPE_FAILURE(cleanup());\n  cleanup();\n}"
  },
  {
    "function_name": "Arena::Arena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
    "lines": "30-42",
    "snippet": "Arena::Arena(ArrayPtr<byte> scratch)\n    : nextChunkSize(kj::max(sizeof(ChunkHeader), scratch.size())) {\n  if (scratch.size() > sizeof(ChunkHeader)) {\n    ChunkHeader* chunk = reinterpret_cast<ChunkHeader*>(scratch.begin());\n    chunk->end = scratch.end();\n    chunk->pos = reinterpret_cast<byte*>(chunk + 1);\n    chunk->next = nullptr;  // Never actually observed.\n\n    // Don't place the chunk in the chunk list because it's not ours to delete.  Just make it the\n    // current chunk so that we'll allocate from it until it is empty.\n    currentChunk = chunk;\n  }\n}",
    "includes": [
      "#include <stdint.h>",
      "#include \"debug.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "chunk + 1"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scratch.end",
          "args": [],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<ChunkHeader*>",
          "args": [
            "scratch.begin()"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scratch.begin",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scratch.size",
          "args": [],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "sizeof(ChunkHeader)",
            "scratch.size()"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\nArena::Arena(ArrayPtr<byte> scratch)\n    : nextChunkSize(kj::max(sizeof(ChunkHeader), scratch.size())) {\n  if (scratch.size() > sizeof(ChunkHeader)) {\n    ChunkHeader* chunk = reinterpret_cast<ChunkHeader*>(scratch.begin());\n    chunk->end = scratch.end();\n    chunk->pos = reinterpret_cast<byte*>(chunk + 1);\n    chunk->next = nullptr;  // Never actually observed.\n\n    // Don't place the chunk in the chunk list because it's not ours to delete.  Just make it the\n    // current chunk so that we'll allocate from it until it is empty.\n    currentChunk = chunk;\n  }\n}"
  },
  {
    "function_name": "Arena::Arena",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/arena.c++",
    "lines": "28-28",
    "snippet": "Arena::Arena(size_t chunkSizeHint): nextChunkSize(kj::max(sizeof(ChunkHeader), chunkSizeHint)) {}",
    "includes": [
      "#include <stdint.h>",
      "#include \"debug.h\"",
      "#include \"arena.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::max",
          "args": [
            "sizeof(ChunkHeader)",
            "chunkSizeHint"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "486-488",
          "snippet": "auto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto max(T&& a, U&& b) -> MaxType<Decay<T>, Decay<U>> {\n  return a > b ? MaxType<Decay<T>, Decay<U>>(a) : MaxType<Decay<T>, Decay<U>>(b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdint.h>\n#include \"debug.h\"\n#include \"arena.h\"\n\nArena::Arena(size_t chunkSizeHint): nextChunkSize(kj::max(sizeof(ChunkHeader), chunkSizeHint)) {}"
  }
]