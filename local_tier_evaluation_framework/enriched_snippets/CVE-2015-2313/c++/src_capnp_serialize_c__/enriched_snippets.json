[
  {
    "function_name": "readMessageCopyFromFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "290-294",
    "snippet": "void readMessageCopyFromFd(int fd, MessageBuilder& target,\n                           ReaderOptions options, kj::ArrayPtr<word> scratchSpace) {\n  kj::FdInputStream stream(fd);\n  readMessageCopy(stream, target, options, scratchSpace);\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "readMessageCopy",
          "args": [
            "stream",
            "target",
            "options",
            "scratchSpace"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nvoid readMessageCopyFromFd(int fd, MessageBuilder& target,\n                           ReaderOptions options, kj::ArrayPtr<word> scratchSpace) {\n  kj::FdInputStream stream(fd);\n  readMessageCopy(stream, target, options, scratchSpace);\n}"
  },
  {
    "function_name": "writeMessageToFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "285-288",
    "snippet": "void writeMessageToFd(int fd, kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  kj::FdOutputStream stream(fd);\n  writeMessage(stream, segments);\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeMessage",
          "args": [
            "stream",
            "segments"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "writeMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
          "lines": "254-279",
          "snippet": "void writeMessage(kj::OutputStream& output, kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  KJ_STACK_ARRAY(_::WireValue<uint32_t>, table, (segments.size() + 2) & ~size_t(1), 16, 64);\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  table[0].set(segments.size() - 1);\n  for (uint i = 0; i < segments.size(); i++) {\n    table[i + 1].set(segments[i].size());\n  }\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    table[segments.size() + 1].set(0);\n  }\n\n  KJ_STACK_ARRAY(kj::ArrayPtr<const byte>, pieces, segments.size() + 1, 4, 32);\n  pieces[0] = table.asBytes();\n\n  for (uint i = 0; i < segments.size(); i++) {\n    pieces[i + 1] = segments[i].asBytes();\n  }\n\n  output.write(pieces);\n}",
          "includes": [
            "#include <exception>",
            "#include <kj/debug.h>",
            "#include \"layout.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nvoid writeMessage(kj::OutputStream& output, kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  KJ_STACK_ARRAY(_::WireValue<uint32_t>, table, (segments.size() + 2) & ~size_t(1), 16, 64);\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  table[0].set(segments.size() - 1);\n  for (uint i = 0; i < segments.size(); i++) {\n    table[i + 1].set(segments[i].size());\n  }\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    table[segments.size() + 1].set(0);\n  }\n\n  KJ_STACK_ARRAY(kj::ArrayPtr<const byte>, pieces, segments.size() + 1, 4, 32);\n  pieces[0] = table.asBytes();\n\n  for (uint i = 0; i < segments.size(); i++) {\n    pieces[i + 1] = segments[i].asBytes();\n  }\n\n  output.write(pieces);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nvoid writeMessageToFd(int fd, kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  kj::FdOutputStream stream(fd);\n  writeMessage(stream, segments);\n}"
  },
  {
    "function_name": "StreamFdMessageReader::~StreamFdMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "283-283",
    "snippet": "StreamFdMessageReader::~StreamFdMessageReader() noexcept(false) {}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nStreamFdMessageReader::~StreamFdMessageReader() noexcept(false) {}"
  },
  {
    "function_name": "writeMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "254-279",
    "snippet": "void writeMessage(kj::OutputStream& output, kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  KJ_STACK_ARRAY(_::WireValue<uint32_t>, table, (segments.size() + 2) & ~size_t(1), 16, 64);\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  table[0].set(segments.size() - 1);\n  for (uint i = 0; i < segments.size(); i++) {\n    table[i + 1].set(segments[i].size());\n  }\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    table[segments.size() + 1].set(0);\n  }\n\n  KJ_STACK_ARRAY(kj::ArrayPtr<const byte>, pieces, segments.size() + 1, 4, 32);\n  pieces[0] = table.asBytes();\n\n  for (uint i = 0; i < segments.size(); i++) {\n    pieces[i + 1] = segments[i].asBytes();\n  }\n\n  output.write(pieces);\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "output.write",
          "args": [
            "pieces"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "CountingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/capnproto-common.h",
          "lines": "53-58",
          "snippet": "void write(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) override {\n    FdOutputStream::write(pieces);\n    for (auto& piece: pieces) {\n      throughput += piece.size();\n    }\n  }",
          "includes": [
            "#include <thread>",
            "#include <capnp/serialize-snappy.h>",
            "#include <kj/debug.h>",
            "#include <capnp/serialize-packed.h>",
            "#include <capnp/serialize.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <thread>\n#include <capnp/serialize-snappy.h>\n#include <kj/debug.h>\n#include <capnp/serialize-packed.h>\n#include <capnp/serialize.h>\n#include \"common.h\"\n\nCountingOutputStream {\n  void write(kj::ArrayPtr<const kj::ArrayPtr<const byte>> pieces) override {\n      FdOutputStream::write(pieces);\n      for (auto& piece: pieces) {\n        throughput += piece.size();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "segments[i].asBytes",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "asBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "128-128",
          "snippet": "inline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }"
        }
      },
      {
        "call_info": {
          "callee": "segments.size",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_STACK_ARRAY",
          "args": [
            "kj::ArrayPtr<const byte>",
            "pieces",
            "segments.size() + 1",
            "4",
            "32"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "table[segments.size",
          "args": [
            "0"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      },
      {
        "call_info": {
          "callee": "table[i + 1].set",
          "args": [
            "segments[i].size()"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_STACK_ARRAY",
          "args": [
            "_::WireValue<uint32_t>",
            "table",
            "(segments.size() + 2) & ~size_t(1)",
            "16",
            "64"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "1"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "segments.size() > 0",
            "\"Tried to serialize uninitialized message.\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nvoid writeMessage(kj::OutputStream& output, kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  KJ_STACK_ARRAY(_::WireValue<uint32_t>, table, (segments.size() + 2) & ~size_t(1), 16, 64);\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  table[0].set(segments.size() - 1);\n  for (uint i = 0; i < segments.size(); i++) {\n    table[i + 1].set(segments[i].size());\n  }\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    table[segments.size() + 1].set(0);\n  }\n\n  KJ_STACK_ARRAY(kj::ArrayPtr<const byte>, pieces, segments.size() + 1, 4, 32);\n  pieces[0] = table.asBytes();\n\n  for (uint i = 0; i < segments.size(); i++) {\n    pieces[i + 1] = segments[i].asBytes();\n  }\n\n  output.write(pieces);\n}"
  },
  {
    "function_name": "readMessageCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "246-250",
    "snippet": "void readMessageCopy(kj::InputStream& input, MessageBuilder& target,\n                     ReaderOptions options, kj::ArrayPtr<word> scratchSpace) {\n  InputStreamMessageReader message(input, options, scratchSpace);\n  target.setRoot(message.getRoot<AnyPointer>());\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "target.setRoot",
          "args": [
            "message.getRoot<AnyPointer>()"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message.getRoot<AnyPointer>",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nvoid readMessageCopy(kj::InputStream& input, MessageBuilder& target,\n                     ReaderOptions options, kj::ArrayPtr<word> scratchSpace) {\n  InputStreamMessageReader message(input, options, scratchSpace);\n  target.setRoot(message.getRoot<AnyPointer>());\n}"
  },
  {
    "function_name": "InputStreamMessageReader::getSegment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "225-244",
    "snippet": "kj::ArrayPtr<const word> InputStreamMessageReader::getSegment(uint id) {\n  if (id > moreSegments.size()) {\n    return nullptr;\n  }\n\n  kj::ArrayPtr<const word> segment = id == 0 ? segment0 : moreSegments[id - 1];\n\n  if (readPos != nullptr) {\n    // May need to lazily read more data.\n    const byte* segmentEnd = reinterpret_cast<const byte*>(segment.end());\n    if (readPos < segmentEnd) {\n      // Note that lazy reads only happen when we have multiple segments, so moreSegments.back() is\n      // valid.\n      const byte* allEnd = reinterpret_cast<const byte*>(moreSegments.back().end());\n      readPos += inputStream.read(readPos, segmentEnd - readPos, allEnd - readPos);\n    }\n  }\n\n  return segment;\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inputStream.read",
          "args": [
            "readPos",
            "segmentEnd - readPos",
            "allEnd - readPos"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "Uncompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "101-113",
          "snippet": "static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                   google::protobuf::MessageLite* message) {\n    google::protobuf::io::CodedInputStream input(rawInput);\n    uint32_t size;\n    GOOGLE_CHECK(input.ReadVarint32(&size));\n\n    auto limit = input.PushLimit(size);\n\n    GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                 input.ConsumedEntireMessage());\n\n    input.PopLimit(limit);\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nUncompressed {\n  static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                     google::protobuf::MessageLite* message) {\n      google::protobuf::io::CodedInputStream input(rawInput);\n      uint32_t size;\n      GOOGLE_CHECK(input.ReadVarint32(&size));\n  \n      auto limit = input.PushLimit(size);\n  \n      GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                   input.ConsumedEntireMessage());\n  \n      input.PopLimit(limit);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "moreSegments.back().end()"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "moreSegments.back",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "moreSegments.back",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "segment.end()"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment.end",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "moreSegments.size",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nkj::ArrayPtr<const word> InputStreamMessageReader::getSegment(uint id) {\n  if (id > moreSegments.size()) {\n    return nullptr;\n  }\n\n  kj::ArrayPtr<const word> segment = id == 0 ? segment0 : moreSegments[id - 1];\n\n  if (readPos != nullptr) {\n    // May need to lazily read more data.\n    const byte* segmentEnd = reinterpret_cast<const byte*>(segment.end());\n    if (readPos < segmentEnd) {\n      // Note that lazy reads only happen when we have multiple segments, so moreSegments.back() is\n      // valid.\n      const byte* allEnd = reinterpret_cast<const byte*>(moreSegments.back().end());\n      readPos += inputStream.read(readPos, segmentEnd - readPos, allEnd - readPos);\n    }\n  }\n\n  return segment;\n}"
  },
  {
    "function_name": "InputStreamMessageReader::~InputStreamMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "214-223",
    "snippet": "InputStreamMessageReader::~InputStreamMessageReader() noexcept(false) {\n  if (readPos != nullptr) {\n    unwindDetector.catchExceptionsIfUnwinding([&]() {\n      // Note that lazy reads only happen when we have multiple segments, so moreSegments.back() is\n      // valid.\n      const byte* allEnd = reinterpret_cast<const byte*>(moreSegments.back().end());\n      inputStream.skip(allEnd - readPos);\n    });\n  }\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unwindDetector.catchExceptionsIfUnwinding",
          "args": [
            "[&]() {\n      // Note that lazy reads only happen when we have multiple segments, so moreSegments.back() is\n      // valid.\n      const byte* allEnd = reinterpret_cast<const byte*>(moreSegments.back().end());\n      inputStream.skip(allEnd - readPos);\n    }"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inputStream.skip",
          "args": [
            "allEnd - readPos"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "skip",
          "container": "TestPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-packed-test.c++",
          "lines": "68-71",
          "snippet": "void skip(size_t bytes) override {\n    KJ_ASSERT(bytes <= data.size() - readPos, \"Overran end of stream.\");\n    readPos += bytes;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize-packed.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <stdlib.h>\n#include <string>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize-packed.h\"\n\nTestPipe {\n  void skip(size_t bytes) override {\n      KJ_ASSERT(bytes <= data.size() - readPos, \"Overran end of stream.\");\n      readPos += bytes;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "moreSegments.back().end()"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "moreSegments.back",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "moreSegments.back",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nInputStreamMessageReader::~InputStreamMessageReader() noexcept(false) {\n  if (readPos != nullptr) {\n    unwindDetector.catchExceptionsIfUnwinding([&]() {\n      // Note that lazy reads only happen when we have multiple segments, so moreSegments.back() is\n      // valid.\n      const byte* allEnd = reinterpret_cast<const byte*>(moreSegments.back().end());\n      inputStream.skip(allEnd - readPos);\n    });\n  }\n}"
  },
  {
    "function_name": "InputStreamMessageReader::InputStreamMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "146-212",
    "snippet": "InputStreamMessageReader::InputStreamMessageReader(\n    kj::InputStream& inputStream, ReaderOptions options, kj::ArrayPtr<word> scratchSpace)\n    : MessageReader(options), inputStream(inputStream), readPos(nullptr) {\n  _::WireValue<uint32_t> firstWord[2];\n\n  inputStream.read(firstWord, sizeof(firstWord));\n\n  uint segmentCount = firstWord[0].get() + 1;\n  uint segment0Size = segmentCount == 0 ? 0 : firstWord[1].get();\n\n  size_t totalWords = segment0Size;\n\n  // Reject messages with too many segments for security reasons.\n  KJ_REQUIRE(segmentCount < 512, \"Message has too many segments.\") {\n    segmentCount = 1;\n    segment0Size = 1;\n    break;\n  }\n\n  // Read sizes for all segments except the first.  Include padding if necessary.\n  KJ_STACK_ARRAY(_::WireValue<uint32_t>, moreSizes, segmentCount & ~1, 16, 64);\n  if (segmentCount > 1) {\n    inputStream.read(moreSizes.begin(), moreSizes.size() * sizeof(moreSizes[0]));\n    for (uint i = 0; i < segmentCount - 1; i++) {\n      totalWords += moreSizes[i].get();\n    }\n  }\n\n  // Don't accept a message which the receiver couldn't possibly traverse without hitting the\n  // traversal limit.  Without this check, a malicious client could transmit a very large segment\n  // size to make the receiver allocate excessive space and possibly crash.\n  KJ_REQUIRE(totalWords <= options.traversalLimitInWords,\n             \"Message is too large.  To increase the limit on the receiving end, see \"\n             \"capnp::ReaderOptions.\") {\n    segmentCount = 1;\n    segment0Size = kj::min(segment0Size, options.traversalLimitInWords);\n    totalWords = segment0Size;\n    break;\n  }\n\n  if (scratchSpace.size() < totalWords) {\n    // TODO(perf):  Consider allocating each segment as a separate chunk to reduce memory\n    //   fragmentation.\n    ownedSpace = kj::heapArray<word>(totalWords);\n    scratchSpace = ownedSpace;\n  }\n\n  segment0 = scratchSpace.slice(0, segment0Size);\n\n  if (segmentCount > 1) {\n    moreSegments = kj::heapArray<kj::ArrayPtr<const word>>(segmentCount - 1);\n    size_t offset = segment0Size;\n\n    for (uint i = 0; i < segmentCount - 1; i++) {\n      uint segmentSize = moreSizes[i].get();\n      moreSegments[i] = scratchSpace.slice(offset, offset + segmentSize);\n      offset += segmentSize;\n    }\n  }\n\n  if (segmentCount == 1) {\n    inputStream.read(scratchSpace.begin(), totalWords * sizeof(word));\n  } else if (segmentCount > 1) {\n    readPos = scratchSpace.asBytes().begin();\n    readPos += inputStream.read(readPos, segment0Size * sizeof(word), totalWords * sizeof(word));\n  }\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inputStream.read",
          "args": [
            "readPos",
            "segment0Size * sizeof(word)",
            "totalWords * sizeof(word)"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": "Uncompressed",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/benchmark/protobuf-common.h",
          "lines": "101-113",
          "snippet": "static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                   google::protobuf::MessageLite* message) {\n    google::protobuf::io::CodedInputStream input(rawInput);\n    uint32_t size;\n    GOOGLE_CHECK(input.ReadVarint32(&size));\n\n    auto limit = input.PushLimit(size);\n\n    GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                 input.ConsumedEntireMessage());\n\n    input.PopLimit(limit);\n  }",
          "includes": [
            "#include <snappy/snappy-sinksource.h>",
            "#include <snappy/snappy.h>",
            "#include <thread>",
            "#include <google/protobuf/io/coded_stream.h>",
            "#include <google/protobuf/io/zero_copy_stream_impl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy/snappy-sinksource.h>\n#include <snappy/snappy.h>\n#include <thread>\n#include <google/protobuf/io/coded_stream.h>\n#include <google/protobuf/io/zero_copy_stream_impl.h>\n#include \"common.h\"\n\nUncompressed {\n  static void read(google::protobuf::io::ZeroCopyInputStream* rawInput,\n                     google::protobuf::MessageLite* message) {\n      google::protobuf::io::CodedInputStream input(rawInput);\n      uint32_t size;\n      GOOGLE_CHECK(input.ReadVarint32(&size));\n  \n      auto limit = input.PushLimit(size);\n  \n      GOOGLE_CHECK(message->MergePartialFromCodedStream(&input) &&\n                   input.ConsumedEntireMessage());\n  \n      input.PopLimit(limit);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scratchSpace.asBytes",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "asBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/blob.h",
          "lines": "128-128",
          "snippet": "inline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }",
          "includes": [
            "#include <string.h>",
            "#include \"common.h\"",
            "#include <kj/string.h>",
            "#include <kj/common.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"common.h\"\n#include <kj/string.h>\n#include <kj/common.h>\n\ninline kj::ArrayPtr<const byte> asBytes() const { return asArray().asBytes(); }"
        }
      },
      {
        "call_info": {
          "callee": "scratchSpace.begin",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "scratchSpace.slice",
          "args": [
            "offset",
            "offset + segmentSize"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "moreSizes[i].get",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<kj::ArrayPtr<const word>>",
          "args": [
            "segmentCount - 1"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<word>",
          "args": [
            "totalWords"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "scratchSpace.size",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "segment0Size",
            "options.traversalLimitInWords"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "totalWords <= options.traversalLimitInWords",
            "\"Message is too large.  To increase the limit on the receiving end, see \"\n             \"capnp::ReaderOptions.\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_STACK_ARRAY",
          "args": [
            "_::WireValue<uint32_t>",
            "moreSizes",
            "segmentCount & ~1",
            "16",
            "64"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "segmentCount < 512",
            "\"Message has too many segments.\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nInputStreamMessageReader::InputStreamMessageReader(\n    kj::InputStream& inputStream, ReaderOptions options, kj::ArrayPtr<word> scratchSpace)\n    : MessageReader(options), inputStream(inputStream), readPos(nullptr) {\n  _::WireValue<uint32_t> firstWord[2];\n\n  inputStream.read(firstWord, sizeof(firstWord));\n\n  uint segmentCount = firstWord[0].get() + 1;\n  uint segment0Size = segmentCount == 0 ? 0 : firstWord[1].get();\n\n  size_t totalWords = segment0Size;\n\n  // Reject messages with too many segments for security reasons.\n  KJ_REQUIRE(segmentCount < 512, \"Message has too many segments.\") {\n    segmentCount = 1;\n    segment0Size = 1;\n    break;\n  }\n\n  // Read sizes for all segments except the first.  Include padding if necessary.\n  KJ_STACK_ARRAY(_::WireValue<uint32_t>, moreSizes, segmentCount & ~1, 16, 64);\n  if (segmentCount > 1) {\n    inputStream.read(moreSizes.begin(), moreSizes.size() * sizeof(moreSizes[0]));\n    for (uint i = 0; i < segmentCount - 1; i++) {\n      totalWords += moreSizes[i].get();\n    }\n  }\n\n  // Don't accept a message which the receiver couldn't possibly traverse without hitting the\n  // traversal limit.  Without this check, a malicious client could transmit a very large segment\n  // size to make the receiver allocate excessive space and possibly crash.\n  KJ_REQUIRE(totalWords <= options.traversalLimitInWords,\n             \"Message is too large.  To increase the limit on the receiving end, see \"\n             \"capnp::ReaderOptions.\") {\n    segmentCount = 1;\n    segment0Size = kj::min(segment0Size, options.traversalLimitInWords);\n    totalWords = segment0Size;\n    break;\n  }\n\n  if (scratchSpace.size() < totalWords) {\n    // TODO(perf):  Consider allocating each segment as a separate chunk to reduce memory\n    //   fragmentation.\n    ownedSpace = kj::heapArray<word>(totalWords);\n    scratchSpace = ownedSpace;\n  }\n\n  segment0 = scratchSpace.slice(0, segment0Size);\n\n  if (segmentCount > 1) {\n    moreSegments = kj::heapArray<kj::ArrayPtr<const word>>(segmentCount - 1);\n    size_t offset = segment0Size;\n\n    for (uint i = 0; i < segmentCount - 1; i++) {\n      uint segmentSize = moreSizes[i].get();\n      moreSegments[i] = scratchSpace.slice(offset, offset + segmentSize);\n      offset += segmentSize;\n    }\n  }\n\n  if (segmentCount == 1) {\n    inputStream.read(scratchSpace.begin(), totalWords * sizeof(word));\n  } else if (segmentCount > 1) {\n    readPos = scratchSpace.asBytes().begin();\n    readPos += inputStream.read(readPos, segment0Size * sizeof(word), totalWords * sizeof(word));\n  }\n}"
  },
  {
    "function_name": "computeSerializedSizeInWords",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "132-142",
    "snippet": "size_t computeSerializedSizeInWords(kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  size_t totalSize = segments.size() / 2 + 1;\n\n  for (auto& segment: segments) {\n    totalSize += segment.size();\n  }\n\n  return totalSize;\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "segment.size",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "segments.size() > 0",
            "\"Tried to serialize uninitialized message.\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nsize_t computeSerializedSizeInWords(kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  size_t totalSize = segments.size() / 2 + 1;\n\n  for (auto& segment: segments) {\n    totalSize += segment.size();\n  }\n\n  return totalSize;\n}"
  },
  {
    "function_name": "messageToFlatArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "100-130",
    "snippet": "kj::Array<word> messageToFlatArray(kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  kj::Array<word> result = kj::heapArray<word>(computeSerializedSizeInWords(segments));\n\n  _::WireValue<uint32_t>* table =\n      reinterpret_cast<_::WireValue<uint32_t>*>(result.begin());\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  table[0].set(segments.size() - 1);\n\n  for (uint i = 0; i < segments.size(); i++) {\n    table[i + 1].set(segments[i].size());\n  }\n\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    table[segments.size() + 1].set(0);\n  }\n\n  word* dst = result.begin() + segments.size() / 2 + 1;\n\n  for (auto& segment: segments) {\n    memcpy(dst, segment.begin(), segment.size() * sizeof(word));\n    dst += segment.size();\n  }\n\n  KJ_DASSERT(dst == result.end(), \"Buffer overrun/underrun bug in code above.\");\n\n  return kj::mv(result);\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "result"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "dst == result.end()",
            "\"Buffer overrun/underrun bug in code above.\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.end",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "segment.size",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "segment.begin()",
            "segment.size() * sizeof(word)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment.begin",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "table[segments.size",
          "args": [
            "0"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "493-493",
          "snippet": "inline constexpr size_t size(T&& arr) { return arr.size(); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr size_t size(T&& arr) { return arr.size(); }"
        }
      },
      {
        "call_info": {
          "callee": "table[i + 1].set",
          "args": [
            "segments[i].size()"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "set",
          "container": "AnyPointer::Builder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "201-201",
          "snippet": "inline void set(Reader value) { builder.copyFrom(value.reader); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\nAnyPointer {\n  Builder {\n    inline void set(Reader value) { builder.copyFrom(value.reader); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<_::WireValue<uint32_t>*>",
          "args": [
            "result.begin()"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<word>",
          "args": [
            "computeSerializedSizeInWords(segments)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "computeSerializedSizeInWords",
          "args": [
            "segments"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "computeSerializedSizeInWords",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
          "lines": "132-142",
          "snippet": "size_t computeSerializedSizeInWords(kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  size_t totalSize = segments.size() / 2 + 1;\n\n  for (auto& segment: segments) {\n    totalSize += segment.size();\n  }\n\n  return totalSize;\n}",
          "includes": [
            "#include <exception>",
            "#include <kj/debug.h>",
            "#include \"layout.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nsize_t computeSerializedSizeInWords(kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  KJ_REQUIRE(segments.size() > 0, \"Tried to serialize uninitialized message.\");\n\n  size_t totalSize = segments.size() / 2 + 1;\n\n  for (auto& segment: segments) {\n    totalSize += segment.size();\n  }\n\n  return totalSize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nkj::Array<word> messageToFlatArray(kj::ArrayPtr<const kj::ArrayPtr<const word>> segments) {\n  kj::Array<word> result = kj::heapArray<word>(computeSerializedSizeInWords(segments));\n\n  _::WireValue<uint32_t>* table =\n      reinterpret_cast<_::WireValue<uint32_t>*>(result.begin());\n\n  // We write the segment count - 1 because this makes the first word zero for single-segment\n  // messages, improving compression.  We don't bother doing this with segment sizes because\n  // one-word segments are rare anyway.\n  table[0].set(segments.size() - 1);\n\n  for (uint i = 0; i < segments.size(); i++) {\n    table[i + 1].set(segments[i].size());\n  }\n\n  if (segments.size() % 2 == 0) {\n    // Set padding byte.\n    table[segments.size() + 1].set(0);\n  }\n\n  word* dst = result.begin() + segments.size() / 2 + 1;\n\n  for (auto& segment: segments) {\n    memcpy(dst, segment.begin(), segment.size() * sizeof(word));\n    dst += segment.size();\n  }\n\n  KJ_DASSERT(dst == result.end(), \"Buffer overrun/underrun bug in code above.\");\n\n  return kj::mv(result);\n}"
  },
  {
    "function_name": "initMessageBuilderFromFlatArrayCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "93-98",
    "snippet": "kj::ArrayPtr<const word> initMessageBuilderFromFlatArrayCopy(\n    kj::ArrayPtr<const word> array, MessageBuilder& target, ReaderOptions options) {\n  FlatArrayMessageReader reader(array, options);\n  target.setRoot(reader.getRoot<AnyPointer>());\n  return kj::arrayPtr(reader.getEnd(), array.end());\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::arrayPtr",
          "args": [
            "reader.getEnd()",
            "array.end()"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array.end",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      },
      {
        "call_info": {
          "callee": "reader.getEnd",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.setRoot",
          "args": [
            "reader.getRoot<AnyPointer>()"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.getRoot<AnyPointer>",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "getRoot",
          "container": "RpcRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/rpc.c++",
          "lines": "1322-1324",
          "snippet": "inline AnyPointer::Builder getRoot() {\n      return paramsBuilder;\n    }",
          "includes": [
            "#include <capnp/rpc.capnp.h>",
            "#include <queue>",
            "#include <map>",
            "#include <unordered_map>",
            "#include <kj/function.h>",
            "#include <kj/one-of.h>",
            "#include <kj/async.h>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include \"message.h\"",
            "#include \"rpc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <capnp/rpc.capnp.h>\n#include <queue>\n#include <map>\n#include <unordered_map>\n#include <kj/function.h>\n#include <kj/one-of.h>\n#include <kj/async.h>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include \"message.h\"\n#include \"rpc.h\"\n\nRpcRequest {\n  inline AnyPointer::Builder getRoot() {\n        return paramsBuilder;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nkj::ArrayPtr<const word> initMessageBuilderFromFlatArrayCopy(\n    kj::ArrayPtr<const word> array, MessageBuilder& target, ReaderOptions options) {\n  FlatArrayMessageReader reader(array, options);\n  target.setRoot(reader.getRoot<AnyPointer>());\n  return kj::arrayPtr(reader.getEnd(), array.end());\n}"
  },
  {
    "function_name": "FlatArrayMessageReader::getSegment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "83-91",
    "snippet": "kj::ArrayPtr<const word> FlatArrayMessageReader::getSegment(uint id) {\n  if (id == 0) {\n    return segment0;\n  } else if (id <= moreSegments.size()) {\n    return moreSegments[id - 1];\n  } else {\n    return nullptr;\n  }\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "moreSegments.size",
          "args": [],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nkj::ArrayPtr<const word> FlatArrayMessageReader::getSegment(uint id) {\n  if (id == 0) {\n    return segment0;\n  } else if (id <= moreSegments.size()) {\n    return moreSegments[id - 1];\n  } else {\n    return nullptr;\n  }\n}"
  },
  {
    "function_name": "FlatArrayMessageReader::FlatArrayMessageReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize.c++",
    "lines": "29-81",
    "snippet": "FlatArrayMessageReader::FlatArrayMessageReader(\n    kj::ArrayPtr<const word> array, ReaderOptions options)\n    : MessageReader(options), end(array.end()) {\n  if (array.size() < 1) {\n    // Assume empty message.\n    return;\n  }\n\n  const _::WireValue<uint32_t>* table =\n      reinterpret_cast<const _::WireValue<uint32_t>*>(array.begin());\n\n  uint segmentCount = table[0].get() + 1;\n  size_t offset = segmentCount / 2u + 1u;\n\n  KJ_REQUIRE(array.size() >= offset, \"Message ends prematurely in segment table.\") {\n    return;\n  }\n\n  if (segmentCount == 0) {\n    end = array.begin() + offset;\n    return;\n  }\n\n  {\n    uint segmentSize = table[1].get();\n\n    KJ_REQUIRE(array.size() >= offset + segmentSize,\n               \"Message ends prematurely in first segment.\") {\n      return;\n    }\n\n    segment0 = array.slice(offset, offset + segmentSize);\n    offset += segmentSize;\n  }\n\n  if (segmentCount > 1) {\n    moreSegments = kj::heapArray<kj::ArrayPtr<const word>>(segmentCount - 1);\n\n    for (uint i = 1; i < segmentCount; i++) {\n      uint segmentSize = table[i + 1].get();\n\n      KJ_REQUIRE(array.size() >= offset + segmentSize, \"Message ends prematurely.\") {\n        moreSegments = nullptr;\n        return;\n      }\n\n      moreSegments[i - 1] = array.slice(offset, offset + segmentSize);\n      offset += segmentSize;\n    }\n  }\n\n  end = array.begin() + offset;\n}",
    "includes": [
      "#include <exception>",
      "#include <kj/debug.h>",
      "#include \"layout.h\"",
      "#include \"serialize.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array.begin",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "550-550",
          "snippet": "inline Iterator begin() { return Iterator(this, 0); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator begin() { return Iterator(this, 0); }"
        }
      },
      {
        "call_info": {
          "callee": "array.slice",
          "args": [
            "offset",
            "offset + segmentSize"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "array.size() >= offset + segmentSize",
            "\"Message ends prematurely.\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array.size",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "599-599",
          "snippet": "inline uint size() { return _builder.size() / ELEMENTS; }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline uint size() { return _builder.size() / ELEMENTS; }"
        }
      },
      {
        "call_info": {
          "callee": "table[i + 1].get",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "get",
          "container": "ConstData",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/generated-header-support.h",
          "lines": "469-471",
          "snippet": "inline Data::Reader get() const {\n    return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n  }",
          "includes": [
            "#include <kj/string-tree.h>",
            "#include <kj/string.h>",
            "#include \"any.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"orphan.h\"",
            "#include \"list.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/string-tree.h>\n#include <kj/string.h>\n#include \"any.h\"\n#include \"pointer-helpers.h\"\n#include \"orphan.h\"\n#include \"list.h\"\n#include \"layout.h\"\n\nConstData {\n  inline Data::Reader get() const {\n      return Data::Reader(reinterpret_cast<const byte*>(ptr), size);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArray<kj::ArrayPtr<const word>>",
          "args": [
            "segmentCount - 1"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "array.size() >= offset + segmentSize",
            "\"Message ends prematurely in first segment.\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "array.size() >= offset",
            "\"Message ends prematurely in segment table.\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const _::WireValue<uint32_t>*>",
          "args": [
            "array.begin()"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array.end",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/any.h",
          "lines": "551-551",
          "snippet": "inline Iterator end() { return Iterator(this, size()); }",
          "includes": [
            "#include \"list.h\"",
            "#include \"orphan.h\"",
            "#include \"pointer-helpers.h\"",
            "#include \"layout.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"list.h\"\n#include \"orphan.h\"\n#include \"pointer-helpers.h\"\n#include \"layout.h\"\n\ninline Iterator end() { return Iterator(this, size()); }"
        }
      }
    ],
    "contextual_snippet": "#include <exception>\n#include <kj/debug.h>\n#include \"layout.h\"\n#include \"serialize.h\"\n\nFlatArrayMessageReader::FlatArrayMessageReader(\n    kj::ArrayPtr<const word> array, ReaderOptions options)\n    : MessageReader(options), end(array.end()) {\n  if (array.size() < 1) {\n    // Assume empty message.\n    return;\n  }\n\n  const _::WireValue<uint32_t>* table =\n      reinterpret_cast<const _::WireValue<uint32_t>*>(array.begin());\n\n  uint segmentCount = table[0].get() + 1;\n  size_t offset = segmentCount / 2u + 1u;\n\n  KJ_REQUIRE(array.size() >= offset, \"Message ends prematurely in segment table.\") {\n    return;\n  }\n\n  if (segmentCount == 0) {\n    end = array.begin() + offset;\n    return;\n  }\n\n  {\n    uint segmentSize = table[1].get();\n\n    KJ_REQUIRE(array.size() >= offset + segmentSize,\n               \"Message ends prematurely in first segment.\") {\n      return;\n    }\n\n    segment0 = array.slice(offset, offset + segmentSize);\n    offset += segmentSize;\n  }\n\n  if (segmentCount > 1) {\n    moreSegments = kj::heapArray<kj::ArrayPtr<const word>>(segmentCount - 1);\n\n    for (uint i = 1; i < segmentCount; i++) {\n      uint segmentSize = table[i + 1].get();\n\n      KJ_REQUIRE(array.size() >= offset + segmentSize, \"Message ends prematurely.\") {\n        moreSegments = nullptr;\n        return;\n      }\n\n      moreSegments[i - 1] = array.slice(offset, offset + segmentSize);\n      offset += segmentSize;\n    }\n  }\n\n  end = array.begin() + offset;\n}"
  }
]