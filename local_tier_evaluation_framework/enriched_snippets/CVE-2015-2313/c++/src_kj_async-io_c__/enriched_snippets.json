[
  {
    "function_name": "setupAsyncIo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1379-1385",
    "snippet": "AsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "ioProvider"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "lowLevel"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowLevel->getEventPort",
          "args": [],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowLevel->getWaitScope",
          "args": [],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heap<AsyncIoProviderImpl>",
          "args": [
            "*lowLevel"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoContext setupAsyncIo() {\n  auto lowLevel = heap<LowLevelAsyncIoProviderImpl>();\n  auto ioProvider = kj::heap<AsyncIoProviderImpl>(*lowLevel);\n  auto& waitScope = lowLevel->getWaitScope();\n  auto& eventPort = lowLevel->getEventPort();\n  return { kj::mv(lowLevel), kj::mv(ioProvider), waitScope, eventPort };\n}"
  },
  {
    "function_name": "newAsyncIoProvider",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1375-1377",
    "snippet": "Own<AsyncIoProvider> newAsyncIoProvider(LowLevelAsyncIoProvider& lowLevel) {\n  return kj::heap<AsyncIoProviderImpl>(lowLevel);\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<AsyncIoProviderImpl>",
          "args": [
            "lowLevel"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nOwn<AsyncIoProvider> newAsyncIoProvider(LowLevelAsyncIoProvider& lowLevel) {\n  return kj::heap<AsyncIoProviderImpl>(lowLevel);\n}"
  },
  {
    "function_name": "LowLevelAsyncIoProvider::wrapDatagramSocketFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1371-1373",
    "snippet": "Own<DatagramPort> LowLevelAsyncIoProvider::wrapDatagramSocketFd(int fd, uint flags) {\n  KJ_UNIMPLEMENTED(\"Datagram sockets not implemented.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Datagram sockets not implemented.\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nOwn<DatagramPort> LowLevelAsyncIoProvider::wrapDatagramSocketFd(int fd, uint flags) {\n  KJ_UNIMPLEMENTED(\"Datagram sockets not implemented.\");\n}"
  },
  {
    "function_name": "NetworkAddress::bindDatagramPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1368-1370",
    "snippet": "Own<DatagramPort> NetworkAddress::bindDatagramPort() {\n  KJ_UNIMPLEMENTED(\"Datagram sockets not implemented.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Datagram sockets not implemented.\""
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nOwn<DatagramPort> NetworkAddress::bindDatagramPort() {\n  KJ_UNIMPLEMENTED(\"Datagram sockets not implemented.\");\n}"
  },
  {
    "function_name": "DatagramPort::setsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1365-1367",
    "snippet": "void DatagramPort::setsockopt(int level, int option, const void* value, uint length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Not a socket.\""
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid DatagramPort::setsockopt(int level, int option, const void* value, uint length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}"
  },
  {
    "function_name": "DatagramPort::getsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1362-1364",
    "snippet": "void DatagramPort::getsockopt(int level, int option, void* value, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Not a socket.\""
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid DatagramPort::getsockopt(int level, int option, void* value, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}"
  },
  {
    "function_name": "ConnectionReceiver::setsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1359-1361",
    "snippet": "void ConnectionReceiver::setsockopt(int level, int option, const void* value, uint length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Not a socket.\""
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid ConnectionReceiver::setsockopt(int level, int option, const void* value, uint length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}"
  },
  {
    "function_name": "ConnectionReceiver::getsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1356-1358",
    "snippet": "void ConnectionReceiver::getsockopt(int level, int option, void* value, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Not a socket.\""
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid ConnectionReceiver::getsockopt(int level, int option, void* value, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}"
  },
  {
    "function_name": "AsyncIoStream::getpeername",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1353-1355",
    "snippet": "void AsyncIoStream::getpeername(struct sockaddr* addr, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Not a socket.\""
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nvoid AsyncIoStream::getpeername(struct sockaddr* addr, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}"
  },
  {
    "function_name": "AsyncIoStream::getsockname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1350-1352",
    "snippet": "void AsyncIoStream::getsockname(struct sockaddr* addr, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Not a socket.\""
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nvoid AsyncIoStream::getsockname(struct sockaddr* addr, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}"
  },
  {
    "function_name": "AsyncIoStream::setsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1347-1349",
    "snippet": "void AsyncIoStream::setsockopt(int level, int option, const void* value, uint length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Not a socket.\""
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid AsyncIoStream::setsockopt(int level, int option, const void* value, uint length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}"
  },
  {
    "function_name": "AsyncIoStream::getsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1344-1346",
    "snippet": "void AsyncIoStream::getsockopt(int level, int option, void* value, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_UNIMPLEMENTED",
          "args": [
            "\"Not a socket.\""
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid AsyncIoStream::getsockopt(int level, int option, void* value, uint* length) {\n  KJ_UNIMPLEMENTED(\"Not a socket.\");\n}"
  },
  {
    "function_name": "AsyncInputStream::read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1340-1342",
    "snippet": "Promise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "[](size_t) {}"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "646-671",
          "snippet": "Promise<Array<SocketAddress>> read() {\n    return input->tryRead(&current, sizeof(current), sizeof(current)).then(\n        [this](size_t n) -> Promise<Array<SocketAddress>> {\n      if (n < sizeof(current)) {\n        thread = nullptr;\n        // getaddrinfo()'s docs seem to say it will never return an empty list, but let's check\n        // anyway.\n        KJ_REQUIRE(addresses.size() > 0, \"DNS lookup returned no addresses.\") { break; }\n        return addresses.releaseAsArray();\n      } else {\n        // getaddrinfo() can return multiple copies of the same address for several reasons.\n        // A major one is that we don't give it a socket type (SOCK_STREAM vs. SOCK_DGRAM), so\n        // it may return two copies of the same address, one for each type, unless it explicitly\n        // knows that the service name given is specific to one type.  But we can't tell it a type,\n        // because we don't actually know which one the user wants, and if we specify SOCK_STREAM\n        // while the user specified a UDP service name then they'll get a resolution error which\n        // is lame.  (At least, I think that's how it works.)\n        //\n        // So we instead resort to de-duping results.\n        if (alreadySeen.insert(current).second) {\n          addresses.add(current);\n        }\n        return read();\n      }\n    });\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<Array<SocketAddress>> read() {\n    return input->tryRead(&current, sizeof(current), sizeof(current)).then(\n        [this](size_t n) -> Promise<Array<SocketAddress>> {\n      if (n < sizeof(current)) {\n        thread = nullptr;\n        // getaddrinfo()'s docs seem to say it will never return an empty list, but let's check\n        // anyway.\n        KJ_REQUIRE(addresses.size() > 0, \"DNS lookup returned no addresses.\") { break; }\n        return addresses.releaseAsArray();\n      } else {\n        // getaddrinfo() can return multiple copies of the same address for several reasons.\n        // A major one is that we don't give it a socket type (SOCK_STREAM vs. SOCK_DGRAM), so\n        // it may return two copies of the same address, one for each type, unless it explicitly\n        // knows that the service name given is specific to one type.  But we can't tell it a type,\n        // because we don't actually know which one the user wants, and if we specify SOCK_STREAM\n        // while the user specified a UDP service name then they'll get a resolution error which\n        // is lame.  (At least, I think that's how it works.)\n        //\n        // So we instead resort to de-duping results.\n        if (alreadySeen.insert(current).second) {\n          addresses.add(current);\n        }\n        return read();\n      }\n    });\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}"
  },
  {
    "function_name": "newPipeThread",
    "container": "AsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1306-1329",
    "snippet": "PipeThread newPipeThread(\n      Function<void(AsyncIoProvider&, AsyncIoStream&, WaitScope&)> startFunc) override {\n    int fds[2];\n    int type = SOCK_STREAM;\n#if __linux__ && !__BIONIC__\n    type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n#endif\n    KJ_SYSCALL(socketpair(AF_UNIX, type, 0, fds));\n\n    int threadFd = fds[1];\n    KJ_ON_SCOPE_FAILURE(close(threadFd));\n\n    auto pipe = lowLevel.wrapSocketFd(fds[0], NEW_FD_FLAGS);\n\n    auto thread = heap<Thread>(kj::mvCapture(startFunc,\n        [threadFd](Function<void(AsyncIoProvider&, AsyncIoStream&, WaitScope&)>&& startFunc) {\n      LowLevelAsyncIoProviderImpl lowLevel;\n      auto stream = lowLevel.wrapSocketFd(threadFd, NEW_FD_FLAGS);\n      AsyncIoProviderImpl ioProvider(lowLevel);\n      startFunc(ioProvider, *stream, lowLevel.getWaitScope());\n    }));\n\n    return { kj::mv(thread), kj::mv(pipe) };\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "pipe"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "thread"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<Thread>",
          "args": [
            "kj::mvCapture(startFunc,\n        [threadFd](Function<void(AsyncIoProvider&, AsyncIoStream&, WaitScope&)>&& startFunc) {\n      LowLevelAsyncIoProviderImpl lowLevel;\n      auto stream = lowLevel.wrapSocketFd(threadFd, NEW_FD_FLAGS);\n      AsyncIoProviderImpl ioProvider(lowLevel);\n      startFunc(ioProvider, *stream, lowLevel.getWaitScope());\n    })"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "startFunc",
            "[threadFd](Function<void(AsyncIoProvider&, AsyncIoStream&, WaitScope&)>&& startFunc) {\n      LowLevelAsyncIoProviderImpl lowLevel;\n      auto stream = lowLevel.wrapSocketFd(threadFd, NEW_FD_FLAGS);\n      AsyncIoProviderImpl ioProvider(lowLevel);\n      startFunc(ioProvider, *stream, lowLevel.getWaitScope());\n    }"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "startFunc",
          "args": [
            "ioProvider",
            "*stream",
            "lowLevel.getWaitScope()"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowLevel.getWaitScope",
          "args": [],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowLevel.wrapSocketFd",
          "args": [
            "threadFd",
            "NEW_FD_FLAGS"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowLevel.wrapSocketFd",
          "args": [
            "fds[0]",
            "NEW_FD_FLAGS"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ON_SCOPE_FAILURE",
          "args": [
            "close(threadFd)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "threadFd"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "socketpair(AF_UNIX, type, 0, fds)"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "type",
            "0",
            "fds"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoProviderImpl {\n  PipeThread newPipeThread(\n        Function<void(AsyncIoProvider&, AsyncIoStream&, WaitScope&)> startFunc) override {\n      int fds[2];\n      int type = SOCK_STREAM;\n  #if __linux__ && !__BIONIC__\n      type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n  #endif\n      KJ_SYSCALL(socketpair(AF_UNIX, type, 0, fds));\n  \n      int threadFd = fds[1];\n      KJ_ON_SCOPE_FAILURE(close(threadFd));\n  \n      auto pipe = lowLevel.wrapSocketFd(fds[0], NEW_FD_FLAGS);\n  \n      auto thread = heap<Thread>(kj::mvCapture(startFunc,\n          [threadFd](Function<void(AsyncIoProvider&, AsyncIoStream&, WaitScope&)>&& startFunc) {\n        LowLevelAsyncIoProviderImpl lowLevel;\n        auto stream = lowLevel.wrapSocketFd(threadFd, NEW_FD_FLAGS);\n        AsyncIoProviderImpl ioProvider(lowLevel);\n        startFunc(ioProvider, *stream, lowLevel.getWaitScope());\n      }));\n  \n      return { kj::mv(thread), kj::mv(pipe) };\n    }\n}"
  },
  {
    "function_name": "newTwoWayPipe",
    "container": "AsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1289-1300",
    "snippet": "TwoWayPipe newTwoWayPipe() override {\n    int fds[2];\n    int type = SOCK_STREAM;\n#if __linux__ && !__BIONIC__\n    type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n#endif\n    KJ_SYSCALL(socketpair(AF_UNIX, type, 0, fds));\n    return TwoWayPipe { {\n      lowLevel.wrapSocketFd(fds[0], NEW_FD_FLAGS),\n      lowLevel.wrapSocketFd(fds[1], NEW_FD_FLAGS)\n    } };\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lowLevel.wrapSocketFd",
          "args": [
            "fds[1]",
            "NEW_FD_FLAGS"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowLevel.wrapSocketFd",
          "args": [
            "fds[0]",
            "NEW_FD_FLAGS"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "socketpair(AF_UNIX, type, 0, fds)"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "type",
            "0",
            "fds"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoProviderImpl {\n  TwoWayPipe newTwoWayPipe() override {\n      int fds[2];\n      int type = SOCK_STREAM;\n  #if __linux__ && !__BIONIC__\n      type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n  #endif\n      KJ_SYSCALL(socketpair(AF_UNIX, type, 0, fds));\n      return TwoWayPipe { {\n        lowLevel.wrapSocketFd(fds[0], NEW_FD_FLAGS),\n        lowLevel.wrapSocketFd(fds[1], NEW_FD_FLAGS)\n      } };\n    }\n}"
  },
  {
    "function_name": "newOneWayPipe",
    "container": "AsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1276-1287",
    "snippet": "OneWayPipe newOneWayPipe() override {\n    int fds[2];\n#if __linux__ && !__BIONIC__\n    KJ_SYSCALL(pipe2(fds, O_NONBLOCK | O_CLOEXEC));\n#else\n    KJ_SYSCALL(pipe(fds));\n#endif\n    return OneWayPipe {\n      lowLevel.wrapInputFd(fds[0], NEW_FD_FLAGS),\n      lowLevel.wrapOutputFd(fds[1], NEW_FD_FLAGS)\n    };\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lowLevel.wrapOutputFd",
          "args": [
            "fds[1]",
            "NEW_FD_FLAGS"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowLevel.wrapInputFd",
          "args": [
            "fds[0]",
            "NEW_FD_FLAGS"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(fds)"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "fds"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe2(fds, O_NONBLOCK | O_CLOEXEC)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe2",
          "args": [
            "fds",
            "O_NONBLOCK | O_CLOEXEC"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoProviderImpl {\n  OneWayPipe newOneWayPipe() override {\n      int fds[2];\n  #if __linux__ && !__BIONIC__\n      KJ_SYSCALL(pipe2(fds, O_NONBLOCK | O_CLOEXEC));\n  #else\n      KJ_SYSCALL(pipe(fds));\n  #endif\n      return OneWayPipe {\n        lowLevel.wrapInputFd(fds[0], NEW_FD_FLAGS),\n        lowLevel.wrapOutputFd(fds[1], NEW_FD_FLAGS)\n      };\n    }\n}"
  },
  {
    "function_name": "AsyncIoProviderImpl",
    "container": "AsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1273-1274",
    "snippet": "AsyncIoProviderImpl(LowLevelAsyncIoProvider& lowLevel)\n      : lowLevel(lowLevel), network(lowLevel) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nAsyncIoProviderImpl {\n  AsyncIoProviderImpl(LowLevelAsyncIoProvider& lowLevel)\n        : lowLevel(lowLevel), network(lowLevel) {}\n}"
  },
  {
    "function_name": "DatagramPortImpl::makeReceiver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1265-1267",
    "snippet": "Own<DatagramReceiver> DatagramPortImpl::makeReceiver(DatagramReceiver::Capacity capacity) {\n  return kj::heap<ReceiverImpl>(*this, capacity);\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<ReceiverImpl>",
          "args": [
            "*this",
            "capacity"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nOwn<DatagramReceiver> DatagramPortImpl::makeReceiver(DatagramReceiver::Capacity capacity) {\n  return kj::heap<ReceiverImpl>(*this, capacity);\n}"
  },
  {
    "function_name": "StoredAddress",
    "container": "StoredAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1254-1256",
    "snippet": "StoredAddress(LowLevelAsyncIoProvider& lowLevel, const void* sockaddr, uint length)\n        : raw(sockaddr, length),\n          abstract(lowLevel, Array<SocketAddress>(&raw, 1, NullArrayDisposer::instance)) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Array<SocketAddress>",
          "args": [
            "&raw",
            "1",
            "NullArrayDisposer::instance"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayBuilder",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "291-294",
          "snippet": "explicit ArrayBuilder(RemoveConst<T>* firstElement, size_t capacity,\n                        const ArrayDisposer& disposer)\n      : ptr(firstElement), pos(firstElement), endPtr(firstElement + capacity),\n        disposer(&disposer) {}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  explicit ArrayBuilder(RemoveConst<T>* firstElement, size_t capacity,\n                          const ArrayDisposer& disposer)\n        : ptr(firstElement), pos(firstElement), endPtr(firstElement + capacity),\n          disposer(&disposer) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nStoredAddress {\n  StoredAddress(LowLevelAsyncIoProvider& lowLevel, const void* sockaddr, uint length)\n          : raw(sockaddr, length),\n            abstract(lowLevel, Array<SocketAddress>(&raw, 1, NullArrayDisposer::instance)) {}\n}"
  },
  {
    "function_name": "getAncillary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1236-1238",
    "snippet": "MaybeTruncated<ArrayPtr<const AncillaryMessage>> getAncillary() override {\n    return { ancillaryList.asPtr(), ancillaryTruncated };\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ancillaryList.asPtr",
          "args": [],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "asPtr",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "313-315",
          "snippet": "inline ArrayPtr<const T> asPtr() const {\n    return arrayPtr(ptr, pos);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  inline ArrayPtr<const T> asPtr() const {\n      return arrayPtr(ptr, pos);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nMaybeTruncated<ArrayPtr<const AncillaryMessage>> getAncillary() override {\n    return { ancillaryList.asPtr(), ancillaryTruncated };\n  }"
  },
  {
    "function_name": "getContent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1232-1234",
    "snippet": "MaybeTruncated<ArrayPtr<const byte>> getContent() override {\n    return { contentBuffer.slice(0, receivedSize), contentTruncated };\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "contentBuffer.slice",
          "args": [
            "0",
            "receivedSize"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nMaybeTruncated<ArrayPtr<const byte>> getContent() override {\n    return { contentBuffer.slice(0, receivedSize), contentTruncated };\n  }"
  },
  {
    "function_name": "receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1167-1230",
    "snippet": "Promise<void> receive() override {\n    struct msghdr msg;\n    memset(&msg, 0, sizeof(msg));\n\n    struct sockaddr_storage addr;\n    memset(&addr, 0, sizeof(addr));\n    msg.msg_name = &addr;\n    msg.msg_namelen = sizeof(addr);\n\n    struct iovec iov;\n    iov.iov_base = contentBuffer.begin();\n    iov.iov_len = contentBuffer.size();\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_control = ancillaryBuffer.begin();\n    msg.msg_controllen = ancillaryBuffer.size();\n\n    ssize_t n;\n    KJ_NONBLOCKING_SYSCALL(n = recvmsg(port.fd, &msg, 0));\n\n    if (n < 0) {\n      // No data available. Wait.\n      return port.observer.whenBecomesReadable().then([this]() {\n        return receive();\n      });\n    } else {\n      receivedSize = n;\n      contentTruncated = msg.msg_flags & MSG_TRUNC;\n\n      source.emplace(port.lowLevel, msg.msg_name, msg.msg_namelen);\n\n      ancillaryList.resize(0);\n      ancillaryTruncated = msg.msg_flags & MSG_CTRUNC;\n\n      for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg); cmsg != nullptr;\n           cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n        // On some platforms (OSX), a cmsghdr's length may cross the end of the ancillary buffer\n        // when truncated. On other platforms (Linux) the length in cmsghdr will itself be\n        // truncated to fit within the buffer.\n\n        const byte* pos = reinterpret_cast<const byte*>(cmsg);\n        size_t available = ancillaryBuffer.end() - pos;\n        if (available < CMSG_SPACE(0)) {\n          // The buffer ends in the middle of the header. We can't use this message.\n          // (On Linux, this never happens, because the message is not included if there isn't\n          // space for a header. I'm not sure how other systems behave, though, so let's be safe.)\n          break;\n        }\n\n        // OK, we know the cmsghdr is valid, at least.\n\n        // Find the start of the message payload.\n        const byte* begin = CMSG_DATA(cmsg);\n\n        // Cap the message length to the available space.\n        const byte* end = pos + kj::min(available, cmsg->cmsg_len);\n\n        ancillaryList.add(AncillaryMessage(\n            cmsg->cmsg_level, cmsg->cmsg_type, arrayPtr(begin, end)));\n      }\n\n      return READY_NOW;\n    }\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ancillaryList.add",
          "args": [
            "AncillaryMessage(\n            cmsg->cmsg_level, cmsg->cmsg_type, arrayPtr(begin, end))"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AncillaryMessage",
          "args": [
            "cmsg->cmsg_level",
            "cmsg->cmsg_type",
            "arrayPtr(begin, end)"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "AncillaryMessage::AncillaryMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.h",
          "lines": "484-486",
          "snippet": "inline AncillaryMessage::AncillaryMessage(\n    int level, int type, ArrayPtr<const byte> data)\n    : level(level), type(type), data(data) {}",
          "includes": [
            "#include \"time.h\"",
            "#include \"thread.h\"",
            "#include \"function.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"time.h\"\n#include \"thread.h\"\n#include \"function.h\"\n#include \"async.h\"\n\ninline AncillaryMessage::AncillaryMessage(\n    int level, int type, ArrayPtr<const byte> data)\n    : level(level), type(type), data(data) {}"
        }
      },
      {
        "call_info": {
          "callee": "arrayPtr",
          "args": [
            "begin",
            "end"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "arrayPtr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1194-1197",
          "snippet": "inline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\ninline constexpr ArrayPtr<T> arrayPtr(T* begin, T* end) {\n  // Use this function to construct ArrayPtrs without writing out the type name.\n  return ArrayPtr<T>(begin, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::min",
          "args": [
            "available",
            "cmsg->cmsg_len"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "473-475",
          "snippet": "auto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nauto min(T&& a, U&& b) -> MinType<Decay<T>, Decay<U>> {\n  return a < b ? MinType<Decay<T>, Decay<U>>(a) : MinType<Decay<T>, Decay<U>>(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMSG_DATA",
          "args": [
            "cmsg"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_SPACE",
          "args": [
            "0"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ancillaryBuffer.end",
          "args": [],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "693-693",
          "snippet": "inline Iterator end() const { return Iterator(value, count); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator end() const { return Iterator(value, count); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "cmsg"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_NXTHDR",
          "args": [
            "&msg",
            "cmsg"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMSG_FIRSTHDR",
          "args": [
            "&msg"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ancillaryList.resize",
          "args": [
            "0"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "96-104",
          "snippet": "inline void resize(size_t size) {\n    if (size > builder.capacity()) grow(size);\n    while (builder.size() < size) {\n      builder.add(T());\n    }\n    while (builder.size() > size) {\n      builder.removeLast();\n    }\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline void resize(size_t size) {\n      if (size > builder.capacity()) grow(size);\n      while (builder.size() < size) {\n        builder.add(T());\n      }\n      while (builder.size() > size) {\n        builder.removeLast();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "source.emplace",
          "args": [
            "port.lowLevel",
            "msg.msg_name",
            "msg.msg_namelen"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.observer.whenBecomesReadable",
          "args": [
            "[this]() {\n        return receive();\n      }"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.observer.whenBecomesReadable",
          "args": [],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = recvmsg(port.fd, &msg, 0)"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvmsg",
          "args": [
            "port.fd",
            "&msg",
            "0"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ancillaryBuffer.size",
          "args": [],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ancillaryBuffer.begin",
          "args": [],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nPromise<void> receive() override {\n    struct msghdr msg;\n    memset(&msg, 0, sizeof(msg));\n\n    struct sockaddr_storage addr;\n    memset(&addr, 0, sizeof(addr));\n    msg.msg_name = &addr;\n    msg.msg_namelen = sizeof(addr);\n\n    struct iovec iov;\n    iov.iov_base = contentBuffer.begin();\n    iov.iov_len = contentBuffer.size();\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    msg.msg_control = ancillaryBuffer.begin();\n    msg.msg_controllen = ancillaryBuffer.size();\n\n    ssize_t n;\n    KJ_NONBLOCKING_SYSCALL(n = recvmsg(port.fd, &msg, 0));\n\n    if (n < 0) {\n      // No data available. Wait.\n      return port.observer.whenBecomesReadable().then([this]() {\n        return receive();\n      });\n    } else {\n      receivedSize = n;\n      contentTruncated = msg.msg_flags & MSG_TRUNC;\n\n      source.emplace(port.lowLevel, msg.msg_name, msg.msg_namelen);\n\n      ancillaryList.resize(0);\n      ancillaryTruncated = msg.msg_flags & MSG_CTRUNC;\n\n      for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg); cmsg != nullptr;\n           cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n        // On some platforms (OSX), a cmsghdr's length may cross the end of the ancillary buffer\n        // when truncated. On other platforms (Linux) the length in cmsghdr will itself be\n        // truncated to fit within the buffer.\n\n        const byte* pos = reinterpret_cast<const byte*>(cmsg);\n        size_t available = ancillaryBuffer.end() - pos;\n        if (available < CMSG_SPACE(0)) {\n          // The buffer ends in the middle of the header. We can't use this message.\n          // (On Linux, this never happens, because the message is not included if there isn't\n          // space for a header. I'm not sure how other systems behave, though, so let's be safe.)\n          break;\n        }\n\n        // OK, we know the cmsghdr is valid, at least.\n\n        // Find the start of the message payload.\n        const byte* begin = CMSG_DATA(cmsg);\n\n        // Cap the message length to the available space.\n        const byte* end = pos + kj::min(available, cmsg->cmsg_len);\n\n        ancillaryList.add(AncillaryMessage(\n            cmsg->cmsg_level, cmsg->cmsg_type, arrayPtr(begin, end)));\n      }\n\n      return READY_NOW;\n    }\n  }"
  },
  {
    "function_name": "ReceiverImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1161-1165",
    "snippet": "explicit ReceiverImpl(DatagramPortImpl& port, Capacity capacity)\n      : port(port),\n        contentBuffer(heapArray<byte>(capacity.content)),\n        ancillaryBuffer(capacity.ancillary > 0 ? heapArray<byte>(capacity.ancillary)\n                                               : Array<byte>(nullptr)) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Array<byte>",
          "args": [
            "nullptr"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayPtr",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1121-1121",
          "snippet": "inline constexpr ArrayPtr(T (&native)[size]): ptr(native), size_(size) {}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline constexpr ArrayPtr(T (&native)[size]): ptr(native), size_(size) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapArray<byte>",
          "args": [
            "capacity.ancillary"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nexplicit ReceiverImpl(DatagramPortImpl& port, Capacity capacity)\n      : port(port),\n        contentBuffer(heapArray<byte>(capacity.content)),\n        ancillaryBuffer(capacity.ancillary > 0 ? heapArray<byte>(capacity.ancillary)\n                                               : Array<byte>(nullptr)) {}"
  },
  {
    "function_name": "DatagramPortImpl::send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1106-1157",
    "snippet": "Promise<size_t> DatagramPortImpl::send(\n    ArrayPtr<const ArrayPtr<const byte>> pieces, NetworkAddress& destination) {\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  auto& addr = downcast<NetworkAddressImpl>(destination).chooseOneAddress();\n  msg.msg_name = const_cast<void*>(implicitCast<const void*>(addr.getRaw()));\n  msg.msg_namelen = addr.getRawSize();\n\n  KJ_STACK_ARRAY(struct iovec, iov, kj::min(pieces.size(), IOV_MAX), 16, 64);\n\n  for (size_t i: kj::indices(pieces)) {\n    iov[i].iov_base = const_cast<void*>(implicitCast<const void*>(pieces[i].begin()));\n    iov[i].iov_len = pieces[i].size();\n  }\n\n  Array<byte> extra;\n  if (pieces.size() > IOV_MAX) {\n    // Too many pieces, but we can't use multiple syscalls because they'd send separate\n    // datagrams. We'll have to copy the trailing pieces into a temporary array.\n    //\n    // TODO(perf): On Linux we could use multiple syscalls via MSG_MORE.\n    size_t extraSize = 0;\n    for (size_t i = IOV_MAX - 1; i < pieces.size(); i++) {\n      extraSize += pieces[i].size();\n    }\n    extra = kj::heapArray<byte>(extraSize);\n    extraSize = 0;\n    for (size_t i = IOV_MAX - 1; i < pieces.size(); i++) {\n      memcpy(extra.begin() + extraSize, pieces[i].begin(), pieces[i].size());\n      extraSize += pieces[i].size();\n    }\n    iov[IOV_MAX - 1].iov_base = extra.begin();\n    iov[IOV_MAX - 1].iov_len = extra.size();\n  }\n\n  msg.msg_iov = iov.begin();\n  msg.msg_iovlen = iov.size();\n\n  ssize_t n;\n  KJ_NONBLOCKING_SYSCALL(n = sendmsg(fd, &msg, 0));\n  if (n < 0) {\n    // Write buffer full.\n    return observer.whenBecomesWritable().then([this, pieces, &destination]() {\n      return send(pieces, destination);\n    });\n  } else {\n    // If less than the whole message was sent, then it was truncated, and there's nothing we can\n    // do about that now.\n    return n;\n  }\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [
      "#define IOV_MAX UIO_MAXIOV"
    ],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [
            "[this, pieces, &destination]() {\n      return send(pieces, destination);\n    }"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "pieces",
            "destination"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "send",
          "container": "LocalRequest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/capability.c++",
          "lines": "207-241",
          "snippet": "RemotePromise<AnyPointer> send() override {\n    KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n\n    // For the lambda capture.\n    uint64_t interfaceId = this->interfaceId;\n    uint16_t methodId = this->methodId;\n\n    auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n\n    auto context = kj::refcounted<LocalCallContext>(\n        kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n    auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n\n    // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n    // so that if the client drops their copy, the promise isn't necessarily canceled.\n    auto forked = promiseAndPipeline.promise.fork();\n\n    // We daemonize one branch, but only after joining it with the promise that fires if\n    // cancellation is allowed.\n    forked.addBranch()\n        .attach(kj::addRef(*context))\n        .exclusiveJoin(kj::mv(cancelPaf.promise))\n        .detach([](kj::Exception&&) {});  // ignore exceptions\n\n    // Now the other branch returns the response from the context.\n    auto promise = forked.addBranch().then(kj::mvCapture(context,\n        [](kj::Own<LocalCallContext>&& context) {\n      context->getResults(MessageSize { 0, 0 });  // force response allocation\n      return kj::mv(KJ_ASSERT_NONNULL(context->response));\n    }));\n\n    // We return the other branch.\n    return RemotePromise<AnyPointer>(\n        kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n  }",
          "includes": [
            "#include \"generated-header-support.h\"",
            "#include <map>",
            "#include <kj/vector.h>",
            "#include <kj/debug.h>",
            "#include <kj/refcount.h>",
            "#include \"arena.h\"",
            "#include \"message.h\"",
            "#include \"capability.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kj::Maybe<kj::Own<MallocMessageBuilder>> request;",
            "kj::Maybe<Response<AnyPointer>> response;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"generated-header-support.h\"\n#include <map>\n#include <kj/vector.h>\n#include <kj/debug.h>\n#include <kj/refcount.h>\n#include \"arena.h\"\n#include \"message.h\"\n#include \"capability.h\"\n\nkj::Maybe<kj::Own<MallocMessageBuilder>> request;\nkj::Maybe<Response<AnyPointer>> response;\n\nLocalRequest {\n  RemotePromise<AnyPointer> send() override {\n      KJ_REQUIRE(message.get() != nullptr, \"Already called send() on this request.\");\n  \n      // For the lambda capture.\n      uint64_t interfaceId = this->interfaceId;\n      uint16_t methodId = this->methodId;\n  \n      auto cancelPaf = kj::newPromiseAndFulfiller<void>();\n  \n      auto context = kj::refcounted<LocalCallContext>(\n          kj::mv(message), client->addRef(), kj::mv(cancelPaf.fulfiller));\n      auto promiseAndPipeline = client->call(interfaceId, methodId, kj::addRef(*context));\n  \n      // We have to make sure the call is not canceled unless permitted.  We need to fork the promise\n      // so that if the client drops their copy, the promise isn't necessarily canceled.\n      auto forked = promiseAndPipeline.promise.fork();\n  \n      // We daemonize one branch, but only after joining it with the promise that fires if\n      // cancellation is allowed.\n      forked.addBranch()\n          .attach(kj::addRef(*context))\n          .exclusiveJoin(kj::mv(cancelPaf.promise))\n          .detach([](kj::Exception&&) {});  // ignore exceptions\n  \n      // Now the other branch returns the response from the context.\n      auto promise = forked.addBranch().then(kj::mvCapture(context,\n          [](kj::Own<LocalCallContext>&& context) {\n        context->getResults(MessageSize { 0, 0 });  // force response allocation\n        return kj::mv(KJ_ASSERT_NONNULL(context->response));\n      }));\n  \n      // We return the other branch.\n      return RemotePromise<AnyPointer>(\n          kj::mv(promise), AnyPointer::Pipeline(kj::mv(promiseAndPipeline.pipeline)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = sendmsg(fd, &msg, 0)"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendmsg",
          "args": [
            "fd",
            "&msg",
            "0"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov.size",
          "args": [],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov.begin",
          "args": [],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "extra.begin() + extraSize",
            "pieces[i].begin()",
            "pieces[i].size()"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray<byte>",
          "args": [
            "extraSize"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<void*>",
          "args": [
            "implicitCast<const void*>(pieces[i].begin())"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "implicitCast<const void*>",
          "args": [
            "pieces[i].begin()"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "implicitCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1203-1207",
          "snippet": "To implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nTo implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.getRawSize",
          "args": [],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "getRawSize",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "390-390",
          "snippet": "socklen_t getRawSize() const { return addrlen; }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "socklen_t addrlen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\n\nSocketAddress {\n  socklen_t getRawSize() const { return addrlen; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<void*>",
          "args": [
            "implicitCast<const void*>(addr.getRaw())"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.getRaw",
          "args": [],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "getRaw",
          "container": "DynamicEnum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "149-149",
          "snippet": "inline uint16_t getRaw() const { return value; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\nDynamicEnum {\n  inline uint16_t getRaw() const { return value; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcast<NetworkAddressImpl>",
          "args": [],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "downcast",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "154-166",
          "snippet": "Own<U> downcast() {\n    // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n    // actually point at an instance of U, the results are undefined (throws an exception in debug\n    // mode if RTTI is enabled, otherwise you're on your own).\n\n    Own<U> result;\n    if (ptr != nullptr) {\n      result.ptr = &kj::downcast<U>(*ptr);\n      result.disposer = disposer;\n      ptr = nullptr;\n    }\n    return result;\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  Own<U> downcast() {\n      // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n      // actually point at an instance of U, the results are undefined (throws an exception in debug\n      // mode if RTTI is enabled, otherwise you're on your own).\n  \n      Own<U> result;\n      if (ptr != nullptr) {\n        result.ptr = &kj::downcast<U>(*ptr);\n        result.disposer = disposer;\n        ptr = nullptr;\n      }\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcast<NetworkAddressImpl>",
          "args": [
            "destination"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\n#define IOV_MAX UIO_MAXIOV\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nPromise<size_t> DatagramPortImpl::send(\n    ArrayPtr<const ArrayPtr<const byte>> pieces, NetworkAddress& destination) {\n  struct msghdr msg;\n  memset(&msg, 0, sizeof(msg));\n\n  auto& addr = downcast<NetworkAddressImpl>(destination).chooseOneAddress();\n  msg.msg_name = const_cast<void*>(implicitCast<const void*>(addr.getRaw()));\n  msg.msg_namelen = addr.getRawSize();\n\n  KJ_STACK_ARRAY(struct iovec, iov, kj::min(pieces.size(), IOV_MAX), 16, 64);\n\n  for (size_t i: kj::indices(pieces)) {\n    iov[i].iov_base = const_cast<void*>(implicitCast<const void*>(pieces[i].begin()));\n    iov[i].iov_len = pieces[i].size();\n  }\n\n  Array<byte> extra;\n  if (pieces.size() > IOV_MAX) {\n    // Too many pieces, but we can't use multiple syscalls because they'd send separate\n    // datagrams. We'll have to copy the trailing pieces into a temporary array.\n    //\n    // TODO(perf): On Linux we could use multiple syscalls via MSG_MORE.\n    size_t extraSize = 0;\n    for (size_t i = IOV_MAX - 1; i < pieces.size(); i++) {\n      extraSize += pieces[i].size();\n    }\n    extra = kj::heapArray<byte>(extraSize);\n    extraSize = 0;\n    for (size_t i = IOV_MAX - 1; i < pieces.size(); i++) {\n      memcpy(extra.begin() + extraSize, pieces[i].begin(), pieces[i].size());\n      extraSize += pieces[i].size();\n    }\n    iov[IOV_MAX - 1].iov_base = extra.begin();\n    iov[IOV_MAX - 1].iov_len = extra.size();\n  }\n\n  msg.msg_iov = iov.begin();\n  msg.msg_iovlen = iov.size();\n\n  ssize_t n;\n  KJ_NONBLOCKING_SYSCALL(n = sendmsg(fd, &msg, 0));\n  if (n < 0) {\n    // Write buffer full.\n    return observer.whenBecomesWritable().then([this, pieces, &destination]() {\n      return send(pieces, destination);\n    });\n  } else {\n    // If less than the whole message was sent, then it was truncated, and there's nothing we can\n    // do about that now.\n    return n;\n  }\n}"
  },
  {
    "function_name": "DatagramPortImpl::send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1088-1104",
    "snippet": "Promise<size_t> DatagramPortImpl::send(\n    const void* buffer, size_t size, NetworkAddress& destination) {\n  auto& addr = downcast<NetworkAddressImpl>(destination).chooseOneAddress();\n\n  ssize_t n;\n  KJ_NONBLOCKING_SYSCALL(n = sendto(fd, buffer, size, 0, addr.getRaw(), addr.getRawSize()));\n  if (n < 0) {\n    // Write buffer full.\n    return observer.whenBecomesWritable().then([this, buffer, size, &destination]() {\n      return send(buffer, size, destination);\n    });\n  } else {\n    // If less than the whole message was sent, then it got truncated, and there's nothing we can\n    // do about it.\n    return n;\n  }\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [
            "[this, buffer, size, &destination]() {\n      return send(buffer, size, destination);\n    }"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_NONBLOCKING_SYSCALL",
          "args": [
            "n = sendto(fd, buffer, size, 0, addr.getRaw(), addr.getRawSize())"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendto",
          "args": [
            "fd",
            "buffer",
            "size",
            "0",
            "addr.getRaw()",
            "addr.getRawSize()"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.getRawSize",
          "args": [],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "getRawSize",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "390-390",
          "snippet": "socklen_t getRawSize() const { return addrlen; }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "socklen_t addrlen;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\n\nSocketAddress {\n  socklen_t getRawSize() const { return addrlen; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.getRaw",
          "args": [],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "getRaw",
          "container": "DynamicEnum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/dynamic.h",
          "lines": "149-149",
          "snippet": "inline uint16_t getRaw() const { return value; }",
          "includes": [
            "#include \"capability.h\"",
            "#include \"any.h\"",
            "#include \"message.h\"",
            "#include \"layout.h\"",
            "#include \"schema.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability.h\"\n#include \"any.h\"\n#include \"message.h\"\n#include \"layout.h\"\n#include \"schema.h\"\n\nDynamicEnum {\n  inline uint16_t getRaw() const { return value; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcast<NetworkAddressImpl>",
          "args": [],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "downcast",
          "container": "Own",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "154-166",
          "snippet": "Own<U> downcast() {\n    // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n    // actually point at an instance of U, the results are undefined (throws an exception in debug\n    // mode if RTTI is enabled, otherwise you're on your own).\n\n    Own<U> result;\n    if (ptr != nullptr) {\n      result.ptr = &kj::downcast<U>(*ptr);\n      result.disposer = disposer;\n      ptr = nullptr;\n    }\n    return result;\n  }",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn {\n  Own<U> downcast() {\n      // Downcast the pointer to Own<U>, destroying the original pointer.  If this pointer does not\n      // actually point at an instance of U, the results are undefined (throws an exception in debug\n      // mode if RTTI is enabled, otherwise you're on your own).\n  \n      Own<U> result;\n      if (ptr != nullptr) {\n        result.ptr = &kj::downcast<U>(*ptr);\n        result.disposer = disposer;\n        ptr = nullptr;\n      }\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "downcast<NetworkAddressImpl>",
          "args": [
            "destination"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nPromise<size_t> DatagramPortImpl::send(\n    const void* buffer, size_t size, NetworkAddress& destination) {\n  auto& addr = downcast<NetworkAddressImpl>(destination).chooseOneAddress();\n\n  ssize_t n;\n  KJ_NONBLOCKING_SYSCALL(n = sendto(fd, buffer, size, 0, addr.getRaw(), addr.getRawSize()));\n  if (n < 0) {\n    // Write buffer full.\n    return observer.whenBecomesWritable().then([this, buffer, size, &destination]() {\n      return send(buffer, size, destination);\n    });\n  } else {\n    // If less than the whole message was sent, then it got truncated, and there's nothing we can\n    // do about it.\n    return n;\n  }\n}"
  },
  {
    "function_name": "getSockaddr",
    "container": "SocketNetwork",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1076-1080",
    "snippet": "Own<NetworkAddress> getSockaddr(const void* sockaddr, uint len) override {\n    auto array = kj::heapArrayBuilder<SocketAddress>(1);\n    array.add(SocketAddress(sockaddr, len));\n    return Own<NetworkAddress>(heap<NetworkAddressImpl>(lowLevel, array.finish()));\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Own<NetworkAddress>",
          "args": [
            "heap<NetworkAddressImpl>(lowLevel, array.finish())"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "OwnOwn",
          "container": "OwnOwn",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "207-207",
          "snippet": "inline OwnOwn(Own<T>&& value) noexcept: value(kj::mv(value)) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwnOwn {\n  inline OwnOwn(Own<T>&& value) noexcept: value(kj::mv(value)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap<NetworkAddressImpl>",
          "args": [
            "lowLevel",
            "array.finish()"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array.finish",
          "args": [],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "array.add",
          "args": [
            "SocketAddress(sockaddr, len)"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SocketAddress",
          "args": [
            "sockaddr",
            "len"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "550-558",
          "snippet": "KJ_IF_MAYBE(portText, portPart) {\n      char* endptr;\n      port = strtoul(portText->cStr(), &endptr, 0);\n      if (portText->size() == 0 || *endptr != '\\0') {\n        // Not a number.  Maybe it's a service name.  Fall back to DNS.\n        return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n      }\n      KJ_REQUIRE(port < 65536, \"Port number too large.\");\n    }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nSocketAddress {\n  KJ_IF_MAYBE(portText, portPart) {\n        char* endptr;\n        port = strtoul(portText->cStr(), &endptr, 0);\n        if (portText->size() == 0 || *endptr != '\\0') {\n          // Not a number.  Maybe it's a service name.  Fall back to DNS.\n          return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n        }\n        KJ_REQUIRE(port < 65536, \"Port number too large.\");\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<SocketAddress>",
          "args": [
            "1"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nSocketNetwork {\n  Own<NetworkAddress> getSockaddr(const void* sockaddr, uint len) override {\n      auto array = kj::heapArrayBuilder<SocketAddress>(1);\n      array.add(SocketAddress(sockaddr, len));\n      return Own<NetworkAddress>(heap<NetworkAddressImpl>(lowLevel, array.finish()));\n    }\n}"
  },
  {
    "function_name": "parseAddress",
    "container": "SocketNetwork",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1066-1074",
    "snippet": "Promise<Own<NetworkAddress>> parseAddress(StringPtr addr, uint portHint = 0) override {\n    auto& lowLevelCopy = lowLevel;\n    return evalLater(mvCapture(heapString(addr),\n        [&lowLevelCopy,portHint](String&& addr) {\n      return SocketAddress::parse(lowLevelCopy, addr, portHint);\n    })).then([&lowLevelCopy](Array<SocketAddress> addresses) -> Own<NetworkAddress> {\n      return heap<NetworkAddressImpl>(lowLevelCopy, kj::mv(addresses));\n    });\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evalLater",
          "args": [
            "[&lowLevelCopy](Array<SocketAddress> addresses) -> Own<NetworkAddress> {\n      return heap<NetworkAddressImpl>(lowLevelCopy, kj::mv(addresses));\n    }"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "evalLater",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-inl.h",
          "lines": "786-788",
          "snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "inline PromiseForResult<Func, void> evalLater(Func&& func) {\n  return _::yield().then(kj::fwd<Func>(func), _::PropagateException());\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap<NetworkAddressImpl>",
          "args": [
            "lowLevelCopy",
            "kj::mv(addresses)"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "addresses"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mvCapture",
          "args": [
            "heapString(addr)",
            "[&lowLevelCopy,portHint](String&& addr) {\n      return SocketAddress::parse(lowLevelCopy, addr, portHint);\n    }"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SocketAddress::parse",
          "args": [
            "lowLevelCopy",
            "addr",
            "portHint"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "490-546",
          "snippet": "static Promise<Array<SocketAddress>> parse(\n      LowLevelAsyncIoProvider& lowLevel, StringPtr str, uint portHint) {\n    // TODO(someday):  Allow commas in `str`.\n\n    SocketAddress result;\n\n    if (str.startsWith(\"unix:\")) {\n      StringPtr path = str.slice(strlen(\"unix:\"));\n      KJ_REQUIRE(path.size() < sizeof(addr.unixDomain.sun_path),\n                 \"Unix domain socket address is too long.\", str);\n      result.addr.unixDomain.sun_family = AF_UNIX;\n      strcpy(result.addr.unixDomain.sun_path, path.cStr());\n      result.addrlen = offsetof(struct sockaddr_un, sun_path) + path.size() + 1;\n      auto array = kj::heapArrayBuilder<SocketAddress>(1);\n      array.add(result);\n      return array.finish();\n    }\n\n    // Try to separate the address and port.\n    ArrayPtr<const char> addrPart;\n    Maybe<StringPtr> portPart;\n\n    int af;\n\n    if (str.startsWith(\"[\")) {\n      // Address starts with a bracket, which is a common way to write an ip6 address with a port,\n      // since without brackets around the address part, the port looks like another segment of\n      // the address.\n      af = AF_INET6;\n      size_t closeBracket = KJ_ASSERT_NONNULL(str.findLast(']'),\n          \"Unclosed '[' in address string.\", str);\n\n      addrPart = str.slice(1, closeBracket);\n      if (str.size() > closeBracket + 1) {\n        KJ_REQUIRE(str.slice(closeBracket + 1).startsWith(\":\"),\n                   \"Expected port suffix after ']'.\", str);\n        portPart = str.slice(closeBracket + 2);\n      }\n    } else {\n      KJ_IF_MAYBE(colon, str.findFirst(':')) {\n        if (str.slice(*colon + 1).findFirst(':') == nullptr) {\n          // There is exactly one colon and no brackets, so it must be an ip4 address with port.\n          af = AF_INET;\n          addrPart = str.slice(0, *colon);\n          portPart = str.slice(*colon + 1);\n        } else {\n          // There are two or more colons and no brackets, so the whole thing must be an ip6\n          // address with no port.\n          af = AF_INET6;\n          addrPart = str;\n        }\n      } else {\n        // No colons, so it must be an ip4 address without port.\n        af = AF_INET;\n        addrPart = str;\n      }\n    }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "socklen_t addrlen;",
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  static Promise<Array<SocketAddress>> parse(\n        LowLevelAsyncIoProvider& lowLevel, StringPtr str, uint portHint) {\n      // TODO(someday):  Allow commas in `str`.\n  \n      SocketAddress result;\n  \n      if (str.startsWith(\"unix:\")) {\n        StringPtr path = str.slice(strlen(\"unix:\"));\n        KJ_REQUIRE(path.size() < sizeof(addr.unixDomain.sun_path),\n                   \"Unix domain socket address is too long.\", str);\n        result.addr.unixDomain.sun_family = AF_UNIX;\n        strcpy(result.addr.unixDomain.sun_path, path.cStr());\n        result.addrlen = offsetof(struct sockaddr_un, sun_path) + path.size() + 1;\n        auto array = kj::heapArrayBuilder<SocketAddress>(1);\n        array.add(result);\n        return array.finish();\n      }\n  \n      // Try to separate the address and port.\n      ArrayPtr<const char> addrPart;\n      Maybe<StringPtr> portPart;\n  \n      int af;\n  \n      if (str.startsWith(\"[\")) {\n        // Address starts with a bracket, which is a common way to write an ip6 address with a port,\n        // since without brackets around the address part, the port looks like another segment of\n        // the address.\n        af = AF_INET6;\n        size_t closeBracket = KJ_ASSERT_NONNULL(str.findLast(']'),\n            \"Unclosed '[' in address string.\", str);\n  \n        addrPart = str.slice(1, closeBracket);\n        if (str.size() > closeBracket + 1) {\n          KJ_REQUIRE(str.slice(closeBracket + 1).startsWith(\":\"),\n                     \"Expected port suffix after ']'.\", str);\n          portPart = str.slice(closeBracket + 2);\n        }\n      } else {\n        KJ_IF_MAYBE(colon, str.findFirst(':')) {\n          if (str.slice(*colon + 1).findFirst(':') == nullptr) {\n            // There is exactly one colon and no brackets, so it must be an ip4 address with port.\n            af = AF_INET;\n            addrPart = str.slice(0, *colon);\n            portPart = str.slice(*colon + 1);\n          } else {\n            // There are two or more colons and no brackets, so the whole thing must be an ip6\n            // address with no port.\n            af = AF_INET6;\n            addrPart = str;\n          }\n        } else {\n          // No colons, so it must be an ip4 address without port.\n          af = AF_INET;\n          addrPart = str;\n        }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "addr"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketNetwork {\n  Promise<Own<NetworkAddress>> parseAddress(StringPtr addr, uint portHint = 0) override {\n      auto& lowLevelCopy = lowLevel;\n      return evalLater(mvCapture(heapString(addr),\n          [&lowLevelCopy,portHint](String&& addr) {\n        return SocketAddress::parse(lowLevelCopy, addr, portHint);\n      })).then([&lowLevelCopy](Array<SocketAddress> addresses) -> Own<NetworkAddress> {\n        return heap<NetworkAddressImpl>(lowLevelCopy, kj::mv(addresses));\n      });\n    }\n}"
  },
  {
    "function_name": "SocketNetwork",
    "container": "SocketNetwork",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1064-1064",
    "snippet": "explicit SocketNetwork(LowLevelAsyncIoProvider& lowLevel): lowLevel(lowLevel) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nSocketNetwork {\n  explicit SocketNetwork(LowLevelAsyncIoProvider& lowLevel): lowLevel(lowLevel) {}\n}"
  },
  {
    "function_name": "connectImpl",
    "container": "NetworkAddressImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1026-1059",
    "snippet": "Promise<Own<AsyncIoStream>> connectImpl(uint index) {\n    KJ_ASSERT(index < addrs.size());\n\n    int fd = addrs[index].socket(SOCK_STREAM);\n\n    KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n      addrs[index].connect(fd);\n    })) {\n      // Connect failed.\n      close(fd);\n      if (index + 1 < addrs.size()) {\n        // Try the next address instead.\n        return connectImpl(index + 1);\n      } else {\n        // No more addresses to try, so propagate the exception.\n        return kj::mv(*exception);\n      }\n    }\n\n    return lowLevel.wrapConnectingSocketFd(fd, NEW_FD_FLAGS).then(\n        [](Own<AsyncIoStream>&& stream) -> Promise<Own<AsyncIoStream>> {\n      // Success, pass along.\n      return kj::mv(stream);\n    }, [this,index](Exception&& exception) -> Promise<Own<AsyncIoStream>> {\n      // Connect failed.\n      if (index + 1 < addrs.size()) {\n        // Try the next address instead.\n        return connectImpl(index + 1);\n      } else {\n        // No more addresses to try, so propagate the exception.\n        return kj::mv(exception);\n      }\n    });\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lowLevel.wrapConnectingSocketFd",
          "args": [
            "[](Own<AsyncIoStream>&& stream) -> Promise<Own<AsyncIoStream>> {\n      // Success, pass along.\n      return kj::mv(stream);\n    }",
            "[this,index](Exception&& exception) -> Promise<Own<AsyncIoStream>> {\n      // Connect failed.\n      if (index + 1 < addrs.size()) {\n        // Try the next address instead.\n        return connectImpl(index + 1);\n      } else {\n        // No more addresses to try, so propagate the exception.\n        return kj::mv(exception);\n      }\n    }"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "wrapConnectingSocketFd",
          "container": "LowLevelAsyncIoProviderImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "916-929",
          "snippet": "Promise<Own<AsyncIoStream>> wrapConnectingSocketFd(int fd, uint flags = 0) override {\n    auto result = heap<AsyncStreamFd>(eventPort, fd, flags);\n\n    auto connected = result->waitConnected();\n    return connected.then(kj::mvCapture(result, [fd](Own<AsyncIoStream>&& stream) {\n      int err;\n      socklen_t errlen = sizeof(err);\n      KJ_SYSCALL(getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen));\n      if (err != 0) {\n        KJ_FAIL_SYSCALL(\"connect()\", err) { break; }\n      }\n      return kj::mv(stream);\n    }));\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLowLevelAsyncIoProviderImpl {\n  Promise<Own<AsyncIoStream>> wrapConnectingSocketFd(int fd, uint flags = 0) override {\n      auto result = heap<AsyncStreamFd>(eventPort, fd, flags);\n  \n      auto connected = result->waitConnected();\n      return connected.then(kj::mvCapture(result, [fd](Own<AsyncIoStream>&& stream) {\n        int err;\n        socklen_t errlen = sizeof(err);\n        KJ_SYSCALL(getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen));\n        if (err != 0) {\n          KJ_FAIL_SYSCALL(\"connect()\", err) { break; }\n        }\n        return kj::mv(stream);\n      }));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "exception"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectImpl",
          "args": [
            "index + 1"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrs.size",
          "args": [],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "*exception"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connectImpl",
          "args": [
            "index + 1"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "exception",
            "kj::runCatchingExceptions([&]() {\n      addrs[index].connect(fd);\n    })"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "550-558",
          "snippet": "KJ_IF_MAYBE(portText, portPart) {\n      char* endptr;\n      port = strtoul(portText->cStr(), &endptr, 0);\n      if (portText->size() == 0 || *endptr != '\\0') {\n        // Not a number.  Maybe it's a service name.  Fall back to DNS.\n        return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n      }\n      KJ_REQUIRE(port < 65536, \"Port number too large.\");\n    }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nSocketAddress {\n  KJ_IF_MAYBE(portText, portPart) {\n        char* endptr;\n        port = strtoul(portText->cStr(), &endptr, 0);\n        if (portText->size() == 0 || *endptr != '\\0') {\n          // Not a number.  Maybe it's a service name.  Fall back to DNS.\n          return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n        }\n        KJ_REQUIRE(port < 65536, \"Port number too large.\");\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::runCatchingExceptions",
          "args": [
            "[&]() {\n      addrs[index].connect(fd);\n    }"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrs[index].connect",
          "args": [
            "fd"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "connect",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "427-446",
          "snippet": "void connect(int sockfd) const {\n    // Unfortunately connect() doesn't fit the mold of KJ_NONBLOCKING_SYSCALL, since it indicates\n    // non-blocking using EINPROGRESS.\n    for (;;) {\n      if (::connect(sockfd, &addr.generic, addrlen) < 0) {\n        int error = errno;\n        if (error == EINPROGRESS) {\n          return;\n        } else if (error != EINTR) {\n          KJ_FAIL_SYSCALL(\"connect()\", error, toString()) {\n            // Recover by returning, since reads/writes will simply fail.\n            return;\n          }\n        }\n      } else {\n        // no error\n        return;\n      }\n    }\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "socklen_t addrlen;",
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  void connect(int sockfd) const {\n      // Unfortunately connect() doesn't fit the mold of KJ_NONBLOCKING_SYSCALL, since it indicates\n      // non-blocking using EINPROGRESS.\n      for (;;) {\n        if (::connect(sockfd, &addr.generic, addrlen) < 0) {\n          int error = errno;\n          if (error == EINPROGRESS) {\n            return;\n          } else if (error != EINTR) {\n            KJ_FAIL_SYSCALL(\"connect()\", error, toString()) {\n              // Recover by returning, since reads/writes will simply fail.\n              return;\n            }\n          }\n        } else {\n          // no error\n          return;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrs[index].socket",
          "args": [
            "SOCK_STREAM"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "392-414",
          "snippet": "int socket(int type) const {\n    bool isStream = type == SOCK_STREAM;\n\n    int result;\n#if __linux__ && !__BIONIC__\n    type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n#endif\n    KJ_SYSCALL(result = ::socket(addr.generic.sa_family, type, 0));\n\n    if (isStream && (addr.generic.sa_family == AF_INET ||\n                     addr.generic.sa_family == AF_INET6)) {\n      // TODO(perf):  As a hack for the 0.4 release we are always setting\n      //   TCP_NODELAY because Nagle's algorithm pretty much kills Cap'n Proto's\n      //   RPC protocol.  Later, we should extend the interface to provide more\n      //   control over this.  Perhaps write() should have a flag which\n      //   specifies whether to pass MSG_MORE.\n      int one = 1;\n      KJ_SYSCALL(setsockopt(\n          result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one)));\n    }\n\n    return result;\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  int socket(int type) const {\n      bool isStream = type == SOCK_STREAM;\n  \n      int result;\n  #if __linux__ && !__BIONIC__\n      type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n  #endif\n      KJ_SYSCALL(result = ::socket(addr.generic.sa_family, type, 0));\n  \n      if (isStream && (addr.generic.sa_family == AF_INET ||\n                       addr.generic.sa_family == AF_INET6)) {\n        // TODO(perf):  As a hack for the 0.4 release we are always setting\n        //   TCP_NODELAY because Nagle's algorithm pretty much kills Cap'n Proto's\n        //   RPC protocol.  Later, we should extend the interface to provide more\n        //   control over this.  Perhaps write() should have a flag which\n        //   specifies whether to pass MSG_MORE.\n        int one = 1;\n        KJ_SYSCALL(setsockopt(\n            result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one)));\n      }\n  \n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT",
          "args": [
            "index < addrs.size()"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connectImpl(uint index) {\n      KJ_ASSERT(index < addrs.size());\n  \n      int fd = addrs[index].socket(SOCK_STREAM);\n  \n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n        addrs[index].connect(fd);\n      })) {\n        // Connect failed.\n        close(fd);\n        if (index + 1 < addrs.size()) {\n          // Try the next address instead.\n          return connectImpl(index + 1);\n        } else {\n          // No more addresses to try, so propagate the exception.\n          return kj::mv(*exception);\n        }\n      }\n  \n      return lowLevel.wrapConnectingSocketFd(fd, NEW_FD_FLAGS).then(\n          [](Own<AsyncIoStream>&& stream) -> Promise<Own<AsyncIoStream>> {\n        // Success, pass along.\n        return kj::mv(stream);\n      }, [this,index](Exception&& exception) -> Promise<Own<AsyncIoStream>> {\n        // Connect failed.\n        if (index + 1 < addrs.size()) {\n          // Try the next address instead.\n          return connectImpl(index + 1);\n        } else {\n          // No more addresses to try, so propagate the exception.\n          return kj::mv(exception);\n        }\n      });\n    }\n}"
  },
  {
    "function_name": "toString",
    "container": "NetworkAddressImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1012-1014",
    "snippet": "String toString() override {\n    return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strArray",
          "args": [
            "KJ_MAP(addr, addrs){ return addr.toString(); }",
            "\",\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_MAP",
          "args": [
            "addr",
            "addrs"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nNetworkAddressImpl {\n  String toString() override {\n      return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n    }\n}"
  },
  {
    "function_name": "clone",
    "container": "NetworkAddressImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "1008-1010",
    "snippet": "Own<NetworkAddress> clone() override {\n    return kj::heap<NetworkAddressImpl>(lowLevel, kj::heapArray(addrs.asPtr()));\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::heap<NetworkAddressImpl>",
          "args": [
            "lowLevel",
            "kj::heapArray(addrs.asPtr())"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapArray",
          "args": [
            "addrs.asPtr()"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "heapArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "696-698",
          "snippet": "inline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline Array<T> heapArray(std::initializer_list<T> init) {\n  return heapArray<T>(init.begin(), init.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrs.asPtr",
          "args": [],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "asPtr",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "313-315",
          "snippet": "inline ArrayPtr<const T> asPtr() const {\n    return arrayPtr(ptr, pos);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  inline ArrayPtr<const T> asPtr() const {\n      return arrayPtr(ptr, pos);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Own<NetworkAddress> clone() override {\n      return kj::heap<NetworkAddressImpl>(lowLevel, kj::heapArray(addrs.asPtr()));\n    }\n}"
  },
  {
    "function_name": "bindDatagramPort",
    "container": "NetworkAddressImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "985-1006",
    "snippet": "Own<DatagramPort> bindDatagramPort() override {\n    if (addrs.size() > 1) {\n      KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n          \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n          \"in the future.\", addrs[0].toString());\n    }\n\n    int fd = addrs[0].socket(SOCK_DGRAM);\n\n    {\n      KJ_ON_SCOPE_FAILURE(close(fd));\n\n      // We always enable SO_REUSEADDR because having to take your server down for five minutes\n      // before it can restart really sucks.\n      int optval = 1;\n      KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n\n      addrs[0].bind(fd);\n    }\n\n    return lowLevel.wrapDatagramSocketFd(fd, NEW_FD_FLAGS);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lowLevel.wrapDatagramSocketFd",
          "args": [
            "fd",
            "NEW_FD_FLAGS"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrs[0].bind",
          "args": [
            "fd"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "bind",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "416-425",
          "snippet": "void bind(int sockfd) const {\n    if (wildcard) {\n      // Disable IPV6_V6ONLY because we want to handle both ipv4 and ipv6 on this socket.  (The\n      // default value of this option varies across platforms.)\n      int value = 0;\n      KJ_SYSCALL(setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &value, sizeof(value)));\n    }\n\n    KJ_SYSCALL(::bind(sockfd, &addr.generic, addrlen), toString());\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "socklen_t addrlen;",
            "bool wildcard = false;",
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nbool wildcard = false;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  void bind(int sockfd) const {\n      if (wildcard) {\n        // Disable IPV6_V6ONLY because we want to handle both ipv4 and ipv6 on this socket.  (The\n        // default value of this option varies across platforms.)\n        int value = 0;\n        KJ_SYSCALL(setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &value, sizeof(value)));\n      }\n  \n      KJ_SYSCALL(::bind(sockfd, &addr.generic, addrlen), toString());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval))"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "&optval",
            "sizeof(optval)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ON_SCOPE_FAILURE",
          "args": [
            "close(fd)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrs[0].socket",
          "args": [
            "SOCK_DGRAM"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "392-414",
          "snippet": "int socket(int type) const {\n    bool isStream = type == SOCK_STREAM;\n\n    int result;\n#if __linux__ && !__BIONIC__\n    type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n#endif\n    KJ_SYSCALL(result = ::socket(addr.generic.sa_family, type, 0));\n\n    if (isStream && (addr.generic.sa_family == AF_INET ||\n                     addr.generic.sa_family == AF_INET6)) {\n      // TODO(perf):  As a hack for the 0.4 release we are always setting\n      //   TCP_NODELAY because Nagle's algorithm pretty much kills Cap'n Proto's\n      //   RPC protocol.  Later, we should extend the interface to provide more\n      //   control over this.  Perhaps write() should have a flag which\n      //   specifies whether to pass MSG_MORE.\n      int one = 1;\n      KJ_SYSCALL(setsockopt(\n          result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one)));\n    }\n\n    return result;\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  int socket(int type) const {\n      bool isStream = type == SOCK_STREAM;\n  \n      int result;\n  #if __linux__ && !__BIONIC__\n      type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n  #endif\n      KJ_SYSCALL(result = ::socket(addr.generic.sa_family, type, 0));\n  \n      if (isStream && (addr.generic.sa_family == AF_INET ||\n                       addr.generic.sa_family == AF_INET6)) {\n        // TODO(perf):  As a hack for the 0.4 release we are always setting\n        //   TCP_NODELAY because Nagle's algorithm pretty much kills Cap'n Proto's\n        //   RPC protocol.  Later, we should extend the interface to provide more\n        //   control over this.  Perhaps write() should have a flag which\n        //   specifies whether to pass MSG_MORE.\n        int one = 1;\n        KJ_SYSCALL(setsockopt(\n            result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one)));\n      }\n  \n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"Bind address resolved to multiple addresses.  Only the first address will \"\n          \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n          \"in the future.\"",
            "addrs[0].toString()"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrs[0].toString",
          "args": [],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1012-1014",
          "snippet": "String toString() override {\n    return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nNetworkAddressImpl {\n  String toString() override {\n      return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrs.size",
          "args": [],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Own<DatagramPort> bindDatagramPort() override {\n      if (addrs.size() > 1) {\n        KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n            \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n            \"in the future.\", addrs[0].toString());\n      }\n  \n      int fd = addrs[0].socket(SOCK_DGRAM);\n  \n      {\n        KJ_ON_SCOPE_FAILURE(close(fd));\n  \n        // We always enable SO_REUSEADDR because having to take your server down for five minutes\n        // before it can restart really sucks.\n        int optval = 1;\n        KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n  \n        addrs[0].bind(fd);\n      }\n  \n      return lowLevel.wrapDatagramSocketFd(fd, NEW_FD_FLAGS);\n    }\n}"
  },
  {
    "function_name": "listen",
    "container": "NetworkAddressImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "959-983",
    "snippet": "Own<ConnectionReceiver> listen() override {\n    if (addrs.size() > 1) {\n      KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n          \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n          \"in the future.\", addrs[0].toString());\n    }\n\n    int fd = addrs[0].socket(SOCK_STREAM);\n\n    {\n      KJ_ON_SCOPE_FAILURE(close(fd));\n\n      // We always enable SO_REUSEADDR because having to take your server down for five minutes\n      // before it can restart really sucks.\n      int optval = 1;\n      KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n\n      addrs[0].bind(fd);\n\n      // TODO(someday):  Let queue size be specified explicitly in string addresses.\n      KJ_SYSCALL(::listen(fd, SOMAXCONN));\n    }\n\n    return lowLevel.wrapListenSocketFd(fd, NEW_FD_FLAGS);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lowLevel.wrapListenSocketFd",
          "args": [
            "fd",
            "NEW_FD_FLAGS"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::listen(fd, SOMAXCONN)"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::listen",
          "args": [
            "fd",
            "SOMAXCONN"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrs[0].bind",
          "args": [
            "fd"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "bind",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "416-425",
          "snippet": "void bind(int sockfd) const {\n    if (wildcard) {\n      // Disable IPV6_V6ONLY because we want to handle both ipv4 and ipv6 on this socket.  (The\n      // default value of this option varies across platforms.)\n      int value = 0;\n      KJ_SYSCALL(setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &value, sizeof(value)));\n    }\n\n    KJ_SYSCALL(::bind(sockfd, &addr.generic, addrlen), toString());\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "socklen_t addrlen;",
            "bool wildcard = false;",
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nbool wildcard = false;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  void bind(int sockfd) const {\n      if (wildcard) {\n        // Disable IPV6_V6ONLY because we want to handle both ipv4 and ipv6 on this socket.  (The\n        // default value of this option varies across platforms.)\n        int value = 0;\n        KJ_SYSCALL(setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &value, sizeof(value)));\n      }\n  \n      KJ_SYSCALL(::bind(sockfd, &addr.generic, addrlen), toString());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval))"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "fd",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "&optval",
            "sizeof(optval)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_ON_SCOPE_FAILURE",
          "args": [
            "close(fd)"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "57-59",
          "snippet": "inline int close(int fd) {\n  return ::_close(fd);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int close(int fd) {\n  return ::_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrs[0].socket",
          "args": [
            "SOCK_STREAM"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "socket",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "392-414",
          "snippet": "int socket(int type) const {\n    bool isStream = type == SOCK_STREAM;\n\n    int result;\n#if __linux__ && !__BIONIC__\n    type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n#endif\n    KJ_SYSCALL(result = ::socket(addr.generic.sa_family, type, 0));\n\n    if (isStream && (addr.generic.sa_family == AF_INET ||\n                     addr.generic.sa_family == AF_INET6)) {\n      // TODO(perf):  As a hack for the 0.4 release we are always setting\n      //   TCP_NODELAY because Nagle's algorithm pretty much kills Cap'n Proto's\n      //   RPC protocol.  Later, we should extend the interface to provide more\n      //   control over this.  Perhaps write() should have a flag which\n      //   specifies whether to pass MSG_MORE.\n      int one = 1;\n      KJ_SYSCALL(setsockopt(\n          result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one)));\n    }\n\n    return result;\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  int socket(int type) const {\n      bool isStream = type == SOCK_STREAM;\n  \n      int result;\n  #if __linux__ && !__BIONIC__\n      type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n  #endif\n      KJ_SYSCALL(result = ::socket(addr.generic.sa_family, type, 0));\n  \n      if (isStream && (addr.generic.sa_family == AF_INET ||\n                       addr.generic.sa_family == AF_INET6)) {\n        // TODO(perf):  As a hack for the 0.4 release we are always setting\n        //   TCP_NODELAY because Nagle's algorithm pretty much kills Cap'n Proto's\n        //   RPC protocol.  Later, we should extend the interface to provide more\n        //   control over this.  Perhaps write() should have a flag which\n        //   specifies whether to pass MSG_MORE.\n        int one = 1;\n        KJ_SYSCALL(setsockopt(\n            result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one)));\n      }\n  \n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_LOG",
          "args": [
            "WARNING",
            "\"Bind address resolved to multiple addresses.  Only the first address will \"\n          \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n          \"in the future.\"",
            "addrs[0].toString()"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrs[0].toString",
          "args": [],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1012-1014",
          "snippet": "String toString() override {\n    return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nNetworkAddressImpl {\n  String toString() override {\n      return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrs.size",
          "args": [],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Own<ConnectionReceiver> listen() override {\n      if (addrs.size() > 1) {\n        KJ_LOG(WARNING, \"Bind address resolved to multiple addresses.  Only the first address will \"\n            \"be used.  If this is incorrect, specify the address numerically.  This may be fixed \"\n            \"in the future.\", addrs[0].toString());\n      }\n  \n      int fd = addrs[0].socket(SOCK_STREAM);\n  \n      {\n        KJ_ON_SCOPE_FAILURE(close(fd));\n  \n        // We always enable SO_REUSEADDR because having to take your server down for five minutes\n        // before it can restart really sucks.\n        int optval = 1;\n        KJ_SYSCALL(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)));\n  \n        addrs[0].bind(fd);\n  \n        // TODO(someday):  Let queue size be specified explicitly in string addresses.\n        KJ_SYSCALL(::listen(fd, SOMAXCONN));\n      }\n  \n      return lowLevel.wrapListenSocketFd(fd, NEW_FD_FLAGS);\n    }\n}"
  },
  {
    "function_name": "connect",
    "container": "NetworkAddressImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "955-957",
    "snippet": "Promise<Own<AsyncIoStream>> connect() override {\n    return connectImpl(0);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connectImpl",
          "args": [
            "0"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connect() override {\n      return connectImpl(0);\n    }\n}"
  },
  {
    "function_name": "NetworkAddressImpl",
    "container": "NetworkAddressImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "952-953",
    "snippet": "NetworkAddressImpl(LowLevelAsyncIoProvider& lowLevel, Array<SocketAddress> addrs)\n      : lowLevel(lowLevel), addrs(kj::mv(addrs)) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "addrs"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  NetworkAddressImpl(LowLevelAsyncIoProvider& lowLevel, Array<SocketAddress> addrs)\n        : lowLevel(lowLevel), addrs(kj::mv(addrs)) {}\n}"
  },
  {
    "function_name": "wrapDatagramSocketFd",
    "container": "LowLevelAsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "933-935",
    "snippet": "Own<DatagramPort> wrapDatagramSocketFd(int fd, uint flags = 0) override {\n    return heap<DatagramPortImpl>(*this, eventPort, fd, flags);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<DatagramPortImpl>",
          "args": [
            "*this",
            "eventPort",
            "fd",
            "flags"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLowLevelAsyncIoProviderImpl {\n  Own<DatagramPort> wrapDatagramSocketFd(int fd, uint flags = 0) override {\n      return heap<DatagramPortImpl>(*this, eventPort, fd, flags);\n    }\n}"
  },
  {
    "function_name": "wrapListenSocketFd",
    "container": "LowLevelAsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "930-932",
    "snippet": "Own<ConnectionReceiver> wrapListenSocketFd(int fd, uint flags = 0) override {\n    return heap<FdConnectionReceiver>(eventPort, fd, flags);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<FdConnectionReceiver>",
          "args": [
            "eventPort",
            "fd",
            "flags"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLowLevelAsyncIoProviderImpl {\n  Own<ConnectionReceiver> wrapListenSocketFd(int fd, uint flags = 0) override {\n      return heap<FdConnectionReceiver>(eventPort, fd, flags);\n    }\n}"
  },
  {
    "function_name": "wrapConnectingSocketFd",
    "container": "LowLevelAsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "916-929",
    "snippet": "Promise<Own<AsyncIoStream>> wrapConnectingSocketFd(int fd, uint flags = 0) override {\n    auto result = heap<AsyncStreamFd>(eventPort, fd, flags);\n\n    auto connected = result->waitConnected();\n    return connected.then(kj::mvCapture(result, [fd](Own<AsyncIoStream>&& stream) {\n      int err;\n      socklen_t errlen = sizeof(err);\n      KJ_SYSCALL(getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen));\n      if (err != 0) {\n        KJ_FAIL_SYSCALL(\"connect()\", err) { break; }\n      }\n      return kj::mv(stream);\n    }));\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connected.then",
          "args": [
            "kj::mvCapture(result, [fd](Own<AsyncIoStream>&& stream) {\n      int err;\n      socklen_t errlen = sizeof(err);\n      KJ_SYSCALL(getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen));\n      if (err != 0) {\n        KJ_FAIL_SYSCALL(\"connect()\", err) { break; }\n      }\n      return kj::mv(stream);\n    })"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "result",
            "[fd](Own<AsyncIoStream>&& stream) {\n      int err;\n      socklen_t errlen = sizeof(err);\n      KJ_SYSCALL(getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen));\n      if (err != 0) {\n        KJ_FAIL_SYSCALL(\"connect()\", err) { break; }\n      }\n      return kj::mv(stream);\n    }"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "stream"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"connect()\"",
            "err"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockopt",
          "args": [
            "fd",
            "SOL_SOCKET",
            "SO_ERROR",
            "&err",
            "&errlen"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result->waitConnected",
          "args": [],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<AsyncStreamFd>",
          "args": [
            "eventPort",
            "fd",
            "flags"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLowLevelAsyncIoProviderImpl {\n  Promise<Own<AsyncIoStream>> wrapConnectingSocketFd(int fd, uint flags = 0) override {\n      auto result = heap<AsyncStreamFd>(eventPort, fd, flags);\n  \n      auto connected = result->waitConnected();\n      return connected.then(kj::mvCapture(result, [fd](Own<AsyncIoStream>&& stream) {\n        int err;\n        socklen_t errlen = sizeof(err);\n        KJ_SYSCALL(getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &errlen));\n        if (err != 0) {\n          KJ_FAIL_SYSCALL(\"connect()\", err) { break; }\n        }\n        return kj::mv(stream);\n      }));\n    }\n}"
  },
  {
    "function_name": "wrapSocketFd",
    "container": "LowLevelAsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "913-915",
    "snippet": "Own<AsyncIoStream> wrapSocketFd(int fd, uint flags = 0) override {\n    return heap<AsyncStreamFd>(eventPort, fd, flags);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<AsyncStreamFd>",
          "args": [
            "eventPort",
            "fd",
            "flags"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLowLevelAsyncIoProviderImpl {\n  Own<AsyncIoStream> wrapSocketFd(int fd, uint flags = 0) override {\n      return heap<AsyncStreamFd>(eventPort, fd, flags);\n    }\n}"
  },
  {
    "function_name": "wrapOutputFd",
    "container": "LowLevelAsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "910-912",
    "snippet": "Own<AsyncOutputStream> wrapOutputFd(int fd, uint flags = 0) override {\n    return heap<AsyncStreamFd>(eventPort, fd, flags);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<AsyncStreamFd>",
          "args": [
            "eventPort",
            "fd",
            "flags"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLowLevelAsyncIoProviderImpl {\n  Own<AsyncOutputStream> wrapOutputFd(int fd, uint flags = 0) override {\n      return heap<AsyncStreamFd>(eventPort, fd, flags);\n    }\n}"
  },
  {
    "function_name": "wrapInputFd",
    "container": "LowLevelAsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "907-909",
    "snippet": "Own<AsyncInputStream> wrapInputFd(int fd, uint flags = 0) override {\n    return heap<AsyncStreamFd>(eventPort, fd, flags);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap<AsyncStreamFd>",
          "args": [
            "eventPort",
            "fd",
            "flags"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLowLevelAsyncIoProviderImpl {\n  Own<AsyncInputStream> wrapInputFd(int fd, uint flags = 0) override {\n      return heap<AsyncStreamFd>(eventPort, fd, flags);\n    }\n}"
  },
  {
    "function_name": "LowLevelAsyncIoProviderImpl",
    "container": "LowLevelAsyncIoProviderImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "902-903",
    "snippet": "LowLevelAsyncIoProviderImpl()\n      : eventLoop(eventPort), timer(eventPort), waitScope(eventLoop) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLowLevelAsyncIoProviderImpl {\n  LowLevelAsyncIoProviderImpl()\n        : eventLoop(eventPort), timer(eventPort), waitScope(eventLoop) {}\n}"
  },
  {
    "function_name": "afterDelay",
    "container": "TimerImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "892-894",
    "snippet": "Promise<void> afterDelay(Duration delay) override {\n    return eventPort.atSteadyTime(eventPort.steadyTime() + delay);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventPort.atSteadyTime",
          "args": [
            "eventPort.steadyTime() + delay"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventPort.steadyTime",
          "args": [],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "steadyTime",
          "container": "UnixEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.h",
          "lines": "90-90",
          "snippet": "TimePoint steadyTime() { return frozenSteadyTime; }",
          "includes": [
            "#include <signal.h>",
            "#include \"io.h\"",
            "#include \"vector.h\"",
            "#include \"time.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include \"io.h\"\n#include \"vector.h\"\n#include \"time.h\"\n#include \"async.h\"\n\nUnixEventPort {\n  TimePoint steadyTime() { return frozenSteadyTime; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTimerImpl {\n  Promise<void> afterDelay(Duration delay) override {\n      return eventPort.atSteadyTime(eventPort.steadyTime() + delay);\n    }\n}"
  },
  {
    "function_name": "atTime",
    "container": "TimerImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "888-890",
    "snippet": "Promise<void> atTime(TimePoint time) override {\n    return eventPort.atSteadyTime(time);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventPort.atSteadyTime",
          "args": [
            "time"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTimerImpl {\n  Promise<void> atTime(TimePoint time) override {\n      return eventPort.atSteadyTime(time);\n    }\n}"
  },
  {
    "function_name": "now",
    "container": "TimerImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "886-886",
    "snippet": "TimePoint now() override { return eventPort.steadyTime(); }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventPort.steadyTime",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "steadyTime",
          "container": "UnixEventPort",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.h",
          "lines": "90-90",
          "snippet": "TimePoint steadyTime() { return frozenSteadyTime; }",
          "includes": [
            "#include <signal.h>",
            "#include \"io.h\"",
            "#include \"vector.h\"",
            "#include \"time.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include \"io.h\"\n#include \"vector.h\"\n#include \"time.h\"\n#include \"async.h\"\n\nUnixEventPort {\n  TimePoint steadyTime() { return frozenSteadyTime; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTimerImpl {\n  TimePoint now() override { return eventPort.steadyTime(); }\n}"
  },
  {
    "function_name": "TimerImpl",
    "container": "TimerImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "884-884",
    "snippet": "TimerImpl(UnixEventPort& eventPort): eventPort(eventPort) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nTimerImpl {\n  TimerImpl(UnixEventPort& eventPort): eventPort(eventPort) {}\n}"
  },
  {
    "function_name": "setsockopt",
    "container": "DatagramPortImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "872-874",
    "snippet": "void setsockopt(int level, int option, const void* value, uint length) override {\n    KJ_SYSCALL(::setsockopt(fd, level, option, value, length));\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::setsockopt(fd, level, option, value, length)"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::setsockopt",
          "args": [
            "fd",
            "level",
            "option",
            "value",
            "length"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  void setsockopt(int level, int option, const void* value, uint length) override {\n      KJ_SYSCALL(::setsockopt(fd, level, option, value, length));\n    }\n}"
  },
  {
    "function_name": "getsockopt",
    "container": "DatagramPortImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "867-871",
    "snippet": "void getsockopt(int level, int option, void* value, uint* length) override {\n    socklen_t socklen = *length;\n    KJ_SYSCALL(::getsockopt(fd, level, option, value, &socklen));\n    *length = socklen;\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::getsockopt(fd, level, option, value, &socklen)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::getsockopt",
          "args": [
            "fd",
            "level",
            "option",
            "value",
            "&socklen"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  void getsockopt(int level, int option, void* value, uint* length) override {\n      socklen_t socklen = *length;\n      KJ_SYSCALL(::getsockopt(fd, level, option, value, &socklen));\n      *length = socklen;\n    }\n}"
  },
  {
    "function_name": "getPort",
    "container": "DatagramPortImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "863-865",
    "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SocketAddress::getLocalAddress",
          "args": [],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SocketAddress::getLocalAddress",
          "args": [
            "fd"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "getLocalAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "608-613",
          "snippet": "static SocketAddress getLocalAddress(int sockfd) {\n    SocketAddress result;\n    result.addrlen = sizeof(addr);\n    KJ_SYSCALL(getsockname(sockfd, &result.addr.generic, &result.addrlen));\n    return result;\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "socklen_t addrlen;",
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nstatic SocketAddress getLocalAddress(int sockfd) {\n    SocketAddress result;\n    result.addrlen = sizeof(addr);\n    KJ_SYSCALL(getsockname(sockfd, &result.addr.generic, &result.addrlen));\n    return result;\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
  },
  {
    "function_name": "DatagramPortImpl",
    "container": "DatagramPortImpl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "850-853",
    "snippet": "DatagramPortImpl(LowLevelAsyncIoProvider& lowLevel, UnixEventPort& eventPort, int fd, uint flags)\n      : OwnedFileDescriptor(fd, flags), lowLevel(lowLevel), eventPort(eventPort),\n        observer(eventPort, fd, UnixEventPort::FdObserver::OBSERVE_READ |\n                                UnixEventPort::FdObserver::OBSERVE_WRITE) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  DatagramPortImpl(LowLevelAsyncIoProvider& lowLevel, UnixEventPort& eventPort, int fd, uint flags)\n        : OwnedFileDescriptor(fd, flags), lowLevel(lowLevel), eventPort(eventPort),\n          observer(eventPort, fd, UnixEventPort::FdObserver::OBSERVE_READ |\n                                  UnixEventPort::FdObserver::OBSERVE_WRITE) {}\n}"
  },
  {
    "function_name": "setsockopt",
    "container": "FdConnectionReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "839-841",
    "snippet": "void setsockopt(int level, int option, const void* value, uint length) override {\n    KJ_SYSCALL(::setsockopt(fd, level, option, value, length));\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::setsockopt(fd, level, option, value, length)"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::setsockopt",
          "args": [
            "fd",
            "level",
            "option",
            "value",
            "length"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nFdConnectionReceiver {\n  void setsockopt(int level, int option, const void* value, uint length) override {\n      KJ_SYSCALL(::setsockopt(fd, level, option, value, length));\n    }\n}"
  },
  {
    "function_name": "getsockopt",
    "container": "FdConnectionReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "834-838",
    "snippet": "void getsockopt(int level, int option, void* value, uint* length) override {\n    socklen_t socklen = *length;\n    KJ_SYSCALL(::getsockopt(fd, level, option, value, &socklen));\n    *length = socklen;\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::getsockopt(fd, level, option, value, &socklen)"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::getsockopt",
          "args": [
            "fd",
            "level",
            "option",
            "value",
            "&socklen"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nFdConnectionReceiver {\n  void getsockopt(int level, int option, void* value, uint* length) override {\n      socklen_t socklen = *length;\n      KJ_SYSCALL(::getsockopt(fd, level, option, value, &socklen));\n      *length = socklen;\n    }\n}"
  },
  {
    "function_name": "getPort",
    "container": "FdConnectionReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "830-832",
    "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SocketAddress::getLocalAddress",
          "args": [],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SocketAddress::getLocalAddress",
          "args": [
            "fd"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "getLocalAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "608-613",
          "snippet": "static SocketAddress getLocalAddress(int sockfd) {\n    SocketAddress result;\n    result.addrlen = sizeof(addr);\n    KJ_SYSCALL(getsockname(sockfd, &result.addr.generic, &result.addrlen));\n    return result;\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "socklen_t addrlen;",
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nstatic SocketAddress getLocalAddress(int sockfd) {\n    SocketAddress result;\n    result.addrlen = sizeof(addr);\n    KJ_SYSCALL(getsockname(sockfd, &result.addr.generic, &result.addrlen));\n    return result;\n  }"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nFdConnectionReceiver {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
  },
  {
    "function_name": "accept",
    "container": "FdConnectionReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "784-828",
    "snippet": "Promise<Own<AsyncIoStream>> accept() override {\n    int newFd;\n\n  retry:\n#if __linux__ && !__BIONIC__\n    newFd = ::accept4(fd, nullptr, nullptr, SOCK_NONBLOCK | SOCK_CLOEXEC);\n#else\n    newFd = ::accept(fd, nullptr, nullptr);\n#endif\n\n    if (newFd >= 0) {\n      return Own<AsyncIoStream>(heap<AsyncStreamFd>(eventPort, newFd, NEW_FD_FLAGS));\n    } else {\n      int error = errno;\n\n      switch (error) {\n        case EAGAIN:\n#if EAGAIN != EWOULDBLOCK\n        case EWOULDBLOCK:\n#endif\n          // Not ready yet.\n          return observer.whenBecomesReadable().then([this]() {\n            return accept();\n          });\n\n        case EINTR:\n        case ENETDOWN:\n        case EPROTO:\n        case EHOSTDOWN:\n        case EHOSTUNREACH:\n        case ENETUNREACH:\n        case ECONNABORTED:\n        case ETIMEDOUT:\n          // According to the Linux man page, accept() may report an error if the accepted\n          // connection is already broken.  In this case, we really ought to just ignore it and\n          // keep waiting.  But it's hard to say exactly what errors are such network errors and\n          // which ones are permanent errors.  We've made a guess here.\n          goto retry;\n\n        default:\n          KJ_FAIL_SYSCALL(\"accept\", error);\n      }\n\n    }\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"accept\"",
            "error"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "[this]() {\n            return accept();\n          }"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Own<AsyncIoStream>",
          "args": [
            "heap<AsyncStreamFd>(eventPort, newFd, NEW_FD_FLAGS)"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "OwnOwn",
          "container": "OwnOwn",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "207-207",
          "snippet": "inline OwnOwn(Own<T>&& value) noexcept: value(kj::mv(value)) {}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwnOwn {\n  inline OwnOwn(Own<T>&& value) noexcept: value(kj::mv(value)) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap<AsyncStreamFd>",
          "args": [
            "eventPort",
            "newFd",
            "NEW_FD_FLAGS"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::accept",
          "args": [
            "fd",
            "nullptr",
            "nullptr"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::accept4",
          "args": [
            "fd",
            "nullptr",
            "nullptr",
            "SOCK_NONBLOCK | SOCK_CLOEXEC"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nFdConnectionReceiver {\n  Promise<Own<AsyncIoStream>> accept() override {\n      int newFd;\n  \n    retry:\n  #if __linux__ && !__BIONIC__\n      newFd = ::accept4(fd, nullptr, nullptr, SOCK_NONBLOCK | SOCK_CLOEXEC);\n  #else\n      newFd = ::accept(fd, nullptr, nullptr);\n  #endif\n  \n      if (newFd >= 0) {\n        return Own<AsyncIoStream>(heap<AsyncStreamFd>(eventPort, newFd, NEW_FD_FLAGS));\n      } else {\n        int error = errno;\n  \n        switch (error) {\n          case EAGAIN:\n  #if EAGAIN != EWOULDBLOCK\n          case EWOULDBLOCK:\n  #endif\n            // Not ready yet.\n            return observer.whenBecomesReadable().then([this]() {\n              return accept();\n            });\n  \n          case EINTR:\n          case ENETDOWN:\n          case EPROTO:\n          case EHOSTDOWN:\n          case EHOSTUNREACH:\n          case ENETUNREACH:\n          case ECONNABORTED:\n          case ETIMEDOUT:\n            // According to the Linux man page, accept() may report an error if the accepted\n            // connection is already broken.  In this case, we really ought to just ignore it and\n            // keep waiting.  But it's hard to say exactly what errors are such network errors and\n            // which ones are permanent errors.  We've made a guess here.\n            goto retry;\n  \n          default:\n            KJ_FAIL_SYSCALL(\"accept\", error);\n        }\n  \n      }\n    }\n}"
  },
  {
    "function_name": "FdConnectionReceiver",
    "container": "FdConnectionReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "780-782",
    "snippet": "FdConnectionReceiver(UnixEventPort& eventPort, int fd, uint flags)\n      : OwnedFileDescriptor(fd, flags), eventPort(eventPort),\n        observer(eventPort, fd, UnixEventPort::FdObserver::OBSERVE_READ) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nFdConnectionReceiver {\n  FdConnectionReceiver(UnixEventPort& eventPort, int fd, uint flags)\n        : OwnedFileDescriptor(fd, flags), eventPort(eventPort),\n          observer(eventPort, fd, UnixEventPort::FdObserver::OBSERVE_READ) {}\n}"
  },
  {
    "function_name": "SocketAddress::lookupHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "686-774",
    "snippet": "Promise<Array<SocketAddress>> SocketAddress::lookupHost(\n    LowLevelAsyncIoProvider& lowLevel, kj::String host, kj::String service, uint portHint) {\n  // This shitty function spawns a thread to run getaddrinfo().  Unfortunately, getaddrinfo() is\n  // the only cross-platform DNS API and it is blocking.\n  //\n  // TODO(perf):  Use a thread pool?  Maybe kj::Thread should use a thread pool automatically?\n  //   Maybe use the various platform-specific asynchronous DNS libraries?  Please do not implement\n  //   a custom DNS resolver...\n\n  int fds[2];\n#if __linux__ && !__BIONIC__\n  KJ_SYSCALL(pipe2(fds, O_NONBLOCK | O_CLOEXEC));\n#else\n  KJ_SYSCALL(pipe(fds));\n#endif\n\n  auto input = lowLevel.wrapInputFd(fds[0], NEW_FD_FLAGS);\n\n  int outFd = fds[1];\n\n  LookupParams params = { kj::mv(host), kj::mv(service) };\n\n  auto thread = heap<Thread>(kj::mvCapture(params, [outFd,portHint](LookupParams&& params) {\n    FdOutputStream output((AutoCloseFd(outFd)));\n\n    struct addrinfo* list;\n    int status = getaddrinfo(\n        params.host == \"*\" ? nullptr : params.host.cStr(),\n        params.service == nullptr ? nullptr : params.service.cStr(),\n        nullptr, &list);\n    if (status == 0) {\n      KJ_DEFER(freeaddrinfo(list));\n\n      struct addrinfo* cur = list;\n      while (cur != nullptr) {\n        if (params.service == nullptr) {\n          switch (cur->ai_addr->sa_family) {\n            case AF_INET:\n              ((struct sockaddr_in*)cur->ai_addr)->sin_port = htons(portHint);\n              break;\n            case AF_INET6:\n              ((struct sockaddr_in6*)cur->ai_addr)->sin6_port = htons(portHint);\n              break;\n            default:\n              break;\n          }\n        }\n\n        SocketAddress addr;\n        memset(&addr, 0, sizeof(addr));  // mollify valgrind\n        if (params.host == \"*\") {\n          // Set up a wildcard SocketAddress.  Only use the port number returned by getaddrinfo().\n          addr.wildcard = true;\n          addr.addrlen = sizeof(addr.addr.inet6);\n          addr.addr.inet6.sin6_family = AF_INET6;\n          switch (cur->ai_addr->sa_family) {\n            case AF_INET:\n              addr.addr.inet6.sin6_port = ((struct sockaddr_in*)cur->ai_addr)->sin_port;\n              break;\n            case AF_INET6:\n              addr.addr.inet6.sin6_port = ((struct sockaddr_in6*)cur->ai_addr)->sin6_port;\n              break;\n            default:\n              addr.addr.inet6.sin6_port = portHint;\n              break;\n          }\n        } else {\n          addr.addrlen = cur->ai_addrlen;\n          memcpy(&addr.addr.generic, cur->ai_addr, cur->ai_addrlen);\n        }\n        static_assert(canMemcpy<SocketAddress>(), \"Can't write() SocketAddress...\");\n        output.write(&addr, sizeof(addr));\n        cur = cur->ai_next;\n      }\n    } else if (status == EAI_SYSTEM) {\n      KJ_FAIL_SYSCALL(\"getaddrinfo\", errno, params.host, params.service) {\n        return;\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"DNS lookup failed.\",\n                      params.host, params.service, gai_strerror(status)) {\n        return;\n      }\n    }\n  }));\n\n  auto reader = heap<LookupReader>(kj::mv(thread), kj::mv(input));\n  return reader->read().attach(kj::mv(reader));\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "socklen_t addrlen;",
      "bool wildcard = false;",
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reader->read",
          "args": [
            "kj::mv(reader)"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "646-671",
          "snippet": "Promise<Array<SocketAddress>> read() {\n    return input->tryRead(&current, sizeof(current), sizeof(current)).then(\n        [this](size_t n) -> Promise<Array<SocketAddress>> {\n      if (n < sizeof(current)) {\n        thread = nullptr;\n        // getaddrinfo()'s docs seem to say it will never return an empty list, but let's check\n        // anyway.\n        KJ_REQUIRE(addresses.size() > 0, \"DNS lookup returned no addresses.\") { break; }\n        return addresses.releaseAsArray();\n      } else {\n        // getaddrinfo() can return multiple copies of the same address for several reasons.\n        // A major one is that we don't give it a socket type (SOCK_STREAM vs. SOCK_DGRAM), so\n        // it may return two copies of the same address, one for each type, unless it explicitly\n        // knows that the service name given is specific to one type.  But we can't tell it a type,\n        // because we don't actually know which one the user wants, and if we specify SOCK_STREAM\n        // while the user specified a UDP service name then they'll get a resolution error which\n        // is lame.  (At least, I think that's how it works.)\n        //\n        // So we instead resort to de-duping results.\n        if (alreadySeen.insert(current).second) {\n          addresses.add(current);\n        }\n        return read();\n      }\n    });\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<Array<SocketAddress>> read() {\n    return input->tryRead(&current, sizeof(current), sizeof(current)).then(\n        [this](size_t n) -> Promise<Array<SocketAddress>> {\n      if (n < sizeof(current)) {\n        thread = nullptr;\n        // getaddrinfo()'s docs seem to say it will never return an empty list, but let's check\n        // anyway.\n        KJ_REQUIRE(addresses.size() > 0, \"DNS lookup returned no addresses.\") { break; }\n        return addresses.releaseAsArray();\n      } else {\n        // getaddrinfo() can return multiple copies of the same address for several reasons.\n        // A major one is that we don't give it a socket type (SOCK_STREAM vs. SOCK_DGRAM), so\n        // it may return two copies of the same address, one for each type, unless it explicitly\n        // knows that the service name given is specific to one type.  But we can't tell it a type,\n        // because we don't actually know which one the user wants, and if we specify SOCK_STREAM\n        // while the user specified a UDP service name then they'll get a resolution error which\n        // is lame.  (At least, I think that's how it works.)\n        //\n        // So we instead resort to de-duping results.\n        if (alreadySeen.insert(current).second) {\n          addresses.add(current);\n        }\n        return read();\n      }\n    });\n  }"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "reader"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader->read",
          "args": [],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<LookupReader>",
          "args": [
            "kj::mv(thread)",
            "kj::mv(input)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "input"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "thread"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap<Thread>",
          "args": [
            "kj::mvCapture(params, [outFd,portHint](LookupParams&& params) {\n    FdOutputStream output((AutoCloseFd(outFd)));\n\n    struct addrinfo* list;\n    int status = getaddrinfo(\n        params.host == \"*\" ? nullptr : params.host.cStr(),\n        params.service == nullptr ? nullptr : params.service.cStr(),\n        nullptr, &list);\n    if (status == 0) {\n      KJ_DEFER(freeaddrinfo(list));\n\n      struct addrinfo* cur = list;\n      while (cur != nullptr) {\n        if (params.service == nullptr) {\n          switch (cur->ai_addr->sa_family) {\n            case AF_INET:\n              ((struct sockaddr_in*)cur->ai_addr)->sin_port = htons(portHint);\n              break;\n            case AF_INET6:\n              ((struct sockaddr_in6*)cur->ai_addr)->sin6_port = htons(portHint);\n              break;\n            default:\n              break;\n          }\n        }\n\n        SocketAddress addr;\n        memset(&addr, 0, sizeof(addr));  // mollify valgrind\n        if (params.host == \"*\") {\n          // Set up a wildcard SocketAddress.  Only use the port number returned by getaddrinfo().\n          addr.wildcard = true;\n          addr.addrlen = sizeof(addr.addr.inet6);\n          addr.addr.inet6.sin6_family = AF_INET6;\n          switch (cur->ai_addr->sa_family) {\n            case AF_INET:\n              addr.addr.inet6.sin6_port = ((struct sockaddr_in*)cur->ai_addr)->sin_port;\n              break;\n            case AF_INET6:\n              addr.addr.inet6.sin6_port = ((struct sockaddr_in6*)cur->ai_addr)->sin6_port;\n              break;\n            default:\n              addr.addr.inet6.sin6_port = portHint;\n              break;\n          }\n        } else {\n          addr.addrlen = cur->ai_addrlen;\n          memcpy(&addr.addr.generic, cur->ai_addr, cur->ai_addrlen);\n        }\n        static_assert(canMemcpy<SocketAddress>(), \"Can't write() SocketAddress...\");\n        output.write(&addr, sizeof(addr));\n        cur = cur->ai_next;\n      }\n    } else if (status == EAI_SYSTEM) {\n      KJ_FAIL_SYSCALL(\"getaddrinfo\", errno, params.host, params.service) {\n        return;\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"DNS lookup failed.\",\n                      params.host, params.service, gai_strerror(status)) {\n        return;\n      }\n    }\n  })"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/memory.h",
          "lines": "331-339",
          "snippet": "Own<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nOwn<Decay<T>> heap(T&& orig) {\n  // Allocate a copy (or move) of the argument on the heap.\n  //\n  // The purpose of this overload is to allow you to omit the template parameter as there is only\n  // one argument and the purpose is to copy it.\n\n  typedef Decay<T> T2;\n  return Own<T2>(new T2(kj::fwd<T>(orig)), _::HeapDisposer<T2>::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mvCapture",
          "args": [
            "params",
            "[outFd,portHint](LookupParams&& params) {\n    FdOutputStream output((AutoCloseFd(outFd)));\n\n    struct addrinfo* list;\n    int status = getaddrinfo(\n        params.host == \"*\" ? nullptr : params.host.cStr(),\n        params.service == nullptr ? nullptr : params.service.cStr(),\n        nullptr, &list);\n    if (status == 0) {\n      KJ_DEFER(freeaddrinfo(list));\n\n      struct addrinfo* cur = list;\n      while (cur != nullptr) {\n        if (params.service == nullptr) {\n          switch (cur->ai_addr->sa_family) {\n            case AF_INET:\n              ((struct sockaddr_in*)cur->ai_addr)->sin_port = htons(portHint);\n              break;\n            case AF_INET6:\n              ((struct sockaddr_in6*)cur->ai_addr)->sin6_port = htons(portHint);\n              break;\n            default:\n              break;\n          }\n        }\n\n        SocketAddress addr;\n        memset(&addr, 0, sizeof(addr));  // mollify valgrind\n        if (params.host == \"*\") {\n          // Set up a wildcard SocketAddress.  Only use the port number returned by getaddrinfo().\n          addr.wildcard = true;\n          addr.addrlen = sizeof(addr.addr.inet6);\n          addr.addr.inet6.sin6_family = AF_INET6;\n          switch (cur->ai_addr->sa_family) {\n            case AF_INET:\n              addr.addr.inet6.sin6_port = ((struct sockaddr_in*)cur->ai_addr)->sin_port;\n              break;\n            case AF_INET6:\n              addr.addr.inet6.sin6_port = ((struct sockaddr_in6*)cur->ai_addr)->sin6_port;\n              break;\n            default:\n              addr.addr.inet6.sin6_port = portHint;\n              break;\n          }\n        } else {\n          addr.addrlen = cur->ai_addrlen;\n          memcpy(&addr.addr.generic, cur->ai_addr, cur->ai_addrlen);\n        }\n        static_assert(canMemcpy<SocketAddress>(), \"Can't write() SocketAddress...\");\n        output.write(&addr, sizeof(addr));\n        cur = cur->ai_next;\n      }\n    } else if (status == EAI_SYSTEM) {\n      KJ_FAIL_SYSCALL(\"getaddrinfo\", errno, params.host, params.service) {\n        return;\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"DNS lookup failed.\",\n                      params.host, params.service, gai_strerror(status)) {\n        return;\n      }\n    }\n  }"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "mvCapture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.h",
          "lines": "383-395",
          "snippet": "inline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}",
          "includes": [
            "#include \"async-inl.h\"",
            "#include \"tuple.h\"",
            "#include \"refcount.h\"",
            "#include \"exception.h\"",
            "#include \"async-prelude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-inl.h\"\n#include \"tuple.h\"\n#include \"refcount.h\"\n#include \"exception.h\"\n#include \"async-prelude.h\"\n\ninline CaptureByMove<Func, Decay<MovedParam>> mvCapture(MovedParam&& param, Func&& func) {\n  // Hack to create a \"lambda\" which captures a variable by moving it rather than copying or\n  // referencing.  C++14 generalized captures should make this obsolete, but for now in C++11 this\n  // is commonly needed for Promise continuations that own their state.  Example usage:\n  //\n  //    Own<Foo> ptr = makeFoo();\n  //    Promise<int> promise = callRpc();\n  //    promise.then(mvCapture(ptr, [](Own<Foo>&& ptr, int result) {\n  //      return ptr->finish(result);\n  //    }));\n\n  return CaptureByMove<Func, Decay<MovedParam>>(kj::fwd<Func>(func), kj::mv(param));\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_REQUIRE",
          "args": [
            "\"DNS lookup failed.\"",
            "params.host",
            "params.service",
            "gai_strerror(status)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "status"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"getaddrinfo\"",
            "errno",
            "params.host",
            "params.service"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.write",
          "args": [
            "&addr",
            "sizeof(addr)"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "FragmentingOutputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-async-test.c++",
          "lines": "42-50",
          "snippet": "void write(const void* buffer, size_t size) override {\n    while (size > 0) {\n      usleep(5000);\n      size_t n = rand() % size + 1;\n      inner.write(buffer, n);\n      buffer = reinterpret_cast<const byte*>(buffer) + n;\n      size -= n;\n    }\n  }",
          "includes": [
            "#include <kj/compat/gtest.h>",
            "#include \"test-util.h\"",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include <kj/thread.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\"",
            "#include \"serialize-async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kj/compat/gtest.h>\n#include \"test-util.h\"\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <kj/thread.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n#include \"serialize-async.h\"\n\nFragmentingOutputStream {\n  void write(const void* buffer, size_t size) override {\n      while (size > 0) {\n        usleep(5000);\n        size_t n = rand() % size + 1;\n        inner.write(buffer, n);\n        buffer = reinterpret_cast<const byte*>(buffer) + n;\n        size -= n;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "canMemcpy<SocketAddress>",
          "args": [],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "canMemcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "440-446",
          "snippet": "constexpr bool canMemcpy() {\n  // Returns true if T can be copied using memcpy instead of using the copy constructor or\n  // assignment operator.\n\n  // GCC defines these to mean what we want them to mean.\n  return __has_trivial_copy(T) && __has_trivial_assign(T);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nconstexpr bool canMemcpy() {\n  // Returns true if T can be copied using memcpy instead of using the copy constructor or\n  // assignment operator.\n\n  // GCC defines these to mean what we want them to mean.\n  return __has_trivial_copy(T) && __has_trivial_assign(T);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr.addr.generic",
            "cur->ai_addr",
            "cur->ai_addrlen"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "portHint"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "portHint"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_DEFER",
          "args": [
            "freeaddrinfo(list)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "list"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "params.host == \"*\" ? nullptr : params.host.cStr()",
            "params.service == nullptr ? nullptr : params.service.cStr()",
            "nullptr",
            "&list"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.service.cStr",
          "args": [],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.host.cStr",
          "args": [],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AutoCloseFd",
          "args": [
            "outFd"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "AutoCloseFd",
          "container": "AutoCloseFd",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.h",
          "lines": "241-241",
          "snippet": "inline AutoCloseFd(AutoCloseFd&& other) noexcept: fd(other.fd) { other.fd = -1; }",
          "includes": [
            "#include \"exception.h\"",
            "#include \"array.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exception.h\"\n#include \"array.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nAutoCloseFd {\n  inline AutoCloseFd(AutoCloseFd&& other) noexcept: fd(other.fd) { other.fd = -1; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "service"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "host"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lowLevel.wrapInputFd",
          "args": [
            "fds[0]",
            "NEW_FD_FLAGS"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe(fds)"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "fds"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/miniposix.h",
          "lines": "84-86",
          "snippet": "inline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <direct.h>",
            "#include <io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <direct.h>\n#include <io.h>\n\ninline int pipe(int fds[2]) {\n  return ::_pipe(fds, 4096, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pipe2(fds, O_NONBLOCK | O_CLOEXEC)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe2",
          "args": [
            "fds",
            "O_NONBLOCK | O_CLOEXEC"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nbool wildcard = false;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nPromise<Array<SocketAddress>> SocketAddress::lookupHost(\n    LowLevelAsyncIoProvider& lowLevel, kj::String host, kj::String service, uint portHint) {\n  // This shitty function spawns a thread to run getaddrinfo().  Unfortunately, getaddrinfo() is\n  // the only cross-platform DNS API and it is blocking.\n  //\n  // TODO(perf):  Use a thread pool?  Maybe kj::Thread should use a thread pool automatically?\n  //   Maybe use the various platform-specific asynchronous DNS libraries?  Please do not implement\n  //   a custom DNS resolver...\n\n  int fds[2];\n#if __linux__ && !__BIONIC__\n  KJ_SYSCALL(pipe2(fds, O_NONBLOCK | O_CLOEXEC));\n#else\n  KJ_SYSCALL(pipe(fds));\n#endif\n\n  auto input = lowLevel.wrapInputFd(fds[0], NEW_FD_FLAGS);\n\n  int outFd = fds[1];\n\n  LookupParams params = { kj::mv(host), kj::mv(service) };\n\n  auto thread = heap<Thread>(kj::mvCapture(params, [outFd,portHint](LookupParams&& params) {\n    FdOutputStream output((AutoCloseFd(outFd)));\n\n    struct addrinfo* list;\n    int status = getaddrinfo(\n        params.host == \"*\" ? nullptr : params.host.cStr(),\n        params.service == nullptr ? nullptr : params.service.cStr(),\n        nullptr, &list);\n    if (status == 0) {\n      KJ_DEFER(freeaddrinfo(list));\n\n      struct addrinfo* cur = list;\n      while (cur != nullptr) {\n        if (params.service == nullptr) {\n          switch (cur->ai_addr->sa_family) {\n            case AF_INET:\n              ((struct sockaddr_in*)cur->ai_addr)->sin_port = htons(portHint);\n              break;\n            case AF_INET6:\n              ((struct sockaddr_in6*)cur->ai_addr)->sin6_port = htons(portHint);\n              break;\n            default:\n              break;\n          }\n        }\n\n        SocketAddress addr;\n        memset(&addr, 0, sizeof(addr));  // mollify valgrind\n        if (params.host == \"*\") {\n          // Set up a wildcard SocketAddress.  Only use the port number returned by getaddrinfo().\n          addr.wildcard = true;\n          addr.addrlen = sizeof(addr.addr.inet6);\n          addr.addr.inet6.sin6_family = AF_INET6;\n          switch (cur->ai_addr->sa_family) {\n            case AF_INET:\n              addr.addr.inet6.sin6_port = ((struct sockaddr_in*)cur->ai_addr)->sin_port;\n              break;\n            case AF_INET6:\n              addr.addr.inet6.sin6_port = ((struct sockaddr_in6*)cur->ai_addr)->sin6_port;\n              break;\n            default:\n              addr.addr.inet6.sin6_port = portHint;\n              break;\n          }\n        } else {\n          addr.addrlen = cur->ai_addrlen;\n          memcpy(&addr.addr.generic, cur->ai_addr, cur->ai_addrlen);\n        }\n        static_assert(canMemcpy<SocketAddress>(), \"Can't write() SocketAddress...\");\n        output.write(&addr, sizeof(addr));\n        cur = cur->ai_next;\n      }\n    } else if (status == EAI_SYSTEM) {\n      KJ_FAIL_SYSCALL(\"getaddrinfo\", errno, params.host, params.service) {\n        return;\n      }\n    } else {\n      KJ_FAIL_REQUIRE(\"DNS lookup failed.\",\n                      params.host, params.service, gai_strerror(status)) {\n        return;\n      }\n    }\n  }));\n\n  auto reader = heap<LookupReader>(kj::mv(thread), kj::mv(input));\n  return reader->read().attach(kj::mv(reader));\n}"
  },
  {
    "function_name": "read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "646-671",
    "snippet": "Promise<Array<SocketAddress>> read() {\n    return input->tryRead(&current, sizeof(current), sizeof(current)).then(\n        [this](size_t n) -> Promise<Array<SocketAddress>> {\n      if (n < sizeof(current)) {\n        thread = nullptr;\n        // getaddrinfo()'s docs seem to say it will never return an empty list, but let's check\n        // anyway.\n        KJ_REQUIRE(addresses.size() > 0, \"DNS lookup returned no addresses.\") { break; }\n        return addresses.releaseAsArray();\n      } else {\n        // getaddrinfo() can return multiple copies of the same address for several reasons.\n        // A major one is that we don't give it a socket type (SOCK_STREAM vs. SOCK_DGRAM), so\n        // it may return two copies of the same address, one for each type, unless it explicitly\n        // knows that the service name given is specific to one type.  But we can't tell it a type,\n        // because we don't actually know which one the user wants, and if we specify SOCK_STREAM\n        // while the user specified a UDP service name then they'll get a resolution error which\n        // is lame.  (At least, I think that's how it works.)\n        //\n        // So we instead resort to de-duping results.\n        if (alreadySeen.insert(current).second) {\n          addresses.add(current);\n        }\n        return read();\n      }\n    });\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "input->tryRead",
          "args": [
            "[this](size_t n) -> Promise<Array<SocketAddress>> {\n      if (n < sizeof(current)) {\n        thread = nullptr;\n        // getaddrinfo()'s docs seem to say it will never return an empty list, but let's check\n        // anyway.\n        KJ_REQUIRE(addresses.size() > 0, \"DNS lookup returned no addresses.\") { break; }\n        return addresses.releaseAsArray();\n      } else {\n        // getaddrinfo() can return multiple copies of the same address for several reasons.\n        // A major one is that we don't give it a socket type (SOCK_STREAM vs. SOCK_DGRAM), so\n        // it may return two copies of the same address, one for each type, unless it explicitly\n        // knows that the service name given is specific to one type.  But we can't tell it a type,\n        // because we don't actually know which one the user wants, and if we specify SOCK_STREAM\n        // while the user specified a UDP service name then they'll get a resolution error which\n        // is lame.  (At least, I think that's how it works.)\n        //\n        // So we instead resort to de-duping results.\n        if (alreadySeen.insert(current).second) {\n          addresses.add(current);\n        }\n        return read();\n      }\n    }"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "createKey",
          "container": "ThreadLocalPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/threadlocal.h",
          "lines": "114-118",
          "snippet": "static pthread_key_t createKey() {\n    pthread_key_t key;\n    pthread_key_create(&key, 0);\n    return key;\n  }",
          "includes": [
            "#include <pthread.h>",
            "#include \"TargetConditionals.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pthread.h>\n#include \"TargetConditionals.h\"\n#include \"common.h\"\n\nThreadLocalPtr {\n  static pthread_key_t createKey() {\n      pthread_key_t key;\n      pthread_key_create(&key, 0);\n      return key;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addresses.add",
          "args": [
            "current"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alreadySeen.insert",
          "args": [
            "current"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addresses.releaseAsArray",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "releaseAsArray",
          "container": "Vector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/vector.h",
          "lines": "66-72",
          "snippet": "inline Array<T> releaseAsArray() {\n    // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n    if (!builder.isFull()) {\n      setCapacity(size());\n    }\n    return builder.finish();\n  }",
          "includes": [
            "#include \"array.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n\nVector {\n  inline Array<T> releaseAsArray() {\n      // TODO(perf):  Avoid a copy/move by allowing Array<T> to point to incomplete space?\n      if (!builder.isFull()) {\n        setCapacity(size());\n      }\n      return builder.finish();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "addresses.size() > 0",
            "\"DNS lookup returned no addresses.\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addresses.size",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input->tryRead",
          "args": [
            "&current",
            "sizeof(current)",
            "sizeof(current)"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "tryRead",
          "container": "TestInputStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/capnp/serialize-test.c++",
          "lines": "156-162",
          "snippet": "size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n    size_t amount = lazy ? minBytes : maxBytes;\n    memcpy(buffer, pos, amount);\n    pos += amount;\n    return amount;\n  }",
          "includes": [
            "#include \"test-util.h\"",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include <kj/miniposix.h>",
            "#include <kj/compat/gtest.h>",
            "#include <kj/debug.h>",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"test-util.h\"\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string>\n#include <kj/miniposix.h>\n#include <kj/compat/gtest.h>\n#include <kj/debug.h>\n#include \"serialize.h\"\n\nTestInputStream {\n  size_t tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n      KJ_ASSERT(maxBytes <= size_t(end - pos), \"Overran end of stream.\");\n      size_t amount = lazy ? minBytes : maxBytes;\n      memcpy(buffer, pos, amount);\n      pos += amount;\n      return amount;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<Array<SocketAddress>> read() {\n    return input->tryRead(&current, sizeof(current), sizeof(current)).then(\n        [this](size_t n) -> Promise<Array<SocketAddress>> {\n      if (n < sizeof(current)) {\n        thread = nullptr;\n        // getaddrinfo()'s docs seem to say it will never return an empty list, but let's check\n        // anyway.\n        KJ_REQUIRE(addresses.size() > 0, \"DNS lookup returned no addresses.\") { break; }\n        return addresses.releaseAsArray();\n      } else {\n        // getaddrinfo() can return multiple copies of the same address for several reasons.\n        // A major one is that we don't give it a socket type (SOCK_STREAM vs. SOCK_DGRAM), so\n        // it may return two copies of the same address, one for each type, unless it explicitly\n        // knows that the service name given is specific to one type.  But we can't tell it a type,\n        // because we don't actually know which one the user wants, and if we specify SOCK_STREAM\n        // while the user specified a UDP service name then they'll get a resolution error which\n        // is lame.  (At least, I think that's how it works.)\n        //\n        // So we instead resort to de-duping results.\n        if (alreadySeen.insert(current).second) {\n          addresses.add(current);\n        }\n        return read();\n      }\n    });\n  }"
  },
  {
    "function_name": "LookupReader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "639-640",
    "snippet": "LookupReader(kj::Own<Thread>&& thread, kj::Own<AsyncInputStream>&& input)\n      : thread(kj::mv(thread)), input(kj::mv(input)) {}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "input"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::mv",
          "args": [
            "thread"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nLookupReader(kj::Own<Thread>&& thread, kj::Own<AsyncInputStream>&& input)\n      : thread(kj::mv(thread)), input(kj::mv(input)) {}"
  },
  {
    "function_name": "getLocalAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "608-613",
    "snippet": "static SocketAddress getLocalAddress(int sockfd) {\n    SocketAddress result;\n    result.addrlen = sizeof(addr);\n    KJ_SYSCALL(getsockname(sockfd, &result.addr.generic, &result.addrlen));\n    return result;\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "socklen_t addrlen;",
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "getsockname(sockfd, &result.addr.generic, &result.addrlen)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "sockfd",
            "&result.addr.generic",
            "&result.addrlen"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nstatic SocketAddress getLocalAddress(int sockfd) {\n    SocketAddress result;\n    result.addrlen = sizeof(addr);\n    KJ_SYSCALL(getsockname(sockfd, &result.addr.generic, &result.addrlen));\n    return result;\n  }"
  },
  {
    "function_name": "KJ_IF_MAYBE",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "550-558",
    "snippet": "KJ_IF_MAYBE(portText, portPart) {\n      char* endptr;\n      port = strtoul(portText->cStr(), &endptr, 0);\n      if (portText->size() == 0 || *endptr != '\\0') {\n        // Not a number.  Maybe it's a service name.  Fall back to DNS.\n        return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n      }\n      KJ_REQUIRE(port < 65536, \"Port number too large.\");\n    }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "port < 65536",
            "\"Port number too large.\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookupHost",
          "args": [
            "lowLevel",
            "kj::heapString(addrPart)",
            "kj::heapString(*portText)",
            "portHint"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kj::heapString",
          "args": [
            "*portText"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "portText->size",
          "args": [],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "portText->cStr()",
            "&endptr",
            "0"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "portText->cStr",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nSocketAddress {\n  KJ_IF_MAYBE(portText, portPart) {\n        char* endptr;\n        port = strtoul(portText->cStr(), &endptr, 0);\n        if (portText->size() == 0 || *endptr != '\\0') {\n          // Not a number.  Maybe it's a service name.  Fall back to DNS.\n          return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n        }\n        KJ_REQUIRE(port < 65536, \"Port number too large.\");\n      }\n}"
  },
  {
    "function_name": "parse",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "490-546",
    "snippet": "static Promise<Array<SocketAddress>> parse(\n      LowLevelAsyncIoProvider& lowLevel, StringPtr str, uint portHint) {\n    // TODO(someday):  Allow commas in `str`.\n\n    SocketAddress result;\n\n    if (str.startsWith(\"unix:\")) {\n      StringPtr path = str.slice(strlen(\"unix:\"));\n      KJ_REQUIRE(path.size() < sizeof(addr.unixDomain.sun_path),\n                 \"Unix domain socket address is too long.\", str);\n      result.addr.unixDomain.sun_family = AF_UNIX;\n      strcpy(result.addr.unixDomain.sun_path, path.cStr());\n      result.addrlen = offsetof(struct sockaddr_un, sun_path) + path.size() + 1;\n      auto array = kj::heapArrayBuilder<SocketAddress>(1);\n      array.add(result);\n      return array.finish();\n    }\n\n    // Try to separate the address and port.\n    ArrayPtr<const char> addrPart;\n    Maybe<StringPtr> portPart;\n\n    int af;\n\n    if (str.startsWith(\"[\")) {\n      // Address starts with a bracket, which is a common way to write an ip6 address with a port,\n      // since without brackets around the address part, the port looks like another segment of\n      // the address.\n      af = AF_INET6;\n      size_t closeBracket = KJ_ASSERT_NONNULL(str.findLast(']'),\n          \"Unclosed '[' in address string.\", str);\n\n      addrPart = str.slice(1, closeBracket);\n      if (str.size() > closeBracket + 1) {\n        KJ_REQUIRE(str.slice(closeBracket + 1).startsWith(\":\"),\n                   \"Expected port suffix after ']'.\", str);\n        portPart = str.slice(closeBracket + 2);\n      }\n    } else {\n      KJ_IF_MAYBE(colon, str.findFirst(':')) {\n        if (str.slice(*colon + 1).findFirst(':') == nullptr) {\n          // There is exactly one colon and no brackets, so it must be an ip4 address with port.\n          af = AF_INET;\n          addrPart = str.slice(0, *colon);\n          portPart = str.slice(*colon + 1);\n        } else {\n          // There are two or more colons and no brackets, so the whole thing must be an ip6\n          // address with no port.\n          af = AF_INET6;\n          addrPart = str;\n        }\n      } else {\n        // No colons, so it must be an ip4 address without port.\n        af = AF_INET;\n        addrPart = str;\n      }\n    }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "socklen_t addrlen;",
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "str.slice",
          "args": [
            "*colon + 1"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "177-177",
          "snippet": "inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline StringPtr slice(size_t start) const { return StringPtr(*this).slice(start); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.slice",
          "args": [
            "0",
            "*colon"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "colon",
            "str.findFirst(':')"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "550-558",
          "snippet": "KJ_IF_MAYBE(portText, portPart) {\n      char* endptr;\n      port = strtoul(portText->cStr(), &endptr, 0);\n      if (portText->size() == 0 || *endptr != '\\0') {\n        // Not a number.  Maybe it's a service name.  Fall back to DNS.\n        return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n      }\n      KJ_REQUIRE(port < 65536, \"Port number too large.\");\n    }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nSocketAddress {\n  KJ_IF_MAYBE(portText, portPart) {\n        char* endptr;\n        port = strtoul(portText->cStr(), &endptr, 0);\n        if (portText->size() == 0 || *endptr != '\\0') {\n          // Not a number.  Maybe it's a service name.  Fall back to DNS.\n          return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n        }\n        KJ_REQUIRE(port < 65536, \"Port number too large.\");\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.findFirst",
          "args": [
            "':'"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "findFirst",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "182-182",
          "snippet": "inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findFirst(char c) const { return StringPtr(*this).findFirst(c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "str.slice(closeBracket + 1).startsWith(\":\")",
            "\"Expected port suffix after ']'.\"",
            "str"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.size",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_ASSERT_NONNULL",
          "args": [
            "str.findLast(']')",
            "\"Unclosed '[' in address string.\"",
            "str"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.findLast",
          "args": [
            "']'"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "findLast",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "183-183",
          "snippet": "inline Maybe<size_t> findLast(char c) const { return StringPtr(*this).findLast(c); }",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline Maybe<size_t> findLast(char c) const { return StringPtr(*this).findLast(c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.startsWith",
          "args": [
            "\"[\""
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "startsWith",
          "container": "String",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.h",
          "lines": "174-174",
          "snippet": "inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}",
          "includes": [
            "#include <string.h>",
            "#include \"array.h\"",
            "#include <initializer_list>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include \"array.h\"\n#include <initializer_list>\n\nString {\n  inline bool startsWith(const StringPtr& other) const { return StringPtr(*this).startsWith(other);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "array.finish",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": "ArrayBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "369-382",
          "snippet": "Array<T> finish() {\n    // We could safely remove this check if we assume that the disposer implementation doesn't\n    // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n    // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n    // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n    // check might catch bugs.  Probably people should use Vector if they want to build arrays\n    // without knowing the final size in advance.\n    KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n    Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n    ptr = nullptr;\n    pos = nullptr;\n    endPtr = nullptr;\n    return result;\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\nArrayBuilder {\n  Array<T> finish() {\n      // We could safely remove this check if we assume that the disposer implementation doesn't\n      // need to know the original capacity, as is thes case with HeapArrayDisposer since it uses\n      // operator new() or if we created a custom disposer for ArrayBuilder which stores the capacity\n      // in a prefix.  But that would make it hard to write cleverer heap allocators, and anyway this\n      // check might catch bugs.  Probably people should use Vector if they want to build arrays\n      // without knowing the final size in advance.\n      KJ_IREQUIRE(pos == endPtr, \"ArrayBuilder::finish() called prematurely.\");\n      Array<T> result(reinterpret_cast<T*>(ptr), pos - ptr, *disposer);\n      ptr = nullptr;\n      pos = nullptr;\n      endPtr = nullptr;\n      return result;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "array.add",
          "args": [
            "result"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "add",
          "container": "TaskSetImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async.c++",
          "lines": "149-153",
          "snippet": "void add(Promise<void>&& promise) {\n    auto task = heap<Task>(*this, kj::mv(promise.node));\n    Task* ptr = task;\n    tasks.insert(std::make_pair(ptr, kj::mv(task)));\n  }",
          "includes": [
            "#include <stdlib.h>",
            "#include <cxxabi.h>",
            "#include <typeinfo>",
            "#include <linux/futex.h>",
            "#include <sys/syscall.h>",
            "#include <unistd.h>",
            "#include <map>",
            "#include <exception>",
            "#include \"threadlocal.h\"",
            "#include \"vector.h\"",
            "#include \"debug.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <cxxabi.h>\n#include <typeinfo>\n#include <linux/futex.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include <map>\n#include <exception>\n#include \"threadlocal.h\"\n#include \"vector.h\"\n#include \"debug.h\"\n#include \"async.h\"\n\nTaskSetImpl {\n  void add(Promise<void>&& promise) {\n      auto task = heap<Task>(*this, kj::mv(promise.node));\n      Task* ptr = task;\n      tasks.insert(std::make_pair(ptr, kj::mv(task)));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "kj::heapArrayBuilder<SocketAddress>",
          "args": [
            "1"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "heapArrayBuilder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/array.h",
          "lines": "410-416",
          "snippet": "inline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <string.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <string.h>\n#include \"common.h\"\n\ninline ArrayBuilder<T> heapArrayBuilder(size_t size) {\n  // Like `heapArray<T>()` but does not default-construct the elements.  You must construct them\n  // manually by calling `add()`.\n\n  return ArrayBuilder<T>(_::HeapArrayDisposer::allocateUninitialized<RemoveConst<T>>(size),\n                         size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "result.addr.unixDomain.sun_path",
            "path.cStr()"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path.cStr",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "path.size() < sizeof(addr.unixDomain.sun_path)",
            "\"Unix domain socket address is too long.\"",
            "str"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"unix:\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  static Promise<Array<SocketAddress>> parse(\n        LowLevelAsyncIoProvider& lowLevel, StringPtr str, uint portHint) {\n      // TODO(someday):  Allow commas in `str`.\n  \n      SocketAddress result;\n  \n      if (str.startsWith(\"unix:\")) {\n        StringPtr path = str.slice(strlen(\"unix:\"));\n        KJ_REQUIRE(path.size() < sizeof(addr.unixDomain.sun_path),\n                   \"Unix domain socket address is too long.\", str);\n        result.addr.unixDomain.sun_family = AF_UNIX;\n        strcpy(result.addr.unixDomain.sun_path, path.cStr());\n        result.addrlen = offsetof(struct sockaddr_un, sun_path) + path.size() + 1;\n        auto array = kj::heapArrayBuilder<SocketAddress>(1);\n        array.add(result);\n        return array.finish();\n      }\n  \n      // Try to separate the address and port.\n      ArrayPtr<const char> addrPart;\n      Maybe<StringPtr> portPart;\n  \n      int af;\n  \n      if (str.startsWith(\"[\")) {\n        // Address starts with a bracket, which is a common way to write an ip6 address with a port,\n        // since without brackets around the address part, the port looks like another segment of\n        // the address.\n        af = AF_INET6;\n        size_t closeBracket = KJ_ASSERT_NONNULL(str.findLast(']'),\n            \"Unclosed '[' in address string.\", str);\n  \n        addrPart = str.slice(1, closeBracket);\n        if (str.size() > closeBracket + 1) {\n          KJ_REQUIRE(str.slice(closeBracket + 1).startsWith(\":\"),\n                     \"Expected port suffix after ']'.\", str);\n          portPart = str.slice(closeBracket + 2);\n        }\n      } else {\n        KJ_IF_MAYBE(colon, str.findFirst(':')) {\n          if (str.slice(*colon + 1).findFirst(':') == nullptr) {\n            // There is exactly one colon and no brackets, so it must be an ip4 address with port.\n            af = AF_INET;\n            addrPart = str.slice(0, *colon);\n            portPart = str.slice(*colon + 1);\n          } else {\n            // There are two or more colons and no brackets, so the whole thing must be an ip6\n            // address with no port.\n            af = AF_INET6;\n            addrPart = str;\n          }\n        } else {\n          // No colons, so it must be an ip4 address without port.\n          af = AF_INET;\n          addrPart = str;\n        }\n      }\n}"
  },
  {
    "function_name": "toString",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "456-484",
    "snippet": "String toString() const {\n    if (wildcard) {\n      return str(\"*:\", getPort());\n    }\n\n    switch (addr.generic.sa_family) {\n      case AF_INET: {\n        char buffer[INET6_ADDRSTRLEN];\n        if (inet_ntop(addr.inet4.sin_family, &addr.inet4.sin_addr,\n                      buffer, sizeof(buffer)) == nullptr) {\n          KJ_FAIL_SYSCALL(\"inet_ntop\", errno) { return heapString(\"(inet_ntop error)\"); }\n        }\n        return str(buffer, ':', ntohs(addr.inet4.sin_port));\n      }\n      case AF_INET6: {\n        char buffer[INET6_ADDRSTRLEN];\n        if (inet_ntop(addr.inet6.sin6_family, &addr.inet6.sin6_addr,\n                      buffer, sizeof(buffer)) == nullptr) {\n          KJ_FAIL_SYSCALL(\"inet_ntop\", errno) { return heapString(\"(inet_ntop error)\"); }\n        }\n        return str('[', buffer, \"]:\", ntohs(addr.inet6.sin6_port));\n      }\n      case AF_UNIX: {\n        return str(\"unix:\", addr.unixDomain.sun_path);\n      }\n      default:\n        return str(\"(unknown address family \", addr.generic.sa_family, \")\");\n    }\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool wildcard = false;",
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"(unknown address family \"",
            "addr.generic.sa_family",
            "\")\""
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"unix:\"",
            "addr.unixDomain.sun_path"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "'['",
            "buffer",
            "\"]:\"",
            "ntohs(addr.inet6.sin6_port)"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.inet6.sin6_port"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heapString",
          "args": [
            "\"(inet_ntop error)\""
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "heapString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/string.c++",
          "lines": "36-40",
          "snippet": "String heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <float.h>",
            "#include <stdio.h>",
            "#include \"debug.h\"",
            "#include \"string.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <errno.h>\n#include <float.h>\n#include <stdio.h>\n#include \"debug.h\"\n#include \"string.h\"\n\nString heapString(size_t size) {\n  char* buffer = _::HeapArrayDisposer::allocate<char>(size + 1);\n  buffer[size] = '\\0';\n  return String(buffer, size, _::HeapArrayDisposer::instance);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"inet_ntop\"",
            "errno"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "addr.inet6.sin6_family",
            "&addr.inet6.sin6_addr",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "buffer",
            "':'",
            "ntohs(addr.inet4.sin_port)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.inet4.sin_port"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"inet_ntop\"",
            "errno"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntop",
          "args": [
            "addr.inet4.sin_family",
            "&addr.inet4.sin_addr",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str",
          "args": [
            "\"*:\"",
            "getPort()"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getPort",
          "args": [],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "getPort",
          "container": "DatagramPortImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "863-865",
          "snippet": "uint getPort() override {\n    return SocketAddress::getLocalAddress(fd).getPort();\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nDatagramPortImpl {\n  uint getPort() override {\n      return SocketAddress::getLocalAddress(fd).getPort();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nbool wildcard = false;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  String toString() const {\n      if (wildcard) {\n        return str(\"*:\", getPort());\n      }\n  \n      switch (addr.generic.sa_family) {\n        case AF_INET: {\n          char buffer[INET6_ADDRSTRLEN];\n          if (inet_ntop(addr.inet4.sin_family, &addr.inet4.sin_addr,\n                        buffer, sizeof(buffer)) == nullptr) {\n            KJ_FAIL_SYSCALL(\"inet_ntop\", errno) { return heapString(\"(inet_ntop error)\"); }\n          }\n          return str(buffer, ':', ntohs(addr.inet4.sin_port));\n        }\n        case AF_INET6: {\n          char buffer[INET6_ADDRSTRLEN];\n          if (inet_ntop(addr.inet6.sin6_family, &addr.inet6.sin6_addr,\n                        buffer, sizeof(buffer)) == nullptr) {\n            KJ_FAIL_SYSCALL(\"inet_ntop\", errno) { return heapString(\"(inet_ntop error)\"); }\n          }\n          return str('[', buffer, \"]:\", ntohs(addr.inet6.sin6_port));\n        }\n        case AF_UNIX: {\n          return str(\"unix:\", addr.unixDomain.sun_path);\n        }\n        default:\n          return str(\"(unknown address family \", addr.generic.sa_family, \")\");\n      }\n    }\n}"
  },
  {
    "function_name": "getPort",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "448-454",
    "snippet": "uint getPort() const {\n    switch (addr.generic.sa_family) {\n      case AF_INET: return ntohs(addr.inet4.sin_port);\n      case AF_INET6: return ntohs(addr.inet6.sin6_port);\n      default: return 0;\n    }\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.inet6.sin6_port"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.inet4.sin_port"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  uint getPort() const {\n      switch (addr.generic.sa_family) {\n        case AF_INET: return ntohs(addr.inet4.sin_port);\n        case AF_INET6: return ntohs(addr.inet6.sin6_port);\n        default: return 0;\n      }\n    }\n}"
  },
  {
    "function_name": "connect",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "427-446",
    "snippet": "void connect(int sockfd) const {\n    // Unfortunately connect() doesn't fit the mold of KJ_NONBLOCKING_SYSCALL, since it indicates\n    // non-blocking using EINPROGRESS.\n    for (;;) {\n      if (::connect(sockfd, &addr.generic, addrlen) < 0) {\n        int error = errno;\n        if (error == EINPROGRESS) {\n          return;\n        } else if (error != EINTR) {\n          KJ_FAIL_SYSCALL(\"connect()\", error, toString()) {\n            // Recover by returning, since reads/writes will simply fail.\n            return;\n          }\n        }\n      } else {\n        // no error\n        return;\n      }\n    }\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "socklen_t addrlen;",
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_FAIL_SYSCALL",
          "args": [
            "\"connect()\"",
            "error",
            "toString()"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1012-1014",
          "snippet": "String toString() override {\n    return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nNetworkAddressImpl {\n  String toString() override {\n      return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::connect",
          "args": [
            "sockfd",
            "&addr.generic",
            "addrlen"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "connectImpl",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1026-1059",
          "snippet": "Promise<Own<AsyncIoStream>> connectImpl(uint index) {\n    KJ_ASSERT(index < addrs.size());\n\n    int fd = addrs[index].socket(SOCK_STREAM);\n\n    KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n      addrs[index].connect(fd);\n    })) {\n      // Connect failed.\n      close(fd);\n      if (index + 1 < addrs.size()) {\n        // Try the next address instead.\n        return connectImpl(index + 1);\n      } else {\n        // No more addresses to try, so propagate the exception.\n        return kj::mv(*exception);\n      }\n    }\n\n    return lowLevel.wrapConnectingSocketFd(fd, NEW_FD_FLAGS).then(\n        [](Own<AsyncIoStream>&& stream) -> Promise<Own<AsyncIoStream>> {\n      // Success, pass along.\n      return kj::mv(stream);\n    }, [this,index](Exception&& exception) -> Promise<Own<AsyncIoStream>> {\n      // Connect failed.\n      if (index + 1 < addrs.size()) {\n        // Try the next address instead.\n        return connectImpl(index + 1);\n      } else {\n        // No more addresses to try, so propagate the exception.\n        return kj::mv(exception);\n      }\n    });\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nNetworkAddressImpl {\n  Promise<Own<AsyncIoStream>> connectImpl(uint index) {\n      KJ_ASSERT(index < addrs.size());\n  \n      int fd = addrs[index].socket(SOCK_STREAM);\n  \n      KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n        addrs[index].connect(fd);\n      })) {\n        // Connect failed.\n        close(fd);\n        if (index + 1 < addrs.size()) {\n          // Try the next address instead.\n          return connectImpl(index + 1);\n        } else {\n          // No more addresses to try, so propagate the exception.\n          return kj::mv(*exception);\n        }\n      }\n  \n      return lowLevel.wrapConnectingSocketFd(fd, NEW_FD_FLAGS).then(\n          [](Own<AsyncIoStream>&& stream) -> Promise<Own<AsyncIoStream>> {\n        // Success, pass along.\n        return kj::mv(stream);\n      }, [this,index](Exception&& exception) -> Promise<Own<AsyncIoStream>> {\n        // Connect failed.\n        if (index + 1 < addrs.size()) {\n          // Try the next address instead.\n          return connectImpl(index + 1);\n        } else {\n          // No more addresses to try, so propagate the exception.\n          return kj::mv(exception);\n        }\n      });\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  void connect(int sockfd) const {\n      // Unfortunately connect() doesn't fit the mold of KJ_NONBLOCKING_SYSCALL, since it indicates\n      // non-blocking using EINPROGRESS.\n      for (;;) {\n        if (::connect(sockfd, &addr.generic, addrlen) < 0) {\n          int error = errno;\n          if (error == EINPROGRESS) {\n            return;\n          } else if (error != EINTR) {\n            KJ_FAIL_SYSCALL(\"connect()\", error, toString()) {\n              // Recover by returning, since reads/writes will simply fail.\n              return;\n            }\n          }\n        } else {\n          // no error\n          return;\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "bind",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "416-425",
    "snippet": "void bind(int sockfd) const {\n    if (wildcard) {\n      // Disable IPV6_V6ONLY because we want to handle both ipv4 and ipv6 on this socket.  (The\n      // default value of this option varies across platforms.)\n      int value = 0;\n      KJ_SYSCALL(setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &value, sizeof(value)));\n    }\n\n    KJ_SYSCALL(::bind(sockfd, &addr.generic, addrlen), toString());\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "socklen_t addrlen;",
      "bool wildcard = false;",
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::bind(sockfd, &addr.generic, addrlen)",
            "toString()"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toString",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "toString",
          "container": "NetworkAddressImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1012-1014",
          "snippet": "String toString() override {\n    return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n  }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nNetworkAddressImpl {\n  String toString() override {\n      return strArray(KJ_MAP(addr, addrs) { return addr.toString(); }, \",\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::bind",
          "args": [
            "sockfd",
            "&addr.generic",
            "addrlen"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &value, sizeof(value))"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "sockfd",
            "IPPROTO_IPV6",
            "IPV6_V6ONLY",
            "&value",
            "sizeof(value)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nbool wildcard = false;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  void bind(int sockfd) const {\n      if (wildcard) {\n        // Disable IPV6_V6ONLY because we want to handle both ipv4 and ipv6 on this socket.  (The\n        // default value of this option varies across platforms.)\n        int value = 0;\n        KJ_SYSCALL(setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &value, sizeof(value)));\n      }\n  \n      KJ_SYSCALL(::bind(sockfd, &addr.generic, addrlen), toString());\n    }\n}"
  },
  {
    "function_name": "socket",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "392-414",
    "snippet": "int socket(int type) const {\n    bool isStream = type == SOCK_STREAM;\n\n    int result;\n#if __linux__ && !__BIONIC__\n    type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n#endif\n    KJ_SYSCALL(result = ::socket(addr.generic.sa_family, type, 0));\n\n    if (isStream && (addr.generic.sa_family == AF_INET ||\n                     addr.generic.sa_family == AF_INET6)) {\n      // TODO(perf):  As a hack for the 0.4 release we are always setting\n      //   TCP_NODELAY because Nagle's algorithm pretty much kills Cap'n Proto's\n      //   RPC protocol.  Later, we should extend the interface to provide more\n      //   control over this.  Perhaps write() should have a flag which\n      //   specifies whether to pass MSG_MORE.\n      int one = 1;\n      KJ_SYSCALL(setsockopt(\n          result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one)));\n    }\n\n    return result;\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "setsockopt(\n          result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one))"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "result",
            "IPPROTO_TCP",
            "TCP_NODELAY",
            "(char*)&one",
            "sizeof(one)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "result = ::socket(addr.generic.sa_family, type, 0)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::socket",
          "args": [
            "addr.generic.sa_family",
            "type",
            "0"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  int socket(int type) const {\n      bool isStream = type == SOCK_STREAM;\n  \n      int result;\n  #if __linux__ && !__BIONIC__\n      type |= SOCK_NONBLOCK | SOCK_CLOEXEC;\n  #endif\n      KJ_SYSCALL(result = ::socket(addr.generic.sa_family, type, 0));\n  \n      if (isStream && (addr.generic.sa_family == AF_INET ||\n                       addr.generic.sa_family == AF_INET6)) {\n        // TODO(perf):  As a hack for the 0.4 release we are always setting\n        //   TCP_NODELAY because Nagle's algorithm pretty much kills Cap'n Proto's\n        //   RPC protocol.  Later, we should extend the interface to provide more\n        //   control over this.  Perhaps write() should have a flag which\n        //   specifies whether to pass MSG_MORE.\n        int one = 1;\n        KJ_SYSCALL(setsockopt(\n            result, IPPROTO_TCP, TCP_NODELAY, (char*)&one, sizeof(one)));\n      }\n  \n      return result;\n    }\n}"
  },
  {
    "function_name": "getRawSize",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "390-390",
    "snippet": "socklen_t getRawSize() const { return addrlen; }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "socklen_t addrlen;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\n\nSocketAddress {\n  socklen_t getRawSize() const { return addrlen; }\n}"
  },
  {
    "function_name": "SocketAddress",
    "container": "SocketAddress",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "372-375",
    "snippet": "SocketAddress(const void* sockaddr, uint len): addrlen(len) {\n    KJ_REQUIRE(len <= sizeof(addr), \"Sorry, your sockaddr is too big for me.\");\n    memcpy(&addr.generic, sockaddr, len);\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "socklen_t addrlen;",
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr.generic",
            "sockaddr",
            "len"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "len <= sizeof(addr)",
            "\"Sorry, your sockaddr is too big for me.\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nsocklen_t addrlen;\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nSocketAddress {\n  SocketAddress(const void* sockaddr, uint len): addrlen(len) {\n      KJ_REQUIRE(len <= sizeof(addr), \"Sorry, your sockaddr is too big for me.\");\n      memcpy(&addr.generic, sockaddr, len);\n    }\n}"
  },
  {
    "function_name": "Promise<void> writeInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "114-365",
    "snippet": "class AsyncStreamFd: public OwnedFileDescriptor, public AsyncIoStream {\npublic:\n  AsyncStreamFd(UnixEventPort& eventPort, int fd, uint flags)\n      : OwnedFileDescriptor(fd, flags),\n        observer(eventPort, fd, UnixEventPort::FdObserver::OBSERVE_READ_WRITE) {}\n  virtual ~AsyncStreamFd() noexcept(false) {}\n\n  Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return tryReadInternal(buffer, minBytes, maxBytes, 0).then([=](size_t result) {\n      KJ_REQUIRE(result >= minBytes, \"Premature EOF\") {\n        // Pretend we read zeros from the input.\n        memset(reinterpret_cast<byte*>(buffer) + result, 0, minBytes - result);\n        return minBytes;\n      }\n      return result;\n    });\n  }\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return tryReadInternal(buffer, minBytes, maxBytes, 0);\n  }\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    ssize_t writeResult;\n    KJ_NONBLOCKING_SYSCALL(writeResult = ::write(fd, buffer, size)) {\n      // Error.\n\n      // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n      // a bug that exists in both Clang and GCC:\n      //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n      //   http://llvm.org/bugs/show_bug.cgi?id=12286\n      goto error;\n    }\n    if (false) {\n    error:\n      return kj::READY_NOW;\n    }\n\n    // A negative result means EAGAIN, which we can treat the same as having written zero bytes.\n    size_t n = writeResult < 0 ? 0 : writeResult;\n\n    if (n == size) {\n      return READY_NOW;\n    }\n\n    // Fewer than `size` bytes were written, therefore we must be out of buffer space. Wait until\n    // the fd becomes writable again.\n    buffer = reinterpret_cast<const byte*>(buffer) + n;\n    size -= n;\n\n    return observer.whenBecomesWritable().then([=]() {\n      return write(buffer, size);\n    });\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    if (pieces.size() == 0) {\n      return writeInternal(nullptr, nullptr);\n    } else {\n      return writeInternal(pieces[0], pieces.slice(1, pieces.size()));\n    }\n  }\n\n  void shutdownWrite() override {\n    // There's no legitimate way to get an AsyncStreamFd that isn't a socket through the\n    // UnixAsyncIoProvider interface.\n    KJ_SYSCALL(shutdown(fd, SHUT_WR));\n  }\n\n  void abortRead() override {\n    // There's no legitimate way to get an AsyncStreamFd that isn't a socket through the\n    // UnixAsyncIoProvider interface.\n    KJ_SYSCALL(shutdown(fd, SHUT_RD));\n  }\n\n  void getsockopt(int level, int option, void* value, uint* length) override {\n    socklen_t socklen = *length;\n    KJ_SYSCALL(::getsockopt(fd, level, option, value, &socklen));\n    *length = socklen;\n  }\n\n  void setsockopt(int level, int option, const void* value, uint length) override {\n    KJ_SYSCALL(::setsockopt(fd, level, option, value, length));\n  }\n\n  void getsockname(struct sockaddr* addr, uint* length) override {\n    socklen_t socklen = *length;\n    KJ_SYSCALL(::getsockname(fd, addr, &socklen));\n    *length = socklen;\n  }\n\n  void getpeername(struct sockaddr* addr, uint* length) override {\n    socklen_t socklen = *length;\n    KJ_SYSCALL(::getpeername(fd, addr, &socklen));\n    *length = socklen;\n  }\n\n  Promise<void> waitConnected() {\n    // Wait until initial connection has completed. This actually just waits until it is writable.\n\n    // Can't just go directly to writeObserver.whenBecomesWritable() because of edge triggering. We\n    // need to explicitly check if the socket is already connected.\n\n    struct pollfd pollfd;\n    memset(&pollfd, 0, sizeof(pollfd));\n    pollfd.fd = fd;\n    pollfd.events = POLLOUT;\n\n    int pollResult;\n    KJ_SYSCALL(pollResult = poll(&pollfd, 1, 0));\n\n    if (pollResult == 0) {\n      // Not ready yet. We can safely use the edge-triggered observer.\n      return observer.whenBecomesWritable();\n    } else {\n      // Ready now.\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  UnixEventPort::FdObserver observer;\n\n  Promise<size_t> tryReadInternal(void* buffer, size_t minBytes, size_t maxBytes,\n                                  size_t alreadyRead) {\n    // `alreadyRead` is the number of bytes we have already received via previous reads -- minBytes,\n    // maxBytes, and buffer have already been adjusted to account for them, but this count must\n    // be included in the final return value.\n\n    ssize_t n;\n    KJ_NONBLOCKING_SYSCALL(n = ::read(fd, buffer, maxBytes)) {\n      // Error.\n\n      // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n      // a bug that exists in both Clang and GCC:\n      //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n      //   http://llvm.org/bugs/show_bug.cgi?id=12286\n      goto error;\n    }\n    if (false) {\n    error:\n      return alreadyRead;\n    }\n\n    if (n < 0) {\n      // Read would block.\n      return observer.whenBecomesReadable().then([=]() {\n        return tryReadInternal(buffer, minBytes, maxBytes, alreadyRead);\n      });\n    } else if (n == 0) {\n      // EOF -OR- maxBytes == 0.\n      return alreadyRead;\n    } else if (implicitCast<size_t>(n) >= minBytes) {\n      // We read enough to stop here.\n      return alreadyRead + n;\n    } else {\n      // The kernel returned fewer bytes than we asked for (and fewer than we need).\n\n      buffer = reinterpret_cast<byte*>(buffer) + n;\n      minBytes -= n;\n      maxBytes -= n;\n      alreadyRead += n;\n\n      KJ_IF_MAYBE(atEnd, observer.atEndHint()) {\n        if (*atEnd) {\n          // We've already received an indication that the next read() will return EOF, so there's\n          // nothing to wait for.\n          return alreadyRead;\n        } else {\n          // As of the last time the event queue was checked, the kernel reported that we were\n          // *not* at the end of the stream. It's unlikely that this has changed in the short time\n          // it took to handle the event, therefore calling read() now will almost certainly fail\n          // with EAGAIN. Moreover, since EOF had not been received as of the last check, we know\n          // that even if it was received since then, whenBecomesReadable() will catch that. So,\n          // let's go ahead and skip calling read() here and instead go straight to waiting for\n          // more input.\n          return observer.whenBecomesReadable().then([=]() {\n            return tryReadInternal(buffer, minBytes, maxBytes, alreadyRead);\n          });\n        }\n      } else {\n        // The kernel has not indicated one way or the other whether we are likely to be at EOF.\n        // In this case we *must* keep calling read() until we either get a return of zero or\n        // EAGAIN.\n        return tryReadInternal(buffer, minBytes, maxBytes, alreadyRead);\n      }\n    }\n  }\n\n  Promise<void> writeInternal(ArrayPtr<const byte> firstPiece,\n                              ArrayPtr<const ArrayPtr<const byte>> morePieces) {\n    // If there are more than IOV_MAX pieces, we'll only write the first IOV_MAX for now, and\n    // then we'll loop later.\n    KJ_STACK_ARRAY(struct iovec, iov, kj::min(1 + morePieces.size(), IOV_MAX), 16, 128);\n    size_t iovTotal = 0;\n\n    // writev() interface is not const-correct.  :(\n    iov[0].iov_base = const_cast<byte*>(firstPiece.begin());\n    iov[0].iov_len = firstPiece.size();\n    iovTotal += iov[0].iov_len;\n    for (uint i = 1; i < iov.size(); i++) {\n      iov[i].iov_base = const_cast<byte*>(morePieces[i - 1].begin());\n      iov[i].iov_len = morePieces[i - 1].size();\n      iovTotal += iov[i].iov_len;\n    }\n\n    ssize_t writeResult;\n    KJ_NONBLOCKING_SYSCALL(writeResult = ::writev(fd, iov.begin(), iov.size())) {\n      // Error.\n\n      // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n      // a bug that exists in both Clang and GCC:\n      //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n      //   http://llvm.org/bugs/show_bug.cgi?id=12286\n      goto error;\n    }\n    if (false) {\n    error:\n      return kj::READY_NOW;\n    }\n\n    // A negative result means EAGAIN, which we can treat the same as having written zero bytes.\n    size_t n = writeResult < 0 ? 0 : writeResult;\n\n    // Discard all data that was written, then issue a new write for what's left (if any).\n    for (;;) {\n      if (n < firstPiece.size()) {\n        // Only part of the first piece was consumed.  Wait for buffer space and then write again.\n        firstPiece = firstPiece.slice(n, firstPiece.size());\n        iovTotal -= n;\n\n        if (iovTotal == 0) {\n          // Oops, what actually happened is that we hit the IOV_MAX limit. Don't wait.\n          return writeInternal(firstPiece, morePieces);\n        }\n\n        return observer.whenBecomesWritable().then([=]() {\n          return writeInternal(firstPiece, morePieces);\n        });\n      } else if (morePieces.size() == 0) {\n        // First piece was fully-consumed and there are no more pieces, so we're done.\n        KJ_DASSERT(n == firstPiece.size(), n);\n        return READY_NOW;\n      } else {\n        // First piece was fully consumed, so move on to the next piece.\n        n -= firstPiece.size();\n        iovTotal -= firstPiece.size();\n        firstPiece = morePieces[0];\n        morePieces = morePieces.slice(1, morePieces.size());\n      }\n    }\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [
      "#define IOV_MAX UIO_MAXIOV"
    ],
    "globals_used": [
      "union {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "morePieces.slice",
          "args": [
            "1",
            "morePieces.size()"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "slice",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1154-1157",
          "snippet": "inline ArrayPtr slice(size_t start, size_t end) {\n    KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n    return ArrayPtr(ptr + start, end - start);\n  }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline ArrayPtr slice(size_t start, size_t end) {\n      KJ_IREQUIRE(start <= end && end <= size_, \"Out-of-bounds ArrayPtr::slice().\");\n      return ArrayPtr(ptr + start, end - start);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "morePieces.size",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ArrayPtr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1131-1131",
          "snippet": "inline size_t size() const { return size_; }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nArrayPtr {\n  inline size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DASSERT",
          "args": [
            "n == firstPiece.size()",
            "n"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [
            "[=]() {\n          return writeInternal(firstPiece, morePieces);\n        }"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeInternal",
          "args": [
            "firstPiece",
            "morePieces"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeInternal",
          "args": [
            "firstPiece",
            "morePieces"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::writev",
          "args": [
            "fd",
            "iov.begin()",
            "iov.size()"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov.begin",
          "args": [],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "Repeat",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "692-692",
          "snippet": "inline Iterator begin() const { return Iterator(value, 0); }",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nRepeat {\n  inline Iterator begin() const { return Iterator(value, 0); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "const_cast<byte*>",
          "args": [
            "morePieces[i - 1].begin()"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<byte*>",
          "args": [
            "firstPiece.begin()"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryReadInternal",
          "args": [
            "buffer",
            "minBytes",
            "maxBytes",
            "alreadyRead"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "[=]() {\n            return tryReadInternal(buffer, minBytes, maxBytes, alreadyRead);\n          }"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryReadInternal",
          "args": [
            "buffer",
            "minBytes",
            "maxBytes",
            "alreadyRead"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_IF_MAYBE",
          "args": [
            "atEnd",
            "observer.atEndHint()"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "KJ_IF_MAYBE",
          "container": "SocketAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "550-558",
          "snippet": "KJ_IF_MAYBE(portText, portPart) {\n      char* endptr;\n      port = strtoul(portText->cStr(), &endptr, 0);\n      if (portText->size() == 0 || *endptr != '\\0') {\n        // Not a number.  Maybe it's a service name.  Fall back to DNS.\n        return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n      }\n      KJ_REQUIRE(port < 65536, \"Port number too large.\");\n    }",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nSocketAddress {\n  KJ_IF_MAYBE(portText, portPart) {\n        char* endptr;\n        port = strtoul(portText->cStr(), &endptr, 0);\n        if (portText->size() == 0 || *endptr != '\\0') {\n          // Not a number.  Maybe it's a service name.  Fall back to DNS.\n          return lookupHost(lowLevel, kj::heapString(addrPart), kj::heapString(*portText), portHint);\n        }\n        KJ_REQUIRE(port < 65536, \"Port number too large.\");\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "observer.atEndHint",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "atEndHint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-unix.h",
          "lines": "191-191",
          "snippet": "inline Maybe<bool> atEndHint() { return atEnd; }",
          "includes": [
            "#include <signal.h>",
            "#include \"io.h\"",
            "#include \"vector.h\"",
            "#include \"time.h\"",
            "#include \"async.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include \"io.h\"\n#include \"vector.h\"\n#include \"time.h\"\n#include \"async.h\"\n\ninline Maybe<bool> atEndHint() { return atEnd; }"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "buffer"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "implicitCast<size_t>",
          "args": [
            "n"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "implicitCast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/common.h",
          "lines": "1203-1207",
          "snippet": "To implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}",
          "includes": [
            "#include <initializer_list>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <initializer_list>\n#include <stddef.h>\n\nTo implicitCast(From&& from) {\n  // `implicitCast<T>(value)` casts `value` to type `T` only if the conversion is implicit.  Useful\n  // for e.g. resolving ambiguous overloads without sacrificing type-safety.\n  return kj::fwd<From>(from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [
            "[=]() {\n        return tryReadInternal(buffer, minBytes, maxBytes, alreadyRead);\n      }"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryReadInternal",
          "args": [
            "buffer",
            "minBytes",
            "maxBytes",
            "alreadyRead"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesReadable",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::read",
          "args": [
            "fd",
            "buffer",
            "maxBytes"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "AsyncInputStream::read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "1340-1342",
          "snippet": "Promise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nPromise<void> AsyncInputStream::read(void* buffer, size_t bytes) {\n  return read(buffer, bytes, bytes).then([](size_t) {});\n}"
        }
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "pollResult = poll(&pollfd, 1, 0)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&pollfd",
            "1",
            "0"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pollfd",
            "0",
            "sizeof(pollfd)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::getpeername(fd, addr, &socklen)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::getpeername",
          "args": [
            "fd",
            "addr",
            "&socklen"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::getsockname(fd, addr, &socklen)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::getsockname",
          "args": [
            "fd",
            "addr",
            "&socklen"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::setsockopt(fd, level, option, value, length)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::setsockopt",
          "args": [
            "fd",
            "level",
            "option",
            "value",
            "length"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "::getsockopt(fd, level, option, value, &socklen)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::getsockopt",
          "args": [
            "fd",
            "level",
            "option",
            "value",
            "&socklen"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "shutdown(fd, SHUT_RD)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "fd",
            "SHUT_RD"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "shutdown(fd, SHUT_WR)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "fd",
            "SHUT_WR"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeInternal",
          "args": [
            "pieces[0]",
            "pieces.slice(1, pieces.size())"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeInternal",
          "args": [
            "nullptr",
            "nullptr"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [
            "[=]() {\n      return write(buffer, size);\n    }"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "buffer",
            "size"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "FdOutputStream::write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/io.c++",
          "lines": "271-281",
          "snippet": "void FdOutputStream::write(const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n\n  while (size > 0) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::write(fd, pos, size), fd);\n    KJ_ASSERT(n > 0, \"write() returned zero.\");\n    pos += n;\n    size -= n;\n  }\n}",
          "includes": [
            "#include <sys/uio.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <algorithm>",
            "#include \"miniposix.h\"",
            "#include \"debug.h\"",
            "#include \"io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/uio.h>\n#include <limits.h>\n#include <errno.h>\n#include <algorithm>\n#include \"miniposix.h\"\n#include \"debug.h\"\n#include \"io.h\"\n\nvoid FdOutputStream::write(const void* buffer, size_t size) {\n  const char* pos = reinterpret_cast<const char*>(buffer);\n\n  while (size > 0) {\n    miniposix::ssize_t n;\n    KJ_SYSCALL(n = miniposix::write(fd, pos, size), fd);\n    KJ_ASSERT(n > 0, \"write() returned zero.\");\n    pos += n;\n    size -= n;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "observer.whenBecomesWritable",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const byte*>",
          "args": [
            "buffer"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::write",
          "args": [
            "fd",
            "buffer",
            "size"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "TestRunner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/test.c++",
          "lines": "426-439",
          "snippet": "void write(Color color, StringPtr prefix, StringPtr message) {\n    StringPtr startColor, endColor;\n    if (useColor) {\n      switch (color) {\n        case RED:   startColor = \"\\033[0;1;31m\"; break;\n        case GREEN: startColor = \"\\033[0;1;32m\"; break;\n        case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n      }\n      endColor = \"\\033[0m\";\n    }\n\n    String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n    write(text);\n  }",
          "includes": [
            "#include <sys/mman.h>",
            "#include <string.h>",
            "#include <signal.h>",
            "#include <stdlib.h>",
            "#include \"miniposix.h\"",
            "#include \"io.h\"",
            "#include \"main.h\"",
            "#include \"test.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/mman.h>\n#include <string.h>\n#include <signal.h>\n#include <stdlib.h>\n#include \"miniposix.h\"\n#include \"io.h\"\n#include \"main.h\"\n#include \"test.h\"\n\nTestRunner {\n  void write(Color color, StringPtr prefix, StringPtr message) {\n      StringPtr startColor, endColor;\n      if (useColor) {\n        switch (color) {\n          case RED:   startColor = \"\\033[0;1;31m\"; break;\n          case GREEN: startColor = \"\\033[0;1;32m\"; break;\n          case BLUE:  startColor = \"\\033[0;1;34m\"; break;\n        }\n        endColor = \"\\033[0m\";\n      }\n  \n      String text = kj::str(startColor, prefix, endColor, ' ', message, '\\n');\n      write(text);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tryReadInternal",
          "args": [
            "buffer",
            "minBytes",
            "maxBytes",
            "0"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryReadInternal",
          "args": [
            "[=](size_t result) {\n      KJ_REQUIRE(result >= minBytes, \"Premature EOF\") {\n        // Pretend we read zeros from the input.\n        memset(reinterpret_cast<byte*>(buffer) + result, 0, minBytes - result);\n        return minBytes;\n      }\n      return result;\n    }"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "reinterpret_cast<byte*>(buffer) + result",
            "0",
            "minBytes - result"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<byte*>",
          "args": [
            "buffer"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_REQUIRE",
          "args": [
            "result >= minBytes",
            "\"Premature EOF\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tryReadInternal",
          "args": [
            "buffer",
            "minBytes",
            "maxBytes",
            "0"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\n#define IOV_MAX UIO_MAXIOV\n\nunion {\n    struct sockaddr generic;\n    struct sockaddr_in inet4;\n    struct sockaddr_in6 inet6;\n    struct sockaddr_un unixDomain;\n    struct sockaddr_storage storage;\n  } addr;\n\nclass AsyncStreamFd: public OwnedFileDescriptor, public AsyncIoStream {\npublic:\n  AsyncStreamFd(UnixEventPort& eventPort, int fd, uint flags)\n      : OwnedFileDescriptor(fd, flags),\n        observer(eventPort, fd, UnixEventPort::FdObserver::OBSERVE_READ_WRITE) {}\n  virtual ~AsyncStreamFd() noexcept(false) {}\n\n  Promise<size_t> read(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return tryReadInternal(buffer, minBytes, maxBytes, 0).then([=](size_t result) {\n      KJ_REQUIRE(result >= minBytes, \"Premature EOF\") {\n        // Pretend we read zeros from the input.\n        memset(reinterpret_cast<byte*>(buffer) + result, 0, minBytes - result);\n        return minBytes;\n      }\n      return result;\n    });\n  }\n\n  Promise<size_t> tryRead(void* buffer, size_t minBytes, size_t maxBytes) override {\n    return tryReadInternal(buffer, minBytes, maxBytes, 0);\n  }\n\n  Promise<void> write(const void* buffer, size_t size) override {\n    ssize_t writeResult;\n    KJ_NONBLOCKING_SYSCALL(writeResult = ::write(fd, buffer, size)) {\n      // Error.\n\n      // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n      // a bug that exists in both Clang and GCC:\n      //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n      //   http://llvm.org/bugs/show_bug.cgi?id=12286\n      goto error;\n    }\n    if (false) {\n    error:\n      return kj::READY_NOW;\n    }\n\n    // A negative result means EAGAIN, which we can treat the same as having written zero bytes.\n    size_t n = writeResult < 0 ? 0 : writeResult;\n\n    if (n == size) {\n      return READY_NOW;\n    }\n\n    // Fewer than `size` bytes were written, therefore we must be out of buffer space. Wait until\n    // the fd becomes writable again.\n    buffer = reinterpret_cast<const byte*>(buffer) + n;\n    size -= n;\n\n    return observer.whenBecomesWritable().then([=]() {\n      return write(buffer, size);\n    });\n  }\n\n  Promise<void> write(ArrayPtr<const ArrayPtr<const byte>> pieces) override {\n    if (pieces.size() == 0) {\n      return writeInternal(nullptr, nullptr);\n    } else {\n      return writeInternal(pieces[0], pieces.slice(1, pieces.size()));\n    }\n  }\n\n  void shutdownWrite() override {\n    // There's no legitimate way to get an AsyncStreamFd that isn't a socket through the\n    // UnixAsyncIoProvider interface.\n    KJ_SYSCALL(shutdown(fd, SHUT_WR));\n  }\n\n  void abortRead() override {\n    // There's no legitimate way to get an AsyncStreamFd that isn't a socket through the\n    // UnixAsyncIoProvider interface.\n    KJ_SYSCALL(shutdown(fd, SHUT_RD));\n  }\n\n  void getsockopt(int level, int option, void* value, uint* length) override {\n    socklen_t socklen = *length;\n    KJ_SYSCALL(::getsockopt(fd, level, option, value, &socklen));\n    *length = socklen;\n  }\n\n  void setsockopt(int level, int option, const void* value, uint length) override {\n    KJ_SYSCALL(::setsockopt(fd, level, option, value, length));\n  }\n\n  void getsockname(struct sockaddr* addr, uint* length) override {\n    socklen_t socklen = *length;\n    KJ_SYSCALL(::getsockname(fd, addr, &socklen));\n    *length = socklen;\n  }\n\n  void getpeername(struct sockaddr* addr, uint* length) override {\n    socklen_t socklen = *length;\n    KJ_SYSCALL(::getpeername(fd, addr, &socklen));\n    *length = socklen;\n  }\n\n  Promise<void> waitConnected() {\n    // Wait until initial connection has completed. This actually just waits until it is writable.\n\n    // Can't just go directly to writeObserver.whenBecomesWritable() because of edge triggering. We\n    // need to explicitly check if the socket is already connected.\n\n    struct pollfd pollfd;\n    memset(&pollfd, 0, sizeof(pollfd));\n    pollfd.fd = fd;\n    pollfd.events = POLLOUT;\n\n    int pollResult;\n    KJ_SYSCALL(pollResult = poll(&pollfd, 1, 0));\n\n    if (pollResult == 0) {\n      // Not ready yet. We can safely use the edge-triggered observer.\n      return observer.whenBecomesWritable();\n    } else {\n      // Ready now.\n      return kj::READY_NOW;\n    }\n  }\n\nprivate:\n  UnixEventPort::FdObserver observer;\n\n  Promise<size_t> tryReadInternal(void* buffer, size_t minBytes, size_t maxBytes,\n                                  size_t alreadyRead) {\n    // `alreadyRead` is the number of bytes we have already received via previous reads -- minBytes,\n    // maxBytes, and buffer have already been adjusted to account for them, but this count must\n    // be included in the final return value.\n\n    ssize_t n;\n    KJ_NONBLOCKING_SYSCALL(n = ::read(fd, buffer, maxBytes)) {\n      // Error.\n\n      // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n      // a bug that exists in both Clang and GCC:\n      //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n      //   http://llvm.org/bugs/show_bug.cgi?id=12286\n      goto error;\n    }\n    if (false) {\n    error:\n      return alreadyRead;\n    }\n\n    if (n < 0) {\n      // Read would block.\n      return observer.whenBecomesReadable().then([=]() {\n        return tryReadInternal(buffer, minBytes, maxBytes, alreadyRead);\n      });\n    } else if (n == 0) {\n      // EOF -OR- maxBytes == 0.\n      return alreadyRead;\n    } else if (implicitCast<size_t>(n) >= minBytes) {\n      // We read enough to stop here.\n      return alreadyRead + n;\n    } else {\n      // The kernel returned fewer bytes than we asked for (and fewer than we need).\n\n      buffer = reinterpret_cast<byte*>(buffer) + n;\n      minBytes -= n;\n      maxBytes -= n;\n      alreadyRead += n;\n\n      KJ_IF_MAYBE(atEnd, observer.atEndHint()) {\n        if (*atEnd) {\n          // We've already received an indication that the next read() will return EOF, so there's\n          // nothing to wait for.\n          return alreadyRead;\n        } else {\n          // As of the last time the event queue was checked, the kernel reported that we were\n          // *not* at the end of the stream. It's unlikely that this has changed in the short time\n          // it took to handle the event, therefore calling read() now will almost certainly fail\n          // with EAGAIN. Moreover, since EOF had not been received as of the last check, we know\n          // that even if it was received since then, whenBecomesReadable() will catch that. So,\n          // let's go ahead and skip calling read() here and instead go straight to waiting for\n          // more input.\n          return observer.whenBecomesReadable().then([=]() {\n            return tryReadInternal(buffer, minBytes, maxBytes, alreadyRead);\n          });\n        }\n      } else {\n        // The kernel has not indicated one way or the other whether we are likely to be at EOF.\n        // In this case we *must* keep calling read() until we either get a return of zero or\n        // EAGAIN.\n        return tryReadInternal(buffer, minBytes, maxBytes, alreadyRead);\n      }\n    }\n  }\n\n  Promise<void> writeInternal(ArrayPtr<const byte> firstPiece,\n                              ArrayPtr<const ArrayPtr<const byte>> morePieces) {\n    // If there are more than IOV_MAX pieces, we'll only write the first IOV_MAX for now, and\n    // then we'll loop later.\n    KJ_STACK_ARRAY(struct iovec, iov, kj::min(1 + morePieces.size(), IOV_MAX), 16, 128);\n    size_t iovTotal = 0;\n\n    // writev() interface is not const-correct.  :(\n    iov[0].iov_base = const_cast<byte*>(firstPiece.begin());\n    iov[0].iov_len = firstPiece.size();\n    iovTotal += iov[0].iov_len;\n    for (uint i = 1; i < iov.size(); i++) {\n      iov[i].iov_base = const_cast<byte*>(morePieces[i - 1].begin());\n      iov[i].iov_len = morePieces[i - 1].size();\n      iovTotal += iov[i].iov_len;\n    }\n\n    ssize_t writeResult;\n    KJ_NONBLOCKING_SYSCALL(writeResult = ::writev(fd, iov.begin(), iov.size())) {\n      // Error.\n\n      // We can't \"return kj::READY_NOW;\" inside this block because it causes a memory leak due to\n      // a bug that exists in both Clang and GCC:\n      //   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=33799\n      //   http://llvm.org/bugs/show_bug.cgi?id=12286\n      goto error;\n    }\n    if (false) {\n    error:\n      return kj::READY_NOW;\n    }\n\n    // A negative result means EAGAIN, which we can treat the same as having written zero bytes.\n    size_t n = writeResult < 0 ? 0 : writeResult;\n\n    // Discard all data that was written, then issue a new write for what's left (if any).\n    for (;;) {\n      if (n < firstPiece.size()) {\n        // Only part of the first piece was consumed.  Wait for buffer space and then write again.\n        firstPiece = firstPiece.slice(n, firstPiece.size());\n        iovTotal -= n;\n\n        if (iovTotal == 0) {\n          // Oops, what actually happened is that we hit the IOV_MAX limit. Don't wait.\n          return writeInternal(firstPiece, morePieces);\n        }\n\n        return observer.whenBecomesWritable().then([=]() {\n          return writeInternal(firstPiece, morePieces);\n        });\n      } else if (morePieces.size() == 0) {\n        // First piece was fully-consumed and there are no more pieces, so we're done.\n        KJ_DASSERT(n == firstPiece.size(), n);\n        return READY_NOW;\n      } else {\n        // First piece was fully consumed, so move on to the next piece.\n        n -= firstPiece.size();\n        iovTotal -= firstPiece.size();\n        firstPiece = morePieces[0];\n        morePieces = morePieces.slice(1, morePieces.size());\n      }\n    }\n  }"
  },
  {
    "function_name": "OwnedFileDescriptor",
    "container": "OwnedFileDescriptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "78-93",
    "snippet": "OwnedFileDescriptor(int fd, uint flags): fd(fd), flags(flags) {\n    if (flags & LowLevelAsyncIoProvider::ALREADY_NONBLOCK) {\n      KJ_DREQUIRE(fcntl(fd, F_GETFL) & O_NONBLOCK, \"You claimed you set NONBLOCK, but you didn't.\");\n    } else {\n      setNonblocking(fd);\n    }\n\n    if (flags & LowLevelAsyncIoProvider::TAKE_OWNERSHIP) {\n      if (flags & LowLevelAsyncIoProvider::ALREADY_CLOEXEC) {\n        KJ_DREQUIRE(fcntl(fd, F_GETFD) & FD_CLOEXEC,\n                    \"You claimed you set CLOEXEC, but you didn't.\");\n      } else {\n        setCloseOnExec(fd);\n      }\n    }\n  }",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setCloseOnExec",
          "args": [
            "fd"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "setCloseOnExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "60-66",
          "snippet": "void setCloseOnExec(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFD));\n  if ((flags & FD_CLOEXEC) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFD, flags | FD_CLOEXEC));\n  }\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid setCloseOnExec(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFD));\n  if ((flags & FD_CLOEXEC) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFD, flags | FD_CLOEXEC));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "fcntl(fd, F_GETFD) & FD_CLOEXEC",
            "\"You claimed you set CLOEXEC, but you didn't.\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFD"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setNonblocking",
          "args": [
            "fd"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "setNonblocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
          "lines": "52-58",
          "snippet": "void setNonblocking(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFL));\n  if ((flags & O_NONBLOCK) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n  }\n}",
          "includes": [
            "#include <limits.h>",
            "#include <poll.h>",
            "#include <set>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <stdlib.h>",
            "#include <stddef.h>",
            "#include <netinet/tcp.h>",
            "#include <netinet/in.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <sys/uio.h>",
            "#include <unistd.h>",
            "#include \"io.h\"",
            "#include \"thread.h\"",
            "#include \"debug.h\"",
            "#include \"async-unix.h\"",
            "#include \"async-io.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid setNonblocking(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFL));\n  if ((flags & O_NONBLOCK) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KJ_DREQUIRE",
          "args": [
            "fcntl(fd, F_GETFL) & O_NONBLOCK",
            "\"You claimed you set NONBLOCK, but you didn't.\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFL"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nOwnedFileDescriptor {\n  OwnedFileDescriptor(int fd, uint flags): fd(fd), flags(flags) {\n      if (flags & LowLevelAsyncIoProvider::ALREADY_NONBLOCK) {\n        KJ_DREQUIRE(fcntl(fd, F_GETFL) & O_NONBLOCK, \"You claimed you set NONBLOCK, but you didn't.\");\n      } else {\n        setNonblocking(fd);\n      }\n  \n      if (flags & LowLevelAsyncIoProvider::TAKE_OWNERSHIP) {\n        if (flags & LowLevelAsyncIoProvider::ALREADY_CLOEXEC) {\n          KJ_DREQUIRE(fcntl(fd, F_GETFD) & FD_CLOEXEC,\n                      \"You claimed you set CLOEXEC, but you didn't.\");\n        } else {\n          setCloseOnExec(fd);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "setCloseOnExec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "60-66",
    "snippet": "void setCloseOnExec(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFD));\n  if ((flags & FD_CLOEXEC) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFD, flags | FD_CLOEXEC));\n  }\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fcntl(fd, F_SETFD, flags | FD_CLOEXEC)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFD",
            "flags | FD_CLOEXEC"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "flags = fcntl(fd, F_GETFD)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFD"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid setCloseOnExec(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFD));\n  if ((flags & FD_CLOEXEC) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFD, flags | FD_CLOEXEC));\n  }\n}"
  },
  {
    "function_name": "setNonblocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2313/repo/c++/src/kj/async-io.c++",
    "lines": "52-58",
    "snippet": "void setNonblocking(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFL));\n  if ((flags & O_NONBLOCK) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n  }\n}",
    "includes": [
      "#include <limits.h>",
      "#include <poll.h>",
      "#include <set>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <stdlib.h>",
      "#include <stddef.h>",
      "#include <netinet/tcp.h>",
      "#include <netinet/in.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <sys/uio.h>",
      "#include <unistd.h>",
      "#include \"io.h\"",
      "#include \"thread.h\"",
      "#include \"debug.h\"",
      "#include \"async-unix.h\"",
      "#include \"async-io.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "fcntl(fd, F_SETFL, flags | O_NONBLOCK)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFL",
            "flags | O_NONBLOCK"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KJ_SYSCALL",
          "args": [
            "flags = fcntl(fd, F_GETFL)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_GETFL"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include <poll.h>\n#include <set>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <sys/uio.h>\n#include <unistd.h>\n#include \"io.h\"\n#include \"thread.h\"\n#include \"debug.h\"\n#include \"async-unix.h\"\n#include \"async-io.h\"\n\nvoid setNonblocking(int fd) {\n  int flags;\n  KJ_SYSCALL(flags = fcntl(fd, F_GETFL));\n  if ((flags & O_NONBLOCK) == 0) {\n    KJ_SYSCALL(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n  }\n}"
  }
]