[
  {
    "function_name": "ValidatePBKDF",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "550-591",
    "snippet": "bool ValidatePBKDF()\n{\n\tbool pass = true;\n\n\t{\n\t// from OpenSSL PKCS#12 Program FAQ v1.77, at http://www.drh-consultancy.demon.co.uk/test.txt\n\tPBKDF_TestTuple testSet[] = \n\t{\n\t\t{1, 1, \"0073006D006500670000\", \"0A58CF64530D823F\", \"8AAAE6297B6CB04642AB5B077851284EB7128F1A2A7FBCA3\"},\n\t\t{2, 1, \"0073006D006500670000\", \"0A58CF64530D823F\", \"79993DFE048D3B76\"},\n\t\t{1, 1, \"0073006D006500670000\", \"642B99AB44FB4B1F\", \"F3A95FEC48D7711E985CFE67908C5AB79FA3D7C5CAA5D966\"},\n\t\t{2, 1, \"0073006D006500670000\", \"642B99AB44FB4B1F\", \"C0A38D64A79BEA1D\"},\n\t\t{3, 1, \"0073006D006500670000\", \"3D83C0E4546AC140\", \"8D967D88F6CAA9D714800AB3D48051D63F73A312\"},\n\t\t{1, 1000, \"007100750065006500670000\", \"05DEC959ACFF72F7\", \"ED2034E36328830FF09DF1E1A07DD357185DAC0D4F9EB3D4\"},\n\t\t{2, 1000, \"007100750065006500670000\", \"05DEC959ACFF72F7\", \"11DEDAD7758D4860\"},\n\t\t{1, 1000, \"007100750065006500670000\", \"1682C0FC5B3F7EC5\", \"483DD6E919D7DE2E8E648BA8F862F3FBFBDC2BCB2C02957F\"},\n\t\t{2, 1000, \"007100750065006500670000\", \"1682C0FC5B3F7EC5\", \"9D461D1B00355C50\"},\n\t\t{3, 1000, \"007100750065006500670000\", \"263216FCC2FAB31C\", \"5EC4C7A80DF652294C3925B6489A7AB857C83476\"}\n\t};\n\n\tPKCS12_PBKDF<SHA1> pbkdf;\n\n\tcout << \"\\nPKCS #12 PBKDF validation suite running...\\n\\n\";\n\tpass = TestPBKDF(pbkdf, testSet, sizeof(testSet)/sizeof(testSet[0])) && pass;\n\t}\n\n\t{\n\t// from draft-ietf-smime-password-03.txt, at http://www.imc.org/draft-ietf-smime-password\n\tPBKDF_TestTuple testSet[] = \n\t{\n\t\t{0, 5, \"70617373776f7264\", \"1234567878563412\", \"D1DAA78615F287E6\"},\n\t\t{0, 500, \"416C6C206E2D656E746974696573206D75737420636F6D6D756E69636174652077697468206F74686572206E2d656E74697469657320766961206E2D3120656E746974656568656568656573\", \"1234567878563412\",\"6A8970BF68C92CAEA84A8DF28510858607126380CC47AB2D\"}\n\t};\n\n\tPKCS5_PBKDF2_HMAC<SHA1> pbkdf;\n\n\tcout << \"\\nPKCS #5 PBKDF2 validation suite running...\\n\\n\";\n\tpass = TestPBKDF(pbkdf, testSet, sizeof(testSet)/sizeof(testSet[0])) && pass;\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TestPBKDF",
          "args": [
            "pbkdf",
            "testSet",
            "sizeof(testSet)/sizeof(testSet[0])"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "TestPBKDF",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "520-548",
          "snippet": "bool TestPBKDF(PasswordBasedKeyDerivationFunction &pbkdf, const PBKDF_TestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass = true;\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tconst PBKDF_TestTuple &tuple = testSet[i];\n\n\t\tstring password, salt, derivedKey;\n\t\tStringSource(tuple.hexPassword, true, new HexDecoder(new StringSink(password)));\n\t\tStringSource(tuple.hexSalt, true, new HexDecoder(new StringSink(salt)));\n\t\tStringSource(tuple.hexDerivedKey, true, new HexDecoder(new StringSink(derivedKey)));\n\n\t\tSecByteBlock derived(derivedKey.size());\n\t\tpbkdf.DeriveKey(derived, derived.size(), tuple.purpose, (byte *)password.data(), password.size(), (byte *)salt.data(), salt.size(), tuple.iterations);\n\t\tbool fail = memcmp(derived, derivedKey.data(), derived.size()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tHexEncoder enc(new FileSink(cout));\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tenc.Put(tuple.purpose);\n\t\tcout << \" \" << tuple.iterations;\n\t\tcout << \" \" << tuple.hexPassword << \" \" << tuple.hexSalt << \" \";\n\t\tenc.Put(derived, derived.size());\n\t\tcout << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool TestPBKDF(PasswordBasedKeyDerivationFunction &pbkdf, const PBKDF_TestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass = true;\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tconst PBKDF_TestTuple &tuple = testSet[i];\n\n\t\tstring password, salt, derivedKey;\n\t\tStringSource(tuple.hexPassword, true, new HexDecoder(new StringSink(password)));\n\t\tStringSource(tuple.hexSalt, true, new HexDecoder(new StringSink(salt)));\n\t\tStringSource(tuple.hexDerivedKey, true, new HexDecoder(new StringSink(derivedKey)));\n\n\t\tSecByteBlock derived(derivedKey.size());\n\t\tpbkdf.DeriveKey(derived, derived.size(), tuple.purpose, (byte *)password.data(), password.size(), (byte *)salt.data(), salt.size(), tuple.iterations);\n\t\tbool fail = memcmp(derived, derivedKey.data(), derived.size()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tHexEncoder enc(new FileSink(cout));\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tenc.Put(tuple.purpose);\n\t\tcout << \" \" << tuple.iterations;\n\t\tcout << \" \" << tuple.hexPassword << \" \" << tuple.hexSalt << \" \";\n\t\tenc.Put(derived, derived.size());\n\t\tcout << endl;\n\t}\n\n\treturn pass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidatePBKDF()\n{\n\tbool pass = true;\n\n\t{\n\t// from OpenSSL PKCS#12 Program FAQ v1.77, at http://www.drh-consultancy.demon.co.uk/test.txt\n\tPBKDF_TestTuple testSet[] = \n\t{\n\t\t{1, 1, \"0073006D006500670000\", \"0A58CF64530D823F\", \"8AAAE6297B6CB04642AB5B077851284EB7128F1A2A7FBCA3\"},\n\t\t{2, 1, \"0073006D006500670000\", \"0A58CF64530D823F\", \"79993DFE048D3B76\"},\n\t\t{1, 1, \"0073006D006500670000\", \"642B99AB44FB4B1F\", \"F3A95FEC48D7711E985CFE67908C5AB79FA3D7C5CAA5D966\"},\n\t\t{2, 1, \"0073006D006500670000\", \"642B99AB44FB4B1F\", \"C0A38D64A79BEA1D\"},\n\t\t{3, 1, \"0073006D006500670000\", \"3D83C0E4546AC140\", \"8D967D88F6CAA9D714800AB3D48051D63F73A312\"},\n\t\t{1, 1000, \"007100750065006500670000\", \"05DEC959ACFF72F7\", \"ED2034E36328830FF09DF1E1A07DD357185DAC0D4F9EB3D4\"},\n\t\t{2, 1000, \"007100750065006500670000\", \"05DEC959ACFF72F7\", \"11DEDAD7758D4860\"},\n\t\t{1, 1000, \"007100750065006500670000\", \"1682C0FC5B3F7EC5\", \"483DD6E919D7DE2E8E648BA8F862F3FBFBDC2BCB2C02957F\"},\n\t\t{2, 1000, \"007100750065006500670000\", \"1682C0FC5B3F7EC5\", \"9D461D1B00355C50\"},\n\t\t{3, 1000, \"007100750065006500670000\", \"263216FCC2FAB31C\", \"5EC4C7A80DF652294C3925B6489A7AB857C83476\"}\n\t};\n\n\tPKCS12_PBKDF<SHA1> pbkdf;\n\n\tcout << \"\\nPKCS #12 PBKDF validation suite running...\\n\\n\";\n\tpass = TestPBKDF(pbkdf, testSet, sizeof(testSet)/sizeof(testSet[0])) && pass;\n\t}\n\n\t{\n\t// from draft-ietf-smime-password-03.txt, at http://www.imc.org/draft-ietf-smime-password\n\tPBKDF_TestTuple testSet[] = \n\t{\n\t\t{0, 5, \"70617373776f7264\", \"1234567878563412\", \"D1DAA78615F287E6\"},\n\t\t{0, 500, \"416C6C206E2D656E746974696573206D75737420636F6D6D756E69636174652077697468206F74686572206E2d656E74697469657320766961206E2D3120656E746974656568656568656573\", \"1234567878563412\",\"6A8970BF68C92CAEA84A8DF28510858607126380CC47AB2D\"}\n\t};\n\n\tPKCS5_PBKDF2_HMAC<SHA1> pbkdf;\n\n\tcout << \"\\nPKCS #5 PBKDF2 validation suite running...\\n\\n\";\n\tpass = TestPBKDF(pbkdf, testSet, sizeof(testSet)/sizeof(testSet[0])) && pass;\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "TestPBKDF",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "520-548",
    "snippet": "bool TestPBKDF(PasswordBasedKeyDerivationFunction &pbkdf, const PBKDF_TestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass = true;\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tconst PBKDF_TestTuple &tuple = testSet[i];\n\n\t\tstring password, salt, derivedKey;\n\t\tStringSource(tuple.hexPassword, true, new HexDecoder(new StringSink(password)));\n\t\tStringSource(tuple.hexSalt, true, new HexDecoder(new StringSink(salt)));\n\t\tStringSource(tuple.hexDerivedKey, true, new HexDecoder(new StringSink(derivedKey)));\n\n\t\tSecByteBlock derived(derivedKey.size());\n\t\tpbkdf.DeriveKey(derived, derived.size(), tuple.purpose, (byte *)password.data(), password.size(), (byte *)salt.data(), salt.size(), tuple.iterations);\n\t\tbool fail = memcmp(derived, derivedKey.data(), derived.size()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tHexEncoder enc(new FileSink(cout));\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tenc.Put(tuple.purpose);\n\t\tcout << \" \" << tuple.iterations;\n\t\tcout << \" \" << tuple.hexPassword << \" \" << tuple.hexSalt << \" \";\n\t\tenc.Put(derived, derived.size());\n\t\tcout << endl;\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enc.Put",
          "args": [
            "derived",
            "derived.size()"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "derived.size",
          "args": [],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "enc.Put",
          "args": [
            "tuple.purpose"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "derived",
            "derivedKey.data()",
            "derived.size()"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "derivedKey.data",
          "args": [],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "300-300",
          "snippet": "typename A::const_pointer data() const {return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pbkdf.DeriveKey",
          "args": [
            "derived",
            "derived.size()",
            "tuple.purpose",
            "(byte *)password.data()",
            "password.size()",
            "(byte *)salt.data()",
            "salt.size()",
            "tuple.iterations"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "tuple.hexDerivedKey",
            "true",
            "new HexDecoder(new StringSink(derivedKey))"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "tuple.hexSalt",
            "true",
            "new HexDecoder(new StringSink(salt))"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "tuple.hexPassword",
            "true",
            "new HexDecoder(new StringSink(password))"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool TestPBKDF(PasswordBasedKeyDerivationFunction &pbkdf, const PBKDF_TestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass = true;\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tconst PBKDF_TestTuple &tuple = testSet[i];\n\n\t\tstring password, salt, derivedKey;\n\t\tStringSource(tuple.hexPassword, true, new HexDecoder(new StringSink(password)));\n\t\tStringSource(tuple.hexSalt, true, new HexDecoder(new StringSink(salt)));\n\t\tStringSource(tuple.hexDerivedKey, true, new HexDecoder(new StringSink(derivedKey)));\n\n\t\tSecByteBlock derived(derivedKey.size());\n\t\tpbkdf.DeriveKey(derived, derived.size(), tuple.purpose, (byte *)password.data(), password.size(), (byte *)salt.data(), salt.size(), tuple.iterations);\n\t\tbool fail = memcmp(derived, derivedKey.data(), derived.size()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tHexEncoder enc(new FileSink(cout));\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tenc.Put(tuple.purpose);\n\t\tcout << \" \" << tuple.iterations;\n\t\tcout << \" \" << tuple.hexPassword << \" \" << tuple.hexSalt << \" \";\n\t\tenc.Put(derived, derived.size());\n\t\tcout << endl;\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateTTMAC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "465-511",
    "snippet": "bool ValidateTTMAC()\n{\n\tconst byte key[TTMAC::KEYLENGTH]={\n\t\t0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,\n\t\t0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x01,0x23,0x45,0x67};\n\n\tconst char *TestVals[8]={\n\t\t\"\",\n\t\t\"a\",\n\t\t\"abc\",\n\t\t\"message digest\",\n\t\t\"abcdefghijklmnopqrstuvwxyz\",\n\t\t\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\",\n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n\t\t\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"};\n\n\tconst byte output[8][TTMAC::DIGESTSIZE]={\n\t\t{0x2d,0xec,0x8e,0xd4,0xa0,0xfd,0x71,0x2e,0xd9,0xfb,0xf2,0xab,0x46,0x6e,0xc2,0xdf,0x21,0x21,0x5e,0x4a},\n\t\t{0x58,0x93,0xe3,0xe6,0xe3,0x06,0x70,0x4d,0xd7,0x7a,0xd6,0xe6,0xed,0x43,0x2c,0xde,0x32,0x1a,0x77,0x56},\n\t\t{0x70,0xbf,0xd1,0x02,0x97,0x97,0xa5,0xc1,0x6d,0xa5,0xb5,0x57,0xa1,0xf0,0xb2,0x77,0x9b,0x78,0x49,0x7e},\n\t\t{0x82,0x89,0xf4,0xf1,0x9f,0xfe,0x4f,0x2a,0xf7,0x37,0xde,0x4b,0xd7,0x1c,0x82,0x9d,0x93,0xa9,0x72,0xfa},\n\t\t{0x21,0x86,0xca,0x09,0xc5,0x53,0x31,0x98,0xb7,0x37,0x1f,0x24,0x52,0x73,0x50,0x4c,0xa9,0x2b,0xae,0x60},\n\t\t{0x8a,0x7b,0xf7,0x7a,0xef,0x62,0xa2,0x57,0x84,0x97,0xa2,0x7c,0x0d,0x65,0x18,0xa4,0x29,0xe7,0xc1,0x4d},\n\t\t{0x54,0xba,0xc3,0x92,0xa8,0x86,0x80,0x6d,0x16,0x95,0x56,0xfc,0xbb,0x67,0x89,0xb5,0x4f,0xb3,0x64,0xfb},\n\t\t{0x0c,0xed,0x2c,0x9f,0x8f,0x0d,0x9d,0x03,0x98,0x1a,0xb5,0xc8,0x18,0x4b,0xac,0x43,0xdd,0x54,0xc4,0x84}};\n\n\tbyte digest[TTMAC::DIGESTSIZE];\n\tbool pass=true, fail;\n\n\tcout << \"\\nTwo-Track-MAC validation suite running...\\n\";\n\n\tTTMAC mac(key, sizeof(key));\n\tfor (size_t k=0; k<sizeof(TestVals)/sizeof(TestVals[0]); k++)\n\t{\n\t\tmac.Update((byte *)TestVals[k], strlen(TestVals[k]));\n\t\tmac.Final(digest);\n\t\tfail = memcmp(digest, output[k], TTMAC::DIGESTSIZE)\n\t\t\t|| !mac.VerifyDigest(output[k], (byte *)TestVals[k], strlen(TestVals[k]));\n\t\tpass = pass && !fail;\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (int j=0;j<TTMAC::DIGESTSIZE;j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << TestVals[k] << '\\\"' << endl;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.VerifyDigest",
          "args": [
            "output[k]",
            "(byte *)TestVals[k]",
            "strlen(TestVals[k])"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TestVals[k]"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "digest",
            "output[k]",
            "TTMAC::DIGESTSIZE"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.Final",
          "args": [
            "digest"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.Update",
          "args": [
            "(byte *)TestVals[k]",
            "strlen(TestVals[k])"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TestVals[k]"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateTTMAC()\n{\n\tconst byte key[TTMAC::KEYLENGTH]={\n\t\t0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,\n\t\t0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x01,0x23,0x45,0x67};\n\n\tconst char *TestVals[8]={\n\t\t\"\",\n\t\t\"a\",\n\t\t\"abc\",\n\t\t\"message digest\",\n\t\t\"abcdefghijklmnopqrstuvwxyz\",\n\t\t\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\",\n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n\t\t\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"};\n\n\tconst byte output[8][TTMAC::DIGESTSIZE]={\n\t\t{0x2d,0xec,0x8e,0xd4,0xa0,0xfd,0x71,0x2e,0xd9,0xfb,0xf2,0xab,0x46,0x6e,0xc2,0xdf,0x21,0x21,0x5e,0x4a},\n\t\t{0x58,0x93,0xe3,0xe6,0xe3,0x06,0x70,0x4d,0xd7,0x7a,0xd6,0xe6,0xed,0x43,0x2c,0xde,0x32,0x1a,0x77,0x56},\n\t\t{0x70,0xbf,0xd1,0x02,0x97,0x97,0xa5,0xc1,0x6d,0xa5,0xb5,0x57,0xa1,0xf0,0xb2,0x77,0x9b,0x78,0x49,0x7e},\n\t\t{0x82,0x89,0xf4,0xf1,0x9f,0xfe,0x4f,0x2a,0xf7,0x37,0xde,0x4b,0xd7,0x1c,0x82,0x9d,0x93,0xa9,0x72,0xfa},\n\t\t{0x21,0x86,0xca,0x09,0xc5,0x53,0x31,0x98,0xb7,0x37,0x1f,0x24,0x52,0x73,0x50,0x4c,0xa9,0x2b,0xae,0x60},\n\t\t{0x8a,0x7b,0xf7,0x7a,0xef,0x62,0xa2,0x57,0x84,0x97,0xa2,0x7c,0x0d,0x65,0x18,0xa4,0x29,0xe7,0xc1,0x4d},\n\t\t{0x54,0xba,0xc3,0x92,0xa8,0x86,0x80,0x6d,0x16,0x95,0x56,0xfc,0xbb,0x67,0x89,0xb5,0x4f,0xb3,0x64,0xfb},\n\t\t{0x0c,0xed,0x2c,0x9f,0x8f,0x0d,0x9d,0x03,0x98,0x1a,0xb5,0xc8,0x18,0x4b,0xac,0x43,0xdd,0x54,0xc4,0x84}};\n\n\tbyte digest[TTMAC::DIGESTSIZE];\n\tbool pass=true, fail;\n\n\tcout << \"\\nTwo-Track-MAC validation suite running...\\n\";\n\n\tTTMAC mac(key, sizeof(key));\n\tfor (size_t k=0; k<sizeof(TestVals)/sizeof(TestVals[0]); k++)\n\t{\n\t\tmac.Update((byte *)TestVals[k], strlen(TestVals[k]));\n\t\tmac.Final(digest);\n\t\tfail = memcmp(digest, output[k], TTMAC::DIGESTSIZE)\n\t\t\t|| !mac.VerifyDigest(output[k], (byte *)TestVals[k], strlen(TestVals[k]));\n\t\tpass = pass && !fail;\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (int j=0;j<TTMAC::DIGESTSIZE;j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << TestVals[k] << '\\\"' << endl;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "ValidateXMACC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "400-462",
    "snippet": "bool ValidateXMACC()\n{\n\ttypedef XMACC<MD5> XMACC_MD5;\n\n\tconst byte keys[2][XMACC_MD5::KEYLENGTH]={\n\t\t{0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb},\n\t\t{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98}};\n\n\tconst word32 counters[2]={0xccddeeff, 0x76543210};\n\n\tconst char *TestVals[7]={\n\t\t\"\",\n\t\t\"a\",\n\t\t\"abc\",\n\t\t\"message digest\",\n\t\t\"abcdefghijklmnopqrstuvwxyz\",\n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n\t\t\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"};\n\n\tconst byte output[2][7][XMACC_MD5::DIGESTSIZE]={\n\t\t{{0xcc,0xdd,0xef,0x00,0xfa,0x89,0x54,0x92,0x86,0x32,0xda,0x2a,0x3f,0x29,0xc5,0x52,0xa0,0x0d,0x05,0x13},\n\t\t{0xcc,0xdd,0xef,0x01,0xae,0xdb,0x8b,0x7b,0x69,0x71,0xc7,0x91,0x71,0x48,0x9d,0x18,0xe7,0xdf,0x9d,0x5a},\n\t\t{0xcc,0xdd,0xef,0x02,0x5e,0x01,0x2e,0x2e,0x4b,0xc3,0x83,0x62,0xc2,0xf4,0xe6,0x18,0x1c,0x44,0xaf,0xca},\n\t\t{0xcc,0xdd,0xef,0x03,0x3e,0xa9,0xf1,0xe0,0x97,0x91,0xf8,0xe2,0xbe,0xe0,0xdf,0xf3,0x41,0x03,0xb3,0x5a},\n\t\t{0xcc,0xdd,0xef,0x04,0x2e,0x6a,0x8d,0xb9,0x72,0xe3,0xce,0x9f,0xf4,0x28,0x45,0xe7,0xbc,0x80,0xa9,0xc7},\n\t\t{0xcc,0xdd,0xef,0x05,0x1a,0xd5,0x40,0x78,0xfb,0x16,0x37,0xfc,0x7a,0x1d,0xce,0xb4,0x77,0x10,0xb2,0xa0},\n\t\t{0xcc,0xdd,0xef,0x06,0x13,0x2f,0x11,0x47,0xd7,0x1b,0xb5,0x52,0x36,0x51,0x26,0xb0,0x96,0xd7,0x60,0x81}},\n\t\t{{0x76,0x54,0x32,0x11,0xe9,0xcb,0x74,0x32,0x07,0x93,0xfe,0x01,0xdd,0x27,0xdb,0xde,0x6b,0x77,0xa4,0x56},\n\t\t{0x76,0x54,0x32,0x12,0xcd,0x55,0x87,0x5c,0xc0,0x35,0x85,0x99,0x44,0x02,0xa5,0x0b,0x8c,0xe7,0x2c,0x68},\n\t\t{0x76,0x54,0x32,0x13,0xac,0xfd,0x87,0x50,0xc3,0x8f,0xcd,0x58,0xaa,0xa5,0x7e,0x7a,0x25,0x63,0x26,0xd1},\n\t\t{0x76,0x54,0x32,0x14,0xe3,0x30,0xf5,0xdd,0x27,0x2b,0x76,0x22,0x7f,0xaa,0x90,0x73,0x6a,0x48,0xdb,0x00},\n\t\t{0x76,0x54,0x32,0x15,0xfc,0x57,0x00,0x20,0x7c,0x9d,0xf6,0x30,0x6f,0xbd,0x46,0x3e,0xfb,0x8a,0x2c,0x60},\n\t\t{0x76,0x54,0x32,0x16,0xfb,0x0f,0xd3,0xdf,0x4c,0x4b,0xc3,0x05,0x9d,0x63,0x1e,0xba,0x25,0x2b,0xbe,0x35},\n\t\t{0x76,0x54,0x32,0x17,0xc6,0xfe,0xe6,0x5f,0xb1,0x35,0x8a,0xf5,0x32,0x7a,0x80,0xbd,0xb8,0x72,0xee,0xae}}};\n\n\tbyte digest[XMACC_MD5::DIGESTSIZE];\n\tbool pass=true, fail;\n\n\tcout << \"\\nXMACC/MD5 validation suite running...\\n\";\n\n\tfor (int k=0; k<2; k++)\n\t{\n\t\tXMACC_MD5 mac(keys[k], counters[k]);\n\t\tcout << \"\\nKEY: \";\n\t\tfor (int j=0;j<XMACC_MD5::KEYLENGTH;j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)keys[k][j];\n\t\tcout << \"    COUNTER: 0x\" << hex << counters[k] << endl << endl;\n\t\tfor (int i=0;i<7;i++)\n\t\t{\n\t\t\tmac.Update((byte *)TestVals[i], strlen(TestVals[i]));\n\t\t\tmac.Final(digest);\n\t\t\tfail = memcmp(digest, output[k][i], XMACC_MD5::DIGESTSIZE)\n\t\t\t\t || !mac.VerifyDigest(output[k][i], (byte *)TestVals[i], strlen(TestVals[i]));\n\t\t\tpass = pass && !fail;\n\t\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\t\tfor (int j=0;j<XMACC_MD5::DIGESTSIZE;j++)\n\t\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\t\tcout << \"   \\\"\" << TestVals[i] << '\\\"' << endl;\n\t\t}\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.VerifyDigest",
          "args": [
            "output[k][i]",
            "(byte *)TestVals[i]",
            "strlen(TestVals[i])"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TestVals[i]"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "digest",
            "output[k][i]",
            "XMACC_MD5::DIGESTSIZE"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.Final",
          "args": [
            "digest"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.Update",
          "args": [
            "(byte *)TestVals[i]",
            "strlen(TestVals[i])"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TestVals[i]"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateXMACC()\n{\n\ttypedef XMACC<MD5> XMACC_MD5;\n\n\tconst byte keys[2][XMACC_MD5::KEYLENGTH]={\n\t\t{0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb},\n\t\t{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98}};\n\n\tconst word32 counters[2]={0xccddeeff, 0x76543210};\n\n\tconst char *TestVals[7]={\n\t\t\"\",\n\t\t\"a\",\n\t\t\"abc\",\n\t\t\"message digest\",\n\t\t\"abcdefghijklmnopqrstuvwxyz\",\n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n\t\t\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"};\n\n\tconst byte output[2][7][XMACC_MD5::DIGESTSIZE]={\n\t\t{{0xcc,0xdd,0xef,0x00,0xfa,0x89,0x54,0x92,0x86,0x32,0xda,0x2a,0x3f,0x29,0xc5,0x52,0xa0,0x0d,0x05,0x13},\n\t\t{0xcc,0xdd,0xef,0x01,0xae,0xdb,0x8b,0x7b,0x69,0x71,0xc7,0x91,0x71,0x48,0x9d,0x18,0xe7,0xdf,0x9d,0x5a},\n\t\t{0xcc,0xdd,0xef,0x02,0x5e,0x01,0x2e,0x2e,0x4b,0xc3,0x83,0x62,0xc2,0xf4,0xe6,0x18,0x1c,0x44,0xaf,0xca},\n\t\t{0xcc,0xdd,0xef,0x03,0x3e,0xa9,0xf1,0xe0,0x97,0x91,0xf8,0xe2,0xbe,0xe0,0xdf,0xf3,0x41,0x03,0xb3,0x5a},\n\t\t{0xcc,0xdd,0xef,0x04,0x2e,0x6a,0x8d,0xb9,0x72,0xe3,0xce,0x9f,0xf4,0x28,0x45,0xe7,0xbc,0x80,0xa9,0xc7},\n\t\t{0xcc,0xdd,0xef,0x05,0x1a,0xd5,0x40,0x78,0xfb,0x16,0x37,0xfc,0x7a,0x1d,0xce,0xb4,0x77,0x10,0xb2,0xa0},\n\t\t{0xcc,0xdd,0xef,0x06,0x13,0x2f,0x11,0x47,0xd7,0x1b,0xb5,0x52,0x36,0x51,0x26,0xb0,0x96,0xd7,0x60,0x81}},\n\t\t{{0x76,0x54,0x32,0x11,0xe9,0xcb,0x74,0x32,0x07,0x93,0xfe,0x01,0xdd,0x27,0xdb,0xde,0x6b,0x77,0xa4,0x56},\n\t\t{0x76,0x54,0x32,0x12,0xcd,0x55,0x87,0x5c,0xc0,0x35,0x85,0x99,0x44,0x02,0xa5,0x0b,0x8c,0xe7,0x2c,0x68},\n\t\t{0x76,0x54,0x32,0x13,0xac,0xfd,0x87,0x50,0xc3,0x8f,0xcd,0x58,0xaa,0xa5,0x7e,0x7a,0x25,0x63,0x26,0xd1},\n\t\t{0x76,0x54,0x32,0x14,0xe3,0x30,0xf5,0xdd,0x27,0x2b,0x76,0x22,0x7f,0xaa,0x90,0x73,0x6a,0x48,0xdb,0x00},\n\t\t{0x76,0x54,0x32,0x15,0xfc,0x57,0x00,0x20,0x7c,0x9d,0xf6,0x30,0x6f,0xbd,0x46,0x3e,0xfb,0x8a,0x2c,0x60},\n\t\t{0x76,0x54,0x32,0x16,0xfb,0x0f,0xd3,0xdf,0x4c,0x4b,0xc3,0x05,0x9d,0x63,0x1e,0xba,0x25,0x2b,0xbe,0x35},\n\t\t{0x76,0x54,0x32,0x17,0xc6,0xfe,0xe6,0x5f,0xb1,0x35,0x8a,0xf5,0x32,0x7a,0x80,0xbd,0xb8,0x72,0xee,0xae}}};\n\n\tbyte digest[XMACC_MD5::DIGESTSIZE];\n\tbool pass=true, fail;\n\n\tcout << \"\\nXMACC/MD5 validation suite running...\\n\";\n\n\tfor (int k=0; k<2; k++)\n\t{\n\t\tXMACC_MD5 mac(keys[k], counters[k]);\n\t\tcout << \"\\nKEY: \";\n\t\tfor (int j=0;j<XMACC_MD5::KEYLENGTH;j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)keys[k][j];\n\t\tcout << \"    COUNTER: 0x\" << hex << counters[k] << endl << endl;\n\t\tfor (int i=0;i<7;i++)\n\t\t{\n\t\t\tmac.Update((byte *)TestVals[i], strlen(TestVals[i]));\n\t\t\tmac.Final(digest);\n\t\t\tfail = memcmp(digest, output[k][i], XMACC_MD5::DIGESTSIZE)\n\t\t\t\t || !mac.VerifyDigest(output[k][i], (byte *)TestVals[i], strlen(TestVals[i]));\n\t\t\tpass = pass && !fail;\n\t\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\t\tfor (int j=0;j<XMACC_MD5::DIGESTSIZE;j++)\n\t\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\t\tcout << \"   \\\"\" << TestVals[i] << '\\\"' << endl;\n\t\t}\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateHMAC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "394-397",
    "snippet": "bool ValidateHMAC()\n{\n\treturn RunTestDataFile(\"TestVectors/hmac.txt\");\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RunTestDataFile",
          "args": [
            "\"TestVectors/hmac.txt\""
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateHMAC()\n{\n\treturn RunTestDataFile(\"TestVectors/hmac.txt\");\n}"
  },
  {
    "function_name": "ValidateMD5MAC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "333-391",
    "snippet": "bool ValidateMD5MAC()\n{\n\tconst byte keys[2][MD5MAC::KEYLENGTH]={\n\t\t{0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff},\n\t\t{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}};\n\n\tconst char *TestVals[7]={\n\t\t\"\",\n\t\t\"a\",\n\t\t\"abc\",\n\t\t\"message digest\",\n\t\t\"abcdefghijklmnopqrstuvwxyz\",\n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n\t\t\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"};\n\n\tconst byte output[2][7][MD5MAC::DIGESTSIZE]={\n\t\t{{0x1f,0x1e,0xf2,0x37,0x5c,0xc0,0xe0,0x84,0x4f,0x98,0xe7,0xe8,0x11,0xa3,0x4d,0xa8},\n\t\t{0x7a,0x76,0xee,0x64,0xca,0x71,0xef,0x23,0x7e,0x26,0x29,0xed,0x94,0x52,0x73,0x65},\n\t\t{0xe8,0x01,0x3c,0x11,0xf7,0x20,0x9d,0x13,0x28,0xc0,0xca,0xa0,0x4f,0xd0,0x12,0xa6},\n\t\t{0xc8,0x95,0x53,0x4f,0x22,0xa1,0x74,0xbc,0x3e,0x6a,0x25,0xa2,0xb2,0xef,0xd6,0x30},\n\t\t{0x91,0x72,0x86,0x7e,0xb6,0x00,0x17,0x88,0x4c,0x6f,0xa8,0xcc,0x88,0xeb,0xe7,0xc9},\n\t\t{0x3b,0xd0,0xe1,0x1d,0x5e,0x09,0x4c,0xb7,0x1e,0x35,0x44,0xac,0xa9,0xb8,0xbf,0xa2},\n\t\t{0x93,0x37,0x16,0x64,0x44,0xcc,0x95,0x35,0xb7,0xd5,0xb8,0x0f,0x91,0xe5,0x29,0xcb}},\n\t\t{{0x2f,0x6e,0x73,0x13,0xbf,0xbb,0xbf,0xcc,0x3a,0x2d,0xde,0x26,0x8b,0x59,0xcc,0x4d},\n\t\t{0x69,0xf6,0xca,0xff,0x40,0x25,0x36,0xd1,0x7a,0xe1,0x38,0x03,0x2c,0x0c,0x5f,0xfd},\n\t\t{0x56,0xd3,0x2b,0x6c,0x34,0x76,0x65,0xd9,0x74,0xd6,0xf7,0x5c,0x3f,0xc6,0xf0,0x40},\n\t\t{0xb8,0x02,0xb2,0x15,0x4e,0x59,0x8b,0x6f,0x87,0x60,0x56,0xc7,0x85,0x46,0x2c,0x0b},\n\t\t{0x5a,0xde,0xf4,0xbf,0xf8,0x04,0xbe,0x08,0x58,0x7e,0x94,0x41,0xcf,0x6d,0xbd,0x57},\n\t\t{0x18,0xe3,0x49,0xa5,0x24,0x44,0xb3,0x0e,0x5e,0xba,0x5a,0xdd,0xdc,0xd9,0xf1,0x8d},\n\t\t{0xf2,0xb9,0x06,0xa5,0xb8,0x4b,0x9b,0x4b,0xbe,0x95,0xed,0x32,0x56,0x4e,0xe7,0xeb}}};\n\n\tbyte digest[MD5MAC::DIGESTSIZE];\n\tbool pass=true, fail;\n\n\tcout << \"\\nMD5MAC validation suite running...\\n\";\n\n\tfor (int k=0; k<2; k++)\n\t{\n\t\tMD5MAC mac(keys[k]);\n\t\tcout << \"\\nKEY: \";\n\t\tfor (int j=0;j<MD5MAC::KEYLENGTH;j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)keys[k][j];\n\t\tcout << endl << endl;\n\t\tfor (int i=0;i<7;i++)\n\t\t{\n\t\t\tmac.Update((byte *)TestVals[i], strlen(TestVals[i]));\n\t\t\tmac.Final(digest);\n\t\t\tfail = memcmp(digest, output[k][i], MD5MAC::DIGESTSIZE)\n\t\t\t\t || !mac.VerifyDigest(output[k][i], (byte *)TestVals[i], strlen(TestVals[i]));\n\t\t\tpass = pass && !fail;\n\t\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\t\tfor (int j=0;j<MD5MAC::DIGESTSIZE;j++)\n\t\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\t\tcout << \"   \\\"\" << TestVals[i] << '\\\"' << endl;\n\t\t}\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.VerifyDigest",
          "args": [
            "output[k][i]",
            "(byte *)TestVals[i]",
            "strlen(TestVals[i])"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TestVals[i]"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "digest",
            "output[k][i]",
            "MD5MAC::DIGESTSIZE"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.Final",
          "args": [
            "digest"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.Update",
          "args": [
            "(byte *)TestVals[i]",
            "strlen(TestVals[i])"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "TestVals[i]"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateMD5MAC()\n{\n\tconst byte keys[2][MD5MAC::KEYLENGTH]={\n\t\t{0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff},\n\t\t{0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10}};\n\n\tconst char *TestVals[7]={\n\t\t\"\",\n\t\t\"a\",\n\t\t\"abc\",\n\t\t\"message digest\",\n\t\t\"abcdefghijklmnopqrstuvwxyz\",\n\t\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n\t\t\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"};\n\n\tconst byte output[2][7][MD5MAC::DIGESTSIZE]={\n\t\t{{0x1f,0x1e,0xf2,0x37,0x5c,0xc0,0xe0,0x84,0x4f,0x98,0xe7,0xe8,0x11,0xa3,0x4d,0xa8},\n\t\t{0x7a,0x76,0xee,0x64,0xca,0x71,0xef,0x23,0x7e,0x26,0x29,0xed,0x94,0x52,0x73,0x65},\n\t\t{0xe8,0x01,0x3c,0x11,0xf7,0x20,0x9d,0x13,0x28,0xc0,0xca,0xa0,0x4f,0xd0,0x12,0xa6},\n\t\t{0xc8,0x95,0x53,0x4f,0x22,0xa1,0x74,0xbc,0x3e,0x6a,0x25,0xa2,0xb2,0xef,0xd6,0x30},\n\t\t{0x91,0x72,0x86,0x7e,0xb6,0x00,0x17,0x88,0x4c,0x6f,0xa8,0xcc,0x88,0xeb,0xe7,0xc9},\n\t\t{0x3b,0xd0,0xe1,0x1d,0x5e,0x09,0x4c,0xb7,0x1e,0x35,0x44,0xac,0xa9,0xb8,0xbf,0xa2},\n\t\t{0x93,0x37,0x16,0x64,0x44,0xcc,0x95,0x35,0xb7,0xd5,0xb8,0x0f,0x91,0xe5,0x29,0xcb}},\n\t\t{{0x2f,0x6e,0x73,0x13,0xbf,0xbb,0xbf,0xcc,0x3a,0x2d,0xde,0x26,0x8b,0x59,0xcc,0x4d},\n\t\t{0x69,0xf6,0xca,0xff,0x40,0x25,0x36,0xd1,0x7a,0xe1,0x38,0x03,0x2c,0x0c,0x5f,0xfd},\n\t\t{0x56,0xd3,0x2b,0x6c,0x34,0x76,0x65,0xd9,0x74,0xd6,0xf7,0x5c,0x3f,0xc6,0xf0,0x40},\n\t\t{0xb8,0x02,0xb2,0x15,0x4e,0x59,0x8b,0x6f,0x87,0x60,0x56,0xc7,0x85,0x46,0x2c,0x0b},\n\t\t{0x5a,0xde,0xf4,0xbf,0xf8,0x04,0xbe,0x08,0x58,0x7e,0x94,0x41,0xcf,0x6d,0xbd,0x57},\n\t\t{0x18,0xe3,0x49,0xa5,0x24,0x44,0xb3,0x0e,0x5e,0xba,0x5a,0xdd,0xdc,0xd9,0xf1,0x8d},\n\t\t{0xf2,0xb9,0x06,0xa5,0xb8,0x4b,0x9b,0x4b,0xbe,0x95,0xed,0x32,0x56,0x4e,0xe7,0xeb}}};\n\n\tbyte digest[MD5MAC::DIGESTSIZE];\n\tbool pass=true, fail;\n\n\tcout << \"\\nMD5MAC validation suite running...\\n\";\n\n\tfor (int k=0; k<2; k++)\n\t{\n\t\tMD5MAC mac(keys[k]);\n\t\tcout << \"\\nKEY: \";\n\t\tfor (int j=0;j<MD5MAC::KEYLENGTH;j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)keys[k][j];\n\t\tcout << endl << endl;\n\t\tfor (int i=0;i<7;i++)\n\t\t{\n\t\t\tmac.Update((byte *)TestVals[i], strlen(TestVals[i]));\n\t\t\tmac.Final(digest);\n\t\t\tfail = memcmp(digest, output[k][i], MD5MAC::DIGESTSIZE)\n\t\t\t\t || !mac.VerifyDigest(output[k][i], (byte *)TestVals[i], strlen(TestVals[i]));\n\t\t\tpass = pass && !fail;\n\t\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\t\tfor (int j=0;j<MD5MAC::DIGESTSIZE;j++)\n\t\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\t\tcout << \"   \\\"\" << TestVals[i] << '\\\"' << endl;\n\t\t}\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateWhirlpool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "327-330",
    "snippet": "bool ValidateWhirlpool()\n{\n\treturn RunTestDataFile(\"TestVectors/whrlpool.txt\");\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RunTestDataFile",
          "args": [
            "\"TestVectors/whrlpool.txt\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateWhirlpool()\n{\n\treturn RunTestDataFile(\"TestVectors/whrlpool.txt\");\n}"
  },
  {
    "function_name": "ValidatePanama",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "322-325",
    "snippet": "bool ValidatePanama()\n{\n\treturn RunTestDataFile(\"TestVectors/panama.txt\");\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RunTestDataFile",
          "args": [
            "\"TestVectors/panama.txt\""
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidatePanama()\n{\n\treturn RunTestDataFile(\"TestVectors/panama.txt\");\n}"
  },
  {
    "function_name": "ValidateHAVAL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "278-319",
    "snippet": "bool ValidateHAVAL()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\xC6\\x8F\\x39\\x91\\x3F\\x90\\x1F\\x3D\\xDF\\x44\\xC7\\x07\\x35\\x7A\\x7D\\x70\"),\n\t\tHashTestTuple(\"a\", \"\\x4D\\xA0\\x8F\\x51\\x4A\\x72\\x75\\xDB\\xC4\\xCE\\xCE\\x4A\\x34\\x73\\x85\\x98\\x39\\x83\\xA8\\x30\"),\n\t\tHashTestTuple(\"HAVAL\", \"\\x0C\\x13\\x96\\xD7\\x77\\x26\\x89\\xC4\\x67\\x73\\xF3\\xDA\\xAC\\xA4\\xEF\\xA9\\x82\\xAD\\xBF\\xB2\\xF1\\x46\\x7E\\xEA\"),\n\t\tHashTestTuple(\"0123456789\", \"\\xBE\\xBD\\x78\\x16\\xF0\\x9B\\xAE\\xEC\\xF8\\x90\\x3B\\x1B\\x9B\\xC6\\x72\\xD9\\xFA\\x42\\x8E\\x46\\x2B\\xA6\\x99\\xF8\\x14\\x84\\x15\\x29\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xC9\\xC7\\xD8\\xAF\\xA1\\x59\\xFD\\x9E\\x96\\x5C\\xB8\\x3F\\xF5\\xEE\\x6F\\x58\\xAE\\xDA\\x35\\x2C\\x0E\\xFF\\x00\\x55\\x48\\x15\\x3A\\x61\\x55\\x1C\\x38\\xEE\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xB4\\x5C\\xB6\\xE6\\x2F\\x2B\\x13\\x20\\xE4\\xF8\\xF1\\xB0\\xB2\\x73\\xD4\\x5A\\xDD\\x47\\xC3\\x21\\xFD\\x23\\x99\\x9D\\xCF\\x40\\x3A\\xC3\\x76\\x36\\xD9\\x63\")\n\t};\n\n\tbool pass=true;\n\n\tcout << \"\\nHAVAL validation suite running...\\n\\n\";\n\t{\n\t\tHAVAL3 md(16);\n\t\tpass = HashModuleTest(md, testSet+0, 1) && pass;\n\t}\n\t{\n\t\tHAVAL3 md(20);\n\t\tpass = HashModuleTest(md, testSet+1, 1) && pass;\n\t}\n\t{\n\t\tHAVAL4 md(24);\n\t\tpass = HashModuleTest(md, testSet+2, 1) && pass;\n\t}\n\t{\n\t\tHAVAL4 md(28);\n\t\tpass = HashModuleTest(md, testSet+3, 1) && pass;\n\t}\n\t{\n\t\tHAVAL5 md(32);\n\t\tpass = HashModuleTest(md, testSet+4, 1) && pass;\n\t}\n\t{\n\t\tHAVAL5 md(32);\n\t\tpass = HashModuleTest(md, testSet+5, 1) && pass;\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashModuleTest",
          "args": [
            "md",
            "testSet+5",
            "1"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "HashModuleTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "45-70",
          "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"",
            "\"\\xB4\\x5C\\xB6\\xE6\\x2F\\x2B\\x13\\x20\\xE4\\xF8\\xF1\\xB0\\xB2\\x73\\xD4\\x5A\\xDD\\x47\\xC3\\x21\\xFD\\x23\\x99\\x9D\\xCF\\x40\\x3A\\xC3\\x76\\x36\\xD9\\x63\""
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "HashTestTuple",
          "container": "HashTestTuple",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "34-35",
          "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateHAVAL()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\xC6\\x8F\\x39\\x91\\x3F\\x90\\x1F\\x3D\\xDF\\x44\\xC7\\x07\\x35\\x7A\\x7D\\x70\"),\n\t\tHashTestTuple(\"a\", \"\\x4D\\xA0\\x8F\\x51\\x4A\\x72\\x75\\xDB\\xC4\\xCE\\xCE\\x4A\\x34\\x73\\x85\\x98\\x39\\x83\\xA8\\x30\"),\n\t\tHashTestTuple(\"HAVAL\", \"\\x0C\\x13\\x96\\xD7\\x77\\x26\\x89\\xC4\\x67\\x73\\xF3\\xDA\\xAC\\xA4\\xEF\\xA9\\x82\\xAD\\xBF\\xB2\\xF1\\x46\\x7E\\xEA\"),\n\t\tHashTestTuple(\"0123456789\", \"\\xBE\\xBD\\x78\\x16\\xF0\\x9B\\xAE\\xEC\\xF8\\x90\\x3B\\x1B\\x9B\\xC6\\x72\\xD9\\xFA\\x42\\x8E\\x46\\x2B\\xA6\\x99\\xF8\\x14\\x84\\x15\\x29\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xC9\\xC7\\xD8\\xAF\\xA1\\x59\\xFD\\x9E\\x96\\x5C\\xB8\\x3F\\xF5\\xEE\\x6F\\x58\\xAE\\xDA\\x35\\x2C\\x0E\\xFF\\x00\\x55\\x48\\x15\\x3A\\x61\\x55\\x1C\\x38\\xEE\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xB4\\x5C\\xB6\\xE6\\x2F\\x2B\\x13\\x20\\xE4\\xF8\\xF1\\xB0\\xB2\\x73\\xD4\\x5A\\xDD\\x47\\xC3\\x21\\xFD\\x23\\x99\\x9D\\xCF\\x40\\x3A\\xC3\\x76\\x36\\xD9\\x63\")\n\t};\n\n\tbool pass=true;\n\n\tcout << \"\\nHAVAL validation suite running...\\n\\n\";\n\t{\n\t\tHAVAL3 md(16);\n\t\tpass = HashModuleTest(md, testSet+0, 1) && pass;\n\t}\n\t{\n\t\tHAVAL3 md(20);\n\t\tpass = HashModuleTest(md, testSet+1, 1) && pass;\n\t}\n\t{\n\t\tHAVAL4 md(24);\n\t\tpass = HashModuleTest(md, testSet+2, 1) && pass;\n\t}\n\t{\n\t\tHAVAL4 md(28);\n\t\tpass = HashModuleTest(md, testSet+3, 1) && pass;\n\t}\n\t{\n\t\tHAVAL5 md(32);\n\t\tpass = HashModuleTest(md, testSet+4, 1) && pass;\n\t}\n\t{\n\t\tHAVAL5 md(32);\n\t\tpass = HashModuleTest(md, testSet+5, 1) && pass;\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateRIPEMD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "202-275",
    "snippet": "bool ValidateRIPEMD()\n{\n\tHashTestTuple testSet128[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\xcd\\xf2\\x62\\x13\\xa1\\x50\\xdc\\x3e\\xcb\\x61\\x0f\\x18\\xf6\\xb3\\x8b\\x46\"),\n\t\tHashTestTuple(\"a\", \"\\x86\\xbe\\x7a\\xfa\\x33\\x9d\\x0f\\xc7\\xcf\\xc7\\x85\\xe7\\x2f\\x57\\x8d\\x33\"),\n\t\tHashTestTuple(\"abc\", \"\\xc1\\x4a\\x12\\x19\\x9c\\x66\\xe4\\xba\\x84\\x63\\x6b\\x0f\\x69\\x14\\x4c\\x77\"),\n\t\tHashTestTuple(\"message digest\", \"\\x9e\\x32\\x7b\\x3d\\x6e\\x52\\x30\\x62\\xaf\\xc1\\x13\\x2d\\x7d\\xf9\\xd1\\xb8\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xfd\\x2a\\xa6\\x07\\xf7\\x1d\\xc8\\xf5\\x10\\x71\\x49\\x22\\xb3\\x71\\x83\\x4e\"),\n\t\tHashTestTuple(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\", \"\\xa1\\xaa\\x06\\x89\\xd0\\xfa\\xfa\\x2d\\xdc\\x22\\xe8\\x8b\\x49\\x13\\x3a\\x06\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xd1\\xe9\\x59\\xeb\\x17\\x9c\\x91\\x1f\\xae\\xa4\\x62\\x4c\\x60\\xc5\\xc7\\x02\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x3f\\x45\\xef\\x19\\x47\\x32\\xc2\\xdb\\xb2\\xc4\\xa2\\xc7\\x69\\x79\\x5f\\xa3\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\x4a\\x7f\\x57\\x23\\xf9\\x54\\xeb\\xa1\\x21\\x6c\\x9d\\x8f\\x63\\x20\\x43\\x1f\", 15625)\n\t};\n\n\tHashTestTuple testSet160[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x9c\\x11\\x85\\xa5\\xc5\\xe9\\xfc\\x54\\x61\\x28\\x08\\x97\\x7e\\xe8\\xf5\\x48\\xb2\\x25\\x8d\\x31\"),\n\t\tHashTestTuple(\"a\", \"\\x0b\\xdc\\x9d\\x2d\\x25\\x6b\\x3e\\xe9\\xda\\xae\\x34\\x7b\\xe6\\xf4\\xdc\\x83\\x5a\\x46\\x7f\\xfe\"),\n\t\tHashTestTuple(\"abc\", \"\\x8e\\xb2\\x08\\xf7\\xe0\\x5d\\x98\\x7a\\x9b\\x04\\x4a\\x8e\\x98\\xc6\\xb0\\x87\\xf1\\x5a\\x0b\\xfc\"),\n\t\tHashTestTuple(\"message digest\", \"\\x5d\\x06\\x89\\xef\\x49\\xd2\\xfa\\xe5\\x72\\xb8\\x81\\xb1\\x23\\xa8\\x5f\\xfa\\x21\\x59\\x5f\\x36\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xf7\\x1c\\x27\\x10\\x9c\\x69\\x2c\\x1b\\x56\\xbb\\xdc\\xeb\\x5b\\x9d\\x28\\x65\\xb3\\x70\\x8d\\xbc\"),\n\t\tHashTestTuple(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\", \"\\x12\\xa0\\x53\\x38\\x4a\\x9c\\x0c\\x88\\xe4\\x05\\xa0\\x6c\\x27\\xdc\\xf4\\x9a\\xda\\x62\\xeb\\x2b\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xb0\\xe2\\x0b\\x6e\\x31\\x16\\x64\\x02\\x86\\xed\\x3a\\x87\\xa5\\x71\\x30\\x79\\xb2\\x1f\\x51\\x89\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x9b\\x75\\x2e\\x45\\x57\\x3d\\x4b\\x39\\xf4\\xdb\\xd3\\x32\\x3c\\xab\\x82\\xbf\\x63\\x32\\x6b\\xfb\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\x52\\x78\\x32\\x43\\xc1\\x69\\x7b\\xdb\\xe1\\x6d\\x37\\xf9\\x7f\\x68\\xf0\\x83\\x25\\xdc\\x15\\x28\", 15625)\n\t};\n\n\tHashTestTuple testSet256[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x02\\xba\\x4c\\x4e\\x5f\\x8e\\xcd\\x18\\x77\\xfc\\x52\\xd6\\x4d\\x30\\xe3\\x7a\\x2d\\x97\\x74\\xfb\\x1e\\x5d\\x02\\x63\\x80\\xae\\x01\\x68\\xe3\\xc5\\x52\\x2d\"),\n\t\tHashTestTuple(\"a\", \"\\xf9\\x33\\x3e\\x45\\xd8\\x57\\xf5\\xd9\\x0a\\x91\\xba\\xb7\\x0a\\x1e\\xba\\x0c\\xfb\\x1b\\xe4\\xb0\\x78\\x3c\\x9a\\xcf\\xcd\\x88\\x3a\\x91\\x34\\x69\\x29\\x25\"),\n\t\tHashTestTuple(\"abc\", \"\\xaf\\xbd\\x6e\\x22\\x8b\\x9d\\x8c\\xbb\\xce\\xf5\\xca\\x2d\\x03\\xe6\\xdb\\xa1\\x0a\\xc0\\xbc\\x7d\\xcb\\xe4\\x68\\x0e\\x1e\\x42\\xd2\\xe9\\x75\\x45\\x9b\\x65\"),\n\t\tHashTestTuple(\"message digest\", \"\\x87\\xe9\\x71\\x75\\x9a\\x1c\\xe4\\x7a\\x51\\x4d\\x5c\\x91\\x4c\\x39\\x2c\\x90\\x18\\xc7\\xc4\\x6b\\xc1\\x44\\x65\\x55\\x4a\\xfc\\xdf\\x54\\xa5\\x07\\x0c\\x0e\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\x64\\x9d\\x30\\x34\\x75\\x1e\\xa2\\x16\\x77\\x6b\\xf9\\xa1\\x8a\\xcc\\x81\\xbc\\x78\\x96\\x11\\x8a\\x51\\x97\\x96\\x87\\x82\\xdd\\x1f\\xd9\\x7d\\x8d\\x51\\x33\"),\n\t\tHashTestTuple(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\", \"\\x38\\x43\\x04\\x55\\x83\\xaa\\xc6\\xc8\\xc8\\xd9\\x12\\x85\\x73\\xe7\\xa9\\x80\\x9a\\xfb\\x2a\\x0f\\x34\\xcc\\xc3\\x6e\\xa9\\xe7\\x2f\\x16\\xf6\\x36\\x8e\\x3f\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\x57\\x40\\xa4\\x08\\xac\\x16\\xb7\\x20\\xb8\\x44\\x24\\xae\\x93\\x1c\\xbb\\x1f\\xe3\\x63\\xd1\\xd0\\xbf\\x40\\x17\\xf1\\xa8\\x9f\\x7e\\xa6\\xde\\x77\\xa0\\xb8\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x06\\xfd\\xcc\\x7a\\x40\\x95\\x48\\xaa\\xf9\\x13\\x68\\xc0\\x6a\\x62\\x75\\xb5\\x53\\xe3\\xf0\\x99\\xbf\\x0e\\xa4\\xed\\xfd\\x67\\x78\\xdf\\x89\\xa8\\x90\\xdd\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\xac\\x95\\x37\\x44\\xe1\\x0e\\x31\\x51\\x4c\\x15\\x0d\\x4d\\x8d\\x7b\\x67\\x73\\x42\\xe3\\x33\\x99\\x78\\x82\\x96\\xe4\\x3a\\xe4\\x85\\x0c\\xe4\\xf9\\x79\\x78\", 15625)\n\t};\n\n\tHashTestTuple testSet320[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x22\\xd6\\x5d\\x56\\x61\\x53\\x6c\\xdc\\x75\\xc1\\xfd\\xf5\\xc6\\xde\\x7b\\x41\\xb9\\xf2\\x73\\x25\\xeb\\xc6\\x1e\\x85\\x57\\x17\\x7d\\x70\\x5a\\x0e\\xc8\\x80\\x15\\x1c\\x3a\\x32\\xa0\\x08\\x99\\xb8\"),\n\t\tHashTestTuple(\"a\", \"\\xce\\x78\\x85\\x06\\x38\\xf9\\x26\\x58\\xa5\\xa5\\x85\\x09\\x75\\x79\\x92\\x6d\\xda\\x66\\x7a\\x57\\x16\\x56\\x2c\\xfc\\xf6\\xfb\\xe7\\x7f\\x63\\x54\\x2f\\x99\\xb0\\x47\\x05\\xd6\\x97\\x0d\\xff\\x5d\"),\n\t\tHashTestTuple(\"abc\", \"\\xde\\x4c\\x01\\xb3\\x05\\x4f\\x89\\x30\\xa7\\x9d\\x09\\xae\\x73\\x8e\\x92\\x30\\x1e\\x5a\\x17\\x08\\x5b\\xef\\xfd\\xc1\\xb8\\xd1\\x16\\x71\\x3e\\x74\\xf8\\x2f\\xa9\\x42\\xd6\\x4c\\xdb\\xc4\\x68\\x2d\"),\n\t\tHashTestTuple(\"message digest\", \"\\x3a\\x8e\\x28\\x50\\x2e\\xd4\\x5d\\x42\\x2f\\x68\\x84\\x4f\\x9d\\xd3\\x16\\xe7\\xb9\\x85\\x33\\xfa\\x3f\\x2a\\x91\\xd2\\x9f\\x84\\xd4\\x25\\xc8\\x8d\\x6b\\x4e\\xff\\x72\\x7d\\xf6\\x6a\\x7c\\x01\\x97\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xca\\xbd\\xb1\\x81\\x0b\\x92\\x47\\x0a\\x20\\x93\\xaa\\x6b\\xce\\x05\\x95\\x2c\\x28\\x34\\x8c\\xf4\\x3f\\xf6\\x08\\x41\\x97\\x51\\x66\\xbb\\x40\\xed\\x23\\x40\\x04\\xb8\\x82\\x44\\x63\\xe6\\xb0\\x09\"),\n\t\tHashTestTuple(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\", \"\\xd0\\x34\\xa7\\x95\\x0c\\xf7\\x22\\x02\\x1b\\xa4\\xb8\\x4d\\xf7\\x69\\xa5\\xde\\x20\\x60\\xe2\\x59\\xdf\\x4c\\x9b\\xb4\\xa4\\x26\\x8c\\x0e\\x93\\x5b\\xbc\\x74\\x70\\xa9\\x69\\xc9\\xd0\\x72\\xa1\\xac\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xed\\x54\\x49\\x40\\xc8\\x6d\\x67\\xf2\\x50\\xd2\\x32\\xc3\\x0b\\x7b\\x3e\\x57\\x70\\xe0\\xc6\\x0c\\x8c\\xb9\\xa4\\xca\\xfe\\x3b\\x11\\x38\\x8a\\xf9\\x92\\x0e\\x1b\\x99\\x23\\x0b\\x84\\x3c\\x86\\xa4\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x55\\x78\\x88\\xaf\\x5f\\x6d\\x8e\\xd6\\x2a\\xb6\\x69\\x45\\xc6\\xd2\\xa0\\xa4\\x7e\\xcd\\x53\\x41\\xe9\\x15\\xeb\\x8f\\xea\\x1d\\x05\\x24\\x95\\x5f\\x82\\x5d\\xc7\\x17\\xe4\\xa0\\x08\\xab\\x2d\\x42\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\xbd\\xee\\x37\\xf4\\x37\\x1e\\x20\\x64\\x6b\\x8b\\x0d\\x86\\x2d\\xda\\x16\\x29\\x2a\\xe3\\x6f\\x40\\x96\\x5e\\x8c\\x85\\x09\\xe6\\x3d\\x1d\\xbd\\xde\\xcc\\x50\\x3e\\x2b\\x63\\xeb\\x92\\x45\\xbb\\x66\", 15625)\n\t};\n\n\tbool pass = true;\n\n\tcout << \"\\nRIPEMD-128 validation suite running...\\n\\n\";\n\tRIPEMD128 md128;\n\tpass = HashModuleTest(md128, testSet128, sizeof(testSet128)/sizeof(testSet128[0])) && pass;\n\n\tcout << \"\\nRIPEMD-160 validation suite running...\\n\\n\";\n\tRIPEMD160 md160;\n\tpass = HashModuleTest(md160, testSet160, sizeof(testSet160)/sizeof(testSet160[0])) && pass;\n\n\tcout << \"\\nRIPEMD-256 validation suite running...\\n\\n\";\n\tRIPEMD256 md256;\n\tpass = HashModuleTest(md256, testSet256, sizeof(testSet256)/sizeof(testSet256[0])) && pass;\n\n\tcout << \"\\nRIPEMD-320 validation suite running...\\n\\n\";\n\tRIPEMD320 md320;\n\tpass = HashModuleTest(md320, testSet320, sizeof(testSet320)/sizeof(testSet320[0])) && pass;\n\n\treturn pass;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashModuleTest",
          "args": [
            "md320",
            "testSet320",
            "sizeof(testSet320)/sizeof(testSet320[0])"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "HashModuleTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "45-70",
          "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
            "\"\\xbd\\xee\\x37\\xf4\\x37\\x1e\\x20\\x64\\x6b\\x8b\\x0d\\x86\\x2d\\xda\\x16\\x29\\x2a\\xe3\\x6f\\x40\\x96\\x5e\\x8c\\x85\\x09\\xe6\\x3d\\x1d\\xbd\\xde\\xcc\\x50\\x3e\\x2b\\x63\\xeb\\x92\\x45\\xbb\\x66\"",
            "15625"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"",
            "\"\\x55\\x78\\x88\\xaf\\x5f\\x6d\\x8e\\xd6\\x2a\\xb6\\x69\\x45\\xc6\\xd2\\xa0\\xa4\\x7e\\xcd\\x53\\x41\\xe9\\x15\\xeb\\x8f\\xea\\x1d\\x05\\x24\\x95\\x5f\\x82\\x5d\\xc7\\x17\\xe4\\xa0\\x08\\xab\\x2d\\x42\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "HashTestTuple",
          "container": "HashTestTuple",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "34-35",
          "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
            "\"\\xac\\x95\\x37\\x44\\xe1\\x0e\\x31\\x51\\x4c\\x15\\x0d\\x4d\\x8d\\x7b\\x67\\x73\\x42\\xe3\\x33\\x99\\x78\\x82\\x96\\xe4\\x3a\\xe4\\x85\\x0c\\xe4\\xf9\\x79\\x78\"",
            "15625"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
            "\"\\x52\\x78\\x32\\x43\\xc1\\x69\\x7b\\xdb\\xe1\\x6d\\x37\\xf9\\x7f\\x68\\xf0\\x83\\x25\\xdc\\x15\\x28\"",
            "15625"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
            "\"\\x4a\\x7f\\x57\\x23\\xf9\\x54\\xeb\\xa1\\x21\\x6c\\x9d\\x8f\\x63\\x20\\x43\\x1f\"",
            "15625"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateRIPEMD()\n{\n\tHashTestTuple testSet128[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\xcd\\xf2\\x62\\x13\\xa1\\x50\\xdc\\x3e\\xcb\\x61\\x0f\\x18\\xf6\\xb3\\x8b\\x46\"),\n\t\tHashTestTuple(\"a\", \"\\x86\\xbe\\x7a\\xfa\\x33\\x9d\\x0f\\xc7\\xcf\\xc7\\x85\\xe7\\x2f\\x57\\x8d\\x33\"),\n\t\tHashTestTuple(\"abc\", \"\\xc1\\x4a\\x12\\x19\\x9c\\x66\\xe4\\xba\\x84\\x63\\x6b\\x0f\\x69\\x14\\x4c\\x77\"),\n\t\tHashTestTuple(\"message digest\", \"\\x9e\\x32\\x7b\\x3d\\x6e\\x52\\x30\\x62\\xaf\\xc1\\x13\\x2d\\x7d\\xf9\\xd1\\xb8\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xfd\\x2a\\xa6\\x07\\xf7\\x1d\\xc8\\xf5\\x10\\x71\\x49\\x22\\xb3\\x71\\x83\\x4e\"),\n\t\tHashTestTuple(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\", \"\\xa1\\xaa\\x06\\x89\\xd0\\xfa\\xfa\\x2d\\xdc\\x22\\xe8\\x8b\\x49\\x13\\x3a\\x06\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xd1\\xe9\\x59\\xeb\\x17\\x9c\\x91\\x1f\\xae\\xa4\\x62\\x4c\\x60\\xc5\\xc7\\x02\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x3f\\x45\\xef\\x19\\x47\\x32\\xc2\\xdb\\xb2\\xc4\\xa2\\xc7\\x69\\x79\\x5f\\xa3\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\x4a\\x7f\\x57\\x23\\xf9\\x54\\xeb\\xa1\\x21\\x6c\\x9d\\x8f\\x63\\x20\\x43\\x1f\", 15625)\n\t};\n\n\tHashTestTuple testSet160[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x9c\\x11\\x85\\xa5\\xc5\\xe9\\xfc\\x54\\x61\\x28\\x08\\x97\\x7e\\xe8\\xf5\\x48\\xb2\\x25\\x8d\\x31\"),\n\t\tHashTestTuple(\"a\", \"\\x0b\\xdc\\x9d\\x2d\\x25\\x6b\\x3e\\xe9\\xda\\xae\\x34\\x7b\\xe6\\xf4\\xdc\\x83\\x5a\\x46\\x7f\\xfe\"),\n\t\tHashTestTuple(\"abc\", \"\\x8e\\xb2\\x08\\xf7\\xe0\\x5d\\x98\\x7a\\x9b\\x04\\x4a\\x8e\\x98\\xc6\\xb0\\x87\\xf1\\x5a\\x0b\\xfc\"),\n\t\tHashTestTuple(\"message digest\", \"\\x5d\\x06\\x89\\xef\\x49\\xd2\\xfa\\xe5\\x72\\xb8\\x81\\xb1\\x23\\xa8\\x5f\\xfa\\x21\\x59\\x5f\\x36\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xf7\\x1c\\x27\\x10\\x9c\\x69\\x2c\\x1b\\x56\\xbb\\xdc\\xeb\\x5b\\x9d\\x28\\x65\\xb3\\x70\\x8d\\xbc\"),\n\t\tHashTestTuple(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\", \"\\x12\\xa0\\x53\\x38\\x4a\\x9c\\x0c\\x88\\xe4\\x05\\xa0\\x6c\\x27\\xdc\\xf4\\x9a\\xda\\x62\\xeb\\x2b\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xb0\\xe2\\x0b\\x6e\\x31\\x16\\x64\\x02\\x86\\xed\\x3a\\x87\\xa5\\x71\\x30\\x79\\xb2\\x1f\\x51\\x89\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x9b\\x75\\x2e\\x45\\x57\\x3d\\x4b\\x39\\xf4\\xdb\\xd3\\x32\\x3c\\xab\\x82\\xbf\\x63\\x32\\x6b\\xfb\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\x52\\x78\\x32\\x43\\xc1\\x69\\x7b\\xdb\\xe1\\x6d\\x37\\xf9\\x7f\\x68\\xf0\\x83\\x25\\xdc\\x15\\x28\", 15625)\n\t};\n\n\tHashTestTuple testSet256[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x02\\xba\\x4c\\x4e\\x5f\\x8e\\xcd\\x18\\x77\\xfc\\x52\\xd6\\x4d\\x30\\xe3\\x7a\\x2d\\x97\\x74\\xfb\\x1e\\x5d\\x02\\x63\\x80\\xae\\x01\\x68\\xe3\\xc5\\x52\\x2d\"),\n\t\tHashTestTuple(\"a\", \"\\xf9\\x33\\x3e\\x45\\xd8\\x57\\xf5\\xd9\\x0a\\x91\\xba\\xb7\\x0a\\x1e\\xba\\x0c\\xfb\\x1b\\xe4\\xb0\\x78\\x3c\\x9a\\xcf\\xcd\\x88\\x3a\\x91\\x34\\x69\\x29\\x25\"),\n\t\tHashTestTuple(\"abc\", \"\\xaf\\xbd\\x6e\\x22\\x8b\\x9d\\x8c\\xbb\\xce\\xf5\\xca\\x2d\\x03\\xe6\\xdb\\xa1\\x0a\\xc0\\xbc\\x7d\\xcb\\xe4\\x68\\x0e\\x1e\\x42\\xd2\\xe9\\x75\\x45\\x9b\\x65\"),\n\t\tHashTestTuple(\"message digest\", \"\\x87\\xe9\\x71\\x75\\x9a\\x1c\\xe4\\x7a\\x51\\x4d\\x5c\\x91\\x4c\\x39\\x2c\\x90\\x18\\xc7\\xc4\\x6b\\xc1\\x44\\x65\\x55\\x4a\\xfc\\xdf\\x54\\xa5\\x07\\x0c\\x0e\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\x64\\x9d\\x30\\x34\\x75\\x1e\\xa2\\x16\\x77\\x6b\\xf9\\xa1\\x8a\\xcc\\x81\\xbc\\x78\\x96\\x11\\x8a\\x51\\x97\\x96\\x87\\x82\\xdd\\x1f\\xd9\\x7d\\x8d\\x51\\x33\"),\n\t\tHashTestTuple(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\", \"\\x38\\x43\\x04\\x55\\x83\\xaa\\xc6\\xc8\\xc8\\xd9\\x12\\x85\\x73\\xe7\\xa9\\x80\\x9a\\xfb\\x2a\\x0f\\x34\\xcc\\xc3\\x6e\\xa9\\xe7\\x2f\\x16\\xf6\\x36\\x8e\\x3f\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\x57\\x40\\xa4\\x08\\xac\\x16\\xb7\\x20\\xb8\\x44\\x24\\xae\\x93\\x1c\\xbb\\x1f\\xe3\\x63\\xd1\\xd0\\xbf\\x40\\x17\\xf1\\xa8\\x9f\\x7e\\xa6\\xde\\x77\\xa0\\xb8\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x06\\xfd\\xcc\\x7a\\x40\\x95\\x48\\xaa\\xf9\\x13\\x68\\xc0\\x6a\\x62\\x75\\xb5\\x53\\xe3\\xf0\\x99\\xbf\\x0e\\xa4\\xed\\xfd\\x67\\x78\\xdf\\x89\\xa8\\x90\\xdd\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\xac\\x95\\x37\\x44\\xe1\\x0e\\x31\\x51\\x4c\\x15\\x0d\\x4d\\x8d\\x7b\\x67\\x73\\x42\\xe3\\x33\\x99\\x78\\x82\\x96\\xe4\\x3a\\xe4\\x85\\x0c\\xe4\\xf9\\x79\\x78\", 15625)\n\t};\n\n\tHashTestTuple testSet320[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x22\\xd6\\x5d\\x56\\x61\\x53\\x6c\\xdc\\x75\\xc1\\xfd\\xf5\\xc6\\xde\\x7b\\x41\\xb9\\xf2\\x73\\x25\\xeb\\xc6\\x1e\\x85\\x57\\x17\\x7d\\x70\\x5a\\x0e\\xc8\\x80\\x15\\x1c\\x3a\\x32\\xa0\\x08\\x99\\xb8\"),\n\t\tHashTestTuple(\"a\", \"\\xce\\x78\\x85\\x06\\x38\\xf9\\x26\\x58\\xa5\\xa5\\x85\\x09\\x75\\x79\\x92\\x6d\\xda\\x66\\x7a\\x57\\x16\\x56\\x2c\\xfc\\xf6\\xfb\\xe7\\x7f\\x63\\x54\\x2f\\x99\\xb0\\x47\\x05\\xd6\\x97\\x0d\\xff\\x5d\"),\n\t\tHashTestTuple(\"abc\", \"\\xde\\x4c\\x01\\xb3\\x05\\x4f\\x89\\x30\\xa7\\x9d\\x09\\xae\\x73\\x8e\\x92\\x30\\x1e\\x5a\\x17\\x08\\x5b\\xef\\xfd\\xc1\\xb8\\xd1\\x16\\x71\\x3e\\x74\\xf8\\x2f\\xa9\\x42\\xd6\\x4c\\xdb\\xc4\\x68\\x2d\"),\n\t\tHashTestTuple(\"message digest\", \"\\x3a\\x8e\\x28\\x50\\x2e\\xd4\\x5d\\x42\\x2f\\x68\\x84\\x4f\\x9d\\xd3\\x16\\xe7\\xb9\\x85\\x33\\xfa\\x3f\\x2a\\x91\\xd2\\x9f\\x84\\xd4\\x25\\xc8\\x8d\\x6b\\x4e\\xff\\x72\\x7d\\xf6\\x6a\\x7c\\x01\\x97\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xca\\xbd\\xb1\\x81\\x0b\\x92\\x47\\x0a\\x20\\x93\\xaa\\x6b\\xce\\x05\\x95\\x2c\\x28\\x34\\x8c\\xf4\\x3f\\xf6\\x08\\x41\\x97\\x51\\x66\\xbb\\x40\\xed\\x23\\x40\\x04\\xb8\\x82\\x44\\x63\\xe6\\xb0\\x09\"),\n\t\tHashTestTuple(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\", \"\\xd0\\x34\\xa7\\x95\\x0c\\xf7\\x22\\x02\\x1b\\xa4\\xb8\\x4d\\xf7\\x69\\xa5\\xde\\x20\\x60\\xe2\\x59\\xdf\\x4c\\x9b\\xb4\\xa4\\x26\\x8c\\x0e\\x93\\x5b\\xbc\\x74\\x70\\xa9\\x69\\xc9\\xd0\\x72\\xa1\\xac\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xed\\x54\\x49\\x40\\xc8\\x6d\\x67\\xf2\\x50\\xd2\\x32\\xc3\\x0b\\x7b\\x3e\\x57\\x70\\xe0\\xc6\\x0c\\x8c\\xb9\\xa4\\xca\\xfe\\x3b\\x11\\x38\\x8a\\xf9\\x92\\x0e\\x1b\\x99\\x23\\x0b\\x84\\x3c\\x86\\xa4\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x55\\x78\\x88\\xaf\\x5f\\x6d\\x8e\\xd6\\x2a\\xb6\\x69\\x45\\xc6\\xd2\\xa0\\xa4\\x7e\\xcd\\x53\\x41\\xe9\\x15\\xeb\\x8f\\xea\\x1d\\x05\\x24\\x95\\x5f\\x82\\x5d\\xc7\\x17\\xe4\\xa0\\x08\\xab\\x2d\\x42\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\xbd\\xee\\x37\\xf4\\x37\\x1e\\x20\\x64\\x6b\\x8b\\x0d\\x86\\x2d\\xda\\x16\\x29\\x2a\\xe3\\x6f\\x40\\x96\\x5e\\x8c\\x85\\x09\\xe6\\x3d\\x1d\\xbd\\xde\\xcc\\x50\\x3e\\x2b\\x63\\xeb\\x92\\x45\\xbb\\x66\", 15625)\n\t};\n\n\tbool pass = true;\n\n\tcout << \"\\nRIPEMD-128 validation suite running...\\n\\n\";\n\tRIPEMD128 md128;\n\tpass = HashModuleTest(md128, testSet128, sizeof(testSet128)/sizeof(testSet128[0])) && pass;\n\n\tcout << \"\\nRIPEMD-160 validation suite running...\\n\\n\";\n\tRIPEMD160 md160;\n\tpass = HashModuleTest(md160, testSet160, sizeof(testSet160)/sizeof(testSet160[0])) && pass;\n\n\tcout << \"\\nRIPEMD-256 validation suite running...\\n\\n\";\n\tRIPEMD256 md256;\n\tpass = HashModuleTest(md256, testSet256, sizeof(testSet256)/sizeof(testSet256[0])) && pass;\n\n\tcout << \"\\nRIPEMD-320 validation suite running...\\n\\n\";\n\tRIPEMD320 md320;\n\tpass = HashModuleTest(md320, testSet320, sizeof(testSet320)/sizeof(testSet320[0])) && pass;\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateTiger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "180-200",
    "snippet": "bool ValidateTiger()\n{\n\tcout << \"\\nTiger validation suite running...\\n\\n\";\n\n\tHashTestTuple testSet[] =\n\t{\n\t\tHashTestTuple(\"\", \"\\x32\\x93\\xac\\x63\\x0c\\x13\\xf0\\x24\\x5f\\x92\\xbb\\xb1\\x76\\x6e\\x16\\x16\\x7a\\x4e\\x58\\x49\\x2d\\xde\\x73\\xf3\"),\n\t\tHashTestTuple(\"abc\", \"\\x2a\\xab\\x14\\x84\\xe8\\xc1\\x58\\xf2\\xbf\\xb8\\xc5\\xff\\x41\\xb5\\x7a\\x52\\x51\\x29\\x13\\x1c\\x95\\x7b\\x5f\\x93\"),\n\t\tHashTestTuple(\"Tiger\", \"\\xdd\\x00\\x23\\x07\\x99\\xf5\\x00\\x9f\\xec\\x6d\\xeb\\xc8\\x38\\xbb\\x6a\\x27\\xdf\\x2b\\x9d\\x6f\\x11\\x0c\\x79\\x37\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-\", \"\\xf7\\x1c\\x85\\x83\\x90\\x2a\\xfb\\x87\\x9e\\xdf\\xe6\\x10\\xf8\\x2c\\x0d\\x47\\x86\\xa3\\xa5\\x34\\x50\\x44\\x86\\xb5\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ=abcdefghijklmnopqrstuvwxyz+0123456789\", \"\\x48\\xce\\xeb\\x63\\x08\\xb8\\x7d\\x46\\xe9\\x5d\\x65\\x61\\x12\\xcd\\xf1\\x8d\\x97\\x91\\x5f\\x97\\x65\\x65\\x89\\x57\"),\n\t\tHashTestTuple(\"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham\", \"\\x8a\\x86\\x68\\x29\\x04\\x0a\\x41\\x0c\\x72\\x9a\\xd2\\x3f\\x5a\\xda\\x71\\x16\\x03\\xb3\\xcd\\xd3\\x57\\xe4\\xc1\\x5e\"),\n\t\tHashTestTuple(\"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham, proceedings of Fast Software Encryption 3, Cambridge.\", \"\\xce\\x55\\xa6\\xaf\\xd5\\x91\\xf5\\xeb\\xac\\x54\\x7f\\xf8\\x4f\\x89\\x22\\x7f\\x93\\x31\\xda\\xb0\\xb6\\x11\\xc8\\x89\"),\n\t\tHashTestTuple(\"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham, proceedings of Fast Software Encryption 3, Cambridge, 1996.\", \"\\x63\\x1a\\xbd\\xd1\\x03\\xeb\\x9a\\x3d\\x24\\x5b\\x6d\\xfd\\x4d\\x77\\xb2\\x57\\xfc\\x74\\x39\\x50\\x1d\\x15\\x68\\xdd\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-\", \"\\xc5\\x40\\x34\\xe5\\xb4\\x3e\\xb8\\x00\\x58\\x48\\xa7\\xe0\\xae\\x6a\\xac\\x76\\xe4\\xff\\x59\\x0a\\xe7\\x15\\xfd\\x25\")\n\t};\n\n\tTiger tiger;\n\n\treturn HashModuleTest(tiger, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashModuleTest",
          "args": [
            "tiger",
            "testSet",
            "sizeof(testSet)/sizeof(testSet[0])"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "HashModuleTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "45-70",
          "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-\"",
            "\"\\xc5\\x40\\x34\\xe5\\xb4\\x3e\\xb8\\x00\\x58\\x48\\xa7\\xe0\\xae\\x6a\\xac\\x76\\xe4\\xff\\x59\\x0a\\xe7\\x15\\xfd\\x25\""
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "HashTestTuple",
          "container": "HashTestTuple",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "34-35",
          "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateTiger()\n{\n\tcout << \"\\nTiger validation suite running...\\n\\n\";\n\n\tHashTestTuple testSet[] =\n\t{\n\t\tHashTestTuple(\"\", \"\\x32\\x93\\xac\\x63\\x0c\\x13\\xf0\\x24\\x5f\\x92\\xbb\\xb1\\x76\\x6e\\x16\\x16\\x7a\\x4e\\x58\\x49\\x2d\\xde\\x73\\xf3\"),\n\t\tHashTestTuple(\"abc\", \"\\x2a\\xab\\x14\\x84\\xe8\\xc1\\x58\\xf2\\xbf\\xb8\\xc5\\xff\\x41\\xb5\\x7a\\x52\\x51\\x29\\x13\\x1c\\x95\\x7b\\x5f\\x93\"),\n\t\tHashTestTuple(\"Tiger\", \"\\xdd\\x00\\x23\\x07\\x99\\xf5\\x00\\x9f\\xec\\x6d\\xeb\\xc8\\x38\\xbb\\x6a\\x27\\xdf\\x2b\\x9d\\x6f\\x11\\x0c\\x79\\x37\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-\", \"\\xf7\\x1c\\x85\\x83\\x90\\x2a\\xfb\\x87\\x9e\\xdf\\xe6\\x10\\xf8\\x2c\\x0d\\x47\\x86\\xa3\\xa5\\x34\\x50\\x44\\x86\\xb5\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ=abcdefghijklmnopqrstuvwxyz+0123456789\", \"\\x48\\xce\\xeb\\x63\\x08\\xb8\\x7d\\x46\\xe9\\x5d\\x65\\x61\\x12\\xcd\\xf1\\x8d\\x97\\x91\\x5f\\x97\\x65\\x65\\x89\\x57\"),\n\t\tHashTestTuple(\"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham\", \"\\x8a\\x86\\x68\\x29\\x04\\x0a\\x41\\x0c\\x72\\x9a\\xd2\\x3f\\x5a\\xda\\x71\\x16\\x03\\xb3\\xcd\\xd3\\x57\\xe4\\xc1\\x5e\"),\n\t\tHashTestTuple(\"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham, proceedings of Fast Software Encryption 3, Cambridge.\", \"\\xce\\x55\\xa6\\xaf\\xd5\\x91\\xf5\\xeb\\xac\\x54\\x7f\\xf8\\x4f\\x89\\x22\\x7f\\x93\\x31\\xda\\xb0\\xb6\\x11\\xc8\\x89\"),\n\t\tHashTestTuple(\"Tiger - A Fast New Hash Function, by Ross Anderson and Eli Biham, proceedings of Fast Software Encryption 3, Cambridge, 1996.\", \"\\x63\\x1a\\xbd\\xd1\\x03\\xeb\\x9a\\x3d\\x24\\x5b\\x6d\\xfd\\x4d\\x77\\xb2\\x57\\xfc\\x74\\x39\\x50\\x1d\\x15\\x68\\xdd\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-\", \"\\xc5\\x40\\x34\\xe5\\xb4\\x3e\\xb8\\x00\\x58\\x48\\xa7\\xe0\\xae\\x6a\\xac\\x76\\xe4\\xff\\x59\\x0a\\xe7\\x15\\xfd\\x25\")\n\t};\n\n\tTiger tiger;\n\n\treturn HashModuleTest(tiger, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}"
  },
  {
    "function_name": "ValidateSHA2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "174-178",
    "snippet": "bool ValidateSHA2()\n{\n\tcout << \"\\nSHA validation suite running...\\n\\n\";\n\treturn RunTestDataFile(\"TestVectors/sha.txt\");\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RunTestDataFile",
          "args": [
            "\"TestVectors/sha.txt\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateSHA2()\n{\n\tcout << \"\\nSHA validation suite running...\\n\\n\";\n\treturn RunTestDataFile(\"TestVectors/sha.txt\");\n}"
  },
  {
    "function_name": "ValidateSHA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "168-172",
    "snippet": "bool ValidateSHA()\n{\n\tcout << \"\\nSHA validation suite running...\\n\\n\";\n\treturn RunTestDataFile(\"TestVectors/sha.txt\");\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RunTestDataFile",
          "args": [
            "\"TestVectors/sha.txt\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateSHA()\n{\n\tcout << \"\\nSHA validation suite running...\\n\\n\";\n\treturn RunTestDataFile(\"TestVectors/sha.txt\");\n}"
  },
  {
    "function_name": "ValidateMD5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "149-166",
    "snippet": "bool ValidateMD5()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\xd4\\x1d\\x8c\\xd9\\x8f\\x00\\xb2\\x04\\xe9\\x80\\x09\\x98\\xec\\xf8\\x42\\x7e\"),\n\t\tHashTestTuple(\"a\", \"\\x0c\\xc1\\x75\\xb9\\xc0\\xf1\\xb6\\xa8\\x31\\xc3\\x99\\xe2\\x69\\x77\\x26\\x61\"),\n\t\tHashTestTuple(\"abc\", \"\\x90\\x01\\x50\\x98\\x3c\\xd2\\x4f\\xb0\\xd6\\x96\\x3f\\x7d\\x28\\xe1\\x7f\\x72\"),\n\t\tHashTestTuple(\"message digest\", \"\\xf9\\x6b\\x69\\x7d\\x7c\\xb7\\x93\\x8d\\x52\\x5a\\x2f\\x31\\xaa\\xf1\\x61\\xd0\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xc3\\xfc\\xd3\\xd7\\x61\\x92\\xe4\\x00\\x7d\\xfb\\x49\\x6c\\xca\\x67\\xe1\\x3b\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xd1\\x74\\xab\\x98\\xd2\\x77\\xd9\\xf5\\xa5\\x61\\x1c\\x2c\\x9f\\x41\\x9d\\x9f\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x57\\xed\\xf4\\xa2\\x2b\\xe3\\xc9\\x55\\xac\\x49\\xda\\x2e\\x21\\x07\\xb6\\x7a\")\n\t};\n\n\tWeak::MD5 md5;\n\n\tcout << \"\\nMD5 validation suite running...\\n\\n\";\n\treturn HashModuleTest(md5, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashModuleTest",
          "args": [
            "md5",
            "testSet",
            "sizeof(testSet)/sizeof(testSet[0])"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "HashModuleTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "45-70",
          "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"",
            "\"\\x57\\xed\\xf4\\xa2\\x2b\\xe3\\xc9\\x55\\xac\\x49\\xda\\x2e\\x21\\x07\\xb6\\x7a\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "HashTestTuple",
          "container": "HashTestTuple",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "34-35",
          "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateMD5()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\xd4\\x1d\\x8c\\xd9\\x8f\\x00\\xb2\\x04\\xe9\\x80\\x09\\x98\\xec\\xf8\\x42\\x7e\"),\n\t\tHashTestTuple(\"a\", \"\\x0c\\xc1\\x75\\xb9\\xc0\\xf1\\xb6\\xa8\\x31\\xc3\\x99\\xe2\\x69\\x77\\x26\\x61\"),\n\t\tHashTestTuple(\"abc\", \"\\x90\\x01\\x50\\x98\\x3c\\xd2\\x4f\\xb0\\xd6\\x96\\x3f\\x7d\\x28\\xe1\\x7f\\x72\"),\n\t\tHashTestTuple(\"message digest\", \"\\xf9\\x6b\\x69\\x7d\\x7c\\xb7\\x93\\x8d\\x52\\x5a\\x2f\\x31\\xaa\\xf1\\x61\\xd0\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xc3\\xfc\\xd3\\xd7\\x61\\x92\\xe4\\x00\\x7d\\xfb\\x49\\x6c\\xca\\x67\\xe1\\x3b\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xd1\\x74\\xab\\x98\\xd2\\x77\\xd9\\xf5\\xa5\\x61\\x1c\\x2c\\x9f\\x41\\x9d\\x9f\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x57\\xed\\xf4\\xa2\\x2b\\xe3\\xc9\\x55\\xac\\x49\\xda\\x2e\\x21\\x07\\xb6\\x7a\")\n\t};\n\n\tWeak::MD5 md5;\n\n\tcout << \"\\nMD5 validation suite running...\\n\\n\";\n\treturn HashModuleTest(md5, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}"
  },
  {
    "function_name": "ValidateMD4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "130-147",
    "snippet": "bool ValidateMD4()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x31\\xd6\\xcf\\xe0\\xd1\\x6a\\xe9\\x31\\xb7\\x3c\\x59\\xd7\\xe0\\xc0\\x89\\xc0\"),\n\t\tHashTestTuple(\"a\", \"\\xbd\\xe5\\x2c\\xb3\\x1d\\xe3\\x3e\\x46\\x24\\x5e\\x05\\xfb\\xdb\\xd6\\xfb\\x24\"),\n\t\tHashTestTuple(\"abc\", \"\\xa4\\x48\\x01\\x7a\\xaf\\x21\\xd8\\x52\\x5f\\xc1\\x0a\\xe8\\x7a\\xa6\\x72\\x9d\"),\n\t\tHashTestTuple(\"message digest\", \"\\xd9\\x13\\x0a\\x81\\x64\\x54\\x9f\\xe8\\x18\\x87\\x48\\x06\\xe1\\xc7\\x01\\x4b\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xd7\\x9e\\x1c\\x30\\x8a\\xa5\\xbb\\xcd\\xee\\xa8\\xed\\x63\\xdf\\x41\\x2d\\xa9\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\x04\\x3f\\x85\\x82\\xf2\\x41\\xdb\\x35\\x1c\\xe6\\x27\\xe1\\x53\\xe7\\xf0\\xe4\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\xe3\\x3b\\x4d\\xdc\\x9c\\x38\\xf2\\x19\\x9c\\x3e\\x7b\\x16\\x4f\\xcc\\x05\\x36\")\n\t};\n\n\tWeak::MD4 md4;\n\n\tcout << \"\\nMD4 validation suite running...\\n\\n\";\n\treturn HashModuleTest(md4, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashModuleTest",
          "args": [
            "md4",
            "testSet",
            "sizeof(testSet)/sizeof(testSet[0])"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "HashModuleTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "45-70",
          "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"",
            "\"\\xe3\\x3b\\x4d\\xdc\\x9c\\x38\\xf2\\x19\\x9c\\x3e\\x7b\\x16\\x4f\\xcc\\x05\\x36\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "HashTestTuple",
          "container": "HashTestTuple",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "34-35",
          "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateMD4()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x31\\xd6\\xcf\\xe0\\xd1\\x6a\\xe9\\x31\\xb7\\x3c\\x59\\xd7\\xe0\\xc0\\x89\\xc0\"),\n\t\tHashTestTuple(\"a\", \"\\xbd\\xe5\\x2c\\xb3\\x1d\\xe3\\x3e\\x46\\x24\\x5e\\x05\\xfb\\xdb\\xd6\\xfb\\x24\"),\n\t\tHashTestTuple(\"abc\", \"\\xa4\\x48\\x01\\x7a\\xaf\\x21\\xd8\\x52\\x5f\\xc1\\x0a\\xe8\\x7a\\xa6\\x72\\x9d\"),\n\t\tHashTestTuple(\"message digest\", \"\\xd9\\x13\\x0a\\x81\\x64\\x54\\x9f\\xe8\\x18\\x87\\x48\\x06\\xe1\\xc7\\x01\\x4b\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xd7\\x9e\\x1c\\x30\\x8a\\xa5\\xbb\\xcd\\xee\\xa8\\xed\\x63\\xdf\\x41\\x2d\\xa9\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\x04\\x3f\\x85\\x82\\xf2\\x41\\xdb\\x35\\x1c\\xe6\\x27\\xe1\\x53\\xe7\\xf0\\xe4\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\xe3\\x3b\\x4d\\xdc\\x9c\\x38\\xf2\\x19\\x9c\\x3e\\x7b\\x16\\x4f\\xcc\\x05\\x36\")\n\t};\n\n\tWeak::MD4 md4;\n\n\tcout << \"\\nMD4 validation suite running...\\n\\n\";\n\treturn HashModuleTest(md4, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}"
  },
  {
    "function_name": "ValidateMD2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "111-128",
    "snippet": "bool ValidateMD2()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x83\\x50\\xe5\\xa3\\xe2\\x4c\\x15\\x3d\\xf2\\x27\\x5c\\x9f\\x80\\x69\\x27\\x73\"),\n\t\tHashTestTuple(\"a\", \"\\x32\\xec\\x01\\xec\\x4a\\x6d\\xac\\x72\\xc0\\xab\\x96\\xfb\\x34\\xc0\\xb5\\xd1\"),\n\t\tHashTestTuple(\"abc\", \"\\xda\\x85\\x3b\\x0d\\x3f\\x88\\xd9\\x9b\\x30\\x28\\x3a\\x69\\xe6\\xde\\xd6\\xbb\"),\n\t\tHashTestTuple(\"message digest\", \"\\xab\\x4f\\x49\\x6b\\xfb\\x2a\\x53\\x0b\\x21\\x9f\\xf3\\x30\\x31\\xfe\\x06\\xb0\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\x4e\\x8d\\xdf\\xf3\\x65\\x02\\x92\\xab\\x5a\\x41\\x08\\xc3\\xaa\\x47\\x94\\x0b\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xda\\x33\\xde\\xf2\\xa4\\x2d\\xf1\\x39\\x75\\x35\\x28\\x46\\xc3\\x03\\x38\\xcd\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\xd5\\x97\\x6f\\x79\\xd8\\x3d\\x3a\\x0d\\xc9\\x80\\x6c\\x3c\\x66\\xf3\\xef\\xd8\")\n\t};\n\n\tWeak::MD2 md2;\n\n\tcout << \"\\nMD2 validation suite running...\\n\\n\";\n\treturn HashModuleTest(md2, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashModuleTest",
          "args": [
            "md2",
            "testSet",
            "sizeof(testSet)/sizeof(testSet[0])"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "HashModuleTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "45-70",
          "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"",
            "\"\\xd5\\x97\\x6f\\x79\\xd8\\x3d\\x3a\\x0d\\xc9\\x80\\x6c\\x3c\\x66\\xf3\\xef\\xd8\""
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "HashTestTuple",
          "container": "HashTestTuple",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "34-35",
          "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateMD2()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x83\\x50\\xe5\\xa3\\xe2\\x4c\\x15\\x3d\\xf2\\x27\\x5c\\x9f\\x80\\x69\\x27\\x73\"),\n\t\tHashTestTuple(\"a\", \"\\x32\\xec\\x01\\xec\\x4a\\x6d\\xac\\x72\\xc0\\xab\\x96\\xfb\\x34\\xc0\\xb5\\xd1\"),\n\t\tHashTestTuple(\"abc\", \"\\xda\\x85\\x3b\\x0d\\x3f\\x88\\xd9\\x9b\\x30\\x28\\x3a\\x69\\xe6\\xde\\xd6\\xbb\"),\n\t\tHashTestTuple(\"message digest\", \"\\xab\\x4f\\x49\\x6b\\xfb\\x2a\\x53\\x0b\\x21\\x9f\\xf3\\x30\\x31\\xfe\\x06\\xb0\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\x4e\\x8d\\xdf\\xf3\\x65\\x02\\x92\\xab\\x5a\\x41\\x08\\xc3\\xaa\\x47\\x94\\x0b\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xda\\x33\\xde\\xf2\\xa4\\x2d\\xf1\\x39\\x75\\x35\\x28\\x46\\xc3\\x03\\x38\\xcd\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\xd5\\x97\\x6f\\x79\\xd8\\x3d\\x3a\\x0d\\xc9\\x80\\x6c\\x3c\\x66\\xf3\\xef\\xd8\")\n\t};\n\n\tWeak::MD2 md2;\n\n\tcout << \"\\nMD2 validation suite running...\\n\\n\";\n\treturn HashModuleTest(md2, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}"
  },
  {
    "function_name": "ValidateAdler32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "92-109",
    "snippet": "bool ValidateAdler32()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x00\\x00\\x00\\x01\"),\n\t\tHashTestTuple(\"a\", \"\\x00\\x62\\x00\\x62\"),\n\t\tHashTestTuple(\"abc\", \"\\x02\\x4d\\x01\\x27\"),\n\t\tHashTestTuple(\"message digest\", \"\\x29\\x75\\x05\\x86\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\x90\\x86\\x0b\\x20\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\x8a\\xdb\\x15\\x0c\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\x15\\xd8\\x70\\xf9\", 15625)\n\t};\n\n\tAdler32 md;\n\n\tcout << \"\\nAdler-32 validation suite running...\\n\\n\";\n\treturn HashModuleTest(md, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashModuleTest",
          "args": [
            "md",
            "testSet",
            "sizeof(testSet)/sizeof(testSet[0])"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "HashModuleTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "45-70",
          "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
            "\"\\x15\\xd8\\x70\\xf9\"",
            "15625"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"",
            "\"\\x8a\\xdb\\x15\\x0c\""
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "HashTestTuple",
          "container": "HashTestTuple",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "34-35",
          "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateAdler32()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x00\\x00\\x00\\x01\"),\n\t\tHashTestTuple(\"a\", \"\\x00\\x62\\x00\\x62\"),\n\t\tHashTestTuple(\"abc\", \"\\x02\\x4d\\x01\\x27\"),\n\t\tHashTestTuple(\"message digest\", \"\\x29\\x75\\x05\\x86\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\x90\\x86\\x0b\\x20\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\x8a\\xdb\\x15\\x0c\"),\n\t\tHashTestTuple(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"\\x15\\xd8\\x70\\xf9\", 15625)\n\t};\n\n\tAdler32 md;\n\n\tcout << \"\\nAdler-32 validation suite running...\\n\\n\";\n\treturn HashModuleTest(md, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}"
  },
  {
    "function_name": "ValidateCRC32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "72-90",
    "snippet": "bool ValidateCRC32()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x00\\x00\\x00\\x00\"),\n\t\tHashTestTuple(\"a\", \"\\x43\\xbe\\xb7\\xe8\"),\n\t\tHashTestTuple(\"abc\", \"\\xc2\\x41\\x24\\x35\"),\n\t\tHashTestTuple(\"message digest\", \"\\x7f\\x9d\\x15\\x20\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xbd\\x50\\x27\\x4c\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xd2\\xe6\\xc2\\x1f\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x72\\x4a\\xa9\\x7c\"),\n\t\tHashTestTuple(\"123456789\", \"\\x26\\x39\\xf4\\xcb\")\n\t};\n\n\tCRC32 crc;\n\n\tcout << \"\\nCRC-32 validation suite running...\\n\\n\";\n\treturn HashModuleTest(crc, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HashModuleTest",
          "args": [
            "crc",
            "testSet",
            "sizeof(testSet)/sizeof(testSet[0])"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "HashModuleTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "45-70",
          "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashTestTuple",
          "args": [
            "\"123456789\"",
            "\"\\x26\\x39\\xf4\\xcb\""
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "HashTestTuple",
          "container": "HashTestTuple",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
          "lines": "34-35",
          "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
          "includes": [
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"files.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"pwdbased.h\"",
            "#include \"integer.h\"",
            "#include \"ttmac.h\"",
            "#include \"hmac.h\"",
            "#include \"ripemd.h\"",
            "#include \"tiger.h\"",
            "#include \"sha.h\"",
            "#include \"md5.h\"",
            "#include \"md4.h\"",
            "#include \"md2.h\"",
            "#include \"adler32.h\"",
            "#include \"crc.h\"",
            "#include \"smartptr.h\"",
            "#include \"validate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool ValidateCRC32()\n{\n\tHashTestTuple testSet[] = \n\t{\n\t\tHashTestTuple(\"\", \"\\x00\\x00\\x00\\x00\"),\n\t\tHashTestTuple(\"a\", \"\\x43\\xbe\\xb7\\xe8\"),\n\t\tHashTestTuple(\"abc\", \"\\xc2\\x41\\x24\\x35\"),\n\t\tHashTestTuple(\"message digest\", \"\\x7f\\x9d\\x15\\x20\"),\n\t\tHashTestTuple(\"abcdefghijklmnopqrstuvwxyz\", \"\\xbd\\x50\\x27\\x4c\"),\n\t\tHashTestTuple(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"\\xd2\\xe6\\xc2\\x1f\"),\n\t\tHashTestTuple(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", \"\\x72\\x4a\\xa9\\x7c\"),\n\t\tHashTestTuple(\"123456789\", \"\\x26\\x39\\xf4\\xcb\")\n\t};\n\n\tCRC32 crc;\n\n\tcout << \"\\nCRC-32 validation suite running...\\n\\n\";\n\treturn HashModuleTest(crc, testSet, sizeof(testSet)/sizeof(testSet[0]));\n}"
  },
  {
    "function_name": "HashModuleTest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "45-70",
    "snippet": "bool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md.DigestSize",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "digest",
            "testSet[i].output",
            "md.DigestSize()"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md.Final",
          "args": [
            "digest"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md.Update",
          "args": [
            "testSet[i].input",
            "testSet[i].inputLen"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nbool HashModuleTest(HashTransformation &md, const HashTestTuple *testSet, unsigned int testSetSize)\n{\n\tbool pass=true, fail;\n\tSecByteBlock digest(md.DigestSize());\n\n\tfor (unsigned int i=0; i<testSetSize; i++)\n\t{\n\t\tunsigned j;\n\n\t\tfor (j=0; j<testSet[i].repeatTimes; j++)\n\t\t\tmd.Update(testSet[i].input, testSet[i].inputLen);\n\t\tmd.Final(digest);\n\t\tfail = memcmp(digest, testSet[i].output, md.DigestSize()) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED   \" : \"passed   \");\n\t\tfor (j=0; j<md.DigestSize(); j++)\n\t\t\tcout << setw(2) << setfill('0') << hex << (int)digest[j];\n\t\tcout << \"   \\\"\" << (char *)testSet[i].input << '\\\"';\n\t\tif (testSet[i].repeatTimes != 1)\n\t\t\tcout << \" repeated \" << dec << testSet[i].repeatTimes << \" times\";\n\t\tcout  << endl;\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "HashTestTuple",
    "container": "HashTestTuple",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "37-38",
    "snippet": "HashTestTuple(const char *input, unsigned int inputLen, const char *output, unsigned int repeatTimes)\n\t\t: input((byte *)input), output((byte *)output), inputLen(inputLen), repeatTimes(repeatTimes) {}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, unsigned int inputLen, const char *output, unsigned int repeatTimes)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(inputLen), repeatTimes(repeatTimes) {}\n}"
  },
  {
    "function_name": "HashTestTuple",
    "container": "HashTestTuple",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat3.cpp",
    "lines": "34-35",
    "snippet": "HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n\t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}",
    "includes": [
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"files.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"pwdbased.h\"",
      "#include \"integer.h\"",
      "#include \"ttmac.h\"",
      "#include \"hmac.h\"",
      "#include \"ripemd.h\"",
      "#include \"tiger.h\"",
      "#include \"sha.h\"",
      "#include \"md5.h\"",
      "#include \"md4.h\"",
      "#include \"md2.h\"",
      "#include \"adler32.h\"",
      "#include \"crc.h\"",
      "#include \"smartptr.h\"",
      "#include \"validate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "input"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iomanip>\n#include <iostream>\n#include \"files.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"pwdbased.h\"\n#include \"integer.h\"\n#include \"ttmac.h\"\n#include \"hmac.h\"\n#include \"ripemd.h\"\n#include \"tiger.h\"\n#include \"sha.h\"\n#include \"md5.h\"\n#include \"md4.h\"\n#include \"md2.h\"\n#include \"adler32.h\"\n#include \"crc.h\"\n#include \"smartptr.h\"\n#include \"validate.h\"\n#include \"pch.h\"\n\nHashTestTuple {\n  HashTestTuple(const char *input, const char *output, unsigned int repeatTimes=1)\n  \t\t: input((byte *)input), output((byte *)output), inputLen(strlen(input)), repeatTimes(repeatTimes) {}\n}"
  }
]