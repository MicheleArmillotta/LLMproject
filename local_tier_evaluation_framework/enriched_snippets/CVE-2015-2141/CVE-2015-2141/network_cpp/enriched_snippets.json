[
  {
    "function_name": "DoFlush",
    "container": "NetworkSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "474-546",
    "snippet": "lword NetworkSink::DoFlush(unsigned long maxTime, size_t targetSize)\n{\n\tNetworkSender &sender = AccessSender();\n\n\tbool forever = maxTime == INFINITE_TIME;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tunsigned int totalFlushSize = 0;\n\n\twhile (true)\n\t{\n\t\tif (m_buffer.CurrentSize() <= targetSize)\n\t\t\tbreak;\n\t\t\n\t\tif (m_needSendResult)\n\t\t{\n\t\t\tif (sender.MustWaitForResult() &&\n\t\t\t\t!sender.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\tCallStack(\"NetworkSink::DoFlush() - wait send result\", 0)))\n\t\t\t\tbreak;\n\n\t\t\tunsigned int sendResult = sender.GetSendResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sent \" + IntToString(sendResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\tm_buffer.Skip(sendResult);\n\t\t\ttotalFlushSize += sendResult;\n\t\t\tm_needSendResult = false;\n\n\t\t\tif (!m_buffer.AnyRetrievable())\n\t\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n\t\tif (sender.MustWaitToSend() && !sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait send\", 0)))\n\t\t\tbreak;\n\n\t\tsize_t contiguousSize = 0;\n\t\tconst byte *block = m_buffer.Spy(contiguousSize);\n\n#if CRYPTOPP_TRACE_NETWORK\n\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sending \" + IntToString(contiguousSize) + \" bytes\\n\").c_str());\n#endif\n\t\tsender.Send(block, contiguousSize);\n\t\tm_needSendResult = true;\n\n\t\tif (maxTime > 0 && timeOut == 0)\n\t\t\tbreak;\t// once time limit is reached, return even if there is more data waiting\n\t}\n\n\tm_byteCountSinceLastTimerReset += totalFlushSize;\n\tComputeCurrentSpeed();\n\t\n\tif (m_buffer.IsEmpty() && !m_needSendResult)\n\t{\n\t\tif (m_eofState == EOF_PENDING_SEND)\n\t\t{\n\t\t\tsender.SendEof();\n\t\t\tm_eofState = sender.MustWaitForEof() ? EOF_PENDING_DELIVERY : EOF_DONE;\n\t\t}\n\n\t\twhile (m_eofState == EOF_PENDING_DELIVERY)\n\t\t{\n\t\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n\t\t\tif (!sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait EOF\", 0)))\n\t\t\t\tbreak;\n\n\t\t\tif (sender.EofSent())\n\t\t\t\tm_eofState = EOF_DONE;\n\t\t}\n\t}\n\n\treturn totalFlushSize;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_TRACE_NETWORK 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sender.EofSent",
          "args": [],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "EofSent",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "439-452",
          "snippet": "bool SocketSender::EofSent()\n{\n\tif (m_resultPending)\n\t{\n\t\tWSANETWORKEVENTS events;\n\t\tm_s.CheckAndHandleError_int(\"WSAEnumNetworkEvents\", WSAEnumNetworkEvents(m_s, m_event, &events));\n\t\tif ((events.lNetworkEvents & FD_CLOSE) != FD_CLOSE)\n\t\t\tthrow Socket::Err(m_s, \"WSAEnumNetworkEvents (FD_CLOSE not present)\", E_FAIL);\n\t\tif (events.iErrorCode[FD_CLOSE_BIT] != 0)\n\t\t\tthrow Socket::Err(m_s, \"FD_CLOSE (via WSAEnumNetworkEvents)\", events.iErrorCode[FD_CLOSE_BIT]);\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult != 0;\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocketSender {\n  bool SocketSender::EofSent()\n  {\n  \tif (m_resultPending)\n  \t{\n  \t\tWSANETWORKEVENTS events;\n  \t\tm_s.CheckAndHandleError_int(\"WSAEnumNetworkEvents\", WSAEnumNetworkEvents(m_s, m_event, &events));\n  \t\tif ((events.lNetworkEvents & FD_CLOSE) != FD_CLOSE)\n  \t\t\tthrow Socket::Err(m_s, \"WSAEnumNetworkEvents (FD_CLOSE not present)\", E_FAIL);\n  \t\tif (events.iErrorCode[FD_CLOSE_BIT] != 0)\n  \t\t\tthrow Socket::Err(m_s, \"FD_CLOSE (via WSAEnumNetworkEvents)\", events.iErrorCode[FD_CLOSE_BIT]);\n  \t\tm_resultPending = false;\n  \t}\n  \treturn m_lastResult != 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sender.Wait",
          "args": [
            "timeOut",
            "CallStack(\"NetworkSink::DoFlush() - wait EOF\", 0)"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "Waitable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "388-393",
          "snippet": "bool Waitable::Wait(unsigned long milliseconds, CallStack const& callStack)\n{\n\tWaitObjectContainer container;\n\tGetWaitObjects(container, callStack);\t// reduce clutter by not adding this func to stack\n\treturn container.Wait(milliseconds);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitable {\n  bool Waitable::Wait(unsigned long milliseconds, CallStack const& callStack)\n  {\n  \tWaitObjectContainer container;\n  \tGetWaitObjects(container, callStack);\t// reduce clutter by not adding this func to stack\n  \treturn container.Wait(milliseconds);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NetworkSink::DoFlush() - wait EOF\"",
            "0"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "maxTime",
            "timer.ElapsedTime()"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTime",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "54-59",
          "snippet": "unsigned long TimerBase::ElapsedTime()\n{\n\tdouble elapsed = ElapsedTimeAsDouble();\n\tassert(elapsed <= ULONG_MAX);\n\treturn (unsigned long)elapsed;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  unsigned long TimerBase::ElapsedTime()\n  {\n  \tdouble elapsed = ElapsedTimeAsDouble();\n  \tassert(elapsed <= ULONG_MAX);\n  \treturn (unsigned long)elapsed;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sender.MustWaitForEof",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitForEof",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "168-168",
          "snippet": "bool MustWaitForEof() { return true; }",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSender {\n  bool MustWaitForEof() { return true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sender.SendEof",
          "args": [],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "SendEof",
          "container": "SocketSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "213-213",
          "snippet": "void SendEof() {ShutDown(SD_SEND);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSink {\n  void SendEof() {ShutDown(SD_SEND);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.IsEmpty",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "IsEmpty",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "198-201",
          "snippet": "bool ByteQueue::IsEmpty() const\n{\n\treturn m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  bool ByteQueue::IsEmpty() const\n  {\n  \treturn m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeCurrentSpeed",
          "args": [],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeCurrentSpeed",
          "container": "NetworkSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "382-393",
          "snippet": "float NetworkSink::ComputeCurrentSpeed()\n{\n\tif (m_speedTimer.ElapsedTime() > 1000)\n\t{\n\t\tm_currentSpeed = m_byteCountSinceLastTimerReset * 1000 / m_speedTimer.ElapsedTime();\n\t\tm_maxObservedSpeed = STDMAX(m_currentSpeed, m_maxObservedSpeed * 0.98f);\n\t\tm_byteCountSinceLastTimerReset = 0;\n\t\tm_speedTimer.StartTimer();\n//\t\tOutputDebugString((\"max speed: \" + IntToString((int)m_maxObservedSpeed) + \" current speed: \" + IntToString((int)m_currentSpeed) + \"\\n\").c_str());\n\t}\n\treturn m_currentSpeed;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink {\n  float NetworkSink::ComputeCurrentSpeed()\n  {\n  \tif (m_speedTimer.ElapsedTime() > 1000)\n  \t{\n  \t\tm_currentSpeed = m_byteCountSinceLastTimerReset * 1000 / m_speedTimer.ElapsedTime();\n  \t\tm_maxObservedSpeed = STDMAX(m_currentSpeed, m_maxObservedSpeed * 0.98f);\n  \t\tm_byteCountSinceLastTimerReset = 0;\n  \t\tm_speedTimer.StartTimer();\n  //\t\tOutputDebugString((\"max speed: \" + IntToString((int)m_maxObservedSpeed) + \" current speed: \" + IntToString((int)m_currentSpeed) + \"\\n\").c_str());\n  \t}\n  \treturn m_currentSpeed;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sender.Send",
          "args": [
            "block",
            "contiguousSize"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "Send",
          "container": "WindowsPipeSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "164-181",
          "snippet": "void WindowsPipeSender::Send(const byte* buf, size_t bufLen)\n{\n\tDWORD written = 0;\n\tHANDLE h = GetHandle();\n\t// don't queue too much at once, or we might use up non-paged memory\n\tif (WriteFile(h, buf, UnsignedMin((DWORD)128*1024, bufLen), &written, &m_overlapped))\n\t{\n\t\tm_resultPending = false;\n\t\tm_lastResult = written;\n\t}\n\telse\n\t{\n\t\tif (GetLastError() != ERROR_IO_PENDING)\n\t\t\tCheckAndHandleError(\"WriteFile\", false);\n\n\t\tm_resultPending = true;\n\t}\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeSender {\n  void WindowsPipeSender::Send(const byte* buf, size_t bufLen)\n  {\n  \tDWORD written = 0;\n  \tHANDLE h = GetHandle();\n  \t// don't queue too much at once, or we might use up non-paged memory\n  \tif (WriteFile(h, buf, UnsignedMin((DWORD)128*1024, bufLen), &written, &m_overlapped))\n  \t{\n  \t\tm_resultPending = false;\n  \t\tm_lastResult = written;\n  \t}\n  \telse\n  \t{\n  \t\tif (GetLastError() != ERROR_IO_PENDING)\n  \t\t\tCheckAndHandleError(\"WriteFile\", false);\n  \n  \t\tm_resultPending = true;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Sending \" + IntToString(contiguousSize) + \" bytes\\n\").c_str()"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "contiguousSize"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.Spy",
          "args": [
            "contiguousSize"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.MustWaitToSend",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitToSend",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "164-164",
          "snippet": "bool MustWaitToSend() {return true;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSender {\n  bool MustWaitToSend() {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.AnyRetrievable",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "AnyRetrievable",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "394-403",
          "snippet": "bool BufferedTransformation::AnyRetrievable() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyRetrievable();\n\telse\n\t{\n\t\tbyte b;\n\t\treturn Peek(b) != 0;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyRetrievable() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyRetrievable();\n  \telse\n  \t{\n  \t\tbyte b;\n  \t\treturn Peek(b) != 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.Skip",
          "args": [
            "sendResult"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "Skip",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "168-179",
          "snippet": "lword FileStore::Skip(lword skipMax)\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tlword oldPos = m_stream->tellg();\n\tstd::istream::off_type offset;\n\tif (!SafeConvert(skipMax, offset))\n\t\tthrow InvalidArgument(\"FileStore: maximum seek offset exceeded\");\n\tm_stream->seekg(offset, ios::cur);\n\treturn (lword)m_stream->tellg() - oldPos;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::Skip(lword skipMax)\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tlword oldPos = m_stream->tellg();\n  \tstd::istream::off_type offset;\n  \tif (!SafeConvert(skipMax, offset))\n  \t\tthrow InvalidArgument(\"FileStore: maximum seek offset exceeded\");\n  \tm_stream->seekg(offset, ios::cur);\n  \treturn (lword)m_stream->tellg() - oldPos;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Sent \" + IntToString(sendResult) + \" bytes\\n\").c_str()"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.GetSendResult",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "GetSendResult",
          "container": "WindowsPipeSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "191-201",
          "snippet": "unsigned int WindowsPipeSender::GetSendResult()\n{\n\tif (m_resultPending)\n\t{\n\t\tHANDLE h = GetHandle();\n\t\tBOOL result = GetOverlappedResult(h, &m_overlapped, &m_lastResult, false);\n\t\tCheckAndHandleError(\"GetOverlappedResult\", result);\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeSender {\n  unsigned int WindowsPipeSender::GetSendResult()\n  {\n  \tif (m_resultPending)\n  \t{\n  \t\tHANDLE h = GetHandle();\n  \t\tBOOL result = GetOverlappedResult(h, &m_overlapped, &m_lastResult, false);\n  \t\tCheckAndHandleError(\"GetOverlappedResult\", result);\n  \t\tm_resultPending = false;\n  \t}\n  \treturn m_lastResult;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sender.MustWaitForResult",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitForResult",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "167-167",
          "snippet": "bool MustWaitForResult() {return true;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSender {\n  bool MustWaitForResult() {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.CurrentSize",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentSize",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "188-196",
          "snippet": "lword ByteQueue::CurrentSize() const\n{\n\tlword size=0;\n\n\tfor (ByteQueueNode *current=m_head; current; current=current->next)\n\t\tsize += current->CurrentSize();\n\n\treturn size + m_lazyLength;\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  lword ByteQueue::CurrentSize() const\n  {\n  \tlword size=0;\n  \n  \tfor (ByteQueueNode *current=m_head; current; current=current->next)\n  \t\tsize += current->CurrentSize();\n  \n  \treturn size + m_lazyLength;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\n#define CRYPTOPP_TRACE_NETWORK 0\n\nNetworkSink {\n  lword NetworkSink::DoFlush(unsigned long maxTime, size_t targetSize)\n  {\n  \tNetworkSender &sender = AccessSender();\n  \n  \tbool forever = maxTime == INFINITE_TIME;\n  \tTimer timer(Timer::MILLISECONDS, forever);\n  \tunsigned int totalFlushSize = 0;\n  \n  \twhile (true)\n  \t{\n  \t\tif (m_buffer.CurrentSize() <= targetSize)\n  \t\t\tbreak;\n  \t\t\n  \t\tif (m_needSendResult)\n  \t\t{\n  \t\t\tif (sender.MustWaitForResult() &&\n  \t\t\t\t!sender.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n  \t\t\t\t\tCallStack(\"NetworkSink::DoFlush() - wait send result\", 0)))\n  \t\t\t\tbreak;\n  \n  \t\t\tunsigned int sendResult = sender.GetSendResult();\n  #if CRYPTOPP_TRACE_NETWORK\n  \t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sent \" + IntToString(sendResult) + \" bytes\\n\").c_str());\n  #endif\n  \t\t\tm_buffer.Skip(sendResult);\n  \t\t\ttotalFlushSize += sendResult;\n  \t\t\tm_needSendResult = false;\n  \n  \t\t\tif (!m_buffer.AnyRetrievable())\n  \t\t\t\tbreak;\n  \t\t}\n  \n  \t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n  \t\tif (sender.MustWaitToSend() && !sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait send\", 0)))\n  \t\t\tbreak;\n  \n  \t\tsize_t contiguousSize = 0;\n  \t\tconst byte *block = m_buffer.Spy(contiguousSize);\n  \n  #if CRYPTOPP_TRACE_NETWORK\n  \t\tOutputDebugString((IntToString((unsigned int)this) + \": Sending \" + IntToString(contiguousSize) + \" bytes\\n\").c_str());\n  #endif\n  \t\tsender.Send(block, contiguousSize);\n  \t\tm_needSendResult = true;\n  \n  \t\tif (maxTime > 0 && timeOut == 0)\n  \t\t\tbreak;\t// once time limit is reached, return even if there is more data waiting\n  \t}\n  \n  \tm_byteCountSinceLastTimerReset += totalFlushSize;\n  \tComputeCurrentSpeed();\n  \t\n  \tif (m_buffer.IsEmpty() && !m_needSendResult)\n  \t{\n  \t\tif (m_eofState == EOF_PENDING_SEND)\n  \t\t{\n  \t\t\tsender.SendEof();\n  \t\t\tm_eofState = sender.MustWaitForEof() ? EOF_PENDING_DELIVERY : EOF_DONE;\n  \t\t}\n  \n  \t\twhile (m_eofState == EOF_PENDING_DELIVERY)\n  \t\t{\n  \t\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n  \t\t\tif (!sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait EOF\", 0)))\n  \t\t\t\tbreak;\n  \n  \t\t\tif (sender.EofSent())\n  \t\t\t\tm_eofState = EOF_DONE;\n  \t\t}\n  \t}\n  \n  \treturn totalFlushSize;\n  }\n}"
  },
  {
    "function_name": "Put2",
    "container": "NetworkSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "418-472",
    "snippet": "size_t NetworkSink::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\tif (m_eofState == EOF_DONE)\n\t{\n\t\tif (length || messageEnd)\n\t\t\tthrow Exception(Exception::OTHER_ERROR, \"NetworkSink::Put2() being called after EOF had been sent\");\n\n\t\treturn 0;\n\t}\n\n\tif (m_eofState > EOF_NONE)\n\t\tgoto EofSite;\n\n\t{\n\t\tif (m_skipBytes)\n\t\t{\n\t\t\tassert(length >= m_skipBytes);\n\t\t\tinString += m_skipBytes;\n\t\t\tlength -= m_skipBytes;\n\t\t}\n\n\t\tm_buffer.Put(inString, length);\n\n\t\tif (!blocking || m_buffer.CurrentSize() > m_autoFlushBound)\n\t\t\tTimedFlush(0, 0);\n\n\t\tsize_t targetSize = messageEnd ? 0 : m_maxBufferSize;\n\t\tif (blocking)\n\t\t\tTimedFlush(INFINITE_TIME, targetSize);\n\n\t\tif (m_buffer.CurrentSize() > targetSize)\n\t\t{\n\t\t\tassert(!blocking);\n\t\t\tm_wasBlocked = true;\n\t\t\tm_skipBytes += length;\n\t\t\tsize_t blockedBytes = UnsignedMin(length, m_buffer.CurrentSize() - targetSize);\n\t\t\treturn STDMAX<size_t>(blockedBytes, 1);\n\t\t}\n\n\t\tm_wasBlocked = false;\n\t\tm_skipBytes = 0;\n\t}\n\n\tif (messageEnd)\n\t{\n\t\tm_eofState = EOF_PENDING_SEND;\n\n\tEofSite:\n\t\tTimedFlush(blocking ? INFINITE_TIME : 0, 0);\n\t\tif (m_eofState != EOF_DONE)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TimedFlush",
          "args": [
            "blocking ? INFINITE_TIME : 0",
            "0"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "TimedFlush",
          "container": "NonblockingSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "162-218",
          "snippet": "lword NonblockingSink::TimedFlush(unsigned long maxTime, size_t targetSize)\n{\n\tm_blockedBySpeedLimit = false;\n\n\tsize_t curBufSize = GetCurrentBufferSize();\n\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n\t\treturn 0;\n\n\tif (!GetMaxBytesPerSecond())\n\t\treturn DoFlush(maxTime, targetSize);\n\n\tbool forever = (maxTime == INFINITE_TIME);\n\tunsigned long timeToGo = maxTime;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tlword totalFlushed = 0;\n\n\ttimer.StartTimer();\n\n\twhile (true)\n\t{\t\n\t\tsize_t flushSize = UnsignedMin(curBufSize - targetSize, ComputeCurrentTransceiveLimit());\n\t\tif (flushSize || EofPending())\n\t\t{\n\t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tsize_t ret = (size_t)DoFlush(timeToGo, curBufSize - flushSize);\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\tNoteTransceive(ret);\n\t\t\t\tcurBufSize -= ret;\n\t\t\t\ttotalFlushed += ret;\n\t\t\t}\n\t\t}\n\n\t\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n\t\t\tbreak;\n\n\t\tif (!forever)\n\t\t{\n\t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tif (!timeToGo)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdouble waitTime = TimeToNextTransceive();\n\t\tif (!forever && waitTime > timeToGo)\n\t\t{\n\t\t\tm_blockedBySpeedLimit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tWaitObjectContainer container;\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSink::TimedFlush() - speed limit\", 0));\n\t\tcontainer.Wait((unsigned long)waitTime);\n\t}\n\n\treturn totalFlushed;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNonblockingSink {\n  lword NonblockingSink::TimedFlush(unsigned long maxTime, size_t targetSize)\n  {\n  \tm_blockedBySpeedLimit = false;\n  \n  \tsize_t curBufSize = GetCurrentBufferSize();\n  \tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n  \t\treturn 0;\n  \n  \tif (!GetMaxBytesPerSecond())\n  \t\treturn DoFlush(maxTime, targetSize);\n  \n  \tbool forever = (maxTime == INFINITE_TIME);\n  \tunsigned long timeToGo = maxTime;\n  \tTimer timer(Timer::MILLISECONDS, forever);\n  \tlword totalFlushed = 0;\n  \n  \ttimer.StartTimer();\n  \n  \twhile (true)\n  \t{\t\n  \t\tsize_t flushSize = UnsignedMin(curBufSize - targetSize, ComputeCurrentTransceiveLimit());\n  \t\tif (flushSize || EofPending())\n  \t\t{\n  \t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n  \t\t\tsize_t ret = (size_t)DoFlush(timeToGo, curBufSize - flushSize);\n  \t\t\tif (ret)\n  \t\t\t{\n  \t\t\t\tNoteTransceive(ret);\n  \t\t\t\tcurBufSize -= ret;\n  \t\t\t\ttotalFlushed += ret;\n  \t\t\t}\n  \t\t}\n  \n  \t\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n  \t\t\tbreak;\n  \n  \t\tif (!forever)\n  \t\t{\n  \t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n  \t\t\tif (!timeToGo)\n  \t\t\t\tbreak;\n  \t\t}\n  \n  \t\tdouble waitTime = TimeToNextTransceive();\n  \t\tif (!forever && waitTime > timeToGo)\n  \t\t{\n  \t\t\tm_blockedBySpeedLimit = true;\n  \t\t\tbreak;\n  \t\t}\n  \n  \t\tWaitObjectContainer container;\n  \t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSink::TimedFlush() - speed limit\", 0));\n  \t\tcontainer.Wait((unsigned long)waitTime);\n  \t}\n  \n  \treturn totalFlushed;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMAX<size_t>",
          "args": [
            "blockedBytes",
            "1"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "length",
            "m_buffer.CurrentSize() - targetSize"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.CurrentSize",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentSize",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "188-196",
          "snippet": "lword ByteQueue::CurrentSize() const\n{\n\tlword size=0;\n\n\tfor (ByteQueueNode *current=m_head; current; current=current->next)\n\t\tsize += current->CurrentSize();\n\n\treturn size + m_lazyLength;\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  lword ByteQueue::CurrentSize() const\n  {\n  \tlword size=0;\n  \n  \tfor (ByteQueueNode *current=m_head; current; current=current->next)\n  \t\tsize += current->CurrentSize();\n  \n  \treturn size + m_lazyLength;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!blocking"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.Put",
          "args": [
            "inString",
            "length"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length >= m_skipBytes"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"NetworkSink::Put2() being called after EOF had been sent\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink {\n  size_t NetworkSink::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n  {\n  \tif (m_eofState == EOF_DONE)\n  \t{\n  \t\tif (length || messageEnd)\n  \t\t\tthrow Exception(Exception::OTHER_ERROR, \"NetworkSink::Put2() being called after EOF had been sent\");\n  \n  \t\treturn 0;\n  \t}\n  \n  \tif (m_eofState > EOF_NONE)\n  \t\tgoto EofSite;\n  \n  \t{\n  \t\tif (m_skipBytes)\n  \t\t{\n  \t\t\tassert(length >= m_skipBytes);\n  \t\t\tinString += m_skipBytes;\n  \t\t\tlength -= m_skipBytes;\n  \t\t}\n  \n  \t\tm_buffer.Put(inString, length);\n  \n  \t\tif (!blocking || m_buffer.CurrentSize() > m_autoFlushBound)\n  \t\t\tTimedFlush(0, 0);\n  \n  \t\tsize_t targetSize = messageEnd ? 0 : m_maxBufferSize;\n  \t\tif (blocking)\n  \t\t\tTimedFlush(INFINITE_TIME, targetSize);\n  \n  \t\tif (m_buffer.CurrentSize() > targetSize)\n  \t\t{\n  \t\t\tassert(!blocking);\n  \t\t\tm_wasBlocked = true;\n  \t\t\tm_skipBytes += length;\n  \t\t\tsize_t blockedBytes = UnsignedMin(length, m_buffer.CurrentSize() - targetSize);\n  \t\t\treturn STDMAX<size_t>(blockedBytes, 1);\n  \t\t}\n  \n  \t\tm_wasBlocked = false;\n  \t\tm_skipBytes = 0;\n  \t}\n  \n  \tif (messageEnd)\n  \t{\n  \t\tm_eofState = EOF_PENDING_SEND;\n  \n  \tEofSite:\n  \t\tTimedFlush(blocking ? INFINITE_TIME : 0, 0);\n  \t\tif (m_eofState != EOF_DONE)\n  \t\t\treturn 1;\n  \t}\n  \n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "GetWaitObjects",
    "container": "NetworkSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "406-416",
    "snippet": "void NetworkSink::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (BlockedBySpeedLimit())\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - speed limit\", &callStack));\n\telse if (m_wasBlocked)\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - was blocked\", &callStack));\n\telse if (!m_buffer.IsEmpty())\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - buffer not empty\", &callStack));\n\telse if (EofPending())\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - EOF pending\", &callStack));\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [
            "container",
            "CallStack(\"NetworkSink::GetWaitObjects() - EOF pending\", &callStack)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NetworkSink::GetWaitObjects() - EOF pending\"",
            "&callStack"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [
            "container",
            "CallStack(\"NetworkSink::GetWaitObjects() - buffer not empty\", &callStack)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.IsEmpty",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "IsEmpty",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "198-201",
          "snippet": "bool ByteQueue::IsEmpty() const\n{\n\treturn m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  bool ByteQueue::IsEmpty() const\n  {\n  \treturn m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [
            "container",
            "CallStack(\"NetworkSink::GetWaitObjects() - was blocked\", &callStack)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetWaitObjects",
          "args": [
            "container",
            "CallStack(\"NetworkSink::GetWaitObjects() - speed limit\", &callStack)"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "GetWaitObjects",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "67-72",
          "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n  {\n  \tdouble nextTransceiveTime = TimeToNextTransceive();\n  \tif (nextTransceiveTime)\n  \t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockedBySpeedLimit",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "BlockedBySpeedLimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "145-145",
          "snippet": "bool BlockedBySpeedLimit() const { return m_blockedBySpeedLimit; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nbool BlockedBySpeedLimit() const { return m_blockedBySpeedLimit; }"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink {\n  void NetworkSink::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n  {\n  \tif (BlockedBySpeedLimit())\n  \t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - speed limit\", &callStack));\n  \telse if (m_wasBlocked)\n  \t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - was blocked\", &callStack));\n  \telse if (!m_buffer.IsEmpty())\n  \t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - buffer not empty\", &callStack));\n  \telse if (EofPending())\n  \t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - EOF pending\", &callStack));\n  }\n}"
  },
  {
    "function_name": "GetMaxWaitObjectCount",
    "container": "NetworkSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "401-404",
    "snippet": "unsigned int NetworkSink::GetMaxWaitObjectCount() const\n{\n\treturn LimitedBandwidth::GetMaxWaitObjectCount() + GetSender().GetMaxWaitObjectCount();\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSender",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSender",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetMaxWaitObjectCount",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxWaitObjectCount",
          "container": "NetworkSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "401-404",
          "snippet": "unsigned int NetworkSink::GetMaxWaitObjectCount() const\n{\n\treturn LimitedBandwidth::GetMaxWaitObjectCount() + GetSender().GetMaxWaitObjectCount();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink {\n  unsigned int NetworkSink::GetMaxWaitObjectCount() const\n  {\n  \treturn LimitedBandwidth::GetMaxWaitObjectCount() + GetSender().GetMaxWaitObjectCount();\n  }\n}"
  },
  {
    "function_name": "GetMaxObservedSpeed",
    "container": "NetworkSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "395-399",
    "snippet": "float NetworkSink::GetMaxObservedSpeed() const\n{\n\tlword m = GetMaxBytesPerSecond();\n\treturn m ? STDMIN(m_maxObservedSpeed, float(CRYPTOPP_VC6_INT64 m)) : m_maxObservedSpeed;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "m_maxObservedSpeed",
            "float(CRYPTOPP_VC6_INT64 m)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float",
          "args": [
            "CRYPTOPP_VC6_INT64m"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxBytesPerSecond",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxBytesPerSecond",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "23-24",
          "snippet": "lword GetMaxBytesPerSecond() const\n\t\t{ return m_maxBytesPerSecond; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nLimitedBandwidth {\n  lword GetMaxBytesPerSecond() const\n  \t\t{ return m_maxBytesPerSecond; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink {\n  float NetworkSink::GetMaxObservedSpeed() const\n  {\n  \tlword m = GetMaxBytesPerSecond();\n  \treturn m ? STDMIN(m_maxObservedSpeed, float(CRYPTOPP_VC6_INT64 m)) : m_maxObservedSpeed;\n  }\n}"
  },
  {
    "function_name": "ComputeCurrentSpeed",
    "container": "NetworkSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "382-393",
    "snippet": "float NetworkSink::ComputeCurrentSpeed()\n{\n\tif (m_speedTimer.ElapsedTime() > 1000)\n\t{\n\t\tm_currentSpeed = m_byteCountSinceLastTimerReset * 1000 / m_speedTimer.ElapsedTime();\n\t\tm_maxObservedSpeed = STDMAX(m_currentSpeed, m_maxObservedSpeed * 0.98f);\n\t\tm_byteCountSinceLastTimerReset = 0;\n\t\tm_speedTimer.StartTimer();\n//\t\tOutputDebugString((\"max speed: \" + IntToString((int)m_maxObservedSpeed) + \" current speed: \" + IntToString((int)m_currentSpeed) + \"\\n\").c_str());\n\t}\n\treturn m_currentSpeed;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_speedTimer.StartTimer",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "StartTimer",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "31-35",
          "snippet": "void TimerBase::StartTimer()\n{\n\tm_last = m_start = GetCurrentTimerValue();\n\tm_started = true;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  void TimerBase::StartTimer()\n  {\n  \tm_last = m_start = GetCurrentTimerValue();\n  \tm_started = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMAX",
          "args": [
            "m_currentSpeed",
            "m_maxObservedSpeed * 0.98f"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_speedTimer.ElapsedTime",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTime",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "54-59",
          "snippet": "unsigned long TimerBase::ElapsedTime()\n{\n\tdouble elapsed = ElapsedTimeAsDouble();\n\tassert(elapsed <= ULONG_MAX);\n\treturn (unsigned long)elapsed;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  unsigned long TimerBase::ElapsedTime()\n  {\n  \tdouble elapsed = ElapsedTimeAsDouble();\n  \tassert(elapsed <= ULONG_MAX);\n  \treturn (unsigned long)elapsed;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink {\n  float NetworkSink::ComputeCurrentSpeed()\n  {\n  \tif (m_speedTimer.ElapsedTime() > 1000)\n  \t{\n  \t\tm_currentSpeed = m_byteCountSinceLastTimerReset * 1000 / m_speedTimer.ElapsedTime();\n  \t\tm_maxObservedSpeed = STDMAX(m_currentSpeed, m_maxObservedSpeed * 0.98f);\n  \t\tm_byteCountSinceLastTimerReset = 0;\n  \t\tm_speedTimer.StartTimer();\n  //\t\tOutputDebugString((\"max speed: \" + IntToString((int)m_maxObservedSpeed) + \" current speed: \" + IntToString((int)m_currentSpeed) + \"\\n\").c_str());\n  \t}\n  \treturn m_currentSpeed;\n  }\n}"
  },
  {
    "function_name": "NetworkSink",
    "container": "NetworkSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "373-380",
    "snippet": "NetworkSink::NetworkSink(unsigned int maxBufferSize, unsigned int autoFlushBound)\n\t: m_maxBufferSize(maxBufferSize), m_autoFlushBound(autoFlushBound)\n\t, m_needSendResult(false), m_wasBlocked(false), m_eofState(EOF_NONE)\n\t, m_buffer(STDMIN(16U*1024U+256, maxBufferSize)), m_skipBytes(0) \n\t, m_speedTimer(Timer::MILLISECONDS), m_byteCountSinceLastTimerReset(0)\n\t, m_currentSpeed(0), m_maxObservedSpeed(0)\n{\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "16U*1024U+256",
            "maxBufferSize"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink {\n  NetworkSink::NetworkSink(unsigned int maxBufferSize, unsigned int autoFlushBound)\n  \t: m_maxBufferSize(maxBufferSize), m_autoFlushBound(autoFlushBound)\n  \t, m_needSendResult(false), m_wasBlocked(false), m_eofState(EOF_NONE)\n  \t, m_buffer(STDMIN(16U*1024U+256, maxBufferSize)), m_skipBytes(0) \n  \t, m_speedTimer(Timer::MILLISECONDS), m_byteCountSinceLastTimerReset(0)\n  \t, m_currentSpeed(0), m_maxObservedSpeed(0)\n  {\n  }\n}"
  },
  {
    "function_name": "DoPump",
    "container": "NetworkSource",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "257-369",
    "snippet": "size_t NetworkSource::DoPump(lword &byteCount, bool blockingOutput, unsigned long maxTime, bool checkDelimiter, byte delimiter)\n{\n\tNetworkReceiver &receiver = AccessReceiver();\n\n\tlword maxSize = byteCount;\n\tbyteCount = 0;\n\tbool forever = maxTime == INFINITE_TIME;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tBufferedTransformation *t = AttachedTransformation();\n\n\tif (m_outputBlocked)\n\t\tgoto DoOutput;\n\n\twhile (true)\n\t{\n\t\tif (m_dataBegin == m_dataEnd)\n\t\t{\n\t\t\tif (receiver.EofReceived())\n\t\t\t\tbreak;\n\n\t\t\tif (m_waitingForResult)\n\t\t\t{\n\t\t\t\tif (receiver.MustWaitForResult() &&\n\t\t\t\t\t!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive result\", 0)))\n\t\t\t\t\tbreak;\n\n\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\tm_dataEnd += recvResult;\n\t\t\t\tm_waitingForResult = false;\n\n\t\t\t\tif (!receiver.MustWaitToReceive() && !receiver.EofReceived() && m_dataEnd != m_buf.size())\n\t\t\t\t\tgoto ReceiveNoWait;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_dataEnd = m_dataBegin = 0;\n\n\t\t\t\tif (receiver.MustWaitToReceive())\n\t\t\t\t{\n\t\t\t\t\tif (!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive\", 0)))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\treceiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd);\n\t\t\t\t\tm_waitingForResult = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\nReceiveNoWait:\n\t\t\t\t\tm_waitingForResult = true;\n\t\t\t\t\t// call Receive repeatedly as long as data is immediately available,\n\t\t\t\t\t// because some receivers tend to return data in small pieces\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Receiving \" + IntToString(m_buf.size()-m_dataEnd) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\t\twhile (receiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd))\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\t\t\tm_dataEnd += recvResult;\n\t\t\t\t\t\tif (receiver.EofReceived() || m_dataEnd > m_buf.size() /2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_waitingForResult = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_putSize = UnsignedMin(m_dataEnd - m_dataBegin, maxSize - byteCount);\n\n\t\t\tif (checkDelimiter)\n\t\t\t\tm_putSize = std::find(m_buf+m_dataBegin, m_buf+m_dataBegin+m_putSize, delimiter) - (m_buf+m_dataBegin);\n\nDoOutput:\n\t\t\tsize_t result = t->PutModifiable2(m_buf+m_dataBegin, m_putSize, 0, forever || blockingOutput);\n\t\t\tif (result)\n\t\t\t{\n\t\t\t\tif (t->Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait attachment\", 0)))\n\t\t\t\t\tgoto DoOutput;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_outputBlocked = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_outputBlocked = false;\n\n\t\t\tbyteCount += m_putSize;\n\t\t\tm_dataBegin += m_putSize;\n\t\t\tif (checkDelimiter && m_dataBegin < m_dataEnd && m_buf[m_dataBegin] == delimiter)\n\t\t\t\tbreak;\n\t\t\tif (maxSize != ULONG_MAX && byteCount == maxSize)\n\t\t\t\tbreak;\n\t\t\t// once time limit is reached, return even if there is more data waiting\n\t\t\t// but make 0 a special case so caller can request a large amount of data to be\n\t\t\t// pumped as long as it is immediately available\n\t\t\tif (maxTime > 0 && timer.ElapsedTime() > maxTime)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_TRACE_NETWORK 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTime",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "54-59",
          "snippet": "unsigned long TimerBase::ElapsedTime()\n{\n\tdouble elapsed = ElapsedTimeAsDouble();\n\tassert(elapsed <= ULONG_MAX);\n\treturn (unsigned long)elapsed;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  unsigned long TimerBase::ElapsedTime()\n  {\n  \tdouble elapsed = ElapsedTimeAsDouble();\n  \tassert(elapsed <= ULONG_MAX);\n  \treturn (unsigned long)elapsed;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->Wait",
          "args": [
            "SaturatingSubtract(maxTime, timer.ElapsedTime())",
            "CallStack(\"NetworkSource::DoPump() - wait attachment\", 0)"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "Waitable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "388-393",
          "snippet": "bool Waitable::Wait(unsigned long milliseconds, CallStack const& callStack)\n{\n\tWaitObjectContainer container;\n\tGetWaitObjects(container, callStack);\t// reduce clutter by not adding this func to stack\n\treturn container.Wait(milliseconds);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitable {\n  bool Waitable::Wait(unsigned long milliseconds, CallStack const& callStack)\n  {\n  \tWaitObjectContainer container;\n  \tGetWaitObjects(container, callStack);\t// reduce clutter by not adding this func to stack\n  \treturn container.Wait(milliseconds);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NetworkSource::DoPump() - wait attachment\"",
            "0"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "maxTime",
            "timer.ElapsedTime()"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->PutModifiable2",
          "args": [
            "m_buf+m_dataBegin",
            "m_putSize",
            "0",
            "forever || blockingOutput"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "PutModifiable2",
          "container": "MeterFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "221-224",
          "snippet": "size_t MeterFilter::PutModifiable2(byte *begin, size_t length, int messageEnd, bool blocking)\n{\n\treturn PutMaybeModifiable(begin, length, messageEnd, blocking, true);\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nMeterFilter {\n  size_t MeterFilter::PutModifiable2(byte *begin, size_t length, int messageEnd, bool blocking)\n  {\n  \treturn PutMaybeModifiable(begin, length, messageEnd, blocking, true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::find",
          "args": [
            "m_buf+m_dataBegin",
            "m_buf+m_dataBegin+m_putSize",
            "delimiter"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "m_dataEnd - m_dataBegin",
            "maxSize - byteCount"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buf.size",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "receiver.EofReceived",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "EofReceived",
          "container": "SocketReceiver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "139-139",
          "snippet": "bool EofReceived() const {return m_eofReceived;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketReceiver {\n  bool EofReceived() const {return m_eofReceived;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "recvResult"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receiver.GetReceiveResult",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "GetReceiveResult",
          "container": "WindowsPipeReceiver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "126-151",
          "snippet": "unsigned int WindowsPipeReceiver::GetReceiveResult()\n{\n\tif (m_resultPending)\n\t{\n\t\tHANDLE h = GetHandle();\n\t\tif (GetOverlappedResult(h, &m_overlapped, &m_lastResult, false))\n\t\t{\n\t\t\tif (m_lastResult == 0)\n\t\t\t\tm_eofReceived = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (GetLastError())\n\t\t\t{\n\t\t\tdefault:\n\t\t\t\tCheckAndHandleError(\"GetOverlappedResult\", false);\n\t\t\tcase ERROR_BROKEN_PIPE:\n\t\t\tcase ERROR_HANDLE_EOF:\n\t\t\t\tm_lastResult = 0;\n\t\t\t\tm_eofReceived = true;\n\t\t\t}\n\t\t}\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeReceiver {\n  unsigned int WindowsPipeReceiver::GetReceiveResult()\n  {\n  \tif (m_resultPending)\n  \t{\n  \t\tHANDLE h = GetHandle();\n  \t\tif (GetOverlappedResult(h, &m_overlapped, &m_lastResult, false))\n  \t\t{\n  \t\t\tif (m_lastResult == 0)\n  \t\t\t\tm_eofReceived = true;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tswitch (GetLastError())\n  \t\t\t{\n  \t\t\tdefault:\n  \t\t\t\tCheckAndHandleError(\"GetOverlappedResult\", false);\n  \t\t\tcase ERROR_BROKEN_PIPE:\n  \t\t\tcase ERROR_HANDLE_EOF:\n  \t\t\t\tm_lastResult = 0;\n  \t\t\t\tm_eofReceived = true;\n  \t\t\t}\n  \t\t}\n  \t\tm_resultPending = false;\n  \t}\n  \treturn m_lastResult;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "receiver.Receive",
          "args": [
            "m_buf+m_dataEnd",
            "m_buf.size()-m_dataEnd"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "Receive",
          "container": "WindowsPipeReceiver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "89-116",
          "snippet": "bool WindowsPipeReceiver::Receive(byte* buf, size_t bufLen)\n{\n\tassert(!m_resultPending && !m_eofReceived);\n\n\tHANDLE h = GetHandle();\n\t// don't queue too much at once, or we might use up non-paged memory\n\tif (ReadFile(h, buf, UnsignedMin((DWORD)128*1024, bufLen), &m_lastResult, &m_overlapped))\n\t{\n\t\tif (m_lastResult == 0)\n\t\t\tm_eofReceived = true;\n\t}\n\telse\n\t{\n\t\tswitch (GetLastError())\n\t\t{\n\t\tdefault:\n\t\t\tCheckAndHandleError(\"ReadFile\", false);\n\t\tcase ERROR_BROKEN_PIPE:\n\t\tcase ERROR_HANDLE_EOF:\n\t\t\tm_lastResult = 0;\n\t\t\tm_eofReceived = true;\n\t\t\tbreak;\n\t\tcase ERROR_IO_PENDING:\n\t\t\tm_resultPending = true;\n\t\t}\n\t}\n\treturn !m_resultPending;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeReceiver {\n  bool WindowsPipeReceiver::Receive(byte* buf, size_t bufLen)\n  {\n  \tassert(!m_resultPending && !m_eofReceived);\n  \n  \tHANDLE h = GetHandle();\n  \t// don't queue too much at once, or we might use up non-paged memory\n  \tif (ReadFile(h, buf, UnsignedMin((DWORD)128*1024, bufLen), &m_lastResult, &m_overlapped))\n  \t{\n  \t\tif (m_lastResult == 0)\n  \t\t\tm_eofReceived = true;\n  \t}\n  \telse\n  \t{\n  \t\tswitch (GetLastError())\n  \t\t{\n  \t\tdefault:\n  \t\t\tCheckAndHandleError(\"ReadFile\", false);\n  \t\tcase ERROR_BROKEN_PIPE:\n  \t\tcase ERROR_HANDLE_EOF:\n  \t\t\tm_lastResult = 0;\n  \t\t\tm_eofReceived = true;\n  \t\t\tbreak;\n  \t\tcase ERROR_IO_PENDING:\n  \t\t\tm_resultPending = true;\n  \t\t}\n  \t}\n  \treturn !m_resultPending;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Receiving \" + IntToString(m_buf.size()-m_dataEnd) + \" bytes\\n\").c_str()"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.MustWaitToReceive",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitToReceive",
          "container": "SocketReceiver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "132-132",
          "snippet": "bool MustWaitToReceive() {return true;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketReceiver {\n  bool MustWaitToReceive() {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str()"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.MustWaitForResult",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitForResult",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "167-167",
          "snippet": "bool MustWaitForResult() {return true;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSender {\n  bool MustWaitForResult() {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessReceiver",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\n#define CRYPTOPP_TRACE_NETWORK 0\n\nNetworkSource {\n  size_t NetworkSource::DoPump(lword &byteCount, bool blockingOutput, unsigned long maxTime, bool checkDelimiter, byte delimiter)\n  {\n  \tNetworkReceiver &receiver = AccessReceiver();\n  \n  \tlword maxSize = byteCount;\n  \tbyteCount = 0;\n  \tbool forever = maxTime == INFINITE_TIME;\n  \tTimer timer(Timer::MILLISECONDS, forever);\n  \tBufferedTransformation *t = AttachedTransformation();\n  \n  \tif (m_outputBlocked)\n  \t\tgoto DoOutput;\n  \n  \twhile (true)\n  \t{\n  \t\tif (m_dataBegin == m_dataEnd)\n  \t\t{\n  \t\t\tif (receiver.EofReceived())\n  \t\t\t\tbreak;\n  \n  \t\t\tif (m_waitingForResult)\n  \t\t\t{\n  \t\t\t\tif (receiver.MustWaitForResult() &&\n  \t\t\t\t\t!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n  \t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive result\", 0)))\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n  #if CRYPTOPP_TRACE_NETWORK\n  \t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n  #endif\n  \t\t\t\tm_dataEnd += recvResult;\n  \t\t\t\tm_waitingForResult = false;\n  \n  \t\t\t\tif (!receiver.MustWaitToReceive() && !receiver.EofReceived() && m_dataEnd != m_buf.size())\n  \t\t\t\t\tgoto ReceiveNoWait;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tm_dataEnd = m_dataBegin = 0;\n  \n  \t\t\t\tif (receiver.MustWaitToReceive())\n  \t\t\t\t{\n  \t\t\t\t\tif (!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n  \t\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive\", 0)))\n  \t\t\t\t\t\tbreak;\n  \n  \t\t\t\t\treceiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd);\n  \t\t\t\t\tm_waitingForResult = true;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  ReceiveNoWait:\n  \t\t\t\t\tm_waitingForResult = true;\n  \t\t\t\t\t// call Receive repeatedly as long as data is immediately available,\n  \t\t\t\t\t// because some receivers tend to return data in small pieces\n  #if CRYPTOPP_TRACE_NETWORK\n  \t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Receiving \" + IntToString(m_buf.size()-m_dataEnd) + \" bytes\\n\").c_str());\n  #endif\n  \t\t\t\t\twhile (receiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd))\n  \t\t\t\t\t{\n  \t\t\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n  #if CRYPTOPP_TRACE_NETWORK\n  \t\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n  #endif\n  \t\t\t\t\t\tm_dataEnd += recvResult;\n  \t\t\t\t\t\tif (receiver.EofReceived() || m_dataEnd > m_buf.size() /2)\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tm_waitingForResult = false;\n  \t\t\t\t\t\t\tbreak;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tm_putSize = UnsignedMin(m_dataEnd - m_dataBegin, maxSize - byteCount);\n  \n  \t\t\tif (checkDelimiter)\n  \t\t\t\tm_putSize = std::find(m_buf+m_dataBegin, m_buf+m_dataBegin+m_putSize, delimiter) - (m_buf+m_dataBegin);\n  \n  DoOutput:\n  \t\t\tsize_t result = t->PutModifiable2(m_buf+m_dataBegin, m_putSize, 0, forever || blockingOutput);\n  \t\t\tif (result)\n  \t\t\t{\n  \t\t\t\tif (t->Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n  \t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait attachment\", 0)))\n  \t\t\t\t\tgoto DoOutput;\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\tm_outputBlocked = true;\n  \t\t\t\t\treturn result;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tm_outputBlocked = false;\n  \n  \t\t\tbyteCount += m_putSize;\n  \t\t\tm_dataBegin += m_putSize;\n  \t\t\tif (checkDelimiter && m_dataBegin < m_dataEnd && m_buf[m_dataBegin] == delimiter)\n  \t\t\t\tbreak;\n  \t\t\tif (maxSize != ULONG_MAX && byteCount == maxSize)\n  \t\t\t\tbreak;\n  \t\t\t// once time limit is reached, return even if there is more data waiting\n  \t\t\t// but make 0 a special case so caller can request a large amount of data to be\n  \t\t\t// pumped as long as it is immediately available\n  \t\t\tif (maxTime > 0 && timer.ElapsedTime() > maxTime)\n  \t\t\t\tbreak;\n  \t\t}\n  \t}\n  \n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "GetWaitObjects",
    "container": "NetworkSource",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "242-255",
    "snippet": "void NetworkSource::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (BlockedBySpeedLimit())\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - speed limit\", &callStack));\n\telse if (!m_outputBlocked)\n\t{\n\t\tif (m_dataBegin == m_dataEnd)\n\t\t\tAccessReceiver().GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - no data\", &callStack)); \n\t\telse\n\t\t\tcontainer.SetNoWait(CallStack(\"NetworkSource::GetWaitObjects() - have data\", &callStack));\n\t}\n\n\tAttachedTransformation()->GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - attachment\", &callStack));\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "container",
            "CallStack(\"NetworkSource::GetWaitObjects() - attachment\", &callStack)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NetworkSource::GetWaitObjects() - attachment\"",
            "&callStack"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container.SetNoWait",
          "args": [
            "CallStack(\"NetworkSource::GetWaitObjects() - have data\", &callStack)"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "SetNoWait",
          "container": "WaitObjectContainer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "81-85",
          "snippet": "void WaitObjectContainer::SetNoWait(CallStack const& callStack)\n{\n\tDetectNoWait(LASTRESULT_NOWAIT, CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack));\n\tm_noWait = true;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer {\n  void WaitObjectContainer::SetNoWait(CallStack const& callStack)\n  {\n  \tDetectNoWait(LASTRESULT_NOWAIT, CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack));\n  \tm_noWait = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessReceiver",
          "args": [
            "container",
            "CallStack(\"NetworkSource::GetWaitObjects() - no data\", &callStack)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessReceiver",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetWaitObjects",
          "args": [
            "container",
            "CallStack(\"NetworkSource::GetWaitObjects() - speed limit\", &callStack)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "GetWaitObjects",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "67-72",
          "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n  {\n  \tdouble nextTransceiveTime = TimeToNextTransceive();\n  \tif (nextTransceiveTime)\n  \t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockedBySpeedLimit",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "BlockedBySpeedLimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "145-145",
          "snippet": "bool BlockedBySpeedLimit() const { return m_blockedBySpeedLimit; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nbool BlockedBySpeedLimit() const { return m_blockedBySpeedLimit; }"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSource {\n  void NetworkSource::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n  {\n  \tif (BlockedBySpeedLimit())\n  \t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - speed limit\", &callStack));\n  \telse if (!m_outputBlocked)\n  \t{\n  \t\tif (m_dataBegin == m_dataEnd)\n  \t\t\tAccessReceiver().GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - no data\", &callStack)); \n  \t\telse\n  \t\t\tcontainer.SetNoWait(CallStack(\"NetworkSource::GetWaitObjects() - have data\", &callStack));\n  \t}\n  \n  \tAttachedTransformation()->GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - attachment\", &callStack));\n  }\n}"
  },
  {
    "function_name": "GetMaxWaitObjectCount",
    "container": "NetworkSource",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "235-240",
    "snippet": "unsigned int NetworkSource::GetMaxWaitObjectCount() const\n{\n\treturn LimitedBandwidth::GetMaxWaitObjectCount()\n\t\t+ GetReceiver().GetMaxWaitObjectCount()\n\t\t+ AttachedTransformation()->GetMaxWaitObjectCount();\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetReceiver",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetReceiver",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetMaxWaitObjectCount",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxWaitObjectCount",
          "container": "NetworkSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "401-404",
          "snippet": "unsigned int NetworkSink::GetMaxWaitObjectCount() const\n{\n\treturn LimitedBandwidth::GetMaxWaitObjectCount() + GetSender().GetMaxWaitObjectCount();\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink {\n  unsigned int NetworkSink::GetMaxWaitObjectCount() const\n  {\n  \treturn LimitedBandwidth::GetMaxWaitObjectCount() + GetSender().GetMaxWaitObjectCount();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSource {\n  unsigned int NetworkSource::GetMaxWaitObjectCount() const\n  {\n  \treturn LimitedBandwidth::GetMaxWaitObjectCount()\n  \t\t+ GetReceiver().GetMaxWaitObjectCount()\n  \t\t+ AttachedTransformation()->GetMaxWaitObjectCount();\n  }\n}"
  },
  {
    "function_name": "NetworkSource",
    "container": "NetworkSource",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "228-233",
    "snippet": "NetworkSource::NetworkSource(BufferedTransformation *attachment)\n\t: NonblockingSource(attachment), m_buf(1024*16)\n\t, m_dataBegin(0), m_dataEnd(0)\n\t, m_waitingForResult(false), m_outputBlocked(false)\n{\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSource {\n  NetworkSource::NetworkSource(BufferedTransformation *attachment)\n  \t: NonblockingSource(attachment), m_buf(1024*16)\n  \t, m_dataBegin(0), m_dataEnd(0)\n  \t, m_waitingForResult(false), m_outputBlocked(false)\n  {\n  }\n}"
  },
  {
    "function_name": "IsolatedFlush",
    "container": "NonblockingSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "220-224",
    "snippet": "bool NonblockingSink::IsolatedFlush(bool hardFlush, bool blocking)\n{\n\tTimedFlush(blocking ? INFINITE_TIME : 0);\n\treturn hardFlush && (!!GetCurrentBufferSize() || EofPending());\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentBufferSize",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimedFlush",
          "args": [
            "blocking ? INFINITE_TIME : 0"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNonblockingSink {\n  bool NonblockingSink::IsolatedFlush(bool hardFlush, bool blocking)\n  {\n  \tTimedFlush(blocking ? INFINITE_TIME : 0);\n  \treturn hardFlush && (!!GetCurrentBufferSize() || EofPending());\n  }\n}"
  },
  {
    "function_name": "TimedFlush",
    "container": "NonblockingSink",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "162-218",
    "snippet": "lword NonblockingSink::TimedFlush(unsigned long maxTime, size_t targetSize)\n{\n\tm_blockedBySpeedLimit = false;\n\n\tsize_t curBufSize = GetCurrentBufferSize();\n\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n\t\treturn 0;\n\n\tif (!GetMaxBytesPerSecond())\n\t\treturn DoFlush(maxTime, targetSize);\n\n\tbool forever = (maxTime == INFINITE_TIME);\n\tunsigned long timeToGo = maxTime;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tlword totalFlushed = 0;\n\n\ttimer.StartTimer();\n\n\twhile (true)\n\t{\t\n\t\tsize_t flushSize = UnsignedMin(curBufSize - targetSize, ComputeCurrentTransceiveLimit());\n\t\tif (flushSize || EofPending())\n\t\t{\n\t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tsize_t ret = (size_t)DoFlush(timeToGo, curBufSize - flushSize);\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\tNoteTransceive(ret);\n\t\t\t\tcurBufSize -= ret;\n\t\t\t\ttotalFlushed += ret;\n\t\t\t}\n\t\t}\n\n\t\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n\t\t\tbreak;\n\n\t\tif (!forever)\n\t\t{\n\t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tif (!timeToGo)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdouble waitTime = TimeToNextTransceive();\n\t\tif (!forever && waitTime > timeToGo)\n\t\t{\n\t\t\tm_blockedBySpeedLimit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tWaitObjectContainer container;\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSink::TimedFlush() - speed limit\", 0));\n\t\tcontainer.Wait((unsigned long)waitTime);\n\t}\n\n\treturn totalFlushed;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.Wait",
          "args": [
            "(unsigned long)waitTime"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "WaitObjectContainer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "331-367",
          "snippet": "bool WaitObjectContainer::Wait(unsigned long milliseconds)\n{\n\tif (m_noWait || (!m_maxFd && !m_firstEventTime))\n\t\treturn true;\n\n\tbool timeoutIsScheduledEvent = false;\n\n\tif (m_firstEventTime)\n\t{\n\t\tdouble timeToFirstEvent = SaturatingSubtract(m_firstEventTime, m_eventTimer.ElapsedTimeAsDouble());\n\t\tif (timeToFirstEvent <= milliseconds)\n\t\t{\n\t\t\tmilliseconds = (unsigned long)timeToFirstEvent;\n\t\t\ttimeoutIsScheduledEvent = true;\n\t\t}\n\t}\n\n\ttimeval tv, *timeout;\n\n\tif (milliseconds == INFINITE_TIME)\n\t\ttimeout = NULL;\n\telse\n\t{\n\t\ttv.tv_sec = milliseconds / 1000;\n\t\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\t\ttimeout = &tv;\n\t}\n\n\tint result = select(m_maxFd+1, &m_readfds, &m_writefds, NULL, timeout);\n\n\tif (result > 0)\n\t\treturn true;\n\telse if (result == 0)\n\t\treturn timeoutIsScheduledEvent;\n\telse\n\t\tthrow Err(\"WaitObjectContainer: select failed with error \" + IntToString(errno));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer {\n  bool WaitObjectContainer::Wait(unsigned long milliseconds)\n  {\n  \tif (m_noWait || (!m_maxFd && !m_firstEventTime))\n  \t\treturn true;\n  \n  \tbool timeoutIsScheduledEvent = false;\n  \n  \tif (m_firstEventTime)\n  \t{\n  \t\tdouble timeToFirstEvent = SaturatingSubtract(m_firstEventTime, m_eventTimer.ElapsedTimeAsDouble());\n  \t\tif (timeToFirstEvent <= milliseconds)\n  \t\t{\n  \t\t\tmilliseconds = (unsigned long)timeToFirstEvent;\n  \t\t\ttimeoutIsScheduledEvent = true;\n  \t\t}\n  \t}\n  \n  \ttimeval tv, *timeout;\n  \n  \tif (milliseconds == INFINITE_TIME)\n  \t\ttimeout = NULL;\n  \telse\n  \t{\n  \t\ttv.tv_sec = milliseconds / 1000;\n  \t\ttv.tv_usec = (milliseconds % 1000) * 1000;\n  \t\ttimeout = &tv;\n  \t}\n  \n  \tint result = select(m_maxFd+1, &m_readfds, &m_writefds, NULL, timeout);\n  \n  \tif (result > 0)\n  \t\treturn true;\n  \telse if (result == 0)\n  \t\treturn timeoutIsScheduledEvent;\n  \telse\n  \t\tthrow Err(\"WaitObjectContainer: select failed with error \" + IntToString(errno));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetWaitObjects",
          "args": [
            "container",
            "CallStack(\"NonblockingSink::TimedFlush() - speed limit\", 0)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "GetWaitObjects",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "67-72",
          "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n  {\n  \tdouble nextTransceiveTime = TimeToNextTransceive();\n  \tif (nextTransceiveTime)\n  \t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NonblockingSink::TimedFlush() - speed limit\"",
            "0"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimeToNextTransceive",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "TimeToNextTransceive",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "25-34",
          "snippet": "double LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  double LimitedBandwidth::TimeToNextTransceive()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn 0;\n  \n  \tif (!m_nextTransceiveTime)\n  \t\tComputeNextTransceiveTime();\n  \n  \treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "maxTime",
            "timer.ElapsedTime()"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTime",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "54-59",
          "snippet": "unsigned long TimerBase::ElapsedTime()\n{\n\tdouble elapsed = ElapsedTimeAsDouble();\n\tassert(elapsed <= ULONG_MAX);\n\treturn (unsigned long)elapsed;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  unsigned long TimerBase::ElapsedTime()\n  {\n  \tdouble elapsed = ElapsedTimeAsDouble();\n  \tassert(elapsed <= ULONG_MAX);\n  \treturn (unsigned long)elapsed;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NoteTransceive",
          "args": [
            "ret"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "NoteTransceive",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "36-44",
          "snippet": "void LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::NoteTransceive(lword size)\n  {\n  \tif (m_maxBytesPerSecond)\n  \t{\n  \t\tdouble curTime = GetCurTimeAndCleanUp();\n  \t\tm_ops.push_back(std::make_pair(curTime, size));\n  \t\tm_nextTransceiveTime = 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoFlush",
          "args": [
            "timeToGo",
            "curBufSize - flushSize"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "DoFlush",
          "container": "NetworkSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "474-546",
          "snippet": "lword NetworkSink::DoFlush(unsigned long maxTime, size_t targetSize)\n{\n\tNetworkSender &sender = AccessSender();\n\n\tbool forever = maxTime == INFINITE_TIME;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tunsigned int totalFlushSize = 0;\n\n\twhile (true)\n\t{\n\t\tif (m_buffer.CurrentSize() <= targetSize)\n\t\t\tbreak;\n\t\t\n\t\tif (m_needSendResult)\n\t\t{\n\t\t\tif (sender.MustWaitForResult() &&\n\t\t\t\t!sender.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\tCallStack(\"NetworkSink::DoFlush() - wait send result\", 0)))\n\t\t\t\tbreak;\n\n\t\t\tunsigned int sendResult = sender.GetSendResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sent \" + IntToString(sendResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\tm_buffer.Skip(sendResult);\n\t\t\ttotalFlushSize += sendResult;\n\t\t\tm_needSendResult = false;\n\n\t\t\tif (!m_buffer.AnyRetrievable())\n\t\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n\t\tif (sender.MustWaitToSend() && !sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait send\", 0)))\n\t\t\tbreak;\n\n\t\tsize_t contiguousSize = 0;\n\t\tconst byte *block = m_buffer.Spy(contiguousSize);\n\n#if CRYPTOPP_TRACE_NETWORK\n\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sending \" + IntToString(contiguousSize) + \" bytes\\n\").c_str());\n#endif\n\t\tsender.Send(block, contiguousSize);\n\t\tm_needSendResult = true;\n\n\t\tif (maxTime > 0 && timeOut == 0)\n\t\t\tbreak;\t// once time limit is reached, return even if there is more data waiting\n\t}\n\n\tm_byteCountSinceLastTimerReset += totalFlushSize;\n\tComputeCurrentSpeed();\n\t\n\tif (m_buffer.IsEmpty() && !m_needSendResult)\n\t{\n\t\tif (m_eofState == EOF_PENDING_SEND)\n\t\t{\n\t\t\tsender.SendEof();\n\t\t\tm_eofState = sender.MustWaitForEof() ? EOF_PENDING_DELIVERY : EOF_DONE;\n\t\t}\n\n\t\twhile (m_eofState == EOF_PENDING_DELIVERY)\n\t\t{\n\t\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n\t\t\tif (!sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait EOF\", 0)))\n\t\t\t\tbreak;\n\n\t\t\tif (sender.EofSent())\n\t\t\t\tm_eofState = EOF_DONE;\n\t\t}\n\t}\n\n\treturn totalFlushSize;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_TRACE_NETWORK 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\n#define CRYPTOPP_TRACE_NETWORK 0\n\nNetworkSink {\n  lword NetworkSink::DoFlush(unsigned long maxTime, size_t targetSize)\n  {\n  \tNetworkSender &sender = AccessSender();\n  \n  \tbool forever = maxTime == INFINITE_TIME;\n  \tTimer timer(Timer::MILLISECONDS, forever);\n  \tunsigned int totalFlushSize = 0;\n  \n  \twhile (true)\n  \t{\n  \t\tif (m_buffer.CurrentSize() <= targetSize)\n  \t\t\tbreak;\n  \t\t\n  \t\tif (m_needSendResult)\n  \t\t{\n  \t\t\tif (sender.MustWaitForResult() &&\n  \t\t\t\t!sender.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n  \t\t\t\t\tCallStack(\"NetworkSink::DoFlush() - wait send result\", 0)))\n  \t\t\t\tbreak;\n  \n  \t\t\tunsigned int sendResult = sender.GetSendResult();\n  #if CRYPTOPP_TRACE_NETWORK\n  \t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sent \" + IntToString(sendResult) + \" bytes\\n\").c_str());\n  #endif\n  \t\t\tm_buffer.Skip(sendResult);\n  \t\t\ttotalFlushSize += sendResult;\n  \t\t\tm_needSendResult = false;\n  \n  \t\t\tif (!m_buffer.AnyRetrievable())\n  \t\t\t\tbreak;\n  \t\t}\n  \n  \t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n  \t\tif (sender.MustWaitToSend() && !sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait send\", 0)))\n  \t\t\tbreak;\n  \n  \t\tsize_t contiguousSize = 0;\n  \t\tconst byte *block = m_buffer.Spy(contiguousSize);\n  \n  #if CRYPTOPP_TRACE_NETWORK\n  \t\tOutputDebugString((IntToString((unsigned int)this) + \": Sending \" + IntToString(contiguousSize) + \" bytes\\n\").c_str());\n  #endif\n  \t\tsender.Send(block, contiguousSize);\n  \t\tm_needSendResult = true;\n  \n  \t\tif (maxTime > 0 && timeOut == 0)\n  \t\t\tbreak;\t// once time limit is reached, return even if there is more data waiting\n  \t}\n  \n  \tm_byteCountSinceLastTimerReset += totalFlushSize;\n  \tComputeCurrentSpeed();\n  \t\n  \tif (m_buffer.IsEmpty() && !m_needSendResult)\n  \t{\n  \t\tif (m_eofState == EOF_PENDING_SEND)\n  \t\t{\n  \t\t\tsender.SendEof();\n  \t\t\tm_eofState = sender.MustWaitForEof() ? EOF_PENDING_DELIVERY : EOF_DONE;\n  \t\t}\n  \n  \t\twhile (m_eofState == EOF_PENDING_DELIVERY)\n  \t\t{\n  \t\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n  \t\t\tif (!sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait EOF\", 0)))\n  \t\t\t\tbreak;\n  \n  \t\t\tif (sender.EofSent())\n  \t\t\t\tm_eofState = EOF_DONE;\n  \t\t}\n  \t}\n  \n  \treturn totalFlushSize;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "curBufSize - targetSize",
            "ComputeCurrentTransceiveLimit()"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeCurrentTransceiveLimit",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeCurrentTransceiveLimit",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "13-23",
          "snippet": "lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn ULONG_MAX;\n  \n  \tdouble curTime = GetCurTimeAndCleanUp();\n  \tlword total = 0;\n  \tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n  \t\ttotal += m_ops[i].second;\n  \treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.StartTimer",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "StartTimer",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "31-35",
          "snippet": "void TimerBase::StartTimer()\n{\n\tm_last = m_start = GetCurrentTimerValue();\n\tm_started = true;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  void TimerBase::StartTimer()\n  {\n  \tm_last = m_start = GetCurrentTimerValue();\n  \tm_started = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetMaxBytesPerSecond",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxBytesPerSecond",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "23-24",
          "snippet": "lword GetMaxBytesPerSecond() const\n\t\t{ return m_maxBytesPerSecond; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nLimitedBandwidth {\n  lword GetMaxBytesPerSecond() const\n  \t\t{ return m_maxBytesPerSecond; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentBufferSize",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNonblockingSink {\n  lword NonblockingSink::TimedFlush(unsigned long maxTime, size_t targetSize)\n  {\n  \tm_blockedBySpeedLimit = false;\n  \n  \tsize_t curBufSize = GetCurrentBufferSize();\n  \tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n  \t\treturn 0;\n  \n  \tif (!GetMaxBytesPerSecond())\n  \t\treturn DoFlush(maxTime, targetSize);\n  \n  \tbool forever = (maxTime == INFINITE_TIME);\n  \tunsigned long timeToGo = maxTime;\n  \tTimer timer(Timer::MILLISECONDS, forever);\n  \tlword totalFlushed = 0;\n  \n  \ttimer.StartTimer();\n  \n  \twhile (true)\n  \t{\t\n  \t\tsize_t flushSize = UnsignedMin(curBufSize - targetSize, ComputeCurrentTransceiveLimit());\n  \t\tif (flushSize || EofPending())\n  \t\t{\n  \t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n  \t\t\tsize_t ret = (size_t)DoFlush(timeToGo, curBufSize - flushSize);\n  \t\t\tif (ret)\n  \t\t\t{\n  \t\t\t\tNoteTransceive(ret);\n  \t\t\t\tcurBufSize -= ret;\n  \t\t\t\ttotalFlushed += ret;\n  \t\t\t}\n  \t\t}\n  \n  \t\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n  \t\t\tbreak;\n  \n  \t\tif (!forever)\n  \t\t{\n  \t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n  \t\t\tif (!timeToGo)\n  \t\t\t\tbreak;\n  \t\t}\n  \n  \t\tdouble waitTime = TimeToNextTransceive();\n  \t\tif (!forever && waitTime > timeToGo)\n  \t\t{\n  \t\t\tm_blockedBySpeedLimit = true;\n  \t\t\tbreak;\n  \t\t}\n  \n  \t\tWaitObjectContainer container;\n  \t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSink::TimedFlush() - speed limit\", 0));\n  \t\tcontainer.Wait((unsigned long)waitTime);\n  \t}\n  \n  \treturn totalFlushed;\n  }\n}"
  },
  {
    "function_name": "PumpMessages2",
    "container": "NonblockingSource",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "140-160",
    "snippet": "size_t NonblockingSource::PumpMessages2(unsigned int &messageCount, bool blocking)\n{\n\tif (messageCount == 0)\n\t\treturn 0;\n\n\tmessageCount = 0;\n\n\tlword byteCount;\n\tdo {\n\t\tbyteCount = LWORD_MAX;\n\t\tRETURN_IF_NONZERO(Pump2(byteCount, blocking));\n\t} while(byteCount == LWORD_MAX);\n\n\tif (!m_messageEndSent && SourceExhausted())\n\t{\n\t\tRETURN_IF_NONZERO(AttachedTransformation()->Put2(NULL, 0, GetAutoSignalPropagation(), true));\n\t\tm_messageEndSent = true;\n\t\tmessageCount = 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RETURN_IF_NONZERO",
          "args": [
            "AttachedTransformation()->Put2(NULL, 0, GetAutoSignalPropagation(), true)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "NULL",
            "0",
            "GetAutoSignalPropagation()",
            "true"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAutoSignalPropagation",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "GetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "860-860",
          "snippet": "virtual int GetAutoSignalPropagation() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual int GetAutoSignalPropagation() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SourceExhausted",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "SourceExhausted",
          "container": "SourceTemplate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "768-769",
          "snippet": "bool SourceExhausted() const\n\t\t{return !m_store.AnyRetrievable() && !m_store.AnyMessages();}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nSourceTemplate {\n  bool SourceExhausted() const\n  \t\t{return !m_store.AnyRetrievable() && !m_store.AnyMessages();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RETURN_IF_NONZERO",
          "args": [
            "Pump2(byteCount, blocking)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pump2",
          "args": [
            "byteCount",
            "blocking"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNonblockingSource {\n  size_t NonblockingSource::PumpMessages2(unsigned int &messageCount, bool blocking)\n  {\n  \tif (messageCount == 0)\n  \t\treturn 0;\n  \n  \tmessageCount = 0;\n  \n  \tlword byteCount;\n  \tdo {\n  \t\tbyteCount = LWORD_MAX;\n  \t\tRETURN_IF_NONZERO(Pump2(byteCount, blocking));\n  \t} while(byteCount == LWORD_MAX);\n  \n  \tif (!m_messageEndSent && SourceExhausted())\n  \t{\n  \t\tRETURN_IF_NONZERO(AttachedTransformation()->Put2(NULL, 0, GetAutoSignalPropagation(), true));\n  \t\tm_messageEndSent = true;\n  \t\tmessageCount = 1;\n  \t}\n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "GeneralPump2",
    "container": "NonblockingSource",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "76-138",
    "snippet": "size_t NonblockingSource::GeneralPump2(\n\tlword& byteCount, bool blockingOutput,\n\tunsigned long maxTime, bool checkDelimiter, byte delimiter)\n{\n\tm_blockedBySpeedLimit = false;\n\n\tif (!GetMaxBytesPerSecond())\n\t{\n\t\tsize_t ret = DoPump(byteCount, blockingOutput, maxTime, checkDelimiter, delimiter);\n\t\tm_doPumpBlocked = (ret != 0);\n\t\treturn ret;\n\t}\n\n\tbool forever = (maxTime == INFINITE_TIME);\n\tunsigned long timeToGo = maxTime;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tlword maxSize = byteCount;\n\tbyteCount = 0;\n\n\ttimer.StartTimer();\n\n\twhile (true)\n\t{\n\t\tlword curMaxSize = UnsignedMin(ComputeCurrentTransceiveLimit(), maxSize - byteCount);\n\n\t\tif (curMaxSize || m_doPumpBlocked)\n\t\t{\n\t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tsize_t ret = DoPump(curMaxSize, blockingOutput, timeToGo, checkDelimiter, delimiter);\n\t\t\tm_doPumpBlocked = (ret != 0);\n\t\t\tif (curMaxSize)\n\t\t\t{\n\t\t\t\tNoteTransceive(curMaxSize);\n\t\t\t\tbyteCount += curMaxSize;\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (maxSize != ULONG_MAX && byteCount >= maxSize)\n\t\t\tbreak;\n\n\t\tif (!forever)\n\t\t{\n\t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tif (!timeToGo)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdouble waitTime = TimeToNextTransceive();\n\t\tif (!forever && waitTime > timeToGo)\n\t\t{\n\t\t\tm_blockedBySpeedLimit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tWaitObjectContainer container;\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSource::GeneralPump2() - speed limit\", 0));\n\t\tcontainer.Wait((unsigned long)waitTime);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.Wait",
          "args": [
            "(unsigned long)waitTime"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "WaitObjectContainer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "331-367",
          "snippet": "bool WaitObjectContainer::Wait(unsigned long milliseconds)\n{\n\tif (m_noWait || (!m_maxFd && !m_firstEventTime))\n\t\treturn true;\n\n\tbool timeoutIsScheduledEvent = false;\n\n\tif (m_firstEventTime)\n\t{\n\t\tdouble timeToFirstEvent = SaturatingSubtract(m_firstEventTime, m_eventTimer.ElapsedTimeAsDouble());\n\t\tif (timeToFirstEvent <= milliseconds)\n\t\t{\n\t\t\tmilliseconds = (unsigned long)timeToFirstEvent;\n\t\t\ttimeoutIsScheduledEvent = true;\n\t\t}\n\t}\n\n\ttimeval tv, *timeout;\n\n\tif (milliseconds == INFINITE_TIME)\n\t\ttimeout = NULL;\n\telse\n\t{\n\t\ttv.tv_sec = milliseconds / 1000;\n\t\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\t\ttimeout = &tv;\n\t}\n\n\tint result = select(m_maxFd+1, &m_readfds, &m_writefds, NULL, timeout);\n\n\tif (result > 0)\n\t\treturn true;\n\telse if (result == 0)\n\t\treturn timeoutIsScheduledEvent;\n\telse\n\t\tthrow Err(\"WaitObjectContainer: select failed with error \" + IntToString(errno));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer {\n  bool WaitObjectContainer::Wait(unsigned long milliseconds)\n  {\n  \tif (m_noWait || (!m_maxFd && !m_firstEventTime))\n  \t\treturn true;\n  \n  \tbool timeoutIsScheduledEvent = false;\n  \n  \tif (m_firstEventTime)\n  \t{\n  \t\tdouble timeToFirstEvent = SaturatingSubtract(m_firstEventTime, m_eventTimer.ElapsedTimeAsDouble());\n  \t\tif (timeToFirstEvent <= milliseconds)\n  \t\t{\n  \t\t\tmilliseconds = (unsigned long)timeToFirstEvent;\n  \t\t\ttimeoutIsScheduledEvent = true;\n  \t\t}\n  \t}\n  \n  \ttimeval tv, *timeout;\n  \n  \tif (milliseconds == INFINITE_TIME)\n  \t\ttimeout = NULL;\n  \telse\n  \t{\n  \t\ttv.tv_sec = milliseconds / 1000;\n  \t\ttv.tv_usec = (milliseconds % 1000) * 1000;\n  \t\ttimeout = &tv;\n  \t}\n  \n  \tint result = select(m_maxFd+1, &m_readfds, &m_writefds, NULL, timeout);\n  \n  \tif (result > 0)\n  \t\treturn true;\n  \telse if (result == 0)\n  \t\treturn timeoutIsScheduledEvent;\n  \telse\n  \t\tthrow Err(\"WaitObjectContainer: select failed with error \" + IntToString(errno));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetWaitObjects",
          "args": [
            "container",
            "CallStack(\"NonblockingSource::GeneralPump2() - speed limit\", 0)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "GetWaitObjects",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "67-72",
          "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n  {\n  \tdouble nextTransceiveTime = TimeToNextTransceive();\n  \tif (nextTransceiveTime)\n  \t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NonblockingSource::GeneralPump2() - speed limit\"",
            "0"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimeToNextTransceive",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "TimeToNextTransceive",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "25-34",
          "snippet": "double LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  double LimitedBandwidth::TimeToNextTransceive()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn 0;\n  \n  \tif (!m_nextTransceiveTime)\n  \t\tComputeNextTransceiveTime();\n  \n  \treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "maxTime",
            "timer.ElapsedTime()"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTime",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "54-59",
          "snippet": "unsigned long TimerBase::ElapsedTime()\n{\n\tdouble elapsed = ElapsedTimeAsDouble();\n\tassert(elapsed <= ULONG_MAX);\n\treturn (unsigned long)elapsed;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  unsigned long TimerBase::ElapsedTime()\n  {\n  \tdouble elapsed = ElapsedTimeAsDouble();\n  \tassert(elapsed <= ULONG_MAX);\n  \treturn (unsigned long)elapsed;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NoteTransceive",
          "args": [
            "curMaxSize"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "NoteTransceive",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "36-44",
          "snippet": "void LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::NoteTransceive(lword size)\n  {\n  \tif (m_maxBytesPerSecond)\n  \t{\n  \t\tdouble curTime = GetCurTimeAndCleanUp();\n  \t\tm_ops.push_back(std::make_pair(curTime, size));\n  \t\tm_nextTransceiveTime = 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoPump",
          "args": [
            "curMaxSize",
            "blockingOutput",
            "timeToGo",
            "checkDelimiter",
            "delimiter"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "DoPump",
          "container": "NetworkSource",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "257-369",
          "snippet": "size_t NetworkSource::DoPump(lword &byteCount, bool blockingOutput, unsigned long maxTime, bool checkDelimiter, byte delimiter)\n{\n\tNetworkReceiver &receiver = AccessReceiver();\n\n\tlword maxSize = byteCount;\n\tbyteCount = 0;\n\tbool forever = maxTime == INFINITE_TIME;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tBufferedTransformation *t = AttachedTransformation();\n\n\tif (m_outputBlocked)\n\t\tgoto DoOutput;\n\n\twhile (true)\n\t{\n\t\tif (m_dataBegin == m_dataEnd)\n\t\t{\n\t\t\tif (receiver.EofReceived())\n\t\t\t\tbreak;\n\n\t\t\tif (m_waitingForResult)\n\t\t\t{\n\t\t\t\tif (receiver.MustWaitForResult() &&\n\t\t\t\t\t!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive result\", 0)))\n\t\t\t\t\tbreak;\n\n\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\tm_dataEnd += recvResult;\n\t\t\t\tm_waitingForResult = false;\n\n\t\t\t\tif (!receiver.MustWaitToReceive() && !receiver.EofReceived() && m_dataEnd != m_buf.size())\n\t\t\t\t\tgoto ReceiveNoWait;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_dataEnd = m_dataBegin = 0;\n\n\t\t\t\tif (receiver.MustWaitToReceive())\n\t\t\t\t{\n\t\t\t\t\tif (!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive\", 0)))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\treceiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd);\n\t\t\t\t\tm_waitingForResult = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\nReceiveNoWait:\n\t\t\t\t\tm_waitingForResult = true;\n\t\t\t\t\t// call Receive repeatedly as long as data is immediately available,\n\t\t\t\t\t// because some receivers tend to return data in small pieces\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Receiving \" + IntToString(m_buf.size()-m_dataEnd) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\t\twhile (receiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd))\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\t\t\tm_dataEnd += recvResult;\n\t\t\t\t\t\tif (receiver.EofReceived() || m_dataEnd > m_buf.size() /2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_waitingForResult = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_putSize = UnsignedMin(m_dataEnd - m_dataBegin, maxSize - byteCount);\n\n\t\t\tif (checkDelimiter)\n\t\t\t\tm_putSize = std::find(m_buf+m_dataBegin, m_buf+m_dataBegin+m_putSize, delimiter) - (m_buf+m_dataBegin);\n\nDoOutput:\n\t\t\tsize_t result = t->PutModifiable2(m_buf+m_dataBegin, m_putSize, 0, forever || blockingOutput);\n\t\t\tif (result)\n\t\t\t{\n\t\t\t\tif (t->Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait attachment\", 0)))\n\t\t\t\t\tgoto DoOutput;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_outputBlocked = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_outputBlocked = false;\n\n\t\t\tbyteCount += m_putSize;\n\t\t\tm_dataBegin += m_putSize;\n\t\t\tif (checkDelimiter && m_dataBegin < m_dataEnd && m_buf[m_dataBegin] == delimiter)\n\t\t\t\tbreak;\n\t\t\tif (maxSize != ULONG_MAX && byteCount == maxSize)\n\t\t\t\tbreak;\n\t\t\t// once time limit is reached, return even if there is more data waiting\n\t\t\t// but make 0 a special case so caller can request a large amount of data to be\n\t\t\t// pumped as long as it is immediately available\n\t\t\tif (maxTime > 0 && timer.ElapsedTime() > maxTime)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_TRACE_NETWORK 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\n#define CRYPTOPP_TRACE_NETWORK 0\n\nNetworkSource {\n  size_t NetworkSource::DoPump(lword &byteCount, bool blockingOutput, unsigned long maxTime, bool checkDelimiter, byte delimiter)\n  {\n  \tNetworkReceiver &receiver = AccessReceiver();\n  \n  \tlword maxSize = byteCount;\n  \tbyteCount = 0;\n  \tbool forever = maxTime == INFINITE_TIME;\n  \tTimer timer(Timer::MILLISECONDS, forever);\n  \tBufferedTransformation *t = AttachedTransformation();\n  \n  \tif (m_outputBlocked)\n  \t\tgoto DoOutput;\n  \n  \twhile (true)\n  \t{\n  \t\tif (m_dataBegin == m_dataEnd)\n  \t\t{\n  \t\t\tif (receiver.EofReceived())\n  \t\t\t\tbreak;\n  \n  \t\t\tif (m_waitingForResult)\n  \t\t\t{\n  \t\t\t\tif (receiver.MustWaitForResult() &&\n  \t\t\t\t\t!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n  \t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive result\", 0)))\n  \t\t\t\t\tbreak;\n  \n  \t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n  #if CRYPTOPP_TRACE_NETWORK\n  \t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n  #endif\n  \t\t\t\tm_dataEnd += recvResult;\n  \t\t\t\tm_waitingForResult = false;\n  \n  \t\t\t\tif (!receiver.MustWaitToReceive() && !receiver.EofReceived() && m_dataEnd != m_buf.size())\n  \t\t\t\t\tgoto ReceiveNoWait;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tm_dataEnd = m_dataBegin = 0;\n  \n  \t\t\t\tif (receiver.MustWaitToReceive())\n  \t\t\t\t{\n  \t\t\t\t\tif (!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n  \t\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive\", 0)))\n  \t\t\t\t\t\tbreak;\n  \n  \t\t\t\t\treceiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd);\n  \t\t\t\t\tm_waitingForResult = true;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  ReceiveNoWait:\n  \t\t\t\t\tm_waitingForResult = true;\n  \t\t\t\t\t// call Receive repeatedly as long as data is immediately available,\n  \t\t\t\t\t// because some receivers tend to return data in small pieces\n  #if CRYPTOPP_TRACE_NETWORK\n  \t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Receiving \" + IntToString(m_buf.size()-m_dataEnd) + \" bytes\\n\").c_str());\n  #endif\n  \t\t\t\t\twhile (receiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd))\n  \t\t\t\t\t{\n  \t\t\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n  #if CRYPTOPP_TRACE_NETWORK\n  \t\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n  #endif\n  \t\t\t\t\t\tm_dataEnd += recvResult;\n  \t\t\t\t\t\tif (receiver.EofReceived() || m_dataEnd > m_buf.size() /2)\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tm_waitingForResult = false;\n  \t\t\t\t\t\t\tbreak;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tm_putSize = UnsignedMin(m_dataEnd - m_dataBegin, maxSize - byteCount);\n  \n  \t\t\tif (checkDelimiter)\n  \t\t\t\tm_putSize = std::find(m_buf+m_dataBegin, m_buf+m_dataBegin+m_putSize, delimiter) - (m_buf+m_dataBegin);\n  \n  DoOutput:\n  \t\t\tsize_t result = t->PutModifiable2(m_buf+m_dataBegin, m_putSize, 0, forever || blockingOutput);\n  \t\t\tif (result)\n  \t\t\t{\n  \t\t\t\tif (t->Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n  \t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait attachment\", 0)))\n  \t\t\t\t\tgoto DoOutput;\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\tm_outputBlocked = true;\n  \t\t\t\t\treturn result;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tm_outputBlocked = false;\n  \n  \t\t\tbyteCount += m_putSize;\n  \t\t\tm_dataBegin += m_putSize;\n  \t\t\tif (checkDelimiter && m_dataBegin < m_dataEnd && m_buf[m_dataBegin] == delimiter)\n  \t\t\t\tbreak;\n  \t\t\tif (maxSize != ULONG_MAX && byteCount == maxSize)\n  \t\t\t\tbreak;\n  \t\t\t// once time limit is reached, return even if there is more data waiting\n  \t\t\t// but make 0 a special case so caller can request a large amount of data to be\n  \t\t\t// pumped as long as it is immediately available\n  \t\t\tif (maxTime > 0 && timer.ElapsedTime() > maxTime)\n  \t\t\t\tbreak;\n  \t\t}\n  \t}\n  \n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "ComputeCurrentTransceiveLimit()",
            "maxSize - byteCount"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeCurrentTransceiveLimit",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeCurrentTransceiveLimit",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "13-23",
          "snippet": "lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn ULONG_MAX;\n  \n  \tdouble curTime = GetCurTimeAndCleanUp();\n  \tlword total = 0;\n  \tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n  \t\ttotal += m_ops[i].second;\n  \treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.StartTimer",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "StartTimer",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "31-35",
          "snippet": "void TimerBase::StartTimer()\n{\n\tm_last = m_start = GetCurrentTimerValue();\n\tm_started = true;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  void TimerBase::StartTimer()\n  {\n  \tm_last = m_start = GetCurrentTimerValue();\n  \tm_started = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetMaxBytesPerSecond",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxBytesPerSecond",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "23-24",
          "snippet": "lword GetMaxBytesPerSecond() const\n\t\t{ return m_maxBytesPerSecond; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nLimitedBandwidth {\n  lword GetMaxBytesPerSecond() const\n  \t\t{ return m_maxBytesPerSecond; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNonblockingSource {\n  size_t NonblockingSource::GeneralPump2(\n  \tlword& byteCount, bool blockingOutput,\n  \tunsigned long maxTime, bool checkDelimiter, byte delimiter)\n  {\n  \tm_blockedBySpeedLimit = false;\n  \n  \tif (!GetMaxBytesPerSecond())\n  \t{\n  \t\tsize_t ret = DoPump(byteCount, blockingOutput, maxTime, checkDelimiter, delimiter);\n  \t\tm_doPumpBlocked = (ret != 0);\n  \t\treturn ret;\n  \t}\n  \n  \tbool forever = (maxTime == INFINITE_TIME);\n  \tunsigned long timeToGo = maxTime;\n  \tTimer timer(Timer::MILLISECONDS, forever);\n  \tlword maxSize = byteCount;\n  \tbyteCount = 0;\n  \n  \ttimer.StartTimer();\n  \n  \twhile (true)\n  \t{\n  \t\tlword curMaxSize = UnsignedMin(ComputeCurrentTransceiveLimit(), maxSize - byteCount);\n  \n  \t\tif (curMaxSize || m_doPumpBlocked)\n  \t\t{\n  \t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n  \t\t\tsize_t ret = DoPump(curMaxSize, blockingOutput, timeToGo, checkDelimiter, delimiter);\n  \t\t\tm_doPumpBlocked = (ret != 0);\n  \t\t\tif (curMaxSize)\n  \t\t\t{\n  \t\t\t\tNoteTransceive(curMaxSize);\n  \t\t\t\tbyteCount += curMaxSize;\n  \t\t\t}\n  \t\t\tif (ret)\n  \t\t\t\treturn ret;\n  \t\t}\n  \n  \t\tif (maxSize != ULONG_MAX && byteCount >= maxSize)\n  \t\t\tbreak;\n  \n  \t\tif (!forever)\n  \t\t{\n  \t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n  \t\t\tif (!timeToGo)\n  \t\t\t\tbreak;\n  \t\t}\n  \n  \t\tdouble waitTime = TimeToNextTransceive();\n  \t\tif (!forever && waitTime > timeToGo)\n  \t\t{\n  \t\t\tm_blockedBySpeedLimit = true;\n  \t\t\tbreak;\n  \t\t}\n  \n  \t\tWaitObjectContainer container;\n  \t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSource::GeneralPump2() - speed limit\", 0));\n  \t\tcontainer.Wait((unsigned long)waitTime);\n  \t}\n  \n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "GetWaitObjects",
    "container": "LimitedBandwidth",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "67-72",
    "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.ScheduleEvent",
          "args": [
            "nextTransceiveTime",
            "CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack)"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ScheduleEvent",
          "container": "WaitObjectContainer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "87-94",
          "snippet": "void WaitObjectContainer::ScheduleEvent(double milliseconds, CallStack const& callStack)\n{\n\tif (milliseconds <= 3)\n\t\tDetectNoWait(LASTRESULT_SCHEDULED, CallStack(\"WaitObjectContainer::ScheduleEvent()\", &callStack));\n\tdouble thisEventTime = m_eventTimer.ElapsedTimeAsDouble() + milliseconds;\n\tif (!m_firstEventTime || thisEventTime < m_firstEventTime)\n\t\tm_firstEventTime = thisEventTime;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer {\n  void WaitObjectContainer::ScheduleEvent(double milliseconds, CallStack const& callStack)\n  {\n  \tif (milliseconds <= 3)\n  \t\tDetectNoWait(LASTRESULT_SCHEDULED, CallStack(\"WaitObjectContainer::ScheduleEvent()\", &callStack));\n  \tdouble thisEventTime = m_eventTimer.ElapsedTimeAsDouble() + milliseconds;\n  \tif (!m_firstEventTime || thisEventTime < m_firstEventTime)\n  \t\tm_firstEventTime = thisEventTime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"LimitedBandwidth::GetWaitObjects()\"",
            "&callStack"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimeToNextTransceive",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "TimeToNextTransceive",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "25-34",
          "snippet": "double LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  double LimitedBandwidth::TimeToNextTransceive()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn 0;\n  \n  \tif (!m_nextTransceiveTime)\n  \t\tComputeNextTransceiveTime();\n  \n  \treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n  {\n  \tdouble nextTransceiveTime = TimeToNextTransceive();\n  \tif (nextTransceiveTime)\n  \t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n  }\n}"
  },
  {
    "function_name": "GetCurTimeAndCleanUp",
    "container": "LimitedBandwidth",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "56-65",
    "snippet": "double LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ops.pop_front",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ops.front",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ops.size",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_timer.ElapsedTimeAsDouble",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTimeAsDouble",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "37-52",
          "snippet": "double TimerBase::ElapsedTimeAsDouble()\n{\n\tif (m_stuckAtZero)\n\t\treturn 0;\n\n\tif (m_started)\n\t{\n\t\tTimerWord now = GetCurrentTimerValue();\n\t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n\t\t\tm_last = now;\n\t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n\t}\n\n\tStartTimer();\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  double TimerBase::ElapsedTimeAsDouble()\n  {\n  \tif (m_stuckAtZero)\n  \t\treturn 0;\n  \n  \tif (m_started)\n  \t{\n  \t\tTimerWord now = GetCurrentTimerValue();\n  \t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n  \t\t\tm_last = now;\n  \t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n  \t}\n  \n  \tStartTimer();\n  \treturn 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  double LimitedBandwidth::GetCurTimeAndCleanUp()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn 0;\n  \n  \tdouble curTime = m_timer.ElapsedTimeAsDouble();\n  \twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n  \t\tm_ops.pop_front();\n  \treturn curTime;\n  }\n}"
  },
  {
    "function_name": "ComputeNextTransceiveTime",
    "container": "LimitedBandwidth",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "46-54",
    "snippet": "void LimitedBandwidth::ComputeNextTransceiveTime()\n{\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (unsigned int i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\tm_nextTransceiveTime =\n\t\t(total < m_maxBytesPerSecond) ? curTime : m_ops.front().first + 1000;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ops.front",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ops.size",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurTimeAndCleanUp",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurTimeAndCleanUp",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "56-65",
          "snippet": "double LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  double LimitedBandwidth::GetCurTimeAndCleanUp()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn 0;\n  \n  \tdouble curTime = m_timer.ElapsedTimeAsDouble();\n  \twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n  \t\tm_ops.pop_front();\n  \treturn curTime;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::ComputeNextTransceiveTime()\n  {\n  \tdouble curTime = GetCurTimeAndCleanUp();\n  \tlword total = 0;\n  \tfor (unsigned int i=0; i!=m_ops.size(); ++i)\n  \t\ttotal += m_ops[i].second;\n  \tm_nextTransceiveTime =\n  \t\t(total < m_maxBytesPerSecond) ? curTime : m_ops.front().first + 1000;\n  }\n}"
  },
  {
    "function_name": "NoteTransceive",
    "container": "LimitedBandwidth",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "36-44",
    "snippet": "void LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ops.push_back",
          "args": [
            "std::make_pair(curTime, size)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "curTime",
            "size"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurTimeAndCleanUp",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurTimeAndCleanUp",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "56-65",
          "snippet": "double LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  double LimitedBandwidth::GetCurTimeAndCleanUp()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn 0;\n  \n  \tdouble curTime = m_timer.ElapsedTimeAsDouble();\n  \twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n  \t\tm_ops.pop_front();\n  \treturn curTime;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::NoteTransceive(lword size)\n  {\n  \tif (m_maxBytesPerSecond)\n  \t{\n  \t\tdouble curTime = GetCurTimeAndCleanUp();\n  \t\tm_ops.push_back(std::make_pair(curTime, size));\n  \t\tm_nextTransceiveTime = 0;\n  \t}\n  }\n}"
  },
  {
    "function_name": "TimeToNextTransceive",
    "container": "LimitedBandwidth",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "25-34",
    "snippet": "double LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "m_nextTransceiveTime",
            "m_timer.ElapsedTimeAsDouble()"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_timer.ElapsedTimeAsDouble",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "ElapsedTimeAsDouble",
          "container": "TimerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/hrtimer.cpp",
          "lines": "37-52",
          "snippet": "double TimerBase::ElapsedTimeAsDouble()\n{\n\tif (m_stuckAtZero)\n\t\treturn 0;\n\n\tif (m_started)\n\t{\n\t\tTimerWord now = GetCurrentTimerValue();\n\t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n\t\t\tm_last = now;\n\t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n\t}\n\n\tStartTimer();\n\treturn 0;\n}",
          "includes": [
            "#include <assert.h>",
            "#include <unistd.h>",
            "#include <sys/times.h>",
            "#include <sys/time.h>",
            "#include <windows.h>",
            "#include <time.h>",
            "#include <stddef.h>\t\t// for NULL",
            "#include \"misc.h\"",
            "#include \"hrtimer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include <unistd.h>\n#include <sys/times.h>\n#include <sys/time.h>\n#include <windows.h>\n#include <time.h>\n#include <stddef.h>\t\t// for NULL\n#include \"misc.h\"\n#include \"hrtimer.h\"\n#include \"pch.h\"\n\nTimerBase {\n  double TimerBase::ElapsedTimeAsDouble()\n  {\n  \tif (m_stuckAtZero)\n  \t\treturn 0;\n  \n  \tif (m_started)\n  \t{\n  \t\tTimerWord now = GetCurrentTimerValue();\n  \t\tif (m_last < now)\t// protect against OS bugs where time goes backwards\n  \t\t\tm_last = now;\n  \t\treturn ConvertTo(m_last - m_start, m_timerUnit);\n  \t}\n  \n  \tStartTimer();\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeNextTransceiveTime",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeNextTransceiveTime",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "46-54",
          "snippet": "void LimitedBandwidth::ComputeNextTransceiveTime()\n{\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (unsigned int i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\tm_nextTransceiveTime =\n\t\t(total < m_maxBytesPerSecond) ? curTime : m_ops.front().first + 1000;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  void LimitedBandwidth::ComputeNextTransceiveTime()\n  {\n  \tdouble curTime = GetCurTimeAndCleanUp();\n  \tlword total = 0;\n  \tfor (unsigned int i=0; i!=m_ops.size(); ++i)\n  \t\ttotal += m_ops[i].second;\n  \tm_nextTransceiveTime =\n  \t\t(total < m_maxBytesPerSecond) ? curTime : m_ops.front().first + 1000;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  double LimitedBandwidth::TimeToNextTransceive()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn 0;\n  \n  \tif (!m_nextTransceiveTime)\n  \t\tComputeNextTransceiveTime();\n  \n  \treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n  }\n}"
  },
  {
    "function_name": "ComputeCurrentTransceiveLimit",
    "container": "LimitedBandwidth",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "13-23",
    "snippet": "lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "m_maxBytesPerSecond",
            "total"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_ops.size",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurTimeAndCleanUp",
          "args": [],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurTimeAndCleanUp",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "56-65",
          "snippet": "double LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  double LimitedBandwidth::GetCurTimeAndCleanUp()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn 0;\n  \n  \tdouble curTime = m_timer.ElapsedTimeAsDouble();\n  \twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n  \t\tm_ops.pop_front();\n  \treturn curTime;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nLimitedBandwidth {\n  lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n  {\n  \tif (!m_maxBytesPerSecond)\n  \t\treturn ULONG_MAX;\n  \n  \tdouble curTime = GetCurTimeAndCleanUp();\n  \tlword total = 0;\n  \tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n  \t\ttotal += m_ops[i].second;\n  \treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n  }\n}"
  }
]