[
  {
    "function_name": "NetworkSink::DoFlush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "474-546",
    "snippet": "lword NetworkSink::DoFlush(unsigned long maxTime, size_t targetSize)\n{\n\tNetworkSender &sender = AccessSender();\n\n\tbool forever = maxTime == INFINITE_TIME;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tunsigned int totalFlushSize = 0;\n\n\twhile (true)\n\t{\n\t\tif (m_buffer.CurrentSize() <= targetSize)\n\t\t\tbreak;\n\t\t\n\t\tif (m_needSendResult)\n\t\t{\n\t\t\tif (sender.MustWaitForResult() &&\n\t\t\t\t!sender.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\tCallStack(\"NetworkSink::DoFlush() - wait send result\", 0)))\n\t\t\t\tbreak;\n\n\t\t\tunsigned int sendResult = sender.GetSendResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sent \" + IntToString(sendResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\tm_buffer.Skip(sendResult);\n\t\t\ttotalFlushSize += sendResult;\n\t\t\tm_needSendResult = false;\n\n\t\t\tif (!m_buffer.AnyRetrievable())\n\t\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n\t\tif (sender.MustWaitToSend() && !sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait send\", 0)))\n\t\t\tbreak;\n\n\t\tsize_t contiguousSize = 0;\n\t\tconst byte *block = m_buffer.Spy(contiguousSize);\n\n#if CRYPTOPP_TRACE_NETWORK\n\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sending \" + IntToString(contiguousSize) + \" bytes\\n\").c_str());\n#endif\n\t\tsender.Send(block, contiguousSize);\n\t\tm_needSendResult = true;\n\n\t\tif (maxTime > 0 && timeOut == 0)\n\t\t\tbreak;\t// once time limit is reached, return even if there is more data waiting\n\t}\n\n\tm_byteCountSinceLastTimerReset += totalFlushSize;\n\tComputeCurrentSpeed();\n\t\n\tif (m_buffer.IsEmpty() && !m_needSendResult)\n\t{\n\t\tif (m_eofState == EOF_PENDING_SEND)\n\t\t{\n\t\t\tsender.SendEof();\n\t\t\tm_eofState = sender.MustWaitForEof() ? EOF_PENDING_DELIVERY : EOF_DONE;\n\t\t}\n\n\t\twhile (m_eofState == EOF_PENDING_DELIVERY)\n\t\t{\n\t\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n\t\t\tif (!sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait EOF\", 0)))\n\t\t\t\tbreak;\n\n\t\t\tif (sender.EofSent())\n\t\t\t\tm_eofState = EOF_DONE;\n\t\t}\n\t}\n\n\treturn totalFlushSize;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_TRACE_NETWORK 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sender.EofSent",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.Wait",
          "args": [
            "timeOut",
            "CallStack(\"NetworkSink::DoFlush() - wait EOF\", 0)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NetworkSink::DoFlush() - wait EOF\"",
            "0"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "maxTime",
            "timer.ElapsedTime()"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.MustWaitForEof",
          "args": [],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitForEof",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "168-168",
          "snippet": "bool MustWaitForEof() { return true; }",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSender {\n  bool MustWaitForEof() { return true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sender.SendEof",
          "args": [],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "SendEof",
          "container": "SocketSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "213-213",
          "snippet": "void SendEof() {ShutDown(SD_SEND);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSink {\n  void SendEof() {ShutDown(SD_SEND);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.IsEmpty",
          "args": [],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ComputeCurrentSpeed",
          "args": [],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "NetworkSink::ComputeCurrentSpeed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "382-393",
          "snippet": "float NetworkSink::ComputeCurrentSpeed()\n{\n\tif (m_speedTimer.ElapsedTime() > 1000)\n\t{\n\t\tm_currentSpeed = m_byteCountSinceLastTimerReset * 1000 / m_speedTimer.ElapsedTime();\n\t\tm_maxObservedSpeed = STDMAX(m_currentSpeed, m_maxObservedSpeed * 0.98f);\n\t\tm_byteCountSinceLastTimerReset = 0;\n\t\tm_speedTimer.StartTimer();\n//\t\tOutputDebugString((\"max speed: \" + IntToString((int)m_maxObservedSpeed) + \" current speed: \" + IntToString((int)m_currentSpeed) + \"\\n\").c_str());\n\t}\n\treturn m_currentSpeed;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nfloat NetworkSink::ComputeCurrentSpeed()\n{\n\tif (m_speedTimer.ElapsedTime() > 1000)\n\t{\n\t\tm_currentSpeed = m_byteCountSinceLastTimerReset * 1000 / m_speedTimer.ElapsedTime();\n\t\tm_maxObservedSpeed = STDMAX(m_currentSpeed, m_maxObservedSpeed * 0.98f);\n\t\tm_byteCountSinceLastTimerReset = 0;\n\t\tm_speedTimer.StartTimer();\n//\t\tOutputDebugString((\"max speed: \" + IntToString((int)m_maxObservedSpeed) + \" current speed: \" + IntToString((int)m_currentSpeed) + \"\\n\").c_str());\n\t}\n\treturn m_currentSpeed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sender.Send",
          "args": [
            "block",
            "contiguousSize"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Sending \" + IntToString(contiguousSize) + \" bytes\\n\").c_str()"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "contiguousSize"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.Spy",
          "args": [
            "contiguousSize"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.Wait",
          "args": [
            "timeOut",
            "CallStack(\"NetworkSink::DoFlush() - wait send\", 0)"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.MustWaitToSend",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitToSend",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "164-164",
          "snippet": "bool MustWaitToSend() {return true;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSender {\n  bool MustWaitToSend() {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.AnyRetrievable",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.Skip",
          "args": [
            "sendResult"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "Skip",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "111-116",
          "snippet": "inline size_t Skip(size_t skipMax)\n\t{\n\t\tsize_t len = STDMIN(skipMax, m_tail-m_head);\n\t\tm_head += len;\n\t\treturn len;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t Skip(size_t skipMax)\n  \t{\n  \t\tsize_t len = STDMIN(skipMax, m_tail-m_head);\n  \t\tm_head += len;\n  \t\treturn len;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Sent \" + IntToString(sendResult) + \" bytes\\n\").c_str()"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.GetSendResult",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.Wait",
          "args": [
            "SaturatingSubtract(maxTime, timer.ElapsedTime())",
            "CallStack(\"NetworkSink::DoFlush() - wait send result\", 0)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sender.MustWaitForResult",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitForResult",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "167-167",
          "snippet": "bool MustWaitForResult() {return true;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSender {\n  bool MustWaitForResult() {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.CurrentSize",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentSize",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "27-30",
          "snippet": "inline size_t CurrentSize() const\n\t{\n\t\treturn m_tail-m_head;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t CurrentSize() const\n  \t{\n  \t\treturn m_tail-m_head;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\n#define CRYPTOPP_TRACE_NETWORK 0\n\nlword NetworkSink::DoFlush(unsigned long maxTime, size_t targetSize)\n{\n\tNetworkSender &sender = AccessSender();\n\n\tbool forever = maxTime == INFINITE_TIME;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tunsigned int totalFlushSize = 0;\n\n\twhile (true)\n\t{\n\t\tif (m_buffer.CurrentSize() <= targetSize)\n\t\t\tbreak;\n\t\t\n\t\tif (m_needSendResult)\n\t\t{\n\t\t\tif (sender.MustWaitForResult() &&\n\t\t\t\t!sender.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\tCallStack(\"NetworkSink::DoFlush() - wait send result\", 0)))\n\t\t\t\tbreak;\n\n\t\t\tunsigned int sendResult = sender.GetSendResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sent \" + IntToString(sendResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\tm_buffer.Skip(sendResult);\n\t\t\ttotalFlushSize += sendResult;\n\t\t\tm_needSendResult = false;\n\n\t\t\tif (!m_buffer.AnyRetrievable())\n\t\t\t\tbreak;\n\t\t}\n\n\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n\t\tif (sender.MustWaitToSend() && !sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait send\", 0)))\n\t\t\tbreak;\n\n\t\tsize_t contiguousSize = 0;\n\t\tconst byte *block = m_buffer.Spy(contiguousSize);\n\n#if CRYPTOPP_TRACE_NETWORK\n\t\tOutputDebugString((IntToString((unsigned int)this) + \": Sending \" + IntToString(contiguousSize) + \" bytes\\n\").c_str());\n#endif\n\t\tsender.Send(block, contiguousSize);\n\t\tm_needSendResult = true;\n\n\t\tif (maxTime > 0 && timeOut == 0)\n\t\t\tbreak;\t// once time limit is reached, return even if there is more data waiting\n\t}\n\n\tm_byteCountSinceLastTimerReset += totalFlushSize;\n\tComputeCurrentSpeed();\n\t\n\tif (m_buffer.IsEmpty() && !m_needSendResult)\n\t{\n\t\tif (m_eofState == EOF_PENDING_SEND)\n\t\t{\n\t\t\tsender.SendEof();\n\t\t\tm_eofState = sender.MustWaitForEof() ? EOF_PENDING_DELIVERY : EOF_DONE;\n\t\t}\n\n\t\twhile (m_eofState == EOF_PENDING_DELIVERY)\n\t\t{\n\t\t\tunsigned long timeOut = maxTime ? SaturatingSubtract(maxTime, timer.ElapsedTime()) : 0;\n\t\t\tif (!sender.Wait(timeOut, CallStack(\"NetworkSink::DoFlush() - wait EOF\", 0)))\n\t\t\t\tbreak;\n\n\t\t\tif (sender.EofSent())\n\t\t\t\tm_eofState = EOF_DONE;\n\t\t}\n\t}\n\n\treturn totalFlushSize;\n}"
  },
  {
    "function_name": "NetworkSink::Put2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "418-472",
    "snippet": "size_t NetworkSink::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\tif (m_eofState == EOF_DONE)\n\t{\n\t\tif (length || messageEnd)\n\t\t\tthrow Exception(Exception::OTHER_ERROR, \"NetworkSink::Put2() being called after EOF had been sent\");\n\n\t\treturn 0;\n\t}\n\n\tif (m_eofState > EOF_NONE)\n\t\tgoto EofSite;\n\n\t{\n\t\tif (m_skipBytes)\n\t\t{\n\t\t\tassert(length >= m_skipBytes);\n\t\t\tinString += m_skipBytes;\n\t\t\tlength -= m_skipBytes;\n\t\t}\n\n\t\tm_buffer.Put(inString, length);\n\n\t\tif (!blocking || m_buffer.CurrentSize() > m_autoFlushBound)\n\t\t\tTimedFlush(0, 0);\n\n\t\tsize_t targetSize = messageEnd ? 0 : m_maxBufferSize;\n\t\tif (blocking)\n\t\t\tTimedFlush(INFINITE_TIME, targetSize);\n\n\t\tif (m_buffer.CurrentSize() > targetSize)\n\t\t{\n\t\t\tassert(!blocking);\n\t\t\tm_wasBlocked = true;\n\t\t\tm_skipBytes += length;\n\t\t\tsize_t blockedBytes = UnsignedMin(length, m_buffer.CurrentSize() - targetSize);\n\t\t\treturn STDMAX<size_t>(blockedBytes, 1);\n\t\t}\n\n\t\tm_wasBlocked = false;\n\t\tm_skipBytes = 0;\n\t}\n\n\tif (messageEnd)\n\t{\n\t\tm_eofState = EOF_PENDING_SEND;\n\n\tEofSite:\n\t\tTimedFlush(blocking ? INFINITE_TIME : 0, 0);\n\t\tif (m_eofState != EOF_DONE)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TimedFlush",
          "args": [
            "blocking ? INFINITE_TIME : 0",
            "0"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMAX<size_t>",
          "args": [
            "blockedBytes",
            "1"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "length",
            "m_buffer.CurrentSize() - targetSize"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.CurrentSize",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentSize",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "27-30",
          "snippet": "inline size_t CurrentSize() const\n\t{\n\t\treturn m_tail-m_head;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t CurrentSize() const\n  \t{\n  \t\treturn m_tail-m_head;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!blocking"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimedFlush",
          "args": [
            "INFINITE_TIME",
            "targetSize"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimedFlush",
          "args": [
            "0",
            "0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.Put",
          "args": [
            "inString",
            "length"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "42-49",
          "snippet": "inline size_t Put(const byte *begin, size_t length)\n\t{\n\t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n\t\tif (buf+m_tail != begin)\n\t\t\tmemcpy(buf+m_tail, begin, l);\n\t\tm_tail += l;\n\t\treturn l;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t Put(const byte *begin, size_t length)\n  \t{\n  \t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n  \t\tif (buf+m_tail != begin)\n  \t\t\tmemcpy(buf+m_tail, begin, l);\n  \t\tm_tail += l;\n  \t\treturn l;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length >= m_skipBytes"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"NetworkSink::Put2() being called after EOF had been sent\""
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nsize_t NetworkSink::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\tif (m_eofState == EOF_DONE)\n\t{\n\t\tif (length || messageEnd)\n\t\t\tthrow Exception(Exception::OTHER_ERROR, \"NetworkSink::Put2() being called after EOF had been sent\");\n\n\t\treturn 0;\n\t}\n\n\tif (m_eofState > EOF_NONE)\n\t\tgoto EofSite;\n\n\t{\n\t\tif (m_skipBytes)\n\t\t{\n\t\t\tassert(length >= m_skipBytes);\n\t\t\tinString += m_skipBytes;\n\t\t\tlength -= m_skipBytes;\n\t\t}\n\n\t\tm_buffer.Put(inString, length);\n\n\t\tif (!blocking || m_buffer.CurrentSize() > m_autoFlushBound)\n\t\t\tTimedFlush(0, 0);\n\n\t\tsize_t targetSize = messageEnd ? 0 : m_maxBufferSize;\n\t\tif (blocking)\n\t\t\tTimedFlush(INFINITE_TIME, targetSize);\n\n\t\tif (m_buffer.CurrentSize() > targetSize)\n\t\t{\n\t\t\tassert(!blocking);\n\t\t\tm_wasBlocked = true;\n\t\t\tm_skipBytes += length;\n\t\t\tsize_t blockedBytes = UnsignedMin(length, m_buffer.CurrentSize() - targetSize);\n\t\t\treturn STDMAX<size_t>(blockedBytes, 1);\n\t\t}\n\n\t\tm_wasBlocked = false;\n\t\tm_skipBytes = 0;\n\t}\n\n\tif (messageEnd)\n\t{\n\t\tm_eofState = EOF_PENDING_SEND;\n\n\tEofSite:\n\t\tTimedFlush(blocking ? INFINITE_TIME : 0, 0);\n\t\tif (m_eofState != EOF_DONE)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "NetworkSink::GetWaitObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "406-416",
    "snippet": "void NetworkSink::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (BlockedBySpeedLimit())\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - speed limit\", &callStack));\n\telse if (m_wasBlocked)\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - was blocked\", &callStack));\n\telse if (!m_buffer.IsEmpty())\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - buffer not empty\", &callStack));\n\telse if (EofPending())\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - EOF pending\", &callStack));\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [
            "container",
            "CallStack(\"NetworkSink::GetWaitObjects() - EOF pending\", &callStack)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NetworkSink::GetWaitObjects() - EOF pending\"",
            "&callStack"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [
            "container",
            "CallStack(\"NetworkSink::GetWaitObjects() - buffer not empty\", &callStack)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.IsEmpty",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [
            "container",
            "CallStack(\"NetworkSink::GetWaitObjects() - was blocked\", &callStack)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessSender",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetWaitObjects",
          "args": [
            "container",
            "CallStack(\"NetworkSink::GetWaitObjects() - speed limit\", &callStack)"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::GetWaitObjects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "67-72",
          "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockedBySpeedLimit",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "BlockedBySpeedLimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "145-145",
          "snippet": "bool BlockedBySpeedLimit() const { return m_blockedBySpeedLimit; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nbool BlockedBySpeedLimit() const { return m_blockedBySpeedLimit; }"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid NetworkSink::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (BlockedBySpeedLimit())\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - speed limit\", &callStack));\n\telse if (m_wasBlocked)\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - was blocked\", &callStack));\n\telse if (!m_buffer.IsEmpty())\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - buffer not empty\", &callStack));\n\telse if (EofPending())\n\t\tAccessSender().GetWaitObjects(container, CallStack(\"NetworkSink::GetWaitObjects() - EOF pending\", &callStack));\n}"
  },
  {
    "function_name": "NetworkSink::GetMaxWaitObjectCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "401-404",
    "snippet": "unsigned int NetworkSink::GetMaxWaitObjectCount() const\n{\n\treturn LimitedBandwidth::GetMaxWaitObjectCount() + GetSender().GetMaxWaitObjectCount();\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetSender",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSender",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetMaxWaitObjectCount",
          "args": [],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxWaitObjectCount",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "38-38",
          "snippet": "unsigned int GetMaxWaitObjectCount() const { return 0; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nLimitedBandwidth {\n  unsigned int GetMaxWaitObjectCount() const { return 0; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nunsigned int NetworkSink::GetMaxWaitObjectCount() const\n{\n\treturn LimitedBandwidth::GetMaxWaitObjectCount() + GetSender().GetMaxWaitObjectCount();\n}"
  },
  {
    "function_name": "NetworkSink::GetMaxObservedSpeed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "395-399",
    "snippet": "float NetworkSink::GetMaxObservedSpeed() const\n{\n\tlword m = GetMaxBytesPerSecond();\n\treturn m ? STDMIN(m_maxObservedSpeed, float(CRYPTOPP_VC6_INT64 m)) : m_maxObservedSpeed;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "m_maxObservedSpeed",
            "float(CRYPTOPP_VC6_INT64 m)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "float",
          "args": [
            "CRYPTOPP_VC6_INT64m"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxBytesPerSecond",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxBytesPerSecond",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "23-24",
          "snippet": "lword GetMaxBytesPerSecond() const\n\t\t{ return m_maxBytesPerSecond; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nLimitedBandwidth {\n  lword GetMaxBytesPerSecond() const\n  \t\t{ return m_maxBytesPerSecond; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nfloat NetworkSink::GetMaxObservedSpeed() const\n{\n\tlword m = GetMaxBytesPerSecond();\n\treturn m ? STDMIN(m_maxObservedSpeed, float(CRYPTOPP_VC6_INT64 m)) : m_maxObservedSpeed;\n}"
  },
  {
    "function_name": "NetworkSink::ComputeCurrentSpeed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "382-393",
    "snippet": "float NetworkSink::ComputeCurrentSpeed()\n{\n\tif (m_speedTimer.ElapsedTime() > 1000)\n\t{\n\t\tm_currentSpeed = m_byteCountSinceLastTimerReset * 1000 / m_speedTimer.ElapsedTime();\n\t\tm_maxObservedSpeed = STDMAX(m_currentSpeed, m_maxObservedSpeed * 0.98f);\n\t\tm_byteCountSinceLastTimerReset = 0;\n\t\tm_speedTimer.StartTimer();\n//\t\tOutputDebugString((\"max speed: \" + IntToString((int)m_maxObservedSpeed) + \" current speed: \" + IntToString((int)m_currentSpeed) + \"\\n\").c_str());\n\t}\n\treturn m_currentSpeed;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_speedTimer.StartTimer",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMAX",
          "args": [
            "m_currentSpeed",
            "m_maxObservedSpeed * 0.98f"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_speedTimer.ElapsedTime",
          "args": [],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_speedTimer.ElapsedTime",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nfloat NetworkSink::ComputeCurrentSpeed()\n{\n\tif (m_speedTimer.ElapsedTime() > 1000)\n\t{\n\t\tm_currentSpeed = m_byteCountSinceLastTimerReset * 1000 / m_speedTimer.ElapsedTime();\n\t\tm_maxObservedSpeed = STDMAX(m_currentSpeed, m_maxObservedSpeed * 0.98f);\n\t\tm_byteCountSinceLastTimerReset = 0;\n\t\tm_speedTimer.StartTimer();\n//\t\tOutputDebugString((\"max speed: \" + IntToString((int)m_maxObservedSpeed) + \" current speed: \" + IntToString((int)m_currentSpeed) + \"\\n\").c_str());\n\t}\n\treturn m_currentSpeed;\n}"
  },
  {
    "function_name": "NetworkSink::NetworkSink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "373-380",
    "snippet": "NetworkSink::NetworkSink(unsigned int maxBufferSize, unsigned int autoFlushBound)\n\t: m_maxBufferSize(maxBufferSize), m_autoFlushBound(autoFlushBound)\n\t, m_needSendResult(false), m_wasBlocked(false), m_eofState(EOF_NONE)\n\t, m_buffer(STDMIN(16U*1024U+256, maxBufferSize)), m_skipBytes(0) \n\t, m_speedTimer(Timer::MILLISECONDS), m_byteCountSinceLastTimerReset(0)\n\t, m_currentSpeed(0), m_maxObservedSpeed(0)\n{\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "16U*1024U+256",
            "maxBufferSize"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSink::NetworkSink(unsigned int maxBufferSize, unsigned int autoFlushBound)\n\t: m_maxBufferSize(maxBufferSize), m_autoFlushBound(autoFlushBound)\n\t, m_needSendResult(false), m_wasBlocked(false), m_eofState(EOF_NONE)\n\t, m_buffer(STDMIN(16U*1024U+256, maxBufferSize)), m_skipBytes(0) \n\t, m_speedTimer(Timer::MILLISECONDS), m_byteCountSinceLastTimerReset(0)\n\t, m_currentSpeed(0), m_maxObservedSpeed(0)\n{\n}"
  },
  {
    "function_name": "NetworkSource::DoPump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "257-369",
    "snippet": "size_t NetworkSource::DoPump(lword &byteCount, bool blockingOutput, unsigned long maxTime, bool checkDelimiter, byte delimiter)\n{\n\tNetworkReceiver &receiver = AccessReceiver();\n\n\tlword maxSize = byteCount;\n\tbyteCount = 0;\n\tbool forever = maxTime == INFINITE_TIME;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tBufferedTransformation *t = AttachedTransformation();\n\n\tif (m_outputBlocked)\n\t\tgoto DoOutput;\n\n\twhile (true)\n\t{\n\t\tif (m_dataBegin == m_dataEnd)\n\t\t{\n\t\t\tif (receiver.EofReceived())\n\t\t\t\tbreak;\n\n\t\t\tif (m_waitingForResult)\n\t\t\t{\n\t\t\t\tif (receiver.MustWaitForResult() &&\n\t\t\t\t\t!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive result\", 0)))\n\t\t\t\t\tbreak;\n\n\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\tm_dataEnd += recvResult;\n\t\t\t\tm_waitingForResult = false;\n\n\t\t\t\tif (!receiver.MustWaitToReceive() && !receiver.EofReceived() && m_dataEnd != m_buf.size())\n\t\t\t\t\tgoto ReceiveNoWait;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_dataEnd = m_dataBegin = 0;\n\n\t\t\t\tif (receiver.MustWaitToReceive())\n\t\t\t\t{\n\t\t\t\t\tif (!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive\", 0)))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\treceiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd);\n\t\t\t\t\tm_waitingForResult = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\nReceiveNoWait:\n\t\t\t\t\tm_waitingForResult = true;\n\t\t\t\t\t// call Receive repeatedly as long as data is immediately available,\n\t\t\t\t\t// because some receivers tend to return data in small pieces\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Receiving \" + IntToString(m_buf.size()-m_dataEnd) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\t\twhile (receiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd))\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\t\t\tm_dataEnd += recvResult;\n\t\t\t\t\t\tif (receiver.EofReceived() || m_dataEnd > m_buf.size() /2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_waitingForResult = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_putSize = UnsignedMin(m_dataEnd - m_dataBegin, maxSize - byteCount);\n\n\t\t\tif (checkDelimiter)\n\t\t\t\tm_putSize = std::find(m_buf+m_dataBegin, m_buf+m_dataBegin+m_putSize, delimiter) - (m_buf+m_dataBegin);\n\nDoOutput:\n\t\t\tsize_t result = t->PutModifiable2(m_buf+m_dataBegin, m_putSize, 0, forever || blockingOutput);\n\t\t\tif (result)\n\t\t\t{\n\t\t\t\tif (t->Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait attachment\", 0)))\n\t\t\t\t\tgoto DoOutput;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_outputBlocked = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_outputBlocked = false;\n\n\t\t\tbyteCount += m_putSize;\n\t\t\tm_dataBegin += m_putSize;\n\t\t\tif (checkDelimiter && m_dataBegin < m_dataEnd && m_buf[m_dataBegin] == delimiter)\n\t\t\t\tbreak;\n\t\t\tif (maxSize != ULONG_MAX && byteCount == maxSize)\n\t\t\t\tbreak;\n\t\t\t// once time limit is reached, return even if there is more data waiting\n\t\t\t// but make 0 a special case so caller can request a large amount of data to be\n\t\t\t// pumped as long as it is immediately available\n\t\t\tif (maxTime > 0 && timer.ElapsedTime() > maxTime)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_TRACE_NETWORK 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->Wait",
          "args": [
            "SaturatingSubtract(maxTime, timer.ElapsedTime())",
            "CallStack(\"NetworkSource::DoPump() - wait attachment\", 0)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NetworkSource::DoPump() - wait attachment\"",
            "0"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "maxTime",
            "timer.ElapsedTime()"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->PutModifiable2",
          "args": [
            "m_buf+m_dataBegin",
            "m_putSize",
            "0",
            "forever || blockingOutput"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "PutModifiable2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "817-818",
          "snippet": "virtual size_t PutModifiable2(byte *inString, size_t length, int messageEnd, bool blocking)\n\t\t\t{return Put2(inString, length, messageEnd, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual size_t PutModifiable2(byte *inString, size_t length, int messageEnd, bool blocking)\n\t\t\t{return Put2(inString, length, messageEnd, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "std::find",
          "args": [
            "m_buf+m_dataBegin",
            "m_buf+m_dataBegin+m_putSize",
            "delimiter"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "m_dataEnd - m_dataBegin",
            "maxSize - byteCount"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buf.size",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "receiver.EofReceived",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "EofReceived",
          "container": "SocketReceiver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "139-139",
          "snippet": "bool EofReceived() const {return m_eofReceived;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketReceiver {\n  bool EofReceived() const {return m_eofReceived;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "recvResult"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "receiver.GetReceiveResult",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.Receive",
          "args": [
            "m_buf+m_dataEnd",
            "m_buf.size()-m_dataEnd"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Receiving \" + IntToString(m_buf.size()-m_dataEnd) + \" bytes\\n\").c_str()"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.Receive",
          "args": [
            "m_buf+m_dataEnd",
            "m_buf.size()-m_dataEnd"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.Wait",
          "args": [
            "SaturatingSubtract(maxTime, timer.ElapsedTime())",
            "CallStack(\"NetworkSource::DoPump() - wait receive\", 0)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.MustWaitToReceive",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitToReceive",
          "container": "SocketReceiver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "132-132",
          "snippet": "bool MustWaitToReceive() {return true;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketReceiver {\n  bool MustWaitToReceive() {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str()"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.GetReceiveResult",
          "args": [],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.Wait",
          "args": [
            "SaturatingSubtract(maxTime, timer.ElapsedTime())",
            "CallStack(\"NetworkSource::DoPump() - wait receive result\", 0)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "receiver.MustWaitForResult",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "MustWaitForResult",
          "container": "SocketSender",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "167-167",
          "snippet": "bool MustWaitForResult() {return true;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocketSender {\n  bool MustWaitForResult() {return true;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessReceiver",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\n#define CRYPTOPP_TRACE_NETWORK 0\n\nsize_t NetworkSource::DoPump(lword &byteCount, bool blockingOutput, unsigned long maxTime, bool checkDelimiter, byte delimiter)\n{\n\tNetworkReceiver &receiver = AccessReceiver();\n\n\tlword maxSize = byteCount;\n\tbyteCount = 0;\n\tbool forever = maxTime == INFINITE_TIME;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tBufferedTransformation *t = AttachedTransformation();\n\n\tif (m_outputBlocked)\n\t\tgoto DoOutput;\n\n\twhile (true)\n\t{\n\t\tif (m_dataBegin == m_dataEnd)\n\t\t{\n\t\t\tif (receiver.EofReceived())\n\t\t\t\tbreak;\n\n\t\t\tif (m_waitingForResult)\n\t\t\t{\n\t\t\t\tif (receiver.MustWaitForResult() &&\n\t\t\t\t\t!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive result\", 0)))\n\t\t\t\t\tbreak;\n\n\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\tm_dataEnd += recvResult;\n\t\t\t\tm_waitingForResult = false;\n\n\t\t\t\tif (!receiver.MustWaitToReceive() && !receiver.EofReceived() && m_dataEnd != m_buf.size())\n\t\t\t\t\tgoto ReceiveNoWait;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_dataEnd = m_dataBegin = 0;\n\n\t\t\t\tif (receiver.MustWaitToReceive())\n\t\t\t\t{\n\t\t\t\t\tif (!receiver.Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait receive\", 0)))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\treceiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd);\n\t\t\t\t\tm_waitingForResult = true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\nReceiveNoWait:\n\t\t\t\t\tm_waitingForResult = true;\n\t\t\t\t\t// call Receive repeatedly as long as data is immediately available,\n\t\t\t\t\t// because some receivers tend to return data in small pieces\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Receiving \" + IntToString(m_buf.size()-m_dataEnd) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\t\twhile (receiver.Receive(m_buf+m_dataEnd, m_buf.size()-m_dataEnd))\n\t\t\t\t\t{\n\t\t\t\t\t\tunsigned int recvResult = receiver.GetReceiveResult();\n#if CRYPTOPP_TRACE_NETWORK\n\t\t\t\t\t\tOutputDebugString((IntToString((unsigned int)this) + \": Received \" + IntToString(recvResult) + \" bytes\\n\").c_str());\n#endif\n\t\t\t\t\t\tm_dataEnd += recvResult;\n\t\t\t\t\t\tif (receiver.EofReceived() || m_dataEnd > m_buf.size() /2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_waitingForResult = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_putSize = UnsignedMin(m_dataEnd - m_dataBegin, maxSize - byteCount);\n\n\t\t\tif (checkDelimiter)\n\t\t\t\tm_putSize = std::find(m_buf+m_dataBegin, m_buf+m_dataBegin+m_putSize, delimiter) - (m_buf+m_dataBegin);\n\nDoOutput:\n\t\t\tsize_t result = t->PutModifiable2(m_buf+m_dataBegin, m_putSize, 0, forever || blockingOutput);\n\t\t\tif (result)\n\t\t\t{\n\t\t\t\tif (t->Wait(SaturatingSubtract(maxTime, timer.ElapsedTime()),\n\t\t\t\t\t\tCallStack(\"NetworkSource::DoPump() - wait attachment\", 0)))\n\t\t\t\t\tgoto DoOutput;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_outputBlocked = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_outputBlocked = false;\n\n\t\t\tbyteCount += m_putSize;\n\t\t\tm_dataBegin += m_putSize;\n\t\t\tif (checkDelimiter && m_dataBegin < m_dataEnd && m_buf[m_dataBegin] == delimiter)\n\t\t\t\tbreak;\n\t\t\tif (maxSize != ULONG_MAX && byteCount == maxSize)\n\t\t\t\tbreak;\n\t\t\t// once time limit is reached, return even if there is more data waiting\n\t\t\t// but make 0 a special case so caller can request a large amount of data to be\n\t\t\t// pumped as long as it is immediately available\n\t\t\tif (maxTime > 0 && timer.ElapsedTime() > maxTime)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "NetworkSource::GetWaitObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "242-255",
    "snippet": "void NetworkSource::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (BlockedBySpeedLimit())\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - speed limit\", &callStack));\n\telse if (!m_outputBlocked)\n\t{\n\t\tif (m_dataBegin == m_dataEnd)\n\t\t\tAccessReceiver().GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - no data\", &callStack)); \n\t\telse\n\t\t\tcontainer.SetNoWait(CallStack(\"NetworkSource::GetWaitObjects() - have data\", &callStack));\n\t}\n\n\tAttachedTransformation()->GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - attachment\", &callStack));\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "container",
            "CallStack(\"NetworkSource::GetWaitObjects() - attachment\", &callStack)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NetworkSource::GetWaitObjects() - attachment\"",
            "&callStack"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container.SetNoWait",
          "args": [
            "CallStack(\"NetworkSource::GetWaitObjects() - have data\", &callStack)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessReceiver",
          "args": [
            "container",
            "CallStack(\"NetworkSource::GetWaitObjects() - no data\", &callStack)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessReceiver",
          "args": [],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetWaitObjects",
          "args": [
            "container",
            "CallStack(\"NetworkSource::GetWaitObjects() - speed limit\", &callStack)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::GetWaitObjects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "67-72",
          "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockedBySpeedLimit",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "BlockedBySpeedLimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "145-145",
          "snippet": "bool BlockedBySpeedLimit() const { return m_blockedBySpeedLimit; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nbool BlockedBySpeedLimit() const { return m_blockedBySpeedLimit; }"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid NetworkSource::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (BlockedBySpeedLimit())\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - speed limit\", &callStack));\n\telse if (!m_outputBlocked)\n\t{\n\t\tif (m_dataBegin == m_dataEnd)\n\t\t\tAccessReceiver().GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - no data\", &callStack)); \n\t\telse\n\t\t\tcontainer.SetNoWait(CallStack(\"NetworkSource::GetWaitObjects() - have data\", &callStack));\n\t}\n\n\tAttachedTransformation()->GetWaitObjects(container, CallStack(\"NetworkSource::GetWaitObjects() - attachment\", &callStack));\n}"
  },
  {
    "function_name": "NetworkSource::GetMaxWaitObjectCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "235-240",
    "snippet": "unsigned int NetworkSource::GetMaxWaitObjectCount() const\n{\n\treturn LimitedBandwidth::GetMaxWaitObjectCount()\n\t\t+ GetReceiver().GetMaxWaitObjectCount()\n\t\t+ AttachedTransformation()->GetMaxWaitObjectCount();\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetReceiver",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetReceiver",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetMaxWaitObjectCount",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxWaitObjectCount",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "38-38",
          "snippet": "unsigned int GetMaxWaitObjectCount() const { return 0; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nLimitedBandwidth {\n  unsigned int GetMaxWaitObjectCount() const { return 0; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nunsigned int NetworkSource::GetMaxWaitObjectCount() const\n{\n\treturn LimitedBandwidth::GetMaxWaitObjectCount()\n\t\t+ GetReceiver().GetMaxWaitObjectCount()\n\t\t+ AttachedTransformation()->GetMaxWaitObjectCount();\n}"
  },
  {
    "function_name": "NetworkSource::NetworkSource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "228-233",
    "snippet": "NetworkSource::NetworkSource(BufferedTransformation *attachment)\n\t: NonblockingSource(attachment), m_buf(1024*16)\n\t, m_dataBegin(0), m_dataEnd(0)\n\t, m_waitingForResult(false), m_outputBlocked(false)\n{\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nNetworkSource::NetworkSource(BufferedTransformation *attachment)\n\t: NonblockingSource(attachment), m_buf(1024*16)\n\t, m_dataBegin(0), m_dataEnd(0)\n\t, m_waitingForResult(false), m_outputBlocked(false)\n{\n}"
  },
  {
    "function_name": "NonblockingSink::IsolatedFlush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "220-224",
    "snippet": "bool NonblockingSink::IsolatedFlush(bool hardFlush, bool blocking)\n{\n\tTimedFlush(blocking ? INFINITE_TIME : 0);\n\treturn hardFlush && (!!GetCurrentBufferSize() || EofPending());\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentBufferSize",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimedFlush",
          "args": [
            "blocking ? INFINITE_TIME : 0"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nbool NonblockingSink::IsolatedFlush(bool hardFlush, bool blocking)\n{\n\tTimedFlush(blocking ? INFINITE_TIME : 0);\n\treturn hardFlush && (!!GetCurrentBufferSize() || EofPending());\n}"
  },
  {
    "function_name": "NonblockingSink::TimedFlush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "162-218",
    "snippet": "lword NonblockingSink::TimedFlush(unsigned long maxTime, size_t targetSize)\n{\n\tm_blockedBySpeedLimit = false;\n\n\tsize_t curBufSize = GetCurrentBufferSize();\n\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n\t\treturn 0;\n\n\tif (!GetMaxBytesPerSecond())\n\t\treturn DoFlush(maxTime, targetSize);\n\n\tbool forever = (maxTime == INFINITE_TIME);\n\tunsigned long timeToGo = maxTime;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tlword totalFlushed = 0;\n\n\ttimer.StartTimer();\n\n\twhile (true)\n\t{\t\n\t\tsize_t flushSize = UnsignedMin(curBufSize - targetSize, ComputeCurrentTransceiveLimit());\n\t\tif (flushSize || EofPending())\n\t\t{\n\t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tsize_t ret = (size_t)DoFlush(timeToGo, curBufSize - flushSize);\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\tNoteTransceive(ret);\n\t\t\t\tcurBufSize -= ret;\n\t\t\t\ttotalFlushed += ret;\n\t\t\t}\n\t\t}\n\n\t\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n\t\t\tbreak;\n\n\t\tif (!forever)\n\t\t{\n\t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tif (!timeToGo)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdouble waitTime = TimeToNextTransceive();\n\t\tif (!forever && waitTime > timeToGo)\n\t\t{\n\t\t\tm_blockedBySpeedLimit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tWaitObjectContainer container;\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSink::TimedFlush() - speed limit\", 0));\n\t\tcontainer.Wait((unsigned long)waitTime);\n\t}\n\n\treturn totalFlushed;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.Wait",
          "args": [
            "(unsigned long)waitTime"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetWaitObjects",
          "args": [
            "container",
            "CallStack(\"NonblockingSink::TimedFlush() - speed limit\", 0)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::GetWaitObjects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "67-72",
          "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NonblockingSink::TimedFlush() - speed limit\"",
            "0"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimeToNextTransceive",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::TimeToNextTransceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "25-34",
          "snippet": "double LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\ndouble LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "maxTime",
            "timer.ElapsedTime()"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NoteTransceive",
          "args": [
            "ret"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::NoteTransceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "36-44",
          "snippet": "void LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoFlush",
          "args": [
            "timeToGo",
            "curBufSize - flushSize"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "curBufSize - targetSize",
            "ComputeCurrentTransceiveLimit()"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeCurrentTransceiveLimit",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::ComputeCurrentTransceiveLimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "13-23",
          "snippet": "lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nlword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.StartTimer",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DoFlush",
          "args": [
            "maxTime",
            "targetSize"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxBytesPerSecond",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxBytesPerSecond",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "23-24",
          "snippet": "lword GetMaxBytesPerSecond() const\n\t\t{ return m_maxBytesPerSecond; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nLimitedBandwidth {\n  lword GetMaxBytesPerSecond() const\n  \t\t{ return m_maxBytesPerSecond; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EofPending",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentBufferSize",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nlword NonblockingSink::TimedFlush(unsigned long maxTime, size_t targetSize)\n{\n\tm_blockedBySpeedLimit = false;\n\n\tsize_t curBufSize = GetCurrentBufferSize();\n\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n\t\treturn 0;\n\n\tif (!GetMaxBytesPerSecond())\n\t\treturn DoFlush(maxTime, targetSize);\n\n\tbool forever = (maxTime == INFINITE_TIME);\n\tunsigned long timeToGo = maxTime;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tlword totalFlushed = 0;\n\n\ttimer.StartTimer();\n\n\twhile (true)\n\t{\t\n\t\tsize_t flushSize = UnsignedMin(curBufSize - targetSize, ComputeCurrentTransceiveLimit());\n\t\tif (flushSize || EofPending())\n\t\t{\n\t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tsize_t ret = (size_t)DoFlush(timeToGo, curBufSize - flushSize);\n\t\t\tif (ret)\n\t\t\t{\n\t\t\t\tNoteTransceive(ret);\n\t\t\t\tcurBufSize -= ret;\n\t\t\t\ttotalFlushed += ret;\n\t\t\t}\n\t\t}\n\n\t\tif (curBufSize <= targetSize && (targetSize || !EofPending()))\n\t\t\tbreak;\n\n\t\tif (!forever)\n\t\t{\n\t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tif (!timeToGo)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdouble waitTime = TimeToNextTransceive();\n\t\tif (!forever && waitTime > timeToGo)\n\t\t{\n\t\t\tm_blockedBySpeedLimit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tWaitObjectContainer container;\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSink::TimedFlush() - speed limit\", 0));\n\t\tcontainer.Wait((unsigned long)waitTime);\n\t}\n\n\treturn totalFlushed;\n}"
  },
  {
    "function_name": "NonblockingSource::PumpMessages2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "140-160",
    "snippet": "size_t NonblockingSource::PumpMessages2(unsigned int &messageCount, bool blocking)\n{\n\tif (messageCount == 0)\n\t\treturn 0;\n\n\tmessageCount = 0;\n\n\tlword byteCount;\n\tdo {\n\t\tbyteCount = LWORD_MAX;\n\t\tRETURN_IF_NONZERO(Pump2(byteCount, blocking));\n\t} while(byteCount == LWORD_MAX);\n\n\tif (!m_messageEndSent && SourceExhausted())\n\t{\n\t\tRETURN_IF_NONZERO(AttachedTransformation()->Put2(NULL, 0, GetAutoSignalPropagation(), true));\n\t\tm_messageEndSent = true;\n\t\tmessageCount = 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RETURN_IF_NONZERO",
          "args": [
            "AttachedTransformation()->Put2(NULL, 0, GetAutoSignalPropagation(), true)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "NULL",
            "0",
            "GetAutoSignalPropagation()",
            "true"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAutoSignalPropagation",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "GetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "860-860",
          "snippet": "virtual int GetAutoSignalPropagation() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual int GetAutoSignalPropagation() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SourceExhausted",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "SourceExhausted",
          "container": "SourceTemplate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "768-769",
          "snippet": "bool SourceExhausted() const\n\t\t{return !m_store.AnyRetrievable() && !m_store.AnyMessages();}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nSourceTemplate {\n  bool SourceExhausted() const\n  \t\t{return !m_store.AnyRetrievable() && !m_store.AnyMessages();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RETURN_IF_NONZERO",
          "args": [
            "Pump2(byteCount, blocking)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pump2",
          "args": [
            "byteCount",
            "blocking"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nsize_t NonblockingSource::PumpMessages2(unsigned int &messageCount, bool blocking)\n{\n\tif (messageCount == 0)\n\t\treturn 0;\n\n\tmessageCount = 0;\n\n\tlword byteCount;\n\tdo {\n\t\tbyteCount = LWORD_MAX;\n\t\tRETURN_IF_NONZERO(Pump2(byteCount, blocking));\n\t} while(byteCount == LWORD_MAX);\n\n\tif (!m_messageEndSent && SourceExhausted())\n\t{\n\t\tRETURN_IF_NONZERO(AttachedTransformation()->Put2(NULL, 0, GetAutoSignalPropagation(), true));\n\t\tm_messageEndSent = true;\n\t\tmessageCount = 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "NonblockingSource::GeneralPump2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "76-138",
    "snippet": "size_t NonblockingSource::GeneralPump2(\n\tlword& byteCount, bool blockingOutput,\n\tunsigned long maxTime, bool checkDelimiter, byte delimiter)\n{\n\tm_blockedBySpeedLimit = false;\n\n\tif (!GetMaxBytesPerSecond())\n\t{\n\t\tsize_t ret = DoPump(byteCount, blockingOutput, maxTime, checkDelimiter, delimiter);\n\t\tm_doPumpBlocked = (ret != 0);\n\t\treturn ret;\n\t}\n\n\tbool forever = (maxTime == INFINITE_TIME);\n\tunsigned long timeToGo = maxTime;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tlword maxSize = byteCount;\n\tbyteCount = 0;\n\n\ttimer.StartTimer();\n\n\twhile (true)\n\t{\n\t\tlword curMaxSize = UnsignedMin(ComputeCurrentTransceiveLimit(), maxSize - byteCount);\n\n\t\tif (curMaxSize || m_doPumpBlocked)\n\t\t{\n\t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tsize_t ret = DoPump(curMaxSize, blockingOutput, timeToGo, checkDelimiter, delimiter);\n\t\t\tm_doPumpBlocked = (ret != 0);\n\t\t\tif (curMaxSize)\n\t\t\t{\n\t\t\t\tNoteTransceive(curMaxSize);\n\t\t\t\tbyteCount += curMaxSize;\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (maxSize != ULONG_MAX && byteCount >= maxSize)\n\t\t\tbreak;\n\n\t\tif (!forever)\n\t\t{\n\t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tif (!timeToGo)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdouble waitTime = TimeToNextTransceive();\n\t\tif (!forever && waitTime > timeToGo)\n\t\t{\n\t\t\tm_blockedBySpeedLimit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tWaitObjectContainer container;\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSource::GeneralPump2() - speed limit\", 0));\n\t\tcontainer.Wait((unsigned long)waitTime);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.Wait",
          "args": [
            "(unsigned long)waitTime"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LimitedBandwidth::GetWaitObjects",
          "args": [
            "container",
            "CallStack(\"NonblockingSource::GeneralPump2() - speed limit\", 0)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::GetWaitObjects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "67-72",
          "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"NonblockingSource::GeneralPump2() - speed limit\"",
            "0"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimeToNextTransceive",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::TimeToNextTransceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "25-34",
          "snippet": "double LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\ndouble LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "maxTime",
            "timer.ElapsedTime()"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NoteTransceive",
          "args": [
            "curMaxSize"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::NoteTransceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "36-44",
          "snippet": "void LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoPump",
          "args": [
            "curMaxSize",
            "blockingOutput",
            "timeToGo",
            "checkDelimiter",
            "delimiter"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer.ElapsedTime",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "ComputeCurrentTransceiveLimit()",
            "maxSize - byteCount"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeCurrentTransceiveLimit",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::ComputeCurrentTransceiveLimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "13-23",
          "snippet": "lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nlword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer.StartTimer",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DoPump",
          "args": [
            "byteCount",
            "blockingOutput",
            "maxTime",
            "checkDelimiter",
            "delimiter"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMaxBytesPerSecond",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxBytesPerSecond",
          "container": "LimitedBandwidth",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.h",
          "lines": "23-24",
          "snippet": "lword GetMaxBytesPerSecond() const\n\t\t{ return m_maxBytesPerSecond; }",
          "includes": [
            "#include <deque>",
            "#include \"hrtimer.h\"",
            "#include \"filters.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"hrtimer.h\"\n#include \"filters.h\"\n#include \"config.h\"\n\nLimitedBandwidth {\n  lword GetMaxBytesPerSecond() const\n  \t\t{ return m_maxBytesPerSecond; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nsize_t NonblockingSource::GeneralPump2(\n\tlword& byteCount, bool blockingOutput,\n\tunsigned long maxTime, bool checkDelimiter, byte delimiter)\n{\n\tm_blockedBySpeedLimit = false;\n\n\tif (!GetMaxBytesPerSecond())\n\t{\n\t\tsize_t ret = DoPump(byteCount, blockingOutput, maxTime, checkDelimiter, delimiter);\n\t\tm_doPumpBlocked = (ret != 0);\n\t\treturn ret;\n\t}\n\n\tbool forever = (maxTime == INFINITE_TIME);\n\tunsigned long timeToGo = maxTime;\n\tTimer timer(Timer::MILLISECONDS, forever);\n\tlword maxSize = byteCount;\n\tbyteCount = 0;\n\n\ttimer.StartTimer();\n\n\twhile (true)\n\t{\n\t\tlword curMaxSize = UnsignedMin(ComputeCurrentTransceiveLimit(), maxSize - byteCount);\n\n\t\tif (curMaxSize || m_doPumpBlocked)\n\t\t{\n\t\t\tif (!forever) timeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tsize_t ret = DoPump(curMaxSize, blockingOutput, timeToGo, checkDelimiter, delimiter);\n\t\t\tm_doPumpBlocked = (ret != 0);\n\t\t\tif (curMaxSize)\n\t\t\t{\n\t\t\t\tNoteTransceive(curMaxSize);\n\t\t\t\tbyteCount += curMaxSize;\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (maxSize != ULONG_MAX && byteCount >= maxSize)\n\t\t\tbreak;\n\n\t\tif (!forever)\n\t\t{\n\t\t\ttimeToGo = SaturatingSubtract(maxTime, timer.ElapsedTime());\n\t\t\tif (!timeToGo)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tdouble waitTime = TimeToNextTransceive();\n\t\tif (!forever && waitTime > timeToGo)\n\t\t{\n\t\t\tm_blockedBySpeedLimit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tWaitObjectContainer container;\n\t\tLimitedBandwidth::GetWaitObjects(container, CallStack(\"NonblockingSource::GeneralPump2() - speed limit\", 0));\n\t\tcontainer.Wait((unsigned long)waitTime);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "LimitedBandwidth::GetWaitObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "67-72",
    "snippet": "void LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.ScheduleEvent",
          "args": [
            "nextTransceiveTime",
            "CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"LimitedBandwidth::GetWaitObjects()\"",
            "&callStack"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimeToNextTransceive",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::TimeToNextTransceive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "25-34",
          "snippet": "double LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\ndouble LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::GetWaitObjects(WaitObjectContainer &container, const CallStack &callStack)\n{\n\tdouble nextTransceiveTime = TimeToNextTransceive();\n\tif (nextTransceiveTime)\n\t\tcontainer.ScheduleEvent(nextTransceiveTime, CallStack(\"LimitedBandwidth::GetWaitObjects()\", &callStack));\n}"
  },
  {
    "function_name": "LimitedBandwidth::GetCurTimeAndCleanUp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "56-65",
    "snippet": "double LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ops.pop_front",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ops.front",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ops.size",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_timer.ElapsedTimeAsDouble",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\ndouble LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}"
  },
  {
    "function_name": "LimitedBandwidth::ComputeNextTransceiveTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "46-54",
    "snippet": "void LimitedBandwidth::ComputeNextTransceiveTime()\n{\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (unsigned int i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\tm_nextTransceiveTime =\n\t\t(total < m_maxBytesPerSecond) ? curTime : m_ops.front().first + 1000;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ops.front",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ops.size",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurTimeAndCleanUp",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::GetCurTimeAndCleanUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "56-65",
          "snippet": "double LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\ndouble LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::ComputeNextTransceiveTime()\n{\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (unsigned int i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\tm_nextTransceiveTime =\n\t\t(total < m_maxBytesPerSecond) ? curTime : m_ops.front().first + 1000;\n}"
  },
  {
    "function_name": "LimitedBandwidth::NoteTransceive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "36-44",
    "snippet": "void LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ops.push_back",
          "args": [
            "std::make_pair(curTime, size)"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "curTime",
            "size"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurTimeAndCleanUp",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::GetCurTimeAndCleanUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "56-65",
          "snippet": "double LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\ndouble LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::NoteTransceive(lword size)\n{\n\tif (m_maxBytesPerSecond)\n\t{\n\t\tdouble curTime = GetCurTimeAndCleanUp();\n\t\tm_ops.push_back(std::make_pair(curTime, size));\n\t\tm_nextTransceiveTime = 0;\n\t}\n}"
  },
  {
    "function_name": "LimitedBandwidth::TimeToNextTransceive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "25-34",
    "snippet": "double LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "m_nextTransceiveTime",
            "m_timer.ElapsedTimeAsDouble()"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_timer.ElapsedTimeAsDouble",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ComputeNextTransceiveTime",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::ComputeNextTransceiveTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "46-54",
          "snippet": "void LimitedBandwidth::ComputeNextTransceiveTime()\n{\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (unsigned int i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\tm_nextTransceiveTime =\n\t\t(total < m_maxBytesPerSecond) ? curTime : m_ops.front().first + 1000;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nvoid LimitedBandwidth::ComputeNextTransceiveTime()\n{\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (unsigned int i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\tm_nextTransceiveTime =\n\t\t(total < m_maxBytesPerSecond) ? curTime : m_ops.front().first + 1000;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\ndouble LimitedBandwidth::TimeToNextTransceive()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tif (!m_nextTransceiveTime)\n\t\tComputeNextTransceiveTime();\n\n\treturn SaturatingSubtract(m_nextTransceiveTime, m_timer.ElapsedTimeAsDouble());\n}"
  },
  {
    "function_name": "LimitedBandwidth::ComputeCurrentTransceiveLimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
    "lines": "13-23",
    "snippet": "lword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"network.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "m_maxBytesPerSecond",
            "total"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_ops.size",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurTimeAndCleanUp",
          "args": [],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "LimitedBandwidth::GetCurTimeAndCleanUp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/network.cpp",
          "lines": "56-65",
          "snippet": "double LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"network.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\ndouble LimitedBandwidth::GetCurTimeAndCleanUp()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn 0;\n\n\tdouble curTime = m_timer.ElapsedTimeAsDouble();\n\twhile (m_ops.size() && (m_ops.front().first + 1000 < curTime))\n\t\tm_ops.pop_front();\n\treturn curTime;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"network.h\"\n#include \"pch.h\"\n\nlword LimitedBandwidth::ComputeCurrentTransceiveLimit()\n{\n\tif (!m_maxBytesPerSecond)\n\t\treturn ULONG_MAX;\n\n\tdouble curTime = GetCurTimeAndCleanUp();\n\tlword total = 0;\n\tfor (OpQueue::size_type i=0; i!=m_ops.size(); ++i)\n\t\ttotal += m_ops[i].second;\n\treturn SaturatingSubtract(m_maxBytesPerSecond, total);\n}"
  }
]