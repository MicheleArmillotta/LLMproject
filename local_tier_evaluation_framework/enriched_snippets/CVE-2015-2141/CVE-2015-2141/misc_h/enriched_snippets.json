[
  {
    "function_name": "SafeLeftShift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1263-1266",
    "snippet": "inline T SafeLeftShift(T value)\n{\n\treturn SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift(value, bits);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift",
          "args": [
            "value",
            "bits"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "LeftShift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1250-1253",
          "snippet": "static inline T LeftShift(T value, unsigned int bits)\n\t{\n\t\treturn value << bits;\n\t}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic inline T LeftShift(T value, unsigned int bits)\n\t{\n\t\treturn value << bits;\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T SafeLeftShift(T value)\n{\n\treturn SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift(value, bits);\n}"
  },
  {
    "function_name": "SafeRightShift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1257-1260",
    "snippet": "inline T SafeRightShift(T value)\n{\n\treturn SafeShifter<(bits>=(8*sizeof(T)))>::RightShift(value, bits);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SafeShifter<(bits>=(8*sizeof(T)))>::RightShift",
          "args": [
            "value",
            "bits"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "RightShift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1244-1247",
          "snippet": "static inline T RightShift(T value, unsigned int bits)\n\t{\n\t\treturn value >> bits;\n\t}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic inline T RightShift(T value, unsigned int bits)\n\t{\n\t\treturn value >> bits;\n\t}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T SafeRightShift(T value)\n{\n\treturn SafeShifter<(bits>=(8*sizeof(T)))>::RightShift(value, bits);\n}"
  },
  {
    "function_name": "LeftShift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1250-1253",
    "snippet": "static inline T LeftShift(T value, unsigned int bits)\n\t{\n\t\treturn value << bits;\n\t}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic inline T LeftShift(T value, unsigned int bits)\n\t{\n\t\treturn value << bits;\n\t}"
  },
  {
    "function_name": "RightShift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1244-1247",
    "snippet": "static inline T RightShift(T value, unsigned int bits)\n\t{\n\t\treturn value >> bits;\n\t}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic inline T RightShift(T value, unsigned int bits)\n\t{\n\t\treturn value >> bits;\n\t}"
  },
  {
    "function_name": "LeftShift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1235-1238",
    "snippet": "static inline T LeftShift(T value, unsigned int bits)\n\t{\n\t\treturn 0;\n\t}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic inline T LeftShift(T value, unsigned int bits)\n\t{\n\t\treturn 0;\n\t}"
  },
  {
    "function_name": "RightShift",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1229-1232",
    "snippet": "static inline T RightShift(T value, unsigned int bits)\n\t{\n\t\treturn 0;\n\t}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic inline T RightShift(T value, unsigned int bits)\n\t{\n\t\treturn 0;\n\t}"
  },
  {
    "function_name": "StringToWord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1215-1220",
    "snippet": "T StringToWord(const std::string &str, ByteOrder order = BIG_ENDIAN_ORDER)\n{\n\tT value = 0;\n\tmemcpy_s(&value, sizeof(value), str.data(), UnsignedMin(str.size(), sizeof(value)));\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define memcpy_s CryptoPP::memcpy_s"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "value"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "NativeByteOrderIs",
          "args": [
            "order"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "NativeByteOrderIs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "403-406",
          "snippet": "inline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "&value",
            "sizeof(value)",
            "str.data()",
            "UnsignedMin(str.size(), sizeof(value))"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "str.size()",
            "sizeof(value)"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.size",
          "args": [],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.data",
          "args": [],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "300-300",
          "snippet": "typename A::const_pointer data() const {return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\nT StringToWord(const std::string &str, ByteOrder order = BIG_ENDIAN_ORDER)\n{\n\tT value = 0;\n\tmemcpy_s(&value, sizeof(value), str.data(), UnsignedMin(str.size(), sizeof(value)));\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}"
  },
  {
    "function_name": "WordToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1206-1212",
    "snippet": "std::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tvalue = ByteReverse(value);\n\n\treturn std::string((char *)&value, sizeof(value));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "(char *)&value",
            "sizeof(value)"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "value"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "NativeByteOrderIs",
          "args": [
            "order"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "NativeByteOrderIs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "403-406",
          "snippet": "inline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tvalue = ByteReverse(value);\n\n\treturn std::string((char *)&value, sizeof(value));\n}"
  },
  {
    "function_name": "Get",
    "container": "BlockGetAndPut",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1201-1201",
    "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetBlock<T, B, GA>",
          "args": [
            "block"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlock",
          "container": "GetBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1159-1160",
          "snippet": "GetBlock(const void *block)\n\t\t: m_block((const byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetBlock {\n  GetBlock(const void *block)\n  \t\t: m_block((const byte *)block) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
  },
  {
    "function_name": "PutBlock",
    "container": "PutBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1179-1180",
    "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
  },
  {
    "function_name": "GetBlock",
    "container": "GetBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1159-1160",
    "snippet": "GetBlock(const void *block)\n\t\t: m_block((const byte *)block) {}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetBlock {\n  GetBlock(const void *block)\n  \t\t: m_block((const byte *)block) {}\n}"
  },
  {
    "function_name": "PutWord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1144-1153",
    "snippet": "inline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedPutWordNonTemplate(order, block, value, xorBlock);\n\tassert(IsAligned<T>(block));\n\tassert(IsAligned<T>(xorBlock));\n#endif\n\t*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<const T *>",
          "args": [
            "xorBlock"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConditionalByteReverse",
          "args": [
            "order",
            "value"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "922-925",
          "snippet": "inline T ConditionalByteReverse(ByteOrder order, T value)\n{\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T ConditionalByteReverse(ByteOrder order, T value)\n{\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<T *>",
          "args": [
            "block"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "IsAligned<T>(xorBlock)"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAligned<T>",
          "args": [
            "xorBlock"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "IsAligned<T>(block)"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnalignedPutWordNonTemplate",
          "args": [
            "order",
            "block",
            "value",
            "xorBlock"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "UnalignedPutWordNonTemplate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1071-1123",
          "snippet": "inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word64 value, const byte *xorBlock)\n{\n\tif (order == BIG_ENDIAN_ORDER)\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word64 value, const byte *xorBlock)\n{\n\tif (order == BIG_ENDIAN_ORDER)\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedPutWordNonTemplate(order, block, value, xorBlock);\n\tassert(IsAligned<T>(block));\n\tassert(IsAligned<T>(xorBlock));\n#endif\n\t*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);\n}"
  },
  {
    "function_name": "GetWord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1138-1141",
    "snippet": "inline void GetWord(bool assumeAligned, ByteOrder order, T &result, const byte *block)\n{\n\tresult = GetWord<T>(assumeAligned, order, block);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void GetWord(bool assumeAligned, ByteOrder order, T &result, const byte *block)\n{\n\tresult = GetWord<T>(assumeAligned, order, block);\n}"
  },
  {
    "function_name": "GetWord",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1127-1135",
    "snippet": "inline T GetWord(bool assumeAligned, ByteOrder order, const byte *block)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedGetWordNonTemplate(order, block, (T*)NULL);\n\tassert(IsAligned<T>(block));\n#endif\n\treturn ConditionalByteReverse(order, *reinterpret_cast<const T *>(block));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ConditionalByteReverse",
          "args": [
            "order",
            "*reinterpret_cast<const T *>(block)"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "922-925",
          "snippet": "inline T ConditionalByteReverse(ByteOrder order, T value)\n{\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T ConditionalByteReverse(ByteOrder order, T value)\n{\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<const T *>",
          "args": [
            "block"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "IsAligned<T>(block)"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAligned<T>",
          "args": [
            "block"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnalignedGetWordNonTemplate",
          "args": [
            "order",
            "block",
            "(T*)NULL"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "UnalignedGetWordNonTemplate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "975-996",
          "snippet": "inline word64 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word64 *)\n{\n\treturn (order == BIG_ENDIAN_ORDER)\n\t\t?\n\t\t(word64(block[7]) |\n\t\t(word64(block[6]) <<  8) |\n\t\t(word64(block[5]) << 16) |\n\t\t(word64(block[4]) << 24) |\n\t\t(word64(block[3]) << 32) |\n\t\t(word64(block[2]) << 40) |\n\t\t(word64(block[1]) << 48) |\n\t\t(word64(block[0]) << 56))\n\t\t:\n\t\t(word64(block[0]) |\n\t\t(word64(block[1]) <<  8) |\n\t\t(word64(block[2]) << 16) |\n\t\t(word64(block[3]) << 24) |\n\t\t(word64(block[4]) << 32) |\n\t\t(word64(block[5]) << 40) |\n\t\t(word64(block[6]) << 48) |\n\t\t(word64(block[7]) << 56));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline word64 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word64 *)\n{\n\treturn (order == BIG_ENDIAN_ORDER)\n\t\t?\n\t\t(word64(block[7]) |\n\t\t(word64(block[6]) <<  8) |\n\t\t(word64(block[5]) << 16) |\n\t\t(word64(block[4]) << 24) |\n\t\t(word64(block[3]) << 32) |\n\t\t(word64(block[2]) << 40) |\n\t\t(word64(block[1]) << 48) |\n\t\t(word64(block[0]) << 56))\n\t\t:\n\t\t(word64(block[0]) |\n\t\t(word64(block[1]) <<  8) |\n\t\t(word64(block[2]) << 16) |\n\t\t(word64(block[3]) << 24) |\n\t\t(word64(block[4]) << 32) |\n\t\t(word64(block[5]) << 40) |\n\t\t(word64(block[6]) << 48) |\n\t\t(word64(block[7]) << 56));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T GetWord(bool assumeAligned, ByteOrder order, const byte *block)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedGetWordNonTemplate(order, block, (T*)NULL);\n\tassert(IsAligned<T>(block));\n#endif\n\treturn ConditionalByteReverse(order, *reinterpret_cast<const T *>(block));\n}"
  },
  {
    "function_name": "UnalignedPutWordNonTemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1071-1123",
    "snippet": "inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word64 value, const byte *xorBlock)\n{\n\tif (order == BIG_ENDIAN_ORDER)\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "7"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "6"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "5"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "4"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "3"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "2"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "7"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "6"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "5"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "4"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "3"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "2"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "2"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "3"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "4"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "5"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "6"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "7"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "2"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "3"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "4"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "5"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "6"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "7"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word64 value, const byte *xorBlock)\n{\n\tif (order == BIG_ENDIAN_ORDER)\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[4] = xorBlock[4] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[5] = xorBlock[5] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[6] = xorBlock[6] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[7] = xorBlock[7] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[4] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 4);\n\t\t\tblock[5] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 5);\n\t\t\tblock[6] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 6);\n\t\t\tblock[7] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 7);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "UnalignedPutWordNonTemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1033-1069",
    "snippet": "inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word32 value, const byte *xorBlock)\n{\n\tif (order == BIG_ENDIAN_ORDER)\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "3"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "2"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "3"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "2"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "2"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "3"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "2"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "3"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word32 value, const byte *xorBlock)\n{\n\tif (order == BIG_ENDIAN_ORDER)\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = xorBlock[2] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = xorBlock[3] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[2] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 2);\n\t\t\tblock[3] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 3);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "UnalignedPutWordNonTemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "1003-1031",
    "snippet": "inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word16 value, const byte *xorBlock)\n{\n\tif (order == BIG_ENDIAN_ORDER)\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "0"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_BYTE_AS_BYTE",
          "args": [
            "value",
            "1"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, word16 value, const byte *xorBlock)\n{\n\tif (order == BIG_ENDIAN_ORDER)\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (xorBlock)\n\t\t{\n\t\t\tblock[0] = xorBlock[0] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = xorBlock[1] ^ CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tblock[0] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 0);\n\t\t\tblock[1] = CRYPTOPP_GET_BYTE_AS_BYTE(value, 1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "UnalignedPutWordNonTemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "998-1001",
    "snippet": "inline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, byte value, const byte *xorBlock)\n{\n\tblock[0] = xorBlock ? (value ^ xorBlock[0]) : value;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void UnalignedPutWordNonTemplate(ByteOrder order, byte *block, byte value, const byte *xorBlock)\n{\n\tblock[0] = xorBlock ? (value ^ xorBlock[0]) : value;\n}"
  },
  {
    "function_name": "UnalignedGetWordNonTemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "975-996",
    "snippet": "inline word64 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word64 *)\n{\n\treturn (order == BIG_ENDIAN_ORDER)\n\t\t?\n\t\t(word64(block[7]) |\n\t\t(word64(block[6]) <<  8) |\n\t\t(word64(block[5]) << 16) |\n\t\t(word64(block[4]) << 24) |\n\t\t(word64(block[3]) << 32) |\n\t\t(word64(block[2]) << 40) |\n\t\t(word64(block[1]) << 48) |\n\t\t(word64(block[0]) << 56))\n\t\t:\n\t\t(word64(block[0]) |\n\t\t(word64(block[1]) <<  8) |\n\t\t(word64(block[2]) << 16) |\n\t\t(word64(block[3]) << 24) |\n\t\t(word64(block[4]) << 32) |\n\t\t(word64(block[5]) << 40) |\n\t\t(word64(block[6]) << 48) |\n\t\t(word64(block[7]) << 56));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[7]"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[6]"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[5]"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[4]"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[3]"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[2]"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[1]"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[0]"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[0]"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[1]"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[2]"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[3]"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[4]"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[5]"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[6]"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "block[7]"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline word64 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word64 *)\n{\n\treturn (order == BIG_ENDIAN_ORDER)\n\t\t?\n\t\t(word64(block[7]) |\n\t\t(word64(block[6]) <<  8) |\n\t\t(word64(block[5]) << 16) |\n\t\t(word64(block[4]) << 24) |\n\t\t(word64(block[3]) << 32) |\n\t\t(word64(block[2]) << 40) |\n\t\t(word64(block[1]) << 48) |\n\t\t(word64(block[0]) << 56))\n\t\t:\n\t\t(word64(block[0]) |\n\t\t(word64(block[1]) <<  8) |\n\t\t(word64(block[2]) << 16) |\n\t\t(word64(block[3]) << 24) |\n\t\t(word64(block[4]) << 32) |\n\t\t(word64(block[5]) << 40) |\n\t\t(word64(block[6]) << 48) |\n\t\t(word64(block[7]) << 56));\n}"
  },
  {
    "function_name": "UnalignedGetWordNonTemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "968-973",
    "snippet": "inline word32 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word32 *)\n{\n\treturn (order == BIG_ENDIAN_ORDER)\n\t\t? word32(block[3]) | (word32(block[2]) << 8) | (word32(block[1]) << 16) | (word32(block[0]) << 24)\n\t\t: word32(block[0]) | (word32(block[1]) << 8) | (word32(block[2]) << 16) | (word32(block[3]) << 24);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "block[3]"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "block[2]"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "block[1]"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "block[0]"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "block[0]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "block[1]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "block[2]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "block[3]"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline word32 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word32 *)\n{\n\treturn (order == BIG_ENDIAN_ORDER)\n\t\t? word32(block[3]) | (word32(block[2]) << 8) | (word32(block[1]) << 16) | (word32(block[0]) << 24)\n\t\t: word32(block[0]) | (word32(block[1]) << 8) | (word32(block[2]) << 16) | (word32(block[3]) << 24);\n}"
  },
  {
    "function_name": "UnalignedGetWordNonTemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "961-966",
    "snippet": "inline word16 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word16 *)\n{\n\treturn (order == BIG_ENDIAN_ORDER)\n\t\t? block[1] | (block[0] << 8)\n\t\t: block[0] | (block[1] << 8);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline word16 UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const word16 *)\n{\n\treturn (order == BIG_ENDIAN_ORDER)\n\t\t? block[1] | (block[0] << 8)\n\t\t: block[0] | (block[1] << 8);\n}"
  },
  {
    "function_name": "UnalignedGetWordNonTemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "956-959",
    "snippet": "inline byte UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const byte *)\n{\n\treturn block[0];\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline byte UnalignedGetWordNonTemplate(ByteOrder order, const byte *block, const byte *)\n{\n\treturn block[0];\n}"
  },
  {
    "function_name": "GetUserKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "946-953",
    "snippet": "inline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n{\n\tconst size_t U = sizeof(T);\n\tassert(inlen <= outlen*U);\n\tmemcpy_s(out, outlen*U, in, inlen);\n\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define memcpy_s CryptoPP::memcpy_s"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ConditionalByteReverse",
          "args": [
            "order",
            "out",
            "out",
            "RoundUpToMultipleOf(inlen, U)"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "937-943",
          "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "inlen",
            "U"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset_z",
          "args": [
            "(byte *)out+inlen",
            "0",
            "outlen*U-inlen"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "out",
            "outlen*U",
            "in",
            "inlen"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "inlen <= outlen*U"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n{\n\tconst size_t U = sizeof(T);\n\tassert(inlen <= outlen*U);\n\tmemcpy_s(out, outlen*U, in, inlen);\n\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n}"
  },
  {
    "function_name": "ConditionalByteReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "937-943",
    "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define memcpy_s CryptoPP::memcpy_s"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "out",
            "byteCount",
            "in",
            "byteCount"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "out",
            "in",
            "byteCount"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "928-934",
          "snippet": "void ByteReverse(T *out, const T *in, size_t byteCount)\n{\n\tassert(byteCount % sizeof(T) == 0);\n\tsize_t count = byteCount/sizeof(T);\n\tfor (size_t i=0; i<count; i++)\n\t\tout[i] = ByteReverse(in[i]);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nvoid ByteReverse(T *out, const T *in, size_t byteCount)\n{\n\tassert(byteCount % sizeof(T) == 0);\n\tsize_t count = byteCount/sizeof(T);\n\tfor (size_t i=0; i<count; i++)\n\t\tout[i] = ByteReverse(in[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NativeByteOrderIs",
          "args": [
            "order"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "NativeByteOrderIs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "403-406",
          "snippet": "inline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
  },
  {
    "function_name": "ByteReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "928-934",
    "snippet": "void ByteReverse(T *out, const T *in, size_t byteCount)\n{\n\tassert(byteCount % sizeof(T) == 0);\n\tsize_t count = byteCount/sizeof(T);\n\tfor (size_t i=0; i<count; i++)\n\t\tout[i] = ByteReverse(in[i]);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "byteCount % sizeof(T) == 0"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nvoid ByteReverse(T *out, const T *in, size_t byteCount)\n{\n\tassert(byteCount % sizeof(T) == 0);\n\tsize_t count = byteCount/sizeof(T);\n\tfor (size_t i=0; i<count; i++)\n\t\tout[i] = ByteReverse(in[i]);\n}"
  },
  {
    "function_name": "ConditionalByteReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "922-925",
    "snippet": "inline T ConditionalByteReverse(ByteOrder order, T value)\n{\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "value"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "NativeByteOrderIs",
          "args": [
            "order"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "NativeByteOrderIs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "403-406",
          "snippet": "inline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T ConditionalByteReverse(ByteOrder order, T value)\n{\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}"
  },
  {
    "function_name": "BitReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "906-919",
    "snippet": "inline T BitReverse(T value)\n{\n\tif (sizeof(T) == 1)\n\t\treturn (T)BitReverse((byte)value);\n\telse if (sizeof(T) == 2)\n\t\treturn (T)BitReverse((word16)value);\n\telse if (sizeof(T) == 4)\n\t\treturn (T)BitReverse((word32)value);\n\telse\n\t{\n\t\tassert(sizeof(T) == 8);\n\t\treturn (T)BitReverse((word64)value);\n\t}\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sizeof(T) == 8"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T BitReverse(T value)\n{\n\tif (sizeof(T) == 1)\n\t\treturn (T)BitReverse((byte)value);\n\telse if (sizeof(T) == 2)\n\t\treturn (T)BitReverse((word16)value);\n\telse if (sizeof(T) == 4)\n\t\treturn (T)BitReverse((word32)value);\n\telse\n\t{\n\t\tassert(sizeof(T) == 8);\n\t\treturn (T)BitReverse((word64)value);\n\t}\n}"
  },
  {
    "function_name": "BitReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "893-903",
    "snippet": "inline word64 BitReverse(word64 value)\n{\n#if CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(BitReverse(word32(value))) << 32) | BitReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xAAAAAAAAAAAAAAAA)) >> 1) | ((value & W64LIT(0x5555555555555555)) << 1);\n\tvalue = ((value & W64LIT(0xCCCCCCCCCCCCCCCC)) >> 2) | ((value & W64LIT(0x3333333333333333)) << 2);\n\tvalue = ((value & W64LIT(0xF0F0F0F0F0F0F0F0)) >> 4) | ((value & W64LIT(0x0F0F0F0F0F0F0F0F)) << 4);\n\treturn ByteReverse(value);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "value"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0x0F0F0F0F0F0F0F0F"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xF0F0F0F0F0F0F0F0"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0x3333333333333333"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xCCCCCCCCCCCCCCCC"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0x5555555555555555"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xAAAAAAAAAAAAAAAA"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "value>>32"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "BitReverse(word32(value))"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "value"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline word64 BitReverse(word64 value)\n{\n#if CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(BitReverse(word32(value))) << 32) | BitReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xAAAAAAAAAAAAAAAA)) >> 1) | ((value & W64LIT(0x5555555555555555)) << 1);\n\tvalue = ((value & W64LIT(0xCCCCCCCCCCCCCCCC)) >> 2) | ((value & W64LIT(0x3333333333333333)) << 2);\n\tvalue = ((value & W64LIT(0xF0F0F0F0F0F0F0F0)) >> 4) | ((value & W64LIT(0x0F0F0F0F0F0F0F0F)) << 4);\n\treturn ByteReverse(value);\n#endif\n}"
  },
  {
    "function_name": "BitReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "885-891",
    "snippet": "inline word32 BitReverse(word32 value)\n{\n\tvalue = ((value & 0xAAAAAAAA) >> 1) | ((value & 0x55555555) << 1);\n\tvalue = ((value & 0xCCCCCCCC) >> 2) | ((value & 0x33333333) << 2);\n\tvalue = ((value & 0xF0F0F0F0) >> 4) | ((value & 0x0F0F0F0F) << 4);\n\treturn ByteReverse(value);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "value"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline word32 BitReverse(word32 value)\n{\n\tvalue = ((value & 0xAAAAAAAA) >> 1) | ((value & 0x55555555) << 1);\n\tvalue = ((value & 0xCCCCCCCC) >> 2) | ((value & 0x33333333) << 2);\n\tvalue = ((value & 0xF0F0F0F0) >> 4) | ((value & 0x0F0F0F0F) << 4);\n\treturn ByteReverse(value);\n}"
  },
  {
    "function_name": "BitReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "877-883",
    "snippet": "inline word16 BitReverse(word16 value)\n{\n\tvalue = ((value & 0xAAAA) >> 1) | ((value & 0x5555) << 1);\n\tvalue = ((value & 0xCCCC) >> 2) | ((value & 0x3333) << 2);\n\tvalue = ((value & 0xF0F0) >> 4) | ((value & 0x0F0F) << 4);\n\treturn ByteReverse(value);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "value"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline word16 BitReverse(word16 value)\n{\n\tvalue = ((value & 0xAAAA) >> 1) | ((value & 0x5555) << 1);\n\tvalue = ((value & 0xCCCC) >> 2) | ((value & 0x3333) << 2);\n\tvalue = ((value & 0xF0F0) >> 4) | ((value & 0x0F0F) << 4);\n\treturn ByteReverse(value);\n}"
  },
  {
    "function_name": "BitReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "870-875",
    "snippet": "inline byte BitReverse(byte value)\n{\n\tvalue = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);\n\tvalue = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);\n\treturn rotlFixed(value, 4U);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotlFixed",
          "args": [
            "value",
            "4U"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "rotlFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "580-584",
          "snippet": "inline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline byte BitReverse(byte value)\n{\n\tvalue = ((value & 0xAA) >> 1) | ((value & 0x55) << 1);\n\tvalue = ((value & 0xCC) >> 2) | ((value & 0x33) << 2);\n\treturn rotlFixed(value, 4U);\n}"
  },
  {
    "function_name": "ByteReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "852-868",
    "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_BYTESWAP_AVAILABLE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotlFixed",
          "args": [
            "value",
            "32U"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "rotlFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "580-584",
          "snippet": "inline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0x0000FFFF0000FFFF"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xFFFF0000FFFF0000"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0x00FF00FF00FF00FF"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xFF00FF00FF00FF00"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "value>>32"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "ByteReverse(word32(value))"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "value"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_byteswap_uint64",
          "args": [
            "value"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bswap_64",
          "args": [
            "value"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
  },
  {
    "function_name": "ByteReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "831-850",
    "snippet": "inline word32 ByteReverse(word32 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_32(value);\n#elif defined(__MWERKS__) && TARGET_CPU_PPC\n\treturn (word32)__lwbrx(&value,0);\n#elif _MSC_VER >= 1400 || (_MSC_VER >= 1300 && !defined(_DLL))\n\treturn _byteswap_ulong(value);\n#elif CRYPTOPP_FAST_ROTATE(32)\n\t// 5 instructions with rotate instruction, 9 without\n\treturn (rotrFixed(value, 8U) & 0xff00ff00) | (rotlFixed(value, 8U) & 0x00ff00ff);\n#else\n\t// 6 instructions with rotate instruction, 8 without\n\tvalue = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n\treturn rotlFixed(value, 16U);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_BYTESWAP_AVAILABLE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotlFixed",
          "args": [
            "value",
            "16U"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "rotlFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "580-584",
          "snippet": "inline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rotrFixed",
          "args": [
            "value",
            "8U"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "rotrFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "586-590",
          "snippet": "inline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_FAST_ROTATE",
          "args": [
            "32"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_byteswap_ulong",
          "args": [
            "value"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lwbrx",
          "args": [
            "&value",
            "0"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bswap_32",
          "args": [
            "value"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word32 ByteReverse(word32 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_32(value);\n#elif defined(__MWERKS__) && TARGET_CPU_PPC\n\treturn (word32)__lwbrx(&value,0);\n#elif _MSC_VER >= 1400 || (_MSC_VER >= 1300 && !defined(_DLL))\n\treturn _byteswap_ulong(value);\n#elif CRYPTOPP_FAST_ROTATE(32)\n\t// 5 instructions with rotate instruction, 9 without\n\treturn (rotrFixed(value, 8U) & 0xff00ff00) | (rotlFixed(value, 8U) & 0x00ff00ff);\n#else\n\t// 6 instructions with rotate instruction, 8 without\n\tvalue = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);\n\treturn rotlFixed(value, 16U);\n#endif\n}"
  },
  {
    "function_name": "ByteReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "820-829",
    "snippet": "inline word16 ByteReverse(word16 value)\n{\n#ifdef CRYPTOPP_BYTESWAP_AVAILABLE\n\treturn bswap_16(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_ushort(value);\n#else\n\treturn rotlFixed(value, 8U);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_BYTESWAP_AVAILABLE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotlFixed",
          "args": [
            "value",
            "8U"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "rotlFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "580-584",
          "snippet": "inline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_byteswap_ushort",
          "args": [
            "value"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bswap_16",
          "args": [
            "value"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word16 ByteReverse(word16 value)\n{\n#ifdef CRYPTOPP_BYTESWAP_AVAILABLE\n\treturn bswap_16(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_ushort(value);\n#else\n\treturn rotlFixed(value, 8U);\n#endif\n}"
  },
  {
    "function_name": "ByteReverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "815-818",
    "snippet": "inline byte ByteReverse(byte value)\n{\n\treturn value;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline byte ByteReverse(byte value)\n{\n\treturn value;\n}"
  },
  {
    "function_name": "GetByte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "807-813",
    "snippet": "inline unsigned int GetByte(ByteOrder order, T value, unsigned int index)\n{\n\tif (order == LITTLE_ENDIAN_ORDER)\n\t\treturn GETBYTE(value, index);\n\telse\n\t\treturn GETBYTE(value, sizeof(T)-index-1);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "value",
            "sizeof(T)-index-1"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "value",
            "index"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline unsigned int GetByte(ByteOrder order, T value, unsigned int index)\n{\n\tif (order == LITTLE_ENDIAN_ORDER)\n\t\treturn GETBYTE(value, index);\n\telse\n\t\treturn GETBYTE(value, sizeof(T)-index-1);\n}"
  },
  {
    "function_name": "rotrMod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "610-614",
    "snippet": "inline T rotrMod(T x, unsigned int y)\n{\n\ty %= sizeof(T)*8;\n\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T",
          "args": [
            "(x>>y) | (x<<(sizeof(T)*8-y))"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotrMod(T x, unsigned int y)\n{\n\ty %= sizeof(T)*8;\n\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n}"
  },
  {
    "function_name": "rotlMod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "604-608",
    "snippet": "inline T rotlMod(T x, unsigned int y)\n{\n\ty %= sizeof(T)*8;\n\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T",
          "args": [
            "(x<<y) | (x>>(sizeof(T)*8-y))"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotlMod(T x, unsigned int y)\n{\n\ty %= sizeof(T)*8;\n\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n}"
  },
  {
    "function_name": "rotrVariable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "598-602",
    "snippet": "inline T rotrVariable(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T",
          "args": [
            "(x>>y) | (x<<(sizeof(T)*8-y))"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "y < sizeof(T)*8"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotrVariable(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn T((x>>y) | (x<<(sizeof(T)*8-y)));\n}"
  },
  {
    "function_name": "rotlVariable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "592-596",
    "snippet": "inline T rotlVariable(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T",
          "args": [
            "(x<<y) | (x>>(sizeof(T)*8-y))"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "y < sizeof(T)*8"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotlVariable(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn T((x<<y) | (x>>(sizeof(T)*8-y)));\n}"
  },
  {
    "function_name": "rotrFixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "586-590",
    "snippet": "inline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T",
          "args": [
            "(x>>y) | (x<<(sizeof(T)*8-y))"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "y < sizeof(T)*8"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}"
  },
  {
    "function_name": "rotlFixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "580-584",
    "snippet": "inline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T",
          "args": [
            "(x<<y) | (x>>(sizeof(T)*8-y))"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "y < sizeof(T)*8"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}"
  },
  {
    "function_name": "StringNarrow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "548-568",
    "snippet": "static std::string StringNarrow(const wchar_t *str, bool throwOnError = true)\n{\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable: 4996)\t//  'wcstombs': This function or variable may be unsafe.\n#endif\n\tsize_t size = wcstombs(NULL, str, 0);\n\tif (size == size_t(0)-1)\n\t{\n\t\tif (throwOnError)\n\t\t\tthrow InvalidArgument(\"StringNarrow: wcstombs() call failed\");\n\t\telse\n\t\t\treturn std::string();\n\t}\n\tstd::string result(size, 0);\n\twcstombs(&result[0], str, size);\n\treturn result;\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wcstombs",
          "args": [
            "&result[0]",
            "str",
            "size"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"StringNarrow: wcstombs() call failed\""
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "0"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcstombs",
          "args": [
            "NULL",
            "str",
            "0"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstatic std::string StringNarrow(const wchar_t *str, bool throwOnError = true)\n{\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable: 4996)\t//  'wcstombs': This function or variable may be unsafe.\n#endif\n\tsize_t size = wcstombs(NULL, str, 0);\n\tif (size == size_t(0)-1)\n\t{\n\t\tif (throwOnError)\n\t\t\tthrow InvalidArgument(\"StringNarrow: wcstombs() call failed\");\n\t\telse\n\t\t\treturn std::string();\n\t}\n\tstd::string result(size, 0);\n\twcstombs(&result[0], str, size);\n\treturn result;\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n}"
  },
  {
    "function_name": "SecureWipeArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "535-545",
    "snippet": "inline void SecureWipeArray(T *buf, size_t n)\n{\n\tif (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)\n\t\tSecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));\n\telse if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)\n\t\tSecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));\n\telse if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)\n\t\tSecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));\n\telse\n\t\tSecureWipeBuffer((byte *)buf, n * sizeof(T));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SecureWipeBuffer",
          "args": [
            "(byte *)buf",
            "n * sizeof(T)"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "SecureWipeBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "518-530",
          "snippet": "inline void SecureWipeBuffer(word64 *buf, size_t n)\n{\n#if CRYPTOPP_BOOL_X64\n\tvolatile word64 *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosq\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosq((word64 *)(size_t)p, 0, n);\n#endif\n#else\n\tSecureWipeBuffer((word32 *)buf, 2*n);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeBuffer(word64 *buf, size_t n)\n{\n#if CRYPTOPP_BOOL_X64\n\tvolatile word64 *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosq\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosq((word64 *)(size_t)p, 0, n);\n#endif\n#else\n\tSecureWipeBuffer((word32 *)buf, 2*n);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAlignmentOf<word16>",
          "args": [],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "GetAlignmentOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "363-379",
          "snippet": "inline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n{\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (sizeof(T) < 16)\n\t\treturn 1;\n#endif\n\n#if (_MSC_VER >= 1300)\n\treturn __alignof(T);\n#elif defined(__GNUC__)\n\treturn __alignof__(T);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn UnsignedMin(4U, sizeof(T));\n#else\n\treturn sizeof(T);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n{\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (sizeof(T) < 16)\n\t\treturn 1;\n#endif\n\n#if (_MSC_VER >= 1300)\n\treturn __alignof(T);\n#elif defined(__GNUC__)\n\treturn __alignof__(T);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn UnsignedMin(4U, sizeof(T));\n#else\n\treturn sizeof(T);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeArray(T *buf, size_t n)\n{\n\tif (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)\n\t\tSecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));\n\telse if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)\n\t\tSecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));\n\telse if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)\n\t\tSecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));\n\telse\n\t\tSecureWipeBuffer((byte *)buf, n * sizeof(T));\n}"
  },
  {
    "function_name": "SecureWipeBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "518-530",
    "snippet": "inline void SecureWipeBuffer(word64 *buf, size_t n)\n{\n#if CRYPTOPP_BOOL_X64\n\tvolatile word64 *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosq\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosq((word64 *)(size_t)p, 0, n);\n#endif\n#else\n\tSecureWipeBuffer((word32 *)buf, 2*n);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stosq",
          "args": [
            "(word64 *)(size_t)p",
            "0",
            "n"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeBuffer(word64 *buf, size_t n)\n{\n#if CRYPTOPP_BOOL_X64\n\tvolatile word64 *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosq\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosq((word64 *)(size_t)p, 0, n);\n#endif\n#else\n\tSecureWipeBuffer((word32 *)buf, 2*n);\n#endif\n}"
  },
  {
    "function_name": "SecureWipeBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "508-516",
    "snippet": "inline void SecureWipeBuffer(word32 *buf, size_t n)\n{\n\tvolatile word32 *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosl\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosd((unsigned long *)(size_t)p, 0, n);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stosd",
          "args": [
            "(unsigned long *)(size_t)p",
            "0",
            "n"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeBuffer(word32 *buf, size_t n)\n{\n\tvolatile word32 *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosl\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosd((unsigned long *)(size_t)p, 0, n);\n#endif\n}"
  },
  {
    "function_name": "SecureWipeBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "498-506",
    "snippet": "inline void SecureWipeBuffer(word16 *buf, size_t n)\n{\n\tvolatile word16 *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosw\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosw((word16 *)(size_t)p, 0, n);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stosw",
          "args": [
            "(word16 *)(size_t)p",
            "0",
            "n"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeBuffer(word16 *buf, size_t n)\n{\n\tvolatile word16 *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosw\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosw((word16 *)(size_t)p, 0, n);\n#endif\n}"
  },
  {
    "function_name": "SecureWipeBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "488-496",
    "snippet": "inline void SecureWipeBuffer(byte *buf, size_t n)\n{\n\tvolatile byte *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosb\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosb((byte *)(size_t)p, 0, n);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stosb",
          "args": [
            "(byte *)(size_t)p",
            "0",
            "n"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeBuffer(byte *buf, size_t n)\n{\n\tvolatile byte *p = buf;\n#ifdef __GNUC__\n\tasm volatile(\"rep stosb\" : \"+c\"(n), \"+D\"(p) : \"a\"(0) : \"memory\");\n#else\n\t__stosb((byte *)(size_t)p, 0, n);\n#endif\n}"
  },
  {
    "function_name": "SecureWipeBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "478-484",
    "snippet": "void SecureWipeBuffer(T *buf, size_t n)\n{\n\t// GCC 4.3.2 on Cygwin optimizes away the first store if this loop is done in the forward direction\n\tvolatile T *p = buf+n;\n\twhile (n--)\n\t\t*(--p) = 0;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nvoid SecureWipeBuffer(T *buf, size_t n)\n{\n\t// GCC 4.3.2 on Cygwin optimizes away the first store if this loop is done in the forward direction\n\tvolatile T *p = buf+n;\n\twhile (n--)\n\t\t*(--p) = 0;\n}"
  },
  {
    "function_name": "ConditionalSwapPointers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "468-473",
    "snippet": "inline void ConditionalSwapPointers(bool c, T &a, T &b)\n{\n\tptrdiff_t t = c * (a - b);\n\ta -= t;\n\tb += t;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void ConditionalSwapPointers(bool c, T &a, T &b)\n{\n\tptrdiff_t t = c * (a - b);\n\ta -= t;\n\tb += t;\n}"
  },
  {
    "function_name": "ConditionalSwap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "460-465",
    "snippet": "inline void ConditionalSwap(bool c, T &a, T &b)\n{\n\tT t = c * (a ^ b);\n\ta ^= t;\n\tb ^= t;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void ConditionalSwap(bool c, T &a, T &b)\n{\n\tT t = c * (a ^ b);\n\ta ^= t;\n\tb ^= t;\n}"
  },
  {
    "function_name": "IncrementCounterByOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "451-457",
    "snippet": "inline void IncrementCounterByOne(byte *output, const byte *input, unsigned int s)\n{\n\tint i, carry;\n\tfor (i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = ((output[i] = input[i]+1) == 0);\n\tmemcpy_s(output, s, input, i+1);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define memcpy_s CryptoPP::memcpy_s"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "output",
            "s",
            "input",
            "i+1"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void IncrementCounterByOne(byte *output, const byte *input, unsigned int s)\n{\n\tint i, carry;\n\tfor (i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = ((output[i] = input[i]+1) == 0);\n\tmemcpy_s(output, s, input, i+1);\n}"
  },
  {
    "function_name": "IncrementCounterByOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "445-449",
    "snippet": "inline void IncrementCounterByOne(byte *inout, unsigned int s)\n{\n\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = !++inout[i];\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void IncrementCounterByOne(byte *inout, unsigned int s)\n{\n\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = !++inout[i];\n}"
  },
  {
    "function_name": "GetCipherDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "438-441",
    "snippet": "inline CipherDir GetCipherDir(const T &obj)\n{\n\treturn obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj.IsForwardTransformation",
          "args": [],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "IsForwardTransformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/arc4.h",
          "lines": "25-25",
          "snippet": "bool IsForwardTransformation() const {return true;}",
          "includes": [
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n\nbool IsForwardTransformation() const {return true;}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline CipherDir GetCipherDir(const T &obj)\n{\n\treturn obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;\n}"
  },
  {
    "function_name": "SaturatingSubtract",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "432-435",
    "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T1",
          "args": [
            "(a > b) ? (a - b) : 0"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
  },
  {
    "function_name": "IntToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "409-429",
    "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "char",
          "args": [
            "(digit < 10 ? '0' : ('a' - 10)) + digit"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
  },
  {
    "function_name": "NativeByteOrderIs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "403-406",
    "snippet": "inline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetNativeByteOrder",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "GetNativeByteOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "398-401",
          "snippet": "inline ByteOrder GetNativeByteOrder()\n{\n\treturn NativeByteOrder::ToEnum();\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline ByteOrder GetNativeByteOrder()\n{\n\treturn NativeByteOrder::ToEnum();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}"
  },
  {
    "function_name": "GetNativeByteOrder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "398-401",
    "snippet": "inline ByteOrder GetNativeByteOrder()\n{\n\treturn NativeByteOrder::ToEnum();\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NativeByteOrder::ToEnum",
          "args": [],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ToEnum",
          "container": "EnumToType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "102-102",
          "snippet": "static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nEnumToType {\n  static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline ByteOrder GetNativeByteOrder()\n{\n\treturn NativeByteOrder::ToEnum();\n}"
  },
  {
    "function_name": "IsAligned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "387-390",
    "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsAlignedOn",
          "args": [
            "p",
            "GetAlignmentOf<T>()"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "IsAlignedOn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "381-384",
          "snippet": "inline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAlignmentOf<T>",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "GetAlignmentOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "363-379",
          "snippet": "inline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n{\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (sizeof(T) < 16)\n\t\treturn 1;\n#endif\n\n#if (_MSC_VER >= 1300)\n\treturn __alignof(T);\n#elif defined(__GNUC__)\n\treturn __alignof__(T);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn UnsignedMin(4U, sizeof(T));\n#else\n\treturn sizeof(T);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n{\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (sizeof(T) < 16)\n\t\treturn 1;\n#endif\n\n#if (_MSC_VER >= 1300)\n\treturn __alignof(T);\n#elif defined(__GNUC__)\n\treturn __alignof__(T);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn UnsignedMin(4U, sizeof(T));\n#else\n\treturn sizeof(T);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
  },
  {
    "function_name": "IsAlignedOn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "381-384",
    "snippet": "inline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ModPowerOf2",
          "args": [
            "(size_t)p",
            "alignment"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ModPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "339-343",
          "snippet": "inline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsPowerOf2",
          "args": [
            "alignment"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "IsPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "333-336",
          "snippet": "inline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}"
  },
  {
    "function_name": "GetAlignmentOf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "363-379",
    "snippet": "inline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n{\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (sizeof(T) < 16)\n\t\treturn 1;\n#endif\n\n#if (_MSC_VER >= 1300)\n\treturn __alignof(T);\n#elif defined(__GNUC__)\n\treturn __alignof__(T);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn UnsignedMin(4U, sizeof(T));\n#else\n\treturn sizeof(T);\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "4U",
            "sizeof(T)"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n{\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (sizeof(T) < 16)\n\t\treturn 1;\n#endif\n\n#if (_MSC_VER >= 1300)\n\treturn __alignof(T);\n#elif defined(__GNUC__)\n\treturn __alignof__(T);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn UnsignedMin(4U, sizeof(T));\n#else\n\treturn sizeof(T);\n#endif\n}"
  },
  {
    "function_name": "RoundUpToMultipleOf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "355-360",
    "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RoundDownToMultipleOf",
          "args": [
            "n+m-1",
            "m"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "RoundDownToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "346-352",
          "snippet": "inline T1 RoundDownToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (IsPowerOf2(m))\n\t\treturn n - ModPowerOf2(n, m);\n\telse\n\t\treturn n - n%m;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundDownToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (IsPowerOf2(m))\n\t\treturn n - ModPowerOf2(n, m);\n\telse\n\t\treturn n - n%m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"RoundUpToMultipleOf: integer overflow\""
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
  },
  {
    "function_name": "RoundDownToMultipleOf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "346-352",
    "snippet": "inline T1 RoundDownToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (IsPowerOf2(m))\n\t\treturn n - ModPowerOf2(n, m);\n\telse\n\t\treturn n - n%m;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ModPowerOf2",
          "args": [
            "n",
            "m"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ModPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "339-343",
          "snippet": "inline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsPowerOf2",
          "args": [
            "m"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "IsPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "333-336",
          "snippet": "inline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundDownToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (IsPowerOf2(m))\n\t\treturn n - ModPowerOf2(n, m);\n\telse\n\t\treturn n - n%m;\n}"
  },
  {
    "function_name": "ModPowerOf2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "339-343",
    "snippet": "inline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T2",
          "args": [
            "a"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "IsPowerOf2(b)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsPowerOf2",
          "args": [
            "b"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "IsPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "333-336",
          "snippet": "inline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}"
  },
  {
    "function_name": "IsPowerOf2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "333-336",
    "snippet": "inline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}"
  },
  {
    "function_name": "BitsToDwords",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "322-325",
    "snippet": "inline size_t BitsToDwords(size_t bitCount)\n{\n\treturn ((bitCount+2*WORD_BITS-1)/(2*WORD_BITS));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline size_t BitsToDwords(size_t bitCount)\n{\n\treturn ((bitCount+2*WORD_BITS-1)/(2*WORD_BITS));\n}"
  },
  {
    "function_name": "BitsToWords",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "317-320",
    "snippet": "inline size_t BitsToWords(size_t bitCount)\n{\n\treturn ((bitCount+WORD_BITS-1)/(WORD_BITS));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline size_t BitsToWords(size_t bitCount)\n{\n\treturn ((bitCount+WORD_BITS-1)/(WORD_BITS));\n}"
  },
  {
    "function_name": "BytesToWords",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "312-315",
    "snippet": "inline size_t BytesToWords(size_t byteCount)\n{\n\treturn ((byteCount+WORD_SIZE-1)/WORD_SIZE);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline size_t BytesToWords(size_t byteCount)\n{\n\treturn ((byteCount+WORD_SIZE-1)/WORD_SIZE);\n}"
  },
  {
    "function_name": "BitsToBytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "307-310",
    "snippet": "inline size_t BitsToBytes(size_t bitCount)\n{\n\treturn ((bitCount+7)/(8));\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline size_t BitsToBytes(size_t bitCount)\n{\n\treturn ((bitCount+7)/(8));\n}"
  },
  {
    "function_name": "SafeConvert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "299-305",
    "snippet": "inline bool SafeConvert(T1 from, T2 &to)\n{\n\tto = (T2)from;\n\tif (from != to || (from > 0) != (to > 0))\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool SafeConvert(T1 from, T2 &to)\n{\n\tto = (T2)from;\n\tif (from != to || (from > 0) != (to > 0))\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "Crop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "290-296",
    "snippet": "inline T Crop(T value, size_t size)\n{\n\tif (size < 8*sizeof(value))\n    \treturn T(value & ((T(1) << size) - 1));\n\telse\n\t\treturn value;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "T",
          "args": [
            "value & ((T(1) << size) - 1)"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T Crop(T value, size_t size)\n{\n\tif (size < 8*sizeof(value))\n    \treturn T(value & ((T(1) << size) - 1));\n\telse\n\t\treturn value;\n}"
  },
  {
    "function_name": "TrailingZeros",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "276-287",
    "snippet": "inline unsigned int TrailingZeros(word64 v)\n{\n#if defined(__GNUC__) && CRYPTOPP_GCC_VERSION >= 30400\n\treturn __builtin_ctzll(v);\n#elif defined(_MSC_VER) && _MSC_VER >= 1400 && (defined(_M_X64) || defined(_M_IA64))\n\tunsigned long result;\n\t_BitScanForward64(&result, v);\n\treturn result;\n#else\n\treturn word32(v) ? TrailingZeros(word32(v)) : 32 + TrailingZeros(word32(v>>32));\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "v>>32"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "v"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "v"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_BitScanForward64",
          "args": [
            "&result",
            "v"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_ctzll",
          "args": [
            "v"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline unsigned int TrailingZeros(word64 v)\n{\n#if defined(__GNUC__) && CRYPTOPP_GCC_VERSION >= 30400\n\treturn __builtin_ctzll(v);\n#elif defined(_MSC_VER) && _MSC_VER >= 1400 && (defined(_M_X64) || defined(_M_IA64))\n\tunsigned long result;\n\t_BitScanForward64(&result, v);\n\treturn result;\n#else\n\treturn word32(v) ? TrailingZeros(word32(v)) : 32 + TrailingZeros(word32(v>>32));\n#endif\n}"
  },
  {
    "function_name": "TrailingZeros",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "257-274",
    "snippet": "inline unsigned int TrailingZeros(word32 v)\n{\n#if defined(__GNUC__) && CRYPTOPP_GCC_VERSION >= 30400\n\treturn __builtin_ctz(v);\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n\tunsigned long result;\n\t_BitScanForward(&result, v);\n\treturn result;\n#else\n\t// from http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightMultLookup\n\tstatic const int MultiplyDeBruijnBitPosition[32] = \n\t{\n\t  0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, \n\t  31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9\n\t};\n\treturn MultiplyDeBruijnBitPosition[((word32)((v & -v) * 0x077CB531U)) >> 27];\n#endif\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "(v & -v) * 0x077CB531U"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_BitScanForward",
          "args": [
            "&result",
            "v"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_ctz",
          "args": [
            "v"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline unsigned int TrailingZeros(word32 v)\n{\n#if defined(__GNUC__) && CRYPTOPP_GCC_VERSION >= 30400\n\treturn __builtin_ctz(v);\n#elif defined(_MSC_VER) && _MSC_VER >= 1400\n\tunsigned long result;\n\t_BitScanForward(&result, v);\n\treturn result;\n#else\n\t// from http://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightMultLookup\n\tstatic const int MultiplyDeBruijnBitPosition[32] = \n\t{\n\t  0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, \n\t  31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9\n\t};\n\treturn MultiplyDeBruijnBitPosition[((word32)((v & -v) * 0x077CB531U)) >> 27];\n#endif\n}"
  },
  {
    "function_name": "BitPrecision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "238-255",
    "snippet": "unsigned int BitPrecision(const T &value)\n{\n\tif (!value)\n\t\treturn 0;\n\n\tunsigned int l=0, h=8*sizeof(value);\n\n\twhile (h-l > 1)\n\t{\n\t\tunsigned int t = (l+h)/2;\n\t\tif (value >> t)\n\t\t\tl = t;\n\t\telse\n\t\t\th = t;\n\t}\n\n\treturn h;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nunsigned int BitPrecision(const T &value)\n{\n\tif (!value)\n\t\treturn 0;\n\n\tunsigned int l=0, h=8*sizeof(value);\n\n\twhile (h-l > 1)\n\t{\n\t\tunsigned int t = (l+h)/2;\n\t\tif (value >> t)\n\t\t\tl = t;\n\t\telse\n\t\t\th = t;\n\t}\n\n\treturn h;\n}"
  },
  {
    "function_name": "BytePrecision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "218-235",
    "snippet": "unsigned int BytePrecision(const T &value)\n{\n\tif (!value)\n\t\treturn 0;\n\n\tunsigned int l=0, h=8*sizeof(value);\n\n\twhile (h-l > 8)\n\t{\n\t\tunsigned int t = (l+h)/2;\n\t\tif (value >> t)\n\t\t\tl = t;\n\t\telse\n\t\t\th = t;\n\t}\n\n\treturn h/8;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nunsigned int BytePrecision(const T &value)\n{\n\tif (!value)\n\t\treturn 0;\n\n\tunsigned int l=0, h=8*sizeof(value);\n\n\twhile (h-l > 8)\n\t{\n\t\tunsigned int t = (l+h)/2;\n\t\tif (value >> t)\n\t\t\tl = t;\n\t\telse\n\t\t\th = t;\n\t}\n\n\treturn h/8;\n}"
  },
  {
    "function_name": "Parity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "210-215",
    "snippet": "unsigned int Parity(T value)\n{\n\tfor (unsigned int i=8*sizeof(value)/2; i>0; i/=2)\n\t\tvalue ^= value >> i;\n\treturn (unsigned int)value&1;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nunsigned int Parity(T value)\n{\n\tfor (unsigned int i=8*sizeof(value)/2; i>0; i/=2)\n\t\tvalue ^= value >> i;\n\treturn (unsigned int)value&1;\n}"
  },
  {
    "function_name": "UnsignedMin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "182-192",
    "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "b>=0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "a==0 || a>0"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_COMPILE_ASSERT",
          "args": [
            "(sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T1",
          "args": [
            "-1"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T2",
          "args": [
            "-1"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
  },
  {
    "function_name": "memmove_s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "152-157",
    "snippet": "inline void memmove_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memmove_s: buffer overflow\");\n\tmemmove(dest, src, count);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define memmove_s CryptoPP::memmove_s"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dest",
            "src",
            "count"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"memmove_s: buffer overflow\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memmove_s CryptoPP::memmove_s\n\ninline void memmove_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memmove_s: buffer overflow\");\n\tmemmove(dest, src, count);\n}"
  },
  {
    "function_name": "memcpy_s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "145-150",
    "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [
      "#define memcpy_s CryptoPP::memcpy_s"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "src",
            "count"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"memcpy_s: buffer overflow\""
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
  },
  {
    "function_name": "Singleton",
    "container": "Singleton",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "111-111",
    "snippet": "Singleton(F objectFactory = F()) : m_objectFactory(objectFactory) {}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "F",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "FindNextWindow",
          "container": "WindowSlider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
          "lines": "219-246",
          "snippet": "void FindNextWindow()\n\t{\n\t\tunsigned int expLen = exp.WordCount() * WORD_BITS;\n\t\tunsigned int skipCount = firstTime ? 0 : windowSize;\n\t\tfirstTime = false;\n\t\twhile (!exp.GetBit(skipCount))\n\t\t{\n\t\t\tif (skipCount >= expLen)\n\t\t\t{\n\t\t\t\tfinished = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tskipCount++;\n\t\t}\n\n\t\texp >>= skipCount;\n\t\twindowBegin += skipCount;\n\t\texpWindow = word32(exp % (word(1) << windowSize));\n\n\t\tif (fastNegate && exp.GetBit(windowSize))\n\t\t{\n\t\t\tnegateNext = true;\n\t\t\texpWindow = (word32(1) << windowSize) - expWindow;\n\t\t\texp += windowModulus;\n\t\t}\n\t\telse\n\t\t\tnegateNext = false;\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"integer.h\"",
            "#include \"algebra.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nWindowSlider {\n  void FindNextWindow()\n  \t{\n  \t\tunsigned int expLen = exp.WordCount() * WORD_BITS;\n  \t\tunsigned int skipCount = firstTime ? 0 : windowSize;\n  \t\tfirstTime = false;\n  \t\twhile (!exp.GetBit(skipCount))\n  \t\t{\n  \t\t\tif (skipCount >= expLen)\n  \t\t\t{\n  \t\t\t\tfinished = true;\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t\tskipCount++;\n  \t\t}\n  \n  \t\texp >>= skipCount;\n  \t\twindowBegin += skipCount;\n  \t\texpWindow = word32(exp % (word(1) << windowSize));\n  \n  \t\tif (fastNegate && exp.GetBit(windowSize))\n  \t\t{\n  \t\t\tnegateNext = true;\n  \t\t\texpWindow = (word32(1) << windowSize) - expWindow;\n  \t\t\texp += windowModulus;\n  \t\t}\n  \t\telse\n  \t\t\tnegateNext = false;\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nSingleton {\n  Singleton(F objectFactory = F()) : m_objectFactory(objectFactory) {}\n}"
  },
  {
    "function_name": "NotCopyable",
    "container": "NotCopyable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
    "lines": "91-91",
    "snippet": "NotCopyable() {}",
    "includes": [
      "#include <byteswap.h>",
      "#include <mem.h>",
      "#include <intrin.h>",
      "#include <string.h>\t\t// for memcpy and memmove",
      "#include \"smartptr.h\"",
      "#include \"cryptlib.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nNotCopyable {\n  NotCopyable() {}\n}"
  }
]