[
  {
    "function_name": "AuthenticateLastFooterBlock",
    "container": "CCM_Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "132-136",
    "snippet": "void CCM_Base::AuthenticateLastFooterBlock(byte *mac, size_t macSize)\r\n{\r\n\tm_ctr.Seek(0);\r\n\tm_ctr.ProcessData(mac, CBC_Buffer(), macSize);\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ctr.ProcessData",
          "args": [
            "mac",
            "CBC_Buffer()",
            "macSize"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessData",
          "container": "CFB_CipherTemplate<BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
          "lines": "177-230",
          "snippet": "void CFB_CipherTemplate<BASE>::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tassert(length % this->MandatoryBlockSize() == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\tunsigned int alignment = policy.GetAlignment();\n\tbyte *reg = policy.GetRegisterBegin();\n\n\tif (m_leftOver)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\tCombineMessageAndShiftRegister(outString, reg + bytesPerIteration - m_leftOver, inString, len);\n\t\tm_leftOver -= len;\n\t\tlength -= len;\n\t\tinString += len;\n\t\toutString += len;\n\t}\n\n\tif (!length)\n\t\treturn;\n\n\tassert(m_leftOver == 0);\n\n\tif (policy.CanIterate() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))\n\t{\n\t\tif (IsAlignedOn(inString, alignment))\n\t\t\tpolicy.Iterate(outString, inString, GetCipherDir(*this), length / bytesPerIteration);\n\t\telse\n\t\t{\n\t\t\tmemcpy(outString, inString, length);\n\t\t\tpolicy.Iterate(outString, outString, GetCipherDir(*this), length / bytesPerIteration);\n\t\t}\n\t\tinString += length - length % bytesPerIteration;\n\t\toutString += length - length % bytesPerIteration;\n\t\tlength %= bytesPerIteration;\n\t}\n\n\twhile (length >= bytesPerIteration)\n\t{\n\t\tpolicy.TransformRegister();\n\t\tCombineMessageAndShiftRegister(outString, reg, inString, bytesPerIteration);\n\t\tlength -= bytesPerIteration;\n\t\tinString += bytesPerIteration;\n\t\toutString += bytesPerIteration;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tpolicy.TransformRegister();\n\t\tCombineMessageAndShiftRegister(outString, reg, inString, length);\n\t\tm_leftOver = bytesPerIteration - length;\n\t}\n}",
          "includes": [
            "#include \"strciphr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nCFB_CipherTemplate<BASE> {\n  void CFB_CipherTemplate<BASE>::ProcessData(byte *outString, const byte *inString, size_t length)\n  {\n  \tassert(length % this->MandatoryBlockSize() == 0);\n  \n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n  \tunsigned int alignment = policy.GetAlignment();\n  \tbyte *reg = policy.GetRegisterBegin();\n  \n  \tif (m_leftOver)\n  \t{\n  \t\tsize_t len = STDMIN(m_leftOver, length);\n  \t\tCombineMessageAndShiftRegister(outString, reg + bytesPerIteration - m_leftOver, inString, len);\n  \t\tm_leftOver -= len;\n  \t\tlength -= len;\n  \t\tinString += len;\n  \t\toutString += len;\n  \t}\n  \n  \tif (!length)\n  \t\treturn;\n  \n  \tassert(m_leftOver == 0);\n  \n  \tif (policy.CanIterate() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))\n  \t{\n  \t\tif (IsAlignedOn(inString, alignment))\n  \t\t\tpolicy.Iterate(outString, inString, GetCipherDir(*this), length / bytesPerIteration);\n  \t\telse\n  \t\t{\n  \t\t\tmemcpy(outString, inString, length);\n  \t\t\tpolicy.Iterate(outString, outString, GetCipherDir(*this), length / bytesPerIteration);\n  \t\t}\n  \t\tinString += length - length % bytesPerIteration;\n  \t\toutString += length - length % bytesPerIteration;\n  \t\tlength %= bytesPerIteration;\n  \t}\n  \n  \twhile (length >= bytesPerIteration)\n  \t{\n  \t\tpolicy.TransformRegister();\n  \t\tCombineMessageAndShiftRegister(outString, reg, inString, bytesPerIteration);\n  \t\tlength -= bytesPerIteration;\n  \t\tinString += bytesPerIteration;\n  \t\toutString += bytesPerIteration;\n  \t}\n  \n  \tif (length > 0)\n  \t{\n  \t\tpolicy.TransformRegister();\n  \t\tCombineMessageAndShiftRegister(outString, reg, inString, length);\n  \t\tm_leftOver = bytesPerIteration - length;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ctr.Seek",
          "args": [
            "0"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "AdditiveCipherTemplate<BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
          "lines": "135-150",
          "snippet": "void AdditiveCipherTemplate<BASE>::Seek(lword position)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tpolicy.SeekToIteration(position / bytesPerIteration);\n\tposition %= bytesPerIteration;\n\n\tif (position > 0)\n\t{\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n\t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n\t}\n\telse\n\t\tm_leftOver = 0;\n}",
          "includes": [
            "#include \"strciphr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nAdditiveCipherTemplate<BASE> {\n  void AdditiveCipherTemplate<BASE>::Seek(lword position)\n  {\n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n  \n  \tpolicy.SeekToIteration(position / bytesPerIteration);\n  \tposition %= bytesPerIteration;\n  \n  \tif (position > 0)\n  \t{\n  \t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n  \t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n  \t}\n  \telse\n  \t\tm_leftOver = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  void CCM_Base::AuthenticateLastFooterBlock(byte *mac, size_t macSize)\r\n  {\r\n  \tm_ctr.Seek(0);\r\n  \tm_ctr.ProcessData(mac, CBC_Buffer(), macSize);\r\n  }\n}"
  },
  {
    "function_name": "AuthenticateLastConfidentialBlock",
    "container": "CCM_Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "116-130",
    "snippet": "void CCM_Base::AuthenticateLastConfidentialBlock()\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tif (m_messageLength != m_totalMessageLength)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\");\r\n\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n\t\tcipher.ProcessBlock(cbcBuffer);\r\n\t\tm_bufferedDataLength = 0;\r\n\t}\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "cbcBuffer"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "cbcBuffer",
            "m_buffer",
            "m_bufferedDataLength"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "80-81",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBlockCipher",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  void CCM_Base::AuthenticateLastConfidentialBlock()\r\n  {\r\n  \tbyte *cbcBuffer = CBC_Buffer();\r\n  \tconst BlockCipher &cipher = GetBlockCipher();\r\n  \r\n  \tif (m_messageLength != m_totalMessageLength)\r\n  \t\tthrow InvalidArgument(AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\");\r\n  \r\n  \tif (m_bufferedDataLength > 0)\r\n  \t{\r\n  \t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n  \t\tcipher.ProcessBlock(cbcBuffer);\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t}\r\n  }\n}"
  },
  {
    "function_name": "AuthenticateLastHeaderBlock",
    "container": "CCM_Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "100-114",
    "snippet": "void CCM_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tif (m_aadLength != m_totalHeaderLength)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": header length doesn't match that given in SpecifyDataLengths\");\r\n\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n\t\tcipher.ProcessBlock(cbcBuffer);\r\n\t\tm_bufferedDataLength = 0;\r\n\t}\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "cbcBuffer"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "cbcBuffer",
            "m_buffer",
            "m_bufferedDataLength"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": header length doesn't match that given in SpecifyDataLengths\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "80-81",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBlockCipher",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  void CCM_Base::AuthenticateLastHeaderBlock()\r\n  {\r\n  \tbyte *cbcBuffer = CBC_Buffer();\r\n  \tconst BlockCipher &cipher = GetBlockCipher();\r\n  \r\n  \tif (m_aadLength != m_totalHeaderLength)\r\n  \t\tthrow InvalidArgument(AlgorithmName() + \": header length doesn't match that given in SpecifyDataLengths\");\r\n  \r\n  \tif (m_bufferedDataLength > 0)\r\n  \t{\r\n  \t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n  \t\tcipher.ProcessBlock(cbcBuffer);\r\n  \t\tm_bufferedDataLength = 0;\r\n  \t}\r\n  }\n}"
  },
  {
    "function_name": "AuthenticateBlocks",
    "container": "CCM_Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "93-98",
    "snippet": "size_t CCM_Base::AuthenticateBlocks(const byte *data, size_t len)\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\treturn cipher.AdvancedProcessBlocks(cbcBuffer, data, cbcBuffer, len, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cipher.AdvancedProcessBlocks",
          "args": [
            "cbcBuffer",
            "data",
            "cbcBuffer",
            "len",
            "BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "AdvancedProcessBlocks",
          "container": "BlockTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "141-177",
          "snippet": "size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n{\n\tsize_t blockSize = BlockSize();\n\tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n\tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n\tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n\n\tif (flags & BT_ReverseDirection)\n\t{\n\t\tassert(length % blockSize == 0);\n\t\tinBlocks += length - blockSize;\n\t\txorBlocks += length - blockSize;\n\t\toutBlocks += length - blockSize;\n\t\tinIncrement = 0-inIncrement;\n\t\txorIncrement = 0-xorIncrement;\n\t\toutIncrement = 0-outIncrement;\n\t}\n\n\twhile (length >= blockSize)\n\t{\n\t\tif (flags & BT_XorInput)\n\t\t{\n\t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n\t\t\tProcessBlock(outBlocks);\n\t\t}\n\t\telse\n\t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n\t\tif (flags & BT_InBlockIsCounter)\n\t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n\t\tinBlocks += inIncrement;\n\t\toutBlocks += outIncrement;\n\t\txorBlocks += xorIncrement;\n\t\tlength -= blockSize;\n\t}\n\n\treturn length;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBlockTransformation {\n  size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n  {\n  \tsize_t blockSize = BlockSize();\n  \tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n  \tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n  \tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n  \n  \tif (flags & BT_ReverseDirection)\n  \t{\n  \t\tassert(length % blockSize == 0);\n  \t\tinBlocks += length - blockSize;\n  \t\txorBlocks += length - blockSize;\n  \t\toutBlocks += length - blockSize;\n  \t\tinIncrement = 0-inIncrement;\n  \t\txorIncrement = 0-xorIncrement;\n  \t\toutIncrement = 0-outIncrement;\n  \t}\n  \n  \twhile (length >= blockSize)\n  \t{\n  \t\tif (flags & BT_XorInput)\n  \t\t{\n  \t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n  \t\t\tProcessBlock(outBlocks);\n  \t\t}\n  \t\telse\n  \t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n  \t\tif (flags & BT_InBlockIsCounter)\n  \t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n  \t\tinBlocks += inIncrement;\n  \t\toutBlocks += outIncrement;\n  \t\txorBlocks += xorIncrement;\n  \t\tlength -= blockSize;\n  \t}\n  \n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBlockCipher",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  size_t CCM_Base::AuthenticateBlocks(const byte *data, size_t len)\r\n  {\r\n  \tbyte *cbcBuffer = CBC_Buffer();\r\n  \tconst BlockCipher &cipher = GetBlockCipher();\r\n  \treturn cipher.AdvancedProcessBlocks(cbcBuffer, data, cbcBuffer, len, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n  }\n}"
  },
  {
    "function_name": "UncheckedSpecifyDataLengths",
    "container": "CCM_Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "51-91",
    "snippet": "void CCM_Base::UncheckedSpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength)\r\n{\r\n\tif (m_state != State_IVSet)\r\n\t\tthrow BadState(AlgorithmName(), \"SpecifyDataLengths\", \"or after State_IVSet\");\r\n\r\n\tm_aadLength = headerLength; \r\n\tm_messageLength = messageLength;\r\n\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tcbcBuffer[0] = byte(64*(headerLength>0) + 8*((m_digestSize-2)/2) + (m_L-1));\t// flag\r\n\tPutWord<word64>(true, BIG_ENDIAN_ORDER, cbcBuffer+REQUIRED_BLOCKSIZE-8, m_messageLength);\r\n\tmemcpy(cbcBuffer+1, m_buffer+1, REQUIRED_BLOCKSIZE-1-m_L);\r\n\tcipher.ProcessBlock(cbcBuffer);\r\n\r\n\tif (headerLength>0)\r\n\t{\r\n\t\tassert(m_bufferedDataLength == 0);\r\n\r\n\t\tif (headerLength < ((1<<16) - (1<<8)))\r\n\t\t{\r\n\t\t\tPutWord<word16>(true, BIG_ENDIAN_ORDER, m_buffer, (word16)headerLength);\r\n\t\t\tm_bufferedDataLength = 2;\r\n\t\t}\r\n\t\telse if (headerLength < (W64LIT(1)<<32))\r\n\t\t{\r\n\t\t\tm_buffer[0] = 0xff;\r\n\t\t\tm_buffer[1] = 0xfe;\r\n\t\t\tPutWord<word32>(false, BIG_ENDIAN_ORDER, m_buffer+2, (word32)headerLength);\r\n\t\t\tm_bufferedDataLength = 6;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_buffer[0] = 0xff;\r\n\t\t\tm_buffer[1] = 0xff;\r\n\t\t\tPutWord<word64>(false, BIG_ENDIAN_ORDER, m_buffer+2, headerLength);\r\n\t\t\tm_bufferedDataLength = 10;\r\n\t\t}\r\n\t}\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PutWord<word64>",
          "args": [
            "false",
            "BIG_ENDIAN_ORDER",
            "m_buffer+2",
            "headerLength"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "PutWord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1144-1153",
          "snippet": "inline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedPutWordNonTemplate(order, block, value, xorBlock);\n\tassert(IsAligned<T>(block));\n\tassert(IsAligned<T>(xorBlock));\n#endif\n\t*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedPutWordNonTemplate(order, block, value, xorBlock);\n\tassert(IsAligned<T>(block));\n\tassert(IsAligned<T>(xorBlock));\n#endif\n\t*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "1"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_bufferedDataLength == 0"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "cbcBuffer"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cbcBuffer+1",
            "m_buffer+1",
            "REQUIRED_BLOCKSIZE-1-m_L"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "64*(headerLength>0) + 8*((m_digestSize-2)/2) + (m_L-1)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBlockCipher",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BadState",
          "args": [
            "AlgorithmName()",
            "\"SpecifyDataLengths\"",
            "\"or after State_IVSet\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "80-81",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  void CCM_Base::UncheckedSpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength)\r\n  {\r\n  \tif (m_state != State_IVSet)\r\n  \t\tthrow BadState(AlgorithmName(), \"SpecifyDataLengths\", \"or after State_IVSet\");\r\n  \r\n  \tm_aadLength = headerLength; \r\n  \tm_messageLength = messageLength;\r\n  \r\n  \tbyte *cbcBuffer = CBC_Buffer();\r\n  \tconst BlockCipher &cipher = GetBlockCipher();\r\n  \r\n  \tcbcBuffer[0] = byte(64*(headerLength>0) + 8*((m_digestSize-2)/2) + (m_L-1));\t// flag\r\n  \tPutWord<word64>(true, BIG_ENDIAN_ORDER, cbcBuffer+REQUIRED_BLOCKSIZE-8, m_messageLength);\r\n  \tmemcpy(cbcBuffer+1, m_buffer+1, REQUIRED_BLOCKSIZE-1-m_L);\r\n  \tcipher.ProcessBlock(cbcBuffer);\r\n  \r\n  \tif (headerLength>0)\r\n  \t{\r\n  \t\tassert(m_bufferedDataLength == 0);\r\n  \r\n  \t\tif (headerLength < ((1<<16) - (1<<8)))\r\n  \t\t{\r\n  \t\t\tPutWord<word16>(true, BIG_ENDIAN_ORDER, m_buffer, (word16)headerLength);\r\n  \t\t\tm_bufferedDataLength = 2;\r\n  \t\t}\r\n  \t\telse if (headerLength < (W64LIT(1)<<32))\r\n  \t\t{\r\n  \t\t\tm_buffer[0] = 0xff;\r\n  \t\t\tm_buffer[1] = 0xfe;\r\n  \t\t\tPutWord<word32>(false, BIG_ENDIAN_ORDER, m_buffer+2, (word32)headerLength);\r\n  \t\t\tm_bufferedDataLength = 6;\r\n  \t\t}\r\n  \t\telse\r\n  \t\t{\r\n  \t\t\tm_buffer[0] = 0xff;\r\n  \t\t\tm_buffer[1] = 0xff;\r\n  \t\t\tPutWord<word64>(false, BIG_ENDIAN_ORDER, m_buffer+2, headerLength);\r\n  \t\t\tm_bufferedDataLength = 10;\r\n  \t\t}\r\n  \t}\r\n  }\n}"
  },
  {
    "function_name": "Resync",
    "container": "CCM_Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "28-49",
    "snippet": "void CCM_Base::Resync(const byte *iv, size_t len)\r\n{\r\n\tBlockCipher &cipher = AccessBlockCipher();\r\n\r\n\tm_L = REQUIRED_BLOCKSIZE-1-(int)len;\r\n\tassert(m_L >= 2);\r\n\tif (m_L > 8)\r\n\t\tm_L = 8;\r\n\r\n\tm_buffer[0] = byte(m_L-1);\t// flag\r\n\tmemcpy(m_buffer+1, iv, len);\r\n\tmemset(m_buffer+1+len, 0, REQUIRED_BLOCKSIZE-1-len);\r\n\r\n\tif (m_state >= State_IVSet)\r\n\t\tm_ctr.Resynchronize(m_buffer, REQUIRED_BLOCKSIZE);\r\n\telse\r\n\t\tm_ctr.SetCipherWithIV(cipher, m_buffer);\r\n\r\n\tm_ctr.Seek(REQUIRED_BLOCKSIZE);\r\n\tm_aadLength = 0; \r\n\tm_messageLength = 0;\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ctr.Seek",
          "args": [
            "REQUIRED_BLOCKSIZE"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "AdditiveCipherTemplate<BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
          "lines": "135-150",
          "snippet": "void AdditiveCipherTemplate<BASE>::Seek(lword position)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tpolicy.SeekToIteration(position / bytesPerIteration);\n\tposition %= bytesPerIteration;\n\n\tif (position > 0)\n\t{\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n\t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n\t}\n\telse\n\t\tm_leftOver = 0;\n}",
          "includes": [
            "#include \"strciphr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nAdditiveCipherTemplate<BASE> {\n  void AdditiveCipherTemplate<BASE>::Seek(lword position)\n  {\n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n  \n  \tpolicy.SeekToIteration(position / bytesPerIteration);\n  \tposition %= bytesPerIteration;\n  \n  \tif (position > 0)\n  \t{\n  \t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n  \t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n  \t}\n  \telse\n  \t\tm_leftOver = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_ctr.SetCipherWithIV",
          "args": [
            "cipher",
            "m_buffer"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "SetCipherWithIV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "52-60",
          "snippet": "void SetCipherWithIV(BlockCipher &cipher, const byte *iv, int feedbackSize = 0)\n\t{\n\t\tthis->ThrowIfInvalidIV(iv);\n\t\tthis->m_cipher = &cipher;\n\t\tthis->ResizeBuffers();\n\t\tthis->SetFeedbackSize(feedbackSize);\n\t\tif (this->IsResynchronizable())\n\t\t\tthis->Resynchronize(iv);\n\t}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid SetCipherWithIV(BlockCipher &cipher, const byte *iv, int feedbackSize = 0)\n\t{\n\t\tthis->ThrowIfInvalidIV(iv);\n\t\tthis->m_cipher = &cipher;\n\t\tthis->ResizeBuffers();\n\t\tthis->SetFeedbackSize(feedbackSize);\n\t\tif (this->IsResynchronizable())\n\t\t\tthis->Resynchronize(iv);\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "m_ctr.Resynchronize",
          "args": [
            "m_buffer",
            "REQUIRED_BLOCKSIZE"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "Resynchronize",
          "container": "VMAC_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.cpp",
          "lines": "99-131",
          "snippet": "void VMAC_Base::Resynchronize(const byte *nonce, int len)\n{\n\tsize_t length = ThrowIfInvalidIVLength(len);\n\tsize_t s = IVSize();\n\tbyte *storedNonce = m_nonce();\n\n\tif (m_is128)\n\t{\n\t\tmemset(storedNonce, 0, s-length);\n\t\tmemcpy(storedNonce+s-length, nonce, length);\n\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t}\n\telse\n\t{\n\t\tif (m_padCached && (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n\t\t{\n\t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n\t\t\tfor (size_t i=0; m_padCached && i<s-length; i++)\n\t\t\t\tm_padCached = (storedNonce[i] == 0);\n\t\t}\n\t\tif (!m_padCached)\n\t\t{\n\t\t\tmemset(storedNonce, 0, s-length);\n\t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n\t\t\tstoredNonce[s-1] = nonce[length-1] & 0xfe;\n\t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t\t\tm_padCached = true;\n\t\t}\n\t\tstoredNonce[s-1] = nonce[length-1];\n\t}\n\tm_isFirstBlock = true;\n\tRestart();\n}",
          "includes": [
            "#include <intrin.h>",
            "#include \"cpu.h\"",
            "#include \"argnames.h\"",
            "#include \"vmac.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [
            "#define const\t// Turbo C++ 2006 workaround"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <intrin.h>\n#include \"cpu.h\"\n#include \"argnames.h\"\n#include \"vmac.h\"\n#include \"pch.h\"\n\n#define const\t// Turbo C++ 2006 workaround\n\nVMAC_Base {\n  void VMAC_Base::Resynchronize(const byte *nonce, int len)\n  {\n  \tsize_t length = ThrowIfInvalidIVLength(len);\n  \tsize_t s = IVSize();\n  \tbyte *storedNonce = m_nonce();\n  \n  \tif (m_is128)\n  \t{\n  \t\tmemset(storedNonce, 0, s-length);\n  \t\tmemcpy(storedNonce+s-length, nonce, length);\n  \t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n  \t}\n  \telse\n  \t{\n  \t\tif (m_padCached && (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n  \t\t{\n  \t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n  \t\t\tfor (size_t i=0; m_padCached && i<s-length; i++)\n  \t\t\t\tm_padCached = (storedNonce[i] == 0);\n  \t\t}\n  \t\tif (!m_padCached)\n  \t\t{\n  \t\t\tmemset(storedNonce, 0, s-length);\n  \t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n  \t\t\tstoredNonce[s-1] = nonce[length-1] & 0xfe;\n  \t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n  \t\t\tm_padCached = true;\n  \t\t}\n  \t\tstoredNonce[s-1] = nonce[length-1];\n  \t}\n  \tm_isFirstBlock = true;\n  \tRestart();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_buffer+1+len",
            "0",
            "REQUIRED_BLOCKSIZE-1-len"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_buffer+1",
            "iv",
            "len"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "m_L-1"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_L >= 2"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessBlockCipher",
          "args": [],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  void CCM_Base::Resync(const byte *iv, size_t len)\r\n  {\r\n  \tBlockCipher &cipher = AccessBlockCipher();\r\n  \r\n  \tm_L = REQUIRED_BLOCKSIZE-1-(int)len;\r\n  \tassert(m_L >= 2);\r\n  \tif (m_L > 8)\r\n  \t\tm_L = 8;\r\n  \r\n  \tm_buffer[0] = byte(m_L-1);\t// flag\r\n  \tmemcpy(m_buffer+1, iv, len);\r\n  \tmemset(m_buffer+1+len, 0, REQUIRED_BLOCKSIZE-1-len);\r\n  \r\n  \tif (m_state >= State_IVSet)\r\n  \t\tm_ctr.Resynchronize(m_buffer, REQUIRED_BLOCKSIZE);\r\n  \telse\r\n  \t\tm_ctr.SetCipherWithIV(cipher, m_buffer);\r\n  \r\n  \tm_ctr.Seek(REQUIRED_BLOCKSIZE);\r\n  \tm_aadLength = 0; \r\n  \tm_messageLength = 0;\r\n  }\n}"
  },
  {
    "function_name": "SetKeyWithoutResync",
    "container": "CCM_Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "11-26",
    "snippet": "void CCM_Base::SetKeyWithoutResync(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tBlockCipher &blockCipher = AccessBlockCipher();\r\n\r\n\tblockCipher.SetKey(userKey, keylength, params);\r\n\r\n\tif (blockCipher.BlockSize() != REQUIRED_BLOCKSIZE)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": block size of underlying block cipher is not 16\");\r\n\r\n\tm_digestSize = params.GetIntValueWithDefault(Name::DigestSize(), DefaultDigestSize());\r\n\tif (m_digestSize % 2 > 0 || m_digestSize < 4 || m_digestSize > 16)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": DigestSize must be 4, 6, 8, 10, 12, 14, or 16\");\r\n\r\n\tm_buffer.Grow(2*REQUIRED_BLOCKSIZE);\r\n\tm_L = 8;\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_buffer.Grow",
          "args": [
            "2*REQUIRED_BLOCKSIZE"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "Grow",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "375-382",
          "snippet": "void Grow(size_type newSize)\n\t{\n\t\tif (newSize > m_size)\n\t\t{\n\t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n\t\t\tm_size = newSize;\n\t\t}\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Grow(size_type newSize)\n  \t{\n  \t\tif (newSize > m_size)\n  \t\t{\n  \t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n  \t\t\tm_size = newSize;\n  \t\t}\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": DigestSize must be 4, 6, 8, 10, 12, 14, or 16\""
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "80-81",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.GetIntValueWithDefault",
          "args": [
            "Name::DigestSize()",
            "DefaultDigestSize()"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultDigestSize",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "DefaultDigestSize",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "87-87",
          "snippet": "int DefaultDigestSize() const {return T_DefaultDigestSize;}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  int DefaultDigestSize() const {return T_DefaultDigestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Name::DigestSize",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": block size of underlying block cipher is not 16\""
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockCipher.BlockSize",
          "args": [],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "blockCipher.SetKey",
          "args": [
            "userKey",
            "keylength",
            "params"
          ],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "SetKey",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "48-60",
          "snippet": "void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tm_bufferedDataLength = 0;\r\n\tm_state = State_Start;\r\n\r\n\tSetKeyWithoutResync(userKey, keylength, params);\r\n\tm_state = State_KeySet;\r\n\r\n\tsize_t length;\r\n\tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n\tif (iv)\r\n\t\tResynchronize(iv, (int)length);\r\n}",
          "includes": [
            "#include \"authenc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n  {\r\n  \tm_bufferedDataLength = 0;\r\n  \tm_state = State_Start;\r\n  \r\n  \tSetKeyWithoutResync(userKey, keylength, params);\r\n  \tm_state = State_KeySet;\r\n  \r\n  \tsize_t length;\r\n  \tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n  \tif (iv)\r\n  \t\tResynchronize(iv, (int)length);\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AccessBlockCipher",
          "args": [],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nCCM_Base {\n  void CCM_Base::SetKeyWithoutResync(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n  {\r\n  \tBlockCipher &blockCipher = AccessBlockCipher();\r\n  \r\n  \tblockCipher.SetKey(userKey, keylength, params);\r\n  \r\n  \tif (blockCipher.BlockSize() != REQUIRED_BLOCKSIZE)\r\n  \t\tthrow InvalidArgument(AlgorithmName() + \": block size of underlying block cipher is not 16\");\r\n  \r\n  \tm_digestSize = params.GetIntValueWithDefault(Name::DigestSize(), DefaultDigestSize());\r\n  \tif (m_digestSize % 2 > 0 || m_digestSize < 4 || m_digestSize > 16)\r\n  \t\tthrow InvalidArgument(AlgorithmName() + \": DigestSize must be 4, 6, 8, 10, 12, 14, or 16\");\r\n  \r\n  \tm_buffer.Grow(2*REQUIRED_BLOCKSIZE);\r\n  \tm_L = 8;\r\n  }\n}"
  }
]