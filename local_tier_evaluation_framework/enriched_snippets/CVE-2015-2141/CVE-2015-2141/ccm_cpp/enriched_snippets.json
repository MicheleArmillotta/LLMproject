[
  {
    "function_name": "CCM_Base::AuthenticateLastFooterBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "132-136",
    "snippet": "void CCM_Base::AuthenticateLastFooterBlock(byte *mac, size_t macSize)\r\n{\r\n\tm_ctr.Seek(0);\r\n\tm_ctr.ProcessData(mac, CBC_Buffer(), macSize);\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ctr.ProcessData",
          "args": [
            "mac",
            "CBC_Buffer()",
            "macSize"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ctr.Seek",
          "args": [
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nvoid CCM_Base::AuthenticateLastFooterBlock(byte *mac, size_t macSize)\r\n{\r\n\tm_ctr.Seek(0);\r\n\tm_ctr.ProcessData(mac, CBC_Buffer(), macSize);\r\n}"
  },
  {
    "function_name": "CCM_Base::AuthenticateLastConfidentialBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "116-130",
    "snippet": "void CCM_Base::AuthenticateLastConfidentialBlock()\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tif (m_messageLength != m_totalMessageLength)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\");\r\n\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n\t\tcipher.ProcessBlock(cbcBuffer);\r\n\t\tm_bufferedDataLength = 0;\r\n\t}\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "cbcBuffer"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "cbcBuffer",
            "m_buffer",
            "m_bufferedDataLength"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "80-81",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBlockCipher",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nvoid CCM_Base::AuthenticateLastConfidentialBlock()\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tif (m_messageLength != m_totalMessageLength)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": message length doesn't match that given in SpecifyDataLengths\");\r\n\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n\t\tcipher.ProcessBlock(cbcBuffer);\r\n\t\tm_bufferedDataLength = 0;\r\n\t}\r\n}"
  },
  {
    "function_name": "CCM_Base::AuthenticateLastHeaderBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "100-114",
    "snippet": "void CCM_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tif (m_aadLength != m_totalHeaderLength)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": header length doesn't match that given in SpecifyDataLengths\");\r\n\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n\t\tcipher.ProcessBlock(cbcBuffer);\r\n\t\tm_bufferedDataLength = 0;\r\n\t}\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "cbcBuffer"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "cbcBuffer",
            "m_buffer",
            "m_bufferedDataLength"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": header length doesn't match that given in SpecifyDataLengths\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "80-81",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBlockCipher",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nvoid CCM_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tif (m_aadLength != m_totalHeaderLength)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": header length doesn't match that given in SpecifyDataLengths\");\r\n\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\txorbuf(cbcBuffer, m_buffer, m_bufferedDataLength);\r\n\t\tcipher.ProcessBlock(cbcBuffer);\r\n\t\tm_bufferedDataLength = 0;\r\n\t}\r\n}"
  },
  {
    "function_name": "CCM_Base::AuthenticateBlocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "93-98",
    "snippet": "size_t CCM_Base::AuthenticateBlocks(const byte *data, size_t len)\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\treturn cipher.AdvancedProcessBlocks(cbcBuffer, data, cbcBuffer, len, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cipher.AdvancedProcessBlocks",
          "args": [
            "cbcBuffer",
            "data",
            "cbcBuffer",
            "len",
            "BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBlockCipher",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nsize_t CCM_Base::AuthenticateBlocks(const byte *data, size_t len)\r\n{\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\treturn cipher.AdvancedProcessBlocks(cbcBuffer, data, cbcBuffer, len, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n}"
  },
  {
    "function_name": "CCM_Base::UncheckedSpecifyDataLengths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "51-91",
    "snippet": "void CCM_Base::UncheckedSpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength)\r\n{\r\n\tif (m_state != State_IVSet)\r\n\t\tthrow BadState(AlgorithmName(), \"SpecifyDataLengths\", \"or after State_IVSet\");\r\n\r\n\tm_aadLength = headerLength; \r\n\tm_messageLength = messageLength;\r\n\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tcbcBuffer[0] = byte(64*(headerLength>0) + 8*((m_digestSize-2)/2) + (m_L-1));\t// flag\r\n\tPutWord<word64>(true, BIG_ENDIAN_ORDER, cbcBuffer+REQUIRED_BLOCKSIZE-8, m_messageLength);\r\n\tmemcpy(cbcBuffer+1, m_buffer+1, REQUIRED_BLOCKSIZE-1-m_L);\r\n\tcipher.ProcessBlock(cbcBuffer);\r\n\r\n\tif (headerLength>0)\r\n\t{\r\n\t\tassert(m_bufferedDataLength == 0);\r\n\r\n\t\tif (headerLength < ((1<<16) - (1<<8)))\r\n\t\t{\r\n\t\t\tPutWord<word16>(true, BIG_ENDIAN_ORDER, m_buffer, (word16)headerLength);\r\n\t\t\tm_bufferedDataLength = 2;\r\n\t\t}\r\n\t\telse if (headerLength < (W64LIT(1)<<32))\r\n\t\t{\r\n\t\t\tm_buffer[0] = 0xff;\r\n\t\t\tm_buffer[1] = 0xfe;\r\n\t\t\tPutWord<word32>(false, BIG_ENDIAN_ORDER, m_buffer+2, (word32)headerLength);\r\n\t\t\tm_bufferedDataLength = 6;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_buffer[0] = 0xff;\r\n\t\t\tm_buffer[1] = 0xff;\r\n\t\t\tPutWord<word64>(false, BIG_ENDIAN_ORDER, m_buffer+2, headerLength);\r\n\t\t\tm_bufferedDataLength = 10;\r\n\t\t}\r\n\t}\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PutWord<word64>",
          "args": [
            "false",
            "BIG_ENDIAN_ORDER",
            "m_buffer+2",
            "headerLength"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "PutWord",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1144-1153",
          "snippet": "inline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedPutWordNonTemplate(order, block, value, xorBlock);\n\tassert(IsAligned<T>(block));\n\tassert(IsAligned<T>(xorBlock));\n#endif\n\t*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void PutWord(bool assumeAligned, ByteOrder order, byte *block, T value, const byte *xorBlock = NULL)\n{\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (!assumeAligned)\n\t\treturn UnalignedPutWordNonTemplate(order, block, value, xorBlock);\n\tassert(IsAligned<T>(block));\n\tassert(IsAligned<T>(xorBlock));\n#endif\n\t*reinterpret_cast<T *>(block) = ConditionalByteReverse(order, value) ^ (xorBlock ? *reinterpret_cast<const T *>(xorBlock) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "1"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_bufferedDataLength == 0"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "cbcBuffer"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cbcBuffer+1",
            "m_buffer+1",
            "REQUIRED_BLOCKSIZE-1-m_L"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "64*(headerLength>0) + 8*((m_digestSize-2)/2) + (m_L-1)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBlockCipher",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBC_Buffer",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BadState",
          "args": [
            "AlgorithmName()",
            "\"SpecifyDataLengths\"",
            "\"or after State_IVSet\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "80-81",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nvoid CCM_Base::UncheckedSpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength)\r\n{\r\n\tif (m_state != State_IVSet)\r\n\t\tthrow BadState(AlgorithmName(), \"SpecifyDataLengths\", \"or after State_IVSet\");\r\n\r\n\tm_aadLength = headerLength; \r\n\tm_messageLength = messageLength;\r\n\r\n\tbyte *cbcBuffer = CBC_Buffer();\r\n\tconst BlockCipher &cipher = GetBlockCipher();\r\n\r\n\tcbcBuffer[0] = byte(64*(headerLength>0) + 8*((m_digestSize-2)/2) + (m_L-1));\t// flag\r\n\tPutWord<word64>(true, BIG_ENDIAN_ORDER, cbcBuffer+REQUIRED_BLOCKSIZE-8, m_messageLength);\r\n\tmemcpy(cbcBuffer+1, m_buffer+1, REQUIRED_BLOCKSIZE-1-m_L);\r\n\tcipher.ProcessBlock(cbcBuffer);\r\n\r\n\tif (headerLength>0)\r\n\t{\r\n\t\tassert(m_bufferedDataLength == 0);\r\n\r\n\t\tif (headerLength < ((1<<16) - (1<<8)))\r\n\t\t{\r\n\t\t\tPutWord<word16>(true, BIG_ENDIAN_ORDER, m_buffer, (word16)headerLength);\r\n\t\t\tm_bufferedDataLength = 2;\r\n\t\t}\r\n\t\telse if (headerLength < (W64LIT(1)<<32))\r\n\t\t{\r\n\t\t\tm_buffer[0] = 0xff;\r\n\t\t\tm_buffer[1] = 0xfe;\r\n\t\t\tPutWord<word32>(false, BIG_ENDIAN_ORDER, m_buffer+2, (word32)headerLength);\r\n\t\t\tm_bufferedDataLength = 6;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tm_buffer[0] = 0xff;\r\n\t\t\tm_buffer[1] = 0xff;\r\n\t\t\tPutWord<word64>(false, BIG_ENDIAN_ORDER, m_buffer+2, headerLength);\r\n\t\t\tm_bufferedDataLength = 10;\r\n\t\t}\r\n\t}\r\n}"
  },
  {
    "function_name": "CCM_Base::Resync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "28-49",
    "snippet": "void CCM_Base::Resync(const byte *iv, size_t len)\r\n{\r\n\tBlockCipher &cipher = AccessBlockCipher();\r\n\r\n\tm_L = REQUIRED_BLOCKSIZE-1-(int)len;\r\n\tassert(m_L >= 2);\r\n\tif (m_L > 8)\r\n\t\tm_L = 8;\r\n\r\n\tm_buffer[0] = byte(m_L-1);\t// flag\r\n\tmemcpy(m_buffer+1, iv, len);\r\n\tmemset(m_buffer+1+len, 0, REQUIRED_BLOCKSIZE-1-len);\r\n\r\n\tif (m_state >= State_IVSet)\r\n\t\tm_ctr.Resynchronize(m_buffer, REQUIRED_BLOCKSIZE);\r\n\telse\r\n\t\tm_ctr.SetCipherWithIV(cipher, m_buffer);\r\n\r\n\tm_ctr.Seek(REQUIRED_BLOCKSIZE);\r\n\tm_aadLength = 0; \r\n\tm_messageLength = 0;\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ctr.Seek",
          "args": [
            "REQUIRED_BLOCKSIZE"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ctr.SetCipherWithIV",
          "args": [
            "cipher",
            "m_buffer"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "SetCipherWithIV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "52-60",
          "snippet": "void SetCipherWithIV(BlockCipher &cipher, const byte *iv, int feedbackSize = 0)\n\t{\n\t\tthis->ThrowIfInvalidIV(iv);\n\t\tthis->m_cipher = &cipher;\n\t\tthis->ResizeBuffers();\n\t\tthis->SetFeedbackSize(feedbackSize);\n\t\tif (this->IsResynchronizable())\n\t\t\tthis->Resynchronize(iv);\n\t}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid SetCipherWithIV(BlockCipher &cipher, const byte *iv, int feedbackSize = 0)\n\t{\n\t\tthis->ThrowIfInvalidIV(iv);\n\t\tthis->m_cipher = &cipher;\n\t\tthis->ResizeBuffers();\n\t\tthis->SetFeedbackSize(feedbackSize);\n\t\tif (this->IsResynchronizable())\n\t\t\tthis->Resynchronize(iv);\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "m_ctr.Resynchronize",
          "args": [
            "m_buffer",
            "REQUIRED_BLOCKSIZE"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_buffer+1+len",
            "0",
            "REQUIRED_BLOCKSIZE-1-len"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_buffer+1",
            "iv",
            "len"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "m_L-1"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_L >= 2"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessBlockCipher",
          "args": [],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nvoid CCM_Base::Resync(const byte *iv, size_t len)\r\n{\r\n\tBlockCipher &cipher = AccessBlockCipher();\r\n\r\n\tm_L = REQUIRED_BLOCKSIZE-1-(int)len;\r\n\tassert(m_L >= 2);\r\n\tif (m_L > 8)\r\n\t\tm_L = 8;\r\n\r\n\tm_buffer[0] = byte(m_L-1);\t// flag\r\n\tmemcpy(m_buffer+1, iv, len);\r\n\tmemset(m_buffer+1+len, 0, REQUIRED_BLOCKSIZE-1-len);\r\n\r\n\tif (m_state >= State_IVSet)\r\n\t\tm_ctr.Resynchronize(m_buffer, REQUIRED_BLOCKSIZE);\r\n\telse\r\n\t\tm_ctr.SetCipherWithIV(cipher, m_buffer);\r\n\r\n\tm_ctr.Seek(REQUIRED_BLOCKSIZE);\r\n\tm_aadLength = 0; \r\n\tm_messageLength = 0;\r\n}"
  },
  {
    "function_name": "CCM_Base::SetKeyWithoutResync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.cpp",
    "lines": "11-26",
    "snippet": "void CCM_Base::SetKeyWithoutResync(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tBlockCipher &blockCipher = AccessBlockCipher();\r\n\r\n\tblockCipher.SetKey(userKey, keylength, params);\r\n\r\n\tif (blockCipher.BlockSize() != REQUIRED_BLOCKSIZE)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": block size of underlying block cipher is not 16\");\r\n\r\n\tm_digestSize = params.GetIntValueWithDefault(Name::DigestSize(), DefaultDigestSize());\r\n\tif (m_digestSize % 2 > 0 || m_digestSize < 4 || m_digestSize > 16)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": DigestSize must be 4, 6, 8, 10, 12, 14, or 16\");\r\n\r\n\tm_buffer.Grow(2*REQUIRED_BLOCKSIZE);\r\n\tm_L = 8;\r\n}",
    "includes": [
      "#include \"ccm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_buffer.Grow",
          "args": [
            "2*REQUIRED_BLOCKSIZE"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "Grow",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "375-382",
          "snippet": "void Grow(size_type newSize)\n\t{\n\t\tif (newSize > m_size)\n\t\t{\n\t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n\t\t\tm_size = newSize;\n\t\t}\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Grow(size_type newSize)\n  \t{\n  \t\tif (newSize > m_size)\n  \t\t{\n  \t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n  \t\t\tm_size = newSize;\n  \t\t}\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": DigestSize must be 4, 6, 8, 10, 12, 14, or 16\""
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "80-81",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/CCM\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.GetIntValueWithDefault",
          "args": [
            "Name::DigestSize()",
            "DefaultDigestSize()"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DefaultDigestSize",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "DefaultDigestSize",
          "container": "CCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ccm.h",
          "lines": "87-87",
          "snippet": "int DefaultDigestSize() const {return T_DefaultDigestSize;}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nCCM_Final {\n  int DefaultDigestSize() const {return T_DefaultDigestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Name::DigestSize",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": block size of underlying block cipher is not 16\""
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockCipher.BlockSize",
          "args": [],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "blockCipher.SetKey",
          "args": [
            "userKey",
            "keylength",
            "params"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessBlockCipher",
          "args": [],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ccm.h\"\n#include \"pch.h\"\n\nvoid CCM_Base::SetKeyWithoutResync(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tBlockCipher &blockCipher = AccessBlockCipher();\r\n\r\n\tblockCipher.SetKey(userKey, keylength, params);\r\n\r\n\tif (blockCipher.BlockSize() != REQUIRED_BLOCKSIZE)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": block size of underlying block cipher is not 16\");\r\n\r\n\tm_digestSize = params.GetIntValueWithDefault(Name::DigestSize(), DefaultDigestSize());\r\n\tif (m_digestSize % 2 > 0 || m_digestSize < 4 || m_digestSize > 16)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": DigestSize must be 4, 6, 8, 10, 12, 14, or 16\");\r\n\r\n\tm_buffer.Grow(2*REQUIRED_BLOCKSIZE);\r\n\tm_L = 8;\r\n}"
  }
]