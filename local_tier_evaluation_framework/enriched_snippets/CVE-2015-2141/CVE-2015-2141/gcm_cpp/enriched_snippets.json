[
  {
    "function_name": "GCM_Base::AuthenticateLastFooterBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "820-825",
    "snippet": "void GCM_Base::AuthenticateLastFooterBlock(byte *mac, size_t macSize)\r\n{\r\n\tm_ctr.Seek(0);\r\n\tReverseHashBufferIfNeeded();\r\n\tm_ctr.ProcessData(mac, HashBuffer(), macSize);\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ctr.ProcessData",
          "args": [
            "mac",
            "HashBuffer()",
            "macSize"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashBuffer",
          "args": [],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReverseHashBufferIfNeeded",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "GCM_Base::ReverseHashBufferIfNeeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "272-281",
          "snippet": "inline void GCM_Base::ReverseHashBufferIfNeeded()\r\n{\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\t__m128i &x = *(__m128i *)HashBuffer();\r\n\t\tx = _mm_shuffle_epi8(x, s_clmulConstants[1]);\r\n\t}\r\n#endif\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline void GCM_Base::ReverseHashBufferIfNeeded()\r\n{\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\t__m128i &x = *(__m128i *)HashBuffer();\r\n\t\tx = _mm_shuffle_epi8(x, s_clmulConstants[1]);\r\n\t}\r\n#endif\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_ctr.Seek",
          "args": [
            "0"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\nvoid GCM_Base::AuthenticateLastFooterBlock(byte *mac, size_t macSize)\r\n{\r\n\tm_ctr.Seek(0);\r\n\tReverseHashBufferIfNeeded();\r\n\tm_ctr.ProcessData(mac, HashBuffer(), macSize);\r\n}"
  },
  {
    "function_name": "GCM_Base::AuthenticateLastConfidentialBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "813-818",
    "snippet": "void GCM_Base::AuthenticateLastConfidentialBlock()\r\n{\r\n\tGCM_Base::AuthenticateLastHeaderBlock();\r\n\tPutBlock<word64, BigEndian, true>(NULL, m_buffer)(m_totalHeaderLength*8)(m_totalMessageLength*8);\r\n\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GCM_Base::AuthenticateBlocks",
          "args": [
            "m_buffer",
            "HASH_BLOCKSIZE"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<word64, BigEndian, true>",
          "args": [
            "m_totalMessageLength*8"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<word64, BigEndian, true>",
          "args": [
            "m_totalHeaderLength*8"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<word64, BigEndian, true>",
          "args": [
            "NULL",
            "m_buffer"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GCM_Base::AuthenticateLastHeaderBlock",
          "args": [],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "GCM_Base::AuthenticateLastHeaderBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "803-811",
          "snippet": "void GCM_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\tmemset(m_buffer+m_bufferedDataLength, 0, HASH_BLOCKSIZE-m_bufferedDataLength);\r\n\t\tm_bufferedDataLength = 0;\r\n\t\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n\t}\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\nvoid GCM_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\tmemset(m_buffer+m_bufferedDataLength, 0, HASH_BLOCKSIZE-m_bufferedDataLength);\r\n\t\tm_bufferedDataLength = 0;\r\n\t\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n\t}\r\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\nvoid GCM_Base::AuthenticateLastConfidentialBlock()\r\n{\r\n\tGCM_Base::AuthenticateLastHeaderBlock();\r\n\tPutBlock<word64, BigEndian, true>(NULL, m_buffer)(m_totalHeaderLength*8)(m_totalMessageLength*8);\r\n\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n}"
  },
  {
    "function_name": "GCM_Base::AuthenticateLastHeaderBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "803-811",
    "snippet": "void GCM_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\tmemset(m_buffer+m_bufferedDataLength, 0, HASH_BLOCKSIZE-m_bufferedDataLength);\r\n\t\tm_bufferedDataLength = 0;\r\n\t\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n\t}\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GCM_Base::AuthenticateBlocks",
          "args": [
            "m_buffer",
            "HASH_BLOCKSIZE"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_buffer+m_bufferedDataLength",
            "0",
            "HASH_BLOCKSIZE-m_bufferedDataLength"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\nvoid GCM_Base::AuthenticateLastHeaderBlock()\r\n{\r\n\tif (m_bufferedDataLength > 0)\r\n\t{\r\n\t\tmemset(m_buffer+m_bufferedDataLength, 0, HASH_BLOCKSIZE-m_bufferedDataLength);\r\n\t\tm_bufferedDataLength = 0;\r\n\t\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n\t}\r\n}"
  },
  {
    "function_name": "GCM_Base::AuthenticateBlocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "352-801",
    "snippet": "size_t GCM_Base::AuthenticateBlocks(const byte *data, size_t len)\r\n{\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\tconst __m128i *table = (const __m128i *)MulTable();\r\n\t\t__m128i x = _mm_load_si128((__m128i *)HashBuffer());\r\n\t\tconst __m128i r = s_clmulConstants[0], bswapMask = s_clmulConstants[1], bswapMask2 = s_clmulConstants[2];\r\n\r\n\t\twhile (len >= 16)\r\n\t\t{\r\n\t\t\tsize_t s = UnsignedMin(len/16, s_clmulTableSizeInBlocks), i=0;\r\n\t\t\t__m128i d, d2 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(data+(s-1)*16)), bswapMask2);;\r\n\t\t\t__m128i c0 = _mm_setzero_si128();\r\n\t\t\t__m128i c1 = _mm_setzero_si128();\r\n\t\t\t__m128i c2 = _mm_setzero_si128();\r\n\r\n\t\t\twhile (true)\r\n\t\t\t{\r\n\t\t\t\t__m128i h0 = _mm_load_si128(table+i);\r\n\t\t\t\t__m128i h1 = _mm_load_si128(table+i+1);\r\n\t\t\t\t__m128i h01 = _mm_xor_si128(h0, h1);\r\n\r\n\t\t\t\tif (++i == s)\r\n\t\t\t\t{\r\n\t\t\t\t\td = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)data), bswapMask);\r\n\t\t\t\t\td = _mm_xor_si128(d, x);\r\n\t\t\t\t\tc0 = _mm_xor_si128(c0, _mm_clmulepi64_si128(d, h0, 0));\r\n\t\t\t\t\tc2 = _mm_xor_si128(c2, _mm_clmulepi64_si128(d, h1, 1));\r\n\t\t\t\t\td = _mm_xor_si128(d, _mm_shuffle_epi32(d, _MM_SHUFFLE(1, 0, 3, 2)));\r\n\t\t\t\t\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(d, h01, 0));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\td = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(data+(s-i)*16-8)), bswapMask2);\r\n\t\t\t\tc0 = _mm_xor_si128(c0, _mm_clmulepi64_si128(d2, h0, 1));\r\n\t\t\t\tc2 = _mm_xor_si128(c2, _mm_clmulepi64_si128(d, h1, 1));\r\n\t\t\t\td2 = _mm_xor_si128(d2, d);\r\n\t\t\t\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(d2, h01, 1));\r\n\r\n\t\t\t\tif (++i == s)\r\n\t\t\t\t{\r\n\t\t\t\t\td = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)data), bswapMask);\r\n\t\t\t\t\td = _mm_xor_si128(d, x);\r\n\t\t\t\t\tc0 = _mm_xor_si128(c0, _mm_clmulepi64_si128(d, h0, 0x10));\r\n\t\t\t\t\tc2 = _mm_xor_si128(c2, _mm_clmulepi64_si128(d, h1, 0x11));\r\n\t\t\t\t\td = _mm_xor_si128(d, _mm_shuffle_epi32(d, _MM_SHUFFLE(1, 0, 3, 2)));\r\n\t\t\t\t\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(d, h01, 0x10));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\td2 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(data+(s-i)*16-8)), bswapMask);\r\n\t\t\t\tc0 = _mm_xor_si128(c0, _mm_clmulepi64_si128(d, h0, 0x10));\r\n\t\t\t\tc2 = _mm_xor_si128(c2, _mm_clmulepi64_si128(d2, h1, 0x10));\r\n\t\t\t\td = _mm_xor_si128(d, d2);\r\n\t\t\t\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(d, h01, 0x10));\r\n\t\t\t}\r\n\t\t\tdata += s*16;\r\n\t\t\tlen -= s*16;\r\n\r\n\t\t\tc1 = _mm_xor_si128(_mm_xor_si128(c1, c0), c2);\r\n\t\t\tx = CLMUL_Reduce(c0, c1, c2, r);\r\n\t\t}\r\n\r\n\t\t_mm_store_si128((__m128i *)HashBuffer(), x);\r\n\t\treturn len;\r\n\t}\r\n#endif\r\n\r\n\ttypedef BlockGetAndPut<word64, NativeByteOrder> Block;\r\n\tword64 *hashBuffer = (word64 *)HashBuffer();\r\n\r\n\tswitch (2*(m_buffer.size()>=64*1024)\r\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\r\n\t\t+ HasSSE2()\r\n#endif\r\n\t\t)\r\n\t{\r\n\tcase 0:\t\t// non-SSE2 and 2K tables\r\n\t\t{\r\n\t\tbyte *table = MulTable();\r\n\t\tword64 x0 = hashBuffer[0], x1 = hashBuffer[1];\r\n\r\n\t\tdo\r\n\t\t{\r\n\t\t\tword64 y0, y1, a0, a1, b0, b1, c0, c1, d0, d1;\r\n\t\t\tBlock::Get(data)(y0)(y1);\r\n\t\t\tx0 ^= y0;\r\n\t\t\tx1 ^= y1;\r\n\r\n\t\t\tdata += HASH_BLOCKSIZE;\r\n\t\t\tlen -= HASH_BLOCKSIZE;\r\n\r\n\t\t\t#define READ_TABLE_WORD64_COMMON(a, b, c, d)\t*(word64 *)(table+(a*1024)+(b*256)+c+d*8)\r\n\r\n\t\t\t#ifdef IS_LITTLE_ENDIAN\r\n\t\t\t\t#if CRYPTOPP_BOOL_SLOW_WORD64\r\n\t\t\t\t\tword32 z0 = (word32)x0;\r\n\t\t\t\t\tword32 z1 = (word32)(x0>>32);\r\n\t\t\t\t\tword32 z2 = (word32)x1;\r\n\t\t\t\t\tword32 z3 = (word32)(x1>>32);\r\n\t\t\t\t\t#define READ_TABLE_WORD64(a, b, c, d, e)\tREAD_TABLE_WORD64_COMMON((d%2), c, (d?(z##c>>((d?d-1:0)*4))&0xf0:(z##c&0xf)<<4), e)\r\n\t\t\t\t#else\r\n\t\t\t\t\t#define READ_TABLE_WORD64(a, b, c, d, e)\tREAD_TABLE_WORD64_COMMON((d%2), c, ((d+8*b)?(x##a>>(((d+8*b)?(d+8*b)-1:1)*4))&0xf0:(x##a&0xf)<<4), e)\r\n\t\t\t\t#endif\r\n\t\t\t\t#define GF_MOST_SIG_8BITS(a) (a##1 >> 7*8)\r\n\t\t\t\t#define GF_SHIFT_8(a) a##1 = (a##1 << 8) ^ (a##0 >> 7*8); a##0 <<= 8;\r\n\t\t\t#else\r\n\t\t\t\t#define READ_TABLE_WORD64(a, b, c, d, e)\tREAD_TABLE_WORD64_COMMON((1-d%2), c, ((15-d-8*b)?(x##a>>(((15-d-8*b)?(15-d-8*b)-1:0)*4))&0xf0:(x##a&0xf)<<4), e)\r\n\t\t\t\t#define GF_MOST_SIG_8BITS(a) (a##1 & 0xff)\r\n\t\t\t\t#define GF_SHIFT_8(a) a##1 = (a##1 >> 8) ^ (a##0 << 7*8); a##0 >>= 8;\r\n\t\t\t#endif\r\n\r\n\t\t\t#define GF_MUL_32BY128(op, a, b, c)\t\t\t\t\t\t\t\t\t\t\t\\\r\n\t\t\t\ta0 op READ_TABLE_WORD64(a, b, c, 0, 0) ^ READ_TABLE_WORD64(a, b, c, 1, 0);\\\r\n\t\t\t\ta1 op READ_TABLE_WORD64(a, b, c, 0, 1) ^ READ_TABLE_WORD64(a, b, c, 1, 1);\\\r\n\t\t\t\tb0 op READ_TABLE_WORD64(a, b, c, 2, 0) ^ READ_TABLE_WORD64(a, b, c, 3, 0);\\\r\n\t\t\t\tb1 op READ_TABLE_WORD64(a, b, c, 2, 1) ^ READ_TABLE_WORD64(a, b, c, 3, 1);\\\r\n\t\t\t\tc0 op READ_TABLE_WORD64(a, b, c, 4, 0) ^ READ_TABLE_WORD64(a, b, c, 5, 0);\\\r\n\t\t\t\tc1 op READ_TABLE_WORD64(a, b, c, 4, 1) ^ READ_TABLE_WORD64(a, b, c, 5, 1);\\\r\n\t\t\t\td0 op READ_TABLE_WORD64(a, b, c, 6, 0) ^ READ_TABLE_WORD64(a, b, c, 7, 0);\\\r\n\t\t\t\td1 op READ_TABLE_WORD64(a, b, c, 6, 1) ^ READ_TABLE_WORD64(a, b, c, 7, 1);\\\r\n\r\n\t\t\tGF_MUL_32BY128(=, 0, 0, 0)\r\n\t\t\tGF_MUL_32BY128(^=, 0, 1, 1)\r\n\t\t\tGF_MUL_32BY128(^=, 1, 0, 2)\r\n\t\t\tGF_MUL_32BY128(^=, 1, 1, 3)\r\n\r\n\t\t\tword32 r = (word32)s_reductionTable[GF_MOST_SIG_8BITS(d)] << 16;\r\n\t\t\tGF_SHIFT_8(d)\r\n\t\t\tc0 ^= d0; c1 ^= d1;\r\n\t\t\tr ^= (word32)s_reductionTable[GF_MOST_SIG_8BITS(c)] << 8;\r\n\t\t\tGF_SHIFT_8(c)\r\n\t\t\tb0 ^= c0; b1 ^= c1;\r\n\t\t\tr ^= s_reductionTable[GF_MOST_SIG_8BITS(b)];\r\n\t\t\tGF_SHIFT_8(b)\r\n\t\t\ta0 ^= b0; a1 ^= b1;\r\n\t\t\ta0 ^= ConditionalByteReverse<word64>(LITTLE_ENDIAN_ORDER, r);\r\n\t\t\tx0 = a0; x1 = a1;\r\n\t\t}\r\n\t\twhile (len >= HASH_BLOCKSIZE);\r\n\r\n\t\thashBuffer[0] = x0; hashBuffer[1] = x1;\r\n\t\treturn len;\r\n\t\t}\r\n\r\n\tcase 2:\t\t// non-SSE2 and 64K tables\r\n\t\t{\r\n\t\tbyte *table = MulTable();\r\n\t\tword64 x0 = hashBuffer[0], x1 = hashBuffer[1];\r\n\r\n\t\tdo\r\n\t\t{\r\n\t\t\tword64 y0, y1, a0, a1;\r\n\t\t\tBlock::Get(data)(y0)(y1);\r\n\t\t\tx0 ^= y0;\r\n\t\t\tx1 ^= y1;\r\n\r\n\t\t\tdata += HASH_BLOCKSIZE;\r\n\t\t\tlen -= HASH_BLOCKSIZE;\r\n\r\n\t\t\t#undef READ_TABLE_WORD64_COMMON\r\n\t\t\t#undef READ_TABLE_WORD64\r\n\r\n\t\t\t#define READ_TABLE_WORD64_COMMON(a, c, d)\t*(word64 *)(table+(a)*256*16+(c)+(d)*8)\r\n\r\n\t\t\t#ifdef IS_LITTLE_ENDIAN\r\n\t\t\t\t#if CRYPTOPP_BOOL_SLOW_WORD64\r\n\t\t\t\t\tword32 z0 = (word32)x0;\r\n\t\t\t\t\tword32 z1 = (word32)(x0>>32);\r\n\t\t\t\t\tword32 z2 = (word32)x1;\r\n\t\t\t\t\tword32 z3 = (word32)(x1>>32);\r\n\t\t\t\t\t#define READ_TABLE_WORD64(b, c, d, e)\tREAD_TABLE_WORD64_COMMON(c*4+d, (d?(z##c>>((d?d:1)*8-4))&0xff0:(z##c&0xff)<<4), e)\r\n\t\t\t\t#else\r\n\t\t\t\t\t#define READ_TABLE_WORD64(b, c, d, e)\tREAD_TABLE_WORD64_COMMON(c*4+d, ((d+4*(c%2))?(x##b>>(((d+4*(c%2))?(d+4*(c%2)):1)*8-4))&0xff0:(x##b&0xff)<<4), e)\r\n\t\t\t\t#endif\r\n\t\t\t#else\r\n\t\t\t\t#define READ_TABLE_WORD64(b, c, d, e)\tREAD_TABLE_WORD64_COMMON(c*4+d, ((7-d-4*(c%2))?(x##b>>(((7-d-4*(c%2))?(7-d-4*(c%2)):1)*8-4))&0xff0:(x##b&0xff)<<4), e)\r\n\t\t\t#endif\r\n\r\n\t\t\t#define GF_MUL_8BY128(op, b, c, d)\t\t\\\r\n\t\t\t\ta0 op READ_TABLE_WORD64(b, c, d, 0);\\\r\n\t\t\t\ta1 op READ_TABLE_WORD64(b, c, d, 1);\\\r\n\r\n\t\t\tGF_MUL_8BY128(=, 0, 0, 0)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 0, 1)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 0, 2)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 0, 3)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 1, 0)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 1, 1)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 1, 2)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 1, 3)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 2, 0)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 2, 1)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 2, 2)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 2, 3)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 3, 0)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 3, 1)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 3, 2)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 3, 3)\r\n\r\n\t\t\tx0 = a0; x1 = a1;\r\n\t\t}\r\n\t\twhile (len >= HASH_BLOCKSIZE);\r\n\r\n\t\thashBuffer[0] = x0; hashBuffer[1] = x1;\r\n\t\treturn len;\r\n\t\t}\r\n#endif\t// #ifndef CRYPTOPP_GENERATE_X64_MASM\r\n\r\n#ifdef CRYPTOPP_X64_MASM_AVAILABLE\r\n\tcase 1:\t\t// SSE2 and 2K tables\r\n\t\tGCM_AuthenticateBlocks_2K(data, len/16, hashBuffer, s_reductionTable);\r\n\t\treturn len % 16;\r\n\tcase 3:\t\t// SSE2 and 64K tables\r\n\t\tGCM_AuthenticateBlocks_64K(data, len/16, hashBuffer);\r\n\t\treturn len % 16;\r\n#endif\r\n\r\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\r\n\tcase 1:\t\t// SSE2 and 2K tables\r\n\t\t{\r\n\t\t#ifdef __GNUC__\r\n\t\t\t__asm__ __volatile__\r\n\t\t\t(\r\n\t\t\t\".intel_syntax noprefix;\"\r\n\t\t#elif defined(CRYPTOPP_GENERATE_X64_MASM)\r\n\t\t\tALIGN   8\r\n\t\t\tGCM_AuthenticateBlocks_2K\tPROC FRAME\r\n\t\t\trex_push_reg rsi\r\n\t\t\tpush_reg rdi\r\n\t\t\tpush_reg rbx\r\n\t\t\t.endprolog\r\n\t\t\tmov rsi, r8\r\n\t\t\tmov r11, r9\r\n\t\t#else\r\n\t\t\tAS2(\tmov\t\tWORD_REG(cx), data\t\t\t)\r\n\t\t\tAS2(\tmov\t\tWORD_REG(dx), len\t\t\t)\r\n\t\t\tAS2(\tmov\t\tWORD_REG(si), hashBuffer\t)\r\n\t\t\tAS2(\tshr\t\tWORD_REG(dx), 4\t\t\t\t)\r\n\t\t#endif\r\n\r\n\t\tAS_PUSH_IF86(\tbx)\r\n\t\tAS_PUSH_IF86(\tbp)\r\n\r\n\t\t#ifdef __GNUC__\r\n\t\t\tAS2(\tmov\t\tAS_REG_7, WORD_REG(di))\r\n\t\t#elif CRYPTOPP_BOOL_X86\r\n\t\t\tAS2(\tlea\t\tAS_REG_7, s_reductionTable)\r\n\t\t#endif\r\n\r\n\t\tAS2(\tmovdqa\txmm0, [WORD_REG(si)]\t\t\t)\r\n\r\n\t\t#define MUL_TABLE_0 WORD_REG(si) + 32\r\n\t\t#define MUL_TABLE_1 WORD_REG(si) + 32 + 1024\r\n\t\t#define RED_TABLE AS_REG_7\r\n\r\n\t\tASL(0)\r\n\t\tAS2(\tmovdqu\txmm4, [WORD_REG(cx)]\t\t\t)\r\n\t\tAS2(\tpxor\txmm0, xmm4\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tmovd\tebx, xmm0\t\t\t\t\t\t)\r\n\t\tAS2(\tmov\t\teax, AS_HEX(f0f0f0f0)\t\t\t)\r\n\t\tAS2(\tand\t\teax, ebx\t\t\t\t\t\t)\r\n\t\tAS2(\tshl\t\tebx, 4\t\t\t\t\t\t\t)\r\n\t\tAS2(\tand\t\tebx, AS_HEX(f0f0f0f0)\t\t\t)\r\n\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm5, XMMWORD_PTR [MUL_TABLE_1 + WORD_REG(di)]\t)\r\n\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm4, XMMWORD_PTR [MUL_TABLE_1 + WORD_REG(di)]\t)\r\n\t\tAS2(\tshr\t\teax, 16\t\t\t\t\t\t\t)\r\n\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm3, XMMWORD_PTR [MUL_TABLE_1 + WORD_REG(di)]\t)\r\n\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm2, XMMWORD_PTR [MUL_TABLE_1 + WORD_REG(di)]\t)\r\n\r\n\t\t#define SSE2_MUL_32BITS(i)\t\t\t\t\t\t\t\t\t\t\t\\\r\n\t\t\tAS2(\tpsrldq\txmm0, 4\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovd\teax, xmm0\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tand\t\teax, AS_HEX(f0f0f0f0)\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, bh\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm5, XMMWORD_PTR [MUL_TABLE_0 + (i-1)*256 + WORD_REG(di)]\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, bl\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm4, XMMWORD_PTR [MUL_TABLE_0 + (i-1)*256 + WORD_REG(di)]\t)\\\r\n\t\t\tAS2(\tshr\t\tebx, 16\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, bh\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm3, XMMWORD_PTR [MUL_TABLE_0 + (i-1)*256 + WORD_REG(di)]\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, bl\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm2, XMMWORD_PTR [MUL_TABLE_0 + (i-1)*256 + WORD_REG(di)]\t)\\\r\n\t\t\tAS2(\tmovd\tebx, xmm0\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tshl\t\tebx, 4\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tand\t\tebx, AS_HEX(f0f0f0f0)\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm5, XMMWORD_PTR [MUL_TABLE_1 + i*256 + WORD_REG(di)]\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm4, XMMWORD_PTR [MUL_TABLE_1 + i*256 + WORD_REG(di)]\t\t)\\\r\n\t\t\tAS2(\tshr\t\teax, 16\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm3, XMMWORD_PTR [MUL_TABLE_1 + i*256 + WORD_REG(di)]\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm2, XMMWORD_PTR [MUL_TABLE_1 + i*256 + WORD_REG(di)]\t\t)\\\r\n\r\n\t\tSSE2_MUL_32BITS(1)\r\n\t\tSSE2_MUL_32BITS(2)\r\n\t\tSSE2_MUL_32BITS(3)\r\n\r\n\t\tAS2(\tmovzx\tedi, bh\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm5, XMMWORD_PTR [MUL_TABLE_0 + 3*256 + WORD_REG(di)]\t)\r\n\t\tAS2(\tmovzx\tedi, bl\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm4, XMMWORD_PTR [MUL_TABLE_0 + 3*256 + WORD_REG(di)]\t)\r\n\t\tAS2(\tshr\t\tebx, 16\t\t\t\t\t\t)\r\n\t\tAS2(\tmovzx\tedi, bh\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm3, XMMWORD_PTR [MUL_TABLE_0 + 3*256 + WORD_REG(di)]\t)\r\n\t\tAS2(\tmovzx\tedi, bl\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm2, XMMWORD_PTR [MUL_TABLE_0 + 3*256 + WORD_REG(di)]\t)\r\n\r\n\t\tAS2(\tmovdqa\txmm0, xmm3\t\t\t\t\t\t)\r\n\t\tAS2(\tpslldq\txmm3, 1\t\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm2, xmm3\t\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm1, xmm2\t\t\t\t\t\t)\r\n\t\tAS2(\tpslldq\txmm2, 1\t\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm5, xmm2\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tpsrldq\txmm0, 15\t\t\t\t\t\t)\r\n\t\tAS2(\tmovd\tWORD_REG(di), xmm0\t\t\t\t\t)\r\n\t\tAS2(\tmovzx\teax, WORD PTR [RED_TABLE + WORD_REG(di)*2]\t)\r\n\t\tAS2(\tshl\t\teax, 8\t\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tmovdqa\txmm0, xmm5\t\t\t\t\t\t)\r\n\t\tAS2(\tpslldq\txmm5, 1\t\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm4, xmm5\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tpsrldq\txmm1, 15\t\t\t\t\t\t)\r\n\t\tAS2(\tmovd\tWORD_REG(di), xmm1\t\t\t\t\t)\r\n\t\tAS2(\txor\t\tax, WORD PTR [RED_TABLE + WORD_REG(di)*2]\t)\r\n\t\tAS2(\tshl\t\teax, 8\t\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tpsrldq\txmm0, 15\t\t\t\t\t\t)\r\n\t\tAS2(\tmovd\tWORD_REG(di), xmm0\t\t\t\t\t)\r\n\t\tAS2(\txor\t\tax, WORD PTR [RED_TABLE + WORD_REG(di)*2]\t)\r\n\r\n\t\tAS2(\tmovd\txmm0, eax\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm0, xmm4\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tadd\t\tWORD_REG(cx), 16\t\t\t\t\t)\r\n\t\tAS2(\tsub\t\tWORD_REG(dx), 1\t\t\t\t\t\t)\r\n\t\tASJ(\tjnz,\t0, b\t\t\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\t[WORD_REG(si)], xmm0\t\t\t\t)\r\n\r\n\t\tAS_POP_IF86(\tbp)\r\n\t\tAS_POP_IF86(\tbx)\r\n\r\n\t\t#ifdef __GNUC__\r\n\t\t\t\t\".att_syntax prefix;\"\r\n\t\t\t\t\t: \r\n\t\t\t\t\t: \"c\" (data), \"d\" (len/16), \"S\" (hashBuffer), \"D\" (s_reductionTable)\r\n\t\t\t\t\t: \"memory\", \"cc\", \"%eax\"\r\n\t\t\t#if CRYPTOPP_BOOL_X64\r\n\t\t\t\t\t, \"%ebx\", \"%r11\"\r\n\t\t\t#endif\r\n\t\t\t\t);\r\n\t\t#elif defined(CRYPTOPP_GENERATE_X64_MASM)\r\n\t\t\tpop rbx\r\n\t\t\tpop rdi\r\n\t\t\tpop rsi\r\n\t\t\tret\r\n\t\t\tGCM_AuthenticateBlocks_2K ENDP\r\n\t\t#endif\r\n\r\n\t\treturn len%16;\r\n\t\t}\r\n\tcase 3:\t\t// SSE2 and 64K tables\r\n\t\t{\r\n\t\t#ifdef __GNUC__\r\n\t\t\t__asm__ __volatile__\r\n\t\t\t(\r\n\t\t\t\".intel_syntax noprefix;\"\r\n\t\t#elif defined(CRYPTOPP_GENERATE_X64_MASM)\r\n\t\t\tALIGN   8\r\n\t\t\tGCM_AuthenticateBlocks_64K\tPROC FRAME\r\n\t\t\trex_push_reg rsi\r\n\t\t\tpush_reg rdi\r\n\t\t\t.endprolog\r\n\t\t\tmov rsi, r8\r\n\t\t#else\r\n\t\t\tAS2(\tmov\t\tWORD_REG(cx), data\t\t\t)\r\n\t\t\tAS2(\tmov\t\tWORD_REG(dx), len\t\t\t)\r\n\t\t\tAS2(\tmov\t\tWORD_REG(si), hashBuffer\t)\r\n\t\t\tAS2(\tshr\t\tWORD_REG(dx), 4\t\t\t\t)\r\n\t\t#endif\r\n\r\n\t\tAS2(\tmovdqa\txmm0, [WORD_REG(si)]\t\t\t\t)\r\n\r\n\t\t#undef MUL_TABLE\r\n\t\t#define MUL_TABLE(i,j) WORD_REG(si) + 32 + (i*4+j)*256*16\r\n\r\n\t\tASL(1)\r\n\t\tAS2(\tmovdqu\txmm1, [WORD_REG(cx)]\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm1, xmm0\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm0, xmm0\t\t\t\t\t\t)\r\n\r\n\t\t#undef SSE2_MUL_32BITS\r\n\t\t#define SSE2_MUL_32BITS(i)\t\t\t\t\t\t\t\t\\\r\n\t\t\tAS2(\tmovd\teax, xmm1\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpsrldq\txmm1, 4\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(di)\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm0, [MUL_TABLE(i,0) + WORD_REG(di)*8]\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(di)\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm0, [MUL_TABLE(i,1) + WORD_REG(di)*8]\t)\\\r\n\t\t\tAS2(\tshr\t\teax, 16\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(di)\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm0, [MUL_TABLE(i,2) + WORD_REG(di)*8]\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(di)\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm0, [MUL_TABLE(i,3) + WORD_REG(di)*8]\t)\\\r\n\r\n\t\tSSE2_MUL_32BITS(0)\r\n\t\tSSE2_MUL_32BITS(1)\r\n\t\tSSE2_MUL_32BITS(2)\r\n\t\tSSE2_MUL_32BITS(3)\r\n\r\n\t\tAS2(\tadd\t\tWORD_REG(cx), 16\t\t\t\t\t)\r\n\t\tAS2(\tsub\t\tWORD_REG(dx), 1\t\t\t\t\t\t)\r\n\t\tASJ(\tjnz,\t1, b\t\t\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\t[WORD_REG(si)], xmm0\t\t\t\t)\r\n\r\n\t\t#ifdef __GNUC__\r\n\t\t\t\t\".att_syntax prefix;\"\r\n\t\t\t\t\t: \r\n\t\t\t\t\t: \"c\" (data), \"d\" (len/16), \"S\" (hashBuffer)\r\n\t\t\t\t\t: \"memory\", \"cc\", \"%edi\", \"%eax\"\r\n\t\t\t\t);\r\n\t\t#elif defined(CRYPTOPP_GENERATE_X64_MASM)\r\n\t\t\tpop rdi\r\n\t\t\tpop rsi\r\n\t\t\tret\r\n\t\t\tGCM_AuthenticateBlocks_64K ENDP\r\n\t\t#endif\r\n\r\n\t\treturn len%16;\r\n\t\t}\r\n#endif\r\n#ifndef CRYPTOPP_GENERATE_X64_MASM\r\n\t}\r\n\r\n\treturn len%16;\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define RED_TABLE AS_REG_7",
      "#define MUL_TABLE_1 WORD_REG(si) + 32 + 1024",
      "#define MUL_TABLE_0 WORD_REG(si) + 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "\"S\"",
          "args": [
            "hashBuffer"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"d\"",
          "args": [
            "len/16"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"c\"",
          "args": [
            "data"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AS2",
          "args": [
            "movdqa\t[WORD_REG(si)]",
            "xmm0"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "si"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASJ",
          "args": [
            "jnz",
            "1",
            "b"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSE2_MUL_32BITS",
          "args": [
            "3"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSE2_MUL_32BITS",
          "args": [
            "2"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSE2_MUL_32BITS",
          "args": [
            "1"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSE2_MUL_32BITS",
          "args": [
            "0"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "cx"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASL",
          "args": [
            "1"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "si"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"D\"",
          "args": [
            "s_reductionTable"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"S\"",
          "args": [
            "hashBuffer"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"d\"",
          "args": [
            "len/16"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"c\"",
          "args": [
            "data"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AS_POP_IF86",
          "args": [
            "bx"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AS_POP_IF86",
          "args": [
            "bp"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AS2",
          "args": [
            "movdqa\t[WORD_REG(si)]",
            "xmm0"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "si"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASJ",
          "args": [
            "jnz",
            "0",
            "b"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSE2_MUL_32BITS",
          "args": [
            "3"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSE2_MUL_32BITS",
          "args": [
            "2"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SSE2_MUL_32BITS",
          "args": [
            "1"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "di"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "cx"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASL",
          "args": [
            "0"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WORD_REG",
          "args": [
            "si"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AS_PUSH_IF86",
          "args": [
            "bp"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AS_PUSH_IF86",
          "args": [
            "bx"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GCM_AuthenticateBlocks_64K",
          "args": [
            "data",
            "len/16",
            "hashBuffer"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GCM_AuthenticateBlocks_2K",
          "args": [
            "data",
            "len/16",
            "hashBuffer",
            "s_reductionTable"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,1",
            "3",
            "3"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,1",
            "3",
            "2"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,1",
            "3",
            "1"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,1",
            "3",
            "0"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,1",
            "2",
            "3"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,1",
            "2",
            "2"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,1",
            "2",
            "1"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,1",
            "2",
            "0"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,0",
            "1",
            "3"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,0",
            "1",
            "2"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,0",
            "1",
            "1"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,0",
            "1",
            "0"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,0",
            "0",
            "3"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,0",
            "0",
            "2"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "^=,0",
            "0",
            "1"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_8BY128",
          "args": [
            "=,0",
            "0",
            "0"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "x1>>32"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "x0>>32"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Block::Get",
          "args": [
            "y1"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MulTable",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConditionalByteReverse<word64>",
          "args": [
            "LITTLE_ENDIAN_ORDER",
            "r"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "922-925",
          "snippet": "inline T ConditionalByteReverse(ByteOrder order, T value)\n{\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T ConditionalByteReverse(ByteOrder order, T value)\n{\n\treturn NativeByteOrderIs(order) ? value : ByteReverse(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GF_SHIFT_8",
          "args": [
            "b"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MOST_SIG_8BITS",
          "args": [
            "b"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_SHIFT_8",
          "args": [
            "c"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MOST_SIG_8BITS",
          "args": [
            "c"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_SHIFT_8",
          "args": [
            "d"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MOST_SIG_8BITS",
          "args": [
            "d"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_32BY128",
          "args": [
            "^=,1",
            "1",
            "3"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_32BY128",
          "args": [
            "^=,1",
            "0",
            "2"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_32BY128",
          "args": [
            "^=,0",
            "1",
            "1"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GF_MUL_32BY128",
          "args": [
            "=,0",
            "0",
            "0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "x1>>32"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "x0>>32"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MulTable",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HasSSE2",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "HasSSE2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "123-128",
          "snippet": "inline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "defined",
          "args": [
            "CRYPTOPP_X64_MASM_AVAILABLE"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.size",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashBuffer",
          "args": [],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_store_si128",
          "args": [
            "(__m128i *)HashBuffer()",
            "x"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashBuffer",
          "args": [],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLMUL_Reduce",
          "args": [
            "c0",
            "c1",
            "c2",
            "r"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "CLMUL_Reduce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "88-118",
          "snippet": "inline __m128i CLMUL_Reduce(__m128i c0, __m128i c1, __m128i c2, const __m128i &r)\r\n{\r\n\t/* \r\n\tThe polynomial to be reduced is c0 * x^128 + c1 * x^64 + c2. c0t below refers to the most \r\n\tsignificant half of c0 as a polynomial, which, due to GCM's bit reflection, are in the\r\n\trightmost bit positions, and the lowest byte addresses.\r\n\r\n\tc1 ^= c0t * 0xc200000000000000\r\n\tc2t ^= c0t\r\n\tt = shift (c1t ^ c0b) left 1 bit\r\n\tc2 ^= t * 0xe100000000000000\r\n\tc2t ^= c1b\r\n\tshift c2 left 1 bit and xor in lowest bit of c1t\r\n\t*/\r\n#if 0\t// MSVC 2010 workaround: see http://connect.microsoft.com/VisualStudio/feedback/details/575301\r\n\tc2 = _mm_xor_si128(c2, _mm_move_epi64(c0));\r\n#else\r\n\tc1 = _mm_xor_si128(c1, _mm_slli_si128(c0, 8));\r\n#endif\r\n\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(c0, r, 0x10));\r\n\tc0 = _mm_srli_si128(c0, 8);\r\n\tc0 = _mm_xor_si128(c0, c1);\r\n\tc0 = _mm_slli_epi64(c0, 1);\r\n\tc0 = _mm_clmulepi64_si128(c0, r, 0);\r\n\tc2 = _mm_xor_si128(c2, c0);\r\n\tc2 = _mm_xor_si128(c2, _mm_srli_si128(c1, 8));\r\n\tc1 = _mm_unpacklo_epi64(c1, c2);\r\n\tc1 = _mm_srli_epi64(c1, 63);\r\n\tc2 = _mm_slli_epi64(c2, 1);\r\n\treturn _mm_xor_si128(c2, c1);\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline __m128i CLMUL_Reduce(__m128i c0, __m128i c1, __m128i c2, const __m128i &r)\r\n{\r\n\t/* \r\n\tThe polynomial to be reduced is c0 * x^128 + c1 * x^64 + c2. c0t below refers to the most \r\n\tsignificant half of c0 as a polynomial, which, due to GCM's bit reflection, are in the\r\n\trightmost bit positions, and the lowest byte addresses.\r\n\r\n\tc1 ^= c0t * 0xc200000000000000\r\n\tc2t ^= c0t\r\n\tt = shift (c1t ^ c0b) left 1 bit\r\n\tc2 ^= t * 0xe100000000000000\r\n\tc2t ^= c1b\r\n\tshift c2 left 1 bit and xor in lowest bit of c1t\r\n\t*/\r\n#if 0\t// MSVC 2010 workaround: see http://connect.microsoft.com/VisualStudio/feedback/details/575301\r\n\tc2 = _mm_xor_si128(c2, _mm_move_epi64(c0));\r\n#else\r\n\tc1 = _mm_xor_si128(c1, _mm_slli_si128(c0, 8));\r\n#endif\r\n\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(c0, r, 0x10));\r\n\tc0 = _mm_srli_si128(c0, 8);\r\n\tc0 = _mm_xor_si128(c0, c1);\r\n\tc0 = _mm_slli_epi64(c0, 1);\r\n\tc0 = _mm_clmulepi64_si128(c0, r, 0);\r\n\tc2 = _mm_xor_si128(c2, c0);\r\n\tc2 = _mm_xor_si128(c2, _mm_srli_si128(c1, 8));\r\n\tc1 = _mm_unpacklo_epi64(c1, c2);\r\n\tc1 = _mm_srli_epi64(c1, 63);\r\n\tc2 = _mm_slli_epi64(c2, 1);\r\n\treturn _mm_xor_si128(c2, c1);\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "_mm_xor_si128(c1, c0)",
            "c2"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c1",
            "c0"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c1",
            "_mm_clmulepi64_si128(d, h01, 0x10)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_clmulepi64_si128",
          "args": [
            "d",
            "h01",
            "0x10"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_clmulepi64_si128",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "47-60",
          "snippet": "__m128i _mm_clmulepi64_si128(const __m128i &a, const __m128i &b, int i)\r\n{\r\n\tword64 A[1] = {ByteReverse(((word64*)&a)[i&1])};\r\n\tword64 B[1] = {ByteReverse(((word64*)&b)[i>>4])};\r\n\r\n\tPolynomialMod2 pa((byte *)A, 8);\r\n\tPolynomialMod2 pb((byte *)B, 8);\r\n\tPolynomialMod2 c = pa*pb;\r\n\r\n\t__m128i output;\r\n\tfor (int i=0; i<16; i++)\r\n\t\t((byte *)&output)[i] = c.GetByte(i);\r\n\treturn output;\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\n__m128i _mm_clmulepi64_si128(const __m128i &a, const __m128i &b, int i)\r\n{\r\n\tword64 A[1] = {ByteReverse(((word64*)&a)[i&1])};\r\n\tword64 B[1] = {ByteReverse(((word64*)&b)[i>>4])};\r\n\r\n\tPolynomialMod2 pa((byte *)A, 8);\r\n\tPolynomialMod2 pb((byte *)B, 8);\r\n\tPolynomialMod2 c = pa*pb;\r\n\r\n\t__m128i output;\r\n\tfor (int i=0; i<16; i++)\r\n\t\t((byte *)&output)[i] = c.GetByte(i);\r\n\treturn output;\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "d",
            "d2"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c2",
            "_mm_clmulepi64_si128(d2, h1, 0x10)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c0",
            "_mm_clmulepi64_si128(d, h0, 0x10)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_shuffle_epi8",
          "args": [
            "_mm_loadu_si128((const __m128i *)(data+(s-i)*16-8))",
            "bswapMask"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_shuffle_epi8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "23-28",
          "snippet": "__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_epi8 (__m128i a, __m128i b)\n{\n\tasm (\"pshufb %1, %0\" : \"+x\"(a) : \"xm\"(b));\n  \treturn a;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\n__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_epi8 (__m128i a, __m128i b)\n{\n\tasm (\"pshufb %1, %0\" : \"+x\"(a) : \"xm\"(b));\n  \treturn a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_loadu_si128",
          "args": [
            "(const __m128i *)(data+(s-i)*16-8)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c1",
            "_mm_clmulepi64_si128(d, h01, 0x10)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "d",
            "_mm_shuffle_epi32(d, _MM_SHUFFLE(1, 0, 3, 2))"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_shuffle_epi32",
          "args": [
            "d",
            "_MM_SHUFFLE(1, 0, 3, 2)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MM_SHUFFLE",
          "args": [
            "1",
            "0",
            "3",
            "2"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c2",
            "_mm_clmulepi64_si128(d, h1, 0x11)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c0",
            "_mm_clmulepi64_si128(d, h0, 0x10)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "d",
            "x"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_loadu_si128",
          "args": [
            "(const __m128i *)data"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c1",
            "_mm_clmulepi64_si128(d2, h01, 1)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "d2",
            "d"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c2",
            "_mm_clmulepi64_si128(d, h1, 1)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c0",
            "_mm_clmulepi64_si128(d2, h0, 1)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_loadu_si128",
          "args": [
            "(const __m128i *)(data+(s-i)*16-8)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c1",
            "_mm_clmulepi64_si128(d, h01, 0)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "d",
            "_mm_shuffle_epi32(d, _MM_SHUFFLE(1, 0, 3, 2))"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_shuffle_epi32",
          "args": [
            "d",
            "_MM_SHUFFLE(1, 0, 3, 2)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MM_SHUFFLE",
          "args": [
            "1",
            "0",
            "3",
            "2"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c2",
            "_mm_clmulepi64_si128(d, h1, 1)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c0",
            "_mm_clmulepi64_si128(d, h0, 0)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "d",
            "x"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_loadu_si128",
          "args": [
            "(const __m128i *)data"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "h0",
            "h1"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_load_si128",
          "args": [
            "table+i+1"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_load_si128",
          "args": [
            "table+i"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_setzero_si128",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_setzero_si128",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_setzero_si128",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_loadu_si128",
          "args": [
            "(const __m128i *)(data+(s-1)*16)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "len/16",
            "s_clmulTableSizeInBlocks"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_load_si128",
          "args": [
            "(__m128i *)HashBuffer()"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashBuffer",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MulTable",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HasCLMUL",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "HasCLMUL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "160-165",
          "snippet": "inline bool HasCLMUL()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasCLMUL;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasCLMUL()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasCLMUL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\n#define RED_TABLE AS_REG_7\n#define MUL_TABLE_1 WORD_REG(si) + 32 + 1024\n#define MUL_TABLE_0 WORD_REG(si) + 32\n\nsize_t GCM_Base::AuthenticateBlocks(const byte *data, size_t len)\r\n{\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\tconst __m128i *table = (const __m128i *)MulTable();\r\n\t\t__m128i x = _mm_load_si128((__m128i *)HashBuffer());\r\n\t\tconst __m128i r = s_clmulConstants[0], bswapMask = s_clmulConstants[1], bswapMask2 = s_clmulConstants[2];\r\n\r\n\t\twhile (len >= 16)\r\n\t\t{\r\n\t\t\tsize_t s = UnsignedMin(len/16, s_clmulTableSizeInBlocks), i=0;\r\n\t\t\t__m128i d, d2 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(data+(s-1)*16)), bswapMask2);;\r\n\t\t\t__m128i c0 = _mm_setzero_si128();\r\n\t\t\t__m128i c1 = _mm_setzero_si128();\r\n\t\t\t__m128i c2 = _mm_setzero_si128();\r\n\r\n\t\t\twhile (true)\r\n\t\t\t{\r\n\t\t\t\t__m128i h0 = _mm_load_si128(table+i);\r\n\t\t\t\t__m128i h1 = _mm_load_si128(table+i+1);\r\n\t\t\t\t__m128i h01 = _mm_xor_si128(h0, h1);\r\n\r\n\t\t\t\tif (++i == s)\r\n\t\t\t\t{\r\n\t\t\t\t\td = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)data), bswapMask);\r\n\t\t\t\t\td = _mm_xor_si128(d, x);\r\n\t\t\t\t\tc0 = _mm_xor_si128(c0, _mm_clmulepi64_si128(d, h0, 0));\r\n\t\t\t\t\tc2 = _mm_xor_si128(c2, _mm_clmulepi64_si128(d, h1, 1));\r\n\t\t\t\t\td = _mm_xor_si128(d, _mm_shuffle_epi32(d, _MM_SHUFFLE(1, 0, 3, 2)));\r\n\t\t\t\t\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(d, h01, 0));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\td = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(data+(s-i)*16-8)), bswapMask2);\r\n\t\t\t\tc0 = _mm_xor_si128(c0, _mm_clmulepi64_si128(d2, h0, 1));\r\n\t\t\t\tc2 = _mm_xor_si128(c2, _mm_clmulepi64_si128(d, h1, 1));\r\n\t\t\t\td2 = _mm_xor_si128(d2, d);\r\n\t\t\t\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(d2, h01, 1));\r\n\r\n\t\t\t\tif (++i == s)\r\n\t\t\t\t{\r\n\t\t\t\t\td = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)data), bswapMask);\r\n\t\t\t\t\td = _mm_xor_si128(d, x);\r\n\t\t\t\t\tc0 = _mm_xor_si128(c0, _mm_clmulepi64_si128(d, h0, 0x10));\r\n\t\t\t\t\tc2 = _mm_xor_si128(c2, _mm_clmulepi64_si128(d, h1, 0x11));\r\n\t\t\t\t\td = _mm_xor_si128(d, _mm_shuffle_epi32(d, _MM_SHUFFLE(1, 0, 3, 2)));\r\n\t\t\t\t\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(d, h01, 0x10));\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\td2 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)(data+(s-i)*16-8)), bswapMask);\r\n\t\t\t\tc0 = _mm_xor_si128(c0, _mm_clmulepi64_si128(d, h0, 0x10));\r\n\t\t\t\tc2 = _mm_xor_si128(c2, _mm_clmulepi64_si128(d2, h1, 0x10));\r\n\t\t\t\td = _mm_xor_si128(d, d2);\r\n\t\t\t\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(d, h01, 0x10));\r\n\t\t\t}\r\n\t\t\tdata += s*16;\r\n\t\t\tlen -= s*16;\r\n\r\n\t\t\tc1 = _mm_xor_si128(_mm_xor_si128(c1, c0), c2);\r\n\t\t\tx = CLMUL_Reduce(c0, c1, c2, r);\r\n\t\t}\r\n\r\n\t\t_mm_store_si128((__m128i *)HashBuffer(), x);\r\n\t\treturn len;\r\n\t}\r\n#endif\r\n\r\n\ttypedef BlockGetAndPut<word64, NativeByteOrder> Block;\r\n\tword64 *hashBuffer = (word64 *)HashBuffer();\r\n\r\n\tswitch (2*(m_buffer.size()>=64*1024)\r\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\r\n\t\t+ HasSSE2()\r\n#endif\r\n\t\t)\r\n\t{\r\n\tcase 0:\t\t// non-SSE2 and 2K tables\r\n\t\t{\r\n\t\tbyte *table = MulTable();\r\n\t\tword64 x0 = hashBuffer[0], x1 = hashBuffer[1];\r\n\r\n\t\tdo\r\n\t\t{\r\n\t\t\tword64 y0, y1, a0, a1, b0, b1, c0, c1, d0, d1;\r\n\t\t\tBlock::Get(data)(y0)(y1);\r\n\t\t\tx0 ^= y0;\r\n\t\t\tx1 ^= y1;\r\n\r\n\t\t\tdata += HASH_BLOCKSIZE;\r\n\t\t\tlen -= HASH_BLOCKSIZE;\r\n\r\n\t\t\t#define READ_TABLE_WORD64_COMMON(a, b, c, d)\t*(word64 *)(table+(a*1024)+(b*256)+c+d*8)\r\n\r\n\t\t\t#ifdef IS_LITTLE_ENDIAN\r\n\t\t\t\t#if CRYPTOPP_BOOL_SLOW_WORD64\r\n\t\t\t\t\tword32 z0 = (word32)x0;\r\n\t\t\t\t\tword32 z1 = (word32)(x0>>32);\r\n\t\t\t\t\tword32 z2 = (word32)x1;\r\n\t\t\t\t\tword32 z3 = (word32)(x1>>32);\r\n\t\t\t\t\t#define READ_TABLE_WORD64(a, b, c, d, e)\tREAD_TABLE_WORD64_COMMON((d%2), c, (d?(z##c>>((d?d-1:0)*4))&0xf0:(z##c&0xf)<<4), e)\r\n\t\t\t\t#else\r\n\t\t\t\t\t#define READ_TABLE_WORD64(a, b, c, d, e)\tREAD_TABLE_WORD64_COMMON((d%2), c, ((d+8*b)?(x##a>>(((d+8*b)?(d+8*b)-1:1)*4))&0xf0:(x##a&0xf)<<4), e)\r\n\t\t\t\t#endif\r\n\t\t\t\t#define GF_MOST_SIG_8BITS(a) (a##1 >> 7*8)\r\n\t\t\t\t#define GF_SHIFT_8(a) a##1 = (a##1 << 8) ^ (a##0 >> 7*8); a##0 <<= 8;\r\n\t\t\t#else\r\n\t\t\t\t#define READ_TABLE_WORD64(a, b, c, d, e)\tREAD_TABLE_WORD64_COMMON((1-d%2), c, ((15-d-8*b)?(x##a>>(((15-d-8*b)?(15-d-8*b)-1:0)*4))&0xf0:(x##a&0xf)<<4), e)\r\n\t\t\t\t#define GF_MOST_SIG_8BITS(a) (a##1 & 0xff)\r\n\t\t\t\t#define GF_SHIFT_8(a) a##1 = (a##1 >> 8) ^ (a##0 << 7*8); a##0 >>= 8;\r\n\t\t\t#endif\r\n\r\n\t\t\t#define GF_MUL_32BY128(op, a, b, c)\t\t\t\t\t\t\t\t\t\t\t\\\r\n\t\t\t\ta0 op READ_TABLE_WORD64(a, b, c, 0, 0) ^ READ_TABLE_WORD64(a, b, c, 1, 0);\\\r\n\t\t\t\ta1 op READ_TABLE_WORD64(a, b, c, 0, 1) ^ READ_TABLE_WORD64(a, b, c, 1, 1);\\\r\n\t\t\t\tb0 op READ_TABLE_WORD64(a, b, c, 2, 0) ^ READ_TABLE_WORD64(a, b, c, 3, 0);\\\r\n\t\t\t\tb1 op READ_TABLE_WORD64(a, b, c, 2, 1) ^ READ_TABLE_WORD64(a, b, c, 3, 1);\\\r\n\t\t\t\tc0 op READ_TABLE_WORD64(a, b, c, 4, 0) ^ READ_TABLE_WORD64(a, b, c, 5, 0);\\\r\n\t\t\t\tc1 op READ_TABLE_WORD64(a, b, c, 4, 1) ^ READ_TABLE_WORD64(a, b, c, 5, 1);\\\r\n\t\t\t\td0 op READ_TABLE_WORD64(a, b, c, 6, 0) ^ READ_TABLE_WORD64(a, b, c, 7, 0);\\\r\n\t\t\t\td1 op READ_TABLE_WORD64(a, b, c, 6, 1) ^ READ_TABLE_WORD64(a, b, c, 7, 1);\\\r\n\r\n\t\t\tGF_MUL_32BY128(=, 0, 0, 0)\r\n\t\t\tGF_MUL_32BY128(^=, 0, 1, 1)\r\n\t\t\tGF_MUL_32BY128(^=, 1, 0, 2)\r\n\t\t\tGF_MUL_32BY128(^=, 1, 1, 3)\r\n\r\n\t\t\tword32 r = (word32)s_reductionTable[GF_MOST_SIG_8BITS(d)] << 16;\r\n\t\t\tGF_SHIFT_8(d)\r\n\t\t\tc0 ^= d0; c1 ^= d1;\r\n\t\t\tr ^= (word32)s_reductionTable[GF_MOST_SIG_8BITS(c)] << 8;\r\n\t\t\tGF_SHIFT_8(c)\r\n\t\t\tb0 ^= c0; b1 ^= c1;\r\n\t\t\tr ^= s_reductionTable[GF_MOST_SIG_8BITS(b)];\r\n\t\t\tGF_SHIFT_8(b)\r\n\t\t\ta0 ^= b0; a1 ^= b1;\r\n\t\t\ta0 ^= ConditionalByteReverse<word64>(LITTLE_ENDIAN_ORDER, r);\r\n\t\t\tx0 = a0; x1 = a1;\r\n\t\t}\r\n\t\twhile (len >= HASH_BLOCKSIZE);\r\n\r\n\t\thashBuffer[0] = x0; hashBuffer[1] = x1;\r\n\t\treturn len;\r\n\t\t}\r\n\r\n\tcase 2:\t\t// non-SSE2 and 64K tables\r\n\t\t{\r\n\t\tbyte *table = MulTable();\r\n\t\tword64 x0 = hashBuffer[0], x1 = hashBuffer[1];\r\n\r\n\t\tdo\r\n\t\t{\r\n\t\t\tword64 y0, y1, a0, a1;\r\n\t\t\tBlock::Get(data)(y0)(y1);\r\n\t\t\tx0 ^= y0;\r\n\t\t\tx1 ^= y1;\r\n\r\n\t\t\tdata += HASH_BLOCKSIZE;\r\n\t\t\tlen -= HASH_BLOCKSIZE;\r\n\r\n\t\t\t#undef READ_TABLE_WORD64_COMMON\r\n\t\t\t#undef READ_TABLE_WORD64\r\n\r\n\t\t\t#define READ_TABLE_WORD64_COMMON(a, c, d)\t*(word64 *)(table+(a)*256*16+(c)+(d)*8)\r\n\r\n\t\t\t#ifdef IS_LITTLE_ENDIAN\r\n\t\t\t\t#if CRYPTOPP_BOOL_SLOW_WORD64\r\n\t\t\t\t\tword32 z0 = (word32)x0;\r\n\t\t\t\t\tword32 z1 = (word32)(x0>>32);\r\n\t\t\t\t\tword32 z2 = (word32)x1;\r\n\t\t\t\t\tword32 z3 = (word32)(x1>>32);\r\n\t\t\t\t\t#define READ_TABLE_WORD64(b, c, d, e)\tREAD_TABLE_WORD64_COMMON(c*4+d, (d?(z##c>>((d?d:1)*8-4))&0xff0:(z##c&0xff)<<4), e)\r\n\t\t\t\t#else\r\n\t\t\t\t\t#define READ_TABLE_WORD64(b, c, d, e)\tREAD_TABLE_WORD64_COMMON(c*4+d, ((d+4*(c%2))?(x##b>>(((d+4*(c%2))?(d+4*(c%2)):1)*8-4))&0xff0:(x##b&0xff)<<4), e)\r\n\t\t\t\t#endif\r\n\t\t\t#else\r\n\t\t\t\t#define READ_TABLE_WORD64(b, c, d, e)\tREAD_TABLE_WORD64_COMMON(c*4+d, ((7-d-4*(c%2))?(x##b>>(((7-d-4*(c%2))?(7-d-4*(c%2)):1)*8-4))&0xff0:(x##b&0xff)<<4), e)\r\n\t\t\t#endif\r\n\r\n\t\t\t#define GF_MUL_8BY128(op, b, c, d)\t\t\\\r\n\t\t\t\ta0 op READ_TABLE_WORD64(b, c, d, 0);\\\r\n\t\t\t\ta1 op READ_TABLE_WORD64(b, c, d, 1);\\\r\n\r\n\t\t\tGF_MUL_8BY128(=, 0, 0, 0)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 0, 1)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 0, 2)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 0, 3)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 1, 0)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 1, 1)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 1, 2)\r\n\t\t\tGF_MUL_8BY128(^=, 0, 1, 3)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 2, 0)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 2, 1)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 2, 2)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 2, 3)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 3, 0)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 3, 1)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 3, 2)\r\n\t\t\tGF_MUL_8BY128(^=, 1, 3, 3)\r\n\r\n\t\t\tx0 = a0; x1 = a1;\r\n\t\t}\r\n\t\twhile (len >= HASH_BLOCKSIZE);\r\n\r\n\t\thashBuffer[0] = x0; hashBuffer[1] = x1;\r\n\t\treturn len;\r\n\t\t}\r\n#endif\t// #ifndef CRYPTOPP_GENERATE_X64_MASM\r\n\r\n#ifdef CRYPTOPP_X64_MASM_AVAILABLE\r\n\tcase 1:\t\t// SSE2 and 2K tables\r\n\t\tGCM_AuthenticateBlocks_2K(data, len/16, hashBuffer, s_reductionTable);\r\n\t\treturn len % 16;\r\n\tcase 3:\t\t// SSE2 and 64K tables\r\n\t\tGCM_AuthenticateBlocks_64K(data, len/16, hashBuffer);\r\n\t\treturn len % 16;\r\n#endif\r\n\r\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\r\n\tcase 1:\t\t// SSE2 and 2K tables\r\n\t\t{\r\n\t\t#ifdef __GNUC__\r\n\t\t\t__asm__ __volatile__\r\n\t\t\t(\r\n\t\t\t\".intel_syntax noprefix;\"\r\n\t\t#elif defined(CRYPTOPP_GENERATE_X64_MASM)\r\n\t\t\tALIGN   8\r\n\t\t\tGCM_AuthenticateBlocks_2K\tPROC FRAME\r\n\t\t\trex_push_reg rsi\r\n\t\t\tpush_reg rdi\r\n\t\t\tpush_reg rbx\r\n\t\t\t.endprolog\r\n\t\t\tmov rsi, r8\r\n\t\t\tmov r11, r9\r\n\t\t#else\r\n\t\t\tAS2(\tmov\t\tWORD_REG(cx), data\t\t\t)\r\n\t\t\tAS2(\tmov\t\tWORD_REG(dx), len\t\t\t)\r\n\t\t\tAS2(\tmov\t\tWORD_REG(si), hashBuffer\t)\r\n\t\t\tAS2(\tshr\t\tWORD_REG(dx), 4\t\t\t\t)\r\n\t\t#endif\r\n\r\n\t\tAS_PUSH_IF86(\tbx)\r\n\t\tAS_PUSH_IF86(\tbp)\r\n\r\n\t\t#ifdef __GNUC__\r\n\t\t\tAS2(\tmov\t\tAS_REG_7, WORD_REG(di))\r\n\t\t#elif CRYPTOPP_BOOL_X86\r\n\t\t\tAS2(\tlea\t\tAS_REG_7, s_reductionTable)\r\n\t\t#endif\r\n\r\n\t\tAS2(\tmovdqa\txmm0, [WORD_REG(si)]\t\t\t)\r\n\r\n\t\t#define MUL_TABLE_0 WORD_REG(si) + 32\r\n\t\t#define MUL_TABLE_1 WORD_REG(si) + 32 + 1024\r\n\t\t#define RED_TABLE AS_REG_7\r\n\r\n\t\tASL(0)\r\n\t\tAS2(\tmovdqu\txmm4, [WORD_REG(cx)]\t\t\t)\r\n\t\tAS2(\tpxor\txmm0, xmm4\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tmovd\tebx, xmm0\t\t\t\t\t\t)\r\n\t\tAS2(\tmov\t\teax, AS_HEX(f0f0f0f0)\t\t\t)\r\n\t\tAS2(\tand\t\teax, ebx\t\t\t\t\t\t)\r\n\t\tAS2(\tshl\t\tebx, 4\t\t\t\t\t\t\t)\r\n\t\tAS2(\tand\t\tebx, AS_HEX(f0f0f0f0)\t\t\t)\r\n\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm5, XMMWORD_PTR [MUL_TABLE_1 + WORD_REG(di)]\t)\r\n\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm4, XMMWORD_PTR [MUL_TABLE_1 + WORD_REG(di)]\t)\r\n\t\tAS2(\tshr\t\teax, 16\t\t\t\t\t\t\t)\r\n\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm3, XMMWORD_PTR [MUL_TABLE_1 + WORD_REG(di)]\t)\r\n\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm2, XMMWORD_PTR [MUL_TABLE_1 + WORD_REG(di)]\t)\r\n\r\n\t\t#define SSE2_MUL_32BITS(i)\t\t\t\t\t\t\t\t\t\t\t\\\r\n\t\t\tAS2(\tpsrldq\txmm0, 4\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovd\teax, xmm0\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tand\t\teax, AS_HEX(f0f0f0f0)\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, bh\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm5, XMMWORD_PTR [MUL_TABLE_0 + (i-1)*256 + WORD_REG(di)]\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, bl\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm4, XMMWORD_PTR [MUL_TABLE_0 + (i-1)*256 + WORD_REG(di)]\t)\\\r\n\t\t\tAS2(\tshr\t\tebx, 16\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, bh\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm3, XMMWORD_PTR [MUL_TABLE_0 + (i-1)*256 + WORD_REG(di)]\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, bl\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm2, XMMWORD_PTR [MUL_TABLE_0 + (i-1)*256 + WORD_REG(di)]\t)\\\r\n\t\t\tAS2(\tmovd\tebx, xmm0\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tshl\t\tebx, 4\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tand\t\tebx, AS_HEX(f0f0f0f0)\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm5, XMMWORD_PTR [MUL_TABLE_1 + i*256 + WORD_REG(di)]\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm4, XMMWORD_PTR [MUL_TABLE_1 + i*256 + WORD_REG(di)]\t\t)\\\r\n\t\t\tAS2(\tshr\t\teax, 16\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm3, XMMWORD_PTR [MUL_TABLE_1 + i*256 + WORD_REG(di)]\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm2, XMMWORD_PTR [MUL_TABLE_1 + i*256 + WORD_REG(di)]\t\t)\\\r\n\r\n\t\tSSE2_MUL_32BITS(1)\r\n\t\tSSE2_MUL_32BITS(2)\r\n\t\tSSE2_MUL_32BITS(3)\r\n\r\n\t\tAS2(\tmovzx\tedi, bh\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm5, XMMWORD_PTR [MUL_TABLE_0 + 3*256 + WORD_REG(di)]\t)\r\n\t\tAS2(\tmovzx\tedi, bl\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm4, XMMWORD_PTR [MUL_TABLE_0 + 3*256 + WORD_REG(di)]\t)\r\n\t\tAS2(\tshr\t\tebx, 16\t\t\t\t\t\t)\r\n\t\tAS2(\tmovzx\tedi, bh\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm3, XMMWORD_PTR [MUL_TABLE_0 + 3*256 + WORD_REG(di)]\t)\r\n\t\tAS2(\tmovzx\tedi, bl\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm2, XMMWORD_PTR [MUL_TABLE_0 + 3*256 + WORD_REG(di)]\t)\r\n\r\n\t\tAS2(\tmovdqa\txmm0, xmm3\t\t\t\t\t\t)\r\n\t\tAS2(\tpslldq\txmm3, 1\t\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm2, xmm3\t\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\txmm1, xmm2\t\t\t\t\t\t)\r\n\t\tAS2(\tpslldq\txmm2, 1\t\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm5, xmm2\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tpsrldq\txmm0, 15\t\t\t\t\t\t)\r\n\t\tAS2(\tmovd\tWORD_REG(di), xmm0\t\t\t\t\t)\r\n\t\tAS2(\tmovzx\teax, WORD PTR [RED_TABLE + WORD_REG(di)*2]\t)\r\n\t\tAS2(\tshl\t\teax, 8\t\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tmovdqa\txmm0, xmm5\t\t\t\t\t\t)\r\n\t\tAS2(\tpslldq\txmm5, 1\t\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm4, xmm5\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tpsrldq\txmm1, 15\t\t\t\t\t\t)\r\n\t\tAS2(\tmovd\tWORD_REG(di), xmm1\t\t\t\t\t)\r\n\t\tAS2(\txor\t\tax, WORD PTR [RED_TABLE + WORD_REG(di)*2]\t)\r\n\t\tAS2(\tshl\t\teax, 8\t\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tpsrldq\txmm0, 15\t\t\t\t\t\t)\r\n\t\tAS2(\tmovd\tWORD_REG(di), xmm0\t\t\t\t\t)\r\n\t\tAS2(\txor\t\tax, WORD PTR [RED_TABLE + WORD_REG(di)*2]\t)\r\n\r\n\t\tAS2(\tmovd\txmm0, eax\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm0, xmm4\t\t\t\t\t\t)\r\n\r\n\t\tAS2(\tadd\t\tWORD_REG(cx), 16\t\t\t\t\t)\r\n\t\tAS2(\tsub\t\tWORD_REG(dx), 1\t\t\t\t\t\t)\r\n\t\tASJ(\tjnz,\t0, b\t\t\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\t[WORD_REG(si)], xmm0\t\t\t\t)\r\n\r\n\t\tAS_POP_IF86(\tbp)\r\n\t\tAS_POP_IF86(\tbx)\r\n\r\n\t\t#ifdef __GNUC__\r\n\t\t\t\t\".att_syntax prefix;\"\r\n\t\t\t\t\t: \r\n\t\t\t\t\t: \"c\" (data), \"d\" (len/16), \"S\" (hashBuffer), \"D\" (s_reductionTable)\r\n\t\t\t\t\t: \"memory\", \"cc\", \"%eax\"\r\n\t\t\t#if CRYPTOPP_BOOL_X64\r\n\t\t\t\t\t, \"%ebx\", \"%r11\"\r\n\t\t\t#endif\r\n\t\t\t\t);\r\n\t\t#elif defined(CRYPTOPP_GENERATE_X64_MASM)\r\n\t\t\tpop rbx\r\n\t\t\tpop rdi\r\n\t\t\tpop rsi\r\n\t\t\tret\r\n\t\t\tGCM_AuthenticateBlocks_2K ENDP\r\n\t\t#endif\r\n\r\n\t\treturn len%16;\r\n\t\t}\r\n\tcase 3:\t\t// SSE2 and 64K tables\r\n\t\t{\r\n\t\t#ifdef __GNUC__\r\n\t\t\t__asm__ __volatile__\r\n\t\t\t(\r\n\t\t\t\".intel_syntax noprefix;\"\r\n\t\t#elif defined(CRYPTOPP_GENERATE_X64_MASM)\r\n\t\t\tALIGN   8\r\n\t\t\tGCM_AuthenticateBlocks_64K\tPROC FRAME\r\n\t\t\trex_push_reg rsi\r\n\t\t\tpush_reg rdi\r\n\t\t\t.endprolog\r\n\t\t\tmov rsi, r8\r\n\t\t#else\r\n\t\t\tAS2(\tmov\t\tWORD_REG(cx), data\t\t\t)\r\n\t\t\tAS2(\tmov\t\tWORD_REG(dx), len\t\t\t)\r\n\t\t\tAS2(\tmov\t\tWORD_REG(si), hashBuffer\t)\r\n\t\t\tAS2(\tshr\t\tWORD_REG(dx), 4\t\t\t\t)\r\n\t\t#endif\r\n\r\n\t\tAS2(\tmovdqa\txmm0, [WORD_REG(si)]\t\t\t\t)\r\n\r\n\t\t#undef MUL_TABLE\r\n\t\t#define MUL_TABLE(i,j) WORD_REG(si) + 32 + (i*4+j)*256*16\r\n\r\n\t\tASL(1)\r\n\t\tAS2(\tmovdqu\txmm1, [WORD_REG(cx)]\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm1, xmm0\t\t\t\t\t\t)\r\n\t\tAS2(\tpxor\txmm0, xmm0\t\t\t\t\t\t)\r\n\r\n\t\t#undef SSE2_MUL_32BITS\r\n\t\t#define SSE2_MUL_32BITS(i)\t\t\t\t\t\t\t\t\\\r\n\t\t\tAS2(\tmovd\teax, xmm1\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpsrldq\txmm1, 4\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(di)\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm0, [MUL_TABLE(i,0) + WORD_REG(di)*8]\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(di)\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm0, [MUL_TABLE(i,1) + WORD_REG(di)*8]\t)\\\r\n\t\t\tAS2(\tshr\t\teax, 16\t\t\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, al\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(di)\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm0, [MUL_TABLE(i,2) + WORD_REG(di)*8]\t)\\\r\n\t\t\tAS2(\tmovzx\tedi, ah\t\t\t\t\t\t)\\\r\n\t\t\tAS2(\tadd\t\tWORD_REG(di), WORD_REG(di)\t\t\t\t\t)\\\r\n\t\t\tAS2(\tpxor\txmm0, [MUL_TABLE(i,3) + WORD_REG(di)*8]\t)\\\r\n\r\n\t\tSSE2_MUL_32BITS(0)\r\n\t\tSSE2_MUL_32BITS(1)\r\n\t\tSSE2_MUL_32BITS(2)\r\n\t\tSSE2_MUL_32BITS(3)\r\n\r\n\t\tAS2(\tadd\t\tWORD_REG(cx), 16\t\t\t\t\t)\r\n\t\tAS2(\tsub\t\tWORD_REG(dx), 1\t\t\t\t\t\t)\r\n\t\tASJ(\tjnz,\t1, b\t\t\t\t\t\t\t)\r\n\t\tAS2(\tmovdqa\t[WORD_REG(si)], xmm0\t\t\t\t)\r\n\r\n\t\t#ifdef __GNUC__\r\n\t\t\t\t\".att_syntax prefix;\"\r\n\t\t\t\t\t: \r\n\t\t\t\t\t: \"c\" (data), \"d\" (len/16), \"S\" (hashBuffer)\r\n\t\t\t\t\t: \"memory\", \"cc\", \"%edi\", \"%eax\"\r\n\t\t\t\t);\r\n\t\t#elif defined(CRYPTOPP_GENERATE_X64_MASM)\r\n\t\t\tpop rdi\r\n\t\t\tpop rsi\r\n\t\t\tret\r\n\t\t\tGCM_AuthenticateBlocks_64K ENDP\r\n\t\t#endif\r\n\r\n\t\treturn len%16;\r\n\t\t}\r\n#endif\r\n#ifndef CRYPTOPP_GENERATE_X64_MASM\r\n\t}\r\n\r\n\treturn len%16;\r\n}"
  },
  {
    "function_name": "GCM_Base::Resync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "283-326",
    "snippet": "void GCM_Base::Resync(const byte *iv, size_t len)\r\n{\r\n\tBlockCipher &cipher = AccessBlockCipher();\r\n\tbyte *hashBuffer = HashBuffer();\r\n\r\n\tif (len == 12)\r\n\t{\r\n\t\tmemcpy(hashBuffer, iv, len);\r\n\t\tmemset(hashBuffer+len, 0, 3);\r\n\t\thashBuffer[len+3] = 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsize_t origLen = len;\r\n\t\tmemset(hashBuffer, 0, HASH_BLOCKSIZE);\r\n\r\n\t\tif (len >= HASH_BLOCKSIZE)\r\n\t\t{\r\n\t\t\tlen = GCM_Base::AuthenticateBlocks(iv, len);\r\n\t\t\tiv += (origLen - len);\r\n\t\t}\r\n\r\n\t\tif (len > 0)\r\n\t\t{\r\n\t\t\tmemcpy(m_buffer, iv, len);\r\n\t\t\tmemset(m_buffer+len, 0, HASH_BLOCKSIZE-len);\r\n\t\t\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n\t\t}\r\n\r\n\t\tPutBlock<word64, BigEndian, true>(NULL, m_buffer)(0)(origLen*8);\r\n\t\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n\r\n\t\tReverseHashBufferIfNeeded();\r\n\t}\r\n\r\n\tif (m_state >= State_IVSet)\r\n\t\tm_ctr.Resynchronize(hashBuffer, REQUIRED_BLOCKSIZE);\r\n\telse\r\n\t\tm_ctr.SetCipherWithIV(cipher, hashBuffer);\r\n\r\n\tm_ctr.Seek(HASH_BLOCKSIZE);\r\n\r\n\tmemset(hashBuffer, 0, HASH_BLOCKSIZE);\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hashBuffer",
            "0",
            "HASH_BLOCKSIZE"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ctr.Seek",
          "args": [
            "HASH_BLOCKSIZE"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_ctr.SetCipherWithIV",
          "args": [
            "cipher",
            "hashBuffer"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "SetCipherWithIV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "52-60",
          "snippet": "void SetCipherWithIV(BlockCipher &cipher, const byte *iv, int feedbackSize = 0)\n\t{\n\t\tthis->ThrowIfInvalidIV(iv);\n\t\tthis->m_cipher = &cipher;\n\t\tthis->ResizeBuffers();\n\t\tthis->SetFeedbackSize(feedbackSize);\n\t\tif (this->IsResynchronizable())\n\t\t\tthis->Resynchronize(iv);\n\t}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid SetCipherWithIV(BlockCipher &cipher, const byte *iv, int feedbackSize = 0)\n\t{\n\t\tthis->ThrowIfInvalidIV(iv);\n\t\tthis->m_cipher = &cipher;\n\t\tthis->ResizeBuffers();\n\t\tthis->SetFeedbackSize(feedbackSize);\n\t\tif (this->IsResynchronizable())\n\t\t\tthis->Resynchronize(iv);\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "m_ctr.Resynchronize",
          "args": [
            "hashBuffer",
            "REQUIRED_BLOCKSIZE"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReverseHashBufferIfNeeded",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "GCM_Base::ReverseHashBufferIfNeeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "272-281",
          "snippet": "inline void GCM_Base::ReverseHashBufferIfNeeded()\r\n{\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\t__m128i &x = *(__m128i *)HashBuffer();\r\n\t\tx = _mm_shuffle_epi8(x, s_clmulConstants[1]);\r\n\t}\r\n#endif\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline void GCM_Base::ReverseHashBufferIfNeeded()\r\n{\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\t__m128i &x = *(__m128i *)HashBuffer();\r\n\t\tx = _mm_shuffle_epi8(x, s_clmulConstants[1]);\r\n\t}\r\n#endif\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "GCM_Base::AuthenticateBlocks",
          "args": [
            "m_buffer",
            "HASH_BLOCKSIZE"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<word64, BigEndian, true>",
          "args": [
            "origLen*8"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<word64, BigEndian, true>",
          "args": [
            "0"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<word64, BigEndian, true>",
          "args": [
            "NULL",
            "m_buffer"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GCM_Base::AuthenticateBlocks",
          "args": [
            "m_buffer",
            "HASH_BLOCKSIZE"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_buffer+len",
            "0",
            "HASH_BLOCKSIZE-len"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_buffer",
            "iv",
            "len"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GCM_Base::AuthenticateBlocks",
          "args": [
            "iv",
            "len"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hashBuffer",
            "0",
            "HASH_BLOCKSIZE"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hashBuffer+len",
            "0",
            "3"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hashBuffer",
            "iv",
            "len"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashBuffer",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessBlockCipher",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\nvoid GCM_Base::Resync(const byte *iv, size_t len)\r\n{\r\n\tBlockCipher &cipher = AccessBlockCipher();\r\n\tbyte *hashBuffer = HashBuffer();\r\n\r\n\tif (len == 12)\r\n\t{\r\n\t\tmemcpy(hashBuffer, iv, len);\r\n\t\tmemset(hashBuffer+len, 0, 3);\r\n\t\thashBuffer[len+3] = 1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsize_t origLen = len;\r\n\t\tmemset(hashBuffer, 0, HASH_BLOCKSIZE);\r\n\r\n\t\tif (len >= HASH_BLOCKSIZE)\r\n\t\t{\r\n\t\t\tlen = GCM_Base::AuthenticateBlocks(iv, len);\r\n\t\t\tiv += (origLen - len);\r\n\t\t}\r\n\r\n\t\tif (len > 0)\r\n\t\t{\r\n\t\t\tmemcpy(m_buffer, iv, len);\r\n\t\t\tmemset(m_buffer+len, 0, HASH_BLOCKSIZE-len);\r\n\t\t\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n\t\t}\r\n\r\n\t\tPutBlock<word64, BigEndian, true>(NULL, m_buffer)(0)(origLen*8);\r\n\t\tGCM_Base::AuthenticateBlocks(m_buffer, HASH_BLOCKSIZE);\r\n\r\n\t\tReverseHashBufferIfNeeded();\r\n\t}\r\n\r\n\tif (m_state >= State_IVSet)\r\n\t\tm_ctr.Resynchronize(hashBuffer, REQUIRED_BLOCKSIZE);\r\n\telse\r\n\t\tm_ctr.SetCipherWithIV(cipher, hashBuffer);\r\n\r\n\tm_ctr.Seek(HASH_BLOCKSIZE);\r\n\r\n\tmemset(hashBuffer, 0, HASH_BLOCKSIZE);\r\n}"
  },
  {
    "function_name": "GCM_Base::ReverseHashBufferIfNeeded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "272-281",
    "snippet": "inline void GCM_Base::ReverseHashBufferIfNeeded()\r\n{\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\t__m128i &x = *(__m128i *)HashBuffer();\r\n\t\tx = _mm_shuffle_epi8(x, s_clmulConstants[1]);\r\n\t}\r\n#endif\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_mm_shuffle_epi8",
          "args": [
            "x",
            "s_clmulConstants[1]"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_shuffle_epi8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "23-28",
          "snippet": "__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_epi8 (__m128i a, __m128i b)\n{\n\tasm (\"pshufb %1, %0\" : \"+x\"(a) : \"xm\"(b));\n  \treturn a;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\n__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_epi8 (__m128i a, __m128i b)\n{\n\tasm (\"pshufb %1, %0\" : \"+x\"(a) : \"xm\"(b));\n  \treturn a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashBuffer",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HasCLMUL",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "HasCLMUL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "160-165",
          "snippet": "inline bool HasCLMUL()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasCLMUL;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasCLMUL()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasCLMUL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline void GCM_Base::ReverseHashBufferIfNeeded()\r\n{\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\t__m128i &x = *(__m128i *)HashBuffer();\r\n\t\tx = _mm_shuffle_epi8(x, s_clmulConstants[1]);\r\n\t}\r\n#endif\r\n}"
  },
  {
    "function_name": "GCM_Base::SetKeyWithoutResync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "130-270",
    "snippet": "void GCM_Base::SetKeyWithoutResync(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tBlockCipher &blockCipher = AccessBlockCipher();\r\n\tblockCipher.SetKey(userKey, keylength, params);\r\n\r\n\tif (blockCipher.BlockSize() != REQUIRED_BLOCKSIZE)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": block size of underlying block cipher is not 16\");\r\n\r\n\tint tableSize, i, j, k;\r\n\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\tparams.GetIntValue(Name::TableSize(), tableSize);\t// avoid \"parameter not used\" error\r\n\t\ttableSize = s_clmulTableSizeInBlocks * REQUIRED_BLOCKSIZE;\r\n\t}\r\n\telse\r\n#endif\r\n\t{\r\n\t\tif (params.GetIntValue(Name::TableSize(), tableSize))\r\n\t\t\ttableSize = (tableSize >= 64*1024) ? 64*1024 : 2*1024;\r\n\t\telse\r\n\t\t\ttableSize = (GetTablesOption() == GCM_64K_Tables) ? 64*1024 : 2*1024;\r\n\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1300 && _MSC_VER < 1400)\r\n\t\t// VC 2003 workaround: compiler generates bad code for 64K tables\r\n\t\ttableSize = 2*1024;\r\n#endif\r\n\t}\r\n\r\n\tm_buffer.resize(3*REQUIRED_BLOCKSIZE + tableSize);\r\n\tbyte *table = MulTable();\r\n\tbyte *hashKey = HashKey();\r\n\tmemset(hashKey, 0, REQUIRED_BLOCKSIZE);\r\n\tblockCipher.ProcessBlock(hashKey);\r\n\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\tconst __m128i r = s_clmulConstants[0];\r\n\t\t__m128i h0 = _mm_shuffle_epi8(_mm_load_si128((__m128i *)hashKey), s_clmulConstants[1]);\r\n\t\t__m128i h = h0;\r\n\r\n\t\tfor (i=0; i<tableSize; i+=32)\r\n\t\t{\r\n\t\t\t__m128i h1 = CLMUL_GF_Mul(h, h0, r);\r\n\t\t\t_mm_storel_epi64((__m128i *)(table+i), h);\r\n\t\t\t_mm_storeu_si128((__m128i *)(table+i+16), h1);\r\n\t\t\t_mm_storeu_si128((__m128i *)(table+i+8), h);\r\n\t\t\t_mm_storel_epi64((__m128i *)(table+i+8), h1);\r\n\t\t\th = CLMUL_GF_Mul(h1, h0, r);\r\n\t\t}\r\n\r\n\t\treturn;\r\n\t}\r\n#endif\r\n\r\n\tword64 V0, V1;\r\n\ttypedef BlockGetAndPut<word64, BigEndian> Block;\r\n\tBlock::Get(hashKey)(V0)(V1);\r\n\r\n\tif (tableSize == 64*1024)\r\n\t{\r\n\t\tfor (i=0; i<128; i++)\r\n\t\t{\r\n\t\t\tk = i%8;\r\n\t\t\tBlock::Put(NULL, table+(i/8)*256*16+(size_t(1)<<(11-k)))(V0)(V1);\r\n\r\n\t\t\tint x = (int)V1 & 1; \r\n\t\t\tV1 = (V1>>1) | (V0<<63);\r\n\t\t\tV0 = (V0>>1) ^ (x ? W64LIT(0xe1) << 56 : 0);\r\n\t\t}\r\n\r\n\t\tfor (i=0; i<16; i++)\r\n\t\t{\r\n\t\t\tmemset(table+i*256*16, 0, 16);\r\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\r\n\t\t\tif (HasSSE2())\r\n\t\t\t\tfor (j=2; j<=0x80; j*=2)\r\n\t\t\t\t\tfor (k=1; k<j; k++)\r\n\t\t\t\t\t\tSSE2_Xor16(table+i*256*16+(j+k)*16, table+i*256*16+j*16, table+i*256*16+k*16);\r\n\t\t\telse\r\n#endif\r\n\t\t\t\tfor (j=2; j<=0x80; j*=2)\r\n\t\t\t\t\tfor (k=1; k<j; k++)\r\n\t\t\t\t\t\tXor16(table+i*256*16+(j+k)*16, table+i*256*16+j*16, table+i*256*16+k*16);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!s_reductionTableInitialized)\r\n\t\t{\r\n\t\t\ts_reductionTable[0] = 0;\r\n\t\t\tword16 x = 0x01c2;\r\n\t\t\ts_reductionTable[1] = ByteReverse(x);\r\n\t\t\tfor (int i=2; i<=0x80; i*=2)\r\n\t\t\t{\r\n\t\t\t\tx <<= 1;\r\n\t\t\t\ts_reductionTable[i] = ByteReverse(x);\r\n\t\t\t\tfor (int j=1; j<i; j++)\r\n\t\t\t\t\ts_reductionTable[i+j] = s_reductionTable[i] ^ s_reductionTable[j];\r\n\t\t\t}\r\n\t\t\ts_reductionTableInitialized = true;\r\n\t\t}\r\n\r\n\t\tfor (i=0; i<128-24; i++)\r\n\t\t{\r\n\t\t\tk = i%32;\r\n\t\t\tif (k < 4)\r\n\t\t\t\tBlock::Put(NULL, table+1024+(i/32)*256+(size_t(1)<<(7-k)))(V0)(V1);\r\n\t\t\telse if (k < 8)\r\n\t\t\t\tBlock::Put(NULL, table+(i/32)*256+(size_t(1)<<(11-k)))(V0)(V1);\r\n\r\n\t\t\tint x = (int)V1 & 1; \r\n\t\t\tV1 = (V1>>1) | (V0<<63);\r\n\t\t\tV0 = (V0>>1) ^ (x ? W64LIT(0xe1) << 56 : 0);\r\n\t\t}\r\n\r\n\t\tfor (i=0; i<4; i++)\r\n\t\t{\r\n\t\t\tmemset(table+i*256, 0, 16);\r\n\t\t\tmemset(table+1024+i*256, 0, 16);\r\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\r\n\t\t\tif (HasSSE2())\r\n\t\t\t\tfor (j=2; j<=8; j*=2)\r\n\t\t\t\t\tfor (k=1; k<j; k++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSSE2_Xor16(table+i*256+(j+k)*16, table+i*256+j*16, table+i*256+k*16);\r\n\t\t\t\t\t\tSSE2_Xor16(table+1024+i*256+(j+k)*16, table+1024+i*256+j*16, table+1024+i*256+k*16);\r\n\t\t\t\t\t}\r\n\t\t\telse\r\n#endif\r\n\t\t\t\tfor (j=2; j<=8; j*=2)\r\n\t\t\t\t\tfor (k=1; k<j; k++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tXor16(table+i*256+(j+k)*16, table+i*256+j*16, table+i*256+k*16);\r\n\t\t\t\t\t\tXor16(table+1024+i*256+(j+k)*16, table+1024+i*256+j*16, table+1024+i*256+k*16);\r\n\t\t\t\t\t}\r\n\t\t}\r\n\t}\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Xor16",
          "args": [
            "table+1024+i*256+(j+k)*16",
            "table+1024+i*256+j*16",
            "table+1024+i*256+k*16"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "Xor16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "74-78",
          "snippet": "inline static void Xor16(byte *a, const byte *b, const byte *c)\r\n{\r\n\t((word64 *)a)[0] = ((word64 *)b)[0] ^ ((word64 *)c)[0];\r\n\t((word64 *)a)[1] = ((word64 *)b)[1] ^ ((word64 *)c)[1];\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline static void Xor16(byte *a, const byte *b, const byte *c)\r\n{\r\n\t((word64 *)a)[0] = ((word64 *)b)[0] ^ ((word64 *)c)[0];\r\n\t((word64 *)a)[1] = ((word64 *)b)[1] ^ ((word64 *)c)[1];\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSE2_Xor16",
          "args": [
            "table+1024+i*256+(j+k)*16",
            "table+1024+i*256+j*16",
            "table+1024+i*256+k*16"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "SSE2_Xor16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "64-71",
          "snippet": "inline static void SSE2_Xor16(byte *a, const byte *b, const byte *c)\r\n{\r\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\r\n\t*(__m128i *)a = _mm_xor_si128(*(__m128i *)b, *(__m128i *)c);\r\n#else\r\n\tasm (\"movdqa %1, %%xmm0; pxor %2, %%xmm0; movdqa %%xmm0, %0;\" : \"=m\" (a[0]) : \"m\"(b[0]), \"m\"(c[0]));\r\n#endif\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline static void SSE2_Xor16(byte *a, const byte *b, const byte *c)\r\n{\r\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\r\n\t*(__m128i *)a = _mm_xor_si128(*(__m128i *)b, *(__m128i *)c);\r\n#else\r\n\tasm (\"movdqa %1, %%xmm0; pxor %2, %%xmm0; movdqa %%xmm0, %0;\" : \"=m\" (a[0]) : \"m\"(b[0]), \"m\"(c[0]));\r\n#endif\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "HasSSE2",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "HasSSE2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "123-128",
          "snippet": "inline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "table+1024+i*256",
            "0",
            "16"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "table+i*256",
            "0",
            "16"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xe1"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "V1"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "NULL",
            "table+(i/32)*256+(size_t(1)<<(11-k))"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "1"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "1"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "x"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "table+i*256*16",
            "0",
            "16"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xe1"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "1"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Block::Get",
          "args": [
            "V1"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLMUL_GF_Mul",
          "args": [
            "h1",
            "h0",
            "r"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "CLMUL_GF_Mul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "120-127",
          "snippet": "inline __m128i CLMUL_GF_Mul(const __m128i &x, const __m128i &h, const __m128i &r)\r\n{\r\n\t__m128i c0 = _mm_clmulepi64_si128(x,h,0);\r\n\t__m128i c1 = _mm_xor_si128(_mm_clmulepi64_si128(x,h,1), _mm_clmulepi64_si128(x,h,0x10));\r\n\t__m128i c2 = _mm_clmulepi64_si128(x,h,0x11);\r\n\r\n\treturn CLMUL_Reduce(c0, c1, c2, r);\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline __m128i CLMUL_GF_Mul(const __m128i &x, const __m128i &h, const __m128i &r)\r\n{\r\n\t__m128i c0 = _mm_clmulepi64_si128(x,h,0);\r\n\t__m128i c1 = _mm_xor_si128(_mm_clmulepi64_si128(x,h,1), _mm_clmulepi64_si128(x,h,0x10));\r\n\t__m128i c2 = _mm_clmulepi64_si128(x,h,0x11);\r\n\r\n\treturn CLMUL_Reduce(c0, c1, c2, r);\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_storel_epi64",
          "args": [
            "(__m128i *)(table+i+8)",
            "h1"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_storeu_si128",
          "args": [
            "(__m128i *)(table+i+8)",
            "h"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_storeu_si128",
          "args": [
            "(__m128i *)(table+i+16)",
            "h1"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_storel_epi64",
          "args": [
            "(__m128i *)(table+i)",
            "h"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_shuffle_epi8",
          "args": [
            "_mm_load_si128((__m128i *)hashKey)",
            "s_clmulConstants[1]"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_shuffle_epi8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "23-28",
          "snippet": "__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_epi8 (__m128i a, __m128i b)\n{\n\tasm (\"pshufb %1, %0\" : \"+x\"(a) : \"xm\"(b));\n  \treturn a;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\n__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_epi8 (__m128i a, __m128i b)\n{\n\tasm (\"pshufb %1, %0\" : \"+x\"(a) : \"xm\"(b));\n  \treturn a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_load_si128",
          "args": [
            "(__m128i *)hashKey"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HasCLMUL",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "HasCLMUL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "160-165",
          "snippet": "inline bool HasCLMUL()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasCLMUL;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasCLMUL()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasCLMUL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockCipher.ProcessBlock",
          "args": [
            "hashKey"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hashKey",
            "0",
            "REQUIRED_BLOCKSIZE"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashKey",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MulTable",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.resize",
          "args": [
            "3*REQUIRED_BLOCKSIZE + tableSize"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTablesOption",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "GetTablesOption",
          "container": "GCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.h",
          "lines": "91-91",
          "snippet": "GCM_TablesOption GetTablesOption() const {return T_TablesOption;}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nGCM_Final {\n  GCM_TablesOption GetTablesOption() const {return T_TablesOption;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.GetIntValue",
          "args": [
            "Name::TableSize()",
            "tableSize"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::TableSize",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetIntValue",
          "args": [
            "Name::TableSize()",
            "tableSize"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::TableSize",
          "args": [],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": block size of underlying block cipher is not 16\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "GCM_Final",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.h",
          "lines": "85-86",
          "snippet": "static std::string StaticAlgorithmName()\r\n\t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/GCM\");}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nGCM_Final {\n  static std::string StaticAlgorithmName()\r\n  \t\t{return T_BlockCipher::StaticAlgorithmName() + std::string(\"/GCM\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockCipher.BlockSize",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "blockCipher.SetKey",
          "args": [
            "userKey",
            "keylength",
            "params"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AccessBlockCipher",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\nvoid GCM_Base::SetKeyWithoutResync(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tBlockCipher &blockCipher = AccessBlockCipher();\r\n\tblockCipher.SetKey(userKey, keylength, params);\r\n\r\n\tif (blockCipher.BlockSize() != REQUIRED_BLOCKSIZE)\r\n\t\tthrow InvalidArgument(AlgorithmName() + \": block size of underlying block cipher is not 16\");\r\n\r\n\tint tableSize, i, j, k;\r\n\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\tparams.GetIntValue(Name::TableSize(), tableSize);\t// avoid \"parameter not used\" error\r\n\t\ttableSize = s_clmulTableSizeInBlocks * REQUIRED_BLOCKSIZE;\r\n\t}\r\n\telse\r\n#endif\r\n\t{\r\n\t\tif (params.GetIntValue(Name::TableSize(), tableSize))\r\n\t\t\ttableSize = (tableSize >= 64*1024) ? 64*1024 : 2*1024;\r\n\t\telse\r\n\t\t\ttableSize = (GetTablesOption() == GCM_64K_Tables) ? 64*1024 : 2*1024;\r\n\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1300 && _MSC_VER < 1400)\r\n\t\t// VC 2003 workaround: compiler generates bad code for 64K tables\r\n\t\ttableSize = 2*1024;\r\n#endif\r\n\t}\r\n\r\n\tm_buffer.resize(3*REQUIRED_BLOCKSIZE + tableSize);\r\n\tbyte *table = MulTable();\r\n\tbyte *hashKey = HashKey();\r\n\tmemset(hashKey, 0, REQUIRED_BLOCKSIZE);\r\n\tblockCipher.ProcessBlock(hashKey);\r\n\r\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\r\n\tif (HasCLMUL())\r\n\t{\r\n\t\tconst __m128i r = s_clmulConstants[0];\r\n\t\t__m128i h0 = _mm_shuffle_epi8(_mm_load_si128((__m128i *)hashKey), s_clmulConstants[1]);\r\n\t\t__m128i h = h0;\r\n\r\n\t\tfor (i=0; i<tableSize; i+=32)\r\n\t\t{\r\n\t\t\t__m128i h1 = CLMUL_GF_Mul(h, h0, r);\r\n\t\t\t_mm_storel_epi64((__m128i *)(table+i), h);\r\n\t\t\t_mm_storeu_si128((__m128i *)(table+i+16), h1);\r\n\t\t\t_mm_storeu_si128((__m128i *)(table+i+8), h);\r\n\t\t\t_mm_storel_epi64((__m128i *)(table+i+8), h1);\r\n\t\t\th = CLMUL_GF_Mul(h1, h0, r);\r\n\t\t}\r\n\r\n\t\treturn;\r\n\t}\r\n#endif\r\n\r\n\tword64 V0, V1;\r\n\ttypedef BlockGetAndPut<word64, BigEndian> Block;\r\n\tBlock::Get(hashKey)(V0)(V1);\r\n\r\n\tif (tableSize == 64*1024)\r\n\t{\r\n\t\tfor (i=0; i<128; i++)\r\n\t\t{\r\n\t\t\tk = i%8;\r\n\t\t\tBlock::Put(NULL, table+(i/8)*256*16+(size_t(1)<<(11-k)))(V0)(V1);\r\n\r\n\t\t\tint x = (int)V1 & 1; \r\n\t\t\tV1 = (V1>>1) | (V0<<63);\r\n\t\t\tV0 = (V0>>1) ^ (x ? W64LIT(0xe1) << 56 : 0);\r\n\t\t}\r\n\r\n\t\tfor (i=0; i<16; i++)\r\n\t\t{\r\n\t\t\tmemset(table+i*256*16, 0, 16);\r\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\r\n\t\t\tif (HasSSE2())\r\n\t\t\t\tfor (j=2; j<=0x80; j*=2)\r\n\t\t\t\t\tfor (k=1; k<j; k++)\r\n\t\t\t\t\t\tSSE2_Xor16(table+i*256*16+(j+k)*16, table+i*256*16+j*16, table+i*256*16+k*16);\r\n\t\t\telse\r\n#endif\r\n\t\t\t\tfor (j=2; j<=0x80; j*=2)\r\n\t\t\t\t\tfor (k=1; k<j; k++)\r\n\t\t\t\t\t\tXor16(table+i*256*16+(j+k)*16, table+i*256*16+j*16, table+i*256*16+k*16);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!s_reductionTableInitialized)\r\n\t\t{\r\n\t\t\ts_reductionTable[0] = 0;\r\n\t\t\tword16 x = 0x01c2;\r\n\t\t\ts_reductionTable[1] = ByteReverse(x);\r\n\t\t\tfor (int i=2; i<=0x80; i*=2)\r\n\t\t\t{\r\n\t\t\t\tx <<= 1;\r\n\t\t\t\ts_reductionTable[i] = ByteReverse(x);\r\n\t\t\t\tfor (int j=1; j<i; j++)\r\n\t\t\t\t\ts_reductionTable[i+j] = s_reductionTable[i] ^ s_reductionTable[j];\r\n\t\t\t}\r\n\t\t\ts_reductionTableInitialized = true;\r\n\t\t}\r\n\r\n\t\tfor (i=0; i<128-24; i++)\r\n\t\t{\r\n\t\t\tk = i%32;\r\n\t\t\tif (k < 4)\r\n\t\t\t\tBlock::Put(NULL, table+1024+(i/32)*256+(size_t(1)<<(7-k)))(V0)(V1);\r\n\t\t\telse if (k < 8)\r\n\t\t\t\tBlock::Put(NULL, table+(i/32)*256+(size_t(1)<<(11-k)))(V0)(V1);\r\n\r\n\t\t\tint x = (int)V1 & 1; \r\n\t\t\tV1 = (V1>>1) | (V0<<63);\r\n\t\t\tV0 = (V0>>1) ^ (x ? W64LIT(0xe1) << 56 : 0);\r\n\t\t}\r\n\r\n\t\tfor (i=0; i<4; i++)\r\n\t\t{\r\n\t\t\tmemset(table+i*256, 0, 16);\r\n\t\t\tmemset(table+1024+i*256, 0, 16);\r\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE\r\n\t\t\tif (HasSSE2())\r\n\t\t\t\tfor (j=2; j<=8; j*=2)\r\n\t\t\t\t\tfor (k=1; k<j; k++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tSSE2_Xor16(table+i*256+(j+k)*16, table+i*256+j*16, table+i*256+k*16);\r\n\t\t\t\t\t\tSSE2_Xor16(table+1024+i*256+(j+k)*16, table+1024+i*256+j*16, table+1024+i*256+k*16);\r\n\t\t\t\t\t}\r\n\t\t\telse\r\n#endif\r\n\t\t\t\tfor (j=2; j<=8; j*=2)\r\n\t\t\t\t\tfor (k=1; k<j; k++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tXor16(table+i*256+(j+k)*16, table+i*256+j*16, table+i*256+k*16);\r\n\t\t\t\t\t\tXor16(table+1024+i*256+(j+k)*16, table+1024+i*256+j*16, table+1024+i*256+k*16);\r\n\t\t\t\t\t}\r\n\t\t}\r\n\t}\r\n}"
  },
  {
    "function_name": "CLMUL_GF_Mul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "120-127",
    "snippet": "inline __m128i CLMUL_GF_Mul(const __m128i &x, const __m128i &h, const __m128i &r)\r\n{\r\n\t__m128i c0 = _mm_clmulepi64_si128(x,h,0);\r\n\t__m128i c1 = _mm_xor_si128(_mm_clmulepi64_si128(x,h,1), _mm_clmulepi64_si128(x,h,0x10));\r\n\t__m128i c2 = _mm_clmulepi64_si128(x,h,0x11);\r\n\r\n\treturn CLMUL_Reduce(c0, c1, c2, r);\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLMUL_Reduce",
          "args": [
            "c0",
            "c1",
            "c2",
            "r"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "CLMUL_Reduce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "88-118",
          "snippet": "inline __m128i CLMUL_Reduce(__m128i c0, __m128i c1, __m128i c2, const __m128i &r)\r\n{\r\n\t/* \r\n\tThe polynomial to be reduced is c0 * x^128 + c1 * x^64 + c2. c0t below refers to the most \r\n\tsignificant half of c0 as a polynomial, which, due to GCM's bit reflection, are in the\r\n\trightmost bit positions, and the lowest byte addresses.\r\n\r\n\tc1 ^= c0t * 0xc200000000000000\r\n\tc2t ^= c0t\r\n\tt = shift (c1t ^ c0b) left 1 bit\r\n\tc2 ^= t * 0xe100000000000000\r\n\tc2t ^= c1b\r\n\tshift c2 left 1 bit and xor in lowest bit of c1t\r\n\t*/\r\n#if 0\t// MSVC 2010 workaround: see http://connect.microsoft.com/VisualStudio/feedback/details/575301\r\n\tc2 = _mm_xor_si128(c2, _mm_move_epi64(c0));\r\n#else\r\n\tc1 = _mm_xor_si128(c1, _mm_slli_si128(c0, 8));\r\n#endif\r\n\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(c0, r, 0x10));\r\n\tc0 = _mm_srli_si128(c0, 8);\r\n\tc0 = _mm_xor_si128(c0, c1);\r\n\tc0 = _mm_slli_epi64(c0, 1);\r\n\tc0 = _mm_clmulepi64_si128(c0, r, 0);\r\n\tc2 = _mm_xor_si128(c2, c0);\r\n\tc2 = _mm_xor_si128(c2, _mm_srli_si128(c1, 8));\r\n\tc1 = _mm_unpacklo_epi64(c1, c2);\r\n\tc1 = _mm_srli_epi64(c1, 63);\r\n\tc2 = _mm_slli_epi64(c2, 1);\r\n\treturn _mm_xor_si128(c2, c1);\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline __m128i CLMUL_Reduce(__m128i c0, __m128i c1, __m128i c2, const __m128i &r)\r\n{\r\n\t/* \r\n\tThe polynomial to be reduced is c0 * x^128 + c1 * x^64 + c2. c0t below refers to the most \r\n\tsignificant half of c0 as a polynomial, which, due to GCM's bit reflection, are in the\r\n\trightmost bit positions, and the lowest byte addresses.\r\n\r\n\tc1 ^= c0t * 0xc200000000000000\r\n\tc2t ^= c0t\r\n\tt = shift (c1t ^ c0b) left 1 bit\r\n\tc2 ^= t * 0xe100000000000000\r\n\tc2t ^= c1b\r\n\tshift c2 left 1 bit and xor in lowest bit of c1t\r\n\t*/\r\n#if 0\t// MSVC 2010 workaround: see http://connect.microsoft.com/VisualStudio/feedback/details/575301\r\n\tc2 = _mm_xor_si128(c2, _mm_move_epi64(c0));\r\n#else\r\n\tc1 = _mm_xor_si128(c1, _mm_slli_si128(c0, 8));\r\n#endif\r\n\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(c0, r, 0x10));\r\n\tc0 = _mm_srli_si128(c0, 8);\r\n\tc0 = _mm_xor_si128(c0, c1);\r\n\tc0 = _mm_slli_epi64(c0, 1);\r\n\tc0 = _mm_clmulepi64_si128(c0, r, 0);\r\n\tc2 = _mm_xor_si128(c2, c0);\r\n\tc2 = _mm_xor_si128(c2, _mm_srli_si128(c1, 8));\r\n\tc1 = _mm_unpacklo_epi64(c1, c2);\r\n\tc1 = _mm_srli_epi64(c1, 63);\r\n\tc2 = _mm_slli_epi64(c2, 1);\r\n\treturn _mm_xor_si128(c2, c1);\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_clmulepi64_si128",
          "args": [
            "x",
            "h",
            "0x11"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_clmulepi64_si128",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "47-60",
          "snippet": "__m128i _mm_clmulepi64_si128(const __m128i &a, const __m128i &b, int i)\r\n{\r\n\tword64 A[1] = {ByteReverse(((word64*)&a)[i&1])};\r\n\tword64 B[1] = {ByteReverse(((word64*)&b)[i>>4])};\r\n\r\n\tPolynomialMod2 pa((byte *)A, 8);\r\n\tPolynomialMod2 pb((byte *)B, 8);\r\n\tPolynomialMod2 c = pa*pb;\r\n\r\n\t__m128i output;\r\n\tfor (int i=0; i<16; i++)\r\n\t\t((byte *)&output)[i] = c.GetByte(i);\r\n\treturn output;\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\n__m128i _mm_clmulepi64_si128(const __m128i &a, const __m128i &b, int i)\r\n{\r\n\tword64 A[1] = {ByteReverse(((word64*)&a)[i&1])};\r\n\tword64 B[1] = {ByteReverse(((word64*)&b)[i>>4])};\r\n\r\n\tPolynomialMod2 pa((byte *)A, 8);\r\n\tPolynomialMod2 pb((byte *)B, 8);\r\n\tPolynomialMod2 c = pa*pb;\r\n\r\n\t__m128i output;\r\n\tfor (int i=0; i<16; i++)\r\n\t\t((byte *)&output)[i] = c.GetByte(i);\r\n\treturn output;\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "_mm_clmulepi64_si128(x,h,1)",
            "_mm_clmulepi64_si128(x,h,0x10)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline __m128i CLMUL_GF_Mul(const __m128i &x, const __m128i &h, const __m128i &r)\r\n{\r\n\t__m128i c0 = _mm_clmulepi64_si128(x,h,0);\r\n\t__m128i c1 = _mm_xor_si128(_mm_clmulepi64_si128(x,h,1), _mm_clmulepi64_si128(x,h,0x10));\r\n\t__m128i c2 = _mm_clmulepi64_si128(x,h,0x11);\r\n\r\n\treturn CLMUL_Reduce(c0, c1, c2, r);\r\n}"
  },
  {
    "function_name": "CLMUL_Reduce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "88-118",
    "snippet": "inline __m128i CLMUL_Reduce(__m128i c0, __m128i c1, __m128i c2, const __m128i &r)\r\n{\r\n\t/* \r\n\tThe polynomial to be reduced is c0 * x^128 + c1 * x^64 + c2. c0t below refers to the most \r\n\tsignificant half of c0 as a polynomial, which, due to GCM's bit reflection, are in the\r\n\trightmost bit positions, and the lowest byte addresses.\r\n\r\n\tc1 ^= c0t * 0xc200000000000000\r\n\tc2t ^= c0t\r\n\tt = shift (c1t ^ c0b) left 1 bit\r\n\tc2 ^= t * 0xe100000000000000\r\n\tc2t ^= c1b\r\n\tshift c2 left 1 bit and xor in lowest bit of c1t\r\n\t*/\r\n#if 0\t// MSVC 2010 workaround: see http://connect.microsoft.com/VisualStudio/feedback/details/575301\r\n\tc2 = _mm_xor_si128(c2, _mm_move_epi64(c0));\r\n#else\r\n\tc1 = _mm_xor_si128(c1, _mm_slli_si128(c0, 8));\r\n#endif\r\n\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(c0, r, 0x10));\r\n\tc0 = _mm_srli_si128(c0, 8);\r\n\tc0 = _mm_xor_si128(c0, c1);\r\n\tc0 = _mm_slli_epi64(c0, 1);\r\n\tc0 = _mm_clmulepi64_si128(c0, r, 0);\r\n\tc2 = _mm_xor_si128(c2, c0);\r\n\tc2 = _mm_xor_si128(c2, _mm_srli_si128(c1, 8));\r\n\tc1 = _mm_unpacklo_epi64(c1, c2);\r\n\tc1 = _mm_srli_epi64(c1, 63);\r\n\tc2 = _mm_slli_epi64(c2, 1);\r\n\treturn _mm_xor_si128(c2, c1);\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c2",
            "c1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_slli_epi64",
          "args": [
            "c2",
            "1"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_srli_epi64",
          "args": [
            "c1",
            "63"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_unpacklo_epi64",
          "args": [
            "c1",
            "c2"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c2",
            "_mm_srli_si128(c1, 8)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_srli_si128",
          "args": [
            "c1",
            "8"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c2",
            "c0"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_clmulepi64_si128",
          "args": [
            "c0",
            "r",
            "0"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_clmulepi64_si128",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
          "lines": "47-60",
          "snippet": "__m128i _mm_clmulepi64_si128(const __m128i &a, const __m128i &b, int i)\r\n{\r\n\tword64 A[1] = {ByteReverse(((word64*)&a)[i&1])};\r\n\tword64 B[1] = {ByteReverse(((word64*)&b)[i>>4])};\r\n\r\n\tPolynomialMod2 pa((byte *)A, 8);\r\n\tPolynomialMod2 pb((byte *)B, 8);\r\n\tPolynomialMod2 c = pa*pb;\r\n\r\n\t__m128i output;\r\n\tfor (int i=0; i<16; i++)\r\n\t\t((byte *)&output)[i] = c.GetByte(i);\r\n\treturn output;\r\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"gcm.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\n__m128i _mm_clmulepi64_si128(const __m128i &a, const __m128i &b, int i)\r\n{\r\n\tword64 A[1] = {ByteReverse(((word64*)&a)[i&1])};\r\n\tword64 B[1] = {ByteReverse(((word64*)&b)[i>>4])};\r\n\r\n\tPolynomialMod2 pa((byte *)A, 8);\r\n\tPolynomialMod2 pb((byte *)B, 8);\r\n\tPolynomialMod2 c = pa*pb;\r\n\r\n\t__m128i output;\r\n\tfor (int i=0; i<16; i++)\r\n\t\t((byte *)&output)[i] = c.GetByte(i);\r\n\treturn output;\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_slli_epi64",
          "args": [
            "c0",
            "1"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c0",
            "c1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_srli_si128",
          "args": [
            "c0",
            "8"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c1",
            "_mm_clmulepi64_si128(c0, r, 0x10)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c1",
            "_mm_slli_si128(c0, 8)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_slli_si128",
          "args": [
            "c0",
            "8"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "c2",
            "_mm_move_epi64(c0)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_move_epi64",
          "args": [
            "c0"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline __m128i CLMUL_Reduce(__m128i c0, __m128i c1, __m128i c2, const __m128i &r)\r\n{\r\n\t/* \r\n\tThe polynomial to be reduced is c0 * x^128 + c1 * x^64 + c2. c0t below refers to the most \r\n\tsignificant half of c0 as a polynomial, which, due to GCM's bit reflection, are in the\r\n\trightmost bit positions, and the lowest byte addresses.\r\n\r\n\tc1 ^= c0t * 0xc200000000000000\r\n\tc2t ^= c0t\r\n\tt = shift (c1t ^ c0b) left 1 bit\r\n\tc2 ^= t * 0xe100000000000000\r\n\tc2t ^= c1b\r\n\tshift c2 left 1 bit and xor in lowest bit of c1t\r\n\t*/\r\n#if 0\t// MSVC 2010 workaround: see http://connect.microsoft.com/VisualStudio/feedback/details/575301\r\n\tc2 = _mm_xor_si128(c2, _mm_move_epi64(c0));\r\n#else\r\n\tc1 = _mm_xor_si128(c1, _mm_slli_si128(c0, 8));\r\n#endif\r\n\tc1 = _mm_xor_si128(c1, _mm_clmulepi64_si128(c0, r, 0x10));\r\n\tc0 = _mm_srli_si128(c0, 8);\r\n\tc0 = _mm_xor_si128(c0, c1);\r\n\tc0 = _mm_slli_epi64(c0, 1);\r\n\tc0 = _mm_clmulepi64_si128(c0, r, 0);\r\n\tc2 = _mm_xor_si128(c2, c0);\r\n\tc2 = _mm_xor_si128(c2, _mm_srli_si128(c1, 8));\r\n\tc1 = _mm_unpacklo_epi64(c1, c2);\r\n\tc1 = _mm_srli_epi64(c1, 63);\r\n\tc2 = _mm_slli_epi64(c2, 1);\r\n\treturn _mm_xor_si128(c2, c1);\r\n}"
  },
  {
    "function_name": "Xor16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "74-78",
    "snippet": "inline static void Xor16(byte *a, const byte *b, const byte *c)\r\n{\r\n\t((word64 *)a)[0] = ((word64 *)b)[0] ^ ((word64 *)c)[0];\r\n\t((word64 *)a)[1] = ((word64 *)b)[1] ^ ((word64 *)c)[1];\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline static void Xor16(byte *a, const byte *b, const byte *c)\r\n{\r\n\t((word64 *)a)[0] = ((word64 *)b)[0] ^ ((word64 *)c)[0];\r\n\t((word64 *)a)[1] = ((word64 *)b)[1] ^ ((word64 *)c)[1];\r\n}"
  },
  {
    "function_name": "SSE2_Xor16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "64-71",
    "snippet": "inline static void SSE2_Xor16(byte *a, const byte *b, const byte *c)\r\n{\r\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\r\n\t*(__m128i *)a = _mm_xor_si128(*(__m128i *)b, *(__m128i *)c);\r\n#else\r\n\tasm (\"movdqa %1, %%xmm0; pxor %2, %%xmm0; movdqa %%xmm0, %0;\" : \"=m\" (a[0]) : \"m\"(b[0]), \"m\"(c[0]));\r\n#endif\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_mm_xor_si128",
          "args": [
            "*(__m128i *)b",
            "*(__m128i *)c"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\ninline static void SSE2_Xor16(byte *a, const byte *b, const byte *c)\r\n{\r\n#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE\r\n\t*(__m128i *)a = _mm_xor_si128(*(__m128i *)b, *(__m128i *)c);\r\n#else\r\n\tasm (\"movdqa %1, %%xmm0; pxor %2, %%xmm0; movdqa %%xmm0, %0;\" : \"=m\" (a[0]) : \"m\"(b[0]), \"m\"(c[0]));\r\n#endif\r\n}"
  },
  {
    "function_name": "_mm_clmulepi64_si128",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "47-60",
    "snippet": "__m128i _mm_clmulepi64_si128(const __m128i &a, const __m128i &b, int i)\r\n{\r\n\tword64 A[1] = {ByteReverse(((word64*)&a)[i&1])};\r\n\tword64 B[1] = {ByteReverse(((word64*)&b)[i>>4])};\r\n\r\n\tPolynomialMod2 pa((byte *)A, 8);\r\n\tPolynomialMod2 pb((byte *)B, 8);\r\n\tPolynomialMod2 c = pa*pb;\r\n\r\n\t__m128i output;\r\n\tfor (int i=0; i<16; i++)\r\n\t\t((byte *)&output)[i] = c.GetByte(i);\r\n\treturn output;\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c.GetByte",
          "args": [
            "i"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "((word64*)&b)[i>>4]"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\n__m128i _mm_clmulepi64_si128(const __m128i &a, const __m128i &b, int i)\r\n{\r\n\tword64 A[1] = {ByteReverse(((word64*)&a)[i&1])};\r\n\tword64 B[1] = {ByteReverse(((word64*)&b)[i>>4])};\r\n\r\n\tPolynomialMod2 pa((byte *)A, 8);\r\n\tPolynomialMod2 pb((byte *)B, 8);\r\n\tPolynomialMod2 c = pa*pb;\r\n\r\n\t__m128i output;\r\n\tfor (int i=0; i<16; i++)\r\n\t\t((byte *)&output)[i] = c.GetByte(i);\r\n\treturn output;\r\n}"
  },
  {
    "function_name": "gcm_gf_mult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "25-45",
    "snippet": "void gcm_gf_mult(const unsigned char *a, const unsigned char *b, unsigned char *c)\r\n{\r\n\tword64 Z0=0, Z1=0, V0, V1;\r\n\r\n\ttypedef BlockGetAndPut<word64, BigEndian> Block;\r\n\tBlock::Get(a)(V0)(V1);\r\n\r\n\tfor (int i=0; i<16; i++) \r\n\t{\r\n\t\tfor (int j=0x80; j!=0; j>>=1)\r\n\t\t{\r\n\t\t\tint x = b[i] & j;\r\n\t\t\tZ0 ^= x ? V0 : 0;\r\n\t\t\tZ1 ^= x ? V1 : 0;\r\n\t\t\tx = (int)V1 & 1;\r\n\t\t\tV1 = (V1>>1) | (V0<<63);\r\n\t\t\tV0 = (V0>>1) ^ (x ? W64LIT(0xe1) << 56 : 0);\r\n\t\t}\r\n\t}\r\n\tBlock::Put(NULL, c)(Z0)(Z1);\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "Z1"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "NULL",
            "c"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xe1"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Block::Get",
          "args": [
            "V1"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\nvoid gcm_gf_mult(const unsigned char *a, const unsigned char *b, unsigned char *c)\r\n{\r\n\tword64 Z0=0, Z1=0, V0, V1;\r\n\r\n\ttypedef BlockGetAndPut<word64, BigEndian> Block;\r\n\tBlock::Get(a)(V0)(V1);\r\n\r\n\tfor (int i=0; i<16; i++) \r\n\t{\r\n\t\tfor (int j=0x80; j!=0; j>>=1)\r\n\t\t{\r\n\t\t\tint x = b[i] & j;\r\n\t\t\tZ0 ^= x ? V0 : 0;\r\n\t\t\tZ1 ^= x ? V1 : 0;\r\n\t\t\tx = (int)V1 & 1;\r\n\t\t\tV1 = (V1>>1) | (V0<<63);\r\n\t\t\tV0 = (V0>>1) ^ (x ? W64LIT(0xe1) << 56 : 0);\r\n\t\t}\r\n\t}\r\n\tBlock::Put(NULL, c)(Z0)(Z1);\r\n}"
  },
  {
    "function_name": "GCM_Base::GCTR::IncrementCounterBy256",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.cpp",
    "lines": "18-21",
    "snippet": "void GCM_Base::GCTR::IncrementCounterBy256()\r\n{\r\n\tIncrementCounterByOne(m_counterArray+BlockSize()-4, 3);\r\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"gcm.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IncrementCounterByOne",
          "args": [
            "m_counterArray+BlockSize()-4",
            "3"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "IncrementCounterByOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "445-449",
          "snippet": "inline void IncrementCounterByOne(byte *inout, unsigned int s)\n{\n\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = !++inout[i];\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void IncrementCounterByOne(byte *inout, unsigned int s)\n{\n\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = !++inout[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticationBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gcm.h",
          "lines": "49-50",
          "snippet": "unsigned int AuthenticationBlockSize() const\r\n\t\t{return HASH_BLOCKSIZE;}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"authenc.h\"\n\nunsigned int AuthenticationBlockSize() const\r\n\t\t{return HASH_BLOCKSIZE;}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"gcm.h\"\n#include \"pch.h\"\n\nvoid GCM_Base::GCTR::IncrementCounterBy256()\r\n{\r\n\tIncrementCounterByOne(m_counterArray+BlockSize()-4, 3);\r\n}"
  }
]