[
  {
    "function_name": "GetSendResult",
    "container": "WindowsPipeSender",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "191-201",
    "snippet": "unsigned int WindowsPipeSender::GetSendResult()\n{\n\tif (m_resultPending)\n\t{\n\t\tHANDLE h = GetHandle();\n\t\tBOOL result = GetOverlappedResult(h, &m_overlapped, &m_lastResult, false);\n\t\tCheckAndHandleError(\"GetOverlappedResult\", result);\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError",
          "args": [
            "\"GetOverlappedResult\"",
            "result"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "WindowsPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "56-57",
          "snippet": "void CheckAndHandleError(const char *operation, BOOL result) const\n\t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipe {\n  void CheckAndHandleError(const char *operation, BOOL result) const\n  \t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOverlappedResult",
          "args": [
            "h",
            "&m_overlapped",
            "&m_lastResult",
            "false"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandle",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandle",
          "container": "WindowsPipeSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "134-134",
          "snippet": "HANDLE GetHandle() const {return WindowsHandle::GetHandle();}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipeSink {\n  HANDLE GetHandle() const {return WindowsHandle::GetHandle();}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeSender {\n  unsigned int WindowsPipeSender::GetSendResult()\n  {\n  \tif (m_resultPending)\n  \t{\n  \t\tHANDLE h = GetHandle();\n  \t\tBOOL result = GetOverlappedResult(h, &m_overlapped, &m_lastResult, false);\n  \t\tCheckAndHandleError(\"GetOverlappedResult\", result);\n  \t\tm_resultPending = false;\n  \t}\n  \treturn m_lastResult;\n  }\n}"
  },
  {
    "function_name": "GetWaitObjects",
    "container": "WindowsPipeSender",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "183-189",
    "snippet": "void WindowsPipeSender::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (m_resultPending)\n\t\tcontainer.AddHandle(m_event, CallStack(\"WindowsPipeSender::GetWaitObjects() - result pending\", &callStack));\n\telse\n\t\tcontainer.SetNoWait(CallStack(\"WindowsPipeSender::GetWaitObjects() - result ready\", &callStack));\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.SetNoWait",
          "args": [
            "CallStack(\"WindowsPipeSender::GetWaitObjects() - result ready\", &callStack)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "SetNoWait",
          "container": "WaitObjectContainer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "81-85",
          "snippet": "void WaitObjectContainer::SetNoWait(CallStack const& callStack)\n{\n\tDetectNoWait(LASTRESULT_NOWAIT, CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack));\n\tm_noWait = true;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer {\n  void WaitObjectContainer::SetNoWait(CallStack const& callStack)\n  {\n  \tDetectNoWait(LASTRESULT_NOWAIT, CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack));\n  \tm_noWait = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"WindowsPipeSender::GetWaitObjects() - result ready\"",
            "&callStack"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container.AddHandle",
          "args": [
            "m_event",
            "CallStack(\"WindowsPipeSender::GetWaitObjects() - result pending\", &callStack)"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "AddHandle",
          "container": "WaitObjectContainer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "139-143",
          "snippet": "void WaitObjectContainer::AddHandle(HANDLE handle, CallStack const& callStack)\n{\n\tDetectNoWait(m_handles.size(), CallStack(\"WaitObjectContainer::AddHandle()\", &callStack));\n\tm_handles.push_back(handle);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer {\n  void WaitObjectContainer::AddHandle(HANDLE handle, CallStack const& callStack)\n  {\n  \tDetectNoWait(m_handles.size(), CallStack(\"WaitObjectContainer::AddHandle()\", &callStack));\n  \tm_handles.push_back(handle);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeSender {\n  void WindowsPipeSender::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n  {\n  \tif (m_resultPending)\n  \t\tcontainer.AddHandle(m_event, CallStack(\"WindowsPipeSender::GetWaitObjects() - result pending\", &callStack));\n  \telse\n  \t\tcontainer.SetNoWait(CallStack(\"WindowsPipeSender::GetWaitObjects() - result ready\", &callStack));\n  }\n}"
  },
  {
    "function_name": "Send",
    "container": "WindowsPipeSender",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "164-181",
    "snippet": "void WindowsPipeSender::Send(const byte* buf, size_t bufLen)\n{\n\tDWORD written = 0;\n\tHANDLE h = GetHandle();\n\t// don't queue too much at once, or we might use up non-paged memory\n\tif (WriteFile(h, buf, UnsignedMin((DWORD)128*1024, bufLen), &written, &m_overlapped))\n\t{\n\t\tm_resultPending = false;\n\t\tm_lastResult = written;\n\t}\n\telse\n\t{\n\t\tif (GetLastError() != ERROR_IO_PENDING)\n\t\t\tCheckAndHandleError(\"WriteFile\", false);\n\n\t\tm_resultPending = true;\n\t}\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError",
          "args": [
            "\"WriteFile\"",
            "false"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "WindowsPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "56-57",
          "snippet": "void CheckAndHandleError(const char *operation, BOOL result) const\n\t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipe {\n  void CheckAndHandleError(const char *operation, BOOL result) const\n  \t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket {\n  int Socket::GetLastError()\n  {\n  #ifdef USE_WINDOWS_STYLE_SOCKETS\n  \treturn WSAGetLastError();\n  #else\n  \treturn errno;\n  #endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteFile",
          "args": [
            "h",
            "buf",
            "UnsignedMin((DWORD)128*1024, bufLen)",
            "&written",
            "&m_overlapped"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "(DWORD)128*1024",
            "bufLen"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandle",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandle",
          "container": "WindowsPipeSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "134-134",
          "snippet": "HANDLE GetHandle() const {return WindowsHandle::GetHandle();}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipeSink {\n  HANDLE GetHandle() const {return WindowsHandle::GetHandle();}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeSender {\n  void WindowsPipeSender::Send(const byte* buf, size_t bufLen)\n  {\n  \tDWORD written = 0;\n  \tHANDLE h = GetHandle();\n  \t// don't queue too much at once, or we might use up non-paged memory\n  \tif (WriteFile(h, buf, UnsignedMin((DWORD)128*1024, bufLen), &written, &m_overlapped))\n  \t{\n  \t\tm_resultPending = false;\n  \t\tm_lastResult = written;\n  \t}\n  \telse\n  \t{\n  \t\tif (GetLastError() != ERROR_IO_PENDING)\n  \t\t\tCheckAndHandleError(\"WriteFile\", false);\n  \n  \t\tm_resultPending = true;\n  \t}\n  }\n}"
  },
  {
    "function_name": "WindowsPipeSender",
    "container": "WindowsPipeSender",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "155-162",
    "snippet": "WindowsPipeSender::WindowsPipeSender()\n\t: m_resultPending(false), m_lastResult(0)\n{\n\tm_event.AttachHandle(CreateEvent(NULL, true, false, NULL), true);\n\tCheckAndHandleError(\"CreateEvent\", m_event.HandleValid());\n\tmemset(&m_overlapped, 0, sizeof(m_overlapped));\n\tm_overlapped.hEvent = m_event;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&m_overlapped",
            "0",
            "sizeof(m_overlapped)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckAndHandleError",
          "args": [
            "\"CreateEvent\"",
            "m_event.HandleValid()"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "WindowsPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "56-57",
          "snippet": "void CheckAndHandleError(const char *operation, BOOL result) const\n\t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipe {\n  void CheckAndHandleError(const char *operation, BOOL result) const\n  \t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_event.HandleValid",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "HandleValid",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "31-34",
          "snippet": "bool WindowsHandle::HandleValid() const\n{\n\treturn m_h && m_h != INVALID_HANDLE_VALUE;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  bool WindowsHandle::HandleValid() const\n  {\n  \treturn m_h && m_h != INVALID_HANDLE_VALUE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_event.AttachHandle",
          "args": [
            "CreateEvent(NULL, true, false, NULL)",
            "true"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "AttachHandle",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "36-44",
          "snippet": "void WindowsHandle::AttachHandle(HANDLE h, bool own)\n{\n\tif (m_own)\n\t\tCloseHandle();\n\n\tm_h = h;\n\tm_own = own;\n\tHandleChanged();\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  void WindowsHandle::AttachHandle(HANDLE h, bool own)\n  {\n  \tif (m_own)\n  \t\tCloseHandle();\n  \n  \tm_h = h;\n  \tm_own = own;\n  \tHandleChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateEvent",
          "args": [
            "NULL",
            "true",
            "false",
            "NULL"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeSender {\n  WindowsPipeSender::WindowsPipeSender()\n  \t: m_resultPending(false), m_lastResult(0)\n  {\n  \tm_event.AttachHandle(CreateEvent(NULL, true, false, NULL), true);\n  \tCheckAndHandleError(\"CreateEvent\", m_event.HandleValid());\n  \tmemset(&m_overlapped, 0, sizeof(m_overlapped));\n  \tm_overlapped.hEvent = m_event;\n  }\n}"
  },
  {
    "function_name": "GetReceiveResult",
    "container": "WindowsPipeReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "126-151",
    "snippet": "unsigned int WindowsPipeReceiver::GetReceiveResult()\n{\n\tif (m_resultPending)\n\t{\n\t\tHANDLE h = GetHandle();\n\t\tif (GetOverlappedResult(h, &m_overlapped, &m_lastResult, false))\n\t\t{\n\t\t\tif (m_lastResult == 0)\n\t\t\t\tm_eofReceived = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (GetLastError())\n\t\t\t{\n\t\t\tdefault:\n\t\t\t\tCheckAndHandleError(\"GetOverlappedResult\", false);\n\t\t\tcase ERROR_BROKEN_PIPE:\n\t\t\tcase ERROR_HANDLE_EOF:\n\t\t\t\tm_lastResult = 0;\n\t\t\t\tm_eofReceived = true;\n\t\t\t}\n\t\t}\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError",
          "args": [
            "\"GetOverlappedResult\"",
            "false"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "WindowsPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "56-57",
          "snippet": "void CheckAndHandleError(const char *operation, BOOL result) const\n\t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipe {\n  void CheckAndHandleError(const char *operation, BOOL result) const\n  \t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket {\n  int Socket::GetLastError()\n  {\n  #ifdef USE_WINDOWS_STYLE_SOCKETS\n  \treturn WSAGetLastError();\n  #else\n  \treturn errno;\n  #endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOverlappedResult",
          "args": [
            "h",
            "&m_overlapped",
            "&m_lastResult",
            "false"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHandle",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandle",
          "container": "WindowsPipeSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "134-134",
          "snippet": "HANDLE GetHandle() const {return WindowsHandle::GetHandle();}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipeSink {\n  HANDLE GetHandle() const {return WindowsHandle::GetHandle();}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeReceiver {\n  unsigned int WindowsPipeReceiver::GetReceiveResult()\n  {\n  \tif (m_resultPending)\n  \t{\n  \t\tHANDLE h = GetHandle();\n  \t\tif (GetOverlappedResult(h, &m_overlapped, &m_lastResult, false))\n  \t\t{\n  \t\t\tif (m_lastResult == 0)\n  \t\t\t\tm_eofReceived = true;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tswitch (GetLastError())\n  \t\t\t{\n  \t\t\tdefault:\n  \t\t\t\tCheckAndHandleError(\"GetOverlappedResult\", false);\n  \t\t\tcase ERROR_BROKEN_PIPE:\n  \t\t\tcase ERROR_HANDLE_EOF:\n  \t\t\t\tm_lastResult = 0;\n  \t\t\t\tm_eofReceived = true;\n  \t\t\t}\n  \t\t}\n  \t\tm_resultPending = false;\n  \t}\n  \treturn m_lastResult;\n  }\n}"
  },
  {
    "function_name": "GetWaitObjects",
    "container": "WindowsPipeReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "118-124",
    "snippet": "void WindowsPipeReceiver::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (m_resultPending)\n\t\tcontainer.AddHandle(m_event, CallStack(\"WindowsPipeReceiver::GetWaitObjects() - result pending\", &callStack));\n\telse if (!m_eofReceived)\n\t\tcontainer.SetNoWait(CallStack(\"WindowsPipeReceiver::GetWaitObjects() - result ready\", &callStack));\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.SetNoWait",
          "args": [
            "CallStack(\"WindowsPipeReceiver::GetWaitObjects() - result ready\", &callStack)"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "SetNoWait",
          "container": "WaitObjectContainer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "81-85",
          "snippet": "void WaitObjectContainer::SetNoWait(CallStack const& callStack)\n{\n\tDetectNoWait(LASTRESULT_NOWAIT, CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack));\n\tm_noWait = true;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer {\n  void WaitObjectContainer::SetNoWait(CallStack const& callStack)\n  {\n  \tDetectNoWait(LASTRESULT_NOWAIT, CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack));\n  \tm_noWait = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"WindowsPipeReceiver::GetWaitObjects() - result ready\"",
            "&callStack"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container.AddHandle",
          "args": [
            "m_event",
            "CallStack(\"WindowsPipeReceiver::GetWaitObjects() - result pending\", &callStack)"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "AddHandle",
          "container": "WaitObjectContainer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "139-143",
          "snippet": "void WaitObjectContainer::AddHandle(HANDLE handle, CallStack const& callStack)\n{\n\tDetectNoWait(m_handles.size(), CallStack(\"WaitObjectContainer::AddHandle()\", &callStack));\n\tm_handles.push_back(handle);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer {\n  void WaitObjectContainer::AddHandle(HANDLE handle, CallStack const& callStack)\n  {\n  \tDetectNoWait(m_handles.size(), CallStack(\"WaitObjectContainer::AddHandle()\", &callStack));\n  \tm_handles.push_back(handle);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeReceiver {\n  void WindowsPipeReceiver::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n  {\n  \tif (m_resultPending)\n  \t\tcontainer.AddHandle(m_event, CallStack(\"WindowsPipeReceiver::GetWaitObjects() - result pending\", &callStack));\n  \telse if (!m_eofReceived)\n  \t\tcontainer.SetNoWait(CallStack(\"WindowsPipeReceiver::GetWaitObjects() - result ready\", &callStack));\n  }\n}"
  },
  {
    "function_name": "Receive",
    "container": "WindowsPipeReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "89-116",
    "snippet": "bool WindowsPipeReceiver::Receive(byte* buf, size_t bufLen)\n{\n\tassert(!m_resultPending && !m_eofReceived);\n\n\tHANDLE h = GetHandle();\n\t// don't queue too much at once, or we might use up non-paged memory\n\tif (ReadFile(h, buf, UnsignedMin((DWORD)128*1024, bufLen), &m_lastResult, &m_overlapped))\n\t{\n\t\tif (m_lastResult == 0)\n\t\t\tm_eofReceived = true;\n\t}\n\telse\n\t{\n\t\tswitch (GetLastError())\n\t\t{\n\t\tdefault:\n\t\t\tCheckAndHandleError(\"ReadFile\", false);\n\t\tcase ERROR_BROKEN_PIPE:\n\t\tcase ERROR_HANDLE_EOF:\n\t\t\tm_lastResult = 0;\n\t\t\tm_eofReceived = true;\n\t\t\tbreak;\n\t\tcase ERROR_IO_PENDING:\n\t\t\tm_resultPending = true;\n\t\t}\n\t}\n\treturn !m_resultPending;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError",
          "args": [
            "\"ReadFile\"",
            "false"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "WindowsPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "56-57",
          "snippet": "void CheckAndHandleError(const char *operation, BOOL result) const\n\t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipe {\n  void CheckAndHandleError(const char *operation, BOOL result) const\n  \t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket {\n  int Socket::GetLastError()\n  {\n  #ifdef USE_WINDOWS_STYLE_SOCKETS\n  \treturn WSAGetLastError();\n  #else\n  \treturn errno;\n  #endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadFile",
          "args": [
            "h",
            "buf",
            "UnsignedMin((DWORD)128*1024, bufLen)",
            "&m_lastResult",
            "&m_overlapped"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "(DWORD)128*1024",
            "bufLen"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandle",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandle",
          "container": "WindowsPipeSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "134-134",
          "snippet": "HANDLE GetHandle() const {return WindowsHandle::GetHandle();}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipeSink {\n  HANDLE GetHandle() const {return WindowsHandle::GetHandle();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!m_resultPending && !m_eofReceived"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeReceiver {\n  bool WindowsPipeReceiver::Receive(byte* buf, size_t bufLen)\n  {\n  \tassert(!m_resultPending && !m_eofReceived);\n  \n  \tHANDLE h = GetHandle();\n  \t// don't queue too much at once, or we might use up non-paged memory\n  \tif (ReadFile(h, buf, UnsignedMin((DWORD)128*1024, bufLen), &m_lastResult, &m_overlapped))\n  \t{\n  \t\tif (m_lastResult == 0)\n  \t\t\tm_eofReceived = true;\n  \t}\n  \telse\n  \t{\n  \t\tswitch (GetLastError())\n  \t\t{\n  \t\tdefault:\n  \t\t\tCheckAndHandleError(\"ReadFile\", false);\n  \t\tcase ERROR_BROKEN_PIPE:\n  \t\tcase ERROR_HANDLE_EOF:\n  \t\t\tm_lastResult = 0;\n  \t\t\tm_eofReceived = true;\n  \t\t\tbreak;\n  \t\tcase ERROR_IO_PENDING:\n  \t\t\tm_resultPending = true;\n  \t\t}\n  \t}\n  \treturn !m_resultPending;\n  }\n}"
  },
  {
    "function_name": "WindowsPipeReceiver",
    "container": "WindowsPipeReceiver",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "80-87",
    "snippet": "WindowsPipeReceiver::WindowsPipeReceiver()\n\t: m_resultPending(false), m_eofReceived(false)\n{\n\tm_event.AttachHandle(CreateEvent(NULL, true, false, NULL), true);\n\tCheckAndHandleError(\"CreateEvent\", m_event.HandleValid());\n\tmemset(&m_overlapped, 0, sizeof(m_overlapped));\n\tm_overlapped.hEvent = m_event;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&m_overlapped",
            "0",
            "sizeof(m_overlapped)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckAndHandleError",
          "args": [
            "\"CreateEvent\"",
            "m_event.HandleValid()"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "WindowsPipe",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "56-57",
          "snippet": "void CheckAndHandleError(const char *operation, BOOL result) const\n\t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipe {\n  void CheckAndHandleError(const char *operation, BOOL result) const\n  \t\t{assert(result==TRUE || result==FALSE); if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_event.HandleValid",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "HandleValid",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "31-34",
          "snippet": "bool WindowsHandle::HandleValid() const\n{\n\treturn m_h && m_h != INVALID_HANDLE_VALUE;\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  bool WindowsHandle::HandleValid() const\n  {\n  \treturn m_h && m_h != INVALID_HANDLE_VALUE;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_event.AttachHandle",
          "args": [
            "CreateEvent(NULL, true, false, NULL)",
            "true"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "AttachHandle",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "36-44",
          "snippet": "void WindowsHandle::AttachHandle(HANDLE h, bool own)\n{\n\tif (m_own)\n\t\tCloseHandle();\n\n\tm_h = h;\n\tm_own = own;\n\tHandleChanged();\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  void WindowsHandle::AttachHandle(HANDLE h, bool own)\n  {\n  \tif (m_own)\n  \t\tCloseHandle();\n  \n  \tm_h = h;\n  \tm_own = own;\n  \tHandleChanged();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateEvent",
          "args": [
            "NULL",
            "true",
            "false",
            "NULL"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipeReceiver {\n  WindowsPipeReceiver::WindowsPipeReceiver()\n  \t: m_resultPending(false), m_eofReceived(false)\n  {\n  \tm_event.AttachHandle(CreateEvent(NULL, true, false, NULL), true);\n  \tCheckAndHandleError(\"CreateEvent\", m_event.HandleValid());\n  \tmemset(&m_overlapped, 0, sizeof(m_overlapped));\n  \tm_overlapped.hEvent = m_event;\n  }\n}"
  },
  {
    "function_name": "Err",
    "container": "WindowsPipe::Err",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "72-76",
    "snippet": "WindowsPipe::Err::Err(HANDLE s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"WindowsPipe: \" + operation + \" operation failed with error 0x\" + IntToString(error, 16), operation, error)\n\t, m_h(s)\n{\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "error",
            "16"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipe {\n  Err {\n    WindowsPipe::Err::Err(HANDLE s, const std::string& operation, int error)\n    \t: OS_Error(IO_ERROR, \"WindowsPipe: \" + operation + \" operation failed with error 0x\" + IntToString(error, 16), operation, error)\n    \t, m_h(s)\n    {\n    }\n  }\n}"
  },
  {
    "function_name": "HandleError",
    "container": "WindowsPipe",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "66-70",
    "snippet": "void WindowsPipe::HandleError(const char *operation) const\n{\n\tDWORD err = GetLastError();\n\tthrow Err(GetHandle(), operation, err);\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "GetHandle()",
            "operation",
            "err"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "Err",
          "container": "WindowsPipe::Err",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "72-76",
          "snippet": "WindowsPipe::Err::Err(HANDLE s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"WindowsPipe: \" + operation + \" operation failed with error 0x\" + IntToString(error, 16), operation, error)\n\t, m_h(s)\n{\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipe {\n  Err {\n    WindowsPipe::Err::Err(HANDLE s, const std::string& operation, int error)\n    \t: OS_Error(IO_ERROR, \"WindowsPipe: \" + operation + \" operation failed with error 0x\" + IntToString(error, 16), operation, error)\n    \t, m_h(s)\n    {\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHandle",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "GetHandle",
          "container": "WindowsPipeSink",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "134-134",
          "snippet": "HANDLE GetHandle() const {return WindowsHandle::GetHandle();}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsPipeSink {\n  HANDLE GetHandle() const {return WindowsHandle::GetHandle();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket {\n  int Socket::GetLastError()\n  {\n  #ifdef USE_WINDOWS_STYLE_SOCKETS\n  \treturn WSAGetLastError();\n  #else\n  \treturn errno;\n  #endif\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsPipe {\n  void WindowsPipe::HandleError(const char *operation) const\n  {\n  \tDWORD err = GetLastError();\n  \tthrow Err(GetHandle(), operation, err);\n  }\n}"
  },
  {
    "function_name": "CloseHandle",
    "container": "WindowsHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "54-62",
    "snippet": "void WindowsHandle::CloseHandle()\n{\n\tif (m_h != INVALID_HANDLE_VALUE)\n\t{\n\t\t::CloseHandle(m_h);\n\t\tm_h = INVALID_HANDLE_VALUE;\n\t\tHandleChanged();\n\t}\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleChanged",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "HandleChanged",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "33-33",
          "snippet": "virtual void HandleChanged() {}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsHandle {\n  virtual void HandleChanged() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "::CloseHandle",
          "args": [
            "m_h"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  void WindowsHandle::CloseHandle()\n  {\n  \tif (m_h != INVALID_HANDLE_VALUE)\n  \t{\n  \t\t::CloseHandle(m_h);\n  \t\tm_h = INVALID_HANDLE_VALUE;\n  \t\tHandleChanged();\n  \t}\n  }\n}"
  },
  {
    "function_name": "DetachHandle",
    "container": "WindowsHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "46-52",
    "snippet": "HANDLE WindowsHandle::DetachHandle()\n{\n\tHANDLE h = m_h;\n\tm_h = INVALID_HANDLE_VALUE;\n\tHandleChanged();\n\treturn h;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleChanged",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "HandleChanged",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "33-33",
          "snippet": "virtual void HandleChanged() {}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsHandle {\n  virtual void HandleChanged() {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  HANDLE WindowsHandle::DetachHandle()\n  {\n  \tHANDLE h = m_h;\n  \tm_h = INVALID_HANDLE_VALUE;\n  \tHandleChanged();\n  \treturn h;\n  }\n}"
  },
  {
    "function_name": "AttachHandle",
    "container": "WindowsHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "36-44",
    "snippet": "void WindowsHandle::AttachHandle(HANDLE h, bool own)\n{\n\tif (m_own)\n\t\tCloseHandle();\n\n\tm_h = h;\n\tm_own = own;\n\tHandleChanged();\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleChanged",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "HandleChanged",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.h",
          "lines": "33-33",
          "snippet": "virtual void HandleChanged() {}",
          "includes": [
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nWindowsHandle {\n  virtual void HandleChanged() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "CloseHandle",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "54-62",
          "snippet": "void WindowsHandle::CloseHandle()\n{\n\tif (m_h != INVALID_HANDLE_VALUE)\n\t{\n\t\t::CloseHandle(m_h);\n\t\tm_h = INVALID_HANDLE_VALUE;\n\t\tHandleChanged();\n\t}\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  void WindowsHandle::CloseHandle()\n  {\n  \tif (m_h != INVALID_HANDLE_VALUE)\n  \t{\n  \t\t::CloseHandle(m_h);\n  \t\tm_h = INVALID_HANDLE_VALUE;\n  \t\tHandleChanged();\n  \t}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  void WindowsHandle::AttachHandle(HANDLE h, bool own)\n  {\n  \tif (m_own)\n  \t\tCloseHandle();\n  \n  \tm_h = h;\n  \tm_own = own;\n  \tHandleChanged();\n  }\n}"
  },
  {
    "function_name": "HandleValid",
    "container": "WindowsHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "31-34",
    "snippet": "bool WindowsHandle::HandleValid() const\n{\n\treturn m_h && m_h != INVALID_HANDLE_VALUE;\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  bool WindowsHandle::HandleValid() const\n  {\n  \treturn m_h && m_h != INVALID_HANDLE_VALUE;\n  }\n}"
  },
  {
    "function_name": "~WindowsHandle",
    "container": "WindowsHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "17-29",
    "snippet": "WindowsHandle::~WindowsHandle()\n{\n\tif (m_own)\n\t{\n\t\ttry\n\t\t{\n\t\t\tCloseHandle();\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "CloseHandle",
          "container": "WindowsHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "54-62",
          "snippet": "void WindowsHandle::CloseHandle()\n{\n\tif (m_h != INVALID_HANDLE_VALUE)\n\t{\n\t\t::CloseHandle(m_h);\n\t\tm_h = INVALID_HANDLE_VALUE;\n\t\tHandleChanged();\n\t}\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  void WindowsHandle::CloseHandle()\n  {\n  \tif (m_h != INVALID_HANDLE_VALUE)\n  \t{\n  \t\t::CloseHandle(m_h);\n  \t\tm_h = INVALID_HANDLE_VALUE;\n  \t\tHandleChanged();\n  \t}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  WindowsHandle::~WindowsHandle()\n  {\n  \tif (m_own)\n  \t{\n  \t\ttry\n  \t\t{\n  \t\t\tCloseHandle();\n  \t\t}\n  \t\tcatch (...)\n  \t\t{\n  \t\t}\n  \t}\n  }\n}"
  },
  {
    "function_name": "WindowsHandle",
    "container": "WindowsHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
    "lines": "12-15",
    "snippet": "WindowsHandle::WindowsHandle(HANDLE h, bool own)\n\t: m_h(h), m_own(own)\n{\n}",
    "includes": [
      "#include \"wait.h\"",
      "#include \"winpipes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nWindowsHandle {\n  WindowsHandle::WindowsHandle(HANDLE h, bool own)\n  \t: m_h(h), m_own(own)\n  {\n  }\n}"
  }
]