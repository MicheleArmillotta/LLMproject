[
  {
    "function_name": "ValidateESIGN",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "687-722",
    "snippet": "bool ValidateESIGN()\n{\n\tcout << \"\\nESIGN validation suite running...\\n\\n\";\n\n\tbool pass = true, fail;\n\n\tconst char *plain = \"test\";\n\tconst byte *signature = (byte *)\n\t\t\"\\xA3\\xE3\\x20\\x65\\xDE\\xDA\\xE7\\xEC\\x05\\xC1\\xBF\\xCD\\x25\\x79\\x7D\\x99\\xCD\\xD5\\x73\\x9D\\x9D\\xF3\\xA4\\xAA\\x9A\\xA4\\x5A\\xC8\\x23\\x3D\\x0D\\x37\\xFE\\xBC\\x76\\x3F\\xF1\\x84\\xF6\\x59\"\n\t\t\"\\x14\\x91\\x4F\\x0C\\x34\\x1B\\xAE\\x9A\\x5C\\x2E\\x2E\\x38\\x08\\x78\\x77\\xCB\\xDC\\x3C\\x7E\\xA0\\x34\\x44\\x5B\\x0F\\x67\\xD9\\x35\\x2A\\x79\\x47\\x1A\\x52\\x37\\x71\\xDB\\x12\\x67\\xC1\\xB6\\xC6\"\n\t\t\"\\x66\\x73\\xB3\\x40\\x2E\\xD6\\xF2\\x1A\\x84\\x0A\\xB6\\x7B\\x0F\\xEB\\x8B\\x88\\xAB\\x33\\xDD\\xE4\\x83\\x21\\x90\\x63\\x2D\\x51\\x2A\\xB1\\x6F\\xAB\\xA7\\x5C\\xFD\\x77\\x99\\xF2\\xE1\\xEF\\x67\\x1A\"\n\t\t\"\\x74\\x02\\x37\\x0E\\xED\\x0A\\x06\\xAD\\xF4\\x15\\x65\\xB8\\xE1\\xD1\\x45\\xAE\\x39\\x19\\xB4\\xFF\\x5D\\xF1\\x45\\x7B\\xE0\\xFE\\x72\\xED\\x11\\x92\\x8F\\x61\\x41\\x4F\\x02\\x00\\xF2\\x76\\x6F\\x7C\"\n\t\t\"\\x79\\xA2\\xE5\\x52\\x20\\x5D\\x97\\x5E\\xFE\\x39\\xAE\\x21\\x10\\xFB\\x35\\xF4\\x80\\x81\\x41\\x13\\xDD\\xE8\\x5F\\xCA\\x1E\\x4F\\xF8\\x9B\\xB2\\x68\\xFB\\x28\";\n\n\tFileSource keys(\"TestData/esig1536.dat\", true, new HexDecoder);\n\tESIGN<SHA>::Signer signer(keys);\n\tESIGN<SHA>::Verifier verifier(signer);\n\n\tfail = !SignatureValidate(signer, verifier);\n\tpass = pass && !fail;\n\n\tfail = !verifier.VerifyMessage((byte *)plain, strlen(plain), signature, verifier.SignatureLength());\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"verification check against test vector\\n\";\n\n\tcout << \"Generating signature key from seed...\" << endl;\n\tsigner.AccessKey().GenerateRandom(GlobalRNG(), MakeParameters(\"Seed\", ConstByteArrayParameter((const byte *)\"test\", 4))(\"KeySize\", 3*512));\n\tverifier = signer;\n\n\tfail = !SignatureValidate(signer, verifier);\n\tpass = pass && !fail;\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "signer",
            "verifier"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "signer.AccessKey",
          "args": [
            "GlobalRNG()",
            "MakeParameters(\"Seed\", ConstByteArrayParameter((const byte *)\"test\", 4))(\"KeySize\", 3*512)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"KeySize\"",
            "3*512"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConstByteArrayParameter",
          "args": [
            "(const byte *)\"test\"",
            "4"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ConstByteArrayParameter",
          "container": "ConstByteArrayParameter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "24-28",
          "snippet": "ConstByteArrayParameter(const T &string, bool deepCopy = false)\n\t{\n        CRYPTOPP_COMPILE_ASSERT(sizeof(CPP_TYPENAME T::value_type) == 1);\n\t\tAssign((const byte *)string.data(), string.size(), deepCopy);\n\t}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nConstByteArrayParameter {\n  ConstByteArrayParameter(const T &string, bool deepCopy = false)\n  \t{\n          CRYPTOPP_COMPILE_ASSERT(sizeof(CPP_TYPENAME T::value_type) == 1);\n  \t\tAssign((const byte *)string.data(), string.size(), deepCopy);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer.AccessKey",
          "args": [],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier.VerifyMessage",
          "args": [
            "(byte *)plain",
            "strlen(plain)",
            "signature",
            "verifier.SignatureLength()"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier.SignatureLength",
          "args": [],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "plain"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateESIGN()\n{\n\tcout << \"\\nESIGN validation suite running...\\n\\n\";\n\n\tbool pass = true, fail;\n\n\tconst char *plain = \"test\";\n\tconst byte *signature = (byte *)\n\t\t\"\\xA3\\xE3\\x20\\x65\\xDE\\xDA\\xE7\\xEC\\x05\\xC1\\xBF\\xCD\\x25\\x79\\x7D\\x99\\xCD\\xD5\\x73\\x9D\\x9D\\xF3\\xA4\\xAA\\x9A\\xA4\\x5A\\xC8\\x23\\x3D\\x0D\\x37\\xFE\\xBC\\x76\\x3F\\xF1\\x84\\xF6\\x59\"\n\t\t\"\\x14\\x91\\x4F\\x0C\\x34\\x1B\\xAE\\x9A\\x5C\\x2E\\x2E\\x38\\x08\\x78\\x77\\xCB\\xDC\\x3C\\x7E\\xA0\\x34\\x44\\x5B\\x0F\\x67\\xD9\\x35\\x2A\\x79\\x47\\x1A\\x52\\x37\\x71\\xDB\\x12\\x67\\xC1\\xB6\\xC6\"\n\t\t\"\\x66\\x73\\xB3\\x40\\x2E\\xD6\\xF2\\x1A\\x84\\x0A\\xB6\\x7B\\x0F\\xEB\\x8B\\x88\\xAB\\x33\\xDD\\xE4\\x83\\x21\\x90\\x63\\x2D\\x51\\x2A\\xB1\\x6F\\xAB\\xA7\\x5C\\xFD\\x77\\x99\\xF2\\xE1\\xEF\\x67\\x1A\"\n\t\t\"\\x74\\x02\\x37\\x0E\\xED\\x0A\\x06\\xAD\\xF4\\x15\\x65\\xB8\\xE1\\xD1\\x45\\xAE\\x39\\x19\\xB4\\xFF\\x5D\\xF1\\x45\\x7B\\xE0\\xFE\\x72\\xED\\x11\\x92\\x8F\\x61\\x41\\x4F\\x02\\x00\\xF2\\x76\\x6F\\x7C\"\n\t\t\"\\x79\\xA2\\xE5\\x52\\x20\\x5D\\x97\\x5E\\xFE\\x39\\xAE\\x21\\x10\\xFB\\x35\\xF4\\x80\\x81\\x41\\x13\\xDD\\xE8\\x5F\\xCA\\x1E\\x4F\\xF8\\x9B\\xB2\\x68\\xFB\\x28\";\n\n\tFileSource keys(\"TestData/esig1536.dat\", true, new HexDecoder);\n\tESIGN<SHA>::Signer signer(keys);\n\tESIGN<SHA>::Verifier verifier(signer);\n\n\tfail = !SignatureValidate(signer, verifier);\n\tpass = pass && !fail;\n\n\tfail = !verifier.VerifyMessage((byte *)plain, strlen(plain), signature, verifier.SignatureLength());\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"verification check against test vector\\n\";\n\n\tcout << \"Generating signature key from seed...\" << endl;\n\tsigner.AccessKey().GenerateRandom(GlobalRNG(), MakeParameters(\"Seed\", ConstByteArrayParameter((const byte *)\"test\", 4))(\"KeySize\", 3*512));\n\tverifier = signer;\n\n\tfail = !SignatureValidate(signer, verifier);\n\tpass = pass && !fail;\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateECDSA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "637-685",
    "snippet": "bool ValidateECDSA()\n{\n\tcout << \"\\nECDSA validation suite running...\\n\\n\";\n\n\t// from Sample Test Vectors for P1363\n\tGF2NT gf2n(191, 9, 0);\n\tbyte a[]=\"\\x28\\x66\\x53\\x7B\\x67\\x67\\x52\\x63\\x6A\\x68\\xF5\\x65\\x54\\xE1\\x26\\x40\\x27\\x6B\\x64\\x9E\\xF7\\x52\\x62\\x67\";\n\tbyte b[]=\"\\x2E\\x45\\xEF\\x57\\x1F\\x00\\x78\\x6F\\x67\\xB0\\x08\\x1B\\x94\\x95\\xA3\\xD9\\x54\\x62\\xF5\\xDE\\x0A\\xA1\\x85\\xEC\";\n\tEC2N ec(gf2n, PolynomialMod2(a,24), PolynomialMod2(b,24));\n\n\tEC2N::Point P;\n\tec.DecodePoint(P, (byte *)\"\\x04\\x36\\xB3\\xDA\\xF8\\xA2\\x32\\x06\\xF9\\xC4\\xF2\\x99\\xD7\\xB2\\x1A\\x9C\\x36\\x91\\x37\\xF2\\xC8\\x4A\\xE1\\xAA\\x0D\"\n\t\t\"\\x76\\x5B\\xE7\\x34\\x33\\xB3\\xF9\\x5E\\x33\\x29\\x32\\xE7\\x0E\\xA2\\x45\\xCA\\x24\\x18\\xEA\\x0E\\xF9\\x80\\x18\\xFB\", ec.EncodedPointSize());\n\tInteger n(\"40000000000000000000000004a20e90c39067c893bbb9a5H\");\n\tInteger d(\"340562e1dda332f9d2aec168249b5696ee39d0ed4d03760fH\");\n\tEC2N::Point Q(ec.Multiply(d, P));\n\tECDSA<EC2N, SHA>::Signer priv(ec, P, n, d);\n\tECDSA<EC2N, SHA>::Verifier pub(priv);\n\n\tInteger h(\"A9993E364706816ABA3E25717850C26C9CD0D89DH\");\n\tInteger k(\"3eeace72b4919d991738d521879f787cb590aff8189d2b69H\");\n\tbyte sig[]=\"\\x03\\x8e\\x5a\\x11\\xfb\\x55\\xe4\\xc6\\x54\\x71\\xdc\\xd4\\x99\\x84\\x52\\xb1\\xe0\\x2d\\x8a\\xf7\\x09\\x9b\\xb9\\x30\"\n\t\t\"\\x0c\\x9a\\x08\\xc3\\x44\\x68\\xc2\\x44\\xb4\\xe5\\xd6\\xb2\\x1b\\x3c\\x68\\x36\\x28\\x07\\x41\\x60\\x20\\x32\\x8b\\x6e\";\n\tInteger r(sig, 24);\n\tInteger s(sig+24, 24);\n\n\tInteger rOut, sOut;\n\tbool fail, pass=true;\n\n\tpriv.RawSign(k, h, rOut, sOut);\n\tfail = (rOut != r) || (sOut != s);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature check against test vector\\n\";\n\n\tfail = !pub.VerifyMessage((byte *)\"abc\", 3, sig, sizeof(sig));\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"verification check against test vector\\n\";\n\n\tfail = pub.VerifyMessage((byte *)\"xyz\", 3, sig, sizeof(sig));\n\tpass = pass && !fail;\n\n\tpass = SignatureValidate(priv, pub) && pass;\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "priv",
            "pub"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pub.VerifyMessage",
          "args": [
            "(byte *)\"xyz\"",
            "3",
            "sig",
            "sizeof(sig)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.VerifyMessage",
          "args": [
            "(byte *)\"abc\"",
            "3",
            "sig",
            "sizeof(sig)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.RawSign",
          "args": [
            "k",
            "h",
            "rOut",
            "sOut"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec.Multiply",
          "args": [
            "d",
            "P"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "Multiply",
          "container": "Word",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "309-314",
          "snippet": "static Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nWord {\n  static Word Multiply(hword a, hword b)\n  \t{\n  \t\tWord r;\n  \t\tr.m_whole = (word)a * b;\n  \t\treturn r;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ec.DecodePoint",
          "args": [
            "P",
            "(byte *)\"\\x04\\x36\\xB3\\xDA\\xF8\\xA2\\x32\\x06\\xF9\\xC4\\xF2\\x99\\xD7\\xB2\\x1A\\x9C\\x36\\x91\\x37\\xF2\\xC8\\x4A\\xE1\\xAA\\x0D\"\n\t\t\"\\x76\\x5B\\xE7\\x34\\x33\\xB3\\xF9\\x5E\\x33\\x29\\x32\\xE7\\x0E\\xA2\\x45\\xCA\\x24\\x18\\xEA\\x0E\\xF9\\x80\\x18\\xFB\"",
            "ec.EncodedPointSize()"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec.EncodedPointSize",
          "args": [],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PolynomialMod2",
          "args": [
            "b",
            "24"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "PolynomialMod2::PolynomialMod2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2n.cpp",
          "lines": "22-32",
          "snippet": "PolynomialMod2::PolynomialMod2(word value, size_t bitLength)\n\t: reg(BitsToWords(bitLength))\n{\n\tassert(value==0 || reg.size()>0);\n\n\tif (reg.size() > 0)\n\t{\n\t\treg[0] = value;\n\t\tSetWords(reg+1, 0, reg.size()-1);\n\t}\n}",
          "includes": [
            "#include <iostream>",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"randpool.h\"",
            "#include \"words.h\"",
            "#include \"algebra.h\"",
            "#include \"gf2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"randpool.h\"\n#include \"words.h\"\n#include \"algebra.h\"\n#include \"gf2n.h\"\n#include \"pch.h\"\n\nPolynomialMod2::PolynomialMod2(word value, size_t bitLength)\n\t: reg(BitsToWords(bitLength))\n{\n\tassert(value==0 || reg.size()>0);\n\n\tif (reg.size() > 0)\n\t{\n\t\treg[0] = value;\n\t\tSetWords(reg+1, 0, reg.size()-1);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateECDSA()\n{\n\tcout << \"\\nECDSA validation suite running...\\n\\n\";\n\n\t// from Sample Test Vectors for P1363\n\tGF2NT gf2n(191, 9, 0);\n\tbyte a[]=\"\\x28\\x66\\x53\\x7B\\x67\\x67\\x52\\x63\\x6A\\x68\\xF5\\x65\\x54\\xE1\\x26\\x40\\x27\\x6B\\x64\\x9E\\xF7\\x52\\x62\\x67\";\n\tbyte b[]=\"\\x2E\\x45\\xEF\\x57\\x1F\\x00\\x78\\x6F\\x67\\xB0\\x08\\x1B\\x94\\x95\\xA3\\xD9\\x54\\x62\\xF5\\xDE\\x0A\\xA1\\x85\\xEC\";\n\tEC2N ec(gf2n, PolynomialMod2(a,24), PolynomialMod2(b,24));\n\n\tEC2N::Point P;\n\tec.DecodePoint(P, (byte *)\"\\x04\\x36\\xB3\\xDA\\xF8\\xA2\\x32\\x06\\xF9\\xC4\\xF2\\x99\\xD7\\xB2\\x1A\\x9C\\x36\\x91\\x37\\xF2\\xC8\\x4A\\xE1\\xAA\\x0D\"\n\t\t\"\\x76\\x5B\\xE7\\x34\\x33\\xB3\\xF9\\x5E\\x33\\x29\\x32\\xE7\\x0E\\xA2\\x45\\xCA\\x24\\x18\\xEA\\x0E\\xF9\\x80\\x18\\xFB\", ec.EncodedPointSize());\n\tInteger n(\"40000000000000000000000004a20e90c39067c893bbb9a5H\");\n\tInteger d(\"340562e1dda332f9d2aec168249b5696ee39d0ed4d03760fH\");\n\tEC2N::Point Q(ec.Multiply(d, P));\n\tECDSA<EC2N, SHA>::Signer priv(ec, P, n, d);\n\tECDSA<EC2N, SHA>::Verifier pub(priv);\n\n\tInteger h(\"A9993E364706816ABA3E25717850C26C9CD0D89DH\");\n\tInteger k(\"3eeace72b4919d991738d521879f787cb590aff8189d2b69H\");\n\tbyte sig[]=\"\\x03\\x8e\\x5a\\x11\\xfb\\x55\\xe4\\xc6\\x54\\x71\\xdc\\xd4\\x99\\x84\\x52\\xb1\\xe0\\x2d\\x8a\\xf7\\x09\\x9b\\xb9\\x30\"\n\t\t\"\\x0c\\x9a\\x08\\xc3\\x44\\x68\\xc2\\x44\\xb4\\xe5\\xd6\\xb2\\x1b\\x3c\\x68\\x36\\x28\\x07\\x41\\x60\\x20\\x32\\x8b\\x6e\";\n\tInteger r(sig, 24);\n\tInteger s(sig+24, 24);\n\n\tInteger rOut, sOut;\n\tbool fail, pass=true;\n\n\tpriv.RawSign(k, h, rOut, sOut);\n\tfail = (rOut != r) || (sOut != s);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature check against test vector\\n\";\n\n\tfail = !pub.VerifyMessage((byte *)\"abc\", 3, sig, sizeof(sig));\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"verification check against test vector\\n\";\n\n\tfail = pub.VerifyMessage((byte *)\"xyz\", 3, sig, sizeof(sig));\n\tpass = pass && !fail;\n\n\tpass = SignatureValidate(priv, pub) && pass;\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateEC2N",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "588-635",
    "snippet": "bool ValidateEC2N()\n{\n\tcout << \"\\nEC2N validation suite running...\\n\\n\";\n\n\tECIES<EC2N>::Decryptor cpriv(GlobalRNG(), ASN1::sect193r1());\n\tECIES<EC2N>::Encryptor cpub(cpriv);\n\tByteQueue bq;\n\tcpriv.DEREncode(bq);\n\tcpub.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);\n\tcpub.DEREncode(bq);\n\tECDSA<EC2N, SHA>::Signer spriv(bq);\n\tECDSA<EC2N, SHA>::Verifier spub(bq);\n\tECDH<EC2N>::Domain ecdhc(ASN1::sect193r1());\n\tECMQV<EC2N>::Domain ecmqvc(ASN1::sect193r1());\n\n\tspriv.AccessKey().Precompute();\n\tByteQueue queue;\n\tspriv.AccessKey().SavePrecomputation(queue);\n\tspriv.AccessKey().LoadPrecomputation(queue);\n\n\tbool pass = SignatureValidate(spriv, spub);\n\tpass = CryptoSystemValidate(cpriv, cpub) && pass;\n\tpass = SimpleKeyAgreementValidate(ecdhc) && pass;\n\tpass = AuthenticatedKeyAgreementValidate(ecmqvc) && pass;\n\n\tcout << \"Turning on point compression...\" << endl;\n\tcpriv.AccessKey().AccessGroupParameters().SetPointCompression(true);\n\tcpub.AccessKey().AccessGroupParameters().SetPointCompression(true);\n\tecdhc.AccessGroupParameters().SetPointCompression(true);\n\tecmqvc.AccessGroupParameters().SetPointCompression(true);\n\tpass = CryptoSystemValidate(cpriv, cpub) && pass;\n\tpass = SimpleKeyAgreementValidate(ecdhc) && pass;\n\tpass = AuthenticatedKeyAgreementValidate(ecmqvc) && pass;\n\n#if 0\t// TODO: turn this back on when I make EC2N faster for pentanomial basis\n\tcout << \"Testing SEC 2 recommended curves...\" << endl;\n\tOID oid;\n\twhile (!(oid = DL_GroupParameters_EC<EC2N>::GetNextRecommendedParametersOID(oid)).m_values.empty())\n\t{\n\t\tDL_GroupParameters_EC<EC2N> params(oid);\n\t\tbool fail = !params.Validate(GlobalRNG(), 2);\n\t\tcout << (fail ? \"FAILED\" : \"passed\") << \"    \" << params.GetCurve().GetField().MaxElementBitLength() << \" bits\" << endl;\n\t\tpass = pass && !fail;\n\t}\n#endif\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.Validate",
          "args": [
            "GlobalRNG()",
            "2"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "Validate",
          "container": "DL_PublicKeyImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "845-850",
          "snippet": "bool Validate(RandomNumberGenerator &rng, unsigned int level) const\n\t{\n\t\tbool pass = GetAbstractGroupParameters().Validate(rng, level);\n\t\tpass = pass && GetAbstractGroupParameters().ValidateElement(level, this->GetPublicElement(), &GetPublicPrecomputation());\n\t\treturn pass;\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nDL_PublicKeyImpl {\n  bool Validate(RandomNumberGenerator &rng, unsigned int level) const\n  \t{\n  \t\tbool pass = GetAbstractGroupParameters().Validate(rng, level);\n  \t\tpass = pass && GetAbstractGroupParameters().ValidateElement(level, this->GetPublicElement(), &GetPublicPrecomputation());\n  \t\treturn pass;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DL_GroupParameters_EC<EC2N>::GetNextRecommendedParametersOID",
          "args": [
            "oid"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthenticatedKeyAgreementValidate",
          "args": [
            "ecmqvc"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticatedKeyAgreementValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "216-254",
          "snippet": "bool AuthenticatedKeyAgreementValidate(AuthenticatedKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    authenticated key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    authenticated key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock spriv1(d.StaticPrivateKeyLength()), spriv2(d.StaticPrivateKeyLength());\n\tSecByteBlock epriv1(d.EphemeralPrivateKeyLength()), epriv2(d.EphemeralPrivateKeyLength());\n\tSecByteBlock spub1(d.StaticPublicKeyLength()), spub2(d.StaticPublicKeyLength());\n\tSecByteBlock epub1(d.EphemeralPublicKeyLength()), epub2(d.EphemeralPublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv1, spub1);\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv2, spub2);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv1, epub1);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv2, epub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, spriv1, epriv1, spub2, epub2) && d.Agree(val2, spriv2, epriv2, spub1, epub1)))\n\t{\n\t\tcout << \"FAILED    authenticated key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    authenticated agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    authenticated key agreement\" << endl;\n\treturn true;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool AuthenticatedKeyAgreementValidate(AuthenticatedKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    authenticated key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    authenticated key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock spriv1(d.StaticPrivateKeyLength()), spriv2(d.StaticPrivateKeyLength());\n\tSecByteBlock epriv1(d.EphemeralPrivateKeyLength()), epriv2(d.EphemeralPrivateKeyLength());\n\tSecByteBlock spub1(d.StaticPublicKeyLength()), spub2(d.StaticPublicKeyLength());\n\tSecByteBlock epub1(d.EphemeralPublicKeyLength()), epub2(d.EphemeralPublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv1, spub1);\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv2, spub2);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv1, epub1);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv2, epub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, spriv1, epriv1, spub2, epub2) && d.Agree(val2, spriv2, epriv2, spub1, epub1)))\n\t{\n\t\tcout << \"FAILED    authenticated key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    authenticated agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    authenticated key agreement\" << endl;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SimpleKeyAgreementValidate",
          "args": [
            "ecdhc"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "SimpleKeyAgreementValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "180-214",
          "snippet": "bool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CryptoSystemValidate",
          "args": [
            "cpriv",
            "cpub"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "CryptoSystemValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "154-178",
          "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecmqvc.AccessGroupParameters",
          "args": [
            "true"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecmqvc.AccessGroupParameters",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecdhc.AccessGroupParameters",
          "args": [
            "true"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecdhc.AccessGroupParameters",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [
            "true"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.AccessKey",
          "args": [
            "true"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.AccessKey",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.AccessKey",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "spriv",
            "spub"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [
            "queue"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [
            "queue"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.DEREncode",
          "args": [
            "bq"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rsa.h",
          "lines": "67-68",
          "snippet": "void DEREncode(BufferedTransformation &bt) const\n\t\t{PKCS8PrivateKey::DEREncode(bt);}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\"",
            "#include \"asn.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n#include \"asn.h\"\n#include \"pubkey.h\"\n\nvoid DEREncode(BufferedTransformation &bt) const\n\t\t{PKCS8PrivateKey::DEREncode(bt);}"
        }
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [
            "true"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateEC2N()\n{\n\tcout << \"\\nEC2N validation suite running...\\n\\n\";\n\n\tECIES<EC2N>::Decryptor cpriv(GlobalRNG(), ASN1::sect193r1());\n\tECIES<EC2N>::Encryptor cpub(cpriv);\n\tByteQueue bq;\n\tcpriv.DEREncode(bq);\n\tcpub.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);\n\tcpub.DEREncode(bq);\n\tECDSA<EC2N, SHA>::Signer spriv(bq);\n\tECDSA<EC2N, SHA>::Verifier spub(bq);\n\tECDH<EC2N>::Domain ecdhc(ASN1::sect193r1());\n\tECMQV<EC2N>::Domain ecmqvc(ASN1::sect193r1());\n\n\tspriv.AccessKey().Precompute();\n\tByteQueue queue;\n\tspriv.AccessKey().SavePrecomputation(queue);\n\tspriv.AccessKey().LoadPrecomputation(queue);\n\n\tbool pass = SignatureValidate(spriv, spub);\n\tpass = CryptoSystemValidate(cpriv, cpub) && pass;\n\tpass = SimpleKeyAgreementValidate(ecdhc) && pass;\n\tpass = AuthenticatedKeyAgreementValidate(ecmqvc) && pass;\n\n\tcout << \"Turning on point compression...\" << endl;\n\tcpriv.AccessKey().AccessGroupParameters().SetPointCompression(true);\n\tcpub.AccessKey().AccessGroupParameters().SetPointCompression(true);\n\tecdhc.AccessGroupParameters().SetPointCompression(true);\n\tecmqvc.AccessGroupParameters().SetPointCompression(true);\n\tpass = CryptoSystemValidate(cpriv, cpub) && pass;\n\tpass = SimpleKeyAgreementValidate(ecdhc) && pass;\n\tpass = AuthenticatedKeyAgreementValidate(ecmqvc) && pass;\n\n#if 0\t// TODO: turn this back on when I make EC2N faster for pentanomial basis\n\tcout << \"Testing SEC 2 recommended curves...\" << endl;\n\tOID oid;\n\twhile (!(oid = DL_GroupParameters_EC<EC2N>::GetNextRecommendedParametersOID(oid)).m_values.empty())\n\t{\n\t\tDL_GroupParameters_EC<EC2N> params(oid);\n\t\tbool fail = !params.Validate(GlobalRNG(), 2);\n\t\tcout << (fail ? \"FAILED\" : \"passed\") << \"    \" << params.GetCurve().GetField().MaxElementBitLength() << \" bits\" << endl;\n\t\tpass = pass && !fail;\n\t}\n#endif\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateECP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "539-586",
    "snippet": "bool ValidateECP()\n{\n\tcout << \"\\nECP validation suite running...\\n\\n\";\n\n\tECIES<ECP>::Decryptor cpriv(GlobalRNG(), ASN1::secp192r1());\n\tECIES<ECP>::Encryptor cpub(cpriv);\n\tByteQueue bq;\n\tcpriv.GetKey().DEREncode(bq);\n\tcpub.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);\n\tcpub.GetKey().DEREncode(bq);\n\tECDSA<ECP, SHA>::Signer spriv(bq);\n\tECDSA<ECP, SHA>::Verifier spub(bq);\n\tECDH<ECP>::Domain ecdhc(ASN1::secp192r1());\n\tECMQV<ECP>::Domain ecmqvc(ASN1::secp192r1());\n\n\tspriv.AccessKey().Precompute();\n\tByteQueue queue;\n\tspriv.AccessKey().SavePrecomputation(queue);\n\tspriv.AccessKey().LoadPrecomputation(queue);\n\n\tbool pass = SignatureValidate(spriv, spub);\n\tcpub.AccessKey().Precompute();\n\tcpriv.AccessKey().Precompute();\n\tpass = CryptoSystemValidate(cpriv, cpub) && pass;\n\tpass = SimpleKeyAgreementValidate(ecdhc) && pass;\n\tpass = AuthenticatedKeyAgreementValidate(ecmqvc) && pass;\n\n\tcout << \"Turning on point compression...\" << endl;\n\tcpriv.AccessKey().AccessGroupParameters().SetPointCompression(true);\n\tcpub.AccessKey().AccessGroupParameters().SetPointCompression(true);\n\tecdhc.AccessGroupParameters().SetPointCompression(true);\n\tecmqvc.AccessGroupParameters().SetPointCompression(true);\n\tpass = CryptoSystemValidate(cpriv, cpub) && pass;\n\tpass = SimpleKeyAgreementValidate(ecdhc) && pass;\n\tpass = AuthenticatedKeyAgreementValidate(ecmqvc) && pass;\n\n\tcout << \"Testing SEC 2, NIST, and Brainpool recommended curves...\" << endl;\n\tOID oid;\n\twhile (!(oid = DL_GroupParameters_EC<ECP>::GetNextRecommendedParametersOID(oid)).m_values.empty())\n\t{\n\t\tDL_GroupParameters_EC<ECP> params(oid);\n\t\tbool fail = !params.Validate(GlobalRNG(), 2);\n\t\tcout << (fail ? \"FAILED\" : \"passed\") << \"    \" << dec << params.GetCurve().GetField().MaxElementBitLength() << \" bits\" << endl;\n\t\tpass = pass && !fail;\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.Validate",
          "args": [
            "GlobalRNG()",
            "2"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "Validate",
          "container": "DL_PublicKeyImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "845-850",
          "snippet": "bool Validate(RandomNumberGenerator &rng, unsigned int level) const\n\t{\n\t\tbool pass = GetAbstractGroupParameters().Validate(rng, level);\n\t\tpass = pass && GetAbstractGroupParameters().ValidateElement(level, this->GetPublicElement(), &GetPublicPrecomputation());\n\t\treturn pass;\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nDL_PublicKeyImpl {\n  bool Validate(RandomNumberGenerator &rng, unsigned int level) const\n  \t{\n  \t\tbool pass = GetAbstractGroupParameters().Validate(rng, level);\n  \t\tpass = pass && GetAbstractGroupParameters().ValidateElement(level, this->GetPublicElement(), &GetPublicPrecomputation());\n  \t\treturn pass;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DL_GroupParameters_EC<ECP>::GetNextRecommendedParametersOID",
          "args": [
            "oid"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AuthenticatedKeyAgreementValidate",
          "args": [
            "ecmqvc"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticatedKeyAgreementValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "216-254",
          "snippet": "bool AuthenticatedKeyAgreementValidate(AuthenticatedKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    authenticated key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    authenticated key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock spriv1(d.StaticPrivateKeyLength()), spriv2(d.StaticPrivateKeyLength());\n\tSecByteBlock epriv1(d.EphemeralPrivateKeyLength()), epriv2(d.EphemeralPrivateKeyLength());\n\tSecByteBlock spub1(d.StaticPublicKeyLength()), spub2(d.StaticPublicKeyLength());\n\tSecByteBlock epub1(d.EphemeralPublicKeyLength()), epub2(d.EphemeralPublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv1, spub1);\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv2, spub2);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv1, epub1);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv2, epub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, spriv1, epriv1, spub2, epub2) && d.Agree(val2, spriv2, epriv2, spub1, epub1)))\n\t{\n\t\tcout << \"FAILED    authenticated key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    authenticated agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    authenticated key agreement\" << endl;\n\treturn true;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool AuthenticatedKeyAgreementValidate(AuthenticatedKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    authenticated key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    authenticated key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock spriv1(d.StaticPrivateKeyLength()), spriv2(d.StaticPrivateKeyLength());\n\tSecByteBlock epriv1(d.EphemeralPrivateKeyLength()), epriv2(d.EphemeralPrivateKeyLength());\n\tSecByteBlock spub1(d.StaticPublicKeyLength()), spub2(d.StaticPublicKeyLength());\n\tSecByteBlock epub1(d.EphemeralPublicKeyLength()), epub2(d.EphemeralPublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv1, spub1);\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv2, spub2);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv1, epub1);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv2, epub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, spriv1, epriv1, spub2, epub2) && d.Agree(val2, spriv2, epriv2, spub1, epub1)))\n\t{\n\t\tcout << \"FAILED    authenticated key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    authenticated agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    authenticated key agreement\" << endl;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SimpleKeyAgreementValidate",
          "args": [
            "ecdhc"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "SimpleKeyAgreementValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "180-214",
          "snippet": "bool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CryptoSystemValidate",
          "args": [
            "cpriv",
            "cpub"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "CryptoSystemValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "154-178",
          "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecmqvc.AccessGroupParameters",
          "args": [
            "true"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecmqvc.AccessGroupParameters",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecdhc.AccessGroupParameters",
          "args": [
            "true"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecdhc.AccessGroupParameters",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [
            "true"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.AccessKey",
          "args": [
            "true"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.AccessKey",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.AccessKey",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.AccessKey",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.AccessKey",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "spriv",
            "spub"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [
            "queue"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [
            "queue"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spriv.AccessKey",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.GetKey",
          "args": [
            "bq"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.GetKey",
          "args": [],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [
            "true"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpub.AccessKey",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.GetKey",
          "args": [
            "bq"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpriv.GetKey",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateECP()\n{\n\tcout << \"\\nECP validation suite running...\\n\\n\";\n\n\tECIES<ECP>::Decryptor cpriv(GlobalRNG(), ASN1::secp192r1());\n\tECIES<ECP>::Encryptor cpub(cpriv);\n\tByteQueue bq;\n\tcpriv.GetKey().DEREncode(bq);\n\tcpub.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);\n\tcpub.GetKey().DEREncode(bq);\n\tECDSA<ECP, SHA>::Signer spriv(bq);\n\tECDSA<ECP, SHA>::Verifier spub(bq);\n\tECDH<ECP>::Domain ecdhc(ASN1::secp192r1());\n\tECMQV<ECP>::Domain ecmqvc(ASN1::secp192r1());\n\n\tspriv.AccessKey().Precompute();\n\tByteQueue queue;\n\tspriv.AccessKey().SavePrecomputation(queue);\n\tspriv.AccessKey().LoadPrecomputation(queue);\n\n\tbool pass = SignatureValidate(spriv, spub);\n\tcpub.AccessKey().Precompute();\n\tcpriv.AccessKey().Precompute();\n\tpass = CryptoSystemValidate(cpriv, cpub) && pass;\n\tpass = SimpleKeyAgreementValidate(ecdhc) && pass;\n\tpass = AuthenticatedKeyAgreementValidate(ecmqvc) && pass;\n\n\tcout << \"Turning on point compression...\" << endl;\n\tcpriv.AccessKey().AccessGroupParameters().SetPointCompression(true);\n\tcpub.AccessKey().AccessGroupParameters().SetPointCompression(true);\n\tecdhc.AccessGroupParameters().SetPointCompression(true);\n\tecmqvc.AccessGroupParameters().SetPointCompression(true);\n\tpass = CryptoSystemValidate(cpriv, cpub) && pass;\n\tpass = SimpleKeyAgreementValidate(ecdhc) && pass;\n\tpass = AuthenticatedKeyAgreementValidate(ecmqvc) && pass;\n\n\tcout << \"Testing SEC 2, NIST, and Brainpool recommended curves...\" << endl;\n\tOID oid;\n\twhile (!(oid = DL_GroupParameters_EC<ECP>::GetNextRecommendedParametersOID(oid)).m_values.empty())\n\t{\n\t\tDL_GroupParameters_EC<ECP> params(oid);\n\t\tbool fail = !params.Validate(GlobalRNG(), 2);\n\t\tcout << (fail ? \"FAILED\" : \"passed\") << \"    \" << dec << params.GetCurve().GetField().MaxElementBitLength() << \" bits\" << endl;\n\t\tpass = pass && !fail;\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateRW",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "515-524",
    "snippet": "bool ValidateRW()\n{\n\tcout << \"\\nRW validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/rw1024.dat\", true, new HexDecoder);\n\tRWSS<PSSR, SHA>::Signer priv(f);\n\tRWSS<PSSR, SHA>::Verifier pub(priv);\n\n\treturn SignatureValidate(priv, pub);\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "priv",
            "pub"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateRW()\n{\n\tcout << \"\\nRW validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/rw1024.dat\", true, new HexDecoder);\n\tRWSS<PSSR, SHA>::Signer priv(f);\n\tRWSS<PSSR, SHA>::Verifier pub(priv);\n\n\treturn SignatureValidate(priv, pub);\n}"
  },
  {
    "function_name": "ValidateRabin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "496-513",
    "snippet": "bool ValidateRabin()\n{\n\tcout << \"\\nRabin validation suite running...\\n\\n\";\n\tbool pass=true;\n\n\t{\n\t\tFileSource f(\"TestData/rabi1024.dat\", true, new HexDecoder);\n\t\tRabinSS<PSSR, SHA>::Signer priv(f);\n\t\tRabinSS<PSSR, SHA>::Verifier pub(priv);\n\t\tpass = SignatureValidate(priv, pub) && pass;\n\t}\n\t{\n\t\tRabinES<OAEP<SHA> >::Decryptor priv(GlobalRNG(), 512);\n\t\tRabinES<OAEP<SHA> >::Encryptor pub(priv);\n\t\tpass = CryptoSystemValidate(priv, pub) && pass;\n\t}\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CryptoSystemValidate",
          "args": [
            "priv",
            "pub"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "CryptoSystemValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "154-178",
          "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "priv",
            "pub"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateRabin()\n{\n\tcout << \"\\nRabin validation suite running...\\n\\n\";\n\tbool pass=true;\n\n\t{\n\t\tFileSource f(\"TestData/rabi1024.dat\", true, new HexDecoder);\n\t\tRabinSS<PSSR, SHA>::Signer priv(f);\n\t\tRabinSS<PSSR, SHA>::Verifier pub(priv);\n\t\tpass = SignatureValidate(priv, pub) && pass;\n\t}\n\t{\n\t\tRabinES<OAEP<SHA> >::Decryptor priv(GlobalRNG(), 512);\n\t\tRabinES<OAEP<SHA> >::Encryptor pub(priv);\n\t\tpass = CryptoSystemValidate(priv, pub) && pass;\n\t}\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateLUC_DL",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "477-494",
    "snippet": "bool ValidateLUC_DL()\n{\n\tcout << \"\\nLUC-HMP validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/lucs512.dat\", true, new HexDecoder);\n\tLUC_HMP<SHA>::Signer privS(f);\n\tLUC_HMP<SHA>::Verifier pubS(privS);\n\tbool pass = SignatureValidate(privS, pubS);\n\n\tcout << \"\\nLUC-IES validation suite running...\\n\\n\";\n\n\tFileSource fc(\"TestData/lucc512.dat\", true, new HexDecoder);\n\tLUC_IES<>::Decryptor privC(fc);\n\tLUC_IES<>::Encryptor pubC(privC);\n\tpass = CryptoSystemValidate(privC, pubC) && pass;\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CryptoSystemValidate",
          "args": [
            "privC",
            "pubC"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "CryptoSystemValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "154-178",
          "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "privS",
            "pubS"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateLUC_DL()\n{\n\tcout << \"\\nLUC-HMP validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/lucs512.dat\", true, new HexDecoder);\n\tLUC_HMP<SHA>::Signer privS(f);\n\tLUC_HMP<SHA>::Verifier pubS(privS);\n\tbool pass = SignatureValidate(privS, pubS);\n\n\tcout << \"\\nLUC-IES validation suite running...\\n\\n\";\n\n\tFileSource fc(\"TestData/lucc512.dat\", true, new HexDecoder);\n\tLUC_IES<>::Decryptor privC(fc);\n\tLUC_IES<>::Encryptor pubC(privC);\n\tpass = CryptoSystemValidate(privC, pubC) && pass;\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateLUC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "458-475",
    "snippet": "bool ValidateLUC()\n{\n\tcout << \"\\nLUC validation suite running...\\n\\n\";\n\tbool pass=true;\n\n\t{\n\t\tFileSource f(\"TestData/luc1024.dat\", true, new HexDecoder);\n\t\tLUCSSA_PKCS1v15_SHA_Signer priv(f);\n\t\tLUCSSA_PKCS1v15_SHA_Verifier pub(priv);\n\t\tpass = SignatureValidate(priv, pub) && pass;\n\t}\n\t{\n\t\tLUCES_OAEP_SHA_Decryptor priv(GlobalRNG(), 512);\n\t\tLUCES_OAEP_SHA_Encryptor pub(priv);\n\t\tpass = CryptoSystemValidate(priv, pub) && pass;\n\t}\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CryptoSystemValidate",
          "args": [
            "priv",
            "pub"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "CryptoSystemValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "154-178",
          "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "priv",
            "pub"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateLUC()\n{\n\tcout << \"\\nLUC validation suite running...\\n\\n\";\n\tbool pass=true;\n\n\t{\n\t\tFileSource f(\"TestData/luc1024.dat\", true, new HexDecoder);\n\t\tLUCSSA_PKCS1v15_SHA_Signer priv(f);\n\t\tLUCSSA_PKCS1v15_SHA_Verifier pub(priv);\n\t\tpass = SignatureValidate(priv, pub) && pass;\n\t}\n\t{\n\t\tLUCES_OAEP_SHA_Decryptor priv(GlobalRNG(), 512);\n\t\tLUCES_OAEP_SHA_Encryptor pub(priv);\n\t\tpass = CryptoSystemValidate(priv, pub) && pass;\n\t}\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateDSA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "442-456",
    "snippet": "bool ValidateDSA(bool thorough)\n{\n\tcout << \"\\nDSA validation suite running...\\n\\n\";\n\n\tbool pass = true;\n\tFileSource fs1(\"TestData/dsa1024.dat\", true, new HexDecoder());\n\tDSA::Signer priv(fs1);\n\tDSA::Verifier pub(priv);\n\tFileSource fs2(\"TestData/dsa1024b.dat\", true, new HexDecoder());\n\tDSA::Verifier pub1(fs2);\n\tassert(pub.GetKey() == pub1.GetKey());\n\tpass = SignatureValidate(priv, pub, thorough) && pass;\n\tpass = RunTestDataFile(\"TestVectors/dsa.txt\", g_nullNameValuePairs, thorough) && pass;\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RunTestDataFile",
          "args": [
            "\"TestVectors/dsa.txt\"",
            "g_nullNameValuePairs",
            "thorough"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "RunTestDataFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "748-757",
          "snippet": "bool RunTestDataFile(const char *filename, const NameValuePairs &overrideParameters, bool thorough)\n{\n\ts_thorough = thorough;\n\tunsigned int totalTests = 0, failedTests = 0;\n\tTestDataFile(filename, overrideParameters, totalTests, failedTests);\n\tcout << dec << \"\\nTests complete. Total tests = \" << totalTests << \". Failed tests = \" << failedTests << \".\\n\";\n\tif (failedTests != 0)\n\t\tcout << \"SOME TESTS FAILED!\\n\";\n\treturn failedTests == 0;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool s_thorough;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic bool s_thorough;\n\nbool RunTestDataFile(const char *filename, const NameValuePairs &overrideParameters, bool thorough)\n{\n\ts_thorough = thorough;\n\tunsigned int totalTests = 0, failedTests = 0;\n\tTestDataFile(filename, overrideParameters, totalTests, failedTests);\n\tcout << dec << \"\\nTests complete. Total tests = \" << totalTests << \". Failed tests = \" << failedTests << \".\\n\";\n\tif (failedTests != 0)\n\t\tcout << \"SOME TESTS FAILED!\\n\";\n\treturn failedTests == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "priv",
            "pub",
            "thorough"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pub.GetKey() == pub1.GetKey()"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub1.GetKey",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetKey",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateDSA(bool thorough)\n{\n\tcout << \"\\nDSA validation suite running...\\n\\n\";\n\n\tbool pass = true;\n\tFileSource fs1(\"TestData/dsa1024.dat\", true, new HexDecoder());\n\tDSA::Signer priv(fs1);\n\tDSA::Verifier pub(priv);\n\tFileSource fs2(\"TestData/dsa1024b.dat\", true, new HexDecoder());\n\tDSA::Verifier pub1(fs2);\n\tassert(pub.GetKey() == pub1.GetKey());\n\tpass = SignatureValidate(priv, pub, thorough) && pass;\n\tpass = RunTestDataFile(\"TestVectors/dsa.txt\", g_nullNameValuePairs, thorough) && pass;\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateNR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "420-440",
    "snippet": "bool ValidateNR()\n{\n\tcout << \"\\nNR validation suite running...\\n\\n\";\n\tbool pass = true;\n\t{\n\t\tFileSource f(\"TestData/nr2048.dat\", true, new HexDecoder);\n\t\tNR<SHA>::Signer privS(f);\n\t\tprivS.AccessKey().Precompute();\n\t\tNR<SHA>::Verifier pubS(privS);\n\n\t\tpass = SignatureValidate(privS, pubS) && pass;\n\t}\n\t{\n\t\tcout << \"Generating new signature key...\" << endl;\n\t\tNR<SHA>::Signer privS(GlobalRNG(), 256);\n\t\tNR<SHA>::Verifier pubS(privS);\n\n\t\tpass = SignatureValidate(privS, pubS) && pass;\n\t}\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignatureValidate",
          "args": [
            "privS",
            "pubS"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "103-152",
          "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privS.AccessKey",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privS.AccessKey",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateNR()\n{\n\tcout << \"\\nNR validation suite running...\\n\\n\";\n\tbool pass = true;\n\t{\n\t\tFileSource f(\"TestData/nr2048.dat\", true, new HexDecoder);\n\t\tNR<SHA>::Signer privS(f);\n\t\tprivS.AccessKey().Precompute();\n\t\tNR<SHA>::Verifier pubS(privS);\n\n\t\tpass = SignatureValidate(privS, pubS) && pass;\n\t}\n\t{\n\t\tcout << \"Generating new signature key...\" << endl;\n\t\tNR<SHA>::Signer privS(GlobalRNG(), 256);\n\t\tNR<SHA>::Verifier pubS(privS);\n\n\t\tpass = SignatureValidate(privS, pubS) && pass;\n\t}\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateDLIES",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "397-418",
    "snippet": "bool ValidateDLIES()\n{\n\tcout << \"\\nDLIES validation suite running...\\n\\n\";\n\tbool pass = true;\n\t{\n\t\tFileSource fc(\"TestData/dlie1024.dat\", true, new HexDecoder);\n\t\tDLIES<>::Decryptor privC(fc);\n\t\tDLIES<>::Encryptor pubC(privC);\n\t\tpass = CryptoSystemValidate(privC, pubC) && pass;\n\t}\n\t{\n\t\tcout << \"Generating new encryption key...\" << endl;\n\t\tDLIES<>::GroupParameters gp;\n\t\tgp.GenerateRandomWithKeySize(GlobalRNG(), 128);\n\t\tDLIES<>::Decryptor decryptor;\n\t\tdecryptor.AccessKey().GenerateRandom(GlobalRNG(), gp);\n\t\tDLIES<>::Encryptor encryptor(decryptor);\n\n\t\tpass = CryptoSystemValidate(decryptor, encryptor) && pass;\n\t}\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CryptoSystemValidate",
          "args": [
            "decryptor",
            "encryptor"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "CryptoSystemValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "154-178",
          "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decryptor.AccessKey",
          "args": [
            "GlobalRNG()",
            "gp"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor.AccessKey",
          "args": [],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gp.GenerateRandomWithKeySize",
          "args": [
            "GlobalRNG()",
            "128"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateDLIES()\n{\n\tcout << \"\\nDLIES validation suite running...\\n\\n\";\n\tbool pass = true;\n\t{\n\t\tFileSource fc(\"TestData/dlie1024.dat\", true, new HexDecoder);\n\t\tDLIES<>::Decryptor privC(fc);\n\t\tDLIES<>::Encryptor pubC(privC);\n\t\tpass = CryptoSystemValidate(privC, pubC) && pass;\n\t}\n\t{\n\t\tcout << \"Generating new encryption key...\" << endl;\n\t\tDLIES<>::GroupParameters gp;\n\t\tgp.GenerateRandomWithKeySize(GlobalRNG(), 128);\n\t\tDLIES<>::Decryptor decryptor;\n\t\tdecryptor.AccessKey().GenerateRandom(GlobalRNG(), gp);\n\t\tDLIES<>::Encryptor encryptor(decryptor);\n\n\t\tpass = CryptoSystemValidate(decryptor, encryptor) && pass;\n\t}\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateElGamal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "379-395",
    "snippet": "bool ValidateElGamal()\n{\n\tcout << \"\\nElGamal validation suite running...\\n\\n\";\n\tbool pass = true;\n\t{\n\t\tFileSource fc(\"TestData/elgc1024.dat\", true, new HexDecoder);\n\t\tElGamalDecryptor privC(fc);\n\t\tElGamalEncryptor pubC(privC);\n\t\tprivC.AccessKey().Precompute();\n\t\tByteQueue queue;\n\t\tprivC.AccessKey().SavePrecomputation(queue);\n\t\tprivC.AccessKey().LoadPrecomputation(queue);\n\n\t\tpass = CryptoSystemValidate(privC, pubC) && pass;\n\t}\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CryptoSystemValidate",
          "args": [
            "privC",
            "pubC"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "CryptoSystemValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "154-178",
          "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "privC.AccessKey",
          "args": [
            "queue"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privC.AccessKey",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privC.AccessKey",
          "args": [
            "queue"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privC.AccessKey",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privC.AccessKey",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "privC.AccessKey",
          "args": [],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateElGamal()\n{\n\tcout << \"\\nElGamal validation suite running...\\n\\n\";\n\tbool pass = true;\n\t{\n\t\tFileSource fc(\"TestData/elgc1024.dat\", true, new HexDecoder);\n\t\tElGamalDecryptor privC(fc);\n\t\tElGamalEncryptor pubC(privC);\n\t\tprivC.AccessKey().Precompute();\n\t\tByteQueue queue;\n\t\tprivC.AccessKey().SavePrecomputation(queue);\n\t\tprivC.AccessKey().LoadPrecomputation(queue);\n\n\t\tpass = CryptoSystemValidate(privC, pubC) && pass;\n\t}\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateXTR_DH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "370-377",
    "snippet": "bool ValidateXTR_DH()\n{\n\tcout << \"\\nXTR-DH validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/xtrdh171.dat\", true, new HexDecoder());\n\tXTR_DH dh(f);\n\treturn SimpleKeyAgreementValidate(dh);\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SimpleKeyAgreementValidate",
          "args": [
            "dh"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "SimpleKeyAgreementValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "180-214",
          "snippet": "bool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateXTR_DH()\n{\n\tcout << \"\\nXTR-DH validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/xtrdh171.dat\", true, new HexDecoder());\n\tXTR_DH dh(f);\n\treturn SimpleKeyAgreementValidate(dh);\n}"
  },
  {
    "function_name": "ValidateLUC_DH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "361-368",
    "snippet": "bool ValidateLUC_DH()\n{\n\tcout << \"\\nLUC-DH validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/lucd512.dat\", true, new HexDecoder());\n\tLUC_DH dh(f);\n\treturn SimpleKeyAgreementValidate(dh);\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SimpleKeyAgreementValidate",
          "args": [
            "dh"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "SimpleKeyAgreementValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "180-214",
          "snippet": "bool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateLUC_DH()\n{\n\tcout << \"\\nLUC-DH validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/lucd512.dat\", true, new HexDecoder());\n\tLUC_DH dh(f);\n\treturn SimpleKeyAgreementValidate(dh);\n}"
  },
  {
    "function_name": "ValidateMQV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "352-359",
    "snippet": "bool ValidateMQV()\n{\n\tcout << \"\\nMQV validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/mqv1024.dat\", true, new HexDecoder());\n\tMQV mqv(f);\n\treturn AuthenticatedKeyAgreementValidate(mqv);\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AuthenticatedKeyAgreementValidate",
          "args": [
            "mqv"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "AuthenticatedKeyAgreementValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "216-254",
          "snippet": "bool AuthenticatedKeyAgreementValidate(AuthenticatedKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    authenticated key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    authenticated key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock spriv1(d.StaticPrivateKeyLength()), spriv2(d.StaticPrivateKeyLength());\n\tSecByteBlock epriv1(d.EphemeralPrivateKeyLength()), epriv2(d.EphemeralPrivateKeyLength());\n\tSecByteBlock spub1(d.StaticPublicKeyLength()), spub2(d.StaticPublicKeyLength());\n\tSecByteBlock epub1(d.EphemeralPublicKeyLength()), epub2(d.EphemeralPublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv1, spub1);\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv2, spub2);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv1, epub1);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv2, epub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, spriv1, epriv1, spub2, epub2) && d.Agree(val2, spriv2, epriv2, spub1, epub1)))\n\t{\n\t\tcout << \"FAILED    authenticated key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    authenticated agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    authenticated key agreement\" << endl;\n\treturn true;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool AuthenticatedKeyAgreementValidate(AuthenticatedKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    authenticated key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    authenticated key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock spriv1(d.StaticPrivateKeyLength()), spriv2(d.StaticPrivateKeyLength());\n\tSecByteBlock epriv1(d.EphemeralPrivateKeyLength()), epriv2(d.EphemeralPrivateKeyLength());\n\tSecByteBlock spub1(d.StaticPublicKeyLength()), spub2(d.StaticPublicKeyLength());\n\tSecByteBlock epub1(d.EphemeralPublicKeyLength()), epub2(d.EphemeralPublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv1, spub1);\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv2, spub2);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv1, epub1);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv2, epub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, spriv1, epriv1, spub2, epub2) && d.Agree(val2, spriv2, epriv2, spub1, epub1)))\n\t{\n\t\tcout << \"FAILED    authenticated key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    authenticated agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    authenticated key agreement\" << endl;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateMQV()\n{\n\tcout << \"\\nMQV validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/mqv1024.dat\", true, new HexDecoder());\n\tMQV mqv(f);\n\treturn AuthenticatedKeyAgreementValidate(mqv);\n}"
  },
  {
    "function_name": "ValidateDH",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "343-350",
    "snippet": "bool ValidateDH()\n{\n\tcout << \"\\nDH validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/dh1024.dat\", true, new HexDecoder());\n\tDH dh(f);\n\treturn SimpleKeyAgreementValidate(dh);\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SimpleKeyAgreementValidate",
          "args": [
            "dh"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "SimpleKeyAgreementValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "180-214",
          "snippet": "bool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateDH()\n{\n\tcout << \"\\nDH validation suite running...\\n\\n\";\n\n\tFileSource f(\"TestData/dh1024.dat\", true, new HexDecoder());\n\tDH dh(f);\n\treturn SimpleKeyAgreementValidate(dh);\n}"
  },
  {
    "function_name": "ValidateRSA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "256-341",
    "snippet": "bool ValidateRSA()\n{\n\tcout << \"\\nRSA validation suite running...\\n\\n\";\n\n\tbyte out[100], outPlain[100];\n\tbool pass = true, fail;\n\n\t{\n\t\tconst char *plain = \"Everyone gets Friday off.\";\n\t\tbyte *signature = (byte *)\n\t\t\t\"\\x05\\xfa\\x6a\\x81\\x2f\\xc7\\xdf\\x8b\\xf4\\xf2\\x54\\x25\\x09\\xe0\\x3e\\x84\"\n\t\t\t\"\\x6e\\x11\\xb9\\xc6\\x20\\xbe\\x20\\x09\\xef\\xb4\\x40\\xef\\xbc\\xc6\\x69\\x21\"\n\t\t\t\"\\x69\\x94\\xac\\x04\\xf3\\x41\\xb5\\x7d\\x05\\x20\\x2d\\x42\\x8f\\xb2\\xa2\\x7b\"\n\t\t\t\"\\x5c\\x77\\xdf\\xd9\\xb1\\x5b\\xfc\\x3d\\x55\\x93\\x53\\x50\\x34\\x10\\xc1\\xe1\";\n\n\t\tFileSource keys(\"TestData/rsa512a.dat\", true, new HexDecoder);\n\t\tWeak::RSASSA_PKCS1v15_MD2_Signer rsaPriv(keys);\n\t\tWeak::RSASSA_PKCS1v15_MD2_Verifier rsaPub(rsaPriv);\n\n\t\tsize_t signatureLength = rsaPriv.SignMessage(GlobalRNG(), (byte *)plain, strlen(plain), out);\n\t\tfail = memcmp(signature, out, 64) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature check against test vector\\n\";\n\n\t\tfail = !rsaPub.VerifyMessage((byte *)plain, strlen(plain), out, signatureLength);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"verification check against test vector\\n\";\n\n\t\tout[10]++;\n\t\tfail = rsaPub.VerifyMessage((byte *)plain, strlen(plain), out, signatureLength);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"invalid signature verification\\n\";\n\t}\n\t{\n\t\tFileSource keys(\"TestData/rsa1024.dat\", true, new HexDecoder);\n\t\tRSAES_PKCS1v15_Decryptor rsaPriv(keys);\n\t\tRSAES_PKCS1v15_Encryptor rsaPub(rsaPriv);\n\n\t\tpass = CryptoSystemValidate(rsaPriv, rsaPub) && pass;\n\t}\n\t{\n\t\tRSAES<OAEP<SHA> >::Decryptor rsaPriv(GlobalRNG(), 512);\n\t\tRSAES<OAEP<SHA> >::Encryptor rsaPub(rsaPriv);\n\n\t\tpass = CryptoSystemValidate(rsaPriv, rsaPub) && pass;\n\t}\n\t{\n\t\tbyte *plain = (byte *)\n\t\t\t\"\\x54\\x85\\x9b\\x34\\x2c\\x49\\xea\\x2a\";\n\t\tbyte *encrypted = (byte *)\n\t\t\t\"\\x14\\xbd\\xdd\\x28\\xc9\\x83\\x35\\x19\\x23\\x80\\xe8\\xe5\\x49\\xb1\\x58\\x2a\"\n\t\t\t\"\\x8b\\x40\\xb4\\x48\\x6d\\x03\\xa6\\xa5\\x31\\x1f\\x1f\\xd5\\xf0\\xa1\\x80\\xe4\"\n\t\t\t\"\\x17\\x53\\x03\\x29\\xa9\\x34\\x90\\x74\\xb1\\x52\\x13\\x54\\x29\\x08\\x24\\x52\"\n\t\t\t\"\\x62\\x51\";\n\t\tbyte *oaepSeed = (byte *)\n\t\t\t\"\\xaa\\xfd\\x12\\xf6\\x59\\xca\\xe6\\x34\\x89\\xb4\\x79\\xe5\\x07\\x6d\\xde\\xc2\"\n\t\t\t\"\\xf0\\x6c\\xb5\\x8f\";\n\t\tByteQueue bq;\n\t\tbq.Put(oaepSeed, 20);\n\t\tFixedRNG rng(bq);\n\n\t\tFileSource privFile(\"TestData/rsa400pv.dat\", true, new HexDecoder);\n\t\tFileSource pubFile(\"TestData/rsa400pb.dat\", true, new HexDecoder);\n\t\tRSAES_OAEP_SHA_Decryptor rsaPriv;\n\t\trsaPriv.AccessKey().BERDecodePrivateKey(privFile, false, 0);\n\t\tRSAES_OAEP_SHA_Encryptor rsaPub(pubFile);\n\n\t\tmemset(out, 0, 50);\n\t\tmemset(outPlain, 0, 8);\n\t\trsaPub.Encrypt(rng, plain, 8, out);\n\t\tDecodingResult result = rsaPriv.FixedLengthDecrypt(GlobalRNG(), encrypted, outPlain);\n\t\tfail = !result.isValidCoding || (result.messageLength!=8) || memcmp(out, encrypted, 50) || memcmp(plain, outPlain, 8);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"PKCS 2.0 encryption and decryption\\n\";\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "plain",
            "outPlain",
            "8"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "out",
            "encrypted",
            "50"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsaPriv.FixedLengthDecrypt",
          "args": [
            "GlobalRNG()",
            "encrypted",
            "outPlain"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "FixedLengthDecrypt",
          "container": "ElGamalObjectImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/elgamal.h",
          "lines": "86-87",
          "snippet": "DecodingResult FixedLengthDecrypt(RandomNumberGenerator &rng, const byte *cipherText, byte *plainText) const\n\t\t{return Decrypt(rng, cipherText, FixedCiphertextLength(), plainText);}",
          "includes": [
            "#include \"dsa.h\"",
            "#include \"modexppc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dsa.h\"\n#include \"modexppc.h\"\n\nElGamalObjectImpl {\n  DecodingResult FixedLengthDecrypt(RandomNumberGenerator &rng, const byte *cipherText, byte *plainText) const\n  \t\t{return Decrypt(rng, cipherText, FixedCiphertextLength(), plainText);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsaPub.Encrypt",
          "args": [
            "rng",
            "plain",
            "8",
            "out"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "outPlain",
            "0",
            "8"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "out",
            "0",
            "50"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsaPriv.AccessKey",
          "args": [
            "privFile",
            "false",
            "0"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsaPriv.AccessKey",
          "args": [],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bq.Put",
          "args": [
            "oaepSeed",
            "20"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "42-49",
          "snippet": "inline size_t Put(const byte *begin, size_t length)\n\t{\n\t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n\t\tif (buf+m_tail != begin)\n\t\t\tmemcpy(buf+m_tail, begin, l);\n\t\tm_tail += l;\n\t\treturn l;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t Put(const byte *begin, size_t length)\n  \t{\n  \t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n  \t\tif (buf+m_tail != begin)\n  \t\t\tmemcpy(buf+m_tail, begin, l);\n  \t\tm_tail += l;\n  \t\treturn l;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CryptoSystemValidate",
          "args": [
            "rsaPriv",
            "rsaPub"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "CryptoSystemValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "154-178",
          "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsaPub.VerifyMessage",
          "args": [
            "(byte *)plain",
            "strlen(plain)",
            "out",
            "signatureLength"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "plain"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsaPub.VerifyMessage",
          "args": [
            "(byte *)plain",
            "strlen(plain)",
            "out",
            "signatureLength"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "plain"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "signature",
            "out",
            "64"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsaPriv.SignMessage",
          "args": [
            "GlobalRNG()",
            "(byte *)plain",
            "strlen(plain)",
            "out"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "plain"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateRSA()\n{\n\tcout << \"\\nRSA validation suite running...\\n\\n\";\n\n\tbyte out[100], outPlain[100];\n\tbool pass = true, fail;\n\n\t{\n\t\tconst char *plain = \"Everyone gets Friday off.\";\n\t\tbyte *signature = (byte *)\n\t\t\t\"\\x05\\xfa\\x6a\\x81\\x2f\\xc7\\xdf\\x8b\\xf4\\xf2\\x54\\x25\\x09\\xe0\\x3e\\x84\"\n\t\t\t\"\\x6e\\x11\\xb9\\xc6\\x20\\xbe\\x20\\x09\\xef\\xb4\\x40\\xef\\xbc\\xc6\\x69\\x21\"\n\t\t\t\"\\x69\\x94\\xac\\x04\\xf3\\x41\\xb5\\x7d\\x05\\x20\\x2d\\x42\\x8f\\xb2\\xa2\\x7b\"\n\t\t\t\"\\x5c\\x77\\xdf\\xd9\\xb1\\x5b\\xfc\\x3d\\x55\\x93\\x53\\x50\\x34\\x10\\xc1\\xe1\";\n\n\t\tFileSource keys(\"TestData/rsa512a.dat\", true, new HexDecoder);\n\t\tWeak::RSASSA_PKCS1v15_MD2_Signer rsaPriv(keys);\n\t\tWeak::RSASSA_PKCS1v15_MD2_Verifier rsaPub(rsaPriv);\n\n\t\tsize_t signatureLength = rsaPriv.SignMessage(GlobalRNG(), (byte *)plain, strlen(plain), out);\n\t\tfail = memcmp(signature, out, 64) != 0;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature check against test vector\\n\";\n\n\t\tfail = !rsaPub.VerifyMessage((byte *)plain, strlen(plain), out, signatureLength);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"verification check against test vector\\n\";\n\n\t\tout[10]++;\n\t\tfail = rsaPub.VerifyMessage((byte *)plain, strlen(plain), out, signatureLength);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"invalid signature verification\\n\";\n\t}\n\t{\n\t\tFileSource keys(\"TestData/rsa1024.dat\", true, new HexDecoder);\n\t\tRSAES_PKCS1v15_Decryptor rsaPriv(keys);\n\t\tRSAES_PKCS1v15_Encryptor rsaPub(rsaPriv);\n\n\t\tpass = CryptoSystemValidate(rsaPriv, rsaPub) && pass;\n\t}\n\t{\n\t\tRSAES<OAEP<SHA> >::Decryptor rsaPriv(GlobalRNG(), 512);\n\t\tRSAES<OAEP<SHA> >::Encryptor rsaPub(rsaPriv);\n\n\t\tpass = CryptoSystemValidate(rsaPriv, rsaPub) && pass;\n\t}\n\t{\n\t\tbyte *plain = (byte *)\n\t\t\t\"\\x54\\x85\\x9b\\x34\\x2c\\x49\\xea\\x2a\";\n\t\tbyte *encrypted = (byte *)\n\t\t\t\"\\x14\\xbd\\xdd\\x28\\xc9\\x83\\x35\\x19\\x23\\x80\\xe8\\xe5\\x49\\xb1\\x58\\x2a\"\n\t\t\t\"\\x8b\\x40\\xb4\\x48\\x6d\\x03\\xa6\\xa5\\x31\\x1f\\x1f\\xd5\\xf0\\xa1\\x80\\xe4\"\n\t\t\t\"\\x17\\x53\\x03\\x29\\xa9\\x34\\x90\\x74\\xb1\\x52\\x13\\x54\\x29\\x08\\x24\\x52\"\n\t\t\t\"\\x62\\x51\";\n\t\tbyte *oaepSeed = (byte *)\n\t\t\t\"\\xaa\\xfd\\x12\\xf6\\x59\\xca\\xe6\\x34\\x89\\xb4\\x79\\xe5\\x07\\x6d\\xde\\xc2\"\n\t\t\t\"\\xf0\\x6c\\xb5\\x8f\";\n\t\tByteQueue bq;\n\t\tbq.Put(oaepSeed, 20);\n\t\tFixedRNG rng(bq);\n\n\t\tFileSource privFile(\"TestData/rsa400pv.dat\", true, new HexDecoder);\n\t\tFileSource pubFile(\"TestData/rsa400pb.dat\", true, new HexDecoder);\n\t\tRSAES_OAEP_SHA_Decryptor rsaPriv;\n\t\trsaPriv.AccessKey().BERDecodePrivateKey(privFile, false, 0);\n\t\tRSAES_OAEP_SHA_Encryptor rsaPub(pubFile);\n\n\t\tmemset(out, 0, 50);\n\t\tmemset(outPlain, 0, 8);\n\t\trsaPub.Encrypt(rng, plain, 8, out);\n\t\tDecodingResult result = rsaPriv.FixedLengthDecrypt(GlobalRNG(), encrypted, outPlain);\n\t\tfail = !result.isValidCoding || (result.messageLength!=8) || memcmp(out, encrypted, 50) || memcmp(plain, outPlain, 8);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"PKCS 2.0 encryption and decryption\\n\";\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "AuthenticatedKeyAgreementValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "216-254",
    "snippet": "bool AuthenticatedKeyAgreementValidate(AuthenticatedKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    authenticated key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    authenticated key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock spriv1(d.StaticPrivateKeyLength()), spriv2(d.StaticPrivateKeyLength());\n\tSecByteBlock epriv1(d.EphemeralPrivateKeyLength()), epriv2(d.EphemeralPrivateKeyLength());\n\tSecByteBlock spub1(d.StaticPublicKeyLength()), spub2(d.StaticPublicKeyLength());\n\tSecByteBlock epub1(d.EphemeralPublicKeyLength()), epub2(d.EphemeralPublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv1, spub1);\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv2, spub2);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv1, epub1);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv2, epub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, spriv1, epriv1, spub2, epub2) && d.Agree(val2, spriv2, epriv2, spub1, epub1)))\n\t{\n\t\tcout << \"FAILED    authenticated key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    authenticated agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    authenticated key agreement\" << endl;\n\treturn true;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "val1.begin()",
            "val2.begin()",
            "d.AgreedValueLength()"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.AgreedValueLength",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "AgreedValueLength",
          "container": "MQV_Domain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqv.h",
          "lines": "45-45",
          "snippet": "unsigned int AgreedValueLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(false);}",
          "includes": [
            "#include \"gfpcrypt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gfpcrypt.h\"\n\nMQV_Domain {\n  unsigned int AgreedValueLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(false);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "val2.begin",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d.Agree",
          "args": [
            "val2",
            "spriv2",
            "epriv2",
            "spub1",
            "epub1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.Agree",
          "args": [
            "val1",
            "spriv1",
            "epriv1",
            "spub2",
            "epub2"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val2.begin()",
            "0x11",
            "val2.size()"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val2.size",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val1.begin()",
            "0x10",
            "val1.size()"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.GenerateEphemeralKeyPair",
          "args": [
            "GlobalRNG()",
            "epriv2",
            "epub2"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateEphemeralKeyPair",
          "container": "DH2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/dh2.h",
          "lines": "44-45",
          "snippet": "void GenerateEphemeralKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const\n\t\t{d2.GenerateKeyPair(rng, privateKey, publicKey);}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nDH2 {\n  void GenerateEphemeralKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const\n  \t\t{d2.GenerateKeyPair(rng, privateKey, publicKey);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.GenerateStaticKeyPair",
          "args": [
            "GlobalRNG()",
            "spriv2",
            "spub2"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateStaticKeyPair",
          "container": "DH2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/dh2.h",
          "lines": "33-34",
          "snippet": "void GenerateStaticKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const\n\t\t{d1.GenerateKeyPair(rng, privateKey, publicKey);}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nDH2 {\n  void GenerateStaticKeyPair(RandomNumberGenerator &rng, byte *privateKey, byte *publicKey) const\n  \t\t{d1.GenerateKeyPair(rng, privateKey, publicKey);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.EphemeralPublicKeyLength",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "EphemeralPublicKeyLength",
          "container": "MQV_Domain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqv.h",
          "lines": "64-64",
          "snippet": "unsigned int EphemeralPublicKeyLength() const {return StaticPublicKeyLength();}",
          "includes": [
            "#include \"gfpcrypt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gfpcrypt.h\"\n\nMQV_Domain {\n  unsigned int EphemeralPublicKeyLength() const {return StaticPublicKeyLength();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d.StaticPublicKeyLength",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "StaticPublicKeyLength",
          "container": "MQV_Domain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqv.h",
          "lines": "47-47",
          "snippet": "unsigned int StaticPublicKeyLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(true);}",
          "includes": [
            "#include \"gfpcrypt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gfpcrypt.h\"\n\nMQV_Domain {\n  unsigned int StaticPublicKeyLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(true);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d.EphemeralPrivateKeyLength",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "EphemeralPrivateKeyLength",
          "container": "MQV_Domain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqv.h",
          "lines": "63-63",
          "snippet": "unsigned int EphemeralPrivateKeyLength() const {return StaticPrivateKeyLength() + StaticPublicKeyLength();}",
          "includes": [
            "#include \"gfpcrypt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gfpcrypt.h\"\n\nMQV_Domain {\n  unsigned int EphemeralPrivateKeyLength() const {return StaticPrivateKeyLength() + StaticPublicKeyLength();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d.StaticPrivateKeyLength",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "StaticPrivateKeyLength",
          "container": "MQV_Domain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqv.h",
          "lines": "46-46",
          "snippet": "unsigned int StaticPrivateKeyLength() const {return GetAbstractGroupParameters().GetSubgroupOrder().ByteCount();}",
          "includes": [
            "#include \"gfpcrypt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gfpcrypt.h\"\n\nMQV_Domain {\n  unsigned int StaticPrivateKeyLength() const {return GetAbstractGroupParameters().GetSubgroupOrder().ByteCount();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d.GetCryptoParameters",
          "args": [
            "GlobalRNG()",
            "3"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.GetCryptoParameters",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool AuthenticatedKeyAgreementValidate(AuthenticatedKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    authenticated key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    authenticated key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock spriv1(d.StaticPrivateKeyLength()), spriv2(d.StaticPrivateKeyLength());\n\tSecByteBlock epriv1(d.EphemeralPrivateKeyLength()), epriv2(d.EphemeralPrivateKeyLength());\n\tSecByteBlock spub1(d.StaticPublicKeyLength()), spub2(d.StaticPublicKeyLength());\n\tSecByteBlock epub1(d.EphemeralPublicKeyLength()), epub2(d.EphemeralPublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv1, spub1);\n\td.GenerateStaticKeyPair(GlobalRNG(), spriv2, spub2);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv1, epub1);\n\td.GenerateEphemeralKeyPair(GlobalRNG(), epriv2, epub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, spriv1, epriv1, spub2, epub2) && d.Agree(val2, spriv2, epriv2, spub1, epub1)))\n\t{\n\t\tcout << \"FAILED    authenticated key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    authenticated agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    authenticated key agreement\" << endl;\n\treturn true;\n}"
  },
  {
    "function_name": "SimpleKeyAgreementValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "180-214",
    "snippet": "bool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "val1.begin()",
            "val2.begin()",
            "d.AgreedValueLength()"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.AgreedValueLength",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "AgreedValueLength",
          "container": "MQV_Domain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqv.h",
          "lines": "45-45",
          "snippet": "unsigned int AgreedValueLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(false);}",
          "includes": [
            "#include \"gfpcrypt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gfpcrypt.h\"\n\nMQV_Domain {\n  unsigned int AgreedValueLength() const {return GetAbstractGroupParameters().GetEncodedElementSize(false);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "val2.begin",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d.Agree",
          "args": [
            "val2",
            "priv2",
            "pub1"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.Agree",
          "args": [
            "val1",
            "priv1",
            "pub2"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val2.begin()",
            "0x11",
            "val2.size()"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val2.size",
          "args": [],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val1.begin()",
            "0x10",
            "val1.size()"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.GenerateKeyPair",
          "args": [
            "GlobalRNG()",
            "priv2",
            "pub2"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.GenerateKeyPair",
          "args": [
            "GlobalRNG()",
            "priv1",
            "pub1"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.PublicKeyLength",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "PublicKeyLength",
          "container": "XTR_DH",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.h",
          "lines": "31-31",
          "snippet": "unsigned int PublicKeyLength() const {return 2*m_p.ByteCount();}",
          "includes": [
            "#include \"xtr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xtr.h\"\n\nXTR_DH {\n  unsigned int PublicKeyLength() const {return 2*m_p.ByteCount();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d.PrivateKeyLength",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "PrivateKeyLength",
          "container": "XTR_DH",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.h",
          "lines": "30-30",
          "snippet": "unsigned int PrivateKeyLength() const {return m_q.ByteCount();}",
          "includes": [
            "#include \"xtr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xtr.h\"\n\nXTR_DH {\n  unsigned int PrivateKeyLength() const {return m_q.ByteCount();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d.GetCryptoParameters",
          "args": [
            "GlobalRNG()",
            "3"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d.GetCryptoParameters",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SimpleKeyAgreementValidate(SimpleKeyAgreementDomain &d)\n{\n\tif (d.GetCryptoParameters().Validate(GlobalRNG(), 3))\n\t\tcout << \"passed    simple key agreement domain parameters validation\" << endl;\n\telse\n\t{\n\t\tcout << \"FAILED    simple key agreement domain parameters invalid\" << endl;\n\t\treturn false;\n\t}\n\n\tSecByteBlock priv1(d.PrivateKeyLength()), priv2(d.PrivateKeyLength());\n\tSecByteBlock pub1(d.PublicKeyLength()), pub2(d.PublicKeyLength());\n\tSecByteBlock val1(d.AgreedValueLength()), val2(d.AgreedValueLength());\n\n\td.GenerateKeyPair(GlobalRNG(), priv1, pub1);\n\td.GenerateKeyPair(GlobalRNG(), priv2, pub2);\n\n\tmemset(val1.begin(), 0x10, val1.size());\n\tmemset(val2.begin(), 0x11, val2.size());\n\n\tif (!(d.Agree(val1, priv1, pub2) && d.Agree(val2, priv2, pub1)))\n\t{\n\t\tcout << \"FAILED    simple key agreement failed\" << endl;\n\t\treturn false;\n\t}\n\n\tif (memcmp(val1.begin(), val2.begin(), d.AgreedValueLength()))\n\t{\n\t\tcout << \"FAILED    simple agreed values not equal\" << endl;\n\t\treturn false;\n\t}\n\n\tcout << \"passed    simple key agreement\" << endl;\n\treturn true;\n}"
  },
  {
    "function_name": "CryptoSystemValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "154-178",
    "snippet": "bool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "message",
            "plaintext",
            "messageLen"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodingResult",
          "args": [
            "messageLen"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.Decrypt",
          "args": [
            "GlobalRNG()",
            "ciphertext",
            "priv.CiphertextLength(messageLen)",
            "plaintext"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.CiphertextLength",
          "args": [
            "messageLen"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "CiphertextLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "144-145",
          "snippet": "size_t CiphertextLength(size_t plaintextLength) const\n\t\t{return plaintextLength <= FixedMaxPlaintextLength() ? FixedCiphertextLength() : 0;}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nsize_t CiphertextLength(size_t plaintextLength) const\n\t\t{return plaintextLength <= FixedMaxPlaintextLength() ? FixedCiphertextLength() : 0;}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.Encrypt",
          "args": [
            "GlobalRNG()",
            "message",
            "messageLen",
            "ciphertext"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.MaxPlaintextLength",
          "args": [
            "ciphertext.size()"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ciphertext.size",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "priv.GetMaterial",
          "args": [
            "GlobalRNG()",
            "thorough ? 3 : 2"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetMaterial",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetMaterial",
          "args": [
            "GlobalRNG()",
            "thorough ? 3 : 2"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetMaterial",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool CryptoSystemValidate(PK_Decryptor &priv, PK_Encryptor &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"cryptosystem key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\tSecByteBlock ciphertext(priv.CiphertextLength(messageLen));\n\tSecByteBlock plaintext(priv.MaxPlaintextLength(ciphertext.size()));\n\n\tpub.Encrypt(GlobalRNG(), message, messageLen, ciphertext);\n\tfail = priv.Decrypt(GlobalRNG(), ciphertext, priv.CiphertextLength(messageLen), plaintext) != DecodingResult(messageLen);\n\tfail = fail || memcmp(message, plaintext, messageLen);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"encryption and decryption\\n\";\n\n\treturn pass;\n}"
  },
  {
    "function_name": "SignatureValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "103-152",
    "snippet": "bool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pub.RecoverMessage",
          "args": [
            "recovered",
            "NULL",
            "0",
            "signature",
            "signatureLength"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "recovered",
            "message",
            "messageLen"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.RecoverMessage",
          "args": [
            "recovered",
            "NULL",
            "0",
            "signature",
            "signatureLength"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.MaxRecoverableLengthFromSignatureLength",
          "args": [
            "signatureLength"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.SignMessageWithRecovery",
          "args": [
            "GlobalRNG()",
            "message",
            "messageLen",
            "NULL",
            "0",
            "signature"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.MaxRecoverableLength",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.VerifyMessage",
          "args": [
            "message",
            "messageLen",
            "signature",
            "signatureLength"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.VerifyMessage",
          "args": [
            "message",
            "messageLen",
            "signature",
            "signatureLength"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.SignMessage",
          "args": [
            "GlobalRNG()",
            "message",
            "messageLen",
            "signature"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.MaxSignatureLength",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetMaterial",
          "args": [
            "GlobalRNG()",
            "thorough ? 3 : 2"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetMaterial",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetMaterial",
          "args": [
            "GlobalRNG()",
            "thorough ? 3 : 2"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetMaterial",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool SignatureValidate(PK_Signer &priv, PK_Verifier &pub, bool thorough = false)\n{\n\tbool pass = true, fail;\n\n\tfail = !pub.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2) || !priv.GetMaterial().Validate(GlobalRNG(), thorough ? 3 : 2);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature key validation\\n\";\n\n\tconst byte *message = (byte *)\"test message\";\n\tconst int messageLen = 12;\n\n\tSecByteBlock signature(priv.MaxSignatureLength());\n\tsize_t signatureLength = priv.SignMessage(GlobalRNG(), message, messageLen, signature);\n\tfail = !pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"signature and verification\\n\";\n\n\t++signature[0];\n\tfail = pub.VerifyMessage(message, messageLen, signature, signatureLength);\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tcout << \"checking invalid signature\" << endl;\n\n\tif (priv.MaxRecoverableLength() > 0)\n\t{\n\t\tsignatureLength = priv.SignMessageWithRecovery(GlobalRNG(), message, messageLen, NULL, 0, signature);\n\t\tSecByteBlock recovered(priv.MaxRecoverableLengthFromSignatureLength(signatureLength));\n\t\tDecodingResult result = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = !(result.isValidCoding && result.messageLength == messageLen && memcmp(recovered, message, messageLen) == 0);\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"signature and verification with recovery\" << endl;\n\n\t\t++signature[0];\n\t\tresult = pub.RecoverMessage(recovered, NULL, 0, signature, signatureLength);\n\t\tfail = result.isValidCoding;\n\t\tpass = pass && !fail;\n\n\t\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\t\tcout << \"recovery with invalid signature\" << endl;\n\t}\n\n\treturn pass;\n}"
  },
  {
    "function_name": "ValidateBBS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "51-101",
    "snippet": "bool ValidateBBS()\n{\n\tcout << \"\\nBlumBlumShub validation suite running...\\n\\n\";\n\n\tInteger p(\"212004934506826557583707108431463840565872545889679278744389317666981496005411448865750399674653351\");\n\tInteger q(\"100677295735404212434355574418077394581488455772477016953458064183204108039226017738610663984508231\");\n\tInteger seed(\"63239752671357255800299643604761065219897634268887145610573595874544114193025997412441121667211431\");\n\tBlumBlumShub bbs(p, q, seed);\n\tbool pass = true, fail;\n\tint j;\n\n\tconst byte output1[] = {\n\t\t0x49,0xEA,0x2C,0xFD,0xB0,0x10,0x64,0xA0,0xBB,0xB9,\n\t\t0x2A,0xF1,0x01,0xDA,0xC1,0x8A,0x94,0xF7,0xB7,0xCE};\n\tconst byte output2[] = {\n\t\t0x74,0x45,0x48,0xAE,0xAC,0xB7,0x0E,0xDF,0xAF,0xD7,\n\t\t0xD5,0x0E,0x8E,0x29,0x83,0x75,0x6B,0x27,0x46,0xA1};\n\n\tbyte buf[20];\n\n\tbbs.GenerateBlock(buf, 20);\n\tfail = memcmp(output1, buf, 20) != 0;\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tfor (j=0;j<20;j++)\n\t\tcout << setw(2) << setfill('0') << hex << (int)buf[j];\n\tcout << endl;\n\n\tbbs.Seek(10);\n\tbbs.GenerateBlock(buf, 10);\n\tfail = memcmp(output1+10, buf, 10) != 0;\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tfor (j=0;j<10;j++)\n\t\tcout << setw(2) << setfill('0') << hex << (int)buf[j];\n\tcout << endl;\n\n\tbbs.Seek(1234567);\n\tbbs.GenerateBlock(buf, 20);\n\tfail = memcmp(output2, buf, 20) != 0;\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tfor (j=0;j<20;j++)\n\t\tcout << setw(2) << setfill('0') << hex << (int)buf[j];\n\tcout << endl;\n\n\treturn pass;\n}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "output2",
            "buf",
            "20"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bbs.GenerateBlock",
          "args": [
            "buf",
            "20"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateBlock",
          "container": "FixedRNG",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
          "lines": "42-45",
          "snippet": "void GenerateBlock(byte *output, size_t size)\n\t{\n\t\tm_source.Get(output, size);\n\t}",
          "includes": [
            "#include \"validate.h\"",
            "#include <iomanip>",
            "#include <iostream>",
            "#include \"osrng.h\"",
            "#include \"esign.h\"",
            "#include \"oids.h\"",
            "#include \"hex.h\"",
            "#include \"files.h\"",
            "#include \"rng.h\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"ecp.h\"",
            "#include \"eccrypto.h\"",
            "#include \"rw.h\"",
            "#include \"rabin.h\"",
            "#include \"xtrcrypt.h\"",
            "#include \"luc.h\"",
            "#include \"mqv.h\"",
            "#include \"dh.h\"",
            "#include \"dsa.h\"",
            "#include \"nr.h\"",
            "#include \"elgamal.h\"",
            "#include \"md2.h\"",
            "#include \"rsa.h\"",
            "#include \"blumshub.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nFixedRNG {\n  void GenerateBlock(byte *output, size_t size)\n  \t{\n  \t\tm_source.Get(output, size);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bbs.Seek",
          "args": [
            "1234567"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "output1+10",
            "buf",
            "10"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bbs.Seek",
          "args": [
            "10"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setfill",
          "args": [
            "'0'"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setw",
          "args": [
            "2"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "output1",
            "buf",
            "20"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nbool ValidateBBS()\n{\n\tcout << \"\\nBlumBlumShub validation suite running...\\n\\n\";\n\n\tInteger p(\"212004934506826557583707108431463840565872545889679278744389317666981496005411448865750399674653351\");\n\tInteger q(\"100677295735404212434355574418077394581488455772477016953458064183204108039226017738610663984508231\");\n\tInteger seed(\"63239752671357255800299643604761065219897634268887145610573595874544114193025997412441121667211431\");\n\tBlumBlumShub bbs(p, q, seed);\n\tbool pass = true, fail;\n\tint j;\n\n\tconst byte output1[] = {\n\t\t0x49,0xEA,0x2C,0xFD,0xB0,0x10,0x64,0xA0,0xBB,0xB9,\n\t\t0x2A,0xF1,0x01,0xDA,0xC1,0x8A,0x94,0xF7,0xB7,0xCE};\n\tconst byte output2[] = {\n\t\t0x74,0x45,0x48,0xAE,0xAC,0xB7,0x0E,0xDF,0xAF,0xD7,\n\t\t0xD5,0x0E,0x8E,0x29,0x83,0x75,0x6B,0x27,0x46,0xA1};\n\n\tbyte buf[20];\n\n\tbbs.GenerateBlock(buf, 20);\n\tfail = memcmp(output1, buf, 20) != 0;\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tfor (j=0;j<20;j++)\n\t\tcout << setw(2) << setfill('0') << hex << (int)buf[j];\n\tcout << endl;\n\n\tbbs.Seek(10);\n\tbbs.GenerateBlock(buf, 10);\n\tfail = memcmp(output1+10, buf, 10) != 0;\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tfor (j=0;j<10;j++)\n\t\tcout << setw(2) << setfill('0') << hex << (int)buf[j];\n\tcout << endl;\n\n\tbbs.Seek(1234567);\n\tbbs.GenerateBlock(buf, 20);\n\tfail = memcmp(output2, buf, 20) != 0;\n\tpass = pass && !fail;\n\n\tcout << (fail ? \"FAILED    \" : \"passed    \");\n\tfor (j=0;j<20;j++)\n\t\tcout << setw(2) << setfill('0') << hex << (int)buf[j];\n\tcout << endl;\n\n\treturn pass;\n}"
  },
  {
    "function_name": "GenerateBlock",
    "container": "FixedRNG",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "42-45",
    "snippet": "void GenerateBlock(byte *output, size_t size)\n\t{\n\t\tm_source.Get(output, size);\n\t}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_source.Get",
          "args": [
            "output",
            "size"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "88-93",
          "snippet": "inline size_t Get(byte *outString, size_t getMax)\n\t{\n\t\tsize_t len = Peek(outString, getMax);\n\t\tm_head += len;\n\t\treturn len;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t Get(byte *outString, size_t getMax)\n  \t{\n  \t\tsize_t len = Peek(outString, getMax);\n  \t\tm_head += len;\n  \t\treturn len;\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nFixedRNG {\n  void GenerateBlock(byte *output, size_t size)\n  \t{\n  \t\tm_source.Get(output, size);\n  \t}\n}"
  },
  {
    "function_name": "FixedRNG",
    "container": "FixedRNG",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/validat2.cpp",
    "lines": "40-40",
    "snippet": "FixedRNG(BufferedTransformation &source) : m_source(source) {}",
    "includes": [
      "#include \"validate.h\"",
      "#include <iomanip>",
      "#include <iostream>",
      "#include \"osrng.h\"",
      "#include \"esign.h\"",
      "#include \"oids.h\"",
      "#include \"hex.h\"",
      "#include \"files.h\"",
      "#include \"rng.h\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"ecp.h\"",
      "#include \"eccrypto.h\"",
      "#include \"rw.h\"",
      "#include \"rabin.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"luc.h\"",
      "#include \"mqv.h\"",
      "#include \"dh.h\"",
      "#include \"dsa.h\"",
      "#include \"nr.h\"",
      "#include \"elgamal.h\"",
      "#include \"md2.h\"",
      "#include \"rsa.h\"",
      "#include \"blumshub.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"validate.h\"\n#include <iomanip>\n#include <iostream>\n#include \"osrng.h\"\n#include \"esign.h\"\n#include \"oids.h\"\n#include \"hex.h\"\n#include \"files.h\"\n#include \"rng.h\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"ecp.h\"\n#include \"eccrypto.h\"\n#include \"rw.h\"\n#include \"rabin.h\"\n#include \"xtrcrypt.h\"\n#include \"luc.h\"\n#include \"mqv.h\"\n#include \"dh.h\"\n#include \"dsa.h\"\n#include \"nr.h\"\n#include \"elgamal.h\"\n#include \"md2.h\"\n#include \"rsa.h\"\n#include \"blumshub.h\"\n#include \"pch.h\"\n\nFixedRNG {\n  FixedRNG(BufferedTransformation &source) : m_source(source) {}\n}"
  }
]