[
  {
    "function_name": "ProcessAndXorBlock",
    "container": "Rijndael::Dec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rijndael.cpp",
    "lines": "429-514",
    "snippet": "void Rijndael::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\n\tif (HasAESNI())\n\t{\n\t\tRijndael::Dec::AdvancedProcessBlocks(inBlock, xorBlock, outBlock, 16, 0);\n\t\treturn;\n\t}\n#endif\n\n\ttypedef BlockGetAndPut<word32, NativeByteOrder> Block;\n\n\tword32 s0, s1, s2, s3, t0, t1, t2, t3;\n\tBlock::Get(inBlock)(s0)(s1)(s2)(s3);\n\n\tconst word32 *rk = m_key;\n\ts0 ^= rk[0];\n\ts1 ^= rk[1];\n\ts2 ^= rk[2];\n\ts3 ^= rk[3];\n\tt0 = rk[4];\n\tt1 = rk[5];\n\tt2 = rk[6];\n\tt3 = rk[7];\n\trk += 8;\n\n\t// timing attack countermeasure. see comments at top for more details\n\tconst int cacheLineSize = GetCacheLineSize();\n\tunsigned int i;\n\tword32 u = 0;\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tfor (i=0; i<2048; i+=cacheLineSize)\n#else\n\tfor (i=0; i<1024; i+=cacheLineSize)\n#endif\n\t\tu &= *(const word32 *)(((const byte *)Td)+i);\n\tu &= Td[255];\n\ts0 |= u; s1 |= u; s2 |= u; s3 |= u;\n\n\tQUARTER_ROUND_FD(s3, t2, t1, t0, t3)\n\tQUARTER_ROUND_FD(s2, t1, t0, t3, t2)\n\tQUARTER_ROUND_FD(s1, t0, t3, t2, t1)\n\tQUARTER_ROUND_FD(s0, t3, t2, t1, t0)\n\n\t// Nr - 2 full rounds:\n    unsigned int r = m_rounds/2 - 1;\n    do\n\t{\n\t\ts0 = rk[0]; s1 = rk[1]; s2 = rk[2]; s3 = rk[3];\n\n\t\tQUARTER_ROUND_D(t3, s2, s1, s0, s3)\n\t\tQUARTER_ROUND_D(t2, s1, s0, s3, s2)\n\t\tQUARTER_ROUND_D(t1, s0, s3, s2, s1)\n\t\tQUARTER_ROUND_D(t0, s3, s2, s1, s0)\n\n\t\tt0 = rk[4]; t1 = rk[5]; t2 = rk[6]; t3 = rk[7];\n\n\t\tQUARTER_ROUND_D(s3, t2, t1, t0, t3)\n\t\tQUARTER_ROUND_D(s2, t1, t0, t3, t2)\n\t\tQUARTER_ROUND_D(s1, t0, t3, t2, t1)\n\t\tQUARTER_ROUND_D(s0, t3, t2, t1, t0)\n\n        rk += 8;\n    } while (--r);\n\n#ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\t// timing attack countermeasure. see comments at top for more details\n\t// If CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS is defined, \n\t// QUARTER_ROUND_LD will use Td, which is already preloaded.\n\tu = 0;\n\tfor (i=0; i<256; i+=cacheLineSize)\n\t\tu &= *(const word32 *)(Sd+i);\n\tu &= *(const word32 *)(Sd+252);\n\tt0 |= u; t1 |= u; t2 |= u; t3 |= u;\n#endif\n\n\tword32 tbw[4];\n\tbyte *const tempBlock = (byte *)tbw;\n\n\tQUARTER_ROUND_LD(t2, 7, 2, 13, 8)\n\tQUARTER_ROUND_LD(t1, 3, 14, 9, 4)\n\tQUARTER_ROUND_LD(t0, 15, 10, 5, 0)\n\tQUARTER_ROUND_LD(t3, 11, 6, 1, 12)\n\n\tBlock::Put(xorBlock, outBlock)(tbw[0]^rk[0])(tbw[1]^rk[1])(tbw[2]^rk[2])(tbw[3]^rk[3]);\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"rijndael.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "word32 s0, s1, s2, s3, t0, t1, t2, t3;",
      "const word32 *rk = m_key;",
      "const int cacheLineSize = GetCacheLineSize();",
      "unsigned int i;",
      "word32 u = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "tbw[3]^rk[3]"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "xorBlock",
            "outBlock"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_LD",
          "args": [
            "t3",
            "11",
            "6",
            "1",
            "12"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_LD",
          "args": [
            "t0",
            "15",
            "10",
            "5",
            "0"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_LD",
          "args": [
            "t1",
            "3",
            "14",
            "9",
            "4"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_LD",
          "args": [
            "t2",
            "7",
            "2",
            "13",
            "8"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_D",
          "args": [
            "s0",
            "t3",
            "t2",
            "t1",
            "t0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_D",
          "args": [
            "s1",
            "t0",
            "t3",
            "t2",
            "t1"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_D",
          "args": [
            "s2",
            "t1",
            "t0",
            "t3",
            "t2"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_D",
          "args": [
            "s3",
            "t2",
            "t1",
            "t0",
            "t3"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_D",
          "args": [
            "t0",
            "s3",
            "s2",
            "s1",
            "s0"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_D",
          "args": [
            "t1",
            "s0",
            "s3",
            "s2",
            "s1"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_D",
          "args": [
            "t2",
            "s1",
            "s0",
            "s3",
            "s2"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_D",
          "args": [
            "t3",
            "s2",
            "s1",
            "s0",
            "s3"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_FD",
          "args": [
            "s0",
            "t3",
            "t2",
            "t1",
            "t0"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_FD",
          "args": [
            "s1",
            "t0",
            "t3",
            "t2",
            "t1"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_FD",
          "args": [
            "s2",
            "t1",
            "t0",
            "t3",
            "t2"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QUARTER_ROUND_FD",
          "args": [
            "s3",
            "t2",
            "t1",
            "t0",
            "t3"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCacheLineSize",
          "args": [],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "GetCacheLineSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "183-186",
          "snippet": "inline int GetCacheLineSize()\n{\n\treturn CRYPTOPP_L1_CACHE_LINE_SIZE;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline int GetCacheLineSize()\n{\n\treturn CRYPTOPP_L1_CACHE_LINE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Get",
          "args": [
            "s3"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Rijndael::Dec::AdvancedProcessBlocks",
          "args": [
            "inBlock",
            "xorBlock",
            "outBlock",
            "16",
            "0"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "AdvancedProcessBlocks",
          "container": "BlockTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "141-177",
          "snippet": "size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n{\n\tsize_t blockSize = BlockSize();\n\tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n\tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n\tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n\n\tif (flags & BT_ReverseDirection)\n\t{\n\t\tassert(length % blockSize == 0);\n\t\tinBlocks += length - blockSize;\n\t\txorBlocks += length - blockSize;\n\t\toutBlocks += length - blockSize;\n\t\tinIncrement = 0-inIncrement;\n\t\txorIncrement = 0-xorIncrement;\n\t\toutIncrement = 0-outIncrement;\n\t}\n\n\twhile (length >= blockSize)\n\t{\n\t\tif (flags & BT_XorInput)\n\t\t{\n\t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n\t\t\tProcessBlock(outBlocks);\n\t\t}\n\t\telse\n\t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n\t\tif (flags & BT_InBlockIsCounter)\n\t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n\t\tinBlocks += inIncrement;\n\t\toutBlocks += outIncrement;\n\t\txorBlocks += xorIncrement;\n\t\tlength -= blockSize;\n\t}\n\n\treturn length;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBlockTransformation {\n  size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n  {\n  \tsize_t blockSize = BlockSize();\n  \tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n  \tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n  \tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n  \n  \tif (flags & BT_ReverseDirection)\n  \t{\n  \t\tassert(length % blockSize == 0);\n  \t\tinBlocks += length - blockSize;\n  \t\txorBlocks += length - blockSize;\n  \t\toutBlocks += length - blockSize;\n  \t\tinIncrement = 0-inIncrement;\n  \t\txorIncrement = 0-xorIncrement;\n  \t\toutIncrement = 0-outIncrement;\n  \t}\n  \n  \twhile (length >= blockSize)\n  \t{\n  \t\tif (flags & BT_XorInput)\n  \t\t{\n  \t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n  \t\t\tProcessBlock(outBlocks);\n  \t\t}\n  \t\telse\n  \t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n  \t\tif (flags & BT_InBlockIsCounter)\n  \t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n  \t\tinBlocks += inIncrement;\n  \t\toutBlocks += outIncrement;\n  \t\txorBlocks += xorIncrement;\n  \t\tlength -= blockSize;\n  \t}\n  \n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "HasAESNI",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "HasAESNI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "153-158",
          "snippet": "inline bool HasAESNI()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasAESNI;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasAESNI()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasAESNI;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"rijndael.h\"\n#include \"pch.h\"\n\nword32 s0, s1, s2, s3, t0, t1, t2, t3;\nconst word32 *rk = m_key;\nconst int cacheLineSize = GetCacheLineSize();\nunsigned int i;\nword32 u = 0;\n\nRijndael {\n  Dec {\n    void Rijndael::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    #if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\n    \tif (HasAESNI())\n    \t{\n    \t\tRijndael::Dec::AdvancedProcessBlocks(inBlock, xorBlock, outBlock, 16, 0);\n    \t\treturn;\n    \t}\n    #endif\n    \n    \ttypedef BlockGetAndPut<word32, NativeByteOrder> Block;\n    \n    \tword32 s0, s1, s2, s3, t0, t1, t2, t3;\n    \tBlock::Get(inBlock)(s0)(s1)(s2)(s3);\n    \n    \tconst word32 *rk = m_key;\n    \ts0 ^= rk[0];\n    \ts1 ^= rk[1];\n    \ts2 ^= rk[2];\n    \ts3 ^= rk[3];\n    \tt0 = rk[4];\n    \tt1 = rk[5];\n    \tt2 = rk[6];\n    \tt3 = rk[7];\n    \trk += 8;\n    \n    \t// timing attack countermeasure. see comments at top for more details\n    \tconst int cacheLineSize = GetCacheLineSize();\n    \tunsigned int i;\n    \tword32 u = 0;\n    #ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n    \tfor (i=0; i<2048; i+=cacheLineSize)\n    #else\n    \tfor (i=0; i<1024; i+=cacheLineSize)\n    #endif\n    \t\tu &= *(const word32 *)(((const byte *)Td)+i);\n    \tu &= Td[255];\n    \ts0 |= u; s1 |= u; s2 |= u; s3 |= u;\n    \n    \tQUARTER_ROUND_FD(s3, t2, t1, t0, t3)\n    \tQUARTER_ROUND_FD(s2, t1, t0, t3, t2)\n    \tQUARTER_ROUND_FD(s1, t0, t3, t2, t1)\n    \tQUARTER_ROUND_FD(s0, t3, t2, t1, t0)\n    \n    \t// Nr - 2 full rounds:\n        unsigned int r = m_rounds/2 - 1;\n        do\n    \t{\n    \t\ts0 = rk[0]; s1 = rk[1]; s2 = rk[2]; s3 = rk[3];\n    \n    \t\tQUARTER_ROUND_D(t3, s2, s1, s0, s3)\n    \t\tQUARTER_ROUND_D(t2, s1, s0, s3, s2)\n    \t\tQUARTER_ROUND_D(t1, s0, s3, s2, s1)\n    \t\tQUARTER_ROUND_D(t0, s3, s2, s1, s0)\n    \n    \t\tt0 = rk[4]; t1 = rk[5]; t2 = rk[6]; t3 = rk[7];\n    \n    \t\tQUARTER_ROUND_D(s3, t2, t1, t0, t3)\n    \t\tQUARTER_ROUND_D(s2, t1, t0, t3, t2)\n    \t\tQUARTER_ROUND_D(s1, t0, t3, t2, t1)\n    \t\tQUARTER_ROUND_D(s0, t3, t2, t1, t0)\n    \n            rk += 8;\n        } while (--r);\n    \n    #ifndef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n    \t// timing attack countermeasure. see comments at top for more details\n    \t// If CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS is defined, \n    \t// QUARTER_ROUND_LD will use Td, which is already preloaded.\n    \tu = 0;\n    \tfor (i=0; i<256; i+=cacheLineSize)\n    \t\tu &= *(const word32 *)(Sd+i);\n    \tu &= *(const word32 *)(Sd+252);\n    \tt0 |= u; t1 |= u; t2 |= u; t3 |= u;\n    #endif\n    \n    \tword32 tbw[4];\n    \tbyte *const tempBlock = (byte *)tbw;\n    \n    \tQUARTER_ROUND_LD(t2, 7, 2, 13, 8)\n    \tQUARTER_ROUND_LD(t1, 3, 14, 9, 4)\n    \tQUARTER_ROUND_LD(t0, 15, 10, 5, 0)\n    \tQUARTER_ROUND_LD(t3, 11, 6, 1, 12)\n    \n    \tBlock::Put(xorBlock, outBlock)(tbw[0]^rk[0])(tbw[1]^rk[1])(tbw[2]^rk[2])(tbw[3]^rk[3]);\n    }\n  }\n}"
  },
  {
    "function_name": "UncheckedSetKey",
    "container": "Rijndael::Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rijndael.cpp",
    "lines": "198-347",
    "snippet": "void Rijndael::Base::UncheckedSetKey(const byte *userKey, unsigned int keylen, const NameValuePairs &)\n{\n\tAssertValidKeyLength(keylen);\n\n\tm_rounds = keylen/4 + 6;\n\tm_key.New(4*(m_rounds+1));\n\n\tword32 *rk = m_key;\n\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE && (!defined(_MSC_VER) || _MSC_VER >= 1600 || CRYPTOPP_BOOL_X86)\n\t// MSVC 2008 SP1 generates bad code for _mm_extract_epi32() when compiling for X64\n\tif (HasAESNI())\n\t{\n\t\tstatic const word32 rcLE[] = {\n\t\t\t0x01, 0x02, 0x04, 0x08,\n\t\t\t0x10, 0x20, 0x40, 0x80,\n\t\t\t0x1B, 0x36, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */\n\t\t};\n\t\tconst word32 *rc = rcLE;\n\n\t\t__m128i temp = _mm_loadu_si128((__m128i *)(userKey+keylen-16));\n\t\tmemcpy(rk, userKey, keylen);\n\n\t\twhile (true)\n\t\t{\n\t\t\trk[keylen/4] = rk[0] ^ _mm_extract_epi32(_mm_aeskeygenassist_si128(temp, 0), 3) ^ *(rc++);\n\t\t\trk[keylen/4+1] = rk[1] ^ rk[keylen/4];\n\t\t\trk[keylen/4+2] = rk[2] ^ rk[keylen/4+1];\n\t\t\trk[keylen/4+3] = rk[3] ^ rk[keylen/4+2];\n\n\t\t\tif (rk + keylen/4 + 4 == m_key.end())\n\t\t\t\tbreak;\n\n\t\t\tif (keylen == 24)\n\t\t\t{\n\t\t\t\trk[10] = rk[ 4] ^ rk[ 9];\n\t\t\t\trk[11] = rk[ 5] ^ rk[10];\n\t\t\t\ttemp = _mm_insert_epi32(temp, rk[11], 3);\n\t\t\t}\n\t\t\telse if (keylen == 32)\n\t\t\t{\n\t\t\t\ttemp = _mm_insert_epi32(temp, rk[11], 3);\n    \t\t\trk[12] = rk[ 4] ^ _mm_extract_epi32(_mm_aeskeygenassist_si128(temp, 0), 2);\n    \t\t\trk[13] = rk[ 5] ^ rk[12];\n    \t\t\trk[14] = rk[ 6] ^ rk[13];\n    \t\t\trk[15] = rk[ 7] ^ rk[14];\n\t\t\t\ttemp = _mm_insert_epi32(temp, rk[15], 3);\n\t\t\t}\n\t\t\telse\n\t\t\t\ttemp = _mm_insert_epi32(temp, rk[7], 3);\n\n\t\t\trk += keylen/4;\n\t\t}\n\n\t\tif (!IsForwardTransformation())\n\t\t{\n\t\t\trk = m_key;\n\t\t\tunsigned int i, j;\n\n\t\t\tstd::swap(*(__m128i *)(rk), *(__m128i *)(rk+4*m_rounds));\n\n\t\t\tfor (i = 4, j = 4*m_rounds-4; i < j; i += 4, j -= 4)\n\t\t\t{\n\t\t\t\ttemp = _mm_aesimc_si128(*(__m128i *)(rk+i));\n\t\t\t\t*(__m128i *)(rk+i) = _mm_aesimc_si128(*(__m128i *)(rk+j));\n\t\t\t\t*(__m128i *)(rk+j) = temp;\n\t\t\t}\n\n\t\t\t*(__m128i *)(rk+i) = _mm_aesimc_si128(*(__m128i *)(rk+i));\n\t\t}\n\n\t\treturn;\n\t}\n#endif\n\n\tGetUserKey(BIG_ENDIAN_ORDER, rk, keylen/4, userKey, keylen);\n\tconst word32 *rc = rcon;\n\tword32 temp;\n\n\twhile (true)\n\t{\n\t\ttemp  = rk[keylen/4-1];\n\t\tword32 x = (word32(Se[GETBYTE(temp, 2)]) << 24) ^ (word32(Se[GETBYTE(temp, 1)]) << 16) ^ (word32(Se[GETBYTE(temp, 0)]) << 8) ^ Se[GETBYTE(temp, 3)];\n\t\trk[keylen/4] = rk[0] ^ x ^ *(rc++);\n\t\trk[keylen/4+1] = rk[1] ^ rk[keylen/4];\n\t\trk[keylen/4+2] = rk[2] ^ rk[keylen/4+1];\n\t\trk[keylen/4+3] = rk[3] ^ rk[keylen/4+2];\n\n\t\tif (rk + keylen/4 + 4 == m_key.end())\n\t\t\tbreak;\n\n\t\tif (keylen == 24)\n\t\t{\n\t\t\trk[10] = rk[ 4] ^ rk[ 9];\n\t\t\trk[11] = rk[ 5] ^ rk[10];\n\t\t}\n\t\telse if (keylen == 32)\n\t\t{\n    \t\ttemp = rk[11];\n    \t\trk[12] = rk[ 4] ^ (word32(Se[GETBYTE(temp, 3)]) << 24) ^ (word32(Se[GETBYTE(temp, 2)]) << 16) ^ (word32(Se[GETBYTE(temp, 1)]) << 8) ^ Se[GETBYTE(temp, 0)];\n    \t\trk[13] = rk[ 5] ^ rk[12];\n    \t\trk[14] = rk[ 6] ^ rk[13];\n    \t\trk[15] = rk[ 7] ^ rk[14];\n\t\t}\n\t\trk += keylen/4;\n\t}\n\n\trk = m_key;\n\n\tif (IsForwardTransformation())\n\t{\n\t\tif (!s_TeFilled)\n\t\t\tFillEncTable();\n\n\t\tConditionalByteReverse(BIG_ENDIAN_ORDER, rk, rk, 16);\n\t\tConditionalByteReverse(BIG_ENDIAN_ORDER, rk + m_rounds*4, rk + m_rounds*4, 16);\n\t}\n\telse\n\t{\n\t\tif (!s_TdFilled)\n\t\t\tFillDecTable();\n\n\t\tunsigned int i, j;\n\n#define InverseMixColumn(x)\t\tTL_M(Td, 0, Se[GETBYTE(x, 3)]) ^ TL_M(Td, 1, Se[GETBYTE(x, 2)]) ^ TL_M(Td, 2, Se[GETBYTE(x, 1)]) ^ TL_M(Td, 3, Se[GETBYTE(x, 0)])\n\n\t\tfor (i = 4, j = 4*m_rounds-4; i < j; i += 4, j -= 4)\n\t\t{\n\t\t\ttemp = InverseMixColumn(rk[i    ]); rk[i    ] = InverseMixColumn(rk[j    ]); rk[j    ] = temp;\n\t\t\ttemp = InverseMixColumn(rk[i + 1]); rk[i + 1] = InverseMixColumn(rk[j + 1]); rk[j + 1] = temp;\n\t\t\ttemp = InverseMixColumn(rk[i + 2]); rk[i + 2] = InverseMixColumn(rk[j + 2]); rk[j + 2] = temp;\n\t\t\ttemp = InverseMixColumn(rk[i + 3]); rk[i + 3] = InverseMixColumn(rk[j + 3]); rk[j + 3] = temp;\n\t\t}\n\n\t\trk[i+0] = InverseMixColumn(rk[i+0]);\n\t\trk[i+1] = InverseMixColumn(rk[i+1]);\n\t\trk[i+2] = InverseMixColumn(rk[i+2]);\n\t\trk[i+3] = InverseMixColumn(rk[i+3]);\n\n\t\ttemp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[0]); rk[0] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+0]); rk[4*m_rounds+0] = temp;\n\t\ttemp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[1]); rk[1] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+1]); rk[4*m_rounds+1] = temp;\n\t\ttemp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[2]); rk[2] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+2]); rk[4*m_rounds+2] = temp;\n\t\ttemp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[3]); rk[3] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+3]); rk[4*m_rounds+3] = temp;\n\t}\n\n#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\n\tif (HasAESNI())\n\t\tConditionalByteReverse(BIG_ENDIAN_ORDER, rk+4, rk+4, (m_rounds-1)*16);\n#endif\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"rijndael.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define TL_M\t\t\tTL_F"
    ],
    "globals_used": [
      "static volatile bool s_TeFilled = false, s_TdFilled = false;",
      "const word32 *rk = m_key;",
      "unsigned int i;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ConditionalByteReverse",
          "args": [
            "BIG_ENDIAN_ORDER",
            "rk+4",
            "rk+4",
            "(m_rounds-1)*16"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "937-943",
          "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HasAESNI",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "HasAESNI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "153-158",
          "snippet": "inline bool HasAESNI()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasAESNI;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasAESNI()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasAESNI;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[i+3]"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[i+2]"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[i+1]"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[i+0]"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[j + 3]"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[i + 3]"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[j + 2]"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[i + 2]"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[j + 1]"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[i + 1]"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[j    ]"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InverseMixColumn",
          "args": [
            "rk[i    ]"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FillDecTable",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "FillDecTable",
          "container": "Rijndael::Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rijndael.cpp",
          "lines": "178-196",
          "snippet": "void Rijndael::Base::FillDecTable()\n{\n\tfor (int i=0; i<256; i++)\n\t{\n\t\tbyte x = Sd[i];\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\t\tword32 y = word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;\n\t\tTd[i] = word64(y | fb(x))<<32 | y | x;\n#else\n\t\tword32 y = fb(x) | word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;;\n\t\tfor (int j=0; j<4; j++)\n\t\t{\n\t\t\tTd[i+j*256] = y;\n\t\t\ty = rotrFixed(y, 8);\n\t\t}\n#endif\n\t}\n\ts_TdFilled = true;\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"rijndael.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int i;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"rijndael.h\"\n#include \"pch.h\"\n\nunsigned int i;\n\nRijndael {\n  Base {\n    void Rijndael::Base::FillDecTable()\n    {\n    \tfor (int i=0; i<256; i++)\n    \t{\n    \t\tbyte x = Sd[i];\n    #ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n    \t\tword32 y = word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;\n    \t\tTd[i] = word64(y | fb(x))<<32 | y | x;\n    #else\n    \t\tword32 y = fb(x) | word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;;\n    \t\tfor (int j=0; j<4; j++)\n    \t\t{\n    \t\t\tTd[i+j*256] = y;\n    \t\t\ty = rotrFixed(y, 8);\n    \t\t}\n    #endif\n    \t}\n    \ts_TdFilled = true;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FillEncTable",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "FillEncTable",
          "container": "Rijndael::Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rijndael.cpp",
          "lines": "155-176",
          "snippet": "void Rijndael::Base::FillEncTable()\n{\n\tfor (int i=0; i<256; i++)\n\t{\n\t\tbyte x = Se[i];\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\t\tword32 y = word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;\n\t\tTe[i] = word64(y | f3(x))<<32 | y;\n#else\n\t\tword32 y = f3(x) | word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;\n\t\tfor (int j=0; j<4; j++)\n\t\t{\n\t\t\tTe[i+j*256] = y;\n\t\t\ty = rotrFixed(y, 8);\n\t\t}\n#endif\n\t}\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tTe[256] = Te[257] = 0;\n#endif\n\ts_TeFilled = true;\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"rijndael.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile bool s_TeFilled = false, s_TdFilled = false;",
            "unsigned int i;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"rijndael.h\"\n#include \"pch.h\"\n\nstatic volatile bool s_TeFilled = false, s_TdFilled = false;\nunsigned int i;\n\nRijndael {\n  Base {\n    void Rijndael::Base::FillEncTable()\n    {\n    \tfor (int i=0; i<256; i++)\n    \t{\n    \t\tbyte x = Se[i];\n    #ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n    \t\tword32 y = word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;\n    \t\tTe[i] = word64(y | f3(x))<<32 | y;\n    #else\n    \t\tword32 y = f3(x) | word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;\n    \t\tfor (int j=0; j<4; j++)\n    \t\t{\n    \t\t\tTe[i+j*256] = y;\n    \t\t\ty = rotrFixed(y, 8);\n    \t\t}\n    #endif\n    \t}\n    #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n    \tTe[256] = Te[257] = 0;\n    #endif\n    \ts_TeFilled = true;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsForwardTransformation",
          "args": [],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "IsForwardTransformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/arc4.h",
          "lines": "25-25",
          "snippet": "bool IsForwardTransformation() const {return true;}",
          "includes": [
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n\nbool IsForwardTransformation() const {return true;}"
        }
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "temp",
            "0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "Se[GETBYTE(temp, 1)]"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "temp",
            "1"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "Se[GETBYTE(temp, 2)]"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "temp",
            "2"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "Se[GETBYTE(temp, 3)]"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "temp",
            "3"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_key.end",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "temp",
            "3"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "Se[GETBYTE(temp, 0)]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "temp",
            "0"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "Se[GETBYTE(temp, 1)]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "temp",
            "1"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "Se[GETBYTE(temp, 2)]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "temp",
            "2"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserKey",
          "args": [
            "BIG_ENDIAN_ORDER",
            "rk",
            "keylen/4",
            "userKey",
            "keylen"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "946-953",
          "snippet": "inline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n{\n\tconst size_t U = sizeof(T);\n\tassert(inlen <= outlen*U);\n\tmemcpy_s(out, outlen*U, in, inlen);\n\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n{\n\tconst size_t U = sizeof(T);\n\tassert(inlen <= outlen*U);\n\tmemcpy_s(out, outlen*U, in, inlen);\n\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_aesimc_si128",
          "args": [
            "*(__m128i *)(rk+i)"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_aesimc_si128",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "63-69",
          "snippet": "__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_aesimc_si128 (__m128i a)\n{\n\t__m128i r;\n\tasm (\"aesimc %1, %0\" : \"=x\"(r) : \"xm\"(a));\n  \treturn r;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\n__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_aesimc_si128 (__m128i a)\n{\n\t__m128i r;\n\tasm (\"aesimc %1, %0\" : \"=x\"(r) : \"xm\"(a));\n  \treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::swap",
          "args": [
            "*(__m128i *)(rk)",
            "*(__m128i *)(rk+4*m_rounds)"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "453-456",
          "snippet": "inline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\ninline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_insert_epi32",
          "args": [
            "temp",
            "rk[7]",
            "3"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_insert_epi32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "40-45",
          "snippet": "__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_insert_epi32 (__m128i a, int b, const int i)\n{\n\tasm (\"pinsrd %2, %1, %0\" : \"+x\"(a) : \"rm\"(b), \"i\"(i));\n  \treturn a;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\n__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_insert_epi32 (__m128i a, int b, const int i)\n{\n\tasm (\"pinsrd %2, %1, %0\" : \"+x\"(a) : \"rm\"(b), \"i\"(i));\n  \treturn a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_extract_epi32",
          "args": [
            "_mm_aeskeygenassist_si128(temp, 0)",
            "2"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_extract_epi32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "33-39",
          "snippet": "__inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_extract_epi32 (__m128i a, const int i)\n{\n\tint r;\n\tasm (\"pextrd %2, %1, %0\" : \"=rm\"(r) : \"x\"(a), \"i\"(i));\n  \treturn r;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\n__inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_extract_epi32 (__m128i a, const int i)\n{\n\tint r;\n\tasm (\"pextrd %2, %1, %0\" : \"=rm\"(r) : \"x\"(a), \"i\"(i));\n  \treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mm_aeskeygenassist_si128",
          "args": [
            "temp",
            "0"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "_mm_aeskeygenassist_si128",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "56-62",
          "snippet": "__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_aeskeygenassist_si128 (__m128i a, const int i)\n{\n\t__m128i r;\n\tasm (\"aeskeygenassist %2, %1, %0\" : \"=x\"(r) : \"xm\"(a), \"i\"(i));\n  \treturn r;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\n__inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_aeskeygenassist_si128 (__m128i a, const int i)\n{\n\t__m128i r;\n\tasm (\"aeskeygenassist %2, %1, %0\" : \"=x\"(r) : \"xm\"(a), \"i\"(i));\n  \treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rk",
            "userKey",
            "keylen"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mm_loadu_si128",
          "args": [
            "(__m128i *)(userKey+keylen-16)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_key.New",
          "args": [
            "4*(m_rounds+1)"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertValidKeyLength",
          "args": [
            "keylen"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"rijndael.h\"\n#include \"pch.h\"\n\n#define TL_M\t\t\tTL_F\n\nstatic volatile bool s_TeFilled = false, s_TdFilled = false;\nconst word32 *rk = m_key;\nunsigned int i;\n\nRijndael {\n  Base {\n    void Rijndael::Base::UncheckedSetKey(const byte *userKey, unsigned int keylen, const NameValuePairs &)\n    {\n    \tAssertValidKeyLength(keylen);\n    \n    \tm_rounds = keylen/4 + 6;\n    \tm_key.New(4*(m_rounds+1));\n    \n    \tword32 *rk = m_key;\n    \n    #if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE && (!defined(_MSC_VER) || _MSC_VER >= 1600 || CRYPTOPP_BOOL_X86)\n    \t// MSVC 2008 SP1 generates bad code for _mm_extract_epi32() when compiling for X64\n    \tif (HasAESNI())\n    \t{\n    \t\tstatic const word32 rcLE[] = {\n    \t\t\t0x01, 0x02, 0x04, 0x08,\n    \t\t\t0x10, 0x20, 0x40, 0x80,\n    \t\t\t0x1B, 0x36, /* for 128-bit blocks, Rijndael never uses more than 10 rcon values */\n    \t\t};\n    \t\tconst word32 *rc = rcLE;\n    \n    \t\t__m128i temp = _mm_loadu_si128((__m128i *)(userKey+keylen-16));\n    \t\tmemcpy(rk, userKey, keylen);\n    \n    \t\twhile (true)\n    \t\t{\n    \t\t\trk[keylen/4] = rk[0] ^ _mm_extract_epi32(_mm_aeskeygenassist_si128(temp, 0), 3) ^ *(rc++);\n    \t\t\trk[keylen/4+1] = rk[1] ^ rk[keylen/4];\n    \t\t\trk[keylen/4+2] = rk[2] ^ rk[keylen/4+1];\n    \t\t\trk[keylen/4+3] = rk[3] ^ rk[keylen/4+2];\n    \n    \t\t\tif (rk + keylen/4 + 4 == m_key.end())\n    \t\t\t\tbreak;\n    \n    \t\t\tif (keylen == 24)\n    \t\t\t{\n    \t\t\t\trk[10] = rk[ 4] ^ rk[ 9];\n    \t\t\t\trk[11] = rk[ 5] ^ rk[10];\n    \t\t\t\ttemp = _mm_insert_epi32(temp, rk[11], 3);\n    \t\t\t}\n    \t\t\telse if (keylen == 32)\n    \t\t\t{\n    \t\t\t\ttemp = _mm_insert_epi32(temp, rk[11], 3);\n        \t\t\trk[12] = rk[ 4] ^ _mm_extract_epi32(_mm_aeskeygenassist_si128(temp, 0), 2);\n        \t\t\trk[13] = rk[ 5] ^ rk[12];\n        \t\t\trk[14] = rk[ 6] ^ rk[13];\n        \t\t\trk[15] = rk[ 7] ^ rk[14];\n    \t\t\t\ttemp = _mm_insert_epi32(temp, rk[15], 3);\n    \t\t\t}\n    \t\t\telse\n    \t\t\t\ttemp = _mm_insert_epi32(temp, rk[7], 3);\n    \n    \t\t\trk += keylen/4;\n    \t\t}\n    \n    \t\tif (!IsForwardTransformation())\n    \t\t{\n    \t\t\trk = m_key;\n    \t\t\tunsigned int i, j;\n    \n    \t\t\tstd::swap(*(__m128i *)(rk), *(__m128i *)(rk+4*m_rounds));\n    \n    \t\t\tfor (i = 4, j = 4*m_rounds-4; i < j; i += 4, j -= 4)\n    \t\t\t{\n    \t\t\t\ttemp = _mm_aesimc_si128(*(__m128i *)(rk+i));\n    \t\t\t\t*(__m128i *)(rk+i) = _mm_aesimc_si128(*(__m128i *)(rk+j));\n    \t\t\t\t*(__m128i *)(rk+j) = temp;\n    \t\t\t}\n    \n    \t\t\t*(__m128i *)(rk+i) = _mm_aesimc_si128(*(__m128i *)(rk+i));\n    \t\t}\n    \n    \t\treturn;\n    \t}\n    #endif\n    \n    \tGetUserKey(BIG_ENDIAN_ORDER, rk, keylen/4, userKey, keylen);\n    \tconst word32 *rc = rcon;\n    \tword32 temp;\n    \n    \twhile (true)\n    \t{\n    \t\ttemp  = rk[keylen/4-1];\n    \t\tword32 x = (word32(Se[GETBYTE(temp, 2)]) << 24) ^ (word32(Se[GETBYTE(temp, 1)]) << 16) ^ (word32(Se[GETBYTE(temp, 0)]) << 8) ^ Se[GETBYTE(temp, 3)];\n    \t\trk[keylen/4] = rk[0] ^ x ^ *(rc++);\n    \t\trk[keylen/4+1] = rk[1] ^ rk[keylen/4];\n    \t\trk[keylen/4+2] = rk[2] ^ rk[keylen/4+1];\n    \t\trk[keylen/4+3] = rk[3] ^ rk[keylen/4+2];\n    \n    \t\tif (rk + keylen/4 + 4 == m_key.end())\n    \t\t\tbreak;\n    \n    \t\tif (keylen == 24)\n    \t\t{\n    \t\t\trk[10] = rk[ 4] ^ rk[ 9];\n    \t\t\trk[11] = rk[ 5] ^ rk[10];\n    \t\t}\n    \t\telse if (keylen == 32)\n    \t\t{\n        \t\ttemp = rk[11];\n        \t\trk[12] = rk[ 4] ^ (word32(Se[GETBYTE(temp, 3)]) << 24) ^ (word32(Se[GETBYTE(temp, 2)]) << 16) ^ (word32(Se[GETBYTE(temp, 1)]) << 8) ^ Se[GETBYTE(temp, 0)];\n        \t\trk[13] = rk[ 5] ^ rk[12];\n        \t\trk[14] = rk[ 6] ^ rk[13];\n        \t\trk[15] = rk[ 7] ^ rk[14];\n    \t\t}\n    \t\trk += keylen/4;\n    \t}\n    \n    \trk = m_key;\n    \n    \tif (IsForwardTransformation())\n    \t{\n    \t\tif (!s_TeFilled)\n    \t\t\tFillEncTable();\n    \n    \t\tConditionalByteReverse(BIG_ENDIAN_ORDER, rk, rk, 16);\n    \t\tConditionalByteReverse(BIG_ENDIAN_ORDER, rk + m_rounds*4, rk + m_rounds*4, 16);\n    \t}\n    \telse\n    \t{\n    \t\tif (!s_TdFilled)\n    \t\t\tFillDecTable();\n    \n    \t\tunsigned int i, j;\n    \n    #define InverseMixColumn(x)\t\tTL_M(Td, 0, Se[GETBYTE(x, 3)]) ^ TL_M(Td, 1, Se[GETBYTE(x, 2)]) ^ TL_M(Td, 2, Se[GETBYTE(x, 1)]) ^ TL_M(Td, 3, Se[GETBYTE(x, 0)])\n    \n    \t\tfor (i = 4, j = 4*m_rounds-4; i < j; i += 4, j -= 4)\n    \t\t{\n    \t\t\ttemp = InverseMixColumn(rk[i    ]); rk[i    ] = InverseMixColumn(rk[j    ]); rk[j    ] = temp;\n    \t\t\ttemp = InverseMixColumn(rk[i + 1]); rk[i + 1] = InverseMixColumn(rk[j + 1]); rk[j + 1] = temp;\n    \t\t\ttemp = InverseMixColumn(rk[i + 2]); rk[i + 2] = InverseMixColumn(rk[j + 2]); rk[j + 2] = temp;\n    \t\t\ttemp = InverseMixColumn(rk[i + 3]); rk[i + 3] = InverseMixColumn(rk[j + 3]); rk[j + 3] = temp;\n    \t\t}\n    \n    \t\trk[i+0] = InverseMixColumn(rk[i+0]);\n    \t\trk[i+1] = InverseMixColumn(rk[i+1]);\n    \t\trk[i+2] = InverseMixColumn(rk[i+2]);\n    \t\trk[i+3] = InverseMixColumn(rk[i+3]);\n    \n    \t\ttemp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[0]); rk[0] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+0]); rk[4*m_rounds+0] = temp;\n    \t\ttemp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[1]); rk[1] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+1]); rk[4*m_rounds+1] = temp;\n    \t\ttemp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[2]); rk[2] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+2]); rk[4*m_rounds+2] = temp;\n    \t\ttemp = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[3]); rk[3] = ConditionalByteReverse(BIG_ENDIAN_ORDER, rk[4*m_rounds+3]); rk[4*m_rounds+3] = temp;\n    \t}\n    \n    #if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE\n    \tif (HasAESNI())\n    \t\tConditionalByteReverse(BIG_ENDIAN_ORDER, rk+4, rk+4, (m_rounds-1)*16);\n    #endif\n    }\n  }\n}"
  },
  {
    "function_name": "FillDecTable",
    "container": "Rijndael::Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rijndael.cpp",
    "lines": "178-196",
    "snippet": "void Rijndael::Base::FillDecTable()\n{\n\tfor (int i=0; i<256; i++)\n\t{\n\t\tbyte x = Sd[i];\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\t\tword32 y = word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;\n\t\tTd[i] = word64(y | fb(x))<<32 | y | x;\n#else\n\t\tword32 y = fb(x) | word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;;\n\t\tfor (int j=0; j<4; j++)\n\t\t{\n\t\t\tTd[i+j*256] = y;\n\t\t\ty = rotrFixed(y, 8);\n\t\t}\n#endif\n\t}\n\ts_TdFilled = true;\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"rijndael.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int i;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotrFixed",
          "args": [
            "y",
            "8"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "rotrFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "586-590",
          "snippet": "inline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "fe(x)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fe",
          "args": [
            "x"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "SafeLeftShift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1263-1266",
          "snippet": "inline T SafeLeftShift(T value)\n{\n\treturn SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift(value, bits);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T SafeLeftShift(T value)\n{\n\treturn SafeShifter<(bits>=(8*sizeof(T)))>::LeftShift(value, bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "f9(x)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f9",
          "args": [
            "x"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "fd(x)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd",
          "args": [
            "x"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb",
          "args": [
            "x"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "y | fb(x)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fb",
          "args": [
            "x"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "fe(x)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "f9(x)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f9",
          "args": [
            "x"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "fd(x)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd",
          "args": [
            "x"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"rijndael.h\"\n#include \"pch.h\"\n\nunsigned int i;\n\nRijndael {\n  Base {\n    void Rijndael::Base::FillDecTable()\n    {\n    \tfor (int i=0; i<256; i++)\n    \t{\n    \t\tbyte x = Sd[i];\n    #ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n    \t\tword32 y = word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;\n    \t\tTd[i] = word64(y | fb(x))<<32 | y | x;\n    #else\n    \t\tword32 y = fb(x) | word32(fd(x))<<8 | word32(f9(x))<<16 | word32(fe(x))<<24;;\n    \t\tfor (int j=0; j<4; j++)\n    \t\t{\n    \t\t\tTd[i+j*256] = y;\n    \t\t\ty = rotrFixed(y, 8);\n    \t\t}\n    #endif\n    \t}\n    \ts_TdFilled = true;\n    }\n  }\n}"
  },
  {
    "function_name": "FillEncTable",
    "container": "Rijndael::Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rijndael.cpp",
    "lines": "155-176",
    "snippet": "void Rijndael::Base::FillEncTable()\n{\n\tfor (int i=0; i<256; i++)\n\t{\n\t\tbyte x = Se[i];\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\t\tword32 y = word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;\n\t\tTe[i] = word64(y | f3(x))<<32 | y;\n#else\n\t\tword32 y = f3(x) | word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;\n\t\tfor (int j=0; j<4; j++)\n\t\t{\n\t\t\tTe[i+j*256] = y;\n\t\t\ty = rotrFixed(y, 8);\n\t\t}\n#endif\n\t}\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tTe[256] = Te[257] = 0;\n#endif\n\ts_TeFilled = true;\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"rijndael.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile bool s_TeFilled = false, s_TdFilled = false;",
      "unsigned int i;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotrFixed",
          "args": [
            "y",
            "8"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "rotrFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "586-590",
          "snippet": "inline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "f2(x)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2",
          "args": [
            "x"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "IsPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "333-336",
          "snippet": "inline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsPowerOf2(const T &n)\n{\n\treturn n > 0 && (n & (n-1)) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "x"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "x"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f3",
          "args": [
            "x"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "y | f3(x)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f3",
          "args": [
            "x"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "f2(x)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "x"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "x"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"rijndael.h\"\n#include \"pch.h\"\n\nstatic volatile bool s_TeFilled = false, s_TdFilled = false;\nunsigned int i;\n\nRijndael {\n  Base {\n    void Rijndael::Base::FillEncTable()\n    {\n    \tfor (int i=0; i<256; i++)\n    \t{\n    \t\tbyte x = Se[i];\n    #ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n    \t\tword32 y = word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;\n    \t\tTe[i] = word64(y | f3(x))<<32 | y;\n    #else\n    \t\tword32 y = f3(x) | word32(x)<<8 | word32(x)<<16 | word32(f2(x))<<24;\n    \t\tfor (int j=0; j<4; j++)\n    \t\t{\n    \t\t\tTe[i+j*256] = y;\n    \t\t\ty = rotrFixed(y, 8);\n    \t\t}\n    #endif\n    \t}\n    #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n    \tTe[256] = Te[257] = 0;\n    #endif\n    \ts_TeFilled = true;\n    }\n  }\n}"
  }
]