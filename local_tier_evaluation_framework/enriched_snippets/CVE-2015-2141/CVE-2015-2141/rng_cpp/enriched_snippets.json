[
  {
    "function_name": "MaurerRandomnessTest::GetTestValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rng.cpp",
    "lines": "144-153",
    "snippet": "double MaurerRandomnessTest::GetTestValue() const\n{\n\tif (BytesNeeded() > 0)\n\t\tthrow Exception(Exception::OTHER_ERROR, \"MaurerRandomnessTest: \" + IntToString(BytesNeeded()) + \" more bytes of input needed\");\n\n\tdouble fTu = (sum/(n-Q))/log(2.0);\t// this is the test value defined by Maurer\n\n\tdouble value = fTu * 0.1392;\t\t// arbitrarily normalize it to\n\treturn value > 1.0 ? 1.0 : value;\t// a number between 0 and 1\n}",
    "includes": [
      "#include <math.h>",
      "#include <time.h>",
      "#include \"fips140.h\"",
      "#include \"rng.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "2.0"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"MaurerRandomnessTest: \" + IntToString(BytesNeeded()) + \" more bytes of input needed\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "BytesNeeded()"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BytesNeeded",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "BytesNeeded",
          "container": "MaurerRandomnessTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rng.h",
          "lines": "62-62",
          "snippet": "unsigned int BytesNeeded() const {return n >= (Q+K) ? 0 : Q+K-n;}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"cryptlib.h\"\n\nMaurerRandomnessTest {\n  unsigned int BytesNeeded() const {return n >= (Q+K) ? 0 : Q+K-n;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <math.h>\n#include <time.h>\n#include \"fips140.h\"\n#include \"rng.h\"\n#include \"pch.h\"\n\ndouble MaurerRandomnessTest::GetTestValue() const\n{\n\tif (BytesNeeded() > 0)\n\t\tthrow Exception(Exception::OTHER_ERROR, \"MaurerRandomnessTest: \" + IntToString(BytesNeeded()) + \" more bytes of input needed\");\n\n\tdouble fTu = (sum/(n-Q))/log(2.0);\t// this is the test value defined by Maurer\n\n\tdouble value = fTu * 0.1392;\t\t// arbitrarily normalize it to\n\treturn value > 1.0 ? 1.0 : value;\t// a number between 0 and 1\n}"
  },
  {
    "function_name": "MaurerRandomnessTest::Put2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rng.cpp",
    "lines": "131-142",
    "snippet": "size_t MaurerRandomnessTest::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\twhile (length--)\n\t{\n\t\tbyte inByte = *inString++;\n\t\tif (n >= Q)\n\t\t\tsum += log(double(n - tab[inByte]));\n\t\ttab[inByte] = n;\n\t\tn++;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <math.h>",
      "#include <time.h>",
      "#include \"fips140.h\"",
      "#include \"rng.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "double(n - tab[inByte])"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "double",
          "args": [
            "n - tab[inByte]"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <math.h>\n#include <time.h>\n#include \"fips140.h\"\n#include \"rng.h\"\n#include \"pch.h\"\n\nsize_t MaurerRandomnessTest::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\twhile (length--)\n\t{\n\t\tbyte inByte = *inString++;\n\t\tif (n >= Q)\n\t\t\tsum += log(double(n - tab[inByte]));\n\t\ttab[inByte] = n;\n\t\tn++;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "MaurerRandomnessTest::MaurerRandomnessTest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rng.cpp",
    "lines": "124-129",
    "snippet": "MaurerRandomnessTest::MaurerRandomnessTest()\n\t: sum(0.0), n(0)\n{\n\tfor (unsigned i=0; i<V; i++)\n\t\ttab[i] = 0;\n}",
    "includes": [
      "#include <math.h>",
      "#include <time.h>",
      "#include \"fips140.h\"",
      "#include \"rng.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <math.h>\n#include <time.h>\n#include \"fips140.h\"\n#include \"rng.h\"\n#include \"pch.h\"\n\nMaurerRandomnessTest::MaurerRandomnessTest()\n\t: sum(0.0), n(0)\n{\n\tfor (unsigned i=0; i<V; i++)\n\t\ttab[i] = 0;\n}"
  },
  {
    "function_name": "X917RNG::GenerateIntoBufferedTransformation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rng.cpp",
    "lines": "83-120",
    "snippet": "void X917RNG::GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword size)\n{\n\twhile (size > 0)\n\t{\n\t\t// calculate new enciphered timestamp\n\t\tif (m_deterministicTimeVector.size())\n\t\t{\n\t\t\tcipher->ProcessBlock(m_deterministicTimeVector, dtbuf);\n\t\t\tIncrementCounterByOne(m_deterministicTimeVector, S);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclock_t c = clock();\n\t\t\txorbuf(dtbuf, (byte *)&c, UnsignedMin(sizeof(c), S));\n\t\t\ttime_t t = time(NULL);\n\t\t\txorbuf(dtbuf+S-UnsignedMin(sizeof(t), S), (byte *)&t, UnsignedMin(sizeof(t), S));\n\t\t\tcipher->ProcessBlock(dtbuf);\n\t\t}\n\n\t\t// combine enciphered timestamp with seed\n\t\txorbuf(randseed, dtbuf, S);\n\n\t\t// generate a new block of random bytes\n\t\tcipher->ProcessBlock(randseed);\n\t\tif (memcmp(m_lastBlock, randseed, S) == 0)\n\t\t\tthrow SelfTestFailure(\"X917RNG: Continuous random number generator test failed.\");\n\n\t\t// output random bytes\n\t\tsize_t len = UnsignedMin(S, size);\n\t\ttarget.ChannelPut(channel, randseed, len);\n\t\tsize -= len;\n\n\t\t// compute new seed vector\n\t\tmemcpy(m_lastBlock, randseed, S);\n\t\txorbuf(randseed, dtbuf, S);\n\t\tcipher->ProcessBlock(randseed);\n\t}\n}",
    "includes": [
      "#include <math.h>",
      "#include <time.h>",
      "#include \"fips140.h\"",
      "#include \"rng.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cipher->ProcessBlock",
          "args": [
            "randseed"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "randseed",
            "dtbuf",
            "S"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_lastBlock",
            "randseed",
            "S"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target.ChannelPut",
          "args": [
            "channel",
            "randseed",
            "len"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ChannelPut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "975-976",
          "snippet": "size_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)\n\t\t\t{return ChannelPut2(channel, inString, length, 0, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)\n\t\t\t{return ChannelPut2(channel, inString, length, 0, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "S",
            "size"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SelfTestFailure",
          "args": [
            "\"X917RNG: Continuous random number generator test failed.\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "m_lastBlock",
            "randseed",
            "S"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher->ProcessBlock",
          "args": [
            "randseed"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher->ProcessBlock",
          "args": [
            "dtbuf"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clock",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IncrementCounterByOne",
          "args": [
            "m_deterministicTimeVector",
            "S"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "IncrementCounterByOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "445-449",
          "snippet": "inline void IncrementCounterByOne(byte *inout, unsigned int s)\n{\n\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = !++inout[i];\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void IncrementCounterByOne(byte *inout, unsigned int s)\n{\n\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = !++inout[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher->ProcessBlock",
          "args": [
            "m_deterministicTimeVector",
            "dtbuf"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_deterministicTimeVector.size",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <math.h>\n#include <time.h>\n#include \"fips140.h\"\n#include \"rng.h\"\n#include \"pch.h\"\n\nvoid X917RNG::GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword size)\n{\n\twhile (size > 0)\n\t{\n\t\t// calculate new enciphered timestamp\n\t\tif (m_deterministicTimeVector.size())\n\t\t{\n\t\t\tcipher->ProcessBlock(m_deterministicTimeVector, dtbuf);\n\t\t\tIncrementCounterByOne(m_deterministicTimeVector, S);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclock_t c = clock();\n\t\t\txorbuf(dtbuf, (byte *)&c, UnsignedMin(sizeof(c), S));\n\t\t\ttime_t t = time(NULL);\n\t\t\txorbuf(dtbuf+S-UnsignedMin(sizeof(t), S), (byte *)&t, UnsignedMin(sizeof(t), S));\n\t\t\tcipher->ProcessBlock(dtbuf);\n\t\t}\n\n\t\t// combine enciphered timestamp with seed\n\t\txorbuf(randseed, dtbuf, S);\n\n\t\t// generate a new block of random bytes\n\t\tcipher->ProcessBlock(randseed);\n\t\tif (memcmp(m_lastBlock, randseed, S) == 0)\n\t\t\tthrow SelfTestFailure(\"X917RNG: Continuous random number generator test failed.\");\n\n\t\t// output random bytes\n\t\tsize_t len = UnsignedMin(S, size);\n\t\ttarget.ChannelPut(channel, randseed, len);\n\t\tsize -= len;\n\n\t\t// compute new seed vector\n\t\tmemcpy(m_lastBlock, randseed, S);\n\t\txorbuf(randseed, dtbuf, S);\n\t\tcipher->ProcessBlock(randseed);\n\t}\n}"
  },
  {
    "function_name": "X917RNG::X917RNG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rng.cpp",
    "lines": "61-81",
    "snippet": "X917RNG::X917RNG(BlockTransformation *c, const byte *seed, const byte *deterministicTimeVector)\n\t: cipher(c),\n\t  S(cipher->BlockSize()),\n\t  dtbuf(S),\n\t  randseed(seed, S),\n\t  m_lastBlock(S),\n\t  m_deterministicTimeVector(deterministicTimeVector, deterministicTimeVector ? S : 0)\n{\n\tif (!deterministicTimeVector)\n\t{\n\t\ttime_t tstamp1 = time(0);\n\t\txorbuf(dtbuf, (byte *)&tstamp1, UnsignedMin(sizeof(tstamp1), S));\n\t\tcipher->ProcessBlock(dtbuf);\n\t\tclock_t tstamp2 = clock();\n\t\txorbuf(dtbuf, (byte *)&tstamp2, UnsignedMin(sizeof(tstamp2), S));\n\t\tcipher->ProcessBlock(dtbuf);\n\t}\n\n\t// for FIPS 140-2\n\tGenerateBlock(m_lastBlock, S);\n}",
    "includes": [
      "#include <math.h>",
      "#include <time.h>",
      "#include \"fips140.h\"",
      "#include \"rng.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenerateBlock",
          "args": [
            "m_lastBlock",
            "S"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "LC_RNG::GenerateBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rng.cpp",
          "lines": "39-55",
          "snippet": "void LC_RNG::GenerateBlock(byte *output, size_t size)\n{\n\twhile (size--)\n\t{\n\t\tword32 hi = seed/q;\n\t\tword32 lo = seed%q;\n\n\t\tlong test = a*lo - r*hi;\n\n\t\tif (test > 0)\n\t\t\tseed = test;\n\t\telse\n\t\t\tseed = test+ m;\n\n\t\t*output++ = (GETBYTE(seed, 0) ^ GETBYTE(seed, 1) ^ GETBYTE(seed, 2) ^ GETBYTE(seed, 3));\n\t}\n}",
          "includes": [
            "#include <math.h>",
            "#include <time.h>",
            "#include \"fips140.h\"",
            "#include \"rng.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <math.h>\n#include <time.h>\n#include \"fips140.h\"\n#include \"rng.h\"\n#include \"pch.h\"\n\nvoid LC_RNG::GenerateBlock(byte *output, size_t size)\n{\n\twhile (size--)\n\t{\n\t\tword32 hi = seed/q;\n\t\tword32 lo = seed%q;\n\n\t\tlong test = a*lo - r*hi;\n\n\t\tif (test > 0)\n\t\t\tseed = test;\n\t\telse\n\t\t\tseed = test+ m;\n\n\t\t*output++ = (GETBYTE(seed, 0) ^ GETBYTE(seed, 1) ^ GETBYTE(seed, 2) ^ GETBYTE(seed, 3));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher->ProcessBlock",
          "args": [
            "dtbuf"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "dtbuf",
            "(byte *)&tstamp2",
            "UnsignedMin(sizeof(tstamp2), S)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "sizeof(tstamp2)",
            "S"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher->ProcessBlock",
          "args": [
            "dtbuf"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher->BlockSize",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      }
    ],
    "contextual_snippet": "#include <math.h>\n#include <time.h>\n#include \"fips140.h\"\n#include \"rng.h\"\n#include \"pch.h\"\n\nX917RNG::X917RNG(BlockTransformation *c, const byte *seed, const byte *deterministicTimeVector)\n\t: cipher(c),\n\t  S(cipher->BlockSize()),\n\t  dtbuf(S),\n\t  randseed(seed, S),\n\t  m_lastBlock(S),\n\t  m_deterministicTimeVector(deterministicTimeVector, deterministicTimeVector ? S : 0)\n{\n\tif (!deterministicTimeVector)\n\t{\n\t\ttime_t tstamp1 = time(0);\n\t\txorbuf(dtbuf, (byte *)&tstamp1, UnsignedMin(sizeof(tstamp1), S));\n\t\tcipher->ProcessBlock(dtbuf);\n\t\tclock_t tstamp2 = clock();\n\t\txorbuf(dtbuf, (byte *)&tstamp2, UnsignedMin(sizeof(tstamp2), S));\n\t\tcipher->ProcessBlock(dtbuf);\n\t}\n\n\t// for FIPS 140-2\n\tGenerateBlock(m_lastBlock, S);\n}"
  },
  {
    "function_name": "LC_RNG::GenerateBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rng.cpp",
    "lines": "39-55",
    "snippet": "void LC_RNG::GenerateBlock(byte *output, size_t size)\n{\n\twhile (size--)\n\t{\n\t\tword32 hi = seed/q;\n\t\tword32 lo = seed%q;\n\n\t\tlong test = a*lo - r*hi;\n\n\t\tif (test > 0)\n\t\t\tseed = test;\n\t\telse\n\t\t\tseed = test+ m;\n\n\t\t*output++ = (GETBYTE(seed, 0) ^ GETBYTE(seed, 1) ^ GETBYTE(seed, 2) ^ GETBYTE(seed, 3));\n\t}\n}",
    "includes": [
      "#include <math.h>",
      "#include <time.h>",
      "#include \"fips140.h\"",
      "#include \"rng.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "seed",
            "3"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "seed",
            "2"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "seed",
            "1"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "seed",
            "0"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <math.h>\n#include <time.h>\n#include \"fips140.h\"\n#include \"rng.h\"\n#include \"pch.h\"\n\nvoid LC_RNG::GenerateBlock(byte *output, size_t size)\n{\n\twhile (size--)\n\t{\n\t\tword32 hi = seed/q;\n\t\tword32 lo = seed%q;\n\n\t\tlong test = a*lo - r*hi;\n\n\t\tif (test > 0)\n\t\t\tseed = test;\n\t\telse\n\t\t\tseed = test+ m;\n\n\t\t*output++ = (GETBYTE(seed, 0) ^ GETBYTE(seed, 1) ^ GETBYTE(seed, 2) ^ GETBYTE(seed, 3));\n\t}\n}"
  }
]