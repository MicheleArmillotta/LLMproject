[
  {
    "function_name": "Equal",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "162-174",
    "snippet": "bool EC2N::Equal(const Point &P, const Point &Q) const\n{\n\tif (P.identity && Q.identity)\n\t\treturn true;\n\n\tif (P.identity && !Q.identity)\n\t\treturn false;\n\n\tif (!P.identity && Q.identity)\n\t\treturn false;\n\n\treturn (m_field->Equal(P.x,Q.x) && m_field->Equal(P.y,Q.y));\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_field->Equal",
          "args": [
            "P.y",
            "Q.y"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "Equal",
          "container": "EC2N",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
          "lines": "162-174",
          "snippet": "bool EC2N::Equal(const Point &P, const Point &Q) const\n{\n\tif (P.identity && Q.identity)\n\t\treturn true;\n\n\tif (P.identity && !Q.identity)\n\t\treturn false;\n\n\tif (!P.identity && Q.identity)\n\t\treturn false;\n\n\treturn (m_field->Equal(P.x,Q.x) && m_field->Equal(P.y,Q.y));\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  bool EC2N::Equal(const Point &P, const Point &Q) const\n  {\n  \tif (P.identity && Q.identity)\n  \t\treturn true;\n  \n  \tif (P.identity && !Q.identity)\n  \t\treturn false;\n  \n  \tif (!P.identity && Q.identity)\n  \t\treturn false;\n  \n  \treturn (m_field->Equal(P.x,Q.x) && m_field->Equal(P.y,Q.y));\n  }\n}"
  },
  {
    "function_name": "VerifyPoint",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "153-160",
    "snippet": "bool EC2N::VerifyPoint(const Point &P) const\n{\n\tconst FieldElement &x = P.x, &y = P.y;\n\treturn P.identity || \n\t\t(x.CoefficientCount() <= m_field->MaxElementBitLength()\n\t\t&& y.CoefficientCount() <= m_field->MaxElementBitLength()\n\t\t&& !(((x+m_a)*x*x+m_b-(x+y)*y)%m_field->GetModulus()));\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_field->GetModulus",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->MaxElementBitLength",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y.CoefficientCount",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "CoefficientCount",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "211-211",
          "snippet": "unsigned int CoefficientCount() const {return B::CoefficientCount(ms_fixedRing);}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  unsigned int CoefficientCount() const {return B::CoefficientCount(ms_fixedRing);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->MaxElementBitLength",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  bool EC2N::VerifyPoint(const Point &P) const\n  {\n  \tconst FieldElement &x = P.x, &y = P.y;\n  \treturn P.identity || \n  \t\t(x.CoefficientCount() <= m_field->MaxElementBitLength()\n  \t\t&& y.CoefficientCount() <= m_field->MaxElementBitLength()\n  \t\t&& !(((x+m_a)*x*x+m_b-(x+y)*y)%m_field->GetModulus()));\n  }\n}"
  },
  {
    "function_name": "ValidateParameters",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "141-151",
    "snippet": "bool EC2N::ValidateParameters(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = !!m_b;\n\tpass = pass && m_a.CoefficientCount() <= m_field->MaxElementBitLength();\n\tpass = pass && m_b.CoefficientCount() <= m_field->MaxElementBitLength();\n\n\tif (level >= 1)\n\t\tpass = pass && m_field->GetModulus().IsIrreducible();\n\t\t\n\treturn pass;\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_field->GetModulus",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->GetModulus",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->MaxElementBitLength",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_b.CoefficientCount",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "CoefficientCount",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "211-211",
          "snippet": "unsigned int CoefficientCount() const {return B::CoefficientCount(ms_fixedRing);}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  unsigned int CoefficientCount() const {return B::CoefficientCount(ms_fixedRing);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->MaxElementBitLength",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  bool EC2N::ValidateParameters(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = !!m_b;\n  \tpass = pass && m_a.CoefficientCount() <= m_field->MaxElementBitLength();\n  \tpass = pass && m_b.CoefficientCount() <= m_field->MaxElementBitLength();\n  \n  \tif (level >= 1)\n  \t\tpass = pass && m_field->GetModulus().IsIrreducible();\n  \t\t\n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "DEREncodePoint",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "134-139",
    "snippet": "void EC2N::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n{\n\tSecByteBlock str(EncodedPointSize(compressed));\n\tEncodePoint(str, P, compressed);\n\tDEREncodeOctetString(bt, str);\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DEREncodeOctetString",
          "args": [
            "bt",
            "str"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncodeOctetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "111-114",
          "snippet": "size_t DEREncodeOctetString(BufferedTransformation &bt, const SecByteBlock &str)\n{\n\treturn DEREncodeOctetString(bt, str.begin(), str.size());\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nsize_t DEREncodeOctetString(BufferedTransformation &bt, const SecByteBlock &str)\n{\n\treturn DEREncodeOctetString(bt, str.begin(), str.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodePoint",
          "args": [
            "str",
            "P",
            "compressed"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncodePoint",
          "container": "EC2N",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
          "lines": "134-139",
          "snippet": "void EC2N::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n{\n\tSecByteBlock str(EncodedPointSize(compressed));\n\tEncodePoint(str, P, compressed);\n\tDEREncodeOctetString(bt, str);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  void EC2N::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n  {\n  \tSecByteBlock str(EncodedPointSize(compressed));\n  \tEncodePoint(str, P, compressed);\n  \tDEREncodeOctetString(bt, str);\n  }\n}"
  },
  {
    "function_name": "BERDecodePoint",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "124-132",
    "snippet": "EC2N::Point EC2N::BERDecodePoint(BufferedTransformation &bt) const\n{\n\tSecByteBlock str;\n\tBERDecodeOctetString(bt, str);\n\tPoint P;\n\tif (!DecodePoint(P, str, str.size()))\n\t\tBERDecodeError();\n\treturn P;\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BERDecodeError",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.h",
          "lines": "49-49",
          "snippet": "inline void BERDecodeError() {throw BERDecodeErr();}",
          "includes": [
            "#include <vector>",
            "#include \"queue.h\"",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"queue.h\"\n#include \"filters.h\"\n\ninline void BERDecodeError() {throw BERDecodeErr();}"
        }
      },
      {
        "call_info": {
          "callee": "DecodePoint",
          "args": [
            "P",
            "str",
            "str.size()"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "DecodePoint",
          "container": "EC2N",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
          "lines": "46-97",
          "snippet": "bool EC2N::DecodePoint(EC2N::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n{\n\tbyte type;\n\tif (encodedPointLen < 1 || !bt.Get(type))\n\t\treturn false;\n\n\tswitch (type)\n\t{\n\tcase 0:\n\t\tP.identity = true;\n\t\treturn true;\n\tcase 2:\n\tcase 3:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(true))\n\t\t\treturn false;\n\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, m_field->MaxElementByteLength()); \n\n\t\tif (P.x.IsZero())\n\t\t{\n\t\t\tP.y = m_field->SquareRoot(m_b);\n\t\t\treturn true;\n\t\t}\n\n\t\tFieldElement z = m_field->Square(P.x);\n\t\tassert(P.x == m_field->SquareRoot(z));\n\t\tP.y = m_field->Divide(m_field->Add(m_field->Multiply(z, m_field->Add(P.x, m_a)), m_b), z);\n\t\tassert(P.x == m_field->Subtract(m_field->Divide(m_field->Subtract(m_field->Multiply(P.y, z), m_b), z), m_a));\n\t\tz = m_field->SolveQuadraticEquation(P.y);\n\t\tassert(m_field->Add(m_field->Square(z), z) == P.y);\n\t\tz.SetCoefficient(0, type & 1);\n\n\t\tP.y = m_field->Multiply(z, P.x);\n\t\treturn true;\n\t}\n\tcase 4:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(false))\n\t\t\treturn false;\n\n\t\tunsigned int len = m_field->MaxElementByteLength();\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, len);\n\t\tP.y.Decode(bt, len);\n\t\treturn true;\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"eprecomp.cpp\"",
            "#include \"algebra.cpp\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  bool EC2N::DecodePoint(EC2N::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n  {\n  \tbyte type;\n  \tif (encodedPointLen < 1 || !bt.Get(type))\n  \t\treturn false;\n  \n  \tswitch (type)\n  \t{\n  \tcase 0:\n  \t\tP.identity = true;\n  \t\treturn true;\n  \tcase 2:\n  \tcase 3:\n  \t{\n  \t\tif (encodedPointLen != EncodedPointSize(true))\n  \t\t\treturn false;\n  \n  \t\tP.identity = false;\n  \t\tP.x.Decode(bt, m_field->MaxElementByteLength()); \n  \n  \t\tif (P.x.IsZero())\n  \t\t{\n  \t\t\tP.y = m_field->SquareRoot(m_b);\n  \t\t\treturn true;\n  \t\t}\n  \n  \t\tFieldElement z = m_field->Square(P.x);\n  \t\tassert(P.x == m_field->SquareRoot(z));\n  \t\tP.y = m_field->Divide(m_field->Add(m_field->Multiply(z, m_field->Add(P.x, m_a)), m_b), z);\n  \t\tassert(P.x == m_field->Subtract(m_field->Divide(m_field->Subtract(m_field->Multiply(P.y, z), m_b), z), m_a));\n  \t\tz = m_field->SolveQuadraticEquation(P.y);\n  \t\tassert(m_field->Add(m_field->Square(z), z) == P.y);\n  \t\tz.SetCoefficient(0, type & 1);\n  \n  \t\tP.y = m_field->Multiply(z, P.x);\n  \t\treturn true;\n  \t}\n  \tcase 4:\n  \t{\n  \t\tif (encodedPointLen != EncodedPointSize(false))\n  \t\t\treturn false;\n  \n  \t\tunsigned int len = m_field->MaxElementByteLength();\n  \t\tP.identity = false;\n  \t\tP.x.Decode(bt, len);\n  \t\tP.y.Decode(bt, len);\n  \t\treturn true;\n  \t}\n  \tdefault:\n  \t\treturn false;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.size",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BERDecodeOctetString",
          "args": [
            "bt",
            "str"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeOctetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "132-144",
          "snippet": "size_t BERDecodeOctetString(BufferedTransformation &bt, BufferedTransformation &str)\n{\n\tbyte b;\n\tif (!bt.Get(b) || b != OCTET_STRING)\n\t\tBERDecodeError();\n\n\tsize_t bc;\n\tif (!BERLengthDecode(bt, bc))\n\t\tBERDecodeError();\n\n\tbt.TransferTo(str, bc);\n\treturn bc;\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nsize_t BERDecodeOctetString(BufferedTransformation &bt, BufferedTransformation &str)\n{\n\tbyte b;\n\tif (!bt.Get(b) || b != OCTET_STRING)\n\t\tBERDecodeError();\n\n\tsize_t bc;\n\tif (!BERLengthDecode(bt, bc))\n\t\tBERDecodeError();\n\n\tbt.TransferTo(str, bc);\n\treturn bc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  EC2N::Point EC2N::BERDecodePoint(BufferedTransformation &bt) const\n  {\n  \tSecByteBlock str;\n  \tBERDecodeOctetString(bt, str);\n  \tPoint P;\n  \tif (!DecodePoint(P, str, str.size()))\n  \t\tBERDecodeError();\n  \treturn P;\n  }\n}"
  },
  {
    "function_name": "EncodePoint",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "117-122",
    "snippet": "void EC2N::EncodePoint(byte *encodedPoint, const Point &P, bool compressed) const\n{\n\tArraySink sink(encodedPoint, EncodedPointSize(compressed));\n\tEncodePoint(sink, P, compressed);\n\tassert(sink.TotalPutLength() == EncodedPointSize(compressed));\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sink.TotalPutLength() == EncodedPointSize(compressed)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodedPointSize",
          "args": [
            "compressed"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sink.TotalPutLength",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodePoint",
          "args": [
            "sink",
            "P",
            "compressed"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncodePoint",
          "container": "EC2N",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
          "lines": "134-139",
          "snippet": "void EC2N::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n{\n\tSecByteBlock str(EncodedPointSize(compressed));\n\tEncodePoint(str, P, compressed);\n\tDEREncodeOctetString(bt, str);\n}",
          "includes": [
            "#include \"eprecomp.cpp\"",
            "#include \"algebra.cpp\"",
            "#include \"asn.h\"",
            "#include \"ec2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  void EC2N::DEREncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n  {\n  \tSecByteBlock str(EncodedPointSize(compressed));\n  \tEncodePoint(str, P, compressed);\n  \tDEREncodeOctetString(bt, str);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  void EC2N::EncodePoint(byte *encodedPoint, const Point &P, bool compressed) const\n  {\n  \tArraySink sink(encodedPoint, EncodedPointSize(compressed));\n  \tEncodePoint(sink, P, compressed);\n  \tassert(sink.TotalPutLength() == EncodedPointSize(compressed));\n  }\n}"
  },
  {
    "function_name": "EncodePoint",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "99-115",
    "snippet": "void EC2N::EncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n{\n\tif (P.identity)\n\t\tNullStore().TransferTo(bt, EncodedPointSize(compressed));\n\telse if (compressed)\n\t{\n\t\tbt.Put(2 + (!P.x ? 0 : m_field->Divide(P.y, P.x).GetBit(0)));\n\t\tP.x.Encode(bt, m_field->MaxElementByteLength());\n\t}\n\telse\n\t{\n\t\tunsigned int len = m_field->MaxElementByteLength();\n\t\tbt.Put(4);\t// uncompressed\n\t\tP.x.Encode(bt, len);\n\t\tP.y.Encode(bt, len);\n\t}\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "P.y.Encode",
          "args": [
            "bt",
            "len"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt.Put",
          "args": [
            "4"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->MaxElementByteLength",
          "args": [],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->MaxElementByteLength",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->Divide",
          "args": [
            "0"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->Divide",
          "args": [
            "P.y",
            "P.x"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "Divide",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "57-58",
          "snippet": "Element Divide(Element a, Element b) const\n\t\t{return Multiply(a, MultiplicativeInverse(b));}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Divide(Element a, Element b) const\n  \t\t{return Multiply(a, MultiplicativeInverse(b));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NullStore",
          "args": [
            "bt",
            "EncodedPointSize(compressed)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodedPointSize",
          "args": [
            "compressed"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NullStore",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  void EC2N::EncodePoint(BufferedTransformation &bt, const Point &P, bool compressed) const\n  {\n  \tif (P.identity)\n  \t\tNullStore().TransferTo(bt, EncodedPointSize(compressed));\n  \telse if (compressed)\n  \t{\n  \t\tbt.Put(2 + (!P.x ? 0 : m_field->Divide(P.y, P.x).GetBit(0)));\n  \t\tP.x.Encode(bt, m_field->MaxElementByteLength());\n  \t}\n  \telse\n  \t{\n  \t\tunsigned int len = m_field->MaxElementByteLength();\n  \t\tbt.Put(4);\t// uncompressed\n  \t\tP.x.Encode(bt, len);\n  \t\tP.y.Encode(bt, len);\n  \t}\n  }\n}"
  },
  {
    "function_name": "DecodePoint",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "46-97",
    "snippet": "bool EC2N::DecodePoint(EC2N::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n{\n\tbyte type;\n\tif (encodedPointLen < 1 || !bt.Get(type))\n\t\treturn false;\n\n\tswitch (type)\n\t{\n\tcase 0:\n\t\tP.identity = true;\n\t\treturn true;\n\tcase 2:\n\tcase 3:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(true))\n\t\t\treturn false;\n\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, m_field->MaxElementByteLength()); \n\n\t\tif (P.x.IsZero())\n\t\t{\n\t\t\tP.y = m_field->SquareRoot(m_b);\n\t\t\treturn true;\n\t\t}\n\n\t\tFieldElement z = m_field->Square(P.x);\n\t\tassert(P.x == m_field->SquareRoot(z));\n\t\tP.y = m_field->Divide(m_field->Add(m_field->Multiply(z, m_field->Add(P.x, m_a)), m_b), z);\n\t\tassert(P.x == m_field->Subtract(m_field->Divide(m_field->Subtract(m_field->Multiply(P.y, z), m_b), z), m_a));\n\t\tz = m_field->SolveQuadraticEquation(P.y);\n\t\tassert(m_field->Add(m_field->Square(z), z) == P.y);\n\t\tz.SetCoefficient(0, type & 1);\n\n\t\tP.y = m_field->Multiply(z, P.x);\n\t\treturn true;\n\t}\n\tcase 4:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(false))\n\t\t\treturn false;\n\n\t\tunsigned int len = m_field->MaxElementByteLength();\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, len);\n\t\tP.y.Decode(bt, len);\n\t\treturn true;\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "P.y.Decode",
          "args": [
            "bt",
            "len"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "Decode",
          "container": "PolynomialMod2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2n.cpp",
          "lines": "145-155",
          "snippet": "void PolynomialMod2::Decode(BufferedTransformation &bt, size_t inputLen)\n{\n\treg.CleanNew(BytesToWords(inputLen));\n\n\tfor (size_t i=inputLen; i > 0; i--)\n\t{\n\t\tbyte b;\n\t\tbt.Get(b);\n\t\treg[(i-1)/WORD_SIZE] |= word(b) << ((i-1)%WORD_SIZE)*8;\n\t}\n}",
          "includes": [
            "#include <iostream>",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"randpool.h\"",
            "#include \"words.h\"",
            "#include \"algebra.h\"",
            "#include \"gf2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"randpool.h\"\n#include \"words.h\"\n#include \"algebra.h\"\n#include \"gf2n.h\"\n#include \"pch.h\"\n\nPolynomialMod2 {\n  void PolynomialMod2::Decode(BufferedTransformation &bt, size_t inputLen)\n  {\n  \treg.CleanNew(BytesToWords(inputLen));\n  \n  \tfor (size_t i=inputLen; i > 0; i--)\n  \t{\n  \t\tbyte b;\n  \t\tbt.Get(b);\n  \t\treg[(i-1)/WORD_SIZE] |= word(b) << ((i-1)%WORD_SIZE)*8;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->MaxElementByteLength",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodedPointSize",
          "args": [
            "false"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->Multiply",
          "args": [
            "z",
            "P.x"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "Multiply",
          "container": "Word",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "309-314",
          "snippet": "static Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nWord {\n  static Word Multiply(hword a, hword b)\n  \t{\n  \t\tWord r;\n  \t\tr.m_whole = (word)a * b;\n  \t\treturn r;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "z.SetCoefficient",
          "args": [
            "0",
            "type & 1"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "SetCoefficient",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "239-239",
          "snippet": "void SetCoefficient(unsigned int i, const CoefficientType &value) {B::SetCoefficient(i, value, ms_fixedRing);}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  void SetCoefficient(unsigned int i, const CoefficientType &value) {B::SetCoefficient(i, value, ms_fixedRing);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_field->Add(m_field->Square(z), z) == P.y"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->Add",
          "args": [
            "m_field->Square(z)",
            "z"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "26-27",
          "snippet": "Element Add(Element a, Element b) const\n\t\t{return a^b;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Add(Element a, Element b) const\n  \t\t{return a^b;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->Square",
          "args": [
            "z"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "Square",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "49-50",
          "snippet": "Element Square(Element a) const\n\t\t{return Multiply(a, a);}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Square(Element a) const\n  \t\t{return Multiply(a, a);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->SolveQuadraticEquation",
          "args": [
            "P.y"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "SolveQuadraticEquation",
          "container": "GF2NP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2n.cpp",
          "lines": "559-582",
          "snippet": "GF2NP::Element GF2NP::SolveQuadraticEquation(const Element &a) const\n{\n\tif (m%2 == 0)\n\t{\n\t\tElement z, w;\n\t\tRandomPool rng;\n\t\tdo\n\t\t{\n\t\t\tElement p((RandomNumberGenerator &)rng, m);\n\t\t\tz = PolynomialMod2::Zero();\n\t\t\tw = p;\n\t\t\tfor (unsigned int i=1; i<=m-1; i++)\n\t\t\t{\n\t\t\t\tw = Square(w);\n\t\t\t\tz = Square(z);\n\t\t\t\tAccumulate(z, Multiply(w, a));\n\t\t\t\tAccumulate(w, p);\n\t\t\t}\n\t\t} while (w.IsZero());\n\t\treturn z;\n\t}\n\telse\n\t\treturn HalfTrace(a);\n}",
          "includes": [
            "#include <iostream>",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"randpool.h\"",
            "#include \"words.h\"",
            "#include \"algebra.h\"",
            "#include \"gf2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"randpool.h\"\n#include \"words.h\"\n#include \"algebra.h\"\n#include \"gf2n.h\"\n#include \"pch.h\"\n\nGF2NP {\n  GF2NP::Element GF2NP::SolveQuadraticEquation(const Element &a) const\n  {\n  \tif (m%2 == 0)\n  \t{\n  \t\tElement z, w;\n  \t\tRandomPool rng;\n  \t\tdo\n  \t\t{\n  \t\t\tElement p((RandomNumberGenerator &)rng, m);\n  \t\t\tz = PolynomialMod2::Zero();\n  \t\t\tw = p;\n  \t\t\tfor (unsigned int i=1; i<=m-1; i++)\n  \t\t\t{\n  \t\t\t\tw = Square(w);\n  \t\t\t\tz = Square(z);\n  \t\t\t\tAccumulate(z, Multiply(w, a));\n  \t\t\t\tAccumulate(w, p);\n  \t\t\t}\n  \t\t} while (w.IsZero());\n  \t\treturn z;\n  \t}\n  \telse\n  \t\treturn HalfTrace(a);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "P.x == m_field->Subtract(m_field->Divide(m_field->Subtract(m_field->Multiply(P.y, z), m_b), z), m_a)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->Subtract",
          "args": [
            "m_field->Divide(m_field->Subtract(m_field->Multiply(P.y, z), m_b), z)",
            "m_a"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "Subtract",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "35-36",
          "snippet": "Element Subtract(Element a, Element b) const\n\t\t{return a^b;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Subtract(Element a, Element b) const\n  \t\t{return a^b;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->Divide",
          "args": [
            "m_field->Subtract(m_field->Multiply(P.y, z), m_b)",
            "z"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "Divide",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "57-58",
          "snippet": "Element Divide(Element a, Element b) const\n\t\t{return Multiply(a, MultiplicativeInverse(b));}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Divide(Element a, Element b) const\n  \t\t{return Multiply(a, MultiplicativeInverse(b));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "P.x == m_field->SquareRoot(z)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_field->SquareRoot",
          "args": [
            "z"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "SquareRoot",
          "container": "GF2NP",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2n.cpp",
          "lines": "542-548",
          "snippet": "GF2NP::Element GF2NP::SquareRoot(const Element &a) const\n{\n\tElement r = a;\n\tfor (unsigned int i=1; i<m; i++)\n\t\tr = Square(r);\n\treturn r;\n}",
          "includes": [
            "#include <iostream>",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"randpool.h\"",
            "#include \"words.h\"",
            "#include \"algebra.h\"",
            "#include \"gf2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"randpool.h\"\n#include \"words.h\"\n#include \"algebra.h\"\n#include \"gf2n.h\"\n#include \"pch.h\"\n\nGF2NP {\n  GF2NP::Element GF2NP::SquareRoot(const Element &a) const\n  {\n  \tElement r = a;\n  \tfor (unsigned int i=1; i<m; i++)\n  \t\tr = Square(r);\n  \treturn r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "P.x.IsZero",
          "args": [],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "IsZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "197-197",
          "snippet": "bool IsZero() const {return !*this;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsZero() const {return !*this;}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->MaxElementByteLength",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodedPointSize",
          "args": [
            "true"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bt.Get",
          "args": [
            "type"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  bool EC2N::DecodePoint(EC2N::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n  {\n  \tbyte type;\n  \tif (encodedPointLen < 1 || !bt.Get(type))\n  \t\treturn false;\n  \n  \tswitch (type)\n  \t{\n  \tcase 0:\n  \t\tP.identity = true;\n  \t\treturn true;\n  \tcase 2:\n  \tcase 3:\n  \t{\n  \t\tif (encodedPointLen != EncodedPointSize(true))\n  \t\t\treturn false;\n  \n  \t\tP.identity = false;\n  \t\tP.x.Decode(bt, m_field->MaxElementByteLength()); \n  \n  \t\tif (P.x.IsZero())\n  \t\t{\n  \t\t\tP.y = m_field->SquareRoot(m_b);\n  \t\t\treturn true;\n  \t\t}\n  \n  \t\tFieldElement z = m_field->Square(P.x);\n  \t\tassert(P.x == m_field->SquareRoot(z));\n  \t\tP.y = m_field->Divide(m_field->Add(m_field->Multiply(z, m_field->Add(P.x, m_a)), m_b), z);\n  \t\tassert(P.x == m_field->Subtract(m_field->Divide(m_field->Subtract(m_field->Multiply(P.y, z), m_b), z), m_a));\n  \t\tz = m_field->SolveQuadraticEquation(P.y);\n  \t\tassert(m_field->Add(m_field->Square(z), z) == P.y);\n  \t\tz.SetCoefficient(0, type & 1);\n  \n  \t\tP.y = m_field->Multiply(z, P.x);\n  \t\treturn true;\n  \t}\n  \tcase 4:\n  \t{\n  \t\tif (encodedPointLen != EncodedPointSize(false))\n  \t\t\treturn false;\n  \n  \t\tunsigned int len = m_field->MaxElementByteLength();\n  \t\tP.identity = false;\n  \t\tP.x.Decode(bt, len);\n  \t\tP.y.Decode(bt, len);\n  \t\treturn true;\n  \t}\n  \tdefault:\n  \t\treturn false;\n  \t}\n  }\n}"
  },
  {
    "function_name": "DecodePoint",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "40-44",
    "snippet": "bool EC2N::DecodePoint(EC2N::Point &P, const byte *encodedPoint, size_t encodedPointLen) const\n{\n\tStringStore store(encodedPoint, encodedPointLen);\n\treturn DecodePoint(P, store, encodedPointLen);\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DecodePoint",
          "args": [
            "P",
            "store",
            "encodedPointLen"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "DecodePoint",
          "container": "EC2N",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
          "lines": "46-97",
          "snippet": "bool EC2N::DecodePoint(EC2N::Point &P, BufferedTransformation &bt, size_t encodedPointLen) const\n{\n\tbyte type;\n\tif (encodedPointLen < 1 || !bt.Get(type))\n\t\treturn false;\n\n\tswitch (type)\n\t{\n\tcase 0:\n\t\tP.identity = true;\n\t\treturn true;\n\tcase 2:\n\tcase 3:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(true))\n\t\t\treturn false;\n\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, m_field->MaxElementByteLength()); \n\n\t\tif (P.x.IsZero())\n\t\t{\n\t\t\tP.y = m_field->SquareRoot(m_b);\n\t\t\treturn true;\n\t\t}\n\n\t\tFieldElement z = m_field->Square(P.x);\n\t\tassert(P.x == m_field->SquareRoot(z));\n\t\tP.y = m_field->Divide(m_field->Add(m_field->Multiply(z, m_field->Add(P.x, m_a)), m_b), z);\n\t\tassert(P.x == m_field->Subtract(m_field->Divide(m_field->Subtract(m_field->Multiply(P.y, z), m_b), z), m_a));\n\t\tz = m_field->SolveQuadraticEquation(P.y);\n\t\tassert(m_field->Add(m_field->Square(z), z) == P.y);\n\t\tz.SetCoefficient(0, type & 1);\n\n\t\tP.y = m_field->Multiply(z, P.x);\n\t\treturn true;\n\t}\n\tcase 4:\n\t{\n\t\tif (encodedPointLen != EncodedPointSize(false))\n\t\t\treturn false;\n\n\t\tunsigned int len = m_field->MaxElementByteLength();\n\t\tP.identity = false;\n\t\tP.x.Decode(bt, len);\n\t\tP.y.Decode(bt, len);\n\t\treturn true;\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  bool EC2N::DecodePoint(EC2N::Point &P, const byte *encodedPoint, size_t encodedPointLen) const\n  {\n  \tStringStore store(encodedPoint, encodedPointLen);\n  \treturn DecodePoint(P, store, encodedPointLen);\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "31-38",
    "snippet": "void EC2N::DEREncode(BufferedTransformation &bt) const\n{\n\tm_field->DEREncode(bt);\n\tDERSequenceEncoder seq(bt);\n\tm_field->DEREncodeElement(seq, m_a);\n\tm_field->DEREncodeElement(seq, m_b);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->DEREncodeElement",
          "args": [
            "seq",
            "m_b"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncodeElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.h",
          "lines": "101-101",
          "snippet": "void DEREncodeElement(BufferedTransformation &bt, const Element &v) const {m_ec.DEREncodePoint(bt, v, false);}",
          "includes": [
            "#include \"pubkey.h\"",
            "#include \"smartptr.h\"",
            "#include \"eprecomp.h\"",
            "#include \"gf2n.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n#include \"smartptr.h\"\n#include \"eprecomp.h\"\n#include \"gf2n.h\"\n\nvoid DEREncodeElement(BufferedTransformation &bt, const Element &v) const {m_ec.DEREncodePoint(bt, v, false);}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->DEREncode",
          "args": [
            "bt"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "EC2N",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
          "lines": "31-38",
          "snippet": "void EC2N::DEREncode(BufferedTransformation &bt) const\n{\n\tm_field->DEREncode(bt);\n\tDERSequenceEncoder seq(bt);\n\tm_field->DEREncodeElement(seq, m_a);\n\tm_field->DEREncodeElement(seq, m_b);\n\tseq.MessageEnd();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  void EC2N::DEREncode(BufferedTransformation &bt) const\n  {\n  \tm_field->DEREncode(bt);\n  \tDERSequenceEncoder seq(bt);\n  \tm_field->DEREncodeElement(seq, m_a);\n  \tm_field->DEREncodeElement(seq, m_b);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "EC2N",
    "container": "EC2N",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ec2n.cpp",
    "lines": "15-29",
    "snippet": "EC2N::EC2N(BufferedTransformation &bt)\n\t: m_field(BERDecodeGF2NP(bt))\n{\n\tBERSequenceDecoder seq(bt);\n\tm_field->BERDecodeElement(seq, m_a);\n\tm_field->BERDecodeElement(seq, m_b);\n\t// skip optional seed\n\tif (!seq.EndReached())\n\t{\n\t\tSecByteBlock seed;\n\t\tunsigned int unused;\n\t\tBERDecodeBitString(seq, seed, unused);\n\t}\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"eprecomp.cpp\"",
      "#include \"algebra.cpp\"",
      "#include \"asn.h\"",
      "#include \"ec2n.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BERDecodeBitString",
          "args": [
            "seq",
            "seed",
            "unused"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeBitString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "181-199",
          "snippet": "size_t BERDecodeBitString(BufferedTransformation &bt, SecByteBlock &str, unsigned int &unusedBits)\n{\n\tbyte b;\n\tif (!bt.Get(b) || b != BIT_STRING)\n\t\tBERDecodeError();\n\n\tsize_t bc;\n\tif (!BERLengthDecode(bt, bc))\n\t\tBERDecodeError();\n\n\tbyte unused;\n\tif (!bt.Get(unused))\n\t\tBERDecodeError();\n\tunusedBits = unused;\n\tstr.resize(bc-1);\n\tif ((bc-1) != bt.Get(str, bc-1))\n\t\tBERDecodeError();\n\treturn bc-1;\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nsize_t BERDecodeBitString(BufferedTransformation &bt, SecByteBlock &str, unsigned int &unusedBits)\n{\n\tbyte b;\n\tif (!bt.Get(b) || b != BIT_STRING)\n\t\tBERDecodeError();\n\n\tsize_t bc;\n\tif (!BERLengthDecode(bt, bc))\n\t\tBERDecodeError();\n\n\tbyte unused;\n\tif (!bt.Get(unused))\n\t\tBERDecodeError();\n\tunusedBits = unused;\n\tstr.resize(bc-1);\n\tif ((bc-1) != bt.Get(str, bc-1))\n\t\tBERDecodeError();\n\treturn bc-1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq.EndReached",
          "args": [],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "EndReached",
          "container": "BERGeneralDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "413-422",
          "snippet": "bool BERGeneralDecoder::EndReached() const\n{\n\tif (m_definiteLength)\n\t\treturn m_length == 0;\n\telse\n\t{\t// check end-of-content octets\n\t\tword16 i;\n\t\treturn (m_inQueue.PeekWord16(i)==2 && i==0);\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nBERGeneralDecoder {\n  bool BERGeneralDecoder::EndReached() const\n  {\n  \tif (m_definiteLength)\n  \t\treturn m_length == 0;\n  \telse\n  \t{\t// check end-of-content octets\n  \t\tword16 i;\n  \t\treturn (m_inQueue.PeekWord16(i)==2 && i==0);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_field->BERDecodeElement",
          "args": [
            "seq",
            "m_b"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeElement",
          "container": "ModularArithmetic",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "4034-4037",
          "snippet": "void ModularArithmetic::BERDecodeElement(BufferedTransformation &in, Element &a) const\n{\n\ta.BERDecodeAsOctetString(in, MaxElementByteLength());\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nModularArithmetic {\n  void ModularArithmetic::BERDecodeElement(BufferedTransformation &in, Element &a) const\n  {\n  \ta.BERDecodeAsOctetString(in, MaxElementByteLength());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BERDecodeGF2NP",
          "args": [
            "bt"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"eprecomp.cpp\"\n#include \"algebra.cpp\"\n#include \"asn.h\"\n#include \"ec2n.h\"\n#include \"pch.h\"\n\nEC2N {\n  EC2N::EC2N(BufferedTransformation &bt)\n  \t: m_field(BERDecodeGF2NP(bt))\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_field->BERDecodeElement(seq, m_a);\n  \tm_field->BERDecodeElement(seq, m_b);\n  \t// skip optional seed\n  \tif (!seq.EndReached())\n  \t{\n  \t\tSecByteBlock seed;\n  \t\tunsigned int unused;\n  \t\tBERDecodeBitString(seq, seed, unused);\n  \t}\n  \tseq.MessageEnd();\n  }\n}"
  }
]