[
  {
    "function_name": "Deflator::EndBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "738-799",
    "snippet": "void Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "m_distanceCounts.begin()",
            "m_distanceCounts.end()",
            "0"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_distanceCounts.end",
          "args": [],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_distanceCounts.begin",
          "args": [],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "m_literalCounts.begin()",
            "m_literalCounts.end()",
            "0"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeBlock",
          "args": [
            "eof",
            "DYNAMIC"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::EncodeBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "632-736",
          "snippet": "void Deflator::EncodeBlock(bool eof, unsigned int blockType)\n{\n\tPutBits(eof, 1);\n\tPutBits(blockType, 2);\n\n\tif (blockType == STORED)\n\t{\n\t\tassert(m_blockStart + m_blockLength <= m_byteBuffer.size());\n\t\tassert(m_blockLength <= 0xffff);\n\t\tFlushBitBuffer();\n\t\tAttachedTransformation()->PutWord16(m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->PutWord16(~m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->Put(m_byteBuffer + m_blockStart, m_blockLength);\n\t}\n\telse\n\t{\n\t\tif (blockType == DYNAMIC)\n\t\t{\n#if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n\t\t\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n\t\t\ttypedef reverse_bidirectional_iterator<unsigned int *, unsigned int> RevIt;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n\ttypedef reverse_iterator<unsigned int *, random_access_iterator_tag, unsigned int> RevIt;\n#else\n\t\t\ttypedef reverse_iterator<unsigned int *> RevIt;\n#endif\n\n\t\t\tFixedSizeSecBlock<unsigned int, 286> literalCodeLengths;\n\t\t\tFixedSizeSecBlock<unsigned int, 30> distanceCodeLengths;\n\n\t\t\tm_literalCounts[256] = 1;\n\t\t\tHuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);\n\t\t\tm_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);\n\t\t\tunsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));\n\n\t\t\tHuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);\n\t\t\tm_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);\n\t\t\tunsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));\n\n\t\t\tSecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);\n\t\t\tmemcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));\n\t\t\tmemcpy(combinedLengths+hlit+257, distanceCodeLengths, (hdist+1)*sizeof(unsigned int));\n\n\t\t\tFixedSizeSecBlock<unsigned int, 19> codeLengthCodeCounts, codeLengthCodeLengths;\n\t\t\tfill(codeLengthCodeCounts.begin(), codeLengthCodeCounts.end(), 0);\n\t\t\tconst unsigned int *p = combinedLengths.begin(), *begin = combinedLengths.begin(), *end = combinedLengths.end();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthCodeCounts[code]++;\n\t\t\t}\n\t\t\tHuffmanEncoder::GenerateCodeLengths(codeLengthCodeLengths, 7, codeLengthCodeCounts, 19);\n\t\t\tHuffmanEncoder codeLengthEncoder(codeLengthCodeLengths, 19);\n\t\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\t\tunsigned int hclen = 19;\n\t\t\twhile (hclen > 4 && codeLengthCodeLengths[border[hclen-1]] == 0)\n\t\t\t\thclen--;\n\t\t\thclen -= 4;\n\n\t\t\tPutBits(hlit, 5);\n\t\t\tPutBits(hdist, 5);\n\t\t\tPutBits(hclen, 4);\n\n\t\t\tfor (unsigned int i=0; i<hclen+4; i++)\n\t\t\t\tPutBits(codeLengthCodeLengths[border[i]], 3);\n\n\t\t\tp = combinedLengths.begin();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthEncoder.Encode(*this, code);\n\t\t\t\tPutBits(extraBits, extraBitsLength);\n\t\t\t}\n\t\t}\n\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanEncoder &literalEncoder = (blockType == STATIC) ? m_staticLiteralEncoder : m_dynamicLiteralEncoder;\n\t\tconst HuffmanEncoder &distanceEncoder = (blockType == STATIC) ? m_staticDistanceEncoder : m_dynamicDistanceEncoder;\n\n\t\tfor (unsigned int i=0; i<m_matchBufferEnd; i++)\n\t\t{\n\t\t\tunsigned int literalCode = m_matchBuffer[i].literalCode;\n\t\t\tliteralEncoder.Encode(*this, literalCode);\n\t\t\tif (literalCode >= 257)\n\t\t\t{\n\t\t\t\tassert(literalCode <= 285);\n\t\t\t\tPutBits(m_matchBuffer[i].literalExtra, lengthExtraBits[literalCode-257]);\n\t\t\t\tunsigned int distanceCode = m_matchBuffer[i].distanceCode;\n\t\t\t\tdistanceEncoder.Encode(*this, distanceCode);\n\t\t\t\tPutBits(m_matchBuffer[i].distanceExtra, distanceExtraBits[distanceCode]);\n\t\t\t}\n\t\t}\n\t\tliteralEncoder.Encode(*this, 256);\t// end of block\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EncodeBlock(bool eof, unsigned int blockType)\n{\n\tPutBits(eof, 1);\n\tPutBits(blockType, 2);\n\n\tif (blockType == STORED)\n\t{\n\t\tassert(m_blockStart + m_blockLength <= m_byteBuffer.size());\n\t\tassert(m_blockLength <= 0xffff);\n\t\tFlushBitBuffer();\n\t\tAttachedTransformation()->PutWord16(m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->PutWord16(~m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->Put(m_byteBuffer + m_blockStart, m_blockLength);\n\t}\n\telse\n\t{\n\t\tif (blockType == DYNAMIC)\n\t\t{\n#if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n\t\t\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n\t\t\ttypedef reverse_bidirectional_iterator<unsigned int *, unsigned int> RevIt;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n\ttypedef reverse_iterator<unsigned int *, random_access_iterator_tag, unsigned int> RevIt;\n#else\n\t\t\ttypedef reverse_iterator<unsigned int *> RevIt;\n#endif\n\n\t\t\tFixedSizeSecBlock<unsigned int, 286> literalCodeLengths;\n\t\t\tFixedSizeSecBlock<unsigned int, 30> distanceCodeLengths;\n\n\t\t\tm_literalCounts[256] = 1;\n\t\t\tHuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);\n\t\t\tm_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);\n\t\t\tunsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));\n\n\t\t\tHuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);\n\t\t\tm_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);\n\t\t\tunsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));\n\n\t\t\tSecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);\n\t\t\tmemcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));\n\t\t\tmemcpy(combinedLengths+hlit+257, distanceCodeLengths, (hdist+1)*sizeof(unsigned int));\n\n\t\t\tFixedSizeSecBlock<unsigned int, 19> codeLengthCodeCounts, codeLengthCodeLengths;\n\t\t\tfill(codeLengthCodeCounts.begin(), codeLengthCodeCounts.end(), 0);\n\t\t\tconst unsigned int *p = combinedLengths.begin(), *begin = combinedLengths.begin(), *end = combinedLengths.end();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthCodeCounts[code]++;\n\t\t\t}\n\t\t\tHuffmanEncoder::GenerateCodeLengths(codeLengthCodeLengths, 7, codeLengthCodeCounts, 19);\n\t\t\tHuffmanEncoder codeLengthEncoder(codeLengthCodeLengths, 19);\n\t\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\t\tunsigned int hclen = 19;\n\t\t\twhile (hclen > 4 && codeLengthCodeLengths[border[hclen-1]] == 0)\n\t\t\t\thclen--;\n\t\t\thclen -= 4;\n\n\t\t\tPutBits(hlit, 5);\n\t\t\tPutBits(hdist, 5);\n\t\t\tPutBits(hclen, 4);\n\n\t\t\tfor (unsigned int i=0; i<hclen+4; i++)\n\t\t\t\tPutBits(codeLengthCodeLengths[border[i]], 3);\n\n\t\t\tp = combinedLengths.begin();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthEncoder.Encode(*this, code);\n\t\t\t\tPutBits(extraBits, extraBitsLength);\n\t\t\t}\n\t\t}\n\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanEncoder &literalEncoder = (blockType == STATIC) ? m_staticLiteralEncoder : m_dynamicLiteralEncoder;\n\t\tconst HuffmanEncoder &distanceEncoder = (blockType == STATIC) ? m_staticDistanceEncoder : m_dynamicDistanceEncoder;\n\n\t\tfor (unsigned int i=0; i<m_matchBufferEnd; i++)\n\t\t{\n\t\t\tunsigned int literalCode = m_matchBuffer[i].literalCode;\n\t\t\tliteralEncoder.Encode(*this, literalCode);\n\t\t\tif (literalCode >= 257)\n\t\t\t{\n\t\t\t\tassert(literalCode <= 285);\n\t\t\t\tPutBits(m_matchBuffer[i].literalExtra, lengthExtraBits[literalCode-257]);\n\t\t\t\tunsigned int distanceCode = m_matchBuffer[i].distanceCode;\n\t\t\t\tdistanceEncoder.Encode(*this, distanceCode);\n\t\t\t\tPutBits(m_matchBuffer[i].distanceExtra, distanceExtraBits[distanceCode]);\n\t\t\t}\n\t\t}\n\t\tliteralEncoder.Encode(*this, 256);\t// end of block\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "2*m_detectSkip",
            "128U"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FinishCounting",
          "args": [],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "LowFirstBitWriter::FinishCounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "33-38",
          "snippet": "unsigned long LowFirstBitWriter::FinishCounting()\n{\n\tassert(m_counting);\n\tm_counting = false;\n\treturn m_bitCount;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nunsigned long LowFirstBitWriter::FinishCounting()\n{\n\tassert(m_counting);\n\tm_counting = false;\n\treturn m_bitCount;\n}"
        }
      },
      {
        "call_info": {
          "callee": "StartCounting",
          "args": [],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "LowFirstBitWriter::StartCounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "26-31",
          "snippet": "void LowFirstBitWriter::StartCounting()\n{\n\tassert(!m_counting);\n\tm_counting = true;\n\tm_bitCount = 0;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::StartCounting()\n{\n\tassert(!m_counting);\n\tm_counting = true;\n\tm_bitCount = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "m_bitsBuffered+3",
            "8U"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
  },
  {
    "function_name": "Deflator::EncodeBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "632-736",
    "snippet": "void Deflator::EncodeBlock(bool eof, unsigned int blockType)\n{\n\tPutBits(eof, 1);\n\tPutBits(blockType, 2);\n\n\tif (blockType == STORED)\n\t{\n\t\tassert(m_blockStart + m_blockLength <= m_byteBuffer.size());\n\t\tassert(m_blockLength <= 0xffff);\n\t\tFlushBitBuffer();\n\t\tAttachedTransformation()->PutWord16(m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->PutWord16(~m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->Put(m_byteBuffer + m_blockStart, m_blockLength);\n\t}\n\telse\n\t{\n\t\tif (blockType == DYNAMIC)\n\t\t{\n#if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n\t\t\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n\t\t\ttypedef reverse_bidirectional_iterator<unsigned int *, unsigned int> RevIt;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n\ttypedef reverse_iterator<unsigned int *, random_access_iterator_tag, unsigned int> RevIt;\n#else\n\t\t\ttypedef reverse_iterator<unsigned int *> RevIt;\n#endif\n\n\t\t\tFixedSizeSecBlock<unsigned int, 286> literalCodeLengths;\n\t\t\tFixedSizeSecBlock<unsigned int, 30> distanceCodeLengths;\n\n\t\t\tm_literalCounts[256] = 1;\n\t\t\tHuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);\n\t\t\tm_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);\n\t\t\tunsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));\n\n\t\t\tHuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);\n\t\t\tm_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);\n\t\t\tunsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));\n\n\t\t\tSecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);\n\t\t\tmemcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));\n\t\t\tmemcpy(combinedLengths+hlit+257, distanceCodeLengths, (hdist+1)*sizeof(unsigned int));\n\n\t\t\tFixedSizeSecBlock<unsigned int, 19> codeLengthCodeCounts, codeLengthCodeLengths;\n\t\t\tfill(codeLengthCodeCounts.begin(), codeLengthCodeCounts.end(), 0);\n\t\t\tconst unsigned int *p = combinedLengths.begin(), *begin = combinedLengths.begin(), *end = combinedLengths.end();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthCodeCounts[code]++;\n\t\t\t}\n\t\t\tHuffmanEncoder::GenerateCodeLengths(codeLengthCodeLengths, 7, codeLengthCodeCounts, 19);\n\t\t\tHuffmanEncoder codeLengthEncoder(codeLengthCodeLengths, 19);\n\t\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\t\tunsigned int hclen = 19;\n\t\t\twhile (hclen > 4 && codeLengthCodeLengths[border[hclen-1]] == 0)\n\t\t\t\thclen--;\n\t\t\thclen -= 4;\n\n\t\t\tPutBits(hlit, 5);\n\t\t\tPutBits(hdist, 5);\n\t\t\tPutBits(hclen, 4);\n\n\t\t\tfor (unsigned int i=0; i<hclen+4; i++)\n\t\t\t\tPutBits(codeLengthCodeLengths[border[i]], 3);\n\n\t\t\tp = combinedLengths.begin();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthEncoder.Encode(*this, code);\n\t\t\t\tPutBits(extraBits, extraBitsLength);\n\t\t\t}\n\t\t}\n\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanEncoder &literalEncoder = (blockType == STATIC) ? m_staticLiteralEncoder : m_dynamicLiteralEncoder;\n\t\tconst HuffmanEncoder &distanceEncoder = (blockType == STATIC) ? m_staticDistanceEncoder : m_dynamicDistanceEncoder;\n\n\t\tfor (unsigned int i=0; i<m_matchBufferEnd; i++)\n\t\t{\n\t\t\tunsigned int literalCode = m_matchBuffer[i].literalCode;\n\t\t\tliteralEncoder.Encode(*this, literalCode);\n\t\t\tif (literalCode >= 257)\n\t\t\t{\n\t\t\t\tassert(literalCode <= 285);\n\t\t\t\tPutBits(m_matchBuffer[i].literalExtra, lengthExtraBits[literalCode-257]);\n\t\t\t\tunsigned int distanceCode = m_matchBuffer[i].distanceCode;\n\t\t\t\tdistanceEncoder.Encode(*this, distanceCode);\n\t\t\t\tPutBits(m_matchBuffer[i].distanceExtra, distanceExtraBits[distanceCode]);\n\t\t\t}\n\t\t}\n\t\tliteralEncoder.Encode(*this, 256);\t// end of block\n\t}\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "literalEncoder.Encode",
          "args": [
            "*this",
            "256"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PutBits",
          "args": [
            "m_matchBuffer[i].distanceExtra",
            "distanceExtraBits[distanceCode]"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "LowFirstBitWriter::PutBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "40-61",
          "snippet": "void LowFirstBitWriter::PutBits(unsigned long value, unsigned int length)\n{\n\tif (m_counting)\n\t\tm_bitCount += length;\n\telse\n\t{\n\t\tm_buffer |= value << m_bitsBuffered;\n\t\tm_bitsBuffered += length;\n\t\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\t\twhile (m_bitsBuffered >= 8)\n\t\t{\n\t\t\tm_outputBuffer[m_bytesBuffered++] = (byte)m_buffer;\n\t\t\tif (m_bytesBuffered == m_outputBuffer.size())\n\t\t\t{\n\t\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\t\tm_bytesBuffered = 0;\n\t\t\t}\n\t\t\tm_buffer >>= 8;\n\t\t\tm_bitsBuffered -= 8;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::PutBits(unsigned long value, unsigned int length)\n{\n\tif (m_counting)\n\t\tm_bitCount += length;\n\telse\n\t{\n\t\tm_buffer |= value << m_bitsBuffered;\n\t\tm_bitsBuffered += length;\n\t\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\t\twhile (m_bitsBuffered >= 8)\n\t\t{\n\t\t\tm_outputBuffer[m_bytesBuffered++] = (byte)m_buffer;\n\t\t\tif (m_bytesBuffered == m_outputBuffer.size())\n\t\t\t{\n\t\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\t\tm_bytesBuffered = 0;\n\t\t\t}\n\t\t\tm_buffer >>= 8;\n\t\t\tm_bitsBuffered -= 8;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "literalCode <= 285"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CodeLengthEncode",
          "args": [
            "begin",
            "end",
            "p",
            "extraBits",
            "extraBitsLength"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "CodeLengthEncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "590-630",
          "snippet": "inline unsigned int CodeLengthEncode(const unsigned int *begin, \n\t\t\t\t\t\t\t\t\t const unsigned int *end, \n\t\t\t\t\t\t\t\t\t const unsigned int *& p, \n\t\t\t\t\t\t\t\t\t unsigned int &extraBits, \n\t\t\t\t\t\t\t\t\t unsigned int &extraBitsLength)\n{\n\tunsigned int v = *p;\n\tif ((end-p) >= 3)\n\t{\n\t\tconst unsigned int *oldp = p;\n\t\tif (v==0 && p[1]==0 && p[2]==0)\n\t\t{\n\t\t\tfor (p=p+3; p!=end && *p==0 && p!=oldp+138; p++) {}\n\t\t\tunsigned int repeat = (unsigned int)(p - oldp);\n\t\t\tif (repeat <= 10)\n\t\t\t{\n\t\t\t\textraBits = repeat-3;\n\t\t\t\textraBitsLength = 3;\n\t\t\t\treturn 17;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\textraBits = repeat-11;\n\t\t\t\textraBitsLength = 7;\n\t\t\t\treturn 18;\n\t\t\t}\n\t\t}\n\t\telse if (p!=begin && v==p[-1] && v==p[1] && v==p[2])\n\t\t{\n\t\t\tfor (p=p+3; p!=end && *p==v && p!=oldp+6; p++) {}\n\t\t\tunsigned int repeat = (unsigned int)(p - oldp);\n\t\t\textraBits = repeat-3;\n\t\t\textraBitsLength = 2;\n\t\t\treturn 16;\n\t\t}\n\t}\n\tp++;\n\textraBits = 0;\n\textraBitsLength = 0;\n\treturn v;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\ninline unsigned int CodeLengthEncode(const unsigned int *begin, \n\t\t\t\t\t\t\t\t\t const unsigned int *end, \n\t\t\t\t\t\t\t\t\t const unsigned int *& p, \n\t\t\t\t\t\t\t\t\t unsigned int &extraBits, \n\t\t\t\t\t\t\t\t\t unsigned int &extraBitsLength)\n{\n\tunsigned int v = *p;\n\tif ((end-p) >= 3)\n\t{\n\t\tconst unsigned int *oldp = p;\n\t\tif (v==0 && p[1]==0 && p[2]==0)\n\t\t{\n\t\t\tfor (p=p+3; p!=end && *p==0 && p!=oldp+138; p++) {}\n\t\t\tunsigned int repeat = (unsigned int)(p - oldp);\n\t\t\tif (repeat <= 10)\n\t\t\t{\n\t\t\t\textraBits = repeat-3;\n\t\t\t\textraBitsLength = 3;\n\t\t\t\treturn 17;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\textraBits = repeat-11;\n\t\t\t\textraBitsLength = 7;\n\t\t\t\treturn 18;\n\t\t\t}\n\t\t}\n\t\telse if (p!=begin && v==p[-1] && v==p[1] && v==p[2])\n\t\t{\n\t\t\tfor (p=p+3; p!=end && *p==v && p!=oldp+6; p++) {}\n\t\t\tunsigned int repeat = (unsigned int)(p - oldp);\n\t\t\textraBits = repeat-3;\n\t\t\textraBitsLength = 2;\n\t\t\treturn 16;\n\t\t}\n\t}\n\tp++;\n\textraBits = 0;\n\textraBitsLength = 0;\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "combinedLengths.begin",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HuffmanEncoder::GenerateCodeLengths",
          "args": [
            "codeLengthCodeLengths",
            "7",
            "codeLengthCodeCounts",
            "19"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "combinedLengths.end",
          "args": [],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "codeLengthCodeCounts.begin()",
            "codeLengthCodeCounts.end()",
            "0"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "combinedLengths+hlit+257",
            "distanceCodeLengths",
            "(hdist+1)*sizeof(unsigned int)"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "combinedLengths",
            "literalCodeLengths",
            "(hlit+257)*sizeof(unsigned int)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_if",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_if",
          "args": [
            "RevIt(distanceCodeLengths.end())",
            "RevIt(distanceCodeLengths.begin()+1)",
            "bind2nd(not_equal_to<unsigned int>(), 0)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind2nd",
          "args": [
            "not_equal_to<unsigned int>()",
            "0"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "not_equal_to<unsigned int>",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RevIt",
          "args": [
            "distanceCodeLengths.begin()+1"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RevIt",
          "args": [
            "distanceCodeLengths.end()"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_dynamicDistanceEncoder.Initialize",
          "args": [
            "distanceCodeLengths",
            "30"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "Initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.h",
          "lines": "54-55",
          "snippet": "void Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}",
          "includes": [
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n\nvoid Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}"
        }
      },
      {
        "call_info": {
          "callee": "HuffmanEncoder::GenerateCodeLengths",
          "args": [
            "distanceCodeLengths",
            "15",
            "m_distanceCounts",
            "30"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_if",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_if",
          "args": [
            "RevIt(literalCodeLengths.end())",
            "RevIt(literalCodeLengths.begin()+257)",
            "bind2nd(not_equal_to<unsigned int>(), 0)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind2nd",
          "args": [
            "not_equal_to<unsigned int>()",
            "0"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "not_equal_to<unsigned int>",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RevIt",
          "args": [
            "literalCodeLengths.begin()+257"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RevIt",
          "args": [
            "literalCodeLengths.end()"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HuffmanEncoder::GenerateCodeLengths",
          "args": [
            "literalCodeLengths",
            "15",
            "m_literalCounts",
            "286"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "m_byteBuffer + m_blockStart",
            "m_blockLength"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "~m_blockLength",
            "LITTLE_ENDIAN_ORDER"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "m_blockLength",
            "LITTLE_ENDIAN_ORDER"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FlushBitBuffer",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "LowFirstBitWriter::FlushBitBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "63-81",
          "snippet": "void LowFirstBitWriter::FlushBitBuffer()\n{\n\tif (m_counting)\n\t\tm_bitCount += 8*(m_bitsBuffered > 0);\n\telse\n\t{\n\t\tif (m_bytesBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\tm_bytesBuffered = 0;\n\t\t}\n\t\tif (m_bitsBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->Put((byte)m_buffer);\n\t\t\tm_buffer = 0;\n\t\t\tm_bitsBuffered = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::FlushBitBuffer()\n{\n\tif (m_counting)\n\t\tm_bitCount += 8*(m_bitsBuffered > 0);\n\telse\n\t{\n\t\tif (m_bytesBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\tm_bytesBuffered = 0;\n\t\t}\n\t\tif (m_bitsBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->Put((byte)m_buffer);\n\t\t\tm_buffer = 0;\n\t\t\tm_bitsBuffered = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_blockLength <= 0xffff"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_blockStart + m_blockLength <= m_byteBuffer.size()"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_byteBuffer.size",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EncodeBlock(bool eof, unsigned int blockType)\n{\n\tPutBits(eof, 1);\n\tPutBits(blockType, 2);\n\n\tif (blockType == STORED)\n\t{\n\t\tassert(m_blockStart + m_blockLength <= m_byteBuffer.size());\n\t\tassert(m_blockLength <= 0xffff);\n\t\tFlushBitBuffer();\n\t\tAttachedTransformation()->PutWord16(m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->PutWord16(~m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->Put(m_byteBuffer + m_blockStart, m_blockLength);\n\t}\n\telse\n\t{\n\t\tif (blockType == DYNAMIC)\n\t\t{\n#if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n\t\t\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n\t\t\ttypedef reverse_bidirectional_iterator<unsigned int *, unsigned int> RevIt;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n\ttypedef reverse_iterator<unsigned int *, random_access_iterator_tag, unsigned int> RevIt;\n#else\n\t\t\ttypedef reverse_iterator<unsigned int *> RevIt;\n#endif\n\n\t\t\tFixedSizeSecBlock<unsigned int, 286> literalCodeLengths;\n\t\t\tFixedSizeSecBlock<unsigned int, 30> distanceCodeLengths;\n\n\t\t\tm_literalCounts[256] = 1;\n\t\t\tHuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);\n\t\t\tm_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);\n\t\t\tunsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));\n\n\t\t\tHuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);\n\t\t\tm_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);\n\t\t\tunsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));\n\n\t\t\tSecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);\n\t\t\tmemcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));\n\t\t\tmemcpy(combinedLengths+hlit+257, distanceCodeLengths, (hdist+1)*sizeof(unsigned int));\n\n\t\t\tFixedSizeSecBlock<unsigned int, 19> codeLengthCodeCounts, codeLengthCodeLengths;\n\t\t\tfill(codeLengthCodeCounts.begin(), codeLengthCodeCounts.end(), 0);\n\t\t\tconst unsigned int *p = combinedLengths.begin(), *begin = combinedLengths.begin(), *end = combinedLengths.end();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthCodeCounts[code]++;\n\t\t\t}\n\t\t\tHuffmanEncoder::GenerateCodeLengths(codeLengthCodeLengths, 7, codeLengthCodeCounts, 19);\n\t\t\tHuffmanEncoder codeLengthEncoder(codeLengthCodeLengths, 19);\n\t\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\t\tunsigned int hclen = 19;\n\t\t\twhile (hclen > 4 && codeLengthCodeLengths[border[hclen-1]] == 0)\n\t\t\t\thclen--;\n\t\t\thclen -= 4;\n\n\t\t\tPutBits(hlit, 5);\n\t\t\tPutBits(hdist, 5);\n\t\t\tPutBits(hclen, 4);\n\n\t\t\tfor (unsigned int i=0; i<hclen+4; i++)\n\t\t\t\tPutBits(codeLengthCodeLengths[border[i]], 3);\n\n\t\t\tp = combinedLengths.begin();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthEncoder.Encode(*this, code);\n\t\t\t\tPutBits(extraBits, extraBitsLength);\n\t\t\t}\n\t\t}\n\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanEncoder &literalEncoder = (blockType == STATIC) ? m_staticLiteralEncoder : m_dynamicLiteralEncoder;\n\t\tconst HuffmanEncoder &distanceEncoder = (blockType == STATIC) ? m_staticDistanceEncoder : m_dynamicDistanceEncoder;\n\n\t\tfor (unsigned int i=0; i<m_matchBufferEnd; i++)\n\t\t{\n\t\t\tunsigned int literalCode = m_matchBuffer[i].literalCode;\n\t\t\tliteralEncoder.Encode(*this, literalCode);\n\t\t\tif (literalCode >= 257)\n\t\t\t{\n\t\t\t\tassert(literalCode <= 285);\n\t\t\t\tPutBits(m_matchBuffer[i].literalExtra, lengthExtraBits[literalCode-257]);\n\t\t\t\tunsigned int distanceCode = m_matchBuffer[i].distanceCode;\n\t\t\t\tdistanceEncoder.Encode(*this, distanceCode);\n\t\t\t\tPutBits(m_matchBuffer[i].distanceExtra, distanceExtraBits[distanceCode]);\n\t\t\t}\n\t\t}\n\t\tliteralEncoder.Encode(*this, 256);\t// end of block\n\t}\n}"
  },
  {
    "function_name": "CodeLengthEncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "590-630",
    "snippet": "inline unsigned int CodeLengthEncode(const unsigned int *begin, \n\t\t\t\t\t\t\t\t\t const unsigned int *end, \n\t\t\t\t\t\t\t\t\t const unsigned int *& p, \n\t\t\t\t\t\t\t\t\t unsigned int &extraBits, \n\t\t\t\t\t\t\t\t\t unsigned int &extraBitsLength)\n{\n\tunsigned int v = *p;\n\tif ((end-p) >= 3)\n\t{\n\t\tconst unsigned int *oldp = p;\n\t\tif (v==0 && p[1]==0 && p[2]==0)\n\t\t{\n\t\t\tfor (p=p+3; p!=end && *p==0 && p!=oldp+138; p++) {}\n\t\t\tunsigned int repeat = (unsigned int)(p - oldp);\n\t\t\tif (repeat <= 10)\n\t\t\t{\n\t\t\t\textraBits = repeat-3;\n\t\t\t\textraBitsLength = 3;\n\t\t\t\treturn 17;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\textraBits = repeat-11;\n\t\t\t\textraBitsLength = 7;\n\t\t\t\treturn 18;\n\t\t\t}\n\t\t}\n\t\telse if (p!=begin && v==p[-1] && v==p[1] && v==p[2])\n\t\t{\n\t\t\tfor (p=p+3; p!=end && *p==v && p!=oldp+6; p++) {}\n\t\t\tunsigned int repeat = (unsigned int)(p - oldp);\n\t\t\textraBits = repeat-3;\n\t\t\textraBitsLength = 2;\n\t\t\treturn 16;\n\t\t}\n\t}\n\tp++;\n\textraBits = 0;\n\textraBitsLength = 0;\n\treturn v;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\ninline unsigned int CodeLengthEncode(const unsigned int *begin, \n\t\t\t\t\t\t\t\t\t const unsigned int *end, \n\t\t\t\t\t\t\t\t\t const unsigned int *& p, \n\t\t\t\t\t\t\t\t\t unsigned int &extraBits, \n\t\t\t\t\t\t\t\t\t unsigned int &extraBitsLength)\n{\n\tunsigned int v = *p;\n\tif ((end-p) >= 3)\n\t{\n\t\tconst unsigned int *oldp = p;\n\t\tif (v==0 && p[1]==0 && p[2]==0)\n\t\t{\n\t\t\tfor (p=p+3; p!=end && *p==0 && p!=oldp+138; p++) {}\n\t\t\tunsigned int repeat = (unsigned int)(p - oldp);\n\t\t\tif (repeat <= 10)\n\t\t\t{\n\t\t\t\textraBits = repeat-3;\n\t\t\t\textraBitsLength = 3;\n\t\t\t\treturn 17;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\textraBits = repeat-11;\n\t\t\t\textraBitsLength = 7;\n\t\t\t\treturn 18;\n\t\t\t}\n\t\t}\n\t\telse if (p!=begin && v==p[-1] && v==p[1] && v==p[2])\n\t\t{\n\t\t\tfor (p=p+3; p!=end && *p==v && p!=oldp+6; p++) {}\n\t\t\tunsigned int repeat = (unsigned int)(p - oldp);\n\t\t\textraBits = repeat-3;\n\t\t\textraBitsLength = 2;\n\t\t\treturn 16;\n\t\t}\n\t}\n\tp++;\n\textraBits = 0;\n\textraBitsLength = 0;\n\treturn v;\n}"
  },
  {
    "function_name": "Deflator::MatchFound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "550-588",
    "snippet": "void Deflator::MatchFound(unsigned int distance, unsigned int length)\n{\n\tif (m_matchBufferEnd == m_matchBuffer.size())\n\t\tEndBlock(false);\n\n\tstatic const unsigned int lengthCodes[] = {\n\t\t257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268,\n\t\t269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,\n\t\t273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274,\n\t\t275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,\n\t\t277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n\t\t278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n\t\t279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n\t\t280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,\n\t\t281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n\t\t281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n\t\t282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n\t\t282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n\t\t283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n\t\t283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n\t\t284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n\t\t284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285};\n\tstatic const unsigned int lengthBases[] = {3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};\n\tstatic const unsigned int distanceBases[30] = \n\t\t{1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577};\n\n\tEncodedMatch &m = m_matchBuffer[m_matchBufferEnd++];\n\tassert(length >= 3);\n\tunsigned int lengthCode = lengthCodes[length-3];\n\tm.literalCode = lengthCode;\n\tm.literalExtra = length - lengthBases[lengthCode-257];\n\tunsigned int distanceCode = (unsigned int)(upper_bound(distanceBases, distanceBases+30, distance) - distanceBases - 1);\n\tm.distanceCode = distanceCode;\n\tm.distanceExtra = distance - distanceBases[distanceCode];\n\n\tm_literalCounts[lengthCode]++;\n\tm_distanceCounts[distanceCode]++;\n\tm_blockLength += length;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "upper_bound",
          "args": [
            "distanceBases",
            "distanceBases+30",
            "distance"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length >= 3"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EndBlock",
          "args": [
            "false"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::EndBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "738-799",
          "snippet": "void Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_matchBuffer.size",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::MatchFound(unsigned int distance, unsigned int length)\n{\n\tif (m_matchBufferEnd == m_matchBuffer.size())\n\t\tEndBlock(false);\n\n\tstatic const unsigned int lengthCodes[] = {\n\t\t257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268,\n\t\t269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,\n\t\t273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274,\n\t\t275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,\n\t\t277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n\t\t278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n\t\t279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n\t\t280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,\n\t\t281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n\t\t281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n\t\t282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n\t\t282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n\t\t283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n\t\t283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n\t\t284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n\t\t284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285};\n\tstatic const unsigned int lengthBases[] = {3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};\n\tstatic const unsigned int distanceBases[30] = \n\t\t{1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577};\n\n\tEncodedMatch &m = m_matchBuffer[m_matchBufferEnd++];\n\tassert(length >= 3);\n\tunsigned int lengthCode = lengthCodes[length-3];\n\tm.literalCode = lengthCode;\n\tm.literalExtra = length - lengthBases[lengthCode-257];\n\tunsigned int distanceCode = (unsigned int)(upper_bound(distanceBases, distanceBases+30, distance) - distanceBases - 1);\n\tm.distanceCode = distanceCode;\n\tm.distanceExtra = distance - distanceBases[distanceCode];\n\n\tm_literalCounts[lengthCode]++;\n\tm_distanceCounts[distanceCode]++;\n\tm_blockLength += length;\n}"
  },
  {
    "function_name": "Deflator::LiteralByte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "540-548",
    "snippet": "void Deflator::LiteralByte(byte b)\n{\n\tif (m_matchBufferEnd == m_matchBuffer.size())\n\t\tEndBlock(false);\n\n\tm_matchBuffer[m_matchBufferEnd++].literalCode = b;\n\tm_literalCounts[b]++;\n\tm_blockLength++;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EndBlock",
          "args": [
            "false"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::EndBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "738-799",
          "snippet": "void Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_matchBuffer.size",
          "args": [],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::LiteralByte(byte b)\n{\n\tif (m_matchBufferEnd == m_matchBuffer.size())\n\t\tEndBlock(false);\n\n\tm_matchBuffer[m_matchBufferEnd++].literalCode = b;\n\tm_literalCounts[b]++;\n\tm_blockLength++;\n}"
  },
  {
    "function_name": "Deflator::IsolatedFlush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "526-538",
    "snippet": "bool Deflator::IsolatedFlush(bool hardFlush, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"Deflator\");\n\n\tm_minLookahead = 0;\n\tProcessBuffer();\n\tm_minLookahead = MAX_MATCH;\n\tEndBlock(false);\n\tif (hardFlush)\n\t\tEncodeBlock(false, STORED);\n\treturn false;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EncodeBlock",
          "args": [
            "false",
            "STORED"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::EncodeBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "632-736",
          "snippet": "void Deflator::EncodeBlock(bool eof, unsigned int blockType)\n{\n\tPutBits(eof, 1);\n\tPutBits(blockType, 2);\n\n\tif (blockType == STORED)\n\t{\n\t\tassert(m_blockStart + m_blockLength <= m_byteBuffer.size());\n\t\tassert(m_blockLength <= 0xffff);\n\t\tFlushBitBuffer();\n\t\tAttachedTransformation()->PutWord16(m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->PutWord16(~m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->Put(m_byteBuffer + m_blockStart, m_blockLength);\n\t}\n\telse\n\t{\n\t\tif (blockType == DYNAMIC)\n\t\t{\n#if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n\t\t\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n\t\t\ttypedef reverse_bidirectional_iterator<unsigned int *, unsigned int> RevIt;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n\ttypedef reverse_iterator<unsigned int *, random_access_iterator_tag, unsigned int> RevIt;\n#else\n\t\t\ttypedef reverse_iterator<unsigned int *> RevIt;\n#endif\n\n\t\t\tFixedSizeSecBlock<unsigned int, 286> literalCodeLengths;\n\t\t\tFixedSizeSecBlock<unsigned int, 30> distanceCodeLengths;\n\n\t\t\tm_literalCounts[256] = 1;\n\t\t\tHuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);\n\t\t\tm_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);\n\t\t\tunsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));\n\n\t\t\tHuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);\n\t\t\tm_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);\n\t\t\tunsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));\n\n\t\t\tSecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);\n\t\t\tmemcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));\n\t\t\tmemcpy(combinedLengths+hlit+257, distanceCodeLengths, (hdist+1)*sizeof(unsigned int));\n\n\t\t\tFixedSizeSecBlock<unsigned int, 19> codeLengthCodeCounts, codeLengthCodeLengths;\n\t\t\tfill(codeLengthCodeCounts.begin(), codeLengthCodeCounts.end(), 0);\n\t\t\tconst unsigned int *p = combinedLengths.begin(), *begin = combinedLengths.begin(), *end = combinedLengths.end();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthCodeCounts[code]++;\n\t\t\t}\n\t\t\tHuffmanEncoder::GenerateCodeLengths(codeLengthCodeLengths, 7, codeLengthCodeCounts, 19);\n\t\t\tHuffmanEncoder codeLengthEncoder(codeLengthCodeLengths, 19);\n\t\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\t\tunsigned int hclen = 19;\n\t\t\twhile (hclen > 4 && codeLengthCodeLengths[border[hclen-1]] == 0)\n\t\t\t\thclen--;\n\t\t\thclen -= 4;\n\n\t\t\tPutBits(hlit, 5);\n\t\t\tPutBits(hdist, 5);\n\t\t\tPutBits(hclen, 4);\n\n\t\t\tfor (unsigned int i=0; i<hclen+4; i++)\n\t\t\t\tPutBits(codeLengthCodeLengths[border[i]], 3);\n\n\t\t\tp = combinedLengths.begin();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthEncoder.Encode(*this, code);\n\t\t\t\tPutBits(extraBits, extraBitsLength);\n\t\t\t}\n\t\t}\n\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanEncoder &literalEncoder = (blockType == STATIC) ? m_staticLiteralEncoder : m_dynamicLiteralEncoder;\n\t\tconst HuffmanEncoder &distanceEncoder = (blockType == STATIC) ? m_staticDistanceEncoder : m_dynamicDistanceEncoder;\n\n\t\tfor (unsigned int i=0; i<m_matchBufferEnd; i++)\n\t\t{\n\t\t\tunsigned int literalCode = m_matchBuffer[i].literalCode;\n\t\t\tliteralEncoder.Encode(*this, literalCode);\n\t\t\tif (literalCode >= 257)\n\t\t\t{\n\t\t\t\tassert(literalCode <= 285);\n\t\t\t\tPutBits(m_matchBuffer[i].literalExtra, lengthExtraBits[literalCode-257]);\n\t\t\t\tunsigned int distanceCode = m_matchBuffer[i].distanceCode;\n\t\t\t\tdistanceEncoder.Encode(*this, distanceCode);\n\t\t\t\tPutBits(m_matchBuffer[i].distanceExtra, distanceExtraBits[distanceCode]);\n\t\t\t}\n\t\t}\n\t\tliteralEncoder.Encode(*this, 256);\t// end of block\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EncodeBlock(bool eof, unsigned int blockType)\n{\n\tPutBits(eof, 1);\n\tPutBits(blockType, 2);\n\n\tif (blockType == STORED)\n\t{\n\t\tassert(m_blockStart + m_blockLength <= m_byteBuffer.size());\n\t\tassert(m_blockLength <= 0xffff);\n\t\tFlushBitBuffer();\n\t\tAttachedTransformation()->PutWord16(m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->PutWord16(~m_blockLength, LITTLE_ENDIAN_ORDER);\n\t\tAttachedTransformation()->Put(m_byteBuffer + m_blockStart, m_blockLength);\n\t}\n\telse\n\t{\n\t\tif (blockType == DYNAMIC)\n\t\t{\n#if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n\t\t\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n\t\t\ttypedef reverse_bidirectional_iterator<unsigned int *, unsigned int> RevIt;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n\ttypedef reverse_iterator<unsigned int *, random_access_iterator_tag, unsigned int> RevIt;\n#else\n\t\t\ttypedef reverse_iterator<unsigned int *> RevIt;\n#endif\n\n\t\t\tFixedSizeSecBlock<unsigned int, 286> literalCodeLengths;\n\t\t\tFixedSizeSecBlock<unsigned int, 30> distanceCodeLengths;\n\n\t\t\tm_literalCounts[256] = 1;\n\t\t\tHuffmanEncoder::GenerateCodeLengths(literalCodeLengths, 15, m_literalCounts, 286);\n\t\t\tm_dynamicLiteralEncoder.Initialize(literalCodeLengths, 286);\n\t\t\tunsigned int hlit = (unsigned int)(find_if(RevIt(literalCodeLengths.end()), RevIt(literalCodeLengths.begin()+257), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (literalCodeLengths.begin()+257));\n\n\t\t\tHuffmanEncoder::GenerateCodeLengths(distanceCodeLengths, 15, m_distanceCounts, 30);\n\t\t\tm_dynamicDistanceEncoder.Initialize(distanceCodeLengths, 30);\n\t\t\tunsigned int hdist = (unsigned int)(find_if(RevIt(distanceCodeLengths.end()), RevIt(distanceCodeLengths.begin()+1), bind2nd(not_equal_to<unsigned int>(), 0)).base() - (distanceCodeLengths.begin()+1));\n\n\t\t\tSecBlockWithHint<unsigned int, 286+30> combinedLengths(hlit+257+hdist+1);\n\t\t\tmemcpy(combinedLengths, literalCodeLengths, (hlit+257)*sizeof(unsigned int));\n\t\t\tmemcpy(combinedLengths+hlit+257, distanceCodeLengths, (hdist+1)*sizeof(unsigned int));\n\n\t\t\tFixedSizeSecBlock<unsigned int, 19> codeLengthCodeCounts, codeLengthCodeLengths;\n\t\t\tfill(codeLengthCodeCounts.begin(), codeLengthCodeCounts.end(), 0);\n\t\t\tconst unsigned int *p = combinedLengths.begin(), *begin = combinedLengths.begin(), *end = combinedLengths.end();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthCodeCounts[code]++;\n\t\t\t}\n\t\t\tHuffmanEncoder::GenerateCodeLengths(codeLengthCodeLengths, 7, codeLengthCodeCounts, 19);\n\t\t\tHuffmanEncoder codeLengthEncoder(codeLengthCodeLengths, 19);\n\t\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\t\tunsigned int hclen = 19;\n\t\t\twhile (hclen > 4 && codeLengthCodeLengths[border[hclen-1]] == 0)\n\t\t\t\thclen--;\n\t\t\thclen -= 4;\n\n\t\t\tPutBits(hlit, 5);\n\t\t\tPutBits(hdist, 5);\n\t\t\tPutBits(hclen, 4);\n\n\t\t\tfor (unsigned int i=0; i<hclen+4; i++)\n\t\t\t\tPutBits(codeLengthCodeLengths[border[i]], 3);\n\n\t\t\tp = combinedLengths.begin();\n\t\t\twhile (p != end)\n\t\t\t{\n\t\t\t\tunsigned int code, extraBits, extraBitsLength;\n\t\t\t\tcode = CodeLengthEncode(begin, end, p, extraBits, extraBitsLength);\n\t\t\t\tcodeLengthEncoder.Encode(*this, code);\n\t\t\t\tPutBits(extraBits, extraBitsLength);\n\t\t\t}\n\t\t}\n\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanEncoder &literalEncoder = (blockType == STATIC) ? m_staticLiteralEncoder : m_dynamicLiteralEncoder;\n\t\tconst HuffmanEncoder &distanceEncoder = (blockType == STATIC) ? m_staticDistanceEncoder : m_dynamicDistanceEncoder;\n\n\t\tfor (unsigned int i=0; i<m_matchBufferEnd; i++)\n\t\t{\n\t\t\tunsigned int literalCode = m_matchBuffer[i].literalCode;\n\t\t\tliteralEncoder.Encode(*this, literalCode);\n\t\t\tif (literalCode >= 257)\n\t\t\t{\n\t\t\t\tassert(literalCode <= 285);\n\t\t\t\tPutBits(m_matchBuffer[i].literalExtra, lengthExtraBits[literalCode-257]);\n\t\t\t\tunsigned int distanceCode = m_matchBuffer[i].distanceCode;\n\t\t\t\tdistanceEncoder.Encode(*this, distanceCode);\n\t\t\t\tPutBits(m_matchBuffer[i].distanceExtra, distanceExtraBits[distanceCode]);\n\t\t\t}\n\t\t}\n\t\tliteralEncoder.Encode(*this, 256);\t// end of block\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EndBlock",
          "args": [
            "false"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::EndBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "738-799",
          "snippet": "void Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessBuffer",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::ProcessBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "425-494",
          "snippet": "void Deflator::ProcessBuffer()\n{\n\tif (!m_headerWritten)\n\t{\n\t\tWritePrestreamHeader();\n\t\tm_headerWritten = true;\n\t}\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tm_stringStart += m_lookahead;\n\t\tm_lookahead = 0;\n\t\tm_blockLength = m_stringStart - m_blockStart;\n\t\tm_matchAvailable = false;\n\t\treturn;\n\t}\n\n\twhile (m_lookahead > m_minLookahead)\n\t{\n\t\twhile (m_dictionaryEnd < m_stringStart && m_dictionaryEnd+3 <= m_stringStart+m_lookahead)\n\t\t\tInsertString(m_dictionaryEnd++);\n\n\t\tif (m_matchAvailable)\n\t\t{\n\t\t\tunsigned int matchPosition, matchLength;\n\t\t\tbool usePreviousMatch;\n\t\t\tif (m_previousLength >= MAX_LAZYLENGTH)\n\t\t\t\tusePreviousMatch = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmatchLength = LongestMatch(matchPosition);\n\t\t\t\tusePreviousMatch = (matchLength == 0);\n\t\t\t}\n\t\t\tif (usePreviousMatch)\n\t\t\t{\n\t\t\t\tMatchFound(m_stringStart-1-m_previousMatch, m_previousLength);\n\t\t\t\tm_stringStart += m_previousLength-1;\n\t\t\t\tm_lookahead -= m_previousLength-1;\n\t\t\t\tm_matchAvailable = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_previousLength = matchLength;\n\t\t\t\tm_previousMatch = matchPosition;\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\t\t\tm_stringStart++;\n\t\t\t\tm_lookahead--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_previousLength = 0;\n\t\t\tm_previousLength = LongestMatch(m_previousMatch);\n\t\t\tif (m_previousLength)\n\t\t\t\tm_matchAvailable = true;\n\t\t\telse\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart]);\n\t\t\tm_stringStart++;\n\t\t\tm_lookahead--;\n\t\t}\n\n\t\tassert(m_stringStart - (m_blockStart+m_blockLength) == (unsigned int)m_matchAvailable);\n\t}\n\n\tif (m_minLookahead == 0 && m_matchAvailable)\n\t{\n\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\tm_matchAvailable = false;\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::ProcessBuffer()\n{\n\tif (!m_headerWritten)\n\t{\n\t\tWritePrestreamHeader();\n\t\tm_headerWritten = true;\n\t}\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tm_stringStart += m_lookahead;\n\t\tm_lookahead = 0;\n\t\tm_blockLength = m_stringStart - m_blockStart;\n\t\tm_matchAvailable = false;\n\t\treturn;\n\t}\n\n\twhile (m_lookahead > m_minLookahead)\n\t{\n\t\twhile (m_dictionaryEnd < m_stringStart && m_dictionaryEnd+3 <= m_stringStart+m_lookahead)\n\t\t\tInsertString(m_dictionaryEnd++);\n\n\t\tif (m_matchAvailable)\n\t\t{\n\t\t\tunsigned int matchPosition, matchLength;\n\t\t\tbool usePreviousMatch;\n\t\t\tif (m_previousLength >= MAX_LAZYLENGTH)\n\t\t\t\tusePreviousMatch = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmatchLength = LongestMatch(matchPosition);\n\t\t\t\tusePreviousMatch = (matchLength == 0);\n\t\t\t}\n\t\t\tif (usePreviousMatch)\n\t\t\t{\n\t\t\t\tMatchFound(m_stringStart-1-m_previousMatch, m_previousLength);\n\t\t\t\tm_stringStart += m_previousLength-1;\n\t\t\t\tm_lookahead -= m_previousLength-1;\n\t\t\t\tm_matchAvailable = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_previousLength = matchLength;\n\t\t\t\tm_previousMatch = matchPosition;\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\t\t\tm_stringStart++;\n\t\t\t\tm_lookahead--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_previousLength = 0;\n\t\t\tm_previousLength = LongestMatch(m_previousMatch);\n\t\t\tif (m_previousLength)\n\t\t\t\tm_matchAvailable = true;\n\t\t\telse\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart]);\n\t\t\tm_stringStart++;\n\t\t\tm_lookahead--;\n\t\t}\n\n\t\tassert(m_stringStart - (m_blockStart+m_blockLength) == (unsigned int)m_matchAvailable);\n\t}\n\n\tif (m_minLookahead == 0 && m_matchAvailable)\n\t{\n\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\tm_matchAvailable = false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"Deflator\""
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nbool Deflator::IsolatedFlush(bool hardFlush, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"Deflator\");\n\n\tm_minLookahead = 0;\n\tProcessBuffer();\n\tm_minLookahead = MAX_MATCH;\n\tEndBlock(false);\n\tif (hardFlush)\n\t\tEncodeBlock(false, STORED);\n\treturn false;\n}"
  },
  {
    "function_name": "Deflator::Put2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "496-524",
    "snippet": "size_t Deflator::Put2(const byte *str, size_t length, int messageEnd, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"Deflator\");\n\n\tsize_t accepted = 0;\n\twhile (accepted < length)\n\t{\n\t\tunsigned int newAccepted = FillWindow(str+accepted, length-accepted);\n\t\tProcessBuffer();\n\t\t// call ProcessUncompressedData() after WritePrestreamHeader()\n\t\tProcessUncompressedData(str+accepted, newAccepted);\n\t\taccepted += newAccepted;\n\t}\n\tassert(accepted == length);\n\n\tif (messageEnd)\n\t{\n\t\tm_minLookahead = 0;\n\t\tProcessBuffer();\n\t\tEndBlock(true);\n\t\tFlushBitBuffer();\n\t\tWritePoststreamTail();\n\t\tReset();\n\t}\n\n\tOutput(0, NULL, 0, messageEnd, blocking);\n\treturn 0;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Output",
          "args": [
            "0",
            "NULL",
            "0",
            "messageEnd",
            "blocking"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Reset",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "Panama<B>::Reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "16-22",
          "snippet": "void Panama<B>::Reset()\n{\n\tmemset(m_state, 0, m_state.SizeInBytes());\n#if CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE\n\tm_state[17] = HasSSSE3();\n#endif\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nvoid Panama<B>::Reset()\n{\n\tmemset(m_state, 0, m_state.SizeInBytes());\n#if CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE\n\tm_state[17] = HasSSSE3();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "WritePoststreamTail",
          "args": [],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "WritePoststreamTail",
          "container": "Deflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.h",
          "lines": "79-79",
          "snippet": "virtual void WritePoststreamTail() {}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"filters.h\"\n\nDeflator {\n  virtual void WritePoststreamTail() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FlushBitBuffer",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "LowFirstBitWriter::FlushBitBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "63-81",
          "snippet": "void LowFirstBitWriter::FlushBitBuffer()\n{\n\tif (m_counting)\n\t\tm_bitCount += 8*(m_bitsBuffered > 0);\n\telse\n\t{\n\t\tif (m_bytesBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\tm_bytesBuffered = 0;\n\t\t}\n\t\tif (m_bitsBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->Put((byte)m_buffer);\n\t\t\tm_buffer = 0;\n\t\t\tm_bitsBuffered = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::FlushBitBuffer()\n{\n\tif (m_counting)\n\t\tm_bitCount += 8*(m_bitsBuffered > 0);\n\telse\n\t{\n\t\tif (m_bytesBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\tm_bytesBuffered = 0;\n\t\t}\n\t\tif (m_bitsBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->Put((byte)m_buffer);\n\t\t\tm_buffer = 0;\n\t\t\tm_bitsBuffered = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EndBlock",
          "args": [
            "true"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::EndBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "738-799",
          "snippet": "void Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessBuffer",
          "args": [],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::ProcessBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "425-494",
          "snippet": "void Deflator::ProcessBuffer()\n{\n\tif (!m_headerWritten)\n\t{\n\t\tWritePrestreamHeader();\n\t\tm_headerWritten = true;\n\t}\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tm_stringStart += m_lookahead;\n\t\tm_lookahead = 0;\n\t\tm_blockLength = m_stringStart - m_blockStart;\n\t\tm_matchAvailable = false;\n\t\treturn;\n\t}\n\n\twhile (m_lookahead > m_minLookahead)\n\t{\n\t\twhile (m_dictionaryEnd < m_stringStart && m_dictionaryEnd+3 <= m_stringStart+m_lookahead)\n\t\t\tInsertString(m_dictionaryEnd++);\n\n\t\tif (m_matchAvailable)\n\t\t{\n\t\t\tunsigned int matchPosition, matchLength;\n\t\t\tbool usePreviousMatch;\n\t\t\tif (m_previousLength >= MAX_LAZYLENGTH)\n\t\t\t\tusePreviousMatch = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmatchLength = LongestMatch(matchPosition);\n\t\t\t\tusePreviousMatch = (matchLength == 0);\n\t\t\t}\n\t\t\tif (usePreviousMatch)\n\t\t\t{\n\t\t\t\tMatchFound(m_stringStart-1-m_previousMatch, m_previousLength);\n\t\t\t\tm_stringStart += m_previousLength-1;\n\t\t\t\tm_lookahead -= m_previousLength-1;\n\t\t\t\tm_matchAvailable = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_previousLength = matchLength;\n\t\t\t\tm_previousMatch = matchPosition;\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\t\t\tm_stringStart++;\n\t\t\t\tm_lookahead--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_previousLength = 0;\n\t\t\tm_previousLength = LongestMatch(m_previousMatch);\n\t\t\tif (m_previousLength)\n\t\t\t\tm_matchAvailable = true;\n\t\t\telse\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart]);\n\t\t\tm_stringStart++;\n\t\t\tm_lookahead--;\n\t\t}\n\n\t\tassert(m_stringStart - (m_blockStart+m_blockLength) == (unsigned int)m_matchAvailable);\n\t}\n\n\tif (m_minLookahead == 0 && m_matchAvailable)\n\t{\n\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\tm_matchAvailable = false;\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::ProcessBuffer()\n{\n\tif (!m_headerWritten)\n\t{\n\t\tWritePrestreamHeader();\n\t\tm_headerWritten = true;\n\t}\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tm_stringStart += m_lookahead;\n\t\tm_lookahead = 0;\n\t\tm_blockLength = m_stringStart - m_blockStart;\n\t\tm_matchAvailable = false;\n\t\treturn;\n\t}\n\n\twhile (m_lookahead > m_minLookahead)\n\t{\n\t\twhile (m_dictionaryEnd < m_stringStart && m_dictionaryEnd+3 <= m_stringStart+m_lookahead)\n\t\t\tInsertString(m_dictionaryEnd++);\n\n\t\tif (m_matchAvailable)\n\t\t{\n\t\t\tunsigned int matchPosition, matchLength;\n\t\t\tbool usePreviousMatch;\n\t\t\tif (m_previousLength >= MAX_LAZYLENGTH)\n\t\t\t\tusePreviousMatch = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmatchLength = LongestMatch(matchPosition);\n\t\t\t\tusePreviousMatch = (matchLength == 0);\n\t\t\t}\n\t\t\tif (usePreviousMatch)\n\t\t\t{\n\t\t\t\tMatchFound(m_stringStart-1-m_previousMatch, m_previousLength);\n\t\t\t\tm_stringStart += m_previousLength-1;\n\t\t\t\tm_lookahead -= m_previousLength-1;\n\t\t\t\tm_matchAvailable = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_previousLength = matchLength;\n\t\t\t\tm_previousMatch = matchPosition;\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\t\t\tm_stringStart++;\n\t\t\t\tm_lookahead--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_previousLength = 0;\n\t\t\tm_previousLength = LongestMatch(m_previousMatch);\n\t\t\tif (m_previousLength)\n\t\t\t\tm_matchAvailable = true;\n\t\t\telse\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart]);\n\t\t\tm_stringStart++;\n\t\t\tm_lookahead--;\n\t\t}\n\n\t\tassert(m_stringStart - (m_blockStart+m_blockLength) == (unsigned int)m_matchAvailable);\n\t}\n\n\tif (m_minLookahead == 0 && m_matchAvailable)\n\t{\n\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\tm_matchAvailable = false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "accepted == length"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcessUncompressedData",
          "args": [
            "str+accepted",
            "newAccepted"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessUncompressedData",
          "container": "Deflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.h",
          "lines": "78-78",
          "snippet": "virtual void ProcessUncompressedData(const byte *string, size_t length) {}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"filters.h\"\n\nDeflator {\n  virtual void ProcessUncompressedData(const byte *string, size_t length) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FillWindow",
          "args": [
            "str+accepted",
            "length-accepted"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::FillWindow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "327-361",
          "snippet": "unsigned int Deflator::FillWindow(const byte *str, size_t length)\n{\n\tunsigned int maxBlockSize = (unsigned int)STDMIN(2UL*DSIZE, 0xffffUL);\n\n\tif (m_stringStart >= maxBlockSize - MAX_MATCH)\n\t{\n\t\tif (m_blockStart < DSIZE)\n\t\t\tEndBlock(false);\n\n\t\tmemcpy(m_byteBuffer, m_byteBuffer + DSIZE, DSIZE);\n\n\t\tm_dictionaryEnd = m_dictionaryEnd < DSIZE ? 0 : m_dictionaryEnd-DSIZE;\n\t\tassert(m_stringStart >= DSIZE);\n\t\tm_stringStart -= DSIZE;\n\t\tassert(!m_matchAvailable || m_previousMatch >= DSIZE);\n\t\tm_previousMatch -= DSIZE;\n\t\tassert(m_blockStart >= DSIZE);\n\t\tm_blockStart -= DSIZE;\n\n\t\tunsigned int i;\n\n\t\tfor (i=0; i<HSIZE; i++)\n\t\t\tm_head[i] = SaturatingSubtract(m_head[i], DSIZE);\n\n\t\tfor (i=0; i<DSIZE; i++)\n\t\t\tm_prev[i] = SaturatingSubtract(m_prev[i], DSIZE);\n\t}\n\n\tassert(maxBlockSize > m_stringStart+m_lookahead);\n\tunsigned int accepted = UnsignedMin(maxBlockSize-(m_stringStart+m_lookahead), length);\n\tassert(accepted > 0);\n\tmemcpy(m_byteBuffer + m_stringStart + m_lookahead, str, accepted);\n\tm_lookahead += accepted;\n\treturn accepted;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nunsigned int Deflator::FillWindow(const byte *str, size_t length)\n{\n\tunsigned int maxBlockSize = (unsigned int)STDMIN(2UL*DSIZE, 0xffffUL);\n\n\tif (m_stringStart >= maxBlockSize - MAX_MATCH)\n\t{\n\t\tif (m_blockStart < DSIZE)\n\t\t\tEndBlock(false);\n\n\t\tmemcpy(m_byteBuffer, m_byteBuffer + DSIZE, DSIZE);\n\n\t\tm_dictionaryEnd = m_dictionaryEnd < DSIZE ? 0 : m_dictionaryEnd-DSIZE;\n\t\tassert(m_stringStart >= DSIZE);\n\t\tm_stringStart -= DSIZE;\n\t\tassert(!m_matchAvailable || m_previousMatch >= DSIZE);\n\t\tm_previousMatch -= DSIZE;\n\t\tassert(m_blockStart >= DSIZE);\n\t\tm_blockStart -= DSIZE;\n\n\t\tunsigned int i;\n\n\t\tfor (i=0; i<HSIZE; i++)\n\t\t\tm_head[i] = SaturatingSubtract(m_head[i], DSIZE);\n\n\t\tfor (i=0; i<DSIZE; i++)\n\t\t\tm_prev[i] = SaturatingSubtract(m_prev[i], DSIZE);\n\t}\n\n\tassert(maxBlockSize > m_stringStart+m_lookahead);\n\tunsigned int accepted = UnsignedMin(maxBlockSize-(m_stringStart+m_lookahead), length);\n\tassert(accepted > 0);\n\tmemcpy(m_byteBuffer + m_stringStart + m_lookahead, str, accepted);\n\tm_lookahead += accepted;\n\treturn accepted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"Deflator\""
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nsize_t Deflator::Put2(const byte *str, size_t length, int messageEnd, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"Deflator\");\n\n\tsize_t accepted = 0;\n\twhile (accepted < length)\n\t{\n\t\tunsigned int newAccepted = FillWindow(str+accepted, length-accepted);\n\t\tProcessBuffer();\n\t\t// call ProcessUncompressedData() after WritePrestreamHeader()\n\t\tProcessUncompressedData(str+accepted, newAccepted);\n\t\taccepted += newAccepted;\n\t}\n\tassert(accepted == length);\n\n\tif (messageEnd)\n\t{\n\t\tm_minLookahead = 0;\n\t\tProcessBuffer();\n\t\tEndBlock(true);\n\t\tFlushBitBuffer();\n\t\tWritePoststreamTail();\n\t\tReset();\n\t}\n\n\tOutput(0, NULL, 0, messageEnd, blocking);\n\treturn 0;\n}"
  },
  {
    "function_name": "Deflator::ProcessBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "425-494",
    "snippet": "void Deflator::ProcessBuffer()\n{\n\tif (!m_headerWritten)\n\t{\n\t\tWritePrestreamHeader();\n\t\tm_headerWritten = true;\n\t}\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tm_stringStart += m_lookahead;\n\t\tm_lookahead = 0;\n\t\tm_blockLength = m_stringStart - m_blockStart;\n\t\tm_matchAvailable = false;\n\t\treturn;\n\t}\n\n\twhile (m_lookahead > m_minLookahead)\n\t{\n\t\twhile (m_dictionaryEnd < m_stringStart && m_dictionaryEnd+3 <= m_stringStart+m_lookahead)\n\t\t\tInsertString(m_dictionaryEnd++);\n\n\t\tif (m_matchAvailable)\n\t\t{\n\t\t\tunsigned int matchPosition, matchLength;\n\t\t\tbool usePreviousMatch;\n\t\t\tif (m_previousLength >= MAX_LAZYLENGTH)\n\t\t\t\tusePreviousMatch = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmatchLength = LongestMatch(matchPosition);\n\t\t\t\tusePreviousMatch = (matchLength == 0);\n\t\t\t}\n\t\t\tif (usePreviousMatch)\n\t\t\t{\n\t\t\t\tMatchFound(m_stringStart-1-m_previousMatch, m_previousLength);\n\t\t\t\tm_stringStart += m_previousLength-1;\n\t\t\t\tm_lookahead -= m_previousLength-1;\n\t\t\t\tm_matchAvailable = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_previousLength = matchLength;\n\t\t\t\tm_previousMatch = matchPosition;\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\t\t\tm_stringStart++;\n\t\t\t\tm_lookahead--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_previousLength = 0;\n\t\t\tm_previousLength = LongestMatch(m_previousMatch);\n\t\t\tif (m_previousLength)\n\t\t\t\tm_matchAvailable = true;\n\t\t\telse\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart]);\n\t\t\tm_stringStart++;\n\t\t\tm_lookahead--;\n\t\t}\n\n\t\tassert(m_stringStart - (m_blockStart+m_blockLength) == (unsigned int)m_matchAvailable);\n\t}\n\n\tif (m_minLookahead == 0 && m_matchAvailable)\n\t{\n\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\tm_matchAvailable = false;\n\t}\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LiteralByte",
          "args": [
            "m_byteBuffer[m_stringStart-1]"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::LiteralByte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "540-548",
          "snippet": "void Deflator::LiteralByte(byte b)\n{\n\tif (m_matchBufferEnd == m_matchBuffer.size())\n\t\tEndBlock(false);\n\n\tm_matchBuffer[m_matchBufferEnd++].literalCode = b;\n\tm_literalCounts[b]++;\n\tm_blockLength++;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::LiteralByte(byte b)\n{\n\tif (m_matchBufferEnd == m_matchBuffer.size())\n\t\tEndBlock(false);\n\n\tm_matchBuffer[m_matchBufferEnd++].literalCode = b;\n\tm_literalCounts[b]++;\n\tm_blockLength++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_stringStart - (m_blockStart+m_blockLength) == (unsigned int)m_matchAvailable"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LongestMatch",
          "args": [
            "m_previousMatch"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::LongestMatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "369-416",
          "snippet": "unsigned int Deflator::LongestMatch(unsigned int &bestMatch) const\n{\n\tassert(m_previousLength < MAX_MATCH);\n\n\tbestMatch = 0;\n\tunsigned int bestLength = STDMAX(m_previousLength, (unsigned int)MIN_MATCH-1);\n\tif (m_lookahead <= bestLength)\n\t\treturn 0;\n\n\tconst byte *scan = m_byteBuffer + m_stringStart, *scanEnd = scan + STDMIN((unsigned int)MAX_MATCH, m_lookahead);\n\tunsigned int limit = m_stringStart > (DSIZE-MAX_MATCH) ? m_stringStart - (DSIZE-MAX_MATCH) : 0;\n\tunsigned int current = m_head[ComputeHash(scan)];\n\n\tunsigned int chainLength = MAX_CHAIN_LENGTH;\n\tif (m_previousLength >= GOOD_MATCH)\n\t\tchainLength >>= 2;\n\n\twhile (current > limit && --chainLength > 0)\n\t{\n\t\tconst byte *match = m_byteBuffer + current;\n\t\tassert(scan + bestLength < m_byteBuffer + m_stringStart + m_lookahead);\n\t\tif (scan[bestLength-1] == match[bestLength-1] && scan[bestLength] == match[bestLength] && scan[0] == match[0] && scan[1] == match[1])\n\t\t{\n\t\t\tassert(scan[2] == match[2]);\n\t\t\tunsigned int len = (unsigned int)(\n#if defined(_STDEXT_BEGIN) && !(defined(_MSC_VER) && (_MSC_VER < 1400 || _MSC_VER >= 1600)) && !defined(_STLPORT_VERSION)\n\t\t\t\tstdext::unchecked_mismatch\n#else\n\t\t\t\tstd::mismatch\n#endif\n#if _MSC_VER >= 1600\n\t\t\t\t(stdext::make_unchecked_array_iterator(scan)+3, stdext::make_unchecked_array_iterator(scanEnd), stdext::make_unchecked_array_iterator(match)+3).first - stdext::make_unchecked_array_iterator(scan));\n#else\n\t\t\t\t(scan+3, scanEnd, match+3).first - scan);\n#endif\n\t\t\tassert(len != bestLength);\n\t\t\tif (len > bestLength)\n\t\t\t{\n\t\t\t\tbestLength = len;\n\t\t\t\tbestMatch = current;\n\t\t\t\tif (len == (scanEnd - scan))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcurrent = m_prev[current & DMASK];\n\t}\n\treturn (bestMatch > 0) ? bestLength : 0;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nunsigned int Deflator::LongestMatch(unsigned int &bestMatch) const\n{\n\tassert(m_previousLength < MAX_MATCH);\n\n\tbestMatch = 0;\n\tunsigned int bestLength = STDMAX(m_previousLength, (unsigned int)MIN_MATCH-1);\n\tif (m_lookahead <= bestLength)\n\t\treturn 0;\n\n\tconst byte *scan = m_byteBuffer + m_stringStart, *scanEnd = scan + STDMIN((unsigned int)MAX_MATCH, m_lookahead);\n\tunsigned int limit = m_stringStart > (DSIZE-MAX_MATCH) ? m_stringStart - (DSIZE-MAX_MATCH) : 0;\n\tunsigned int current = m_head[ComputeHash(scan)];\n\n\tunsigned int chainLength = MAX_CHAIN_LENGTH;\n\tif (m_previousLength >= GOOD_MATCH)\n\t\tchainLength >>= 2;\n\n\twhile (current > limit && --chainLength > 0)\n\t{\n\t\tconst byte *match = m_byteBuffer + current;\n\t\tassert(scan + bestLength < m_byteBuffer + m_stringStart + m_lookahead);\n\t\tif (scan[bestLength-1] == match[bestLength-1] && scan[bestLength] == match[bestLength] && scan[0] == match[0] && scan[1] == match[1])\n\t\t{\n\t\t\tassert(scan[2] == match[2]);\n\t\t\tunsigned int len = (unsigned int)(\n#if defined(_STDEXT_BEGIN) && !(defined(_MSC_VER) && (_MSC_VER < 1400 || _MSC_VER >= 1600)) && !defined(_STLPORT_VERSION)\n\t\t\t\tstdext::unchecked_mismatch\n#else\n\t\t\t\tstd::mismatch\n#endif\n#if _MSC_VER >= 1600\n\t\t\t\t(stdext::make_unchecked_array_iterator(scan)+3, stdext::make_unchecked_array_iterator(scanEnd), stdext::make_unchecked_array_iterator(match)+3).first - stdext::make_unchecked_array_iterator(scan));\n#else\n\t\t\t\t(scan+3, scanEnd, match+3).first - scan);\n#endif\n\t\t\tassert(len != bestLength);\n\t\t\tif (len > bestLength)\n\t\t\t{\n\t\t\t\tbestLength = len;\n\t\t\t\tbestMatch = current;\n\t\t\t\tif (len == (scanEnd - scan))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcurrent = m_prev[current & DMASK];\n\t}\n\treturn (bestMatch > 0) ? bestLength : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MatchFound",
          "args": [
            "m_stringStart-1-m_previousMatch",
            "m_previousLength"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::MatchFound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "550-588",
          "snippet": "void Deflator::MatchFound(unsigned int distance, unsigned int length)\n{\n\tif (m_matchBufferEnd == m_matchBuffer.size())\n\t\tEndBlock(false);\n\n\tstatic const unsigned int lengthCodes[] = {\n\t\t257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268,\n\t\t269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,\n\t\t273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274,\n\t\t275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,\n\t\t277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n\t\t278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n\t\t279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n\t\t280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,\n\t\t281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n\t\t281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n\t\t282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n\t\t282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n\t\t283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n\t\t283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n\t\t284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n\t\t284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285};\n\tstatic const unsigned int lengthBases[] = {3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};\n\tstatic const unsigned int distanceBases[30] = \n\t\t{1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577};\n\n\tEncodedMatch &m = m_matchBuffer[m_matchBufferEnd++];\n\tassert(length >= 3);\n\tunsigned int lengthCode = lengthCodes[length-3];\n\tm.literalCode = lengthCode;\n\tm.literalExtra = length - lengthBases[lengthCode-257];\n\tunsigned int distanceCode = (unsigned int)(upper_bound(distanceBases, distanceBases+30, distance) - distanceBases - 1);\n\tm.distanceCode = distanceCode;\n\tm.distanceExtra = distance - distanceBases[distanceCode];\n\n\tm_literalCounts[lengthCode]++;\n\tm_distanceCounts[distanceCode]++;\n\tm_blockLength += length;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::MatchFound(unsigned int distance, unsigned int length)\n{\n\tif (m_matchBufferEnd == m_matchBuffer.size())\n\t\tEndBlock(false);\n\n\tstatic const unsigned int lengthCodes[] = {\n\t\t257, 258, 259, 260, 261, 262, 263, 264, 265, 265, 266, 266, 267, 267, 268, 268,\n\t\t269, 269, 269, 269, 270, 270, 270, 270, 271, 271, 271, 271, 272, 272, 272, 272,\n\t\t273, 273, 273, 273, 273, 273, 273, 273, 274, 274, 274, 274, 274, 274, 274, 274,\n\t\t275, 275, 275, 275, 275, 275, 275, 275, 276, 276, 276, 276, 276, 276, 276, 276,\n\t\t277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n\t\t278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n\t\t279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n\t\t280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280, 280,\n\t\t281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n\t\t281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281, 281,\n\t\t282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n\t\t282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282, 282,\n\t\t283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n\t\t283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283, 283,\n\t\t284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284,\n\t\t284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 284, 285};\n\tstatic const unsigned int lengthBases[] = {3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};\n\tstatic const unsigned int distanceBases[30] = \n\t\t{1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577};\n\n\tEncodedMatch &m = m_matchBuffer[m_matchBufferEnd++];\n\tassert(length >= 3);\n\tunsigned int lengthCode = lengthCodes[length-3];\n\tm.literalCode = lengthCode;\n\tm.literalExtra = length - lengthBases[lengthCode-257];\n\tunsigned int distanceCode = (unsigned int)(upper_bound(distanceBases, distanceBases+30, distance) - distanceBases - 1);\n\tm.distanceCode = distanceCode;\n\tm.distanceExtra = distance - distanceBases[distanceCode];\n\n\tm_literalCounts[lengthCode]++;\n\tm_distanceCounts[distanceCode]++;\n\tm_blockLength += length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InsertString",
          "args": [
            "m_dictionaryEnd++"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::InsertString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "418-423",
          "snippet": "inline void Deflator::InsertString(unsigned int start)\n{\n\tunsigned int hash = ComputeHash(m_byteBuffer + start);\n\tm_prev[start & DMASK] = m_head[hash];\n\tm_head[hash] = start;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\ninline void Deflator::InsertString(unsigned int start)\n{\n\tunsigned int hash = ComputeHash(m_byteBuffer + start);\n\tm_prev[start & DMASK] = m_head[hash];\n\tm_head[hash] = start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WritePrestreamHeader",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "WritePrestreamHeader",
          "container": "Deflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.h",
          "lines": "77-77",
          "snippet": "virtual void WritePrestreamHeader() {}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"filters.h\"\n\nDeflator {\n  virtual void WritePrestreamHeader() {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::ProcessBuffer()\n{\n\tif (!m_headerWritten)\n\t{\n\t\tWritePrestreamHeader();\n\t\tm_headerWritten = true;\n\t}\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tm_stringStart += m_lookahead;\n\t\tm_lookahead = 0;\n\t\tm_blockLength = m_stringStart - m_blockStart;\n\t\tm_matchAvailable = false;\n\t\treturn;\n\t}\n\n\twhile (m_lookahead > m_minLookahead)\n\t{\n\t\twhile (m_dictionaryEnd < m_stringStart && m_dictionaryEnd+3 <= m_stringStart+m_lookahead)\n\t\t\tInsertString(m_dictionaryEnd++);\n\n\t\tif (m_matchAvailable)\n\t\t{\n\t\t\tunsigned int matchPosition, matchLength;\n\t\t\tbool usePreviousMatch;\n\t\t\tif (m_previousLength >= MAX_LAZYLENGTH)\n\t\t\t\tusePreviousMatch = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tmatchLength = LongestMatch(matchPosition);\n\t\t\t\tusePreviousMatch = (matchLength == 0);\n\t\t\t}\n\t\t\tif (usePreviousMatch)\n\t\t\t{\n\t\t\t\tMatchFound(m_stringStart-1-m_previousMatch, m_previousLength);\n\t\t\t\tm_stringStart += m_previousLength-1;\n\t\t\t\tm_lookahead -= m_previousLength-1;\n\t\t\t\tm_matchAvailable = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_previousLength = matchLength;\n\t\t\t\tm_previousMatch = matchPosition;\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\t\t\tm_stringStart++;\n\t\t\t\tm_lookahead--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_previousLength = 0;\n\t\t\tm_previousLength = LongestMatch(m_previousMatch);\n\t\t\tif (m_previousLength)\n\t\t\t\tm_matchAvailable = true;\n\t\t\telse\n\t\t\t\tLiteralByte(m_byteBuffer[m_stringStart]);\n\t\t\tm_stringStart++;\n\t\t\tm_lookahead--;\n\t\t}\n\n\t\tassert(m_stringStart - (m_blockStart+m_blockLength) == (unsigned int)m_matchAvailable);\n\t}\n\n\tif (m_minLookahead == 0 && m_matchAvailable)\n\t{\n\t\tLiteralByte(m_byteBuffer[m_stringStart-1]);\n\t\tm_matchAvailable = false;\n\t}\n}"
  },
  {
    "function_name": "Deflator::InsertString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "418-423",
    "snippet": "inline void Deflator::InsertString(unsigned int start)\n{\n\tunsigned int hash = ComputeHash(m_byteBuffer + start);\n\tm_prev[start & DMASK] = m_head[hash];\n\tm_head[hash] = start;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ComputeHash",
          "args": [
            "m_byteBuffer + start"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::ComputeHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "363-367",
          "snippet": "inline unsigned int Deflator::ComputeHash(const byte *str) const\n{\n\tassert(str+3 <= m_byteBuffer + m_stringStart + m_lookahead);\n\treturn ((str[0] << 10) ^ (str[1] << 5) ^ str[2]) & HMASK;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\ninline unsigned int Deflator::ComputeHash(const byte *str) const\n{\n\tassert(str+3 <= m_byteBuffer + m_stringStart + m_lookahead);\n\treturn ((str[0] << 10) ^ (str[1] << 5) ^ str[2]) & HMASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\ninline void Deflator::InsertString(unsigned int start)\n{\n\tunsigned int hash = ComputeHash(m_byteBuffer + start);\n\tm_prev[start & DMASK] = m_head[hash];\n\tm_head[hash] = start;\n}"
  },
  {
    "function_name": "Deflator::LongestMatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "369-416",
    "snippet": "unsigned int Deflator::LongestMatch(unsigned int &bestMatch) const\n{\n\tassert(m_previousLength < MAX_MATCH);\n\n\tbestMatch = 0;\n\tunsigned int bestLength = STDMAX(m_previousLength, (unsigned int)MIN_MATCH-1);\n\tif (m_lookahead <= bestLength)\n\t\treturn 0;\n\n\tconst byte *scan = m_byteBuffer + m_stringStart, *scanEnd = scan + STDMIN((unsigned int)MAX_MATCH, m_lookahead);\n\tunsigned int limit = m_stringStart > (DSIZE-MAX_MATCH) ? m_stringStart - (DSIZE-MAX_MATCH) : 0;\n\tunsigned int current = m_head[ComputeHash(scan)];\n\n\tunsigned int chainLength = MAX_CHAIN_LENGTH;\n\tif (m_previousLength >= GOOD_MATCH)\n\t\tchainLength >>= 2;\n\n\twhile (current > limit && --chainLength > 0)\n\t{\n\t\tconst byte *match = m_byteBuffer + current;\n\t\tassert(scan + bestLength < m_byteBuffer + m_stringStart + m_lookahead);\n\t\tif (scan[bestLength-1] == match[bestLength-1] && scan[bestLength] == match[bestLength] && scan[0] == match[0] && scan[1] == match[1])\n\t\t{\n\t\t\tassert(scan[2] == match[2]);\n\t\t\tunsigned int len = (unsigned int)(\n#if defined(_STDEXT_BEGIN) && !(defined(_MSC_VER) && (_MSC_VER < 1400 || _MSC_VER >= 1600)) && !defined(_STLPORT_VERSION)\n\t\t\t\tstdext::unchecked_mismatch\n#else\n\t\t\t\tstd::mismatch\n#endif\n#if _MSC_VER >= 1600\n\t\t\t\t(stdext::make_unchecked_array_iterator(scan)+3, stdext::make_unchecked_array_iterator(scanEnd), stdext::make_unchecked_array_iterator(match)+3).first - stdext::make_unchecked_array_iterator(scan));\n#else\n\t\t\t\t(scan+3, scanEnd, match+3).first - scan);\n#endif\n\t\t\tassert(len != bestLength);\n\t\t\tif (len > bestLength)\n\t\t\t{\n\t\t\t\tbestLength = len;\n\t\t\t\tbestMatch = current;\n\t\t\t\tif (len == (scanEnd - scan))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcurrent = m_prev[current & DMASK];\n\t}\n\treturn (bestMatch > 0) ? bestLength : 0;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len != bestLength"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stdext::make_unchecked_array_iterator",
          "args": [
            "scan"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stdext::make_unchecked_array_iterator",
          "args": [
            "match"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stdext::make_unchecked_array_iterator",
          "args": [
            "scanEnd"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stdext::make_unchecked_array_iterator",
          "args": [
            "scan"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defined",
          "args": [
            "_STLPORT_VERSION"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defined",
          "args": [
            "_MSC_VER"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "scan[2] == match[2]"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "scan + bestLength < m_byteBuffer + m_stringStart + m_lookahead"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ComputeHash",
          "args": [
            "scan"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::ComputeHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "363-367",
          "snippet": "inline unsigned int Deflator::ComputeHash(const byte *str) const\n{\n\tassert(str+3 <= m_byteBuffer + m_stringStart + m_lookahead);\n\treturn ((str[0] << 10) ^ (str[1] << 5) ^ str[2]) & HMASK;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\ninline unsigned int Deflator::ComputeHash(const byte *str) const\n{\n\tassert(str+3 <= m_byteBuffer + m_stringStart + m_lookahead);\n\treturn ((str[0] << 10) ^ (str[1] << 5) ^ str[2]) & HMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "(unsigned int)MAX_MATCH",
            "m_lookahead"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMAX",
          "args": [
            "m_previousLength",
            "(unsigned int)MIN_MATCH-1"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_previousLength < MAX_MATCH"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nunsigned int Deflator::LongestMatch(unsigned int &bestMatch) const\n{\n\tassert(m_previousLength < MAX_MATCH);\n\n\tbestMatch = 0;\n\tunsigned int bestLength = STDMAX(m_previousLength, (unsigned int)MIN_MATCH-1);\n\tif (m_lookahead <= bestLength)\n\t\treturn 0;\n\n\tconst byte *scan = m_byteBuffer + m_stringStart, *scanEnd = scan + STDMIN((unsigned int)MAX_MATCH, m_lookahead);\n\tunsigned int limit = m_stringStart > (DSIZE-MAX_MATCH) ? m_stringStart - (DSIZE-MAX_MATCH) : 0;\n\tunsigned int current = m_head[ComputeHash(scan)];\n\n\tunsigned int chainLength = MAX_CHAIN_LENGTH;\n\tif (m_previousLength >= GOOD_MATCH)\n\t\tchainLength >>= 2;\n\n\twhile (current > limit && --chainLength > 0)\n\t{\n\t\tconst byte *match = m_byteBuffer + current;\n\t\tassert(scan + bestLength < m_byteBuffer + m_stringStart + m_lookahead);\n\t\tif (scan[bestLength-1] == match[bestLength-1] && scan[bestLength] == match[bestLength] && scan[0] == match[0] && scan[1] == match[1])\n\t\t{\n\t\t\tassert(scan[2] == match[2]);\n\t\t\tunsigned int len = (unsigned int)(\n#if defined(_STDEXT_BEGIN) && !(defined(_MSC_VER) && (_MSC_VER < 1400 || _MSC_VER >= 1600)) && !defined(_STLPORT_VERSION)\n\t\t\t\tstdext::unchecked_mismatch\n#else\n\t\t\t\tstd::mismatch\n#endif\n#if _MSC_VER >= 1600\n\t\t\t\t(stdext::make_unchecked_array_iterator(scan)+3, stdext::make_unchecked_array_iterator(scanEnd), stdext::make_unchecked_array_iterator(match)+3).first - stdext::make_unchecked_array_iterator(scan));\n#else\n\t\t\t\t(scan+3, scanEnd, match+3).first - scan);\n#endif\n\t\t\tassert(len != bestLength);\n\t\t\tif (len > bestLength)\n\t\t\t{\n\t\t\t\tbestLength = len;\n\t\t\t\tbestMatch = current;\n\t\t\t\tif (len == (scanEnd - scan))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcurrent = m_prev[current & DMASK];\n\t}\n\treturn (bestMatch > 0) ? bestLength : 0;\n}"
  },
  {
    "function_name": "Deflator::ComputeHash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "363-367",
    "snippet": "inline unsigned int Deflator::ComputeHash(const byte *str) const\n{\n\tassert(str+3 <= m_byteBuffer + m_stringStart + m_lookahead);\n\treturn ((str[0] << 10) ^ (str[1] << 5) ^ str[2]) & HMASK;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str+3 <= m_byteBuffer + m_stringStart + m_lookahead"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\ninline unsigned int Deflator::ComputeHash(const byte *str) const\n{\n\tassert(str+3 <= m_byteBuffer + m_stringStart + m_lookahead);\n\treturn ((str[0] << 10) ^ (str[1] << 5) ^ str[2]) & HMASK;\n}"
  },
  {
    "function_name": "Deflator::FillWindow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "327-361",
    "snippet": "unsigned int Deflator::FillWindow(const byte *str, size_t length)\n{\n\tunsigned int maxBlockSize = (unsigned int)STDMIN(2UL*DSIZE, 0xffffUL);\n\n\tif (m_stringStart >= maxBlockSize - MAX_MATCH)\n\t{\n\t\tif (m_blockStart < DSIZE)\n\t\t\tEndBlock(false);\n\n\t\tmemcpy(m_byteBuffer, m_byteBuffer + DSIZE, DSIZE);\n\n\t\tm_dictionaryEnd = m_dictionaryEnd < DSIZE ? 0 : m_dictionaryEnd-DSIZE;\n\t\tassert(m_stringStart >= DSIZE);\n\t\tm_stringStart -= DSIZE;\n\t\tassert(!m_matchAvailable || m_previousMatch >= DSIZE);\n\t\tm_previousMatch -= DSIZE;\n\t\tassert(m_blockStart >= DSIZE);\n\t\tm_blockStart -= DSIZE;\n\n\t\tunsigned int i;\n\n\t\tfor (i=0; i<HSIZE; i++)\n\t\t\tm_head[i] = SaturatingSubtract(m_head[i], DSIZE);\n\n\t\tfor (i=0; i<DSIZE; i++)\n\t\t\tm_prev[i] = SaturatingSubtract(m_prev[i], DSIZE);\n\t}\n\n\tassert(maxBlockSize > m_stringStart+m_lookahead);\n\tunsigned int accepted = UnsignedMin(maxBlockSize-(m_stringStart+m_lookahead), length);\n\tassert(accepted > 0);\n\tmemcpy(m_byteBuffer + m_stringStart + m_lookahead, str, accepted);\n\tm_lookahead += accepted;\n\treturn accepted;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_byteBuffer + m_stringStart + m_lookahead",
            "str",
            "accepted"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "accepted > 0"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "maxBlockSize-(m_stringStart+m_lookahead)",
            "length"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "maxBlockSize > m_stringStart+m_lookahead"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "m_prev[i]",
            "DSIZE"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_blockStart >= DSIZE"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!m_matchAvailable || m_previousMatch >= DSIZE"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_stringStart >= DSIZE"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_byteBuffer",
            "m_byteBuffer + DSIZE",
            "DSIZE"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EndBlock",
          "args": [
            "false"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::EndBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "738-799",
          "snippet": "void Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "2UL*DSIZE",
            "0xffffUL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nunsigned int Deflator::FillWindow(const byte *str, size_t length)\n{\n\tunsigned int maxBlockSize = (unsigned int)STDMIN(2UL*DSIZE, 0xffffUL);\n\n\tif (m_stringStart >= maxBlockSize - MAX_MATCH)\n\t{\n\t\tif (m_blockStart < DSIZE)\n\t\t\tEndBlock(false);\n\n\t\tmemcpy(m_byteBuffer, m_byteBuffer + DSIZE, DSIZE);\n\n\t\tm_dictionaryEnd = m_dictionaryEnd < DSIZE ? 0 : m_dictionaryEnd-DSIZE;\n\t\tassert(m_stringStart >= DSIZE);\n\t\tm_stringStart -= DSIZE;\n\t\tassert(!m_matchAvailable || m_previousMatch >= DSIZE);\n\t\tm_previousMatch -= DSIZE;\n\t\tassert(m_blockStart >= DSIZE);\n\t\tm_blockStart -= DSIZE;\n\n\t\tunsigned int i;\n\n\t\tfor (i=0; i<HSIZE; i++)\n\t\t\tm_head[i] = SaturatingSubtract(m_head[i], DSIZE);\n\n\t\tfor (i=0; i<DSIZE; i++)\n\t\t\tm_prev[i] = SaturatingSubtract(m_prev[i], DSIZE);\n\t}\n\n\tassert(maxBlockSize > m_stringStart+m_lookahead);\n\tunsigned int accepted = UnsignedMin(maxBlockSize-(m_stringStart+m_lookahead), length);\n\tassert(accepted > 0);\n\tmemcpy(m_byteBuffer + m_stringStart + m_lookahead, str, accepted);\n\tm_lookahead += accepted;\n\treturn accepted;\n}"
  },
  {
    "function_name": "Deflator::SetDeflateLevel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "297-325",
    "snippet": "void Deflator::SetDeflateLevel(int deflateLevel)\n{\n\tif (!(MIN_DEFLATE_LEVEL <= deflateLevel && deflateLevel <= MAX_DEFLATE_LEVEL))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(deflateLevel) + \" is an invalid deflate level\");\n\n\tif (deflateLevel == m_deflateLevel)\n\t\treturn;\n\n\tEndBlock(false);\n\n\tstatic const unsigned int configurationTable[10][4] = {\n\t\t/*      good lazy nice chain */\n\t\t/* 0 */ {0,    0,  0,    0},  /* store only */\n\t\t/* 1 */ {4,    3,  8,    4},  /* maximum speed, no lazy matches */\n\t\t/* 2 */ {4,    3, 16,    8},\n\t\t/* 3 */ {4,    3, 32,   32},\n\t\t/* 4 */ {4,    4, 16,   16},  /* lazy matches */\n\t\t/* 5 */ {8,   16, 32,   32},\n\t\t/* 6 */ {8,   16, 128, 128},\n\t\t/* 7 */ {8,   32, 128, 256},\n\t\t/* 8 */ {32, 128, 258, 1024},\n\t\t/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */\n\n\tGOOD_MATCH = configurationTable[deflateLevel][0];\n\tMAX_LAZYLENGTH = configurationTable[deflateLevel][1];\n\tMAX_CHAIN_LENGTH = configurationTable[deflateLevel][3];\n\n\tm_deflateLevel = deflateLevel;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EndBlock",
          "args": [
            "false"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::EndBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "738-799",
          "snippet": "void Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::EndBlock(bool eof)\n{\n\tif (m_blockLength == 0 && !eof)\n\t\treturn;\n\n\tif (m_deflateLevel == 0)\n\t{\n\t\tEncodeBlock(eof, STORED);\n\n\t\tif (m_compressibleDeflateLevel > 0 && ++m_detectCount == m_detectSkip)\n\t\t{\n\t\t\tm_deflateLevel = m_compressibleDeflateLevel;\n\t\t\tm_detectCount = 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tunsigned long storedLen = 8*((unsigned long)m_blockLength+4) + RoundUpToMultipleOf(m_bitsBuffered+3, 8U)-m_bitsBuffered;\n\n\t\tStartCounting();\n\t\tEncodeBlock(eof, STATIC);\n\t\tunsigned long staticLen = FinishCounting();\n\n\t\tunsigned long dynamicLen;\n\t\tif (m_blockLength < 128 && m_deflateLevel < 8)\n\t\t\tdynamicLen = ULONG_MAX;\n\t\telse\n\t\t{\n\t\t\tStartCounting();\n\t\t\tEncodeBlock(eof, DYNAMIC);\n\t\t\tdynamicLen = FinishCounting();\n\t\t}\n\n\t\tif (storedLen <= staticLen && storedLen <= dynamicLen)\n\t\t{\n\t\t\tEncodeBlock(eof, STORED);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t{\n\t\t\t\tif (m_detectSkip)\n\t\t\t\t\tm_deflateLevel = 0;\n\t\t\t\tm_detectSkip = m_detectSkip ? STDMIN(2*m_detectSkip, 128U) : 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (staticLen <= dynamicLen)\n\t\t\t\tEncodeBlock(eof, STATIC);\n\t\t\telse\n\t\t\t\tEncodeBlock(eof, DYNAMIC);\n\n\t\t\tif (m_compressibleDeflateLevel > 0)\n\t\t\t\tm_detectSkip = 0;\n\t\t}\n\t}\n\n\tm_matchBufferEnd = 0;\n\tm_blockStart += m_blockLength;\n\tm_blockLength = 0;\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"Deflator: \" + IntToString(deflateLevel) + \" is an invalid deflate level\""
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "deflateLevel"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::SetDeflateLevel(int deflateLevel)\n{\n\tif (!(MIN_DEFLATE_LEVEL <= deflateLevel && deflateLevel <= MAX_DEFLATE_LEVEL))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(deflateLevel) + \" is an invalid deflate level\");\n\n\tif (deflateLevel == m_deflateLevel)\n\t\treturn;\n\n\tEndBlock(false);\n\n\tstatic const unsigned int configurationTable[10][4] = {\n\t\t/*      good lazy nice chain */\n\t\t/* 0 */ {0,    0,  0,    0},  /* store only */\n\t\t/* 1 */ {4,    3,  8,    4},  /* maximum speed, no lazy matches */\n\t\t/* 2 */ {4,    3, 16,    8},\n\t\t/* 3 */ {4,    3, 32,   32},\n\t\t/* 4 */ {4,    4, 16,   16},  /* lazy matches */\n\t\t/* 5 */ {8,   16, 32,   32},\n\t\t/* 6 */ {8,   16, 128, 128},\n\t\t/* 7 */ {8,   32, 128, 256},\n\t\t/* 8 */ {32, 128, 258, 1024},\n\t\t/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */\n\n\tGOOD_MATCH = configurationTable[deflateLevel][0];\n\tMAX_LAZYLENGTH = configurationTable[deflateLevel][1];\n\tMAX_CHAIN_LENGTH = configurationTable[deflateLevel][3];\n\n\tm_deflateLevel = deflateLevel;\n}"
  },
  {
    "function_name": "Deflator::Reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "270-295",
    "snippet": "void Deflator::Reset(bool forceReset)\n{\n\tif (forceReset)\n\t\tClearBitBuffer();\n\telse\n\t\tassert(m_bitsBuffered == 0);\n\n\tm_headerWritten = false;\n\tm_matchAvailable = false;\n\tm_dictionaryEnd = 0;\n\tm_stringStart = 0;\n\tm_lookahead = 0;\n\tm_minLookahead = MAX_MATCH;\n\tm_matchBufferEnd = 0;\n\tm_blockStart = 0;\n\tm_blockLength = 0;\n\n\tm_detectCount = 1;\n\tm_detectSkip = 0;\n\n\t// m_prev will be initialized automaticly in InsertString\n\tfill(m_head.begin(), m_head.end(), 0);\n\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "m_distanceCounts.begin()",
            "m_distanceCounts.end()",
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_distanceCounts.end",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_distanceCounts.begin",
          "args": [],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "m_literalCounts.begin()",
            "m_literalCounts.end()",
            "0"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "m_head.begin()",
            "m_head.end()",
            "0"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_bitsBuffered == 0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearBitBuffer",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "LowFirstBitWriter::ClearBitBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "83-88",
          "snippet": "void LowFirstBitWriter::ClearBitBuffer()\n{\n\tm_buffer = 0;\n\tm_bytesBuffered = 0;\n\tm_bitsBuffered = 0;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::ClearBitBuffer()\n{\n\tm_buffer = 0;\n\tm_bytesBuffered = 0;\n\tm_bitsBuffered = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::Reset(bool forceReset)\n{\n\tif (forceReset)\n\t\tClearBitBuffer();\n\telse\n\t\tassert(m_bitsBuffered == 0);\n\n\tm_headerWritten = false;\n\tm_matchAvailable = false;\n\tm_dictionaryEnd = 0;\n\tm_stringStart = 0;\n\tm_lookahead = 0;\n\tm_minLookahead = MAX_MATCH;\n\tm_matchBufferEnd = 0;\n\tm_blockStart = 0;\n\tm_blockLength = 0;\n\n\tm_detectCount = 1;\n\tm_detectSkip = 0;\n\n\t// m_prev will be initialized automaticly in InsertString\n\tfill(m_head.begin(), m_head.end(), 0);\n\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
  },
  {
    "function_name": "Deflator::IsolatedInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "248-268",
    "snippet": "void Deflator::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tint log2WindowSize = parameters.GetIntValueWithDefault(\"Log2WindowSize\", DEFAULT_LOG2_WINDOW_SIZE);\n\tif (!(MIN_LOG2_WINDOW_SIZE <= log2WindowSize && log2WindowSize <= MAX_LOG2_WINDOW_SIZE))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(log2WindowSize) + \" is an invalid window size\");\n\n\tm_log2WindowSize = log2WindowSize;\n\tDSIZE = 1 << m_log2WindowSize;\n\tDMASK = DSIZE - 1;\n\tHSIZE = 1 << m_log2WindowSize;\n\tHMASK = HSIZE - 1;\n\tm_byteBuffer.New(2*DSIZE);\n\tm_head.New(HSIZE);\n\tm_prev.New(DSIZE);\n\tm_matchBuffer.New(DSIZE/2);\n\tReset(true);\n\n\tSetDeflateLevel(parameters.GetIntValueWithDefault(\"DeflateLevel\", DEFAULT_DEFLATE_LEVEL));\n\tbool detectUncompressible = parameters.GetValueWithDefault(\"DetectUncompressible\", true);\n\tm_compressibleDeflateLevel = detectUncompressible ? m_deflateLevel : 0;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parameters.GetValueWithDefault",
          "args": [
            "\"DetectUncompressible\"",
            "true"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetDeflateLevel",
          "args": [
            "parameters.GetIntValueWithDefault(\"DeflateLevel\", DEFAULT_DEFLATE_LEVEL)"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::SetDeflateLevel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "297-325",
          "snippet": "void Deflator::SetDeflateLevel(int deflateLevel)\n{\n\tif (!(MIN_DEFLATE_LEVEL <= deflateLevel && deflateLevel <= MAX_DEFLATE_LEVEL))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(deflateLevel) + \" is an invalid deflate level\");\n\n\tif (deflateLevel == m_deflateLevel)\n\t\treturn;\n\n\tEndBlock(false);\n\n\tstatic const unsigned int configurationTable[10][4] = {\n\t\t/*      good lazy nice chain */\n\t\t/* 0 */ {0,    0,  0,    0},  /* store only */\n\t\t/* 1 */ {4,    3,  8,    4},  /* maximum speed, no lazy matches */\n\t\t/* 2 */ {4,    3, 16,    8},\n\t\t/* 3 */ {4,    3, 32,   32},\n\t\t/* 4 */ {4,    4, 16,   16},  /* lazy matches */\n\t\t/* 5 */ {8,   16, 32,   32},\n\t\t/* 6 */ {8,   16, 128, 128},\n\t\t/* 7 */ {8,   32, 128, 256},\n\t\t/* 8 */ {32, 128, 258, 1024},\n\t\t/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */\n\n\tGOOD_MATCH = configurationTable[deflateLevel][0];\n\tMAX_LAZYLENGTH = configurationTable[deflateLevel][1];\n\tMAX_CHAIN_LENGTH = configurationTable[deflateLevel][3];\n\n\tm_deflateLevel = deflateLevel;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::SetDeflateLevel(int deflateLevel)\n{\n\tif (!(MIN_DEFLATE_LEVEL <= deflateLevel && deflateLevel <= MAX_DEFLATE_LEVEL))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(deflateLevel) + \" is an invalid deflate level\");\n\n\tif (deflateLevel == m_deflateLevel)\n\t\treturn;\n\n\tEndBlock(false);\n\n\tstatic const unsigned int configurationTable[10][4] = {\n\t\t/*      good lazy nice chain */\n\t\t/* 0 */ {0,    0,  0,    0},  /* store only */\n\t\t/* 1 */ {4,    3,  8,    4},  /* maximum speed, no lazy matches */\n\t\t/* 2 */ {4,    3, 16,    8},\n\t\t/* 3 */ {4,    3, 32,   32},\n\t\t/* 4 */ {4,    4, 16,   16},  /* lazy matches */\n\t\t/* 5 */ {8,   16, 32,   32},\n\t\t/* 6 */ {8,   16, 128, 128},\n\t\t/* 7 */ {8,   32, 128, 256},\n\t\t/* 8 */ {32, 128, 258, 1024},\n\t\t/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */\n\n\tGOOD_MATCH = configurationTable[deflateLevel][0];\n\tMAX_LAZYLENGTH = configurationTable[deflateLevel][1];\n\tMAX_CHAIN_LENGTH = configurationTable[deflateLevel][3];\n\n\tm_deflateLevel = deflateLevel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameters.GetIntValueWithDefault",
          "args": [
            "\"DeflateLevel\"",
            "DEFAULT_DEFLATE_LEVEL"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Reset",
          "args": [
            "true"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::Reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "270-295",
          "snippet": "void Deflator::Reset(bool forceReset)\n{\n\tif (forceReset)\n\t\tClearBitBuffer();\n\telse\n\t\tassert(m_bitsBuffered == 0);\n\n\tm_headerWritten = false;\n\tm_matchAvailable = false;\n\tm_dictionaryEnd = 0;\n\tm_stringStart = 0;\n\tm_lookahead = 0;\n\tm_minLookahead = MAX_MATCH;\n\tm_matchBufferEnd = 0;\n\tm_blockStart = 0;\n\tm_blockLength = 0;\n\n\tm_detectCount = 1;\n\tm_detectSkip = 0;\n\n\t// m_prev will be initialized automaticly in InsertString\n\tfill(m_head.begin(), m_head.end(), 0);\n\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::Reset(bool forceReset)\n{\n\tif (forceReset)\n\t\tClearBitBuffer();\n\telse\n\t\tassert(m_bitsBuffered == 0);\n\n\tm_headerWritten = false;\n\tm_matchAvailable = false;\n\tm_dictionaryEnd = 0;\n\tm_stringStart = 0;\n\tm_lookahead = 0;\n\tm_minLookahead = MAX_MATCH;\n\tm_matchBufferEnd = 0;\n\tm_blockStart = 0;\n\tm_blockLength = 0;\n\n\tm_detectCount = 1;\n\tm_detectSkip = 0;\n\n\t// m_prev will be initialized automaticly in InsertString\n\tfill(m_head.begin(), m_head.end(), 0);\n\n\tfill(m_literalCounts.begin(), m_literalCounts.end(), 0);\n\tfill(m_distanceCounts.begin(), m_distanceCounts.end(), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_matchBuffer.New",
          "args": [
            "DSIZE/2"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"Deflator: \" + IntToString(log2WindowSize) + \" is an invalid window size\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "log2WindowSize"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameters.GetIntValueWithDefault",
          "args": [
            "\"Log2WindowSize\"",
            "DEFAULT_LOG2_WINDOW_SIZE"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tint log2WindowSize = parameters.GetIntValueWithDefault(\"Log2WindowSize\", DEFAULT_LOG2_WINDOW_SIZE);\n\tif (!(MIN_LOG2_WINDOW_SIZE <= log2WindowSize && log2WindowSize <= MAX_LOG2_WINDOW_SIZE))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(log2WindowSize) + \" is an invalid window size\");\n\n\tm_log2WindowSize = log2WindowSize;\n\tDSIZE = 1 << m_log2WindowSize;\n\tDMASK = DSIZE - 1;\n\tHSIZE = 1 << m_log2WindowSize;\n\tHMASK = HSIZE - 1;\n\tm_byteBuffer.New(2*DSIZE);\n\tm_head.New(HSIZE);\n\tm_prev.New(DSIZE);\n\tm_matchBuffer.New(DSIZE/2);\n\tReset(true);\n\n\tSetDeflateLevel(parameters.GetIntValueWithDefault(\"DeflateLevel\", DEFAULT_DEFLATE_LEVEL));\n\tbool detectUncompressible = parameters.GetValueWithDefault(\"DetectUncompressible\", true);\n\tm_compressibleDeflateLevel = detectUncompressible ? m_deflateLevel : 0;\n}"
  },
  {
    "function_name": "Deflator::InitializeStaticEncoders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "236-246",
    "snippet": "void Deflator::InitializeStaticEncoders()\n{\n\tunsigned int codeLengths[288];\n\tfill(codeLengths + 0, codeLengths + 144, 8);\n\tfill(codeLengths + 144, codeLengths + 256, 9);\n\tfill(codeLengths + 256, codeLengths + 280, 7);\n\tfill(codeLengths + 280, codeLengths + 288, 8);\n\tm_staticLiteralEncoder.Initialize(codeLengths, 288);\n\tfill(codeLengths + 0, codeLengths + 32, 5);\n\tm_staticDistanceEncoder.Initialize(codeLengths, 32);\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_staticDistanceEncoder.Initialize",
          "args": [
            "codeLengths",
            "32"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "Initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.h",
          "lines": "54-55",
          "snippet": "void Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}",
          "includes": [
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n\nvoid Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}"
        }
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "codeLengths + 0",
            "codeLengths + 32",
            "5"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "codeLengths + 280",
            "codeLengths + 288",
            "8"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "codeLengths + 256",
            "codeLengths + 280",
            "7"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "codeLengths + 144",
            "codeLengths + 256",
            "9"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "codeLengths + 0",
            "codeLengths + 144",
            "8"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::InitializeStaticEncoders()\n{\n\tunsigned int codeLengths[288];\n\tfill(codeLengths + 0, codeLengths + 144, 8);\n\tfill(codeLengths + 144, codeLengths + 256, 9);\n\tfill(codeLengths + 256, codeLengths + 280, 7);\n\tfill(codeLengths + 280, codeLengths + 288, 8);\n\tm_staticLiteralEncoder.Initialize(codeLengths, 288);\n\tfill(codeLengths + 0, codeLengths + 32, 5);\n\tm_staticDistanceEncoder.Initialize(codeLengths, 32);\n}"
  },
  {
    "function_name": "Deflator::Deflator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "228-234",
    "snippet": "Deflator::Deflator(const NameValuePairs &parameters, BufferedTransformation *attachment)\n\t: LowFirstBitWriter(attachment)\n\t, m_deflateLevel(-1)\n{\n\tInitializeStaticEncoders();\n\tIsolatedInitialize(parameters);\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsolatedInitialize",
          "args": [
            "parameters"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::IsolatedInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "248-268",
          "snippet": "void Deflator::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tint log2WindowSize = parameters.GetIntValueWithDefault(\"Log2WindowSize\", DEFAULT_LOG2_WINDOW_SIZE);\n\tif (!(MIN_LOG2_WINDOW_SIZE <= log2WindowSize && log2WindowSize <= MAX_LOG2_WINDOW_SIZE))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(log2WindowSize) + \" is an invalid window size\");\n\n\tm_log2WindowSize = log2WindowSize;\n\tDSIZE = 1 << m_log2WindowSize;\n\tDMASK = DSIZE - 1;\n\tHSIZE = 1 << m_log2WindowSize;\n\tHMASK = HSIZE - 1;\n\tm_byteBuffer.New(2*DSIZE);\n\tm_head.New(HSIZE);\n\tm_prev.New(DSIZE);\n\tm_matchBuffer.New(DSIZE/2);\n\tReset(true);\n\n\tSetDeflateLevel(parameters.GetIntValueWithDefault(\"DeflateLevel\", DEFAULT_DEFLATE_LEVEL));\n\tbool detectUncompressible = parameters.GetValueWithDefault(\"DetectUncompressible\", true);\n\tm_compressibleDeflateLevel = detectUncompressible ? m_deflateLevel : 0;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tint log2WindowSize = parameters.GetIntValueWithDefault(\"Log2WindowSize\", DEFAULT_LOG2_WINDOW_SIZE);\n\tif (!(MIN_LOG2_WINDOW_SIZE <= log2WindowSize && log2WindowSize <= MAX_LOG2_WINDOW_SIZE))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(log2WindowSize) + \" is an invalid window size\");\n\n\tm_log2WindowSize = log2WindowSize;\n\tDSIZE = 1 << m_log2WindowSize;\n\tDMASK = DSIZE - 1;\n\tHSIZE = 1 << m_log2WindowSize;\n\tHMASK = HSIZE - 1;\n\tm_byteBuffer.New(2*DSIZE);\n\tm_head.New(HSIZE);\n\tm_prev.New(DSIZE);\n\tm_matchBuffer.New(DSIZE/2);\n\tReset(true);\n\n\tSetDeflateLevel(parameters.GetIntValueWithDefault(\"DeflateLevel\", DEFAULT_DEFLATE_LEVEL));\n\tbool detectUncompressible = parameters.GetValueWithDefault(\"DetectUncompressible\", true);\n\tm_compressibleDeflateLevel = detectUncompressible ? m_deflateLevel : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitializeStaticEncoders",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::InitializeStaticEncoders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "236-246",
          "snippet": "void Deflator::InitializeStaticEncoders()\n{\n\tunsigned int codeLengths[288];\n\tfill(codeLengths + 0, codeLengths + 144, 8);\n\tfill(codeLengths + 144, codeLengths + 256, 9);\n\tfill(codeLengths + 256, codeLengths + 280, 7);\n\tfill(codeLengths + 280, codeLengths + 288, 8);\n\tm_staticLiteralEncoder.Initialize(codeLengths, 288);\n\tfill(codeLengths + 0, codeLengths + 32, 5);\n\tm_staticDistanceEncoder.Initialize(codeLengths, 32);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::InitializeStaticEncoders()\n{\n\tunsigned int codeLengths[288];\n\tfill(codeLengths + 0, codeLengths + 144, 8);\n\tfill(codeLengths + 144, codeLengths + 256, 9);\n\tfill(codeLengths + 256, codeLengths + 280, 7);\n\tfill(codeLengths + 280, codeLengths + 288, 8);\n\tm_staticLiteralEncoder.Initialize(codeLengths, 288);\n\tfill(codeLengths + 0, codeLengths + 32, 5);\n\tm_staticDistanceEncoder.Initialize(codeLengths, 32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nDeflator::Deflator(const NameValuePairs &parameters, BufferedTransformation *attachment)\n\t: LowFirstBitWriter(attachment)\n\t, m_deflateLevel(-1)\n{\n\tInitializeStaticEncoders();\n\tIsolatedInitialize(parameters);\n}"
  },
  {
    "function_name": "Deflator::Deflator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "220-226",
    "snippet": "Deflator::Deflator(BufferedTransformation *attachment, int deflateLevel, int log2WindowSize, bool detectUncompressible)\n\t: LowFirstBitWriter(attachment)\n\t, m_deflateLevel(-1)\n{\n\tInitializeStaticEncoders();\n\tIsolatedInitialize(MakeParameters(\"DeflateLevel\", deflateLevel)(\"Log2WindowSize\", log2WindowSize)(\"DetectUncompressible\", detectUncompressible));\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsolatedInitialize",
          "args": [
            "MakeParameters(\"DeflateLevel\", deflateLevel)(\"Log2WindowSize\", log2WindowSize)(\"DetectUncompressible\", detectUncompressible)"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::IsolatedInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "248-268",
          "snippet": "void Deflator::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tint log2WindowSize = parameters.GetIntValueWithDefault(\"Log2WindowSize\", DEFAULT_LOG2_WINDOW_SIZE);\n\tif (!(MIN_LOG2_WINDOW_SIZE <= log2WindowSize && log2WindowSize <= MAX_LOG2_WINDOW_SIZE))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(log2WindowSize) + \" is an invalid window size\");\n\n\tm_log2WindowSize = log2WindowSize;\n\tDSIZE = 1 << m_log2WindowSize;\n\tDMASK = DSIZE - 1;\n\tHSIZE = 1 << m_log2WindowSize;\n\tHMASK = HSIZE - 1;\n\tm_byteBuffer.New(2*DSIZE);\n\tm_head.New(HSIZE);\n\tm_prev.New(DSIZE);\n\tm_matchBuffer.New(DSIZE/2);\n\tReset(true);\n\n\tSetDeflateLevel(parameters.GetIntValueWithDefault(\"DeflateLevel\", DEFAULT_DEFLATE_LEVEL));\n\tbool detectUncompressible = parameters.GetValueWithDefault(\"DetectUncompressible\", true);\n\tm_compressibleDeflateLevel = detectUncompressible ? m_deflateLevel : 0;\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tint log2WindowSize = parameters.GetIntValueWithDefault(\"Log2WindowSize\", DEFAULT_LOG2_WINDOW_SIZE);\n\tif (!(MIN_LOG2_WINDOW_SIZE <= log2WindowSize && log2WindowSize <= MAX_LOG2_WINDOW_SIZE))\n\t\tthrow InvalidArgument(\"Deflator: \" + IntToString(log2WindowSize) + \" is an invalid window size\");\n\n\tm_log2WindowSize = log2WindowSize;\n\tDSIZE = 1 << m_log2WindowSize;\n\tDMASK = DSIZE - 1;\n\tHSIZE = 1 << m_log2WindowSize;\n\tHMASK = HSIZE - 1;\n\tm_byteBuffer.New(2*DSIZE);\n\tm_head.New(HSIZE);\n\tm_prev.New(DSIZE);\n\tm_matchBuffer.New(DSIZE/2);\n\tReset(true);\n\n\tSetDeflateLevel(parameters.GetIntValueWithDefault(\"DeflateLevel\", DEFAULT_DEFLATE_LEVEL));\n\tbool detectUncompressible = parameters.GetValueWithDefault(\"DetectUncompressible\", true);\n\tm_compressibleDeflateLevel = detectUncompressible ? m_deflateLevel : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"DetectUncompressible\"",
            "detectUncompressible"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitializeStaticEncoders",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "Deflator::InitializeStaticEncoders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "236-246",
          "snippet": "void Deflator::InitializeStaticEncoders()\n{\n\tunsigned int codeLengths[288];\n\tfill(codeLengths + 0, codeLengths + 144, 8);\n\tfill(codeLengths + 144, codeLengths + 256, 9);\n\tfill(codeLengths + 256, codeLengths + 280, 7);\n\tfill(codeLengths + 280, codeLengths + 288, 8);\n\tm_staticLiteralEncoder.Initialize(codeLengths, 288);\n\tfill(codeLengths + 0, codeLengths + 32, 5);\n\tm_staticDistanceEncoder.Initialize(codeLengths, 32);\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid Deflator::InitializeStaticEncoders()\n{\n\tunsigned int codeLengths[288];\n\tfill(codeLengths + 0, codeLengths + 144, 8);\n\tfill(codeLengths + 144, codeLengths + 256, 9);\n\tfill(codeLengths + 256, codeLengths + 280, 7);\n\tfill(codeLengths + 280, codeLengths + 288, 8);\n\tm_staticLiteralEncoder.Initialize(codeLengths, 288);\n\tfill(codeLengths + 0, codeLengths + 32, 5);\n\tm_staticDistanceEncoder.Initialize(codeLengths, 32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nDeflator::Deflator(BufferedTransformation *attachment, int deflateLevel, int log2WindowSize, bool detectUncompressible)\n\t: LowFirstBitWriter(attachment)\n\t, m_deflateLevel(-1)\n{\n\tInitializeStaticEncoders();\n\tIsolatedInitialize(MakeParameters(\"DeflateLevel\", deflateLevel)(\"Log2WindowSize\", log2WindowSize)(\"DetectUncompressible\", detectUncompressible));\n}"
  },
  {
    "function_name": "HuffmanEncoder::Encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "214-218",
    "snippet": "inline void HuffmanEncoder::Encode(LowFirstBitWriter &writer, value_t value) const\n{\n\tassert(m_valueToCode[value].len > 0);\n\twriter.PutBits(m_valueToCode[value].code, m_valueToCode[value].len);\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writer.PutBits",
          "args": [
            "m_valueToCode[value].code",
            "m_valueToCode[value].len"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_valueToCode[value].len > 0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\ninline void HuffmanEncoder::Encode(LowFirstBitWriter &writer, value_t value) const\n{\n\tassert(m_valueToCode[value].len > 0);\n\twriter.PutBits(m_valueToCode[value].code, m_valueToCode[value].len);\n}"
  },
  {
    "function_name": "HuffmanEncoder::Initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "182-212",
    "snippet": "void HuffmanEncoder::Initialize(const unsigned int *codeBits, unsigned int nCodes)\n{\n\tassert(nCodes > 0);\n\tunsigned int maxCodeBits = *max_element(codeBits, codeBits+nCodes);\n\tif (maxCodeBits == 0)\n\t\treturn;\t\t// assume this object won't be used\n\n\tSecBlockWithHint<unsigned int, 15+1> blCount(maxCodeBits+1);\n\tfill(blCount.begin(), blCount.end(), 0);\n\tunsigned int i;\n\tfor (i=0; i<nCodes; i++)\n\t\tblCount[codeBits[i]]++;\n\n\tcode_t code = 0;\n\tSecBlockWithHint<code_t, 15+1> nextCode(maxCodeBits+1);\n\tnextCode[1] = 0;\n\tfor (i=2; i<=maxCodeBits; i++)\n\t{\n\t\tcode = (code + blCount[i-1]) << 1;\n\t\tnextCode[i] = code;\n\t}\n\tassert(maxCodeBits == 1 || code == (1 << maxCodeBits) - blCount[maxCodeBits]);\n\n\tm_valueToCode.resize(nCodes);\n\tfor (i=0; i<nCodes; i++)\n\t{\n\t\tunsigned int len = m_valueToCode[i].len = codeBits[i];\n\t\tif (len != 0)\n\t\t\tm_valueToCode[i].code = BitReverse(nextCode[len]++) >> (8*sizeof(code_t)-len);\n\t}\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BitReverse",
          "args": [
            "nextCode[len]++"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "BitReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "906-919",
          "snippet": "inline T BitReverse(T value)\n{\n\tif (sizeof(T) == 1)\n\t\treturn (T)BitReverse((byte)value);\n\telse if (sizeof(T) == 2)\n\t\treturn (T)BitReverse((word16)value);\n\telse if (sizeof(T) == 4)\n\t\treturn (T)BitReverse((word32)value);\n\telse\n\t{\n\t\tassert(sizeof(T) == 8);\n\t\treturn (T)BitReverse((word64)value);\n\t}\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T BitReverse(T value)\n{\n\tif (sizeof(T) == 1)\n\t\treturn (T)BitReverse((byte)value);\n\telse if (sizeof(T) == 2)\n\t\treturn (T)BitReverse((word16)value);\n\telse if (sizeof(T) == 4)\n\t\treturn (T)BitReverse((word32)value);\n\telse\n\t{\n\t\tassert(sizeof(T) == 8);\n\t\treturn (T)BitReverse((word64)value);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_valueToCode.resize",
          "args": [
            "nCodes"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "maxCodeBits == 1 || code == (1 << maxCodeBits) - blCount[maxCodeBits]"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "blCount.begin()",
            "blCount.end()",
            "0"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blCount.end",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blCount.begin",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_element",
          "args": [
            "codeBits",
            "codeBits+nCodes"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nCodes > 0"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid HuffmanEncoder::Initialize(const unsigned int *codeBits, unsigned int nCodes)\n{\n\tassert(nCodes > 0);\n\tunsigned int maxCodeBits = *max_element(codeBits, codeBits+nCodes);\n\tif (maxCodeBits == 0)\n\t\treturn;\t\t// assume this object won't be used\n\n\tSecBlockWithHint<unsigned int, 15+1> blCount(maxCodeBits+1);\n\tfill(blCount.begin(), blCount.end(), 0);\n\tunsigned int i;\n\tfor (i=0; i<nCodes; i++)\n\t\tblCount[codeBits[i]]++;\n\n\tcode_t code = 0;\n\tSecBlockWithHint<code_t, 15+1> nextCode(maxCodeBits+1);\n\tnextCode[1] = 0;\n\tfor (i=2; i<=maxCodeBits; i++)\n\t{\n\t\tcode = (code + blCount[i-1]) << 1;\n\t\tnextCode[i] = code;\n\t}\n\tassert(maxCodeBits == 1 || code == (1 << maxCodeBits) - blCount[maxCodeBits]);\n\n\tm_valueToCode.resize(nCodes);\n\tfor (i=0; i<nCodes; i++)\n\t{\n\t\tunsigned int len = m_valueToCode[i].len = codeBits[i];\n\t\tif (len != 0)\n\t\t\tm_valueToCode[i].code = BitReverse(nextCode[len]++) >> (8*sizeof(code_t)-len);\n\t}\n}"
  },
  {
    "function_name": "HuffmanEncoder::GenerateCodeLengths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "109-180",
    "snippet": "void HuffmanEncoder::GenerateCodeLengths(unsigned int *codeBits, unsigned int maxCodeBits, const unsigned int *codeCounts, size_t nCodes)\n{\n\tassert(nCodes > 0);\n\tassert(nCodes <= ((size_t)1 << maxCodeBits));\n\n\tsize_t i;\n\tSecBlockWithHint<HuffmanNode, 2*286> tree(nCodes);\n\tfor (i=0; i<nCodes; i++)\n\t{\n\t\ttree[i].symbol = i;\n\t\ttree[i].freq = codeCounts[i];\n\t}\n\tsort(tree.begin(), tree.end(), FreqLessThan());\n\tsize_t treeBegin = upper_bound(tree.begin(), tree.end(), 0, FreqLessThan()) - tree.begin();\n\tif (treeBegin == nCodes)\n\t{\t// special case for no codes\n\t\tfill(codeBits, codeBits+nCodes, 0);\n\t\treturn;\n\t}\n\ttree.resize(nCodes + nCodes - treeBegin - 1);\n\n\tsize_t leastLeaf = treeBegin, leastInterior = nCodes;\n\tfor (i=nCodes; i<tree.size(); i++)\n\t{\n\t\tsize_t least;\n\t\tleast = (leastLeaf == nCodes || (leastInterior < i && tree[leastInterior].freq < tree[leastLeaf].freq)) ? leastInterior++ : leastLeaf++;\n\t\ttree[i].freq = tree[least].freq;\n\t\ttree[least].parent = i;\n\t\tleast = (leastLeaf == nCodes || (leastInterior < i && tree[leastInterior].freq < tree[leastLeaf].freq)) ? leastInterior++ : leastLeaf++;\n\t\ttree[i].freq += tree[least].freq;\n\t\ttree[least].parent = i;\n\t}\n\n\ttree[tree.size()-1].depth = 0;\n\tif (tree.size() >= 2)\n\t\tfor (i=tree.size()-2; i>=nCodes; i--)\n\t\t\ttree[i].depth = tree[tree[i].parent].depth + 1;\n\tunsigned int sum = 0;\n\tSecBlockWithHint<unsigned int, 15+1> blCount(maxCodeBits+1);\n\tfill(blCount.begin(), blCount.end(), 0);\n\tfor (i=treeBegin; i<nCodes; i++)\n\t{\n\t\tsize_t depth = STDMIN(maxCodeBits, tree[tree[i].parent].depth + 1);\n\t\tblCount[depth]++;\n\t\tsum += 1 << (maxCodeBits - depth);\n\t}\n\n\tunsigned int overflow = sum > (unsigned int)(1 << maxCodeBits) ? sum - (1 << maxCodeBits) : 0;\n\n\twhile (overflow--)\n\t{\n\t\tunsigned int bits = maxCodeBits-1;\n\t\twhile (blCount[bits] == 0)\n\t\t\tbits--;\n\t\tblCount[bits]--;\n\t\tblCount[bits+1] += 2;\n\t\tassert(blCount[maxCodeBits] > 0);\n\t\tblCount[maxCodeBits]--;\n\t}\n\n\tfor (i=0; i<treeBegin; i++)\n\t\tcodeBits[tree[i].symbol] = 0;\n\tunsigned int bits = maxCodeBits;\n\tfor (i=treeBegin; i<nCodes; i++)\n\t{\n\t\twhile (blCount[bits] == 0)\n\t\t\tbits--;\n\t\tcodeBits[tree[i].symbol] = bits;\n\t\tblCount[bits]--;\n\t}\n\tassert(blCount[bits] == 0);\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "blCount[bits] == 0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "blCount[maxCodeBits] > 0"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "maxCodeBits",
            "tree[tree[i].parent].depth + 1"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "blCount.begin()",
            "blCount.end()",
            "0"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blCount.end",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "blCount.begin",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree.size",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree.resize",
          "args": [
            "nCodes + nCodes - treeBegin - 1"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill",
          "args": [
            "codeBits",
            "codeBits+nCodes",
            "0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_bound",
          "args": [
            "tree.begin()",
            "tree.end()",
            "0",
            "FreqLessThan()"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreqLessThan",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "tree.begin()",
            "tree.end()",
            "FreqLessThan()"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreqLessThan",
          "args": [],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nCodes <= ((size_t)1 << maxCodeBits)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nCodes > 0"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid HuffmanEncoder::GenerateCodeLengths(unsigned int *codeBits, unsigned int maxCodeBits, const unsigned int *codeCounts, size_t nCodes)\n{\n\tassert(nCodes > 0);\n\tassert(nCodes <= ((size_t)1 << maxCodeBits));\n\n\tsize_t i;\n\tSecBlockWithHint<HuffmanNode, 2*286> tree(nCodes);\n\tfor (i=0; i<nCodes; i++)\n\t{\n\t\ttree[i].symbol = i;\n\t\ttree[i].freq = codeCounts[i];\n\t}\n\tsort(tree.begin(), tree.end(), FreqLessThan());\n\tsize_t treeBegin = upper_bound(tree.begin(), tree.end(), 0, FreqLessThan()) - tree.begin();\n\tif (treeBegin == nCodes)\n\t{\t// special case for no codes\n\t\tfill(codeBits, codeBits+nCodes, 0);\n\t\treturn;\n\t}\n\ttree.resize(nCodes + nCodes - treeBegin - 1);\n\n\tsize_t leastLeaf = treeBegin, leastInterior = nCodes;\n\tfor (i=nCodes; i<tree.size(); i++)\n\t{\n\t\tsize_t least;\n\t\tleast = (leastLeaf == nCodes || (leastInterior < i && tree[leastInterior].freq < tree[leastLeaf].freq)) ? leastInterior++ : leastLeaf++;\n\t\ttree[i].freq = tree[least].freq;\n\t\ttree[least].parent = i;\n\t\tleast = (leastLeaf == nCodes || (leastInterior < i && tree[leastInterior].freq < tree[leastLeaf].freq)) ? leastInterior++ : leastLeaf++;\n\t\ttree[i].freq += tree[least].freq;\n\t\ttree[least].parent = i;\n\t}\n\n\ttree[tree.size()-1].depth = 0;\n\tif (tree.size() >= 2)\n\t\tfor (i=tree.size()-2; i>=nCodes; i--)\n\t\t\ttree[i].depth = tree[tree[i].parent].depth + 1;\n\tunsigned int sum = 0;\n\tSecBlockWithHint<unsigned int, 15+1> blCount(maxCodeBits+1);\n\tfill(blCount.begin(), blCount.end(), 0);\n\tfor (i=treeBegin; i<nCodes; i++)\n\t{\n\t\tsize_t depth = STDMIN(maxCodeBits, tree[tree[i].parent].depth + 1);\n\t\tblCount[depth]++;\n\t\tsum += 1 << (maxCodeBits - depth);\n\t}\n\n\tunsigned int overflow = sum > (unsigned int)(1 << maxCodeBits) ? sum - (1 << maxCodeBits) : 0;\n\n\twhile (overflow--)\n\t{\n\t\tunsigned int bits = maxCodeBits-1;\n\t\twhile (blCount[bits] == 0)\n\t\t\tbits--;\n\t\tblCount[bits]--;\n\t\tblCount[bits+1] += 2;\n\t\tassert(blCount[maxCodeBits] > 0);\n\t\tblCount[maxCodeBits]--;\n\t}\n\n\tfor (i=0; i<treeBegin; i++)\n\t\tcodeBits[tree[i].symbol] = 0;\n\tunsigned int bits = maxCodeBits;\n\tfor (i=treeBegin; i<nCodes; i++)\n\t{\n\t\twhile (blCount[bits] == 0)\n\t\t\tbits--;\n\t\tcodeBits[tree[i].symbol] = bits;\n\t\tblCount[bits]--;\n\t}\n\tassert(blCount[bits] == 0);\n}"
  },
  {
    "function_name": "HuffmanEncoder::HuffmanEncoder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "90-93",
    "snippet": "HuffmanEncoder::HuffmanEncoder(const unsigned int *codeBits, unsigned int nCodes)\n{\n\tInitialize(codeBits, nCodes);\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Initialize",
          "args": [
            "codeBits",
            "nCodes"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "HuffmanEncoder::Initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
          "lines": "182-212",
          "snippet": "void HuffmanEncoder::Initialize(const unsigned int *codeBits, unsigned int nCodes)\n{\n\tassert(nCodes > 0);\n\tunsigned int maxCodeBits = *max_element(codeBits, codeBits+nCodes);\n\tif (maxCodeBits == 0)\n\t\treturn;\t\t// assume this object won't be used\n\n\tSecBlockWithHint<unsigned int, 15+1> blCount(maxCodeBits+1);\n\tfill(blCount.begin(), blCount.end(), 0);\n\tunsigned int i;\n\tfor (i=0; i<nCodes; i++)\n\t\tblCount[codeBits[i]]++;\n\n\tcode_t code = 0;\n\tSecBlockWithHint<code_t, 15+1> nextCode(maxCodeBits+1);\n\tnextCode[1] = 0;\n\tfor (i=2; i<=maxCodeBits; i++)\n\t{\n\t\tcode = (code + blCount[i-1]) << 1;\n\t\tnextCode[i] = code;\n\t}\n\tassert(maxCodeBits == 1 || code == (1 << maxCodeBits) - blCount[maxCodeBits]);\n\n\tm_valueToCode.resize(nCodes);\n\tfor (i=0; i<nCodes; i++)\n\t{\n\t\tunsigned int len = m_valueToCode[i].len = codeBits[i];\n\t\tif (len != 0)\n\t\t\tm_valueToCode[i].code = BitReverse(nextCode[len]++) >> (8*sizeof(code_t)-len);\n\t}\n}",
          "includes": [
            "#include <iterator>",
            "#include <functional>",
            "#include \"zdeflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid HuffmanEncoder::Initialize(const unsigned int *codeBits, unsigned int nCodes)\n{\n\tassert(nCodes > 0);\n\tunsigned int maxCodeBits = *max_element(codeBits, codeBits+nCodes);\n\tif (maxCodeBits == 0)\n\t\treturn;\t\t// assume this object won't be used\n\n\tSecBlockWithHint<unsigned int, 15+1> blCount(maxCodeBits+1);\n\tfill(blCount.begin(), blCount.end(), 0);\n\tunsigned int i;\n\tfor (i=0; i<nCodes; i++)\n\t\tblCount[codeBits[i]]++;\n\n\tcode_t code = 0;\n\tSecBlockWithHint<code_t, 15+1> nextCode(maxCodeBits+1);\n\tnextCode[1] = 0;\n\tfor (i=2; i<=maxCodeBits; i++)\n\t{\n\t\tcode = (code + blCount[i-1]) << 1;\n\t\tnextCode[i] = code;\n\t}\n\tassert(maxCodeBits == 1 || code == (1 << maxCodeBits) - blCount[maxCodeBits]);\n\n\tm_valueToCode.resize(nCodes);\n\tfor (i=0; i<nCodes; i++)\n\t{\n\t\tunsigned int len = m_valueToCode[i].len = codeBits[i];\n\t\tif (len != 0)\n\t\t\tm_valueToCode[i].code = BitReverse(nextCode[len]++) >> (8*sizeof(code_t)-len);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nHuffmanEncoder::HuffmanEncoder(const unsigned int *codeBits, unsigned int nCodes)\n{\n\tInitialize(codeBits, nCodes);\n}"
  },
  {
    "function_name": "LowFirstBitWriter::ClearBitBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "83-88",
    "snippet": "void LowFirstBitWriter::ClearBitBuffer()\n{\n\tm_buffer = 0;\n\tm_bytesBuffered = 0;\n\tm_bitsBuffered = 0;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::ClearBitBuffer()\n{\n\tm_buffer = 0;\n\tm_bytesBuffered = 0;\n\tm_bitsBuffered = 0;\n}"
  },
  {
    "function_name": "LowFirstBitWriter::FlushBitBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "63-81",
    "snippet": "void LowFirstBitWriter::FlushBitBuffer()\n{\n\tif (m_counting)\n\t\tm_bitCount += 8*(m_bitsBuffered > 0);\n\telse\n\t{\n\t\tif (m_bytesBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\tm_bytesBuffered = 0;\n\t\t}\n\t\tif (m_bitsBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->Put((byte)m_buffer);\n\t\t\tm_buffer = 0;\n\t\t\tm_bitsBuffered = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte)m_buffer"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "m_outputBuffer",
            "m_bytesBuffered"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::FlushBitBuffer()\n{\n\tif (m_counting)\n\t\tm_bitCount += 8*(m_bitsBuffered > 0);\n\telse\n\t{\n\t\tif (m_bytesBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\tm_bytesBuffered = 0;\n\t\t}\n\t\tif (m_bitsBuffered > 0)\n\t\t{\n\t\t\tAttachedTransformation()->Put((byte)m_buffer);\n\t\t\tm_buffer = 0;\n\t\t\tm_bitsBuffered = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "LowFirstBitWriter::PutBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "40-61",
    "snippet": "void LowFirstBitWriter::PutBits(unsigned long value, unsigned int length)\n{\n\tif (m_counting)\n\t\tm_bitCount += length;\n\telse\n\t{\n\t\tm_buffer |= value << m_bitsBuffered;\n\t\tm_bitsBuffered += length;\n\t\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\t\twhile (m_bitsBuffered >= 8)\n\t\t{\n\t\t\tm_outputBuffer[m_bytesBuffered++] = (byte)m_buffer;\n\t\t\tif (m_bytesBuffered == m_outputBuffer.size())\n\t\t\t{\n\t\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\t\tm_bytesBuffered = 0;\n\t\t\t}\n\t\t\tm_buffer >>= 8;\n\t\t\tm_bitsBuffered -= 8;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "m_outputBuffer",
            "m_bytesBuffered"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputBuffer.size",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_bitsBuffered <= sizeof(unsigned long)*8"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::PutBits(unsigned long value, unsigned int length)\n{\n\tif (m_counting)\n\t\tm_bitCount += length;\n\telse\n\t{\n\t\tm_buffer |= value << m_bitsBuffered;\n\t\tm_bitsBuffered += length;\n\t\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\t\twhile (m_bitsBuffered >= 8)\n\t\t{\n\t\t\tm_outputBuffer[m_bytesBuffered++] = (byte)m_buffer;\n\t\t\tif (m_bytesBuffered == m_outputBuffer.size())\n\t\t\t{\n\t\t\t\tAttachedTransformation()->PutModifiable(m_outputBuffer, m_bytesBuffered);\n\t\t\t\tm_bytesBuffered = 0;\n\t\t\t}\n\t\t\tm_buffer >>= 8;\n\t\t\tm_bitsBuffered -= 8;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "LowFirstBitWriter::FinishCounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "33-38",
    "snippet": "unsigned long LowFirstBitWriter::FinishCounting()\n{\n\tassert(m_counting);\n\tm_counting = false;\n\treturn m_bitCount;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_counting"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nunsigned long LowFirstBitWriter::FinishCounting()\n{\n\tassert(m_counting);\n\tm_counting = false;\n\treturn m_bitCount;\n}"
  },
  {
    "function_name": "LowFirstBitWriter::StartCounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "26-31",
    "snippet": "void LowFirstBitWriter::StartCounting()\n{\n\tassert(!m_counting);\n\tm_counting = true;\n\tm_bitCount = 0;\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!m_counting"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nvoid LowFirstBitWriter::StartCounting()\n{\n\tassert(!m_counting);\n\tm_counting = true;\n\tm_bitCount = 0;\n}"
  },
  {
    "function_name": "LowFirstBitWriter::LowFirstBitWriter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zdeflate.cpp",
    "lines": "21-24",
    "snippet": "LowFirstBitWriter::LowFirstBitWriter(BufferedTransformation *attachment)\n\t: Filter(attachment), m_counting(false), m_buffer(0), m_bitsBuffered(0), m_bytesBuffered(0)\n{\n}",
    "includes": [
      "#include <iterator>",
      "#include <functional>",
      "#include \"zdeflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <iterator>\n#include <functional>\n#include \"zdeflate.h\"\n#include \"pch.h\"\n\nLowFirstBitWriter::LowFirstBitWriter(BufferedTransformation *attachment)\n\t: Filter(attachment), m_counting(false), m_buffer(0), m_bitsBuffered(0), m_bytesBuffered(0)\n{\n}"
  }
]