[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/dlltest.cpp",
    "lines": "199-203",
    "snippet": "int __cdecl main()\n{\n\tFIPS140_SampleApplication();\n\treturn 0;\n}",
    "includes": [
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FIPS140_SampleApplication",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "FIPS140_SampleApplication",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/dlltest.cpp",
          "lines": "10-172",
          "snippet": "void FIPS140_SampleApplication()\n{\n\tif (!FIPS_140_2_ComplianceEnabled())\n\t{\n\t\tcerr << \"FIPS 140-2 compliance was turned off at compile time.\\n\";\n\t\tabort();\n\t}\n\n\t// check self test status\n\tif (GetPowerUpSelfTestStatus() != POWER_UP_SELF_TEST_PASSED)\n\t{\n\t\tcerr << \"Automatic power-up self test failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"0. Automatic power-up self test passed.\\n\";\n\n\t// simulate a power-up self test error\n\tSimulatePowerUpSelfTestFailure();\n\ttry\n\t{\n\t\t// trying to use a crypto algorithm after power-up self test error will result in an exception\n\t\tAES::Encryption aes;\n\n\t\t// should not be here\n\t\tcerr << \"Use of AES failed to cause an exception after power-up self test error.\\n\";\n\t\tabort();\n\t}\n\tcatch (SelfTestFailure &e)\n\t{\n\t\tcout << \"1. Caught expected exception when simulating self test failure. Exception message follows: \";\n\t\tcout << e.what() << endl;\n\t}\n\n\t// clear the self test error state and redo power-up self test\n\tDoDllPowerUpSelfTest();\n\tif (GetPowerUpSelfTestStatus() != POWER_UP_SELF_TEST_PASSED)\n\t{\n\t\tcerr << \"Re-do power-up self test failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"2. Re-do power-up self test passed.\\n\";\n\n\t// encrypt and decrypt\n\tconst byte key[] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef, 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef, 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};\n\tconst byte iv[] = {0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef};\n\tconst byte plaintext[] = {\t// \"Now is the time for all \" without tailing 0\n\t\t0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,\n\t\t0x68,0x65,0x20,0x74,0x69,0x6d,0x65,0x20,\n\t\t0x66,0x6f,0x72,0x20,0x61,0x6c,0x6c,0x20};\n\tbyte ciphertext[24];\n\tbyte decrypted[24];\n\n\tCFB_FIPS_Mode<DES_EDE3>::Encryption encryption_DES_EDE3_CFB;\n\tencryption_DES_EDE3_CFB.SetKeyWithIV(key, sizeof(key), iv);\n\tencryption_DES_EDE3_CFB.ProcessString(ciphertext, plaintext, 24);\n\n\tCFB_FIPS_Mode<DES_EDE3>::Decryption decryption_DES_EDE3_CFB;\n\tdecryption_DES_EDE3_CFB.SetKeyWithIV(key, sizeof(key), iv);\n\tdecryption_DES_EDE3_CFB.ProcessString(decrypted, ciphertext, 24);\n\n\tif (memcmp(plaintext, decrypted, 24) != 0)\n\t{\n\t\tcerr << \"DES-EDE3-CFB Encryption/decryption failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"3. DES-EDE3-CFB Encryption/decryption succeeded.\\n\";\n\n\t// hash\n\tconst byte message[] = {'a', 'b', 'c'};\n\tconst byte expectedDigest[] = {0xA9,0x99,0x3E,0x36,0x47,0x06,0x81,0x6A,0xBA,0x3E,0x25,0x71,0x78,0x50,0xC2,0x6C,0x9C,0xD0,0xD8,0x9D};\n\tbyte digest[20];\n\t\n\tSHA1 sha;\n\tsha.Update(message, 3);\n\tsha.Final(digest);\n\n\tif (memcmp(digest, expectedDigest, 20) != 0)\n\t{\n\t\tcerr << \"SHA-1 hash failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"4. SHA-1 hash succeeded.\\n\";\n\n\t// create auto-seeded X9.17 RNG object, if available\n#ifdef OS_RNG_AVAILABLE\n\tAutoSeededX917RNG<AES> rng;\n#else\n\t// this is used to allow this function to compile on platforms that don't have auto-seeded RNGs\n\tRandomNumberGenerator &rng(NullRNG());\n#endif\n\n\t// generate DSA key\n\tDSA::PrivateKey dsaPrivateKey;\n\tdsaPrivateKey.GenerateRandomWithKeySize(rng, 1024);\n\tDSA::PublicKey dsaPublicKey;\n\tdsaPublicKey.AssignFrom(dsaPrivateKey);\n\tif (!dsaPrivateKey.Validate(rng, 3) || !dsaPublicKey.Validate(rng, 3))\n\t{\n\t\tcerr << \"DSA key generation failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"5. DSA key generation succeeded.\\n\";\n\n\t// encode DSA key\n\tstd::string encodedDsaPublicKey, encodedDsaPrivateKey;\n\tdsaPublicKey.DEREncode(StringSink(encodedDsaPublicKey).Ref());\n\tdsaPrivateKey.DEREncode(StringSink(encodedDsaPrivateKey).Ref());\n\n\t// decode DSA key\n\tDSA::PrivateKey decodedDsaPrivateKey;\n\tdecodedDsaPrivateKey.BERDecode(StringStore(encodedDsaPrivateKey).Ref());\n\tDSA::PublicKey decodedDsaPublicKey;\n\tdecodedDsaPublicKey.BERDecode(StringStore(encodedDsaPublicKey).Ref());\n\n\tif (!decodedDsaPrivateKey.Validate(rng, 3) || !decodedDsaPublicKey.Validate(rng, 3))\n\t{\n\t\tcerr << \"DSA key encode/decode failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"6. DSA key encode/decode succeeded.\\n\";\n\n\t// sign and verify\n\tbyte signature[40];\n\tDSA::Signer signer(dsaPrivateKey);\n\tassert(signer.SignatureLength() == 40);\n\tsigner.SignMessage(rng, message, 3, signature);\n\n\tDSA::Verifier verifier(dsaPublicKey);\n\tif (!verifier.VerifyMessage(message, 3, signature, sizeof(signature)))\n\t{\n\t\tcerr << \"DSA signature and verification failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"7. DSA signature and verification succeeded.\\n\";\n\n\n\t// try to verify an invalid signature\n\tsignature[0] ^= 1;\n\tif (verifier.VerifyMessage(message, 3, signature, sizeof(signature)))\n\t{\n\t\tcerr << \"DSA signature verification failed to detect bad signature.\\n\";\n\t\tabort();\n\t}\n\tcout << \"8. DSA signature verification successfully detected bad signature.\\n\";\n\n\t// try to use an invalid key length\n\ttry\n\t{\n\t\tECB_Mode<DES_EDE3>::Encryption encryption_DES_EDE3_ECB;\n\t\tencryption_DES_EDE3_ECB.SetKey(key, 5);\n\n\t\t// should not be here\n\t\tcerr << \"DES-EDE3 implementation did not detect use of invalid key length.\\n\";\n\t\tabort();\n\t}\n\tcatch (InvalidArgument &e)\n\t{\n\t\tcout << \"9. Caught expected exception when using invalid key length. Exception message follows: \";\n\t\tcout << e.what() << endl;\n\t}\n\n\tcout << \"\\nFIPS 140-2 Sample Application completed normally.\\n\";\n}",
          "includes": [
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dll.h\"\n\nvoid FIPS140_SampleApplication()\n{\n\tif (!FIPS_140_2_ComplianceEnabled())\n\t{\n\t\tcerr << \"FIPS 140-2 compliance was turned off at compile time.\\n\";\n\t\tabort();\n\t}\n\n\t// check self test status\n\tif (GetPowerUpSelfTestStatus() != POWER_UP_SELF_TEST_PASSED)\n\t{\n\t\tcerr << \"Automatic power-up self test failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"0. Automatic power-up self test passed.\\n\";\n\n\t// simulate a power-up self test error\n\tSimulatePowerUpSelfTestFailure();\n\ttry\n\t{\n\t\t// trying to use a crypto algorithm after power-up self test error will result in an exception\n\t\tAES::Encryption aes;\n\n\t\t// should not be here\n\t\tcerr << \"Use of AES failed to cause an exception after power-up self test error.\\n\";\n\t\tabort();\n\t}\n\tcatch (SelfTestFailure &e)\n\t{\n\t\tcout << \"1. Caught expected exception when simulating self test failure. Exception message follows: \";\n\t\tcout << e.what() << endl;\n\t}\n\n\t// clear the self test error state and redo power-up self test\n\tDoDllPowerUpSelfTest();\n\tif (GetPowerUpSelfTestStatus() != POWER_UP_SELF_TEST_PASSED)\n\t{\n\t\tcerr << \"Re-do power-up self test failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"2. Re-do power-up self test passed.\\n\";\n\n\t// encrypt and decrypt\n\tconst byte key[] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef, 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef, 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};\n\tconst byte iv[] = {0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef};\n\tconst byte plaintext[] = {\t// \"Now is the time for all \" without tailing 0\n\t\t0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,\n\t\t0x68,0x65,0x20,0x74,0x69,0x6d,0x65,0x20,\n\t\t0x66,0x6f,0x72,0x20,0x61,0x6c,0x6c,0x20};\n\tbyte ciphertext[24];\n\tbyte decrypted[24];\n\n\tCFB_FIPS_Mode<DES_EDE3>::Encryption encryption_DES_EDE3_CFB;\n\tencryption_DES_EDE3_CFB.SetKeyWithIV(key, sizeof(key), iv);\n\tencryption_DES_EDE3_CFB.ProcessString(ciphertext, plaintext, 24);\n\n\tCFB_FIPS_Mode<DES_EDE3>::Decryption decryption_DES_EDE3_CFB;\n\tdecryption_DES_EDE3_CFB.SetKeyWithIV(key, sizeof(key), iv);\n\tdecryption_DES_EDE3_CFB.ProcessString(decrypted, ciphertext, 24);\n\n\tif (memcmp(plaintext, decrypted, 24) != 0)\n\t{\n\t\tcerr << \"DES-EDE3-CFB Encryption/decryption failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"3. DES-EDE3-CFB Encryption/decryption succeeded.\\n\";\n\n\t// hash\n\tconst byte message[] = {'a', 'b', 'c'};\n\tconst byte expectedDigest[] = {0xA9,0x99,0x3E,0x36,0x47,0x06,0x81,0x6A,0xBA,0x3E,0x25,0x71,0x78,0x50,0xC2,0x6C,0x9C,0xD0,0xD8,0x9D};\n\tbyte digest[20];\n\t\n\tSHA1 sha;\n\tsha.Update(message, 3);\n\tsha.Final(digest);\n\n\tif (memcmp(digest, expectedDigest, 20) != 0)\n\t{\n\t\tcerr << \"SHA-1 hash failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"4. SHA-1 hash succeeded.\\n\";\n\n\t// create auto-seeded X9.17 RNG object, if available\n#ifdef OS_RNG_AVAILABLE\n\tAutoSeededX917RNG<AES> rng;\n#else\n\t// this is used to allow this function to compile on platforms that don't have auto-seeded RNGs\n\tRandomNumberGenerator &rng(NullRNG());\n#endif\n\n\t// generate DSA key\n\tDSA::PrivateKey dsaPrivateKey;\n\tdsaPrivateKey.GenerateRandomWithKeySize(rng, 1024);\n\tDSA::PublicKey dsaPublicKey;\n\tdsaPublicKey.AssignFrom(dsaPrivateKey);\n\tif (!dsaPrivateKey.Validate(rng, 3) || !dsaPublicKey.Validate(rng, 3))\n\t{\n\t\tcerr << \"DSA key generation failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"5. DSA key generation succeeded.\\n\";\n\n\t// encode DSA key\n\tstd::string encodedDsaPublicKey, encodedDsaPrivateKey;\n\tdsaPublicKey.DEREncode(StringSink(encodedDsaPublicKey).Ref());\n\tdsaPrivateKey.DEREncode(StringSink(encodedDsaPrivateKey).Ref());\n\n\t// decode DSA key\n\tDSA::PrivateKey decodedDsaPrivateKey;\n\tdecodedDsaPrivateKey.BERDecode(StringStore(encodedDsaPrivateKey).Ref());\n\tDSA::PublicKey decodedDsaPublicKey;\n\tdecodedDsaPublicKey.BERDecode(StringStore(encodedDsaPublicKey).Ref());\n\n\tif (!decodedDsaPrivateKey.Validate(rng, 3) || !decodedDsaPublicKey.Validate(rng, 3))\n\t{\n\t\tcerr << \"DSA key encode/decode failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"6. DSA key encode/decode succeeded.\\n\";\n\n\t// sign and verify\n\tbyte signature[40];\n\tDSA::Signer signer(dsaPrivateKey);\n\tassert(signer.SignatureLength() == 40);\n\tsigner.SignMessage(rng, message, 3, signature);\n\n\tDSA::Verifier verifier(dsaPublicKey);\n\tif (!verifier.VerifyMessage(message, 3, signature, sizeof(signature)))\n\t{\n\t\tcerr << \"DSA signature and verification failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"7. DSA signature and verification succeeded.\\n\";\n\n\n\t// try to verify an invalid signature\n\tsignature[0] ^= 1;\n\tif (verifier.VerifyMessage(message, 3, signature, sizeof(signature)))\n\t{\n\t\tcerr << \"DSA signature verification failed to detect bad signature.\\n\";\n\t\tabort();\n\t}\n\tcout << \"8. DSA signature verification successfully detected bad signature.\\n\";\n\n\t// try to use an invalid key length\n\ttry\n\t{\n\t\tECB_Mode<DES_EDE3>::Encryption encryption_DES_EDE3_ECB;\n\t\tencryption_DES_EDE3_ECB.SetKey(key, 5);\n\n\t\t// should not be here\n\t\tcerr << \"DES-EDE3 implementation did not detect use of invalid key length.\\n\";\n\t\tabort();\n\t}\n\tcatch (InvalidArgument &e)\n\t{\n\t\tcout << \"9. Caught expected exception when using invalid key length. Exception message follows: \";\n\t\tcout << e.what() << endl;\n\t}\n\n\tcout << \"\\nFIPS 140-2 Sample Application completed normally.\\n\";\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dll.h\"\n\nint __cdecl main()\n{\n\tFIPS140_SampleApplication();\n\treturn 0;\n}"
  },
  {
    "function_name": "SetNewAndDeleteFromCryptoPP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/dlltest.cpp",
    "lines": "179-183",
    "snippet": "__declspec(dllexport) void __cdecl SetNewAndDeleteFromCryptoPP(PNew pNew, PDelete pDelete, PSetNewHandler pSetNewHandler)\n{\n\ts_pNew = pNew;\n\ts_pDelete = pDelete;\n}",
    "includes": [
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"dll.h\"\n\n__declspec(dllexport) void __cdecl SetNewAndDeleteFromCryptoPP(PNew pNew, PDelete pDelete, PSetNewHandler pSetNewHandler)\n{\n\ts_pNew = pNew;\n\ts_pDelete = pDelete;\n}"
  },
  {
    "function_name": "FIPS140_SampleApplication",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/dlltest.cpp",
    "lines": "10-172",
    "snippet": "void FIPS140_SampleApplication()\n{\n\tif (!FIPS_140_2_ComplianceEnabled())\n\t{\n\t\tcerr << \"FIPS 140-2 compliance was turned off at compile time.\\n\";\n\t\tabort();\n\t}\n\n\t// check self test status\n\tif (GetPowerUpSelfTestStatus() != POWER_UP_SELF_TEST_PASSED)\n\t{\n\t\tcerr << \"Automatic power-up self test failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"0. Automatic power-up self test passed.\\n\";\n\n\t// simulate a power-up self test error\n\tSimulatePowerUpSelfTestFailure();\n\ttry\n\t{\n\t\t// trying to use a crypto algorithm after power-up self test error will result in an exception\n\t\tAES::Encryption aes;\n\n\t\t// should not be here\n\t\tcerr << \"Use of AES failed to cause an exception after power-up self test error.\\n\";\n\t\tabort();\n\t}\n\tcatch (SelfTestFailure &e)\n\t{\n\t\tcout << \"1. Caught expected exception when simulating self test failure. Exception message follows: \";\n\t\tcout << e.what() << endl;\n\t}\n\n\t// clear the self test error state and redo power-up self test\n\tDoDllPowerUpSelfTest();\n\tif (GetPowerUpSelfTestStatus() != POWER_UP_SELF_TEST_PASSED)\n\t{\n\t\tcerr << \"Re-do power-up self test failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"2. Re-do power-up self test passed.\\n\";\n\n\t// encrypt and decrypt\n\tconst byte key[] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef, 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef, 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};\n\tconst byte iv[] = {0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef};\n\tconst byte plaintext[] = {\t// \"Now is the time for all \" without tailing 0\n\t\t0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,\n\t\t0x68,0x65,0x20,0x74,0x69,0x6d,0x65,0x20,\n\t\t0x66,0x6f,0x72,0x20,0x61,0x6c,0x6c,0x20};\n\tbyte ciphertext[24];\n\tbyte decrypted[24];\n\n\tCFB_FIPS_Mode<DES_EDE3>::Encryption encryption_DES_EDE3_CFB;\n\tencryption_DES_EDE3_CFB.SetKeyWithIV(key, sizeof(key), iv);\n\tencryption_DES_EDE3_CFB.ProcessString(ciphertext, plaintext, 24);\n\n\tCFB_FIPS_Mode<DES_EDE3>::Decryption decryption_DES_EDE3_CFB;\n\tdecryption_DES_EDE3_CFB.SetKeyWithIV(key, sizeof(key), iv);\n\tdecryption_DES_EDE3_CFB.ProcessString(decrypted, ciphertext, 24);\n\n\tif (memcmp(plaintext, decrypted, 24) != 0)\n\t{\n\t\tcerr << \"DES-EDE3-CFB Encryption/decryption failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"3. DES-EDE3-CFB Encryption/decryption succeeded.\\n\";\n\n\t// hash\n\tconst byte message[] = {'a', 'b', 'c'};\n\tconst byte expectedDigest[] = {0xA9,0x99,0x3E,0x36,0x47,0x06,0x81,0x6A,0xBA,0x3E,0x25,0x71,0x78,0x50,0xC2,0x6C,0x9C,0xD0,0xD8,0x9D};\n\tbyte digest[20];\n\t\n\tSHA1 sha;\n\tsha.Update(message, 3);\n\tsha.Final(digest);\n\n\tif (memcmp(digest, expectedDigest, 20) != 0)\n\t{\n\t\tcerr << \"SHA-1 hash failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"4. SHA-1 hash succeeded.\\n\";\n\n\t// create auto-seeded X9.17 RNG object, if available\n#ifdef OS_RNG_AVAILABLE\n\tAutoSeededX917RNG<AES> rng;\n#else\n\t// this is used to allow this function to compile on platforms that don't have auto-seeded RNGs\n\tRandomNumberGenerator &rng(NullRNG());\n#endif\n\n\t// generate DSA key\n\tDSA::PrivateKey dsaPrivateKey;\n\tdsaPrivateKey.GenerateRandomWithKeySize(rng, 1024);\n\tDSA::PublicKey dsaPublicKey;\n\tdsaPublicKey.AssignFrom(dsaPrivateKey);\n\tif (!dsaPrivateKey.Validate(rng, 3) || !dsaPublicKey.Validate(rng, 3))\n\t{\n\t\tcerr << \"DSA key generation failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"5. DSA key generation succeeded.\\n\";\n\n\t// encode DSA key\n\tstd::string encodedDsaPublicKey, encodedDsaPrivateKey;\n\tdsaPublicKey.DEREncode(StringSink(encodedDsaPublicKey).Ref());\n\tdsaPrivateKey.DEREncode(StringSink(encodedDsaPrivateKey).Ref());\n\n\t// decode DSA key\n\tDSA::PrivateKey decodedDsaPrivateKey;\n\tdecodedDsaPrivateKey.BERDecode(StringStore(encodedDsaPrivateKey).Ref());\n\tDSA::PublicKey decodedDsaPublicKey;\n\tdecodedDsaPublicKey.BERDecode(StringStore(encodedDsaPublicKey).Ref());\n\n\tif (!decodedDsaPrivateKey.Validate(rng, 3) || !decodedDsaPublicKey.Validate(rng, 3))\n\t{\n\t\tcerr << \"DSA key encode/decode failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"6. DSA key encode/decode succeeded.\\n\";\n\n\t// sign and verify\n\tbyte signature[40];\n\tDSA::Signer signer(dsaPrivateKey);\n\tassert(signer.SignatureLength() == 40);\n\tsigner.SignMessage(rng, message, 3, signature);\n\n\tDSA::Verifier verifier(dsaPublicKey);\n\tif (!verifier.VerifyMessage(message, 3, signature, sizeof(signature)))\n\t{\n\t\tcerr << \"DSA signature and verification failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"7. DSA signature and verification succeeded.\\n\";\n\n\n\t// try to verify an invalid signature\n\tsignature[0] ^= 1;\n\tif (verifier.VerifyMessage(message, 3, signature, sizeof(signature)))\n\t{\n\t\tcerr << \"DSA signature verification failed to detect bad signature.\\n\";\n\t\tabort();\n\t}\n\tcout << \"8. DSA signature verification successfully detected bad signature.\\n\";\n\n\t// try to use an invalid key length\n\ttry\n\t{\n\t\tECB_Mode<DES_EDE3>::Encryption encryption_DES_EDE3_ECB;\n\t\tencryption_DES_EDE3_ECB.SetKey(key, 5);\n\n\t\t// should not be here\n\t\tcerr << \"DES-EDE3 implementation did not detect use of invalid key length.\\n\";\n\t\tabort();\n\t}\n\tcatch (InvalidArgument &e)\n\t{\n\t\tcout << \"9. Caught expected exception when using invalid key length. Exception message follows: \";\n\t\tcout << e.what() << endl;\n\t}\n\n\tcout << \"\\nFIPS 140-2 Sample Application completed normally.\\n\";\n}",
    "includes": [
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encryption_DES_EDE3_ECB.SetKey",
          "args": [
            "key",
            "5"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier.VerifyMessage",
          "args": [
            "message",
            "3",
            "signature",
            "sizeof(signature)"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyMessage",
          "container": "PK_Verifier",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "784-790",
          "snippet": "bool PK_Verifier::VerifyMessage(const byte *message, size_t messageLen, const byte *signature, size_t signatureLength) const\n{\n\tstd::auto_ptr<PK_MessageAccumulator> m(NewVerificationAccumulator());\n\tInputSignature(*m, signature, signatureLength);\n\tm->Update(message, messageLen);\n\treturn VerifyAndRestart(*m);\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nPK_Verifier {\n  bool PK_Verifier::VerifyMessage(const byte *message, size_t messageLen, const byte *signature, size_t signatureLength) const\n  {\n  \tstd::auto_ptr<PK_MessageAccumulator> m(NewVerificationAccumulator());\n  \tInputSignature(*m, signature, signatureLength);\n  \tm->Update(message, messageLen);\n  \treturn VerifyAndRestart(*m);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer.SignMessage",
          "args": [
            "rng",
            "message",
            "3",
            "signature"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "SignMessage",
          "container": "PK_Signer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "762-767",
          "snippet": "size_t PK_Signer::SignMessage(RandomNumberGenerator &rng, const byte *message, size_t messageLen, byte *signature) const\n{\n\tstd::auto_ptr<PK_MessageAccumulator> m(NewSignatureAccumulator(rng));\n\tm->Update(message, messageLen);\n\treturn SignAndRestart(rng, *m, signature, false);\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nPK_Signer {\n  size_t PK_Signer::SignMessage(RandomNumberGenerator &rng, const byte *message, size_t messageLen, byte *signature) const\n  {\n  \tstd::auto_ptr<PK_MessageAccumulator> m(NewSignatureAccumulator(rng));\n  \tm->Update(message, messageLen);\n  \treturn SignAndRestart(rng, *m, signature, false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "signer.SignatureLength() == 40"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer.SignatureLength",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decodedDsaPublicKey.Validate",
          "args": [
            "rng",
            "3"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "Validate",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "183-201",
          "snippet": "bool InvertibleRabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = RabinFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p%4 == 3 && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q%4 == 3 && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t\tpass = pass && Jacobi(m_r, m_p) == 1;\n\t\tpass = pass && Jacobi(m_r, m_q) == -1;\n\t\tpass = pass && Jacobi(m_s, m_p) == -1;\n\t\tpass = pass && Jacobi(m_s, m_q) == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
          "includes": [
            "#include \"modarith.h\"",
            "#include \"sha.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rabin.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  bool InvertibleRabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = RabinFunction::Validate(rng, level);\n  \tpass = pass && m_p > Integer::One() && m_p%4 == 3 && m_p < m_n;\n  \tpass = pass && m_q > Integer::One() && m_q%4 == 3 && m_q < m_n;\n  \tpass = pass && m_u.IsPositive() && m_u < m_p;\n  \tif (level >= 1)\n  \t{\n  \t\tpass = pass && m_p * m_q == m_n;\n  \t\tpass = pass && m_u * m_q % m_p == 1;\n  \t\tpass = pass && Jacobi(m_r, m_p) == 1;\n  \t\tpass = pass && Jacobi(m_r, m_q) == -1;\n  \t\tpass = pass && Jacobi(m_s, m_p) == -1;\n  \t\tpass = pass && Jacobi(m_s, m_q) == 1;\n  \t}\n  \tif (level >= 2)\n  \t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n  \treturn pass;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decodedDsaPublicKey.BERDecode",
          "args": [
            "StringStore(encodedDsaPublicKey).Ref()"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3146-3153",
          "snippet": "void Integer::BERDecode(BufferedTransformation &bt)\n{\n\tBERGeneralDecoder dec(bt, INTEGER);\n\tif (!dec.IsDefiniteLength() || dec.MaxRetrievable() < dec.RemainingLength())\n\t\tBERDecodeError();\n\tDecode(dec, (size_t)dec.RemainingLength(), SIGNED);\n\tdec.MessageEnd();\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERGeneralDecoder dec(bt, INTEGER);\n  \tif (!dec.IsDefiniteLength() || dec.MaxRetrievable() < dec.RemainingLength())\n  \t\tBERDecodeError();\n  \tDecode(dec, (size_t)dec.RemainingLength(), SIGNED);\n  \tdec.MessageEnd();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringStore",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "StringStore",
          "container": "StringStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "669-670",
          "snippet": "StringStore(const char *string = NULL)\n\t\t{StoreInitialize(MakeParameters(\"InputBuffer\", ConstByteArrayParameter(string)));}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringStore {\n  StringStore(const char *string = NULL)\n  \t\t{StoreInitialize(MakeParameters(\"InputBuffer\", ConstByteArrayParameter(string)));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringStore",
          "args": [
            "encodedDsaPublicKey"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "StoreInitialize",
          "container": "StringStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "1046-1054",
          "snippet": "void StringStore::StoreInitialize(const NameValuePairs &parameters)\n{\n\tConstByteArrayParameter array;\n\tif (!parameters.GetValue(Name::InputBuffer(), array))\n\t\tthrow InvalidArgument(\"StringStore: missing InputBuffer argument\");\n\tm_store = array.begin();\n\tm_length = array.size();\n\tm_count = 0;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nStringStore {\n  void StringStore::StoreInitialize(const NameValuePairs &parameters)\n  {\n  \tConstByteArrayParameter array;\n  \tif (!parameters.GetValue(Name::InputBuffer(), array))\n  \t\tthrow InvalidArgument(\"StringStore: missing InputBuffer argument\");\n  \tm_store = array.begin();\n  \tm_length = array.size();\n  \tm_count = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsaPrivateKey.DEREncode",
          "args": [
            "StringSink(encodedDsaPrivateKey).Ref()"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "ModularArithmetic",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "4021-4027",
          "snippet": "void ModularArithmetic::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tASN1::prime_field().DEREncode(seq);\n\tm_modulus.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nModularArithmetic {\n  void ModularArithmetic::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tASN1::prime_field().DEREncode(seq);\n  \tm_modulus.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [
            "encodedDsaPrivateKey"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "StringSinkTemplate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "594-595",
          "snippet": "void IsolatedInitialize(const NameValuePairs &parameters)\n\t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringSinkTemplate {\n  void IsolatedInitialize(const NameValuePairs &parameters)\n  \t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dsaPublicKey.AssignFrom",
          "args": [
            "dsaPrivateKey"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFrom",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "212-219",
          "snippet": "void InvertibleRabinFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper<RabinFunction>(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
          "includes": [
            "#include \"modarith.h\"",
            "#include \"sha.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rabin.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  void InvertibleRabinFunction::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper<RabinFunction>(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n  \t\t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dsaPrivateKey.GenerateRandomWithKeySize",
          "args": [
            "rng",
            "1024"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateRandomWithKeySize",
          "container": "GeneratableCryptoMaterial",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "658-661",
          "snippet": "void GeneratableCryptoMaterial::GenerateRandomWithKeySize(RandomNumberGenerator &rng, unsigned int keySize)\n{\n\tGenerateRandom(rng, MakeParameters(\"KeySize\", (int)keySize));\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nGeneratableCryptoMaterial {\n  void GeneratableCryptoMaterial::GenerateRandomWithKeySize(RandomNumberGenerator &rng, unsigned int keySize)\n  {\n  \tGenerateRandom(rng, MakeParameters(\"KeySize\", (int)keySize));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "digest",
            "expectedDigest",
            "20"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sha.Final",
          "args": [
            "digest"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sha.Update",
          "args": [
            "message",
            "3"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "plaintext",
            "decrypted",
            "24"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryption_DES_EDE3_CFB.ProcessString",
          "args": [
            "decrypted",
            "ciphertext",
            "24"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryption_DES_EDE3_CFB.SetKeyWithIV",
          "args": [
            "key",
            "sizeof(key)",
            "iv"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encryption_DES_EDE3_CFB.ProcessString",
          "args": [
            "ciphertext",
            "plaintext",
            "24"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encryption_DES_EDE3_CFB.SetKeyWithIV",
          "args": [
            "key",
            "sizeof(key)",
            "iv"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPowerUpSelfTestStatus",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "CRYPTOPP_API GetPowerUpSelfTestStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fips140.cpp",
          "lines": "38-41",
          "snippet": "PowerUpSelfTestStatus CRYPTOPP_API GetPowerUpSelfTestStatus()\n{\n\treturn g_powerUpSelfTestStatus;\n}",
          "includes": [
            "#include \"trdlocal.h\"\t// needs to be included last for cygwin",
            "#include \"fips140.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trdlocal.h\"\t// needs to be included last for cygwin\n#include \"fips140.h\"\n#include \"pch.h\"\n\nPowerUpSelfTestStatus CRYPTOPP_API GetPowerUpSelfTestStatus()\n{\n\treturn g_powerUpSelfTestStatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoDllPowerUpSelfTest",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "DoDllPowerUpSelfTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipstest.cpp",
          "lines": "575-578",
          "snippet": "void DoDllPowerUpSelfTest()\n{\n\tthrow NotImplemented(\"DoDllPowerUpSelfTest() only available on Windows\");\n}",
          "includes": [
            "#include <iostream>",
            "#include <windows.h>",
            "#include \"dll.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <windows.h>\n#include \"dll.h\"\n#include \"pch.h\"\n\nvoid DoDllPowerUpSelfTest()\n{\n\tthrow NotImplemented(\"DoDllPowerUpSelfTest() only available on Windows\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SimulatePowerUpSelfTestFailure",
          "args": [],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "SimulatePowerUpSelfTestFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fips140.cpp",
          "lines": "33-36",
          "snippet": "void SimulatePowerUpSelfTestFailure()\n{\n\tg_powerUpSelfTestStatus = POWER_UP_SELF_TEST_FAILED;\n}",
          "includes": [
            "#include \"trdlocal.h\"\t// needs to be included last for cygwin",
            "#include \"fips140.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trdlocal.h\"\t// needs to be included last for cygwin\n#include \"fips140.h\"\n#include \"pch.h\"\n\nvoid SimulatePowerUpSelfTestFailure()\n{\n\tg_powerUpSelfTestStatus = POWER_UP_SELF_TEST_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FIPS_140_2_ComplianceEnabled",
          "args": [],
          "line": 12
        },
        "resolved": true,
        "details": {
          "function_name": "FIPS_140_2_ComplianceEnabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fips140.cpp",
          "lines": "28-31",
          "snippet": "bool FIPS_140_2_ComplianceEnabled()\n{\n\treturn CRYPTOPP_ENABLE_COMPLIANCE_WITH_FIPS_140_2;\n}",
          "includes": [
            "#include \"trdlocal.h\"\t// needs to be included last for cygwin",
            "#include \"fips140.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_ENABLE_COMPLIANCE_WITH_FIPS_140_2 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trdlocal.h\"\t// needs to be included last for cygwin\n#include \"fips140.h\"\n#include \"pch.h\"\n\n#define CRYPTOPP_ENABLE_COMPLIANCE_WITH_FIPS_140_2 0\n\nbool FIPS_140_2_ComplianceEnabled()\n{\n\treturn CRYPTOPP_ENABLE_COMPLIANCE_WITH_FIPS_140_2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dll.h\"\n\nvoid FIPS140_SampleApplication()\n{\n\tif (!FIPS_140_2_ComplianceEnabled())\n\t{\n\t\tcerr << \"FIPS 140-2 compliance was turned off at compile time.\\n\";\n\t\tabort();\n\t}\n\n\t// check self test status\n\tif (GetPowerUpSelfTestStatus() != POWER_UP_SELF_TEST_PASSED)\n\t{\n\t\tcerr << \"Automatic power-up self test failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"0. Automatic power-up self test passed.\\n\";\n\n\t// simulate a power-up self test error\n\tSimulatePowerUpSelfTestFailure();\n\ttry\n\t{\n\t\t// trying to use a crypto algorithm after power-up self test error will result in an exception\n\t\tAES::Encryption aes;\n\n\t\t// should not be here\n\t\tcerr << \"Use of AES failed to cause an exception after power-up self test error.\\n\";\n\t\tabort();\n\t}\n\tcatch (SelfTestFailure &e)\n\t{\n\t\tcout << \"1. Caught expected exception when simulating self test failure. Exception message follows: \";\n\t\tcout << e.what() << endl;\n\t}\n\n\t// clear the self test error state and redo power-up self test\n\tDoDllPowerUpSelfTest();\n\tif (GetPowerUpSelfTestStatus() != POWER_UP_SELF_TEST_PASSED)\n\t{\n\t\tcerr << \"Re-do power-up self test failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"2. Re-do power-up self test passed.\\n\";\n\n\t// encrypt and decrypt\n\tconst byte key[] = {0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef, 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef, 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};\n\tconst byte iv[] = {0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef};\n\tconst byte plaintext[] = {\t// \"Now is the time for all \" without tailing 0\n\t\t0x4e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,\n\t\t0x68,0x65,0x20,0x74,0x69,0x6d,0x65,0x20,\n\t\t0x66,0x6f,0x72,0x20,0x61,0x6c,0x6c,0x20};\n\tbyte ciphertext[24];\n\tbyte decrypted[24];\n\n\tCFB_FIPS_Mode<DES_EDE3>::Encryption encryption_DES_EDE3_CFB;\n\tencryption_DES_EDE3_CFB.SetKeyWithIV(key, sizeof(key), iv);\n\tencryption_DES_EDE3_CFB.ProcessString(ciphertext, plaintext, 24);\n\n\tCFB_FIPS_Mode<DES_EDE3>::Decryption decryption_DES_EDE3_CFB;\n\tdecryption_DES_EDE3_CFB.SetKeyWithIV(key, sizeof(key), iv);\n\tdecryption_DES_EDE3_CFB.ProcessString(decrypted, ciphertext, 24);\n\n\tif (memcmp(plaintext, decrypted, 24) != 0)\n\t{\n\t\tcerr << \"DES-EDE3-CFB Encryption/decryption failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"3. DES-EDE3-CFB Encryption/decryption succeeded.\\n\";\n\n\t// hash\n\tconst byte message[] = {'a', 'b', 'c'};\n\tconst byte expectedDigest[] = {0xA9,0x99,0x3E,0x36,0x47,0x06,0x81,0x6A,0xBA,0x3E,0x25,0x71,0x78,0x50,0xC2,0x6C,0x9C,0xD0,0xD8,0x9D};\n\tbyte digest[20];\n\t\n\tSHA1 sha;\n\tsha.Update(message, 3);\n\tsha.Final(digest);\n\n\tif (memcmp(digest, expectedDigest, 20) != 0)\n\t{\n\t\tcerr << \"SHA-1 hash failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"4. SHA-1 hash succeeded.\\n\";\n\n\t// create auto-seeded X9.17 RNG object, if available\n#ifdef OS_RNG_AVAILABLE\n\tAutoSeededX917RNG<AES> rng;\n#else\n\t// this is used to allow this function to compile on platforms that don't have auto-seeded RNGs\n\tRandomNumberGenerator &rng(NullRNG());\n#endif\n\n\t// generate DSA key\n\tDSA::PrivateKey dsaPrivateKey;\n\tdsaPrivateKey.GenerateRandomWithKeySize(rng, 1024);\n\tDSA::PublicKey dsaPublicKey;\n\tdsaPublicKey.AssignFrom(dsaPrivateKey);\n\tif (!dsaPrivateKey.Validate(rng, 3) || !dsaPublicKey.Validate(rng, 3))\n\t{\n\t\tcerr << \"DSA key generation failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"5. DSA key generation succeeded.\\n\";\n\n\t// encode DSA key\n\tstd::string encodedDsaPublicKey, encodedDsaPrivateKey;\n\tdsaPublicKey.DEREncode(StringSink(encodedDsaPublicKey).Ref());\n\tdsaPrivateKey.DEREncode(StringSink(encodedDsaPrivateKey).Ref());\n\n\t// decode DSA key\n\tDSA::PrivateKey decodedDsaPrivateKey;\n\tdecodedDsaPrivateKey.BERDecode(StringStore(encodedDsaPrivateKey).Ref());\n\tDSA::PublicKey decodedDsaPublicKey;\n\tdecodedDsaPublicKey.BERDecode(StringStore(encodedDsaPublicKey).Ref());\n\n\tif (!decodedDsaPrivateKey.Validate(rng, 3) || !decodedDsaPublicKey.Validate(rng, 3))\n\t{\n\t\tcerr << \"DSA key encode/decode failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"6. DSA key encode/decode succeeded.\\n\";\n\n\t// sign and verify\n\tbyte signature[40];\n\tDSA::Signer signer(dsaPrivateKey);\n\tassert(signer.SignatureLength() == 40);\n\tsigner.SignMessage(rng, message, 3, signature);\n\n\tDSA::Verifier verifier(dsaPublicKey);\n\tif (!verifier.VerifyMessage(message, 3, signature, sizeof(signature)))\n\t{\n\t\tcerr << \"DSA signature and verification failed.\\n\";\n\t\tabort();\n\t}\n\tcout << \"7. DSA signature and verification succeeded.\\n\";\n\n\n\t// try to verify an invalid signature\n\tsignature[0] ^= 1;\n\tif (verifier.VerifyMessage(message, 3, signature, sizeof(signature)))\n\t{\n\t\tcerr << \"DSA signature verification failed to detect bad signature.\\n\";\n\t\tabort();\n\t}\n\tcout << \"8. DSA signature verification successfully detected bad signature.\\n\";\n\n\t// try to use an invalid key length\n\ttry\n\t{\n\t\tECB_Mode<DES_EDE3>::Encryption encryption_DES_EDE3_ECB;\n\t\tencryption_DES_EDE3_ECB.SetKey(key, 5);\n\n\t\t// should not be here\n\t\tcerr << \"DES-EDE3 implementation did not detect use of invalid key length.\\n\";\n\t\tabort();\n\t}\n\tcatch (InvalidArgument &e)\n\t{\n\t\tcout << \"9. Caught expected exception when using invalid key length. Exception message follows: \";\n\t\tcout << e.what() << endl;\n\t}\n\n\tcout << \"\\nFIPS 140-2 Sample Application completed normally.\\n\";\n}"
  }
]