[
  {
    "function_name": "CMAC_Base::TruncatedFinal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cmac.cpp",
    "lines": "99-118",
    "snippet": "void CMAC_Base::TruncatedFinal(byte *mac, size_t size)\r\n{\r\n\tThrowIfInvalidTruncatedSize(size);\r\n\r\n\tBlockCipher &cipher = AccessCipher();\r\n\tunsigned int blockSize = cipher.BlockSize();\r\n\r\n\tif (m_counter < blockSize)\r\n\t{\r\n\t\tm_reg[m_counter] ^= 0x80;\r\n\t\tcipher.AdvancedProcessBlocks(m_reg, m_reg+2*blockSize, m_reg, blockSize, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n\t}\r\n\telse\r\n\t\tcipher.AdvancedProcessBlocks(m_reg, m_reg+blockSize, m_reg, blockSize, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n\r\n\tmemcpy(mac, m_reg, size);\r\n\r\n\tm_counter = 0;\r\n\tmemset(m_reg, 0, blockSize);\r\n}",
    "includes": [
      "#include \"cmac.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_reg",
            "0",
            "blockSize"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mac",
            "m_reg",
            "size"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.AdvancedProcessBlocks",
          "args": [
            "m_reg",
            "m_reg+blockSize",
            "m_reg",
            "blockSize",
            "BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.AdvancedProcessBlocks",
          "args": [
            "m_reg",
            "m_reg+2*blockSize",
            "m_reg",
            "blockSize",
            "BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.BlockSize",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "AccessCipher",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ThrowIfInvalidTruncatedSize",
          "args": [
            "size"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "HashTransformation::ThrowIfInvalidTruncatedSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "309-313",
          "snippet": "void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n{\n\tif (size > DigestSize())\n\t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nvoid HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n{\n\tif (size > DigestSize())\n\t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cmac.h\"\n#include \"pch.h\"\n\nvoid CMAC_Base::TruncatedFinal(byte *mac, size_t size)\r\n{\r\n\tThrowIfInvalidTruncatedSize(size);\r\n\r\n\tBlockCipher &cipher = AccessCipher();\r\n\tunsigned int blockSize = cipher.BlockSize();\r\n\r\n\tif (m_counter < blockSize)\r\n\t{\r\n\t\tm_reg[m_counter] ^= 0x80;\r\n\t\tcipher.AdvancedProcessBlocks(m_reg, m_reg+2*blockSize, m_reg, blockSize, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n\t}\r\n\telse\r\n\t\tcipher.AdvancedProcessBlocks(m_reg, m_reg+blockSize, m_reg, blockSize, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n\r\n\tmemcpy(mac, m_reg, size);\r\n\r\n\tm_counter = 0;\r\n\tmemset(m_reg, 0, blockSize);\r\n}"
  },
  {
    "function_name": "CMAC_Base::Update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cmac.cpp",
    "lines": "58-97",
    "snippet": "void CMAC_Base::Update(const byte *input, size_t length)\r\n{\r\n\tif (!length)\r\n\t\treturn;\r\n\r\n\tBlockCipher &cipher = AccessCipher();\r\n\tunsigned int blockSize = cipher.BlockSize();\r\n\r\n\tif (m_counter > 0)\r\n\t{\r\n\t\tunsigned int len = UnsignedMin(blockSize - m_counter, length);\r\n\t\txorbuf(m_reg+m_counter, input, len);\r\n\t\tlength -= len;\r\n\t\tinput += len;\r\n\t\tm_counter += len;\r\n\r\n\t\tif (m_counter == blockSize && length > 0)\r\n\t\t{\r\n\t\t\tcipher.ProcessBlock(m_reg);\r\n\t\t\tm_counter = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (length > blockSize)\r\n\t{\r\n\t\tassert(m_counter == 0);\r\n\t\tsize_t leftOver = 1 + cipher.AdvancedProcessBlocks(m_reg, input, m_reg, length-1, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n\t\tinput += (length - leftOver);\r\n\t\tlength = leftOver;\r\n\t}\r\n\r\n\tif (length > 0)\r\n\t{\r\n\t\tassert(m_counter + length <= blockSize);\r\n\t\txorbuf(m_reg+m_counter, input, length);\r\n\t\tm_counter += (unsigned int)length;\r\n\t}\r\n\r\n\tassert(m_counter > 0);\r\n}",
    "includes": [
      "#include \"cmac.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_counter > 0"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "m_reg+m_counter",
            "input",
            "length"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_counter + length <= blockSize"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.AdvancedProcessBlocks",
          "args": [
            "m_reg",
            "input",
            "m_reg",
            "length-1",
            "BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_counter == 0"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "m_reg"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "blockSize - m_counter",
            "length"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher.BlockSize",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "AccessCipher",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cmac.h\"\n#include \"pch.h\"\n\nvoid CMAC_Base::Update(const byte *input, size_t length)\r\n{\r\n\tif (!length)\r\n\t\treturn;\r\n\r\n\tBlockCipher &cipher = AccessCipher();\r\n\tunsigned int blockSize = cipher.BlockSize();\r\n\r\n\tif (m_counter > 0)\r\n\t{\r\n\t\tunsigned int len = UnsignedMin(blockSize - m_counter, length);\r\n\t\txorbuf(m_reg+m_counter, input, len);\r\n\t\tlength -= len;\r\n\t\tinput += len;\r\n\t\tm_counter += len;\r\n\r\n\t\tif (m_counter == blockSize && length > 0)\r\n\t\t{\r\n\t\t\tcipher.ProcessBlock(m_reg);\r\n\t\t\tm_counter = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tif (length > blockSize)\r\n\t{\r\n\t\tassert(m_counter == 0);\r\n\t\tsize_t leftOver = 1 + cipher.AdvancedProcessBlocks(m_reg, input, m_reg, length-1, BlockTransformation::BT_DontIncrementInOutPointers|BlockTransformation::BT_XorInput);\r\n\t\tinput += (length - leftOver);\r\n\t\tlength = leftOver;\r\n\t}\r\n\r\n\tif (length > 0)\r\n\t{\r\n\t\tassert(m_counter + length <= blockSize);\r\n\t\txorbuf(m_reg+m_counter, input, length);\r\n\t\tm_counter += (unsigned int)length;\r\n\t}\r\n\r\n\tassert(m_counter > 0);\r\n}"
  },
  {
    "function_name": "CMAC_Base::UncheckedSetKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cmac.cpp",
    "lines": "43-56",
    "snippet": "void CMAC_Base::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\r\n{\r\n\tBlockCipher &cipher = AccessCipher();\r\n\tunsigned int blockSize = cipher.BlockSize();\r\n\r\n\tcipher.SetKey(key, length, params);\r\n\tm_reg.CleanNew(3*blockSize);\r\n\tm_counter = 0;\r\n\r\n\tcipher.ProcessBlock(m_reg, m_reg+blockSize);\r\n\tMulU(m_reg+blockSize, blockSize);\r\n\tmemcpy(m_reg+2*blockSize, m_reg+blockSize, blockSize);\r\n\tMulU(m_reg+2*blockSize, blockSize);\r\n}",
    "includes": [
      "#include \"cmac.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MulU",
          "args": [
            "m_reg+2*blockSize",
            "blockSize"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "MulU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cmac.cpp",
          "lines": "11-41",
          "snippet": "static void MulU(byte *k, unsigned int length)\r\n{\r\n\tbyte carry = 0;\r\n\r\n\tfor (int i=length-1; i>=1; i-=2)\r\n\t{\r\n\t\tbyte carry2 = k[i] >> 7;\r\n\t\tk[i] += k[i] + carry;\r\n\t\tcarry = k[i-1] >> 7;\r\n\t\tk[i-1] += k[i-1] + carry2;\r\n\t}\r\n\r\n\tif (carry)\r\n\t{\r\n\t\tswitch (length)\r\n\t\t{\r\n\t\tcase 8:\r\n\t\t\tk[7] ^= 0x1b;\r\n\t\t\tbreak;\r\n\t\tcase 16:\r\n\t\t\tk[15] ^= 0x87;\r\n\t\t\tbreak;\r\n\t\tcase 32:\r\n\t\t\tk[30] ^= 4; \r\n\t\t\tk[31] ^= 0x23;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow InvalidArgument(\"CMAC: \" + IntToString(length) + \" is not a supported cipher block size\");\r\n\t\t}\r\n\t}\r\n}",
          "includes": [
            "#include \"cmac.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cmac.h\"\n#include \"pch.h\"\n\nstatic void MulU(byte *k, unsigned int length)\r\n{\r\n\tbyte carry = 0;\r\n\r\n\tfor (int i=length-1; i>=1; i-=2)\r\n\t{\r\n\t\tbyte carry2 = k[i] >> 7;\r\n\t\tk[i] += k[i] + carry;\r\n\t\tcarry = k[i-1] >> 7;\r\n\t\tk[i-1] += k[i-1] + carry2;\r\n\t}\r\n\r\n\tif (carry)\r\n\t{\r\n\t\tswitch (length)\r\n\t\t{\r\n\t\tcase 8:\r\n\t\t\tk[7] ^= 0x1b;\r\n\t\t\tbreak;\r\n\t\tcase 16:\r\n\t\t\tk[15] ^= 0x87;\r\n\t\t\tbreak;\r\n\t\tcase 32:\r\n\t\t\tk[30] ^= 4; \r\n\t\t\tk[31] ^= 0x23;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow InvalidArgument(\"CMAC: \" + IntToString(length) + \" is not a supported cipher block size\");\r\n\t\t}\r\n\t}\r\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_reg+2*blockSize",
            "m_reg+blockSize",
            "blockSize"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.ProcessBlock",
          "args": [
            "m_reg",
            "m_reg+blockSize"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_reg.CleanNew",
          "args": [
            "3*blockSize"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "CleanNew",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "368-372",
          "snippet": "void CleanNew(size_type newSize)\n\t{\n\t\tNew(newSize);\n\t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void CleanNew(size_type newSize)\n  \t{\n  \t\tNew(newSize);\n  \t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher.SetKey",
          "args": [
            "key",
            "length",
            "params"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher.BlockSize",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "AccessCipher",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cmac.h\"\n#include \"pch.h\"\n\nvoid CMAC_Base::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\r\n{\r\n\tBlockCipher &cipher = AccessCipher();\r\n\tunsigned int blockSize = cipher.BlockSize();\r\n\r\n\tcipher.SetKey(key, length, params);\r\n\tm_reg.CleanNew(3*blockSize);\r\n\tm_counter = 0;\r\n\r\n\tcipher.ProcessBlock(m_reg, m_reg+blockSize);\r\n\tMulU(m_reg+blockSize, blockSize);\r\n\tmemcpy(m_reg+2*blockSize, m_reg+blockSize, blockSize);\r\n\tMulU(m_reg+2*blockSize, blockSize);\r\n}"
  },
  {
    "function_name": "MulU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cmac.cpp",
    "lines": "11-41",
    "snippet": "static void MulU(byte *k, unsigned int length)\r\n{\r\n\tbyte carry = 0;\r\n\r\n\tfor (int i=length-1; i>=1; i-=2)\r\n\t{\r\n\t\tbyte carry2 = k[i] >> 7;\r\n\t\tk[i] += k[i] + carry;\r\n\t\tcarry = k[i-1] >> 7;\r\n\t\tk[i-1] += k[i-1] + carry2;\r\n\t}\r\n\r\n\tif (carry)\r\n\t{\r\n\t\tswitch (length)\r\n\t\t{\r\n\t\tcase 8:\r\n\t\t\tk[7] ^= 0x1b;\r\n\t\t\tbreak;\r\n\t\tcase 16:\r\n\t\t\tk[15] ^= 0x87;\r\n\t\t\tbreak;\r\n\t\tcase 32:\r\n\t\t\tk[30] ^= 4; \r\n\t\t\tk[31] ^= 0x23;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow InvalidArgument(\"CMAC: \" + IntToString(length) + \" is not a supported cipher block size\");\r\n\t\t}\r\n\t}\r\n}",
    "includes": [
      "#include \"cmac.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"CMAC: \" + IntToString(length) + \" is not a supported cipher block size\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "length"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cmac.h\"\n#include \"pch.h\"\n\nstatic void MulU(byte *k, unsigned int length)\r\n{\r\n\tbyte carry = 0;\r\n\r\n\tfor (int i=length-1; i>=1; i-=2)\r\n\t{\r\n\t\tbyte carry2 = k[i] >> 7;\r\n\t\tk[i] += k[i] + carry;\r\n\t\tcarry = k[i-1] >> 7;\r\n\t\tk[i-1] += k[i-1] + carry2;\r\n\t}\r\n\r\n\tif (carry)\r\n\t{\r\n\t\tswitch (length)\r\n\t\t{\r\n\t\tcase 8:\r\n\t\t\tk[7] ^= 0x1b;\r\n\t\t\tbreak;\r\n\t\tcase 16:\r\n\t\t\tk[15] ^= 0x87;\r\n\t\t\tbreak;\r\n\t\tcase 32:\r\n\t\t\tk[30] ^= 4; \r\n\t\t\tk[31] ^= 0x23;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow InvalidArgument(\"CMAC: \" + IntToString(length) + \" is not a supported cipher block size\");\r\n\t\t}\r\n\t}\r\n}"
  }
]