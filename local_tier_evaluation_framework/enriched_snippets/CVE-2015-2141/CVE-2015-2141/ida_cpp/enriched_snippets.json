[
  {
    "function_name": "Put2",
    "container": "PaddingRemover",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "373-419",
    "snippet": "size_t PaddingRemover::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"PaddingRemover\");\n\n\tconst byte *const end = begin + length;\n\n\tif (m_possiblePadding)\n\t{\n\t\tsize_t len = find_if(begin, end, bind2nd(not_equal_to<byte>(), 0)) - begin;\n\t\tm_zeroCount += len;\n\t\tbegin += len;\n\t\tif (begin == end)\n\t\t\treturn 0;\n\n\t\tAttachedTransformation()->Put(1);\n\t\twhile (m_zeroCount--)\n\t\t\tAttachedTransformation()->Put(0);\n\t\tAttachedTransformation()->Put(*begin++);\n\t\tm_possiblePadding = false;\n\t}\n\n#if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n\t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n\ttypedef reverse_bidirectional_iterator<const byte *, const byte> RevIt;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n\ttypedef reverse_iterator<const byte *, random_access_iterator_tag, const byte> RevIt;\n#else\n\ttypedef reverse_iterator<const byte *> RevIt;\n#endif\n\tconst byte *x = find_if(RevIt(end), RevIt(begin), bind2nd(not_equal_to<byte>(), 0)).base();\n\tif (x != begin && *(x-1) == 1)\n\t{\n\t\tAttachedTransformation()->Put(begin, x-begin-1);\n\t\tm_possiblePadding = true;\n\t\tm_zeroCount = end - x;\n\t}\n\telse\n\t\tAttachedTransformation()->Put(begin, end-begin);\n\n\tif (messageEnd)\n\t{\n\t\tm_possiblePadding = false;\n\t\tOutput(0, begin, length, messageEnd, blocking);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Output",
          "args": [
            "0",
            "begin",
            "length",
            "messageEnd",
            "blocking"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "OutputFlush",
          "container": "Filter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "120-129",
          "snippet": "bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n{\n\tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n\t{\n\t\tm_continueAt = outputSite;\n\t\treturn true;\n\t}\n\tm_continueAt = 0;\n\treturn false;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilter {\n  bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n  {\n  \tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n  \t{\n  \t\tm_continueAt = outputSite;\n  \t\treturn true;\n  \t}\n  \tm_continueAt = 0;\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "begin",
            "end-begin"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "begin",
            "x-begin-1"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_if",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_if",
          "args": [
            "RevIt(end)",
            "RevIt(begin)",
            "bind2nd(not_equal_to<byte>(), 0)"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind2nd",
          "args": [
            "not_equal_to<byte>()",
            "0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "not_equal_to<byte>",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RevIt",
          "args": [
            "begin"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RevIt",
          "args": [
            "end"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "*begin++"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "1"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_if",
          "args": [
            "begin",
            "end",
            "bind2nd(not_equal_to<byte>(), 0)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind2nd",
          "args": [
            "not_equal_to<byte>()",
            "0"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "not_equal_to<byte>",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"PaddingRemover\""
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nPaddingRemover {\n  size_t PaddingRemover::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)\n  {\n  \tif (!blocking)\n  \t\tthrow BlockingInputOnly(\"PaddingRemover\");\n  \n  \tconst byte *const end = begin + length;\n  \n  \tif (m_possiblePadding)\n  \t{\n  \t\tsize_t len = find_if(begin, end, bind2nd(not_equal_to<byte>(), 0)) - begin;\n  \t\tm_zeroCount += len;\n  \t\tbegin += len;\n  \t\tif (begin == end)\n  \t\t\treturn 0;\n  \n  \t\tAttachedTransformation()->Put(1);\n  \t\twhile (m_zeroCount--)\n  \t\t\tAttachedTransformation()->Put(0);\n  \t\tAttachedTransformation()->Put(*begin++);\n  \t\tm_possiblePadding = false;\n  \t}\n  \n  #if defined(_MSC_VER) && !defined(__MWERKS__) && (_MSC_VER <= 1300)\n  \t// VC60 and VC7 workaround: built-in reverse_iterator has two template parameters, Dinkumware only has one\n  \ttypedef reverse_bidirectional_iterator<const byte *, const byte> RevIt;\n  #elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC)\n  \ttypedef reverse_iterator<const byte *, random_access_iterator_tag, const byte> RevIt;\n  #else\n  \ttypedef reverse_iterator<const byte *> RevIt;\n  #endif\n  \tconst byte *x = find_if(RevIt(end), RevIt(begin), bind2nd(not_equal_to<byte>(), 0)).base();\n  \tif (x != begin && *(x-1) == 1)\n  \t{\n  \t\tAttachedTransformation()->Put(begin, x-begin-1);\n  \t\tm_possiblePadding = true;\n  \t\tm_zeroCount = end - x;\n  \t}\n  \telse\n  \t\tAttachedTransformation()->Put(begin, end-begin);\n  \n  \tif (messageEnd)\n  \t{\n  \t\tm_possiblePadding = false;\n  \t\tOutput(0, begin, length, messageEnd, blocking);\n  \t}\n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "OutputMessageEnds",
    "container": "InformationRecovery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "361-371",
    "snippet": "void InformationRecovery::OutputMessageEnds()\n{\n\tif (m_pad)\n\t{\n\t\tPaddingRemover paddingRemover(new Redirector(*AttachedTransformation()));\n\t\tm_queue.TransferAllTo(paddingRemover);\n\t}\n\n\tif (GetAutoSignalPropagation() != 0)\n\t\tAttachedTransformation()->MessageEnd(GetAutoSignalPropagation()-1);\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "GetAutoSignalPropagation()-1"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAutoSignalPropagation",
          "args": [],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "GetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "860-860",
          "snippet": "virtual int GetAutoSignalPropagation() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual int GetAutoSignalPropagation() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_queue.TransferAllTo",
          "args": [
            "paddingRemover"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "TransferAllTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "944-945",
          "snippet": "void TransferAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n\t\t\t{TransferAllTo2(target, channel);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvoid TransferAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n\t\t\t{TransferAllTo2(target, channel);}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationRecovery {\n  void InformationRecovery::OutputMessageEnds()\n  {\n  \tif (m_pad)\n  \t{\n  \t\tPaddingRemover paddingRemover(new Redirector(*AttachedTransformation()));\n  \t\tm_queue.TransferAllTo(paddingRemover);\n  \t}\n  \n  \tif (GetAutoSignalPropagation() != 0)\n  \t\tAttachedTransformation()->MessageEnd(GetAutoSignalPropagation()-1);\n  }\n}"
  },
  {
    "function_name": "FlushOutputQueues",
    "container": "InformationRecovery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "347-359",
    "snippet": "void InformationRecovery::FlushOutputQueues()\n{\n\twhile (m_outputQueues[0].AnyRetrievable())\n\t{\n\t\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n\t\t\tm_outputQueues[i].TransferTo(m_queue, 1);\n\t}\n\n\tif (m_pad)\n\t\tm_queue.TransferTo(*AttachedTransformation(), m_queue.MaxRetrievable()-4*m_threshold);\n\telse\n\t\tm_queue.TransferTo(*AttachedTransformation());\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_queue.TransferTo",
          "args": [
            "*AttachedTransformation()"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "TransferTo",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "95-101",
          "snippet": "inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n\t{\n\t\tsize_t len = m_tail-m_head;\n\t\ttarget.ChannelPutModifiable(channel, buf+m_head, len);\n\t\tm_head = m_tail;\n\t\treturn len;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n  \t{\n  \t\tsize_t len = m_tail-m_head;\n  \t\ttarget.ChannelPutModifiable(channel, buf+m_head, len);\n  \t\tm_head = m_tail;\n  \t\treturn len;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_queue.MaxRetrievable",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputChannelIds.size",
          "args": [],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputQueues[0].AnyRetrievable",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "AnyRetrievable",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "394-403",
          "snippet": "bool BufferedTransformation::AnyRetrievable() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyRetrievable();\n\telse\n\t{\n\t\tbyte b;\n\t\treturn Peek(b) != 0;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyRetrievable() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyRetrievable();\n  \telse\n  \t{\n  \t\tbyte b;\n  \t\treturn Peek(b) != 0;\n  \t}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationRecovery {\n  void InformationRecovery::FlushOutputQueues()\n  {\n  \twhile (m_outputQueues[0].AnyRetrievable())\n  \t{\n  \t\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n  \t\t\tm_outputQueues[i].TransferTo(m_queue, 1);\n  \t}\n  \n  \tif (m_pad)\n  \t\tm_queue.TransferTo(*AttachedTransformation(), m_queue.MaxRetrievable()-4*m_threshold);\n  \telse\n  \t\tm_queue.TransferTo(*AttachedTransformation());\n  }\n}"
  },
  {
    "function_name": "IsolatedInitialize",
    "container": "InformationRecovery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "341-345",
    "snippet": "void InformationRecovery::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tm_pad = parameters.GetValueWithDefault(\"RemovePadding\", true);\n\tRawIDA::IsolatedInitialize(parameters);\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RawIDA::IsolatedInitialize",
          "args": [
            "parameters"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "21-49",
          "snippet": "void RawIDA::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tif (!parameters.GetIntValue(\"RecoveryThreshold\", m_threshold))\n\t\tthrow InvalidArgument(\"RawIDA: missing RecoveryThreshold argument\");\n\n\tif (m_threshold <= 0)\n\t\tthrow InvalidArgument(\"RawIDA: RecoveryThreshold must be greater than 0\");\n\n\tm_lastMapPosition = m_inputChannelMap.end();\n\tm_channelsReady = 0;\n\tm_channelsFinished = 0;\n\tm_w.New(m_threshold);\n\tm_y.New(m_threshold);\n\tm_inputQueues.reserve(m_threshold);\n\n\tm_outputChannelIds.clear();\n\tm_outputChannelIdStrings.clear();\n\tm_outputQueues.clear();\n\n\tword32 outputChannelID;\n\tif (parameters.GetValue(\"OutputChannelID\", outputChannelID))\n\t\tAddOutputChannel(outputChannelID);\n\telse\n\t{\n\t\tint nShares = parameters.GetIntValueWithDefault(\"NumberOfShares\", m_threshold);\n\t\tfor (int i=0; i<nShares; i++)\n\t\t\tAddOutputChannel(i);\n\t}\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tif (!parameters.GetIntValue(\"RecoveryThreshold\", m_threshold))\n  \t\tthrow InvalidArgument(\"RawIDA: missing RecoveryThreshold argument\");\n  \n  \tif (m_threshold <= 0)\n  \t\tthrow InvalidArgument(\"RawIDA: RecoveryThreshold must be greater than 0\");\n  \n  \tm_lastMapPosition = m_inputChannelMap.end();\n  \tm_channelsReady = 0;\n  \tm_channelsFinished = 0;\n  \tm_w.New(m_threshold);\n  \tm_y.New(m_threshold);\n  \tm_inputQueues.reserve(m_threshold);\n  \n  \tm_outputChannelIds.clear();\n  \tm_outputChannelIdStrings.clear();\n  \tm_outputQueues.clear();\n  \n  \tword32 outputChannelID;\n  \tif (parameters.GetValue(\"OutputChannelID\", outputChannelID))\n  \t\tAddOutputChannel(outputChannelID);\n  \telse\n  \t{\n  \t\tint nShares = parameters.GetIntValueWithDefault(\"NumberOfShares\", m_threshold);\n  \t\tfor (int i=0; i<nShares; i++)\n  \t\t\tAddOutputChannel(i);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameters.GetValueWithDefault",
          "args": [
            "\"RemovePadding\"",
            "true"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationRecovery {\n  void InformationRecovery::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tm_pad = parameters.GetValueWithDefault(\"RemovePadding\", true);\n  \tRawIDA::IsolatedInitialize(parameters);\n  }\n}"
  },
  {
    "function_name": "Put2",
    "container": "InformationDispersal",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "315-339",
    "snippet": "size_t InformationDispersal::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"InformationDispersal\");\n\t\n\twhile (length--)\n\t{\n\t\tm_ida.ChannelData(m_nextChannel, begin, 1, false);\n\t\tbegin++;\n\t\tm_nextChannel++;\n\t\tif (m_nextChannel == m_ida.GetThreshold())\n\t\t\tm_nextChannel = 0;\n\t}\n\n\tif (messageEnd)\n\t{\n\t\tm_ida.SetAutoSignalPropagation(messageEnd-1);\n\t\tif (m_pad)\n\t\t\tInformationDispersal::Put(1);\n\t\tfor (word32 i=0; i<m_ida.GetThreshold(); i++)\n\t\t\tm_ida.ChannelData(i, NULL, 0, true);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ida.ChannelData",
          "args": [
            "i",
            "NULL",
            "0",
            "true"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ChannelData",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "88-118",
          "snippet": "void RawIDA::ChannelData(word32 channelId, const byte *inString, size_t length, bool messageEnd)\n{\n\tint i = InsertInputChannel(channelId);\n\tif (i < m_threshold)\n\t{\n\t\tlword size = m_inputQueues[i].MaxRetrievable();\n\t\tm_inputQueues[i].Put(inString, length);\n\t\tif (size < 4 && size + length >= 4)\n\t\t{\n\t\t\tm_channelsReady++;\n\t\t\tif (m_channelsReady == static_cast<unsigned int>(m_threshold))\n\t\t\t\tProcessInputQueues();\n\t\t}\n\n\t\tif (messageEnd)\n\t\t{\n\t\t\tm_inputQueues[i].MessageEnd();\n\t\t\tif (m_inputQueues[i].NumberOfMessages() == 1)\n\t\t\t{\n\t\t\t\tm_channelsFinished++;\n\t\t\t\tif (m_channelsFinished == static_cast<unsigned int>(m_threshold))\n\t\t\t\t{\n\t\t\t\t\tm_channelsReady = 0;\n\t\t\t\t\tfor (i=0; i<m_threshold; i++)\n\t\t\t\t\t\tm_channelsReady += m_inputQueues[i].AnyRetrievable();\n\t\t\t\t\tProcessInputQueues();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::ChannelData(word32 channelId, const byte *inString, size_t length, bool messageEnd)\n  {\n  \tint i = InsertInputChannel(channelId);\n  \tif (i < m_threshold)\n  \t{\n  \t\tlword size = m_inputQueues[i].MaxRetrievable();\n  \t\tm_inputQueues[i].Put(inString, length);\n  \t\tif (size < 4 && size + length >= 4)\n  \t\t{\n  \t\t\tm_channelsReady++;\n  \t\t\tif (m_channelsReady == static_cast<unsigned int>(m_threshold))\n  \t\t\t\tProcessInputQueues();\n  \t\t}\n  \n  \t\tif (messageEnd)\n  \t\t{\n  \t\t\tm_inputQueues[i].MessageEnd();\n  \t\t\tif (m_inputQueues[i].NumberOfMessages() == 1)\n  \t\t\t{\n  \t\t\t\tm_channelsFinished++;\n  \t\t\t\tif (m_channelsFinished == static_cast<unsigned int>(m_threshold))\n  \t\t\t\t{\n  \t\t\t\t\tm_channelsReady = 0;\n  \t\t\t\t\tfor (i=0; i<m_threshold; i++)\n  \t\t\t\t\t\tm_channelsReady += m_inputQueues[i].AnyRetrievable();\n  \t\t\t\t\tProcessInputQueues();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_ida.GetThreshold",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "GetThreshold",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.h",
          "lines": "19-19",
          "snippet": "unsigned int GetThreshold() const {return m_threshold;}",
          "includes": [
            "#include <vector>",
            "#include <map>",
            "#include \"channels.h\"",
            "#include \"filters.h\"",
            "#include \"mqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <map>\n#include \"channels.h\"\n#include \"filters.h\"\n#include \"mqueue.h\"\n\nRawIDA {\n  unsigned int GetThreshold() const {return m_threshold;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InformationDispersal::Put",
          "args": [
            "1"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "m_ida.SetAutoSignalPropagation",
          "args": [
            "messageEnd-1"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "SetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "857-857",
          "snippet": "virtual void SetAutoSignalPropagation(int propagation) {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual void SetAutoSignalPropagation(int propagation) {}"
        }
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"InformationDispersal\""
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationDispersal {\n  size_t InformationDispersal::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)\n  {\n  \tif (!blocking)\n  \t\tthrow BlockingInputOnly(\"InformationDispersal\");\n  \t\n  \twhile (length--)\n  \t{\n  \t\tm_ida.ChannelData(m_nextChannel, begin, 1, false);\n  \t\tbegin++;\n  \t\tm_nextChannel++;\n  \t\tif (m_nextChannel == m_ida.GetThreshold())\n  \t\t\tm_nextChannel = 0;\n  \t}\n  \n  \tif (messageEnd)\n  \t{\n  \t\tm_ida.SetAutoSignalPropagation(messageEnd-1);\n  \t\tif (m_pad)\n  \t\t\tInformationDispersal::Put(1);\n  \t\tfor (word32 i=0; i<m_ida.GetThreshold(); i++)\n  \t\t\tm_ida.ChannelData(i, NULL, 0, true);\n  \t}\n  \n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "IsolatedInitialize",
    "container": "InformationDispersal",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "308-313",
    "snippet": "void InformationDispersal::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tm_nextChannel = 0;\n\tm_pad = parameters.GetValueWithDefault(\"AddPadding\", true);\n\tm_ida.IsolatedInitialize(parameters);\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ida.IsolatedInitialize",
          "args": [
            "parameters"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "InformationRecovery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "341-345",
          "snippet": "void InformationRecovery::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tm_pad = parameters.GetValueWithDefault(\"RemovePadding\", true);\n\tRawIDA::IsolatedInitialize(parameters);\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationRecovery {\n  void InformationRecovery::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tm_pad = parameters.GetValueWithDefault(\"RemovePadding\", true);\n  \tRawIDA::IsolatedInitialize(parameters);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameters.GetValueWithDefault",
          "args": [
            "\"AddPadding\"",
            "true"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationDispersal {\n  void InformationDispersal::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tm_nextChannel = 0;\n  \tm_pad = parameters.GetValueWithDefault(\"AddPadding\", true);\n  \tm_ida.IsolatedInitialize(parameters);\n  }\n}"
  },
  {
    "function_name": "OutputMessageEnds",
    "container": "SecretRecovery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "294-304",
    "snippet": "void SecretRecovery::OutputMessageEnds()\n{\n\tif (m_pad)\n\t{\n\t\tPaddingRemover paddingRemover(new Redirector(*AttachedTransformation()));\n\t\tm_outputQueues[0].TransferAllTo(paddingRemover);\n\t}\n\n\tif (GetAutoSignalPropagation() != 0)\n\t\tAttachedTransformation()->MessageEnd(GetAutoSignalPropagation()-1);\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "GetAutoSignalPropagation()-1"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAutoSignalPropagation",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "GetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "860-860",
          "snippet": "virtual int GetAutoSignalPropagation() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual int GetAutoSignalPropagation() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputQueues[0].TransferAllTo",
          "args": [
            "paddingRemover"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "TransferAllTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "944-945",
          "snippet": "void TransferAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n\t\t\t{TransferAllTo2(target, channel);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvoid TransferAllTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n\t\t\t{TransferAllTo2(target, channel);}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nSecretRecovery {\n  void SecretRecovery::OutputMessageEnds()\n  {\n  \tif (m_pad)\n  \t{\n  \t\tPaddingRemover paddingRemover(new Redirector(*AttachedTransformation()));\n  \t\tm_outputQueues[0].TransferAllTo(paddingRemover);\n  \t}\n  \n  \tif (GetAutoSignalPropagation() != 0)\n  \t\tAttachedTransformation()->MessageEnd(GetAutoSignalPropagation()-1);\n  }\n}"
  },
  {
    "function_name": "FlushOutputQueues",
    "container": "SecretRecovery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "286-292",
    "snippet": "void SecretRecovery::FlushOutputQueues()\n{\n\tif (m_pad)\n\t\tm_outputQueues[0].TransferTo(*AttachedTransformation(), m_outputQueues[0].MaxRetrievable()-4);\n\telse\n\t\tm_outputQueues[0].TransferTo(*AttachedTransformation());\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_outputQueues[0].TransferTo",
          "args": [
            "*AttachedTransformation()"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "TransferTo",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "95-101",
          "snippet": "inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n\t{\n\t\tsize_t len = m_tail-m_head;\n\t\ttarget.ChannelPutModifiable(channel, buf+m_head, len);\n\t\tm_head = m_tail;\n\t\treturn len;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n  \t{\n  \t\tsize_t len = m_tail-m_head;\n  \t\ttarget.ChannelPutModifiable(channel, buf+m_head, len);\n  \t\tm_head = m_tail;\n  \t\treturn len;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputQueues[0].MaxRetrievable",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nSecretRecovery {\n  void SecretRecovery::FlushOutputQueues()\n  {\n  \tif (m_pad)\n  \t\tm_outputQueues[0].TransferTo(*AttachedTransformation(), m_outputQueues[0].MaxRetrievable()-4);\n  \telse\n  \t\tm_outputQueues[0].TransferTo(*AttachedTransformation());\n  }\n}"
  },
  {
    "function_name": "IsolatedInitialize",
    "container": "SecretRecovery",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "280-284",
    "snippet": "void SecretRecovery::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tm_pad = parameters.GetValueWithDefault(\"RemovePadding\", true);\n\tRawIDA::IsolatedInitialize(CombinedNameValuePairs(parameters, MakeParameters(\"OutputChannelID\", (word32)0xffffffff)));\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RawIDA::IsolatedInitialize",
          "args": [
            "CombinedNameValuePairs(parameters, MakeParameters(\"OutputChannelID\", (word32)0xffffffff))"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "21-49",
          "snippet": "void RawIDA::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tif (!parameters.GetIntValue(\"RecoveryThreshold\", m_threshold))\n\t\tthrow InvalidArgument(\"RawIDA: missing RecoveryThreshold argument\");\n\n\tif (m_threshold <= 0)\n\t\tthrow InvalidArgument(\"RawIDA: RecoveryThreshold must be greater than 0\");\n\n\tm_lastMapPosition = m_inputChannelMap.end();\n\tm_channelsReady = 0;\n\tm_channelsFinished = 0;\n\tm_w.New(m_threshold);\n\tm_y.New(m_threshold);\n\tm_inputQueues.reserve(m_threshold);\n\n\tm_outputChannelIds.clear();\n\tm_outputChannelIdStrings.clear();\n\tm_outputQueues.clear();\n\n\tword32 outputChannelID;\n\tif (parameters.GetValue(\"OutputChannelID\", outputChannelID))\n\t\tAddOutputChannel(outputChannelID);\n\telse\n\t{\n\t\tint nShares = parameters.GetIntValueWithDefault(\"NumberOfShares\", m_threshold);\n\t\tfor (int i=0; i<nShares; i++)\n\t\t\tAddOutputChannel(i);\n\t}\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tif (!parameters.GetIntValue(\"RecoveryThreshold\", m_threshold))\n  \t\tthrow InvalidArgument(\"RawIDA: missing RecoveryThreshold argument\");\n  \n  \tif (m_threshold <= 0)\n  \t\tthrow InvalidArgument(\"RawIDA: RecoveryThreshold must be greater than 0\");\n  \n  \tm_lastMapPosition = m_inputChannelMap.end();\n  \tm_channelsReady = 0;\n  \tm_channelsFinished = 0;\n  \tm_w.New(m_threshold);\n  \tm_y.New(m_threshold);\n  \tm_inputQueues.reserve(m_threshold);\n  \n  \tm_outputChannelIds.clear();\n  \tm_outputChannelIdStrings.clear();\n  \tm_outputQueues.clear();\n  \n  \tword32 outputChannelID;\n  \tif (parameters.GetValue(\"OutputChannelID\", outputChannelID))\n  \t\tAddOutputChannel(outputChannelID);\n  \telse\n  \t{\n  \t\tint nShares = parameters.GetIntValueWithDefault(\"NumberOfShares\", m_threshold);\n  \t\tfor (int i=0; i<nShares; i++)\n  \t\t\tAddOutputChannel(i);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CombinedNameValuePairs",
          "args": [
            "parameters",
            "MakeParameters(\"OutputChannelID\", (word32)0xffffffff)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"OutputChannelID\"",
            "(word32)0xffffffff"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameters.GetValueWithDefault",
          "args": [
            "\"RemovePadding\"",
            "true"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nSecretRecovery {\n  void SecretRecovery::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tm_pad = parameters.GetValueWithDefault(\"RemovePadding\", true);\n  \tRawIDA::IsolatedInitialize(CombinedNameValuePairs(parameters, MakeParameters(\"OutputChannelID\", (word32)0xffffffff)));\n  }\n}"
  },
  {
    "function_name": "Put2",
    "container": "SecretSharing",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "243-278",
    "snippet": "size_t SecretSharing::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"SecretSharing\");\n\n\tSecByteBlock buf(UnsignedMin(256, length));\n\tunsigned int threshold = m_ida.GetThreshold();\n\twhile (length > 0)\n\t{\n\t\tsize_t len = STDMIN(length, buf.size());\n\t\tm_ida.ChannelData(0xffffffff, begin, len, false);\n\t\tfor (unsigned int i=0; i<threshold-1; i++)\n\t\t{\n\t\t\tm_rng.GenerateBlock(buf, len);\n\t\t\tm_ida.ChannelData(i, buf, len, false);\n\t\t}\n\t\tlength -= len;\n\t\tbegin += len;\n\t}\n\n\tif (messageEnd)\n\t{\n\t\tm_ida.SetAutoSignalPropagation(messageEnd-1);\n\t\tif (m_pad)\n\t\t{\n\t\t\tSecretSharing::Put(1);\n\t\t\twhile (m_ida.InputBuffered(0xffffffff) > 0)\n\t\t\t\tSecretSharing::Put(0);\n\t\t}\n\t\tm_ida.ChannelData(0xffffffff, NULL, 0, true);\n\t\tfor (unsigned int i=0; i<m_ida.GetThreshold()-1; i++)\n\t\t\tm_ida.ChannelData(i, NULL, 0, true);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ida.ChannelData",
          "args": [
            "i",
            "NULL",
            "0",
            "true"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ChannelData",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "88-118",
          "snippet": "void RawIDA::ChannelData(word32 channelId, const byte *inString, size_t length, bool messageEnd)\n{\n\tint i = InsertInputChannel(channelId);\n\tif (i < m_threshold)\n\t{\n\t\tlword size = m_inputQueues[i].MaxRetrievable();\n\t\tm_inputQueues[i].Put(inString, length);\n\t\tif (size < 4 && size + length >= 4)\n\t\t{\n\t\t\tm_channelsReady++;\n\t\t\tif (m_channelsReady == static_cast<unsigned int>(m_threshold))\n\t\t\t\tProcessInputQueues();\n\t\t}\n\n\t\tif (messageEnd)\n\t\t{\n\t\t\tm_inputQueues[i].MessageEnd();\n\t\t\tif (m_inputQueues[i].NumberOfMessages() == 1)\n\t\t\t{\n\t\t\t\tm_channelsFinished++;\n\t\t\t\tif (m_channelsFinished == static_cast<unsigned int>(m_threshold))\n\t\t\t\t{\n\t\t\t\t\tm_channelsReady = 0;\n\t\t\t\t\tfor (i=0; i<m_threshold; i++)\n\t\t\t\t\t\tm_channelsReady += m_inputQueues[i].AnyRetrievable();\n\t\t\t\t\tProcessInputQueues();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::ChannelData(word32 channelId, const byte *inString, size_t length, bool messageEnd)\n  {\n  \tint i = InsertInputChannel(channelId);\n  \tif (i < m_threshold)\n  \t{\n  \t\tlword size = m_inputQueues[i].MaxRetrievable();\n  \t\tm_inputQueues[i].Put(inString, length);\n  \t\tif (size < 4 && size + length >= 4)\n  \t\t{\n  \t\t\tm_channelsReady++;\n  \t\t\tif (m_channelsReady == static_cast<unsigned int>(m_threshold))\n  \t\t\t\tProcessInputQueues();\n  \t\t}\n  \n  \t\tif (messageEnd)\n  \t\t{\n  \t\t\tm_inputQueues[i].MessageEnd();\n  \t\t\tif (m_inputQueues[i].NumberOfMessages() == 1)\n  \t\t\t{\n  \t\t\t\tm_channelsFinished++;\n  \t\t\t\tif (m_channelsFinished == static_cast<unsigned int>(m_threshold))\n  \t\t\t\t{\n  \t\t\t\t\tm_channelsReady = 0;\n  \t\t\t\t\tfor (i=0; i<m_threshold; i++)\n  \t\t\t\t\t\tm_channelsReady += m_inputQueues[i].AnyRetrievable();\n  \t\t\t\t\tProcessInputQueues();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_ida.GetThreshold",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "GetThreshold",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.h",
          "lines": "19-19",
          "snippet": "unsigned int GetThreshold() const {return m_threshold;}",
          "includes": [
            "#include <vector>",
            "#include <map>",
            "#include \"channels.h\"",
            "#include \"filters.h\"",
            "#include \"mqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <map>\n#include \"channels.h\"\n#include \"filters.h\"\n#include \"mqueue.h\"\n\nRawIDA {\n  unsigned int GetThreshold() const {return m_threshold;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SecretSharing::Put",
          "args": [
            "0"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "m_ida.InputBuffered",
          "args": [
            "0xffffffff"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "InputBuffered",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "120-124",
          "snippet": "lword RawIDA::InputBuffered(word32 channelId) const\n{\n\tint i = LookupInputChannel(channelId);\n\treturn i < m_threshold ? m_inputQueues[i].MaxRetrievable() : 0;\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  lword RawIDA::InputBuffered(word32 channelId) const\n  {\n  \tint i = LookupInputChannel(channelId);\n  \treturn i < m_threshold ? m_inputQueues[i].MaxRetrievable() : 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_ida.SetAutoSignalPropagation",
          "args": [
            "messageEnd-1"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "SetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "857-857",
          "snippet": "virtual void SetAutoSignalPropagation(int propagation) {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual void SetAutoSignalPropagation(int propagation) {}"
        }
      },
      {
        "call_info": {
          "callee": "m_rng.GenerateBlock",
          "args": [
            "buf",
            "len"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateBlock",
          "container": "KDF2_RNG",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3241-3246",
          "snippet": "void GenerateBlock(byte *output, size_t size)\n\t{\n\t\tPutWord(false, BIG_ENDIAN_ORDER, m_counterAndSeed, m_counter);\n\t\t++m_counter;\n\t\tP1363_KDF2<SHA1>::DeriveKey(output, size, m_counterAndSeed, m_counterAndSeed.size(), NULL, 0);\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nKDF2_RNG {\n  void GenerateBlock(byte *output, size_t size)\n  \t{\n  \t\tPutWord(false, BIG_ENDIAN_ORDER, m_counterAndSeed, m_counter);\n  \t\t++m_counter;\n  \t\tP1363_KDF2<SHA1>::DeriveKey(output, size, m_counterAndSeed, m_counterAndSeed.size(), NULL, 0);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "length",
            "buf.size()"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf.size",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "256",
            "length"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"SecretSharing\""
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nSecretSharing {\n  size_t SecretSharing::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)\n  {\n  \tif (!blocking)\n  \t\tthrow BlockingInputOnly(\"SecretSharing\");\n  \n  \tSecByteBlock buf(UnsignedMin(256, length));\n  \tunsigned int threshold = m_ida.GetThreshold();\n  \twhile (length > 0)\n  \t{\n  \t\tsize_t len = STDMIN(length, buf.size());\n  \t\tm_ida.ChannelData(0xffffffff, begin, len, false);\n  \t\tfor (unsigned int i=0; i<threshold-1; i++)\n  \t\t{\n  \t\t\tm_rng.GenerateBlock(buf, len);\n  \t\t\tm_ida.ChannelData(i, buf, len, false);\n  \t\t}\n  \t\tlength -= len;\n  \t\tbegin += len;\n  \t}\n  \n  \tif (messageEnd)\n  \t{\n  \t\tm_ida.SetAutoSignalPropagation(messageEnd-1);\n  \t\tif (m_pad)\n  \t\t{\n  \t\t\tSecretSharing::Put(1);\n  \t\t\twhile (m_ida.InputBuffered(0xffffffff) > 0)\n  \t\t\t\tSecretSharing::Put(0);\n  \t\t}\n  \t\tm_ida.ChannelData(0xffffffff, NULL, 0, true);\n  \t\tfor (unsigned int i=0; i<m_ida.GetThreshold()-1; i++)\n  \t\t\tm_ida.ChannelData(i, NULL, 0, true);\n  \t}\n  \n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "IsolatedInitialize",
    "container": "SecretSharing",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "237-241",
    "snippet": "void SecretSharing::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tm_pad = parameters.GetValueWithDefault(\"AddPadding\", true);\n\tm_ida.IsolatedInitialize(parameters);\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_ida.IsolatedInitialize",
          "args": [
            "parameters"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "InformationRecovery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "341-345",
          "snippet": "void InformationRecovery::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tm_pad = parameters.GetValueWithDefault(\"RemovePadding\", true);\n\tRawIDA::IsolatedInitialize(parameters);\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationRecovery {\n  void InformationRecovery::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tm_pad = parameters.GetValueWithDefault(\"RemovePadding\", true);\n  \tRawIDA::IsolatedInitialize(parameters);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameters.GetValueWithDefault",
          "args": [
            "\"AddPadding\"",
            "true"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nSecretSharing {\n  void SecretSharing::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tm_pad = parameters.GetValueWithDefault(\"AddPadding\", true);\n  \tm_ida.IsolatedInitialize(parameters);\n  }\n}"
  },
  {
    "function_name": "OutputMessageEnds",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "226-233",
    "snippet": "void RawIDA::OutputMessageEnds()\n{\n\tif (GetAutoSignalPropagation() != 0)\n\t{\n\t\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n\t\t\tAttachedTransformation()->ChannelMessageEnd(m_outputChannelIdStrings[i], GetAutoSignalPropagation()-1);\n\t}\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "m_outputChannelIdStrings[i]",
            "GetAutoSignalPropagation()-1"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAutoSignalPropagation",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "GetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "860-860",
          "snippet": "virtual int GetAutoSignalPropagation() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual int GetAutoSignalPropagation() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputChannelIds.size",
          "args": [],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::OutputMessageEnds()\n  {\n  \tif (GetAutoSignalPropagation() != 0)\n  \t{\n  \t\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n  \t\t\tAttachedTransformation()->ChannelMessageEnd(m_outputChannelIdStrings[i], GetAutoSignalPropagation()-1);\n  \t}\n  }\n}"
  },
  {
    "function_name": "FlushOutputQueues",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "220-224",
    "snippet": "void RawIDA::FlushOutputQueues()\n{\n\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n\t\tm_outputQueues[i].TransferAllTo(*AttachedTransformation(), m_outputChannelIdStrings[i]);\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_outputQueues[i].TransferAllTo",
          "args": [
            "*AttachedTransformation()",
            "m_outputChannelIdStrings[i]"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputChannelIds.size",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::FlushOutputQueues()\n  {\n  \tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n  \t\tm_outputQueues[i].TransferAllTo(*AttachedTransformation(), m_outputChannelIdStrings[i]);\n  }\n}"
  },
  {
    "function_name": "ProcessInputQueues",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "159-218",
    "snippet": "void RawIDA::ProcessInputQueues()\n{\n\tbool finished = (m_channelsFinished == static_cast<unsigned int>(m_threshold));\n\tint i;\n\n\twhile (finished ? m_channelsReady > 0 : m_channelsReady == static_cast<size_t>(m_threshold))\n\t{\n\t\tm_channelsReady = 0;\n\t\tfor (i=0; i<m_threshold; i++)\n\t\t{\n\t\t\tMessageQueue &queue = m_inputQueues[i];\n\t\t\tqueue.GetWord32(m_y[i]);\n\n\t\t\tif (finished)\n\t\t\t\tm_channelsReady += queue.AnyRetrievable();\n\t\t\telse\n\t\t\t\tm_channelsReady += queue.NumberOfMessages() > 0 || queue.MaxRetrievable() >= 4;\n\t\t}\n\n\t\tfor (i=0; (unsigned int)i<m_outputChannelIds.size(); i++)\n\t\t{\n\t\t\tif (m_outputToInput[i] != static_cast<unsigned int>(m_threshold))\n\t\t\t\tm_outputQueues[i].PutWord32(m_y[m_outputToInput[i]]);\n\t\t\telse if (m_v[i].size() == static_cast<size_t>(m_threshold))\n\t\t\t\tm_outputQueues[i].PutWord32(BulkPolynomialInterpolateAt(field, m_y.begin(), m_v[i].begin(), m_threshold));\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_u.resize(m_threshold);\n\t\t\t\tPrepareBulkPolynomialInterpolationAt(field, m_u.begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n\t\t\t\tm_outputQueues[i].PutWord32(BulkPolynomialInterpolateAt(field, m_y.begin(), m_u.begin(), m_threshold));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m_outputChannelIds.size() > 0 && m_outputQueues[0].AnyRetrievable())\n\t\tFlushOutputQueues();\n\n\tif (finished)\n\t{\n\t\tOutputMessageEnds();\n\n\t\tm_channelsReady = 0;\n\t\tm_channelsFinished = 0;\n\t\tm_v.clear();\n\n\t\tvector<MessageQueue> inputQueues;\n\t\tvector<word32> inputChannelIds;\n\n\t\tinputQueues.swap(m_inputQueues);\n\t\tinputChannelIds.swap(m_inputChannelIds);\n\t\tm_inputChannelMap.clear();\n\t\tm_lastMapPosition = m_inputChannelMap.end();\n\n\t\tfor (i=0; i<m_threshold; i++)\n\t\t{\n\t\t\tinputQueues[i].GetNextMessage();\n\t\t\tinputQueues[i].TransferAllTo(*AttachedTransformation(), WordToString(inputChannelIds[i]));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inputQueues[i].TransferAllTo",
          "args": [
            "*AttachedTransformation()",
            "WordToString(inputChannelIds[i])"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WordToString",
          "args": [
            "inputChannelIds[i]"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "WordToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1206-1212",
          "snippet": "std::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tvalue = ByteReverse(value);\n\n\treturn std::string((char *)&value, sizeof(value));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tvalue = ByteReverse(value);\n\n\treturn std::string((char *)&value, sizeof(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inputQueues[i].GetNextMessage",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "GetNextMessage",
          "container": "Store",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "1022-1031",
          "snippet": "bool Store::GetNextMessage()\n{\n\tif (!m_messageEnd && !AnyRetrievable())\n\t{\n\t\tm_messageEnd=true;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nStore {\n  bool Store::GetNextMessage()\n  {\n  \tif (!m_messageEnd && !AnyRetrievable())\n  \t{\n  \t\tm_messageEnd=true;\n  \t\treturn true;\n  \t}\n  \telse\n  \t\treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputChannelMap.end",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputChannelMap.clear",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inputChannelIds.swap",
          "args": [
            "m_inputChannelIds"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2954-2958",
          "snippet": "void Integer::swap(Integer &a)\n{\n\treg.swap(a.reg);\n\tstd::swap(sign, a.sign);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::swap(Integer &a)\n  {\n  \treg.swap(a.reg);\n  \tstd::swap(sign, a.sign);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_v.clear",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputMessageEnds",
          "args": [],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "OutputMessageEnds",
          "container": "InformationRecovery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "361-371",
          "snippet": "void InformationRecovery::OutputMessageEnds()\n{\n\tif (m_pad)\n\t{\n\t\tPaddingRemover paddingRemover(new Redirector(*AttachedTransformation()));\n\t\tm_queue.TransferAllTo(paddingRemover);\n\t}\n\n\tif (GetAutoSignalPropagation() != 0)\n\t\tAttachedTransformation()->MessageEnd(GetAutoSignalPropagation()-1);\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationRecovery {\n  void InformationRecovery::OutputMessageEnds()\n  {\n  \tif (m_pad)\n  \t{\n  \t\tPaddingRemover paddingRemover(new Redirector(*AttachedTransformation()));\n  \t\tm_queue.TransferAllTo(paddingRemover);\n  \t}\n  \n  \tif (GetAutoSignalPropagation() != 0)\n  \t\tAttachedTransformation()->MessageEnd(GetAutoSignalPropagation()-1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FlushOutputQueues",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "FlushOutputQueues",
          "container": "InformationRecovery",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "347-359",
          "snippet": "void InformationRecovery::FlushOutputQueues()\n{\n\twhile (m_outputQueues[0].AnyRetrievable())\n\t{\n\t\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n\t\t\tm_outputQueues[i].TransferTo(m_queue, 1);\n\t}\n\n\tif (m_pad)\n\t\tm_queue.TransferTo(*AttachedTransformation(), m_queue.MaxRetrievable()-4*m_threshold);\n\telse\n\t\tm_queue.TransferTo(*AttachedTransformation());\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nInformationRecovery {\n  void InformationRecovery::FlushOutputQueues()\n  {\n  \twhile (m_outputQueues[0].AnyRetrievable())\n  \t{\n  \t\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n  \t\t\tm_outputQueues[i].TransferTo(m_queue, 1);\n  \t}\n  \n  \tif (m_pad)\n  \t\tm_queue.TransferTo(*AttachedTransformation(), m_queue.MaxRetrievable()-4*m_threshold);\n  \telse\n  \t\tm_queue.TransferTo(*AttachedTransformation());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputQueues[0].AnyRetrievable",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "AnyRetrievable",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "394-403",
          "snippet": "bool BufferedTransformation::AnyRetrievable() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyRetrievable();\n\telse\n\t{\n\t\tbyte b;\n\t\treturn Peek(b) != 0;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyRetrievable() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyRetrievable();\n  \telse\n  \t{\n  \t\tbyte b;\n  \t\treturn Peek(b) != 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputChannelIds.size",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputQueues[i].PutWord32",
          "args": [
            "BulkPolynomialInterpolateAt(field, m_y.begin(), m_u.begin(), m_threshold)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BulkPolynomialInterpolateAt",
          "args": [
            "field",
            "m_y.begin()",
            "m_u.begin()",
            "m_threshold"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "BulkPolynomialInterpolateAt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.cpp",
          "lines": "555-561",
          "snippet": "Element BulkPolynomialInterpolateAt(const Ring &ring, const Element y[], const Element v[], unsigned int n)\n{\n\tElement result = ring.Identity();\n\tfor (unsigned int i=0; i<n; i++)\n\t\tring.Accumulate(result, ring.Multiply(y[i], v[i]));\n\treturn result;\n}",
          "includes": [
            "#include <iostream>",
            "#include <sstream>",
            "#include \"secblock.h\"",
            "#include \"polynomi.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <sstream>\n#include \"secblock.h\"\n#include \"polynomi.h\"\n#include \"pch.h\"\n\nElement BulkPolynomialInterpolateAt(const Ring &ring, const Element y[], const Element v[], unsigned int n)\n{\n\tElement result = ring.Identity();\n\tfor (unsigned int i=0; i<n; i++)\n\t\tring.Accumulate(result, ring.Multiply(y[i], v[i]));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.begin",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrepareBulkPolynomialInterpolationAt",
          "args": [
            "field",
            "m_u.begin()",
            "m_outputChannelIds[i]",
            "&(m_inputChannelIds[0])",
            "m_w.begin()",
            "m_threshold"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareBulkPolynomialInterpolationAt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.cpp",
          "lines": "528-552",
          "snippet": "void PrepareBulkPolynomialInterpolationAt(const Ring &ring, Element *v, const Element &position, const Element x[], const Element w[], unsigned int n)\n{\n\tassert(n > 0);\n\n\tstd::vector<Element> a(2*n-1);\n\tunsigned int i;\n\n\tfor (i=0; i<n; i++)\n\t\ta[n-1+i] = ring.Subtract(position, x[i]);\n\n\tfor (i=n-1; i>1; i--)\n\t\ta[i-1] = ring.Multiply(a[2*i], a[2*i-1]);\n\n\ta[0] = ring.MultiplicativeIdentity();\n\n\tfor (i=0; i<n-1; i++)\n\t{\n\t\tstd::swap(a[2*i+1], a[2*i+2]);\n\t\ta[2*i+1] = ring.Multiply(a[i], a[2*i+1]);\n\t\ta[2*i+2] = ring.Multiply(a[i], a[2*i+2]);\n\t}\n\n\tfor (i=0; i<n; i++)\n\t\tv[i] = ring.Multiply(a[n-1+i], w[i]);\n}",
          "includes": [
            "#include <iostream>",
            "#include <sstream>",
            "#include \"secblock.h\"",
            "#include \"polynomi.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <sstream>\n#include \"secblock.h\"\n#include \"polynomi.h\"\n#include \"pch.h\"\n\nvoid PrepareBulkPolynomialInterpolationAt(const Ring &ring, Element *v, const Element &position, const Element x[], const Element w[], unsigned int n)\n{\n\tassert(n > 0);\n\n\tstd::vector<Element> a(2*n-1);\n\tunsigned int i;\n\n\tfor (i=0; i<n; i++)\n\t\ta[n-1+i] = ring.Subtract(position, x[i]);\n\n\tfor (i=n-1; i>1; i--)\n\t\ta[i-1] = ring.Multiply(a[2*i], a[2*i-1]);\n\n\ta[0] = ring.MultiplicativeIdentity();\n\n\tfor (i=0; i<n-1; i++)\n\t{\n\t\tstd::swap(a[2*i+1], a[2*i+2]);\n\t\ta[2*i+1] = ring.Multiply(a[i], a[2*i+1]);\n\t\ta[2*i+2] = ring.Multiply(a[i], a[2*i+2]);\n\t}\n\n\tfor (i=0; i<n; i++)\n\t\tv[i] = ring.Multiply(a[n-1+i], w[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.resize",
          "args": [
            "m_threshold"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputQueues[i].PutWord32",
          "args": [
            "BulkPolynomialInterpolateAt(field, m_y.begin(), m_v[i].begin(), m_threshold)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<size_t>",
          "args": [
            "m_threshold"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputQueues[i].PutWord32",
          "args": [
            "m_y[m_outputToInput[i]]"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned int>",
          "args": [
            "m_threshold"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue.MaxRetrievable",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue.NumberOfMessages",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "NumberOfMessages",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "459-465",
          "snippet": "unsigned int BufferedTransformation::NumberOfMessages() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->NumberOfMessages();\n\telse\n\t\treturn CopyMessagesTo(TheBitBucket());\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  unsigned int BufferedTransformation::NumberOfMessages() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->NumberOfMessages();\n  \telse\n  \t\treturn CopyMessagesTo(TheBitBucket());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue.GetWord32",
          "args": [
            "m_y[i]"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<size_t>",
          "args": [
            "m_threshold"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned int>",
          "args": [
            "m_threshold"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;\n\nRawIDA {\n  void RawIDA::ProcessInputQueues()\n  {\n  \tbool finished = (m_channelsFinished == static_cast<unsigned int>(m_threshold));\n  \tint i;\n  \n  \twhile (finished ? m_channelsReady > 0 : m_channelsReady == static_cast<size_t>(m_threshold))\n  \t{\n  \t\tm_channelsReady = 0;\n  \t\tfor (i=0; i<m_threshold; i++)\n  \t\t{\n  \t\t\tMessageQueue &queue = m_inputQueues[i];\n  \t\t\tqueue.GetWord32(m_y[i]);\n  \n  \t\t\tif (finished)\n  \t\t\t\tm_channelsReady += queue.AnyRetrievable();\n  \t\t\telse\n  \t\t\t\tm_channelsReady += queue.NumberOfMessages() > 0 || queue.MaxRetrievable() >= 4;\n  \t\t}\n  \n  \t\tfor (i=0; (unsigned int)i<m_outputChannelIds.size(); i++)\n  \t\t{\n  \t\t\tif (m_outputToInput[i] != static_cast<unsigned int>(m_threshold))\n  \t\t\t\tm_outputQueues[i].PutWord32(m_y[m_outputToInput[i]]);\n  \t\t\telse if (m_v[i].size() == static_cast<size_t>(m_threshold))\n  \t\t\t\tm_outputQueues[i].PutWord32(BulkPolynomialInterpolateAt(field, m_y.begin(), m_v[i].begin(), m_threshold));\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tm_u.resize(m_threshold);\n  \t\t\t\tPrepareBulkPolynomialInterpolationAt(field, m_u.begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n  \t\t\t\tm_outputQueues[i].PutWord32(BulkPolynomialInterpolateAt(field, m_y.begin(), m_u.begin(), m_threshold));\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  \tif (m_outputChannelIds.size() > 0 && m_outputQueues[0].AnyRetrievable())\n  \t\tFlushOutputQueues();\n  \n  \tif (finished)\n  \t{\n  \t\tOutputMessageEnds();\n  \n  \t\tm_channelsReady = 0;\n  \t\tm_channelsFinished = 0;\n  \t\tm_v.clear();\n  \n  \t\tvector<MessageQueue> inputQueues;\n  \t\tvector<word32> inputChannelIds;\n  \n  \t\tinputQueues.swap(m_inputQueues);\n  \t\tinputChannelIds.swap(m_inputChannelIds);\n  \t\tm_inputChannelMap.clear();\n  \t\tm_lastMapPosition = m_inputChannelMap.end();\n  \n  \t\tfor (i=0; i<m_threshold; i++)\n  \t\t{\n  \t\t\tinputQueues[i].GetNextMessage();\n  \t\t\tinputQueues[i].TransferAllTo(*AttachedTransformation(), WordToString(inputChannelIds[i]));\n  \t\t}\n  \t}\n  }\n}"
  },
  {
    "function_name": "PrepareInterpolation",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "151-157",
    "snippet": "void RawIDA::PrepareInterpolation()\n{\n\tassert(m_inputChannelIds.size() == m_threshold);\n\tPrepareBulkPolynomialInterpolation(field, m_w.begin(), &(m_inputChannelIds[0]), m_threshold);\n\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n\t\tComputeV(i);\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ComputeV",
          "args": [
            "i"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeV",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "126-140",
          "snippet": "void RawIDA::ComputeV(unsigned int i)\n{\n\tif (i >= m_v.size())\n\t{\n\t\tm_v.resize(i+1);\n\t\tm_outputToInput.resize(i+1);\n\t}\n\n\tm_outputToInput[i] = LookupInputChannel(m_outputChannelIds[i]);\n\tif (m_outputToInput[i] == static_cast<unsigned int>(m_threshold) && i * m_threshold <= 1000*1000)\n\t{\n\t\tm_v[i].resize(m_threshold);\n\t\tPrepareBulkPolynomialInterpolationAt(field, m_v[i].begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n\t}\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;\n\nRawIDA {\n  void RawIDA::ComputeV(unsigned int i)\n  {\n  \tif (i >= m_v.size())\n  \t{\n  \t\tm_v.resize(i+1);\n  \t\tm_outputToInput.resize(i+1);\n  \t}\n  \n  \tm_outputToInput[i] = LookupInputChannel(m_outputChannelIds[i]);\n  \tif (m_outputToInput[i] == static_cast<unsigned int>(m_threshold) && i * m_threshold <= 1000*1000)\n  \t{\n  \t\tm_v[i].resize(m_threshold);\n  \t\tPrepareBulkPolynomialInterpolationAt(field, m_v[i].begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputChannelIds.size",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrepareBulkPolynomialInterpolation",
          "args": [
            "field",
            "m_w.begin()",
            "&(m_inputChannelIds[0])",
            "m_threshold"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareBulkPolynomialInterpolation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.cpp",
          "lines": "515-525",
          "snippet": "void PrepareBulkPolynomialInterpolation(const Ring &ring, Element *w, const Element x[], unsigned int n)\n{\n\tfor (unsigned int i=0; i<n; i++)\n\t{\n\t\tElement t = ring.MultiplicativeIdentity();\n\t\tfor (unsigned int j=0; j<n; j++)\n\t\t\tif (i != j)\n\t\t\t\tt = ring.Multiply(t, ring.Subtract(x[i], x[j]));\n\t\tw[i] = ring.MultiplicativeInverse(t);\n\t}\n}",
          "includes": [
            "#include <iostream>",
            "#include <sstream>",
            "#include \"secblock.h\"",
            "#include \"polynomi.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <sstream>\n#include \"secblock.h\"\n#include \"polynomi.h\"\n#include \"pch.h\"\n\nvoid PrepareBulkPolynomialInterpolation(const Ring &ring, Element *w, const Element x[], unsigned int n)\n{\n\tfor (unsigned int i=0; i<n; i++)\n\t{\n\t\tElement t = ring.MultiplicativeIdentity();\n\t\tfor (unsigned int j=0; j<n; j++)\n\t\t\tif (i != j)\n\t\t\t\tt = ring.Multiply(t, ring.Subtract(x[i], x[j]));\n\t\tw[i] = ring.MultiplicativeInverse(t);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_w.begin",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_inputChannelIds.size() == m_threshold"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;\n\nRawIDA {\n  void RawIDA::PrepareInterpolation()\n  {\n  \tassert(m_inputChannelIds.size() == m_threshold);\n  \tPrepareBulkPolynomialInterpolation(field, m_w.begin(), &(m_inputChannelIds[0]), m_threshold);\n  \tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n  \t\tComputeV(i);\n  }\n}"
  },
  {
    "function_name": "AddOutputChannel",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "142-149",
    "snippet": "void RawIDA::AddOutputChannel(word32 channelId)\n{\n\tm_outputChannelIds.push_back(channelId);\n\tm_outputChannelIdStrings.push_back(WordToString(channelId));\n\tm_outputQueues.push_back(ByteQueue());\n\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n\t\tComputeV((unsigned int)m_outputChannelIds.size() - 1);\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ComputeV",
          "args": [
            "(unsigned int)m_outputChannelIds.size() - 1"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeV",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "126-140",
          "snippet": "void RawIDA::ComputeV(unsigned int i)\n{\n\tif (i >= m_v.size())\n\t{\n\t\tm_v.resize(i+1);\n\t\tm_outputToInput.resize(i+1);\n\t}\n\n\tm_outputToInput[i] = LookupInputChannel(m_outputChannelIds[i]);\n\tif (m_outputToInput[i] == static_cast<unsigned int>(m_threshold) && i * m_threshold <= 1000*1000)\n\t{\n\t\tm_v[i].resize(m_threshold);\n\t\tPrepareBulkPolynomialInterpolationAt(field, m_v[i].begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n\t}\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;\n\nRawIDA {\n  void RawIDA::ComputeV(unsigned int i)\n  {\n  \tif (i >= m_v.size())\n  \t{\n  \t\tm_v.resize(i+1);\n  \t\tm_outputToInput.resize(i+1);\n  \t}\n  \n  \tm_outputToInput[i] = LookupInputChannel(m_outputChannelIds[i]);\n  \tif (m_outputToInput[i] == static_cast<unsigned int>(m_threshold) && i * m_threshold <= 1000*1000)\n  \t{\n  \t\tm_v[i].resize(m_threshold);\n  \t\tPrepareBulkPolynomialInterpolationAt(field, m_v[i].begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputChannelIds.size",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<size_t>",
          "args": [
            "m_threshold"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputQueues.push_back",
          "args": [
            "ByteQueue()"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ByteQueue",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "FinalizeLazyPut",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "285-291",
          "snippet": "void ByteQueue::FinalizeLazyPut()\n{\n\tsize_t len = m_lazyLength;\n\tm_lazyLength = 0;\n\tif (len)\n\t\tPut(m_lazyString, len);\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  void ByteQueue::FinalizeLazyPut()\n  {\n  \tsize_t len = m_lazyLength;\n  \tm_lazyLength = 0;\n  \tif (len)\n  \t\tPut(m_lazyString, len);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputChannelIdStrings.push_back",
          "args": [
            "WordToString(channelId)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WordToString",
          "args": [
            "channelId"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "WordToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1206-1212",
          "snippet": "std::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tvalue = ByteReverse(value);\n\n\treturn std::string((char *)&value, sizeof(value));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string WordToString(T value, ByteOrder order = BIG_ENDIAN_ORDER)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tvalue = ByteReverse(value);\n\n\treturn std::string((char *)&value, sizeof(value));\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_outputChannelIds.push_back",
          "args": [
            "channelId"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::AddOutputChannel(word32 channelId)\n  {\n  \tm_outputChannelIds.push_back(channelId);\n  \tm_outputChannelIdStrings.push_back(WordToString(channelId));\n  \tm_outputQueues.push_back(ByteQueue());\n  \tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n  \t\tComputeV((unsigned int)m_outputChannelIds.size() - 1);\n  }\n}"
  },
  {
    "function_name": "ComputeV",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "126-140",
    "snippet": "void RawIDA::ComputeV(unsigned int i)\n{\n\tif (i >= m_v.size())\n\t{\n\t\tm_v.resize(i+1);\n\t\tm_outputToInput.resize(i+1);\n\t}\n\n\tm_outputToInput[i] = LookupInputChannel(m_outputChannelIds[i]);\n\tif (m_outputToInput[i] == static_cast<unsigned int>(m_threshold) && i * m_threshold <= 1000*1000)\n\t{\n\t\tm_v[i].resize(m_threshold);\n\t\tPrepareBulkPolynomialInterpolationAt(field, m_v[i].begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n\t}\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrepareBulkPolynomialInterpolationAt",
          "args": [
            "field",
            "m_v[i].begin()",
            "m_outputChannelIds[i]",
            "&(m_inputChannelIds[0])",
            "m_w.begin()",
            "m_threshold"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareBulkPolynomialInterpolationAt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.cpp",
          "lines": "528-552",
          "snippet": "void PrepareBulkPolynomialInterpolationAt(const Ring &ring, Element *v, const Element &position, const Element x[], const Element w[], unsigned int n)\n{\n\tassert(n > 0);\n\n\tstd::vector<Element> a(2*n-1);\n\tunsigned int i;\n\n\tfor (i=0; i<n; i++)\n\t\ta[n-1+i] = ring.Subtract(position, x[i]);\n\n\tfor (i=n-1; i>1; i--)\n\t\ta[i-1] = ring.Multiply(a[2*i], a[2*i-1]);\n\n\ta[0] = ring.MultiplicativeIdentity();\n\n\tfor (i=0; i<n-1; i++)\n\t{\n\t\tstd::swap(a[2*i+1], a[2*i+2]);\n\t\ta[2*i+1] = ring.Multiply(a[i], a[2*i+1]);\n\t\ta[2*i+2] = ring.Multiply(a[i], a[2*i+2]);\n\t}\n\n\tfor (i=0; i<n; i++)\n\t\tv[i] = ring.Multiply(a[n-1+i], w[i]);\n}",
          "includes": [
            "#include <iostream>",
            "#include <sstream>",
            "#include \"secblock.h\"",
            "#include \"polynomi.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <sstream>\n#include \"secblock.h\"\n#include \"polynomi.h\"\n#include \"pch.h\"\n\nvoid PrepareBulkPolynomialInterpolationAt(const Ring &ring, Element *v, const Element &position, const Element x[], const Element w[], unsigned int n)\n{\n\tassert(n > 0);\n\n\tstd::vector<Element> a(2*n-1);\n\tunsigned int i;\n\n\tfor (i=0; i<n; i++)\n\t\ta[n-1+i] = ring.Subtract(position, x[i]);\n\n\tfor (i=n-1; i>1; i--)\n\t\ta[i-1] = ring.Multiply(a[2*i], a[2*i-1]);\n\n\ta[0] = ring.MultiplicativeIdentity();\n\n\tfor (i=0; i<n-1; i++)\n\t{\n\t\tstd::swap(a[2*i+1], a[2*i+2]);\n\t\ta[2*i+1] = ring.Multiply(a[i], a[2*i+1]);\n\t\ta[2*i+2] = ring.Multiply(a[i], a[2*i+2]);\n\t}\n\n\tfor (i=0; i<n; i++)\n\t\tv[i] = ring.Multiply(a[n-1+i], w[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_w.begin",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_v[i].resize",
          "args": [
            "m_threshold"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned int>",
          "args": [
            "m_threshold"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LookupInputChannel",
          "args": [
            "m_outputChannelIds[i]"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "LookupInputChannel",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "79-86",
          "snippet": "unsigned int RawIDA::LookupInputChannel(word32 channelId) const\n{\n\tmap<word32, unsigned int>::const_iterator it = m_inputChannelMap.find(channelId);\n\tif (it == m_inputChannelMap.end())\n\t\treturn m_threshold;\n\telse\n\t\treturn it->second;\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  unsigned int RawIDA::LookupInputChannel(word32 channelId) const\n  {\n  \tmap<word32, unsigned int>::const_iterator it = m_inputChannelMap.find(channelId);\n  \tif (it == m_inputChannelMap.end())\n  \t\treturn m_threshold;\n  \telse\n  \t\treturn it->second;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_v.size",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;\n\nRawIDA {\n  void RawIDA::ComputeV(unsigned int i)\n  {\n  \tif (i >= m_v.size())\n  \t{\n  \t\tm_v.resize(i+1);\n  \t\tm_outputToInput.resize(i+1);\n  \t}\n  \n  \tm_outputToInput[i] = LookupInputChannel(m_outputChannelIds[i]);\n  \tif (m_outputToInput[i] == static_cast<unsigned int>(m_threshold) && i * m_threshold <= 1000*1000)\n  \t{\n  \t\tm_v[i].resize(m_threshold);\n  \t\tPrepareBulkPolynomialInterpolationAt(field, m_v[i].begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n  \t}\n  }\n}"
  },
  {
    "function_name": "InputBuffered",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "120-124",
    "snippet": "lword RawIDA::InputBuffered(word32 channelId) const\n{\n\tint i = LookupInputChannel(channelId);\n\treturn i < m_threshold ? m_inputQueues[i].MaxRetrievable() : 0;\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_inputQueues[i].MaxRetrievable",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LookupInputChannel",
          "args": [
            "channelId"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "LookupInputChannel",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "79-86",
          "snippet": "unsigned int RawIDA::LookupInputChannel(word32 channelId) const\n{\n\tmap<word32, unsigned int>::const_iterator it = m_inputChannelMap.find(channelId);\n\tif (it == m_inputChannelMap.end())\n\t\treturn m_threshold;\n\telse\n\t\treturn it->second;\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  unsigned int RawIDA::LookupInputChannel(word32 channelId) const\n  {\n  \tmap<word32, unsigned int>::const_iterator it = m_inputChannelMap.find(channelId);\n  \tif (it == m_inputChannelMap.end())\n  \t\treturn m_threshold;\n  \telse\n  \t\treturn it->second;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  lword RawIDA::InputBuffered(word32 channelId) const\n  {\n  \tint i = LookupInputChannel(channelId);\n  \treturn i < m_threshold ? m_inputQueues[i].MaxRetrievable() : 0;\n  }\n}"
  },
  {
    "function_name": "ChannelData",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "88-118",
    "snippet": "void RawIDA::ChannelData(word32 channelId, const byte *inString, size_t length, bool messageEnd)\n{\n\tint i = InsertInputChannel(channelId);\n\tif (i < m_threshold)\n\t{\n\t\tlword size = m_inputQueues[i].MaxRetrievable();\n\t\tm_inputQueues[i].Put(inString, length);\n\t\tif (size < 4 && size + length >= 4)\n\t\t{\n\t\t\tm_channelsReady++;\n\t\t\tif (m_channelsReady == static_cast<unsigned int>(m_threshold))\n\t\t\t\tProcessInputQueues();\n\t\t}\n\n\t\tif (messageEnd)\n\t\t{\n\t\t\tm_inputQueues[i].MessageEnd();\n\t\t\tif (m_inputQueues[i].NumberOfMessages() == 1)\n\t\t\t{\n\t\t\t\tm_channelsFinished++;\n\t\t\t\tif (m_channelsFinished == static_cast<unsigned int>(m_threshold))\n\t\t\t\t{\n\t\t\t\t\tm_channelsReady = 0;\n\t\t\t\t\tfor (i=0; i<m_threshold; i++)\n\t\t\t\t\t\tm_channelsReady += m_inputQueues[i].AnyRetrievable();\n\t\t\t\t\tProcessInputQueues();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessInputQueues",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessInputQueues",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "159-218",
          "snippet": "void RawIDA::ProcessInputQueues()\n{\n\tbool finished = (m_channelsFinished == static_cast<unsigned int>(m_threshold));\n\tint i;\n\n\twhile (finished ? m_channelsReady > 0 : m_channelsReady == static_cast<size_t>(m_threshold))\n\t{\n\t\tm_channelsReady = 0;\n\t\tfor (i=0; i<m_threshold; i++)\n\t\t{\n\t\t\tMessageQueue &queue = m_inputQueues[i];\n\t\t\tqueue.GetWord32(m_y[i]);\n\n\t\t\tif (finished)\n\t\t\t\tm_channelsReady += queue.AnyRetrievable();\n\t\t\telse\n\t\t\t\tm_channelsReady += queue.NumberOfMessages() > 0 || queue.MaxRetrievable() >= 4;\n\t\t}\n\n\t\tfor (i=0; (unsigned int)i<m_outputChannelIds.size(); i++)\n\t\t{\n\t\t\tif (m_outputToInput[i] != static_cast<unsigned int>(m_threshold))\n\t\t\t\tm_outputQueues[i].PutWord32(m_y[m_outputToInput[i]]);\n\t\t\telse if (m_v[i].size() == static_cast<size_t>(m_threshold))\n\t\t\t\tm_outputQueues[i].PutWord32(BulkPolynomialInterpolateAt(field, m_y.begin(), m_v[i].begin(), m_threshold));\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_u.resize(m_threshold);\n\t\t\t\tPrepareBulkPolynomialInterpolationAt(field, m_u.begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n\t\t\t\tm_outputQueues[i].PutWord32(BulkPolynomialInterpolateAt(field, m_y.begin(), m_u.begin(), m_threshold));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (m_outputChannelIds.size() > 0 && m_outputQueues[0].AnyRetrievable())\n\t\tFlushOutputQueues();\n\n\tif (finished)\n\t{\n\t\tOutputMessageEnds();\n\n\t\tm_channelsReady = 0;\n\t\tm_channelsFinished = 0;\n\t\tm_v.clear();\n\n\t\tvector<MessageQueue> inputQueues;\n\t\tvector<word32> inputChannelIds;\n\n\t\tinputQueues.swap(m_inputQueues);\n\t\tinputChannelIds.swap(m_inputChannelIds);\n\t\tm_inputChannelMap.clear();\n\t\tm_lastMapPosition = m_inputChannelMap.end();\n\n\t\tfor (i=0; i<m_threshold; i++)\n\t\t{\n\t\t\tinputQueues[i].GetNextMessage();\n\t\t\tinputQueues[i].TransferAllTo(*AttachedTransformation(), WordToString(inputChannelIds[i]));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;\n\nRawIDA {\n  void RawIDA::ProcessInputQueues()\n  {\n  \tbool finished = (m_channelsFinished == static_cast<unsigned int>(m_threshold));\n  \tint i;\n  \n  \twhile (finished ? m_channelsReady > 0 : m_channelsReady == static_cast<size_t>(m_threshold))\n  \t{\n  \t\tm_channelsReady = 0;\n  \t\tfor (i=0; i<m_threshold; i++)\n  \t\t{\n  \t\t\tMessageQueue &queue = m_inputQueues[i];\n  \t\t\tqueue.GetWord32(m_y[i]);\n  \n  \t\t\tif (finished)\n  \t\t\t\tm_channelsReady += queue.AnyRetrievable();\n  \t\t\telse\n  \t\t\t\tm_channelsReady += queue.NumberOfMessages() > 0 || queue.MaxRetrievable() >= 4;\n  \t\t}\n  \n  \t\tfor (i=0; (unsigned int)i<m_outputChannelIds.size(); i++)\n  \t\t{\n  \t\t\tif (m_outputToInput[i] != static_cast<unsigned int>(m_threshold))\n  \t\t\t\tm_outputQueues[i].PutWord32(m_y[m_outputToInput[i]]);\n  \t\t\telse if (m_v[i].size() == static_cast<size_t>(m_threshold))\n  \t\t\t\tm_outputQueues[i].PutWord32(BulkPolynomialInterpolateAt(field, m_y.begin(), m_v[i].begin(), m_threshold));\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tm_u.resize(m_threshold);\n  \t\t\t\tPrepareBulkPolynomialInterpolationAt(field, m_u.begin(), m_outputChannelIds[i], &(m_inputChannelIds[0]), m_w.begin(), m_threshold);\n  \t\t\t\tm_outputQueues[i].PutWord32(BulkPolynomialInterpolateAt(field, m_y.begin(), m_u.begin(), m_threshold));\n  \t\t\t}\n  \t\t}\n  \t}\n  \n  \tif (m_outputChannelIds.size() > 0 && m_outputQueues[0].AnyRetrievable())\n  \t\tFlushOutputQueues();\n  \n  \tif (finished)\n  \t{\n  \t\tOutputMessageEnds();\n  \n  \t\tm_channelsReady = 0;\n  \t\tm_channelsFinished = 0;\n  \t\tm_v.clear();\n  \n  \t\tvector<MessageQueue> inputQueues;\n  \t\tvector<word32> inputChannelIds;\n  \n  \t\tinputQueues.swap(m_inputQueues);\n  \t\tinputChannelIds.swap(m_inputChannelIds);\n  \t\tm_inputChannelMap.clear();\n  \t\tm_lastMapPosition = m_inputChannelMap.end();\n  \n  \t\tfor (i=0; i<m_threshold; i++)\n  \t\t{\n  \t\t\tinputQueues[i].GetNextMessage();\n  \t\t\tinputQueues[i].TransferAllTo(*AttachedTransformation(), WordToString(inputChannelIds[i]));\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputQueues[i].AnyRetrievable",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "AnyRetrievable",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "394-403",
          "snippet": "bool BufferedTransformation::AnyRetrievable() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyRetrievable();\n\telse\n\t{\n\t\tbyte b;\n\t\treturn Peek(b) != 0;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyRetrievable() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyRetrievable();\n  \telse\n  \t{\n  \t\tbyte b;\n  \t\treturn Peek(b) != 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned int>",
          "args": [
            "m_threshold"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inputQueues[i].NumberOfMessages",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "NumberOfMessages",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "459-465",
          "snippet": "unsigned int BufferedTransformation::NumberOfMessages() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->NumberOfMessages();\n\telse\n\t\treturn CopyMessagesTo(TheBitBucket());\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  unsigned int BufferedTransformation::NumberOfMessages() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->NumberOfMessages();\n  \telse\n  \t\treturn CopyMessagesTo(TheBitBucket());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputQueues[i].MessageEnd",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned int>",
          "args": [
            "m_threshold"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inputQueues[i].Put",
          "args": [
            "inString",
            "length"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputQueues[i].MaxRetrievable",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "InsertInputChannel",
          "args": [
            "channelId"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "InsertInputChannel",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "51-77",
          "snippet": "unsigned int RawIDA::InsertInputChannel(word32 channelId)\n{\n\tif (m_lastMapPosition != m_inputChannelMap.end())\n\t{\n\t\tif (m_lastMapPosition->first == channelId)\n\t\t\tgoto skipFind;\n\t\t++m_lastMapPosition;\n\t\tif (m_lastMapPosition != m_inputChannelMap.end() && m_lastMapPosition->first == channelId)\n\t\t\tgoto skipFind;\n\t}\n\tm_lastMapPosition = m_inputChannelMap.find(channelId);\n\nskipFind:\n\tif (m_lastMapPosition == m_inputChannelMap.end())\n\t{\n\t\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n\t\t\treturn m_threshold;\n\n\t\tm_lastMapPosition = m_inputChannelMap.insert(InputChannelMap::value_type(channelId, (unsigned int)m_inputChannelIds.size())).first;\n\t\tm_inputQueues.push_back(MessageQueue());\n\t\tm_inputChannelIds.push_back(channelId);\n\n\t\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n\t\t\tPrepareInterpolation();\n\t}\n\treturn m_lastMapPosition->second;\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  unsigned int RawIDA::InsertInputChannel(word32 channelId)\n  {\n  \tif (m_lastMapPosition != m_inputChannelMap.end())\n  \t{\n  \t\tif (m_lastMapPosition->first == channelId)\n  \t\t\tgoto skipFind;\n  \t\t++m_lastMapPosition;\n  \t\tif (m_lastMapPosition != m_inputChannelMap.end() && m_lastMapPosition->first == channelId)\n  \t\t\tgoto skipFind;\n  \t}\n  \tm_lastMapPosition = m_inputChannelMap.find(channelId);\n  \n  skipFind:\n  \tif (m_lastMapPosition == m_inputChannelMap.end())\n  \t{\n  \t\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n  \t\t\treturn m_threshold;\n  \n  \t\tm_lastMapPosition = m_inputChannelMap.insert(InputChannelMap::value_type(channelId, (unsigned int)m_inputChannelIds.size())).first;\n  \t\tm_inputQueues.push_back(MessageQueue());\n  \t\tm_inputChannelIds.push_back(channelId);\n  \n  \t\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n  \t\t\tPrepareInterpolation();\n  \t}\n  \treturn m_lastMapPosition->second;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::ChannelData(word32 channelId, const byte *inString, size_t length, bool messageEnd)\n  {\n  \tint i = InsertInputChannel(channelId);\n  \tif (i < m_threshold)\n  \t{\n  \t\tlword size = m_inputQueues[i].MaxRetrievable();\n  \t\tm_inputQueues[i].Put(inString, length);\n  \t\tif (size < 4 && size + length >= 4)\n  \t\t{\n  \t\t\tm_channelsReady++;\n  \t\t\tif (m_channelsReady == static_cast<unsigned int>(m_threshold))\n  \t\t\t\tProcessInputQueues();\n  \t\t}\n  \n  \t\tif (messageEnd)\n  \t\t{\n  \t\t\tm_inputQueues[i].MessageEnd();\n  \t\t\tif (m_inputQueues[i].NumberOfMessages() == 1)\n  \t\t\t{\n  \t\t\t\tm_channelsFinished++;\n  \t\t\t\tif (m_channelsFinished == static_cast<unsigned int>(m_threshold))\n  \t\t\t\t{\n  \t\t\t\t\tm_channelsReady = 0;\n  \t\t\t\t\tfor (i=0; i<m_threshold; i++)\n  \t\t\t\t\t\tm_channelsReady += m_inputQueues[i].AnyRetrievable();\n  \t\t\t\t\tProcessInputQueues();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
  },
  {
    "function_name": "LookupInputChannel",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "79-86",
    "snippet": "unsigned int RawIDA::LookupInputChannel(word32 channelId) const\n{\n\tmap<word32, unsigned int>::const_iterator it = m_inputChannelMap.find(channelId);\n\tif (it == m_inputChannelMap.end())\n\t\treturn m_threshold;\n\telse\n\t\treturn it->second;\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_inputChannelMap.end",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputChannelMap.find",
          "args": [
            "channelId"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  unsigned int RawIDA::LookupInputChannel(word32 channelId) const\n  {\n  \tmap<word32, unsigned int>::const_iterator it = m_inputChannelMap.find(channelId);\n  \tif (it == m_inputChannelMap.end())\n  \t\treturn m_threshold;\n  \telse\n  \t\treturn it->second;\n  }\n}"
  },
  {
    "function_name": "InsertInputChannel",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "51-77",
    "snippet": "unsigned int RawIDA::InsertInputChannel(word32 channelId)\n{\n\tif (m_lastMapPosition != m_inputChannelMap.end())\n\t{\n\t\tif (m_lastMapPosition->first == channelId)\n\t\t\tgoto skipFind;\n\t\t++m_lastMapPosition;\n\t\tif (m_lastMapPosition != m_inputChannelMap.end() && m_lastMapPosition->first == channelId)\n\t\t\tgoto skipFind;\n\t}\n\tm_lastMapPosition = m_inputChannelMap.find(channelId);\n\nskipFind:\n\tif (m_lastMapPosition == m_inputChannelMap.end())\n\t{\n\t\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n\t\t\treturn m_threshold;\n\n\t\tm_lastMapPosition = m_inputChannelMap.insert(InputChannelMap::value_type(channelId, (unsigned int)m_inputChannelIds.size())).first;\n\t\tm_inputQueues.push_back(MessageQueue());\n\t\tm_inputChannelIds.push_back(channelId);\n\n\t\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n\t\t\tPrepareInterpolation();\n\t}\n\treturn m_lastMapPosition->second;\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrepareInterpolation",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareInterpolation",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "151-157",
          "snippet": "void RawIDA::PrepareInterpolation()\n{\n\tassert(m_inputChannelIds.size() == m_threshold);\n\tPrepareBulkPolynomialInterpolation(field, m_w.begin(), &(m_inputChannelIds[0]), m_threshold);\n\tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n\t\tComputeV(i);\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nANONYMOUS_NAMESPACE_BEGIN\nstatic const CryptoPP::GF2_32 field;\n\nRawIDA {\n  void RawIDA::PrepareInterpolation()\n  {\n  \tassert(m_inputChannelIds.size() == m_threshold);\n  \tPrepareBulkPolynomialInterpolation(field, m_w.begin(), &(m_inputChannelIds[0]), m_threshold);\n  \tfor (unsigned int i=0; i<m_outputChannelIds.size(); i++)\n  \t\tComputeV(i);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<size_t>",
          "args": [
            "m_threshold"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inputChannelIds.size",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputChannelIds.push_back",
          "args": [
            "channelId"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inputQueues.push_back",
          "args": [
            "MessageQueue()"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageQueue",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "GetNextMessage",
          "container": "MessageQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "32-43",
          "snippet": "bool MessageQueue::GetNextMessage()\n{\n\tif (NumberOfMessages() > 0 && !AnyRetrievable())\n\t{\n\t\tm_lengths.pop_front();\n\t\tif (m_messageCounts[0] == 0 && m_messageCounts.size() > 1)\n\t\t\tm_messageCounts.pop_front();\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"mqueue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nMessageQueue {\n  bool MessageQueue::GetNextMessage()\n  {\n  \tif (NumberOfMessages() > 0 && !AnyRetrievable())\n  \t{\n  \t\tm_lengths.pop_front();\n  \t\tif (m_messageCounts[0] == 0 && m_messageCounts.size() > 1)\n  \t\t\tm_messageCounts.pop_front();\n  \t\treturn true;\n  \t}\n  \telse\n  \t\treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputChannelMap.insert",
          "args": [
            "InputChannelMap::value_type(channelId, (unsigned int)m_inputChannelIds.size())"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InputChannelMap::value_type",
          "args": [
            "channelId",
            "(unsigned int)m_inputChannelIds.size()"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<size_t>",
          "args": [
            "m_threshold"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inputChannelMap.end",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputChannelMap.find",
          "args": [
            "channelId"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  unsigned int RawIDA::InsertInputChannel(word32 channelId)\n  {\n  \tif (m_lastMapPosition != m_inputChannelMap.end())\n  \t{\n  \t\tif (m_lastMapPosition->first == channelId)\n  \t\t\tgoto skipFind;\n  \t\t++m_lastMapPosition;\n  \t\tif (m_lastMapPosition != m_inputChannelMap.end() && m_lastMapPosition->first == channelId)\n  \t\t\tgoto skipFind;\n  \t}\n  \tm_lastMapPosition = m_inputChannelMap.find(channelId);\n  \n  skipFind:\n  \tif (m_lastMapPosition == m_inputChannelMap.end())\n  \t{\n  \t\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n  \t\t\treturn m_threshold;\n  \n  \t\tm_lastMapPosition = m_inputChannelMap.insert(InputChannelMap::value_type(channelId, (unsigned int)m_inputChannelIds.size())).first;\n  \t\tm_inputQueues.push_back(MessageQueue());\n  \t\tm_inputChannelIds.push_back(channelId);\n  \n  \t\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n  \t\t\tPrepareInterpolation();\n  \t}\n  \treturn m_lastMapPosition->second;\n  }\n}"
  },
  {
    "function_name": "IsolatedInitialize",
    "container": "RawIDA",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
    "lines": "21-49",
    "snippet": "void RawIDA::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tif (!parameters.GetIntValue(\"RecoveryThreshold\", m_threshold))\n\t\tthrow InvalidArgument(\"RawIDA: missing RecoveryThreshold argument\");\n\n\tif (m_threshold <= 0)\n\t\tthrow InvalidArgument(\"RawIDA: RecoveryThreshold must be greater than 0\");\n\n\tm_lastMapPosition = m_inputChannelMap.end();\n\tm_channelsReady = 0;\n\tm_channelsFinished = 0;\n\tm_w.New(m_threshold);\n\tm_y.New(m_threshold);\n\tm_inputQueues.reserve(m_threshold);\n\n\tm_outputChannelIds.clear();\n\tm_outputChannelIdStrings.clear();\n\tm_outputQueues.clear();\n\n\tword32 outputChannelID;\n\tif (parameters.GetValue(\"OutputChannelID\", outputChannelID))\n\t\tAddOutputChannel(outputChannelID);\n\telse\n\t{\n\t\tint nShares = parameters.GetIntValueWithDefault(\"NumberOfShares\", m_threshold);\n\t\tfor (int i=0; i<nShares; i++)\n\t\t\tAddOutputChannel(i);\n\t}\n}",
    "includes": [
      "#include \"polynomi.cpp\"",
      "#include <functional>",
      "#include \"polynomi.h\"",
      "#include \"gf2_32.h\"",
      "#include \"algebra.h\"",
      "#include \"ida.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddOutputChannel",
          "args": [
            "i"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "AddOutputChannel",
          "container": "RawIDA",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.cpp",
          "lines": "142-149",
          "snippet": "void RawIDA::AddOutputChannel(word32 channelId)\n{\n\tm_outputChannelIds.push_back(channelId);\n\tm_outputChannelIdStrings.push_back(WordToString(channelId));\n\tm_outputQueues.push_back(ByteQueue());\n\tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n\t\tComputeV((unsigned int)m_outputChannelIds.size() - 1);\n}",
          "includes": [
            "#include \"polynomi.cpp\"",
            "#include <functional>",
            "#include \"polynomi.h\"",
            "#include \"gf2_32.h\"",
            "#include \"algebra.h\"",
            "#include \"ida.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::AddOutputChannel(word32 channelId)\n  {\n  \tm_outputChannelIds.push_back(channelId);\n  \tm_outputChannelIdStrings.push_back(WordToString(channelId));\n  \tm_outputQueues.push_back(ByteQueue());\n  \tif (m_inputChannelIds.size() == static_cast<size_t>(m_threshold))\n  \t\tComputeV((unsigned int)m_outputChannelIds.size() - 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameters.GetIntValueWithDefault",
          "args": [
            "\"NumberOfShares\"",
            "m_threshold"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetValue",
          "args": [
            "\"OutputChannelID\"",
            "outputChannelID"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputQueues.clear",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputChannelIdStrings.clear",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_outputChannelIds.clear",
          "args": [],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inputQueues.reserve",
          "args": [
            "m_threshold"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_y.New",
          "args": [
            "m_threshold"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inputChannelMap.end",
          "args": [],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"RawIDA: RecoveryThreshold must be greater than 0\""
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"RawIDA: missing RecoveryThreshold argument\""
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parameters.GetIntValue",
          "args": [
            "\"RecoveryThreshold\"",
            "m_threshold"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"polynomi.cpp\"\n#include <functional>\n#include \"polynomi.h\"\n#include \"gf2_32.h\"\n#include \"algebra.h\"\n#include \"ida.h\"\n#include \"pch.h\"\n\nRawIDA {\n  void RawIDA::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tif (!parameters.GetIntValue(\"RecoveryThreshold\", m_threshold))\n  \t\tthrow InvalidArgument(\"RawIDA: missing RecoveryThreshold argument\");\n  \n  \tif (m_threshold <= 0)\n  \t\tthrow InvalidArgument(\"RawIDA: RecoveryThreshold must be greater than 0\");\n  \n  \tm_lastMapPosition = m_inputChannelMap.end();\n  \tm_channelsReady = 0;\n  \tm_channelsFinished = 0;\n  \tm_w.New(m_threshold);\n  \tm_y.New(m_threshold);\n  \tm_inputQueues.reserve(m_threshold);\n  \n  \tm_outputChannelIds.clear();\n  \tm_outputChannelIdStrings.clear();\n  \tm_outputQueues.clear();\n  \n  \tword32 outputChannelID;\n  \tif (parameters.GetValue(\"OutputChannelID\", outputChannelID))\n  \t\tAddOutputChannel(outputChannelID);\n  \telse\n  \t{\n  \t\tint nShares = parameters.GetIntValueWithDefault(\"NumberOfShares\", m_threshold);\n  \t\tfor (int i=0; i<nShares; i++)\n  \t\t\tAddOutputChannel(i);\n  \t}\n  }\n}"
  }
]