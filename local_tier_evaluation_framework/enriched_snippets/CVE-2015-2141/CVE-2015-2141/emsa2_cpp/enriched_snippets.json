[
  {
    "function_name": "ComputeMessageRepresentative",
    "container": "EMSA2Pad",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.cpp",
    "lines": "10-30",
    "snippet": "void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n\tconst byte *recoverableMessage, size_t recoverableMessageLength,\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tif (representativeBitLength % 8 != 7)\n\t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n\n\tsize_t digestSize = hash.DigestSize();\n\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n\n\trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n\tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n\tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n\tafterP2[0] = 0xba;\n\thash.Final(afterP2+1);\n\trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n\trepresentative[representativeByteLength-1] = 0xcc;\n}",
    "includes": [
      "#include \"emsa2.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash.Final",
          "args": [
            "afterP2+1"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "representative+1",
            "0xbb",
            "representativeByteLength-digestSize-4"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitsToBytes",
          "args": [
            "representativeBitLength"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "BitsToBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "307-310",
          "snippet": "inline size_t BitsToBytes(size_t bitCount)\n{\n\treturn ((bitCount+7)/(8));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline size_t BitsToBytes(size_t bitCount)\n{\n\treturn ((bitCount+7)/(8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.DigestSize",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::InvalidKeyLength",
          "args": [
            "\"EMSA2: EMSA2 requires a key length that is a multiple of 8\""
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize())"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MinRepresentativeBitLength",
          "args": [
            "hashIdentifier.second",
            "hash.DigestSize()"
          ],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      }
    ],
    "contextual_snippet": "#include \"emsa2.h\"\n#include \"pch.h\"\n\nEMSA2Pad {\n  void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n  \tconst byte *recoverableMessage, size_t recoverableMessageLength,\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength) const\n  {\n  \tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n  \n  \tif (representativeBitLength % 8 != 7)\n  \t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n  \n  \tsize_t digestSize = hash.DigestSize();\n  \tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n  \n  \trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n  \tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n  \tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n  \tafterP2[0] = 0xba;\n  \thash.Final(afterP2+1);\n  \trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n  \trepresentative[representativeByteLength-1] = 0xcc;\n  }\n}"
  }
]