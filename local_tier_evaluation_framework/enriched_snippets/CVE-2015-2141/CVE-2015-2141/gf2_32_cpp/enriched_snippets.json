[
  {
    "function_name": "GF2_32::MultiplicativeInverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2_32.cpp",
    "lines": "46-97",
    "snippet": "GF2_32::Element GF2_32::MultiplicativeInverse(Element a) const\n{\n\tif (a <= 1)\t\t// 1 is a special case\n\t\treturn a;\n\n\t// warning - don't try to adapt this algorithm for another situation\n\tword32 g0=m_modulus, g1=a, g2=a;\n\tword32 v0=0, v1=1, v2=1;\n\n\tassert(g1);\n\n\twhile (!(g2 & 0x80000000))\n\t{\n\t\tg2 <<= 1;\n\t\tv2 <<= 1;\n\t}\n\n\tg2 <<= 1;\n\tv2 <<= 1;\n\n\tg0 ^= g2;\n\tv0 ^= v2;\n\n\twhile (g0 != 1)\n\t{\n\t\tif (g1 < g0 || ((g0^g1) < g0 && (g0^g1) < g1))\n\t\t{\n\t\t\tassert(BitPrecision(g1) <= BitPrecision(g0));\n\t\t\tg2 = g1;\n\t\t\tv2 = v1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(BitPrecision(g1) > BitPrecision(g0));\n\t\t\tg2 = g0; g0 = g1; g1 = g2;\n\t\t\tv2 = v0; v0 = v1; v1 = v2;\n\t\t}\n\n\t\twhile ((g0^g2) >= g2)\n\t\t{\n\t\t\tassert(BitPrecision(g0) > BitPrecision(g2));\n\t\t\tg2 <<= 1;\n\t\t\tv2 <<= 1;\n\t\t}\n\n\t\tassert(BitPrecision(g0) == BitPrecision(g2));\n\t\tg0 ^= g2;\n\t\tv0 ^= v2;\n\t}\n\n\treturn v0;\n}",
    "includes": [
      "#include \"gf2_32.h\"",
      "#include \"misc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "BitPrecision(g0) == BitPrecision(g2)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitPrecision",
          "args": [
            "g2"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "BitPrecision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "238-255",
          "snippet": "unsigned int BitPrecision(const T &value)\n{\n\tif (!value)\n\t\treturn 0;\n\n\tunsigned int l=0, h=8*sizeof(value);\n\n\twhile (h-l > 1)\n\t{\n\t\tunsigned int t = (l+h)/2;\n\t\tif (value >> t)\n\t\t\tl = t;\n\t\telse\n\t\t\th = t;\n\t}\n\n\treturn h;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nunsigned int BitPrecision(const T &value)\n{\n\tif (!value)\n\t\treturn 0;\n\n\tunsigned int l=0, h=8*sizeof(value);\n\n\twhile (h-l > 1)\n\t{\n\t\tunsigned int t = (l+h)/2;\n\t\tif (value >> t)\n\t\t\tl = t;\n\t\telse\n\t\t\th = t;\n\t}\n\n\treturn h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "BitPrecision(g0) > BitPrecision(g2)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "BitPrecision(g1) > BitPrecision(g0)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "BitPrecision(g1) <= BitPrecision(g0)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "g1"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gf2_32.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nGF2_32::Element GF2_32::MultiplicativeInverse(Element a) const\n{\n\tif (a <= 1)\t\t// 1 is a special case\n\t\treturn a;\n\n\t// warning - don't try to adapt this algorithm for another situation\n\tword32 g0=m_modulus, g1=a, g2=a;\n\tword32 v0=0, v1=1, v2=1;\n\n\tassert(g1);\n\n\twhile (!(g2 & 0x80000000))\n\t{\n\t\tg2 <<= 1;\n\t\tv2 <<= 1;\n\t}\n\n\tg2 <<= 1;\n\tv2 <<= 1;\n\n\tg0 ^= g2;\n\tv0 ^= v2;\n\n\twhile (g0 != 1)\n\t{\n\t\tif (g1 < g0 || ((g0^g1) < g0 && (g0^g1) < g1))\n\t\t{\n\t\t\tassert(BitPrecision(g1) <= BitPrecision(g0));\n\t\t\tg2 = g1;\n\t\t\tv2 = v1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(BitPrecision(g1) > BitPrecision(g0));\n\t\t\tg2 = g0; g0 = g1; g1 = g2;\n\t\t\tv2 = v0; v0 = v1; v1 = v2;\n\t\t}\n\n\t\twhile ((g0^g2) >= g2)\n\t\t{\n\t\t\tassert(BitPrecision(g0) > BitPrecision(g2));\n\t\t\tg2 <<= 1;\n\t\t\tv2 <<= 1;\n\t\t}\n\n\t\tassert(BitPrecision(g0) == BitPrecision(g2));\n\t\tg0 ^= g2;\n\t\tv0 ^= v2;\n\t}\n\n\treturn v0;\n}"
  },
  {
    "function_name": "GF2_32::Multiply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2_32.cpp",
    "lines": "9-44",
    "snippet": "GF2_32::Element GF2_32::Multiply(Element a, Element b) const\n{\n\tword32 table[4];\n\ttable[0] = 0;\n\ttable[1] = m_modulus;\n\tif (a & 0x80000000)\n\t{\n\t\ttable[2] = m_modulus ^ (a<<1);\n\t\ttable[3] = a<<1;\n\t}\n\telse\n\t{\n\t\ttable[2] = a<<1;\n\t\ttable[3] = m_modulus ^ (a<<1);\n\t}\n\n#if CRYPTOPP_FAST_ROTATE(32)\n\tb = rotrFixed(b, 30U);\n\tword32 result = table[b&2];\n\n\tfor (int i=29; i>=0; --i)\n\t{\n\t\tb = rotlFixed(b, 1U);\n\t\tresult = (result<<1) ^ table[(b&2) + (result>>31)];\n\t}\n\n\treturn (b&1) ? result ^ a : result;\n#else\n\tword32 result = table[(b>>30) & 2];\n\n\tfor (int i=29; i>=0; --i)\n\t\tresult = (result<<1) ^ table[((b>>i)&2) + (result>>31)];\n\n\treturn (b&1) ? result ^ a : result;\n#endif\n}",
    "includes": [
      "#include \"gf2_32.h\"",
      "#include \"misc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rotlFixed",
          "args": [
            "b",
            "1U"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "rotlFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "580-584",
          "snippet": "inline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotlFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x<<y) | (x>>(sizeof(T)*8-y))) : x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rotrFixed",
          "args": [
            "b",
            "30U"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "rotrFixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "586-590",
          "snippet": "inline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T rotrFixed(T x, unsigned int y)\n{\n\tassert(y < sizeof(T)*8);\n\treturn y ? T((x>>y) | (x<<(sizeof(T)*8-y))) : x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_FAST_ROTATE",
          "args": [
            "32"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gf2_32.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nGF2_32::Element GF2_32::Multiply(Element a, Element b) const\n{\n\tword32 table[4];\n\ttable[0] = 0;\n\ttable[1] = m_modulus;\n\tif (a & 0x80000000)\n\t{\n\t\ttable[2] = m_modulus ^ (a<<1);\n\t\ttable[3] = a<<1;\n\t}\n\telse\n\t{\n\t\ttable[2] = a<<1;\n\t\ttable[3] = m_modulus ^ (a<<1);\n\t}\n\n#if CRYPTOPP_FAST_ROTATE(32)\n\tb = rotrFixed(b, 30U);\n\tword32 result = table[b&2];\n\n\tfor (int i=29; i>=0; --i)\n\t{\n\t\tb = rotlFixed(b, 1U);\n\t\tresult = (result<<1) ^ table[(b&2) + (result>>31)];\n\t}\n\n\treturn (b&1) ? result ^ a : result;\n#else\n\tword32 result = table[(b>>30) & 2];\n\n\tfor (int i=29; i>=0; --i)\n\t\tresult = (result<<1) ^ table[((b>>i)&2) + (result>>31)];\n\n\treturn (b&1) ? result ^ a : result;\n#endif\n}"
  }
]