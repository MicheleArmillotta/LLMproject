[
  {
    "function_name": "XTR_Exponentiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.cpp",
    "lines": "53-95",
    "snippet": "GFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"xtr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfp2.ConvertOut",
          "args": [
            "S[1]"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertOut",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "65-66",
          "snippet": "GFP2Element ConvertOut(const GFP2Element &a) const\n\t\t{return GFP2Element(modp.ConvertOut(a.c1), modp.ConvertOut(a.c2));}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  GFP2Element ConvertOut(const GFP2Element &a) const\n  \t\t{return GFP2Element(modp.ConvertOut(a.c1), modp.ConvertOut(a.c2));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp2.SpecialOperation1",
          "args": [
            "S[1]"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S[2].swap",
          "args": [
            "S[1]"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "30-34",
          "snippet": "void swap(GFP2Element &a)\n\t{\n\t\tc1.swap(a.c1);\n\t\tc2.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void swap(GFP2Element &a)\n  \t{\n  \t\tc1.swap(a.c1);\n  \t\tc2.swap(a.c2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp2.SpecialOperation1",
          "args": [
            "S[0]"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp2.SpecialOperation1",
          "args": [
            "S[1]"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp2.Accumulate",
          "args": [
            "S[2]",
            "gfp2.SpecialOperation2(S[0], cp, S[1])"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp2.SpecialOperation2",
          "args": [
            "S[0]",
            "cp",
            "S[1]"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp2.RaiseToPthPower",
          "args": [
            "S[2]"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp2.SpecialOperation1",
          "args": [
            "S[2]"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp2.SpecialOperation1",
          "args": [
            "S[1]"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp2.Accumulate",
          "args": [
            "S[0]",
            "gfp2.SpecialOperation2(S[2], c, S[1])"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp2.SpecialOperation2",
          "args": [
            "S[2]",
            "c",
            "S[1]"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.GetBit",
          "args": [
            "i"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "GetBit",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2894-2900",
          "snippet": "bool Integer::GetBit(size_t n) const\n{\n\tif (n/WORD_BITS >= reg.size())\n\t\treturn 0;\n\telse\n\t\treturn bool((reg[n/WORD_BITS] >> (n % WORD_BITS)) & 1);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  bool Integer::GetBit(size_t n) const\n  {\n  \tif (n/WORD_BITS >= reg.size())\n  \t\treturn 0;\n  \telse\n  \t\treturn bool((reg[n/WORD_BITS] >> (n % WORD_BITS)) & 1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "e.BitCount",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "BitCount",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3054-3061",
          "snippet": "unsigned int Integer::BitCount() const\n{\n\tunsigned wordCount = WordCount();\n\tif (wordCount)\n\t\treturn (wordCount-1)*WORD_BITS + BitPrecision(reg[wordCount-1]);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  unsigned int Integer::BitCount() const\n  {\n  \tunsigned wordCount = WordCount();\n  \tif (wordCount)\n  \t\treturn (wordCount-1)*WORD_BITS + BitPrecision(reg[wordCount-1]);\n  \telse\n  \t\treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp2.SpecialOperation1",
          "args": [
            "c"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfp2.ConvertIn",
          "args": [
            "3"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertIn",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "62-63",
          "snippet": "GFP2Element ConvertIn(const GFP2Element &a) const\n\t\t{return GFP2Element(modp.ConvertIn(a.c1), modp.ConvertIn(a.c2));}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  GFP2Element ConvertIn(const GFP2Element &a) const\n  \t\t{return GFP2Element(modp.ConvertIn(a.c1), modp.ConvertIn(a.c2));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp2.PthPower",
          "args": [
            "c"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP2Element",
          "args": [
            "-3",
            "-3"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"xtr.h\"\n#include \"pch.h\"\n\nGFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}"
  },
  {
    "function_name": "XTR_FindPrimesAndGenerator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.cpp",
    "lines": "16-51",
    "snippet": "void XTR_FindPrimesAndGenerator(RandomNumberGenerator &rng, Integer &p, Integer &q, GFP2Element &g, unsigned int pbits, unsigned int qbits)\n{\n\tassert(qbits > 9);\t// no primes exist for pbits = 10, qbits = 9\n\tassert(pbits > qbits);\n\n\tconst Integer minQ = Integer::Power2(qbits - 1);\n\tconst Integer maxQ = Integer::Power2(qbits) - 1;\n\tconst Integer minP = Integer::Power2(pbits - 1);\n\tconst Integer maxP = Integer::Power2(pbits) - 1;\n\n\tInteger r1, r2;\n\tdo\n\t{\n\t\tbool qFound = q.Randomize(rng, minQ, maxQ, Integer::PRIME, 7, 12);\n\t\tassert(qFound);\n\t\tbool solutionsExist = SolveModularQuadraticEquation(r1, r2, 1, -1, 1, q);\n\t\tassert(solutionsExist);\n\t} while (!p.Randomize(rng, minP, maxP, Integer::PRIME, CRT(rng.GenerateBit()?r1:r2, q, 2, 3, EuclideanMultiplicativeInverse(p, 3)), 3*q));\n\tassert(((p.Squared() - p + 1) % q).IsZero());\n\n\tGFP2_ONB<ModularArithmetic> gfp2(p);\n\tGFP2Element three = gfp2.ConvertIn(3), t;\n\n\twhile (true)\n\t{\n\t\tg.c1.Randomize(rng, Integer::Zero(), p-1);\n\t\tg.c2.Randomize(rng, Integer::Zero(), p-1);\n\t\tt = XTR_Exponentiate(g, p+1, p);\n\t\tif (t.c1 == t.c2)\n\t\t\tcontinue;\n\t\tg = XTR_Exponentiate(g, (p.Squared()-p+1)/q, p);\n\t\tif (g != three)\n\t\t\tbreak;\n\t}\n\tassert(XTR_Exponentiate(g, q, p) == three);\n}",
    "includes": [
      "#include \"algebra.cpp\"",
      "#include \"nbtheory.h\"",
      "#include \"xtr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "XTR_Exponentiate(g, q, p) == three"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XTR_Exponentiate",
          "args": [
            "g",
            "q",
            "p"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "XTR_Exponentiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.cpp",
          "lines": "53-95",
          "snippet": "GFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"xtr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"xtr.h\"\n#include \"pch.h\"\n\nGFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p.Squared",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "g.c2.Randomize",
          "args": [
            "rng",
            "Integer::Zero()",
            "p-1"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "Randomize",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3210-3225",
          "snippet": "void Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)\n{\n\tif (min > max)\n\t\tthrow InvalidArgument(\"Integer: Min must be no greater than Max\");\n\n\tInteger range = max - min;\n\tconst unsigned int nbits = range.BitCount();\n\n\tdo\n\t{\n\t\tRandomize(rng, nbits);\n\t}\n\twhile (*this > range);\n\n\t*this += min;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)\n  {\n  \tif (min > max)\n  \t\tthrow InvalidArgument(\"Integer: Min must be no greater than Max\");\n  \n  \tInteger range = max - min;\n  \tconst unsigned int nbits = range.BitCount();\n  \n  \tdo\n  \t{\n  \t\tRandomize(rng, nbits);\n  \t}\n  \twhile (*this > range);\n  \n  \t*this += min;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Zero",
          "args": [],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "Zero",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "23-24",
          "snippet": "Element Zero() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Zero() const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfp2.ConvertIn",
          "args": [
            "3"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertIn",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "62-63",
          "snippet": "GFP2Element ConvertIn(const GFP2Element &a) const\n\t\t{return GFP2Element(modp.ConvertIn(a.c1), modp.ConvertIn(a.c2));}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  GFP2Element ConvertIn(const GFP2Element &a) const\n  \t\t{return GFP2Element(modp.ConvertIn(a.c1), modp.ConvertIn(a.c2));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "((p.Squared() - p + 1) % q).IsZero()"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRT",
          "args": [
            "rng.GenerateBit()?r1:r2",
            "q",
            "2",
            "3",
            "EuclideanMultiplicativeInverse(p, 3)"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "CRT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "553-570",
          "snippet": "Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "EuclideanMultiplicativeInverse",
          "args": [
            "p",
            "3"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "EuclideanMultiplicativeInverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "69-70",
          "snippet": "inline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)\n\t{return a.InverseMod(b);}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)\n\t{return a.InverseMod(b);}"
        }
      },
      {
        "call_info": {
          "callee": "rng.GenerateBit",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateBit",
          "container": "RandomNumberGenerator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "236-239",
          "snippet": "unsigned int RandomNumberGenerator::GenerateBit()\n{\n\treturn GenerateByte() & 1;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nRandomNumberGenerator {\n  unsigned int RandomNumberGenerator::GenerateBit()\n  {\n  \treturn GenerateByte() & 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "solutionsExist"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SolveModularQuadraticEquation",
          "args": [
            "r1",
            "r2",
            "1",
            "-1",
            "1",
            "q"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "SolveModularQuadraticEquation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "621-644",
          "snippet": "bool SolveModularQuadraticEquation(Integer &r1, Integer &r2, const Integer &a, const Integer &b, const Integer &c, const Integer &p)\n{\n\tInteger D = (b.Squared() - 4*a*c) % p;\n\tswitch (Jacobi(D, p))\n\t{\n\tdefault:\n\t\tassert(false);\t// not reached\n\t\treturn false;\n\tcase -1:\n\t\treturn false;\n\tcase 0:\n\t\tr1 = r2 = (-b*(a+a).InverseMod(p)) % p;\n\t\tassert(((r1.Squared()*a + r1*b + c) % p).IsZero());\n\t\treturn true;\n\tcase 1:\n\t\tInteger s = ModularSquareRoot(D, p);\n\t\tInteger t = (a+a).InverseMod(p);\n\t\tr1 = (s-b)*t % p;\n\t\tr2 = (-s-b)*t % p;\n\t\tassert(((r1.Squared()*a + r1*b + c) % p).IsZero());\n\t\tassert(((r2.Squared()*a + r2*b + c) % p).IsZero());\n\t\treturn true;\n\t}\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool SolveModularQuadraticEquation(Integer &r1, Integer &r2, const Integer &a, const Integer &b, const Integer &c, const Integer &p)\n{\n\tInteger D = (b.Squared() - 4*a*c) % p;\n\tswitch (Jacobi(D, p))\n\t{\n\tdefault:\n\t\tassert(false);\t// not reached\n\t\treturn false;\n\tcase -1:\n\t\treturn false;\n\tcase 0:\n\t\tr1 = r2 = (-b*(a+a).InverseMod(p)) % p;\n\t\tassert(((r1.Squared()*a + r1*b + c) % p).IsZero());\n\t\treturn true;\n\tcase 1:\n\t\tInteger s = ModularSquareRoot(D, p);\n\t\tInteger t = (a+a).InverseMod(p);\n\t\tr1 = (s-b)*t % p;\n\t\tr2 = (-s-b)*t % p;\n\t\tassert(((r1.Squared()*a + r1*b + c) % p).IsZero());\n\t\tassert(((r2.Squared()*a + r2*b + c) % p).IsZero());\n\t\treturn true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "qFound"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer::Power2",
          "args": [
            "pbits"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "Power2",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2846-2851",
          "snippet": "Integer Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  Integer Integer::Power2(size_t e)\n  {\n  \tInteger r((word)0, BitsToWords(e+1));\n  \tr.SetBit(e);\n  \treturn r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pbits > qbits"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "qbits > 9"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"xtr.h\"\n#include \"pch.h\"\n\nvoid XTR_FindPrimesAndGenerator(RandomNumberGenerator &rng, Integer &p, Integer &q, GFP2Element &g, unsigned int pbits, unsigned int qbits)\n{\n\tassert(qbits > 9);\t// no primes exist for pbits = 10, qbits = 9\n\tassert(pbits > qbits);\n\n\tconst Integer minQ = Integer::Power2(qbits - 1);\n\tconst Integer maxQ = Integer::Power2(qbits) - 1;\n\tconst Integer minP = Integer::Power2(pbits - 1);\n\tconst Integer maxP = Integer::Power2(pbits) - 1;\n\n\tInteger r1, r2;\n\tdo\n\t{\n\t\tbool qFound = q.Randomize(rng, minQ, maxQ, Integer::PRIME, 7, 12);\n\t\tassert(qFound);\n\t\tbool solutionsExist = SolveModularQuadraticEquation(r1, r2, 1, -1, 1, q);\n\t\tassert(solutionsExist);\n\t} while (!p.Randomize(rng, minP, maxP, Integer::PRIME, CRT(rng.GenerateBit()?r1:r2, q, 2, 3, EuclideanMultiplicativeInverse(p, 3)), 3*q));\n\tassert(((p.Squared() - p + 1) % q).IsZero());\n\n\tGFP2_ONB<ModularArithmetic> gfp2(p);\n\tGFP2Element three = gfp2.ConvertIn(3), t;\n\n\twhile (true)\n\t{\n\t\tg.c1.Randomize(rng, Integer::Zero(), p-1);\n\t\tg.c2.Randomize(rng, Integer::Zero(), p-1);\n\t\tt = XTR_Exponentiate(g, p+1, p);\n\t\tif (t.c1 == t.c2)\n\t\t\tcontinue;\n\t\tg = XTR_Exponentiate(g, (p.Squared()-p+1)/q, p);\n\t\tif (g != three)\n\t\t\tbreak;\n\t}\n\tassert(XTR_Exponentiate(g, q, p) == three);\n}"
  }
]