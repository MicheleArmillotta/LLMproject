[
  {
    "function_name": "TF_EncryptorBase::Encrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "148-161",
    "snippet": "void TF_EncryptorBase::Encrypt(RandomNumberGenerator &rng, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &parameters) const\n{\n\tif (plaintextLength > FixedMaxPlaintextLength())\n\t{\n\t\tif (FixedMaxPlaintextLength() < 1)\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": this key is too short to encrypt any messages\");\n\t\telse\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": message length of \" + IntToString(plaintextLength) + \" exceeds the maximum of \" + IntToString(FixedMaxPlaintextLength()) + \" for this public key\");\n\t}\n\n\tSecByteBlock paddedBlock(PaddedBlockByteLength());\n\tGetMessageEncodingInterface().Pad(rng, plaintext, plaintextLength, paddedBlock, PaddedBlockBitLength(), parameters);\n\tGetTrapdoorFunctionInterface().ApplyRandomizedFunction(rng, Integer(paddedBlock, paddedBlock.size())).Encode(ciphertext, FixedCiphertextLength());\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "ciphertext",
            "FixedCiphertextLength()"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FixedCiphertextLength",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "FixedCiphertextLength",
          "container": "ElGamalObjectImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/elgamal.h",
          "lines": "82-82",
          "snippet": "size_t FixedCiphertextLength() const {return this->CiphertextLength(0);}",
          "includes": [
            "#include \"dsa.h\"",
            "#include \"modexppc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dsa.h\"\n#include \"modexppc.h\"\n\nElGamalObjectImpl {\n  size_t FixedCiphertextLength() const {return this->CiphertextLength(0);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "rng",
            "Integer(paddedBlock, paddedBlock.size())"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "paddedBlock",
            "paddedBlock.size()"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2960-2965",
          "snippet": "Integer::Integer(word value, size_t length)\n\t: reg(RoundupSize(length)), sign(POSITIVE)\n{\n\treg[0] = value;\n\tSetWords(reg+1, 0, reg.size()-1);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger::Integer(word value, size_t length)\n\t: reg(RoundupSize(length)), sign(POSITIVE)\n{\n\treg[0] = value;\n\tSetWords(reg+1, 0, reg.size()-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "paddedBlock.size",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [
            "rng",
            "plaintext",
            "plaintextLength",
            "paddedBlock",
            "PaddedBlockBitLength()",
            "parameters"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PaddedBlockBitLength",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": message length of \" + IntToString(plaintextLength) + \" exceeds the maximum of \" + IntToString(FixedMaxPlaintextLength()) + \" for this public key\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "FixedMaxPlaintextLength()"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FixedMaxPlaintextLength",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "FixedMaxPlaintextLength",
          "container": "ElGamalObjectImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/elgamal.h",
          "lines": "81-81",
          "snippet": "size_t FixedMaxPlaintextLength() const {return this->MaxPlaintextLength(FixedCiphertextLength());}",
          "includes": [
            "#include \"dsa.h\"",
            "#include \"modexppc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dsa.h\"\n#include \"modexppc.h\"\n\nElGamalObjectImpl {\n  size_t FixedMaxPlaintextLength() const {return this->MaxPlaintextLength(FixedCiphertextLength());}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "DL_SS",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "1655-1655",
          "snippet": "static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string(\"/EMSA1(\") + H::StaticAlgorithmName() + \")\";}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nDL_SS {\n  static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string(\"/EMSA1(\") + H::StaticAlgorithmName() + \")\";}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": this key is too short to encrypt any messages\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nvoid TF_EncryptorBase::Encrypt(RandomNumberGenerator &rng, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &parameters) const\n{\n\tif (plaintextLength > FixedMaxPlaintextLength())\n\t{\n\t\tif (FixedMaxPlaintextLength() < 1)\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": this key is too short to encrypt any messages\");\n\t\telse\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": message length of \" + IntToString(plaintextLength) + \" exceeds the maximum of \" + IntToString(FixedMaxPlaintextLength()) + \" for this public key\");\n\t}\n\n\tSecByteBlock paddedBlock(PaddedBlockByteLength());\n\tGetMessageEncodingInterface().Pad(rng, plaintext, plaintextLength, paddedBlock, PaddedBlockBitLength(), parameters);\n\tGetTrapdoorFunctionInterface().ApplyRandomizedFunction(rng, Integer(paddedBlock, paddedBlock.size())).Encode(ciphertext, FixedCiphertextLength());\n}"
  },
  {
    "function_name": "TF_DecryptorBase::Decrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "135-146",
    "snippet": "DecodingResult TF_DecryptorBase::Decrypt(RandomNumberGenerator &rng, const byte *ciphertext, size_t ciphertextLength, byte *plaintext, const NameValuePairs &parameters) const\n{\n\tif (ciphertextLength != FixedCiphertextLength())\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": ciphertext length of \" + IntToString(ciphertextLength) + \" doesn't match the required length of \" + IntToString(FixedCiphertextLength()) + \" for this key\");\n\n\tSecByteBlock paddedBlock(PaddedBlockByteLength());\n\tInteger x = GetTrapdoorFunctionInterface().CalculateInverse(rng, Integer(ciphertext, ciphertextLength));\n\tif (x.ByteCount() > paddedBlock.size())\n\t\tx = Integer::Zero();\t// don't return false here to prevent timing attack\n\tx.Encode(paddedBlock, paddedBlock.size());\n\treturn GetMessageEncodingInterface().Unpad(paddedBlock, PaddedBlockBitLength(), plaintext, parameters);\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [
            "paddedBlock",
            "PaddedBlockBitLength()",
            "plaintext",
            "parameters"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PaddedBlockBitLength",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x.Encode",
          "args": [
            "paddedBlock",
            "paddedBlock.size()"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "paddedBlock.size",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Zero",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "Zero",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "23-24",
          "snippet": "Element Zero() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Zero() const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x.ByteCount",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "rng",
            "Integer(ciphertext, ciphertextLength)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "ciphertext",
            "ciphertextLength"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2960-2965",
          "snippet": "Integer::Integer(word value, size_t length)\n\t: reg(RoundupSize(length)), sign(POSITIVE)\n{\n\treg[0] = value;\n\tSetWords(reg+1, 0, reg.size()-1);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger::Integer(word value, size_t length)\n\t: reg(RoundupSize(length)), sign(POSITIVE)\n{\n\treg[0] = value;\n\tSetWords(reg+1, 0, reg.size()-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": ciphertext length of \" + IntToString(ciphertextLength) + \" doesn't match the required length of \" + IntToString(FixedCiphertextLength()) + \" for this key\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "FixedCiphertextLength()"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FixedCiphertextLength",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "FixedCiphertextLength",
          "container": "ElGamalObjectImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/elgamal.h",
          "lines": "82-82",
          "snippet": "size_t FixedCiphertextLength() const {return this->CiphertextLength(0);}",
          "includes": [
            "#include \"dsa.h\"",
            "#include \"modexppc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dsa.h\"\n#include \"modexppc.h\"\n\nElGamalObjectImpl {\n  size_t FixedCiphertextLength() const {return this->CiphertextLength(0);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "DL_SS",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "1655-1655",
          "snippet": "static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string(\"/EMSA1(\") + H::StaticAlgorithmName() + \")\";}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nDL_SS {\n  static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string(\"/EMSA1(\") + H::StaticAlgorithmName() + \")\";}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nDecodingResult TF_DecryptorBase::Decrypt(RandomNumberGenerator &rng, const byte *ciphertext, size_t ciphertextLength, byte *plaintext, const NameValuePairs &parameters) const\n{\n\tif (ciphertextLength != FixedCiphertextLength())\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": ciphertext length of \" + IntToString(ciphertextLength) + \" doesn't match the required length of \" + IntToString(FixedCiphertextLength()) + \" for this key\");\n\n\tSecByteBlock paddedBlock(PaddedBlockByteLength());\n\tInteger x = GetTrapdoorFunctionInterface().CalculateInverse(rng, Integer(ciphertext, ciphertextLength));\n\tif (x.ByteCount() > paddedBlock.size())\n\t\tx = Integer::Zero();\t// don't return false here to prevent timing attack\n\tx.Encode(paddedBlock, paddedBlock.size());\n\treturn GetMessageEncodingInterface().Unpad(paddedBlock, PaddedBlockBitLength(), plaintext, parameters);\n}"
  },
  {
    "function_name": "TF_VerifierBase::RecoverAndRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "120-133",
    "snippet": "DecodingResult TF_VerifierBase::RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tDecodingResult result = encoding.RecoverMessageFromRepresentative(\n\t\tma.AccessHash(), id, ma.m_empty, ma.m_representative, MessageRepresentativeBitLength(), recoveredMessage);\n\tma.m_empty = true;\n\treturn result;\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encoding.RecoverMessageFromRepresentative",
          "args": [
            "ma.AccessHash()",
            "id",
            "ma.m_empty",
            "ma.m_representative",
            "MessageRepresentativeBitLength()",
            "recoveredMessage"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nDecodingResult TF_VerifierBase::RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tDecodingResult result = encoding.RecoverMessageFromRepresentative(\n\t\tma.AccessHash(), id, ma.m_empty, ma.m_representative, MessageRepresentativeBitLength(), recoveredMessage);\n\tma.m_empty = true;\n\treturn result;\n}"
  },
  {
    "function_name": "TF_VerifierBase::VerifyAndRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "105-118",
    "snippet": "bool TF_VerifierBase::VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tbool result = encoding.VerifyMessageRepresentative(\n\t\tma.AccessHash(), id, ma.m_empty, ma.m_representative, MessageRepresentativeBitLength());\n\tma.m_empty = true;\n\treturn result;\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encoding.VerifyMessageRepresentative",
          "args": [
            "ma.AccessHash()",
            "id",
            "ma.m_empty",
            "ma.m_representative",
            "MessageRepresentativeBitLength()"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nbool TF_VerifierBase::VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tbool result = encoding.VerifyMessageRepresentative(\n\t\tma.AccessHash(), id, ma.m_empty, ma.m_representative, MessageRepresentativeBitLength());\n\tma.m_empty = true;\n\treturn result;\n}"
  },
  {
    "function_name": "TF_VerifierBase::InputSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "89-103",
    "snippet": "void TF_VerifierBase::InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tma.m_representative.New(MessageRepresentativeLength());\n\tInteger x = GetTrapdoorFunctionInterface().ApplyFunction(Integer(signature, signatureLength));\n\tif (x.BitCount() > MessageRepresentativeBitLength())\n\t\tx = Integer::Zero();\t// don't return false here to prevent timing attack\n\tx.Encode(ma.m_representative, ma.m_representative.size());\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x.Encode",
          "args": [
            "ma.m_representative",
            "ma.m_representative.size()"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ma.m_representative.size",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Zero",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "Zero",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "23-24",
          "snippet": "Element Zero() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Zero() const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x.BitCount",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "Integer(signature, signatureLength)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "signature",
            "signatureLength"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2960-2965",
          "snippet": "Integer::Integer(word value, size_t length)\n\t: reg(RoundupSize(length)), sign(POSITIVE)\n{\n\treg[0] = value;\n\tSetWords(reg+1, 0, reg.size()-1);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger::Integer(word value, size_t length)\n\t: reg(RoundupSize(length)), sign(POSITIVE)\n{\n\treg[0] = value;\n\tSetWords(reg+1, 0, reg.size()-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.m_representative.New",
          "args": [
            "MessageRepresentativeLength()"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeLength",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nvoid TF_VerifierBase::InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tma.m_representative.New(MessageRepresentativeLength());\n\tInteger x = GetTrapdoorFunctionInterface().ApplyFunction(Integer(signature, signatureLength));\n\tif (x.BitCount() > MessageRepresentativeBitLength())\n\t\tx = Integer::Zero();\t// don't return false here to prevent timing attack\n\tx.Encode(ma.m_representative, ma.m_representative.size());\n}"
  },
  {
    "function_name": "TF_SignerBase::SignAndRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "67-87",
    "snippet": "size_t TF_SignerBase::SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tSecByteBlock representative(MessageRepresentativeLength());\n\tencoding.ComputeMessageRepresentative(rng, \n\t\tma.m_recoverableMessage, ma.m_recoverableMessage.size(), \n\t\tma.AccessHash(), id, ma.m_empty,\n\t\trepresentative, MessageRepresentativeBitLength());\n\tma.m_empty = true;\n\n\tInteger r(representative, representative.size());\n\tsize_t signatureLength = SignatureLength();\n\tGetTrapdoorFunctionInterface().CalculateRandomizedInverse(rng, r).Encode(signature, signatureLength);\n\treturn signatureLength;\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "signature",
            "signatureLength"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "rng",
            "r"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignatureLength",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "representative.size",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "encoding.ComputeMessageRepresentative",
          "args": [
            "rng",
            "ma.m_recoverableMessage",
            "ma.m_recoverableMessage.size()",
            "ma.AccessHash()",
            "id",
            "ma.m_empty",
            "representative",
            "MessageRepresentativeBitLength()"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeMessageRepresentative",
          "container": "EMSA5Pad",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/esign.h",
          "lines": "92-104",
          "snippet": "void ComputeMessageRepresentative(RandomNumberGenerator &rng, \n\t\tconst byte *recoverableMessage, size_t recoverableMessageLength,\n\t\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\t\tbyte *representative, size_t representativeBitLength) const\n\t{\n\t\tSecByteBlock digest(hash.DigestSize());\n\t\thash.Final(digest);\n\t\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n\t\tT mgf;\n\t\tmgf.GenerateAndMask(hash, representative, representativeByteLength, digest, digest.size(), false);\n\t\tif (representativeBitLength % 8 != 0)\n\t\t\trepresentative[0] = (byte)Crop(representative[0], representativeBitLength % 8);\n\t}",
          "includes": [
            "#include \"asn.h\"",
            "#include \"integer.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"asn.h\"\n#include \"integer.h\"\n#include \"pubkey.h\"\n\nEMSA5Pad {\n  void ComputeMessageRepresentative(RandomNumberGenerator &rng, \n  \t\tconst byte *recoverableMessage, size_t recoverableMessageLength,\n  \t\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \t\tbyte *representative, size_t representativeBitLength) const\n  \t{\n  \t\tSecByteBlock digest(hash.DigestSize());\n  \t\thash.Final(digest);\n  \t\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n  \t\tT mgf;\n  \t\tmgf.GenerateAndMask(hash, representative, representativeByteLength, digest, digest.size(), false);\n  \t\tif (representativeBitLength % 8 != 0)\n  \t\t\trepresentative[0] = (byte)Crop(representative[0], representativeBitLength % 8);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nsize_t TF_SignerBase::SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tSecByteBlock representative(MessageRepresentativeLength());\n\tencoding.ComputeMessageRepresentative(rng, \n\t\tma.m_recoverableMessage, ma.m_recoverableMessage.size(), \n\t\tma.AccessHash(), id, ma.m_empty,\n\t\trepresentative, MessageRepresentativeBitLength());\n\tma.m_empty = true;\n\n\tInteger r(representative, representative.size());\n\tsize_t signatureLength = SignatureLength();\n\tGetTrapdoorFunctionInterface().CalculateRandomizedInverse(rng, r).Encode(signature, signatureLength);\n\treturn signatureLength;\n}"
  },
  {
    "function_name": "TF_SignerBase::InputRecoverableMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "44-65",
    "snippet": "void TF_SignerBase::InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tsize_t maxRecoverableLength = encoding.MaxRecoverableLength(MessageRepresentativeBitLength(), GetHashIdentifier().second, ma.AccessHash().DigestSize());\n\n\tif (maxRecoverableLength == 0)\n\t\t{throw NotImplemented(\"TF_SignerBase: this algorithm does not support messsage recovery or the key is too short\");}\n\tif (recoverableMessageLength > maxRecoverableLength)\n\t\tthrow InvalidArgument(\"TF_SignerBase: the recoverable message part is too long for the given key and algorithm\");\n\n\tma.m_recoverableMessage.Assign(recoverableMessage, recoverableMessageLength);\n\tencoding.ProcessRecoverableMessage(\n\t\tma.AccessHash(), \n\t\trecoverableMessage, recoverableMessageLength,\n\t\tNULL, 0, ma.m_semisignature);\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encoding.ProcessRecoverableMessage",
          "args": [
            "ma.AccessHash()",
            "recoverableMessage",
            "recoverableMessageLength",
            "NULL",
            "0",
            "ma.m_semisignature"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.m_recoverableMessage.Assign",
          "args": [
            "recoverableMessage",
            "recoverableMessageLength"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "Assign",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "310-314",
          "snippet": "void Assign(const T *t, size_type len)\n\t{\n\t\tNew(len);\n\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Assign(const T *t, size_type len)\n  \t{\n  \t\tNew(len);\n  \t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"TF_SignerBase: the recoverable message part is too long for the given key and algorithm\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NotImplemented",
          "args": [
            "\"TF_SignerBase: this algorithm does not support messsage recovery or the key is too short\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MaxRecoverableLength",
          "args": [
            "MessageRepresentativeBitLength()",
            "GetHashIdentifier().second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nvoid TF_SignerBase::InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tsize_t maxRecoverableLength = encoding.MaxRecoverableLength(MessageRepresentativeBitLength(), GetHashIdentifier().second, ma.AccessHash().DigestSize());\n\n\tif (maxRecoverableLength == 0)\n\t\t{throw NotImplemented(\"TF_SignerBase: this algorithm does not support messsage recovery or the key is too short\");}\n\tif (recoverableMessageLength > maxRecoverableLength)\n\t\tthrow InvalidArgument(\"TF_SignerBase: the recoverable message part is too long for the given key and algorithm\");\n\n\tma.m_recoverableMessage.Assign(recoverableMessage, recoverableMessageLength);\n\tencoding.ProcessRecoverableMessage(\n\t\tma.AccessHash(), \n\t\trecoverableMessage, recoverableMessageLength,\n\t\tNULL, 0, ma.m_semisignature);\n}"
  },
  {
    "function_name": "PK_RecoverableSignatureMessageEncodingMethod::VerifyMessageRepresentative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "34-42",
    "snippet": "bool PK_RecoverableSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tSecByteBlock recoveredMessage(MaxRecoverableLength(representativeBitLength, hashIdentifier.second, hash.DigestSize()));\n\tDecodingResult result = RecoverMessageFromRepresentative(\n\t\thash, hashIdentifier, messageEmpty, representative, representativeBitLength, recoveredMessage);\n\treturn result.isValidCoding && result.messageLength == 0;\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RecoverMessageFromRepresentative",
          "args": [
            "hash",
            "hashIdentifier",
            "messageEmpty",
            "representative",
            "representativeBitLength",
            "recoveredMessage"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxRecoverableLength",
          "args": [
            "representativeBitLength",
            "hashIdentifier.second",
            "hash.DigestSize()"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "PSSR_MEM_Base::MaxRecoverableLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pssr.cpp",
          "lines": "23-28",
          "snippet": "size_t PSSR_MEM_Base::MaxRecoverableLength(size_t representativeBitLength, size_t hashIdentifierLength, size_t digestLength) const\n{\n\tif (AllowRecovery())\n\t\treturn SaturatingSubtract(representativeBitLength, MinRepresentativeBitLength(hashIdentifierLength, digestLength)) / 8;\n\treturn 0;\n}",
          "includes": [
            "#include <functional>",
            "#include \"pssr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include \"pssr.h\"\n#include \"pch.h\"\n\nsize_t PSSR_MEM_Base::MaxRecoverableLength(size_t representativeBitLength, size_t hashIdentifierLength, size_t digestLength) const\n{\n\tif (AllowRecovery())\n\t\treturn SaturatingSubtract(representativeBitLength, MinRepresentativeBitLength(hashIdentifierLength, digestLength)) / 8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.DigestSize",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nbool PK_RecoverableSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tSecByteBlock recoveredMessage(MaxRecoverableLength(representativeBitLength, hashIdentifier.second, hash.DigestSize()));\n\tDecodingResult result = RecoverMessageFromRepresentative(\n\t\thash, hashIdentifier, messageEmpty, representative, representativeBitLength, recoveredMessage);\n\treturn result.isValidCoding && result.messageLength == 0;\n}"
  },
  {
    "function_name": "PK_DeterministicSignatureMessageEncodingMethod::VerifyMessageRepresentative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "25-32",
    "snippet": "bool PK_DeterministicSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tSecByteBlock computedRepresentative(BitsToBytes(representativeBitLength));\n\tComputeMessageRepresentative(NullRNG(), NULL, 0, hash, hashIdentifier, messageEmpty, computedRepresentative, representativeBitLength);\n\treturn VerifyBufsEqual(representative, computedRepresentative, computedRepresentative.size());\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyBufsEqual",
          "args": [
            "representative",
            "computedRepresentative",
            "computedRepresentative.size()"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyBufsEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "79-113",
          "snippet": "bool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nbool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "computedRepresentative.size",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeMessageRepresentative",
          "args": [
            "NullRNG()",
            "NULL",
            "0",
            "hash",
            "hashIdentifier",
            "messageEmpty",
            "computedRepresentative",
            "representativeBitLength"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "EMSA2Pad::ComputeMessageRepresentative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.cpp",
          "lines": "10-30",
          "snippet": "void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n\tconst byte *recoverableMessage, size_t recoverableMessageLength,\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tif (representativeBitLength % 8 != 7)\n\t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n\n\tsize_t digestSize = hash.DigestSize();\n\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n\n\trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n\tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n\tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n\tafterP2[0] = 0xba;\n\thash.Final(afterP2+1);\n\trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n\trepresentative[representativeByteLength-1] = 0xcc;\n}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"pch.h\"\n\nvoid EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n\tconst byte *recoverableMessage, size_t recoverableMessageLength,\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tif (representativeBitLength % 8 != 7)\n\t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n\n\tsize_t digestSize = hash.DigestSize();\n\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n\n\trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n\tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n\tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n\tafterP2[0] = 0xba;\n\thash.Final(afterP2+1);\n\trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n\trepresentative[representativeByteLength-1] = 0xcc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NullRNG",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "AlgorithmName",
          "container": "ClassNullRNG",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "291-291",
          "snippet": "std::string AlgorithmName() const {return \"NullRNG\";}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nClassNullRNG {\n  std::string AlgorithmName() const {return \"NullRNG\";}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nbool PK_DeterministicSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tSecByteBlock computedRepresentative(BitsToBytes(representativeBitLength));\n\tComputeMessageRepresentative(NullRNG(), NULL, 0, hash, hashIdentifier, messageEmpty, computedRepresentative, representativeBitLength);\n\treturn VerifyBufsEqual(representative, computedRepresentative, computedRepresentative.size());\n}"
  },
  {
    "function_name": "P1363_MGF1KDF2_Common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "11-23",
    "snippet": "void P1363_MGF1KDF2_Common(HashTransformation &hash, byte *output, size_t outputLength, const byte *input, size_t inputLength, const byte *derivationParams, size_t derivationParamsLength, bool mask, unsigned int counterStart)\n{\n\tArraySink *sink;\n\tHashFilter filter(hash, sink = mask ? new ArrayXorSink(output, outputLength) : new ArraySink(output, outputLength));\n\tword32 counter = counterStart;\n\twhile (sink->AvailableSize() > 0)\n\t{\n\t\tfilter.Put(input, inputLength);\n\t\tfilter.PutWord32(counter++);\n\t\tfilter.Put(derivationParams, derivationParamsLength);\n\t\tfilter.MessageEnd();\n\t}\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filter.MessageEnd",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "807-808",
          "snippet": "bool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nbool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "filter.Put",
          "args": [
            "derivationParams",
            "derivationParamsLength"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "42-49",
          "snippet": "inline size_t Put(const byte *begin, size_t length)\n\t{\n\t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n\t\tif (buf+m_tail != begin)\n\t\t\tmemcpy(buf+m_tail, begin, l);\n\t\tm_tail += l;\n\t\treturn l;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t Put(const byte *begin, size_t length)\n  \t{\n  \t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n  \t\tif (buf+m_tail != begin)\n  \t\t\tmemcpy(buf+m_tail, begin, l);\n  \t\tm_tail += l;\n  \t\treturn l;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter.PutWord32",
          "args": [
            "counter++"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sink->AvailableSize",
          "args": [],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nvoid P1363_MGF1KDF2_Common(HashTransformation &hash, byte *output, size_t outputLength, const byte *input, size_t inputLength, const byte *derivationParams, size_t derivationParamsLength, bool mask, unsigned int counterStart)\n{\n\tArraySink *sink;\n\tHashFilter filter(hash, sink = mask ? new ArrayXorSink(output, outputLength) : new ArraySink(output, outputLength));\n\tword32 counter = counterStart;\n\twhile (sink->AvailableSize() > 0)\n\t{\n\t\tfilter.Put(input, inputLength);\n\t\tfilter.PutWord32(counter++);\n\t\tfilter.Put(derivationParams, derivationParamsLength);\n\t\tfilter.MessageEnd();\n\t}\n}"
  }
]