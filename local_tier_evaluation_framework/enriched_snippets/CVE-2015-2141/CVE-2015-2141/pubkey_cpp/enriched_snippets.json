[
  {
    "function_name": "Encrypt",
    "container": "TF_EncryptorBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "148-161",
    "snippet": "void TF_EncryptorBase::Encrypt(RandomNumberGenerator &rng, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &parameters) const\n{\n\tif (plaintextLength > FixedMaxPlaintextLength())\n\t{\n\t\tif (FixedMaxPlaintextLength() < 1)\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": this key is too short to encrypt any messages\");\n\t\telse\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": message length of \" + IntToString(plaintextLength) + \" exceeds the maximum of \" + IntToString(FixedMaxPlaintextLength()) + \" for this public key\");\n\t}\n\n\tSecByteBlock paddedBlock(PaddedBlockByteLength());\n\tGetMessageEncodingInterface().Pad(rng, plaintext, plaintextLength, paddedBlock, PaddedBlockBitLength(), parameters);\n\tGetTrapdoorFunctionInterface().ApplyRandomizedFunction(rng, Integer(paddedBlock, paddedBlock.size())).Encode(ciphertext, FixedCiphertextLength());\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "ciphertext",
            "FixedCiphertextLength()"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FixedCiphertextLength",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "FixedCiphertextLength",
          "container": "ElGamalObjectImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/elgamal.h",
          "lines": "82-82",
          "snippet": "size_t FixedCiphertextLength() const {return this->CiphertextLength(0);}",
          "includes": [
            "#include \"dsa.h\"",
            "#include \"modexppc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dsa.h\"\n#include \"modexppc.h\"\n\nElGamalObjectImpl {\n  size_t FixedCiphertextLength() const {return this->CiphertextLength(0);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "rng",
            "Integer(paddedBlock, paddedBlock.size())"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "paddedBlock",
            "paddedBlock.size()"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "Gcd",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3953-3956",
          "snippet": "Integer Integer::Gcd(const Integer &a, const Integer &b)\n{\n\treturn EuclideanDomainOf<Integer>().Gcd(a, b);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  Integer Integer::Gcd(const Integer &a, const Integer &b)\n  {\n  \treturn EuclideanDomainOf<Integer>().Gcd(a, b);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "paddedBlock.size",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [
            "rng",
            "plaintext",
            "plaintextLength",
            "paddedBlock",
            "PaddedBlockBitLength()",
            "parameters"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PaddedBlockBitLength",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": message length of \" + IntToString(plaintextLength) + \" exceeds the maximum of \" + IntToString(FixedMaxPlaintextLength()) + \" for this public key\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "FixedMaxPlaintextLength()"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FixedMaxPlaintextLength",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "FixedMaxPlaintextLength",
          "container": "ElGamalObjectImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/elgamal.h",
          "lines": "81-81",
          "snippet": "size_t FixedMaxPlaintextLength() const {return this->MaxPlaintextLength(FixedCiphertextLength());}",
          "includes": [
            "#include \"dsa.h\"",
            "#include \"modexppc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dsa.h\"\n#include \"modexppc.h\"\n\nElGamalObjectImpl {\n  size_t FixedMaxPlaintextLength() const {return this->MaxPlaintextLength(FixedCiphertextLength());}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "DL_SS",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "1655-1655",
          "snippet": "static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string(\"/EMSA1(\") + H::StaticAlgorithmName() + \")\";}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nDL_SS {\n  static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string(\"/EMSA1(\") + H::StaticAlgorithmName() + \")\";}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": this key is too short to encrypt any messages\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nTF_EncryptorBase {\n  void TF_EncryptorBase::Encrypt(RandomNumberGenerator &rng, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &parameters) const\n  {\n  \tif (plaintextLength > FixedMaxPlaintextLength())\n  \t{\n  \t\tif (FixedMaxPlaintextLength() < 1)\n  \t\t\tthrow InvalidArgument(AlgorithmName() + \": this key is too short to encrypt any messages\");\n  \t\telse\n  \t\t\tthrow InvalidArgument(AlgorithmName() + \": message length of \" + IntToString(plaintextLength) + \" exceeds the maximum of \" + IntToString(FixedMaxPlaintextLength()) + \" for this public key\");\n  \t}\n  \n  \tSecByteBlock paddedBlock(PaddedBlockByteLength());\n  \tGetMessageEncodingInterface().Pad(rng, plaintext, plaintextLength, paddedBlock, PaddedBlockBitLength(), parameters);\n  \tGetTrapdoorFunctionInterface().ApplyRandomizedFunction(rng, Integer(paddedBlock, paddedBlock.size())).Encode(ciphertext, FixedCiphertextLength());\n  }\n}"
  },
  {
    "function_name": "Decrypt",
    "container": "TF_DecryptorBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "135-146",
    "snippet": "DecodingResult TF_DecryptorBase::Decrypt(RandomNumberGenerator &rng, const byte *ciphertext, size_t ciphertextLength, byte *plaintext, const NameValuePairs &parameters) const\n{\n\tif (ciphertextLength != FixedCiphertextLength())\n\t\t\tthrow InvalidArgument(AlgorithmName() + \": ciphertext length of \" + IntToString(ciphertextLength) + \" doesn't match the required length of \" + IntToString(FixedCiphertextLength()) + \" for this key\");\n\n\tSecByteBlock paddedBlock(PaddedBlockByteLength());\n\tInteger x = GetTrapdoorFunctionInterface().CalculateInverse(rng, Integer(ciphertext, ciphertextLength));\n\tif (x.ByteCount() > paddedBlock.size())\n\t\tx = Integer::Zero();\t// don't return false here to prevent timing attack\n\tx.Encode(paddedBlock, paddedBlock.size());\n\treturn GetMessageEncodingInterface().Unpad(paddedBlock, PaddedBlockBitLength(), plaintext, parameters);\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [
            "paddedBlock",
            "PaddedBlockBitLength()",
            "plaintext",
            "parameters"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PaddedBlockBitLength",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x.Encode",
          "args": [
            "paddedBlock",
            "paddedBlock.size()"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "paddedBlock.size",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Zero",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "Zero",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "23-24",
          "snippet": "Element Zero() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Zero() const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x.ByteCount",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ByteCount",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3045-3052",
          "snippet": "unsigned int Integer::ByteCount() const\n{\n\tunsigned wordCount = WordCount();\n\tif (wordCount)\n\t\treturn (wordCount-1)*WORD_SIZE + BytePrecision(reg[wordCount-1]);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  unsigned int Integer::ByteCount() const\n  {\n  \tunsigned wordCount = WordCount();\n  \tif (wordCount)\n  \t\treturn (wordCount-1)*WORD_SIZE + BytePrecision(reg[wordCount-1]);\n  \telse\n  \t\treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "rng",
            "Integer(ciphertext, ciphertextLength)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "ciphertext",
            "ciphertextLength"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "Gcd",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3953-3956",
          "snippet": "Integer Integer::Gcd(const Integer &a, const Integer &b)\n{\n\treturn EuclideanDomainOf<Integer>().Gcd(a, b);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  Integer Integer::Gcd(const Integer &a, const Integer &b)\n  {\n  \treturn EuclideanDomainOf<Integer>().Gcd(a, b);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "AlgorithmName() + \": ciphertext length of \" + IntToString(ciphertextLength) + \" doesn't match the required length of \" + IntToString(FixedCiphertextLength()) + \" for this key\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "FixedCiphertextLength()"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FixedCiphertextLength",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "FixedCiphertextLength",
          "container": "ElGamalObjectImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/elgamal.h",
          "lines": "82-82",
          "snippet": "size_t FixedCiphertextLength() const {return this->CiphertextLength(0);}",
          "includes": [
            "#include \"dsa.h\"",
            "#include \"modexppc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dsa.h\"\n#include \"modexppc.h\"\n\nElGamalObjectImpl {\n  size_t FixedCiphertextLength() const {return this->CiphertextLength(0);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AlgorithmName",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "StaticAlgorithmName",
          "container": "DL_SS",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "1655-1655",
          "snippet": "static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string(\"/EMSA1(\") + H::StaticAlgorithmName() + \")\";}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nDL_SS {\n  static std::string StaticAlgorithmName() {return SA::StaticAlgorithmName() + std::string(\"/EMSA1(\") + H::StaticAlgorithmName() + \")\";}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nTF_DecryptorBase {\n  DecodingResult TF_DecryptorBase::Decrypt(RandomNumberGenerator &rng, const byte *ciphertext, size_t ciphertextLength, byte *plaintext, const NameValuePairs &parameters) const\n  {\n  \tif (ciphertextLength != FixedCiphertextLength())\n  \t\t\tthrow InvalidArgument(AlgorithmName() + \": ciphertext length of \" + IntToString(ciphertextLength) + \" doesn't match the required length of \" + IntToString(FixedCiphertextLength()) + \" for this key\");\n  \n  \tSecByteBlock paddedBlock(PaddedBlockByteLength());\n  \tInteger x = GetTrapdoorFunctionInterface().CalculateInverse(rng, Integer(ciphertext, ciphertextLength));\n  \tif (x.ByteCount() > paddedBlock.size())\n  \t\tx = Integer::Zero();\t// don't return false here to prevent timing attack\n  \tx.Encode(paddedBlock, paddedBlock.size());\n  \treturn GetMessageEncodingInterface().Unpad(paddedBlock, PaddedBlockBitLength(), plaintext, parameters);\n  }\n}"
  },
  {
    "function_name": "RecoverAndRestart",
    "container": "TF_VerifierBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "120-133",
    "snippet": "DecodingResult TF_VerifierBase::RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tDecodingResult result = encoding.RecoverMessageFromRepresentative(\n\t\tma.AccessHash(), id, ma.m_empty, ma.m_representative, MessageRepresentativeBitLength(), recoveredMessage);\n\tma.m_empty = true;\n\treturn result;\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encoding.RecoverMessageFromRepresentative",
          "args": [
            "ma.AccessHash()",
            "id",
            "ma.m_empty",
            "ma.m_representative",
            "MessageRepresentativeBitLength()",
            "recoveredMessage"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "RecoverMessageFromRepresentative",
          "container": "PSSR_MEM_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pssr.cpp",
          "lines": "84-141",
          "snippet": "DecodingResult PSSR_MEM_Base::RecoverMessageFromRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength,\n\tbyte *recoverableMessage) const\n{\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tconst size_t u = hashIdentifier.second + 1;\n\tconst size_t representativeByteLength = BitsToBytes(representativeBitLength);\n\tconst size_t digestSize = hash.DigestSize();\n\tconst size_t saltSize = SaltLen(digestSize);\n\tconst byte *const h = representative + representativeByteLength - u - digestSize;\n\n\tSecByteBlock digest(digestSize);\n\thash.Final(digest);\n\n\tDecodingResult result(0);\n\tbool &valid = result.isValidCoding;\n\tsize_t &recoverableMessageLength = result.messageLength;\n\n\tvalid = (representative[representativeByteLength - 1] == (hashIdentifier.second ? 0xcc : 0xbc)) && valid;\n\tvalid = VerifyBufsEqual(representative + representativeByteLength - u, hashIdentifier.first, hashIdentifier.second) && valid;\n\n\tGetMGF().GenerateAndMask(hash, representative, representativeByteLength - u - digestSize, h, digestSize);\n\tif (representativeBitLength % 8 != 0)\n\t\trepresentative[0] = (byte)Crop(representative[0], representativeBitLength % 8);\n\n\t// extract salt and recoverableMessage from DB = 00 ... || 01 || M || salt\n\tbyte *salt = representative + representativeByteLength - u - digestSize - saltSize;\n\tbyte *M = std::find_if(representative, salt-1, std::bind2nd(std::not_equal_to<byte>(), 0));\n\trecoverableMessageLength = salt-M-1;\n\tif (*M == 0x01 \n\t\t&& (size_t)(M - representative - (representativeBitLength % 8 != 0)) >= MinPadLen(digestSize)\n\t\t&& recoverableMessageLength <= MaxRecoverableLength(representativeBitLength, hashIdentifier.second, digestSize))\n\t{\n\t\tmemcpy(recoverableMessage, M+1, recoverableMessageLength);\n\t}\n\telse\n\t{\n\t\trecoverableMessageLength = 0;\n\t\tvalid = false;\n\t}\n\n\t// verify H = hash of M'\n\tbyte c[8];\n\tPutWord(false, BIG_ENDIAN_ORDER, c, (word32)SafeRightShift<29>(recoverableMessageLength));\n\tPutWord(false, BIG_ENDIAN_ORDER, c+4, word32(recoverableMessageLength << 3));\n\thash.Update(c, 8);\n\thash.Update(recoverableMessage, recoverableMessageLength);\n\thash.Update(digest, digestSize);\n\thash.Update(salt, saltSize);\n\tvalid = hash.Verify(h) && valid;\n\n\tif (!AllowRecovery() && valid && recoverableMessageLength != 0)\n\t\t{throw NotImplemented(\"PSSR_MEM: message recovery disabled\");}\n\t\n\treturn result;\n}",
          "includes": [
            "#include <functional>",
            "#include \"pssr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include \"pssr.h\"\n#include \"pch.h\"\n\nPSSR_MEM_Base {\n  DecodingResult PSSR_MEM_Base::RecoverMessageFromRepresentative(\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength,\n  \tbyte *recoverableMessage) const\n  {\n  \tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n  \n  \tconst size_t u = hashIdentifier.second + 1;\n  \tconst size_t representativeByteLength = BitsToBytes(representativeBitLength);\n  \tconst size_t digestSize = hash.DigestSize();\n  \tconst size_t saltSize = SaltLen(digestSize);\n  \tconst byte *const h = representative + representativeByteLength - u - digestSize;\n  \n  \tSecByteBlock digest(digestSize);\n  \thash.Final(digest);\n  \n  \tDecodingResult result(0);\n  \tbool &valid = result.isValidCoding;\n  \tsize_t &recoverableMessageLength = result.messageLength;\n  \n  \tvalid = (representative[representativeByteLength - 1] == (hashIdentifier.second ? 0xcc : 0xbc)) && valid;\n  \tvalid = VerifyBufsEqual(representative + representativeByteLength - u, hashIdentifier.first, hashIdentifier.second) && valid;\n  \n  \tGetMGF().GenerateAndMask(hash, representative, representativeByteLength - u - digestSize, h, digestSize);\n  \tif (representativeBitLength % 8 != 0)\n  \t\trepresentative[0] = (byte)Crop(representative[0], representativeBitLength % 8);\n  \n  \t// extract salt and recoverableMessage from DB = 00 ... || 01 || M || salt\n  \tbyte *salt = representative + representativeByteLength - u - digestSize - saltSize;\n  \tbyte *M = std::find_if(representative, salt-1, std::bind2nd(std::not_equal_to<byte>(), 0));\n  \trecoverableMessageLength = salt-M-1;\n  \tif (*M == 0x01 \n  \t\t&& (size_t)(M - representative - (representativeBitLength % 8 != 0)) >= MinPadLen(digestSize)\n  \t\t&& recoverableMessageLength <= MaxRecoverableLength(representativeBitLength, hashIdentifier.second, digestSize))\n  \t{\n  \t\tmemcpy(recoverableMessage, M+1, recoverableMessageLength);\n  \t}\n  \telse\n  \t{\n  \t\trecoverableMessageLength = 0;\n  \t\tvalid = false;\n  \t}\n  \n  \t// verify H = hash of M'\n  \tbyte c[8];\n  \tPutWord(false, BIG_ENDIAN_ORDER, c, (word32)SafeRightShift<29>(recoverableMessageLength));\n  \tPutWord(false, BIG_ENDIAN_ORDER, c+4, word32(recoverableMessageLength << 3));\n  \thash.Update(c, 8);\n  \thash.Update(recoverableMessage, recoverableMessageLength);\n  \thash.Update(digest, digestSize);\n  \thash.Update(salt, saltSize);\n  \tvalid = hash.Verify(h) && valid;\n  \n  \tif (!AllowRecovery() && valid && recoverableMessageLength != 0)\n  \t\t{throw NotImplemented(\"PSSR_MEM: message recovery disabled\");}\n  \t\n  \treturn result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nTF_VerifierBase {\n  DecodingResult TF_VerifierBase::RecoverAndRestart(byte *recoveredMessage, PK_MessageAccumulator &messageAccumulator) const\n  {\n  \tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n  \tHashIdentifier id = GetHashIdentifier();\n  \tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n  \n  \tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n  \t\tthrow PK_SignatureScheme::KeyTooShort();\n  \n  \tDecodingResult result = encoding.RecoverMessageFromRepresentative(\n  \t\tma.AccessHash(), id, ma.m_empty, ma.m_representative, MessageRepresentativeBitLength(), recoveredMessage);\n  \tma.m_empty = true;\n  \treturn result;\n  }\n}"
  },
  {
    "function_name": "VerifyAndRestart",
    "container": "TF_VerifierBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "105-118",
    "snippet": "bool TF_VerifierBase::VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tbool result = encoding.VerifyMessageRepresentative(\n\t\tma.AccessHash(), id, ma.m_empty, ma.m_representative, MessageRepresentativeBitLength());\n\tma.m_empty = true;\n\treturn result;\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encoding.VerifyMessageRepresentative",
          "args": [
            "ma.AccessHash()",
            "id",
            "ma.m_empty",
            "ma.m_representative",
            "MessageRepresentativeBitLength()"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyMessageRepresentative",
          "container": "PK_RecoverableSignatureMessageEncodingMethod",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
          "lines": "34-42",
          "snippet": "bool PK_RecoverableSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tSecByteBlock recoveredMessage(MaxRecoverableLength(representativeBitLength, hashIdentifier.second, hash.DigestSize()));\n\tDecodingResult result = RecoverMessageFromRepresentative(\n\t\thash, hashIdentifier, messageEmpty, representative, representativeBitLength, recoveredMessage);\n\treturn result.isValidCoding && result.messageLength == 0;\n}",
          "includes": [
            "#include \"pubkey.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nPK_RecoverableSignatureMessageEncodingMethod {\n  bool PK_RecoverableSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength) const\n  {\n  \tSecByteBlock recoveredMessage(MaxRecoverableLength(representativeBitLength, hashIdentifier.second, hash.DigestSize()));\n  \tDecodingResult result = RecoverMessageFromRepresentative(\n  \t\thash, hashIdentifier, messageEmpty, representative, representativeBitLength, recoveredMessage);\n  \treturn result.isValidCoding && result.messageLength == 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nTF_VerifierBase {\n  bool TF_VerifierBase::VerifyAndRestart(PK_MessageAccumulator &messageAccumulator) const\n  {\n  \tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n  \tHashIdentifier id = GetHashIdentifier();\n  \tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n  \n  \tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n  \t\tthrow PK_SignatureScheme::KeyTooShort();\n  \n  \tbool result = encoding.VerifyMessageRepresentative(\n  \t\tma.AccessHash(), id, ma.m_empty, ma.m_representative, MessageRepresentativeBitLength());\n  \tma.m_empty = true;\n  \treturn result;\n  }\n}"
  },
  {
    "function_name": "InputSignature",
    "container": "TF_VerifierBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "89-103",
    "snippet": "void TF_VerifierBase::InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tma.m_representative.New(MessageRepresentativeLength());\n\tInteger x = GetTrapdoorFunctionInterface().ApplyFunction(Integer(signature, signatureLength));\n\tif (x.BitCount() > MessageRepresentativeBitLength())\n\t\tx = Integer::Zero();\t// don't return false here to prevent timing attack\n\tx.Encode(ma.m_representative, ma.m_representative.size());\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x.Encode",
          "args": [
            "ma.m_representative",
            "ma.m_representative.size()"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ma.m_representative.size",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Zero",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "Zero",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "23-24",
          "snippet": "Element Zero() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Zero() const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x.BitCount",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "BitCount",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3054-3061",
          "snippet": "unsigned int Integer::BitCount() const\n{\n\tunsigned wordCount = WordCount();\n\tif (wordCount)\n\t\treturn (wordCount-1)*WORD_BITS + BitPrecision(reg[wordCount-1]);\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  unsigned int Integer::BitCount() const\n  {\n  \tunsigned wordCount = WordCount();\n  \tif (wordCount)\n  \t\treturn (wordCount-1)*WORD_BITS + BitPrecision(reg[wordCount-1]);\n  \telse\n  \t\treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "Integer(signature, signatureLength)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "signature",
            "signatureLength"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "Gcd",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3953-3956",
          "snippet": "Integer Integer::Gcd(const Integer &a, const Integer &b)\n{\n\treturn EuclideanDomainOf<Integer>().Gcd(a, b);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  Integer Integer::Gcd(const Integer &a, const Integer &b)\n  {\n  \treturn EuclideanDomainOf<Integer>().Gcd(a, b);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.m_representative.New",
          "args": [
            "MessageRepresentativeLength()"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeLength",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nTF_VerifierBase {\n  void TF_VerifierBase::InputSignature(PK_MessageAccumulator &messageAccumulator, const byte *signature, size_t signatureLength) const\n  {\n  \tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n  \tHashIdentifier id = GetHashIdentifier();\n  \tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n  \n  \tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n  \t\tthrow PK_SignatureScheme::KeyTooShort();\n  \n  \tma.m_representative.New(MessageRepresentativeLength());\n  \tInteger x = GetTrapdoorFunctionInterface().ApplyFunction(Integer(signature, signatureLength));\n  \tif (x.BitCount() > MessageRepresentativeBitLength())\n  \t\tx = Integer::Zero();\t// don't return false here to prevent timing attack\n  \tx.Encode(ma.m_representative, ma.m_representative.size());\n  }\n}"
  },
  {
    "function_name": "SignAndRestart",
    "container": "TF_SignerBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "67-87",
    "snippet": "size_t TF_SignerBase::SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tSecByteBlock representative(MessageRepresentativeLength());\n\tencoding.ComputeMessageRepresentative(rng, \n\t\tma.m_recoverableMessage, ma.m_recoverableMessage.size(), \n\t\tma.AccessHash(), id, ma.m_empty,\n\t\trepresentative, MessageRepresentativeBitLength());\n\tma.m_empty = true;\n\n\tInteger r(representative, representative.size());\n\tsize_t signatureLength = SignatureLength();\n\tGetTrapdoorFunctionInterface().CalculateRandomizedInverse(rng, r).Encode(signature, signatureLength);\n\treturn signatureLength;\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "signature",
            "signatureLength"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [
            "rng",
            "r"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTrapdoorFunctionInterface",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignatureLength",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "representative.size",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "encoding.ComputeMessageRepresentative",
          "args": [
            "rng",
            "ma.m_recoverableMessage",
            "ma.m_recoverableMessage.size()",
            "ma.AccessHash()",
            "id",
            "ma.m_empty",
            "representative",
            "MessageRepresentativeBitLength()"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeMessageRepresentative",
          "container": "EMSA2Pad",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.cpp",
          "lines": "10-30",
          "snippet": "void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n\tconst byte *recoverableMessage, size_t recoverableMessageLength,\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tif (representativeBitLength % 8 != 7)\n\t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n\n\tsize_t digestSize = hash.DigestSize();\n\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n\n\trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n\tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n\tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n\tafterP2[0] = 0xba;\n\thash.Final(afterP2+1);\n\trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n\trepresentative[representativeByteLength-1] = 0xcc;\n}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"pch.h\"\n\nEMSA2Pad {\n  void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n  \tconst byte *recoverableMessage, size_t recoverableMessageLength,\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength) const\n  {\n  \tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n  \n  \tif (representativeBitLength % 8 != 7)\n  \t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n  \n  \tsize_t digestSize = hash.DigestSize();\n  \tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n  \n  \trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n  \tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n  \tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n  \tafterP2[0] = 0xba;\n  \thash.Final(afterP2+1);\n  \trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n  \trepresentative[representativeByteLength-1] = 0xcc;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nTF_SignerBase {\n  size_t TF_SignerBase::SignAndRestart(RandomNumberGenerator &rng, PK_MessageAccumulator &messageAccumulator, byte *signature, bool restart) const\n  {\n  \tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n  \tHashIdentifier id = GetHashIdentifier();\n  \tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n  \n  \tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n  \t\tthrow PK_SignatureScheme::KeyTooShort();\n  \n  \tSecByteBlock representative(MessageRepresentativeLength());\n  \tencoding.ComputeMessageRepresentative(rng, \n  \t\tma.m_recoverableMessage, ma.m_recoverableMessage.size(), \n  \t\tma.AccessHash(), id, ma.m_empty,\n  \t\trepresentative, MessageRepresentativeBitLength());\n  \tma.m_empty = true;\n  \n  \tInteger r(representative, representative.size());\n  \tsize_t signatureLength = SignatureLength();\n  \tGetTrapdoorFunctionInterface().CalculateRandomizedInverse(rng, r).Encode(signature, signatureLength);\n  \treturn signatureLength;\n  }\n}"
  },
  {
    "function_name": "InputRecoverableMessage",
    "container": "TF_SignerBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "44-65",
    "snippet": "void TF_SignerBase::InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const\n{\n\tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n\tHashIdentifier id = GetHashIdentifier();\n\tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n\n\tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n\t\tthrow PK_SignatureScheme::KeyTooShort();\n\n\tsize_t maxRecoverableLength = encoding.MaxRecoverableLength(MessageRepresentativeBitLength(), GetHashIdentifier().second, ma.AccessHash().DigestSize());\n\n\tif (maxRecoverableLength == 0)\n\t\t{throw NotImplemented(\"TF_SignerBase: this algorithm does not support messsage recovery or the key is too short\");}\n\tif (recoverableMessageLength > maxRecoverableLength)\n\t\tthrow InvalidArgument(\"TF_SignerBase: the recoverable message part is too long for the given key and algorithm\");\n\n\tma.m_recoverableMessage.Assign(recoverableMessage, recoverableMessageLength);\n\tencoding.ProcessRecoverableMessage(\n\t\tma.AccessHash(), \n\t\trecoverableMessage, recoverableMessageLength,\n\t\tNULL, 0, ma.m_semisignature);\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encoding.ProcessRecoverableMessage",
          "args": [
            "ma.AccessHash()",
            "recoverableMessage",
            "recoverableMessageLength",
            "NULL",
            "0",
            "ma.m_semisignature"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.m_recoverableMessage.Assign",
          "args": [
            "recoverableMessage",
            "recoverableMessageLength"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "Assign",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "310-314",
          "snippet": "void Assign(const T *t, size_type len)\n\t{\n\t\tNew(len);\n\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Assign(const T *t, size_type len)\n  \t{\n  \t\tNew(len);\n  \t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"TF_SignerBase: the recoverable message part is too long for the given key and algorithm\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NotImplemented",
          "args": [
            "\"TF_SignerBase: this algorithm does not support messsage recovery or the key is too short\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MaxRecoverableLength",
          "args": [
            "MessageRepresentativeBitLength()",
            "GetHashIdentifier().second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRecoverableLength",
          "container": "PSSR_MEM_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pssr.cpp",
          "lines": "23-28",
          "snippet": "size_t PSSR_MEM_Base::MaxRecoverableLength(size_t representativeBitLength, size_t hashIdentifierLength, size_t digestLength) const\n{\n\tif (AllowRecovery())\n\t\treturn SaturatingSubtract(representativeBitLength, MinRepresentativeBitLength(hashIdentifierLength, digestLength)) / 8;\n\treturn 0;\n}",
          "includes": [
            "#include <functional>",
            "#include \"pssr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include \"pssr.h\"\n#include \"pch.h\"\n\nPSSR_MEM_Base {\n  size_t PSSR_MEM_Base::MaxRecoverableLength(size_t representativeBitLength, size_t hashIdentifierLength, size_t digestLength) const\n  {\n  \tif (AllowRecovery())\n  \t\treturn SaturatingSubtract(representativeBitLength, MinRepresentativeBitLength(hashIdentifierLength, digestLength)) / 8;\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHashIdentifier",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashIdentifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "408-412",
          "snippet": "HashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nHashIdentifier GetHashIdentifier() const\n\t{\n        typedef CPP_TYPENAME SchemeOptions::MessageEncodingMethod::HashIdentifierLookup::template HashIdentifierLookup2<CPP_TYPENAME SchemeOptions::HashFunction> L;\n        return L::Lookup();\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PK_SignatureScheme::KeyTooShort",
          "args": [],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoding.MinRepresentativeBitLength",
          "args": [
            "id.second",
            "ma.AccessHash().DigestSize()"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.h",
          "lines": "64-65",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierLength, size_t digestLength) const\n\t\t{return 8*digestLength + 31;}"
        }
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ma.AccessHash",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MessageRepresentativeBitLength",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMessageEncodingInterface",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<PK_MessageAccumulatorBase &>",
          "args": [
            "messageAccumulator"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nTF_SignerBase {\n  void TF_SignerBase::InputRecoverableMessage(PK_MessageAccumulator &messageAccumulator, const byte *recoverableMessage, size_t recoverableMessageLength) const\n  {\n  \tPK_MessageAccumulatorBase &ma = static_cast<PK_MessageAccumulatorBase &>(messageAccumulator);\n  \tHashIdentifier id = GetHashIdentifier();\n  \tconst MessageEncodingInterface &encoding = GetMessageEncodingInterface();\n  \n  \tif (MessageRepresentativeBitLength() < encoding.MinRepresentativeBitLength(id.second, ma.AccessHash().DigestSize()))\n  \t\tthrow PK_SignatureScheme::KeyTooShort();\n  \n  \tsize_t maxRecoverableLength = encoding.MaxRecoverableLength(MessageRepresentativeBitLength(), GetHashIdentifier().second, ma.AccessHash().DigestSize());\n  \n  \tif (maxRecoverableLength == 0)\n  \t\t{throw NotImplemented(\"TF_SignerBase: this algorithm does not support messsage recovery or the key is too short\");}\n  \tif (recoverableMessageLength > maxRecoverableLength)\n  \t\tthrow InvalidArgument(\"TF_SignerBase: the recoverable message part is too long for the given key and algorithm\");\n  \n  \tma.m_recoverableMessage.Assign(recoverableMessage, recoverableMessageLength);\n  \tencoding.ProcessRecoverableMessage(\n  \t\tma.AccessHash(), \n  \t\trecoverableMessage, recoverableMessageLength,\n  \t\tNULL, 0, ma.m_semisignature);\n  }\n}"
  },
  {
    "function_name": "VerifyMessageRepresentative",
    "container": "PK_RecoverableSignatureMessageEncodingMethod",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "34-42",
    "snippet": "bool PK_RecoverableSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tSecByteBlock recoveredMessage(MaxRecoverableLength(representativeBitLength, hashIdentifier.second, hash.DigestSize()));\n\tDecodingResult result = RecoverMessageFromRepresentative(\n\t\thash, hashIdentifier, messageEmpty, representative, representativeBitLength, recoveredMessage);\n\treturn result.isValidCoding && result.messageLength == 0;\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RecoverMessageFromRepresentative",
          "args": [
            "hash",
            "hashIdentifier",
            "messageEmpty",
            "representative",
            "representativeBitLength",
            "recoveredMessage"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "RecoverMessageFromRepresentative",
          "container": "PSSR_MEM_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pssr.cpp",
          "lines": "84-141",
          "snippet": "DecodingResult PSSR_MEM_Base::RecoverMessageFromRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength,\n\tbyte *recoverableMessage) const\n{\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tconst size_t u = hashIdentifier.second + 1;\n\tconst size_t representativeByteLength = BitsToBytes(representativeBitLength);\n\tconst size_t digestSize = hash.DigestSize();\n\tconst size_t saltSize = SaltLen(digestSize);\n\tconst byte *const h = representative + representativeByteLength - u - digestSize;\n\n\tSecByteBlock digest(digestSize);\n\thash.Final(digest);\n\n\tDecodingResult result(0);\n\tbool &valid = result.isValidCoding;\n\tsize_t &recoverableMessageLength = result.messageLength;\n\n\tvalid = (representative[representativeByteLength - 1] == (hashIdentifier.second ? 0xcc : 0xbc)) && valid;\n\tvalid = VerifyBufsEqual(representative + representativeByteLength - u, hashIdentifier.first, hashIdentifier.second) && valid;\n\n\tGetMGF().GenerateAndMask(hash, representative, representativeByteLength - u - digestSize, h, digestSize);\n\tif (representativeBitLength % 8 != 0)\n\t\trepresentative[0] = (byte)Crop(representative[0], representativeBitLength % 8);\n\n\t// extract salt and recoverableMessage from DB = 00 ... || 01 || M || salt\n\tbyte *salt = representative + representativeByteLength - u - digestSize - saltSize;\n\tbyte *M = std::find_if(representative, salt-1, std::bind2nd(std::not_equal_to<byte>(), 0));\n\trecoverableMessageLength = salt-M-1;\n\tif (*M == 0x01 \n\t\t&& (size_t)(M - representative - (representativeBitLength % 8 != 0)) >= MinPadLen(digestSize)\n\t\t&& recoverableMessageLength <= MaxRecoverableLength(representativeBitLength, hashIdentifier.second, digestSize))\n\t{\n\t\tmemcpy(recoverableMessage, M+1, recoverableMessageLength);\n\t}\n\telse\n\t{\n\t\trecoverableMessageLength = 0;\n\t\tvalid = false;\n\t}\n\n\t// verify H = hash of M'\n\tbyte c[8];\n\tPutWord(false, BIG_ENDIAN_ORDER, c, (word32)SafeRightShift<29>(recoverableMessageLength));\n\tPutWord(false, BIG_ENDIAN_ORDER, c+4, word32(recoverableMessageLength << 3));\n\thash.Update(c, 8);\n\thash.Update(recoverableMessage, recoverableMessageLength);\n\thash.Update(digest, digestSize);\n\thash.Update(salt, saltSize);\n\tvalid = hash.Verify(h) && valid;\n\n\tif (!AllowRecovery() && valid && recoverableMessageLength != 0)\n\t\t{throw NotImplemented(\"PSSR_MEM: message recovery disabled\");}\n\t\n\treturn result;\n}",
          "includes": [
            "#include <functional>",
            "#include \"pssr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include \"pssr.h\"\n#include \"pch.h\"\n\nPSSR_MEM_Base {\n  DecodingResult PSSR_MEM_Base::RecoverMessageFromRepresentative(\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength,\n  \tbyte *recoverableMessage) const\n  {\n  \tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n  \n  \tconst size_t u = hashIdentifier.second + 1;\n  \tconst size_t representativeByteLength = BitsToBytes(representativeBitLength);\n  \tconst size_t digestSize = hash.DigestSize();\n  \tconst size_t saltSize = SaltLen(digestSize);\n  \tconst byte *const h = representative + representativeByteLength - u - digestSize;\n  \n  \tSecByteBlock digest(digestSize);\n  \thash.Final(digest);\n  \n  \tDecodingResult result(0);\n  \tbool &valid = result.isValidCoding;\n  \tsize_t &recoverableMessageLength = result.messageLength;\n  \n  \tvalid = (representative[representativeByteLength - 1] == (hashIdentifier.second ? 0xcc : 0xbc)) && valid;\n  \tvalid = VerifyBufsEqual(representative + representativeByteLength - u, hashIdentifier.first, hashIdentifier.second) && valid;\n  \n  \tGetMGF().GenerateAndMask(hash, representative, representativeByteLength - u - digestSize, h, digestSize);\n  \tif (representativeBitLength % 8 != 0)\n  \t\trepresentative[0] = (byte)Crop(representative[0], representativeBitLength % 8);\n  \n  \t// extract salt and recoverableMessage from DB = 00 ... || 01 || M || salt\n  \tbyte *salt = representative + representativeByteLength - u - digestSize - saltSize;\n  \tbyte *M = std::find_if(representative, salt-1, std::bind2nd(std::not_equal_to<byte>(), 0));\n  \trecoverableMessageLength = salt-M-1;\n  \tif (*M == 0x01 \n  \t\t&& (size_t)(M - representative - (representativeBitLength % 8 != 0)) >= MinPadLen(digestSize)\n  \t\t&& recoverableMessageLength <= MaxRecoverableLength(representativeBitLength, hashIdentifier.second, digestSize))\n  \t{\n  \t\tmemcpy(recoverableMessage, M+1, recoverableMessageLength);\n  \t}\n  \telse\n  \t{\n  \t\trecoverableMessageLength = 0;\n  \t\tvalid = false;\n  \t}\n  \n  \t// verify H = hash of M'\n  \tbyte c[8];\n  \tPutWord(false, BIG_ENDIAN_ORDER, c, (word32)SafeRightShift<29>(recoverableMessageLength));\n  \tPutWord(false, BIG_ENDIAN_ORDER, c+4, word32(recoverableMessageLength << 3));\n  \thash.Update(c, 8);\n  \thash.Update(recoverableMessage, recoverableMessageLength);\n  \thash.Update(digest, digestSize);\n  \thash.Update(salt, saltSize);\n  \tvalid = hash.Verify(h) && valid;\n  \n  \tif (!AllowRecovery() && valid && recoverableMessageLength != 0)\n  \t\t{throw NotImplemented(\"PSSR_MEM: message recovery disabled\");}\n  \t\n  \treturn result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaxRecoverableLength",
          "args": [
            "representativeBitLength",
            "hashIdentifier.second",
            "hash.DigestSize()"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRecoverableLength",
          "container": "PSSR_MEM_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pssr.cpp",
          "lines": "23-28",
          "snippet": "size_t PSSR_MEM_Base::MaxRecoverableLength(size_t representativeBitLength, size_t hashIdentifierLength, size_t digestLength) const\n{\n\tif (AllowRecovery())\n\t\treturn SaturatingSubtract(representativeBitLength, MinRepresentativeBitLength(hashIdentifierLength, digestLength)) / 8;\n\treturn 0;\n}",
          "includes": [
            "#include <functional>",
            "#include \"pssr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include \"pssr.h\"\n#include \"pch.h\"\n\nPSSR_MEM_Base {\n  size_t PSSR_MEM_Base::MaxRecoverableLength(size_t representativeBitLength, size_t hashIdentifierLength, size_t digestLength) const\n  {\n  \tif (AllowRecovery())\n  \t\treturn SaturatingSubtract(representativeBitLength, MinRepresentativeBitLength(hashIdentifierLength, digestLength)) / 8;\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.DigestSize",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nPK_RecoverableSignatureMessageEncodingMethod {\n  bool PK_RecoverableSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength) const\n  {\n  \tSecByteBlock recoveredMessage(MaxRecoverableLength(representativeBitLength, hashIdentifier.second, hash.DigestSize()));\n  \tDecodingResult result = RecoverMessageFromRepresentative(\n  \t\thash, hashIdentifier, messageEmpty, representative, representativeBitLength, recoveredMessage);\n  \treturn result.isValidCoding && result.messageLength == 0;\n  }\n}"
  },
  {
    "function_name": "VerifyMessageRepresentative",
    "container": "PK_DeterministicSignatureMessageEncodingMethod",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "25-32",
    "snippet": "bool PK_DeterministicSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tSecByteBlock computedRepresentative(BitsToBytes(representativeBitLength));\n\tComputeMessageRepresentative(NullRNG(), NULL, 0, hash, hashIdentifier, messageEmpty, computedRepresentative, representativeBitLength);\n\treturn VerifyBufsEqual(representative, computedRepresentative, computedRepresentative.size());\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyBufsEqual",
          "args": [
            "representative",
            "computedRepresentative",
            "computedRepresentative.size()"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyBufsEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "79-113",
          "snippet": "bool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nbool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "computedRepresentative.size",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeMessageRepresentative",
          "args": [
            "NullRNG()",
            "NULL",
            "0",
            "hash",
            "hashIdentifier",
            "messageEmpty",
            "computedRepresentative",
            "representativeBitLength"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeMessageRepresentative",
          "container": "EMSA2Pad",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/emsa2.cpp",
          "lines": "10-30",
          "snippet": "void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n\tconst byte *recoverableMessage, size_t recoverableMessageLength,\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tif (representativeBitLength % 8 != 7)\n\t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n\n\tsize_t digestSize = hash.DigestSize();\n\tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n\n\trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n\tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n\tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n\tafterP2[0] = 0xba;\n\thash.Final(afterP2+1);\n\trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n\trepresentative[representativeByteLength-1] = 0xcc;\n}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"pch.h\"\n\nEMSA2Pad {\n  void EMSA2Pad::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n  \tconst byte *recoverableMessage, size_t recoverableMessageLength,\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength) const\n  {\n  \tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n  \n  \tif (representativeBitLength % 8 != 7)\n  \t\tthrow PK_SignatureScheme::InvalidKeyLength(\"EMSA2: EMSA2 requires a key length that is a multiple of 8\");\n  \n  \tsize_t digestSize = hash.DigestSize();\n  \tsize_t representativeByteLength = BitsToBytes(representativeBitLength);\n  \n  \trepresentative[0] = messageEmpty ? 0x4b : 0x6b;\n  \tmemset(representative+1, 0xbb, representativeByteLength-digestSize-4);\t// pad with 0xbb\n  \tbyte *afterP2 = representative+representativeByteLength-digestSize-3;\n  \tafterP2[0] = 0xba;\n  \thash.Final(afterP2+1);\n  \trepresentative[representativeByteLength-2] = *hashIdentifier.first;\n  \trepresentative[representativeByteLength-1] = 0xcc;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NullRNG",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "AlgorithmName",
          "container": "ClassNullRNG",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "291-291",
          "snippet": "std::string AlgorithmName() const {return \"NullRNG\";}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nClassNullRNG {\n  std::string AlgorithmName() const {return \"NullRNG\";}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nPK_DeterministicSignatureMessageEncodingMethod {\n  bool PK_DeterministicSignatureMessageEncodingMethod::VerifyMessageRepresentative(\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength) const\n  {\n  \tSecByteBlock computedRepresentative(BitsToBytes(representativeBitLength));\n  \tComputeMessageRepresentative(NullRNG(), NULL, 0, hash, hashIdentifier, messageEmpty, computedRepresentative, representativeBitLength);\n  \treturn VerifyBufsEqual(representative, computedRepresentative, computedRepresentative.size());\n  }\n}"
  },
  {
    "function_name": "P1363_MGF1KDF2_Common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.cpp",
    "lines": "11-23",
    "snippet": "void P1363_MGF1KDF2_Common(HashTransformation &hash, byte *output, size_t outputLength, const byte *input, size_t inputLength, const byte *derivationParams, size_t derivationParamsLength, bool mask, unsigned int counterStart)\n{\n\tArraySink *sink;\n\tHashFilter filter(hash, sink = mask ? new ArrayXorSink(output, outputLength) : new ArraySink(output, outputLength));\n\tword32 counter = counterStart;\n\twhile (sink->AvailableSize() > 0)\n\t{\n\t\tfilter.Put(input, inputLength);\n\t\tfilter.PutWord32(counter++);\n\t\tfilter.Put(derivationParams, derivationParamsLength);\n\t\tfilter.MessageEnd();\n\t}\n}",
    "includes": [
      "#include \"pubkey.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filter.MessageEnd",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter.Put",
          "args": [
            "derivationParams",
            "derivationParamsLength"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter.PutWord32",
          "args": [
            "counter++"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sink->AvailableSize",
          "args": [],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pubkey.h\"\n#include \"pch.h\"\n\nvoid P1363_MGF1KDF2_Common(HashTransformation &hash, byte *output, size_t outputLength, const byte *input, size_t inputLength, const byte *derivationParams, size_t derivationParamsLength, bool mask, unsigned int counterStart)\n{\n\tArraySink *sink;\n\tHashFilter filter(hash, sink = mask ? new ArrayXorSink(output, outputLength) : new ArraySink(output, outputLength));\n\tword32 counter = counterStart;\n\twhile (sink->AvailableSize() > 0)\n\t{\n\t\tfilter.Put(input, inputLength);\n\t\tfilter.PutWord32(counter++);\n\t\tfilter.Put(derivationParams, derivationParamsLength);\n\t\tfilter.MessageEnd();\n\t}\n}"
  }
]