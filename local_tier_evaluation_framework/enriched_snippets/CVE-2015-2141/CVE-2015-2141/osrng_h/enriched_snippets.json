[
  {
    "function_name": "Reseed",
    "container": "AutoSeededX917RNG<BLOCK_CIPHER>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
    "lines": "122-141",
    "snippet": "void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(bool blocking, const byte *input, size_t length)\n{\n\tSecByteBlock seed(BLOCK_CIPHER::BLOCKSIZE + BLOCK_CIPHER::DEFAULT_KEYLENGTH);\n\tconst byte *key;\n\tdo\n\t{\n\t\tOS_GenerateRandomBlock(blocking, seed, seed.size());\n\t\tif (length > 0)\n\t\t{\n\t\t\tSHA256 hash;\n\t\t\thash.Update(seed, seed.size());\n\t\t\thash.Update(input, length);\n\t\t\thash.TruncatedFinal(seed, UnsignedMin(hash.DigestSize(), seed.size()));\n\t\t}\n\t\tkey = seed + BLOCK_CIPHER::BLOCKSIZE;\n\t}\t// check that seed and key don't have same value\n\twhile (memcmp(key, seed, STDMIN((unsigned int)BLOCK_CIPHER::BLOCKSIZE, (unsigned int)BLOCK_CIPHER::DEFAULT_KEYLENGTH)) == 0);\n\n\tReseed(key, BLOCK_CIPHER::DEFAULT_KEYLENGTH, seed, NULL);\n}",
    "includes": [
      "#include \"fips140.h\"",
      "#include \"sha.h\"",
      "#include \"aes.h\"",
      "#include \"rng.h\"",
      "#include \"randpool.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Reseed",
          "args": [
            "key",
            "BLOCK_CIPHER::DEFAULT_KEYLENGTH",
            "seed",
            "NULL"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "Reseed",
          "container": "AutoSeededX917RNG<BLOCK_CIPHER>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
          "lines": "116-119",
          "snippet": "void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(const byte *key, size_t keylength, const byte *seed, const byte *timeVector)\n{\n\tm_rng.reset(new X917RNG(new typename BLOCK_CIPHER::Encryption(key, keylength), seed, timeVector));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "key",
            "seed",
            "STDMIN((unsigned int)BLOCK_CIPHER::BLOCKSIZE, (unsigned int)BLOCK_CIPHER::DEFAULT_KEYLENGTH)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "(unsigned int)BLOCK_CIPHER::BLOCKSIZE",
            "(unsigned int)BLOCK_CIPHER::DEFAULT_KEYLENGTH"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.TruncatedFinal",
          "args": [
            "seed",
            "UnsignedMin(hash.DigestSize(), seed.size())"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "TruncatedFinal",
          "container": "PanamaHash<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "422-438",
          "snippet": "void PanamaHash<B>::TruncatedFinal(byte *hash, size_t size)\n{\n\tthis->ThrowIfInvalidTruncatedSize(size);\n\n\tthis->PadLastBlock(this->BLOCKSIZE, 0x01);\n\t\n\tHashEndianCorrectedBlock(this->m_data);\n\n\tthis->Iterate(32);\t// pull\n\n\tFixedSizeSecBlock<word32, 8> buf;\n\tthis->Iterate(1, NULL, buf.BytePtr(), NULL);\n\n\tmemcpy(hash, buf, size);\n\n\tthis->Restart();\t\t// reinit for next use\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaHash<B> {\n  void PanamaHash<B>::TruncatedFinal(byte *hash, size_t size)\n  {\n  \tthis->ThrowIfInvalidTruncatedSize(size);\n  \n  \tthis->PadLastBlock(this->BLOCKSIZE, 0x01);\n  \t\n  \tHashEndianCorrectedBlock(this->m_data);\n  \n  \tthis->Iterate(32);\t// pull\n  \n  \tFixedSizeSecBlock<word32, 8> buf;\n  \tthis->Iterate(1, NULL, buf.BytePtr(), NULL);\n  \n  \tmemcpy(hash, buf, size);\n  \n  \tthis->Restart();\t\t// reinit for next use\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "hash.DigestSize()",
            "seed.size()"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seed.size",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.DigestSize",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.Update",
          "args": [
            "input",
            "length"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OS_GenerateRandomBlock",
          "args": [
            "blocking",
            "seed",
            "seed.size()"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fips140.h\"\n#include \"sha.h\"\n#include \"aes.h\"\n#include \"rng.h\"\n#include \"randpool.h\"\n#include \"config.h\"\n\nAutoSeededX917RNG<BLOCK_CIPHER> {\n  void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(bool blocking, const byte *input, size_t length)\n  {\n  \tSecByteBlock seed(BLOCK_CIPHER::BLOCKSIZE + BLOCK_CIPHER::DEFAULT_KEYLENGTH);\n  \tconst byte *key;\n  \tdo\n  \t{\n  \t\tOS_GenerateRandomBlock(blocking, seed, seed.size());\n  \t\tif (length > 0)\n  \t\t{\n  \t\t\tSHA256 hash;\n  \t\t\thash.Update(seed, seed.size());\n  \t\t\thash.Update(input, length);\n  \t\t\thash.TruncatedFinal(seed, UnsignedMin(hash.DigestSize(), seed.size()));\n  \t\t}\n  \t\tkey = seed + BLOCK_CIPHER::BLOCKSIZE;\n  \t}\t// check that seed and key don't have same value\n  \twhile (memcmp(key, seed, STDMIN((unsigned int)BLOCK_CIPHER::BLOCKSIZE, (unsigned int)BLOCK_CIPHER::DEFAULT_KEYLENGTH)) == 0);\n  \n  \tReseed(key, BLOCK_CIPHER::DEFAULT_KEYLENGTH, seed, NULL);\n  }\n}"
  },
  {
    "function_name": "Reseed",
    "container": "AutoSeededX917RNG<BLOCK_CIPHER>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
    "lines": "116-119",
    "snippet": "void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(const byte *key, size_t keylength, const byte *seed, const byte *timeVector)\n{\n\tm_rng.reset(new X917RNG(new typename BLOCK_CIPHER::Encryption(key, keylength), seed, timeVector));\n}",
    "includes": [
      "#include \"fips140.h\"",
      "#include \"sha.h\"",
      "#include \"aes.h\"",
      "#include \"rng.h\"",
      "#include \"randpool.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_rng.reset",
          "args": [
            "new X917RNG(new typename BLOCK_CIPHER::Encryption(key, keylength), seed, timeVector)"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "member_ptr<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "50-50",
          "snippet": "void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nmember_ptr<T> {\n  void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fips140.h\"\n#include \"sha.h\"\n#include \"aes.h\"\n#include \"rng.h\"\n#include \"randpool.h\"\n#include \"config.h\"\n\nAutoSeededX917RNG<BLOCK_CIPHER> {\n  void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(const byte *key, size_t keylength, const byte *seed, const byte *timeVector)\n  {\n  \tm_rng.reset(new X917RNG(new typename BLOCK_CIPHER::Encryption(key, keylength), seed, timeVector));\n  }\n}"
  },
  {
    "function_name": "GenerateIntoBufferedTransformation",
    "container": "AutoSeededX917RNG",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
    "lines": "109-109",
    "snippet": "void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword length) {m_rng->GenerateIntoBufferedTransformation(target, channel, length);}",
    "includes": [
      "#include \"fips140.h\"",
      "#include \"sha.h\"",
      "#include \"aes.h\"",
      "#include \"rng.h\"",
      "#include \"randpool.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_rng->GenerateIntoBufferedTransformation",
          "args": [
            "target",
            "channel",
            "length"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateIntoBufferedTransformation",
          "container": "AutoSeededX917RNG",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
          "lines": "109-109",
          "snippet": "void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword length) {m_rng->GenerateIntoBufferedTransformation(target, channel, length);}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"fips140.h\"\n#include \"sha.h\"\n#include \"aes.h\"\n#include \"rng.h\"\n#include \"randpool.h\"\n#include \"config.h\"\n\nAutoSeededX917RNG {\n  void GenerateIntoBufferedTransformation(BufferedTransformation &target, const std::string &channel, lword length) {m_rng->GenerateIntoBufferedTransformation(target, channel, length);}\n}"
  },
  {
    "function_name": "IncorporateEntropy",
    "container": "AutoSeededX917RNG",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
    "lines": "108-108",
    "snippet": "void IncorporateEntropy(const byte *input, size_t length) {Reseed(false, input, length);}",
    "includes": [
      "#include \"fips140.h\"",
      "#include \"sha.h\"",
      "#include \"aes.h\"",
      "#include \"rng.h\"",
      "#include \"randpool.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Reseed",
          "args": [
            "false",
            "input",
            "length"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "Reseed",
          "container": "AutoSeededX917RNG<BLOCK_CIPHER>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
          "lines": "122-141",
          "snippet": "void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(bool blocking, const byte *input, size_t length)\n{\n\tSecByteBlock seed(BLOCK_CIPHER::BLOCKSIZE + BLOCK_CIPHER::DEFAULT_KEYLENGTH);\n\tconst byte *key;\n\tdo\n\t{\n\t\tOS_GenerateRandomBlock(blocking, seed, seed.size());\n\t\tif (length > 0)\n\t\t{\n\t\t\tSHA256 hash;\n\t\t\thash.Update(seed, seed.size());\n\t\t\thash.Update(input, length);\n\t\t\thash.TruncatedFinal(seed, UnsignedMin(hash.DigestSize(), seed.size()));\n\t\t}\n\t\tkey = seed + BLOCK_CIPHER::BLOCKSIZE;\n\t}\t// check that seed and key don't have same value\n\twhile (memcmp(key, seed, STDMIN((unsigned int)BLOCK_CIPHER::BLOCKSIZE, (unsigned int)BLOCK_CIPHER::DEFAULT_KEYLENGTH)) == 0);\n\n\tReseed(key, BLOCK_CIPHER::DEFAULT_KEYLENGTH, seed, NULL);\n}",
          "includes": [
            "#include \"fips140.h\"",
            "#include \"sha.h\"",
            "#include \"aes.h\"",
            "#include \"rng.h\"",
            "#include \"randpool.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fips140.h\"\n#include \"sha.h\"\n#include \"aes.h\"\n#include \"rng.h\"\n#include \"randpool.h\"\n#include \"config.h\"\n\nAutoSeededX917RNG<BLOCK_CIPHER> {\n  void AutoSeededX917RNG<BLOCK_CIPHER>::Reseed(bool blocking, const byte *input, size_t length)\n  {\n  \tSecByteBlock seed(BLOCK_CIPHER::BLOCKSIZE + BLOCK_CIPHER::DEFAULT_KEYLENGTH);\n  \tconst byte *key;\n  \tdo\n  \t{\n  \t\tOS_GenerateRandomBlock(blocking, seed, seed.size());\n  \t\tif (length > 0)\n  \t\t{\n  \t\t\tSHA256 hash;\n  \t\t\thash.Update(seed, seed.size());\n  \t\t\thash.Update(input, length);\n  \t\t\thash.TruncatedFinal(seed, UnsignedMin(hash.DigestSize(), seed.size()));\n  \t\t}\n  \t\tkey = seed + BLOCK_CIPHER::BLOCKSIZE;\n  \t}\t// check that seed and key don't have same value\n  \twhile (memcmp(key, seed, STDMIN((unsigned int)BLOCK_CIPHER::BLOCKSIZE, (unsigned int)BLOCK_CIPHER::DEFAULT_KEYLENGTH)) == 0);\n  \n  \tReseed(key, BLOCK_CIPHER::DEFAULT_KEYLENGTH, seed, NULL);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fips140.h\"\n#include \"sha.h\"\n#include \"aes.h\"\n#include \"rng.h\"\n#include \"randpool.h\"\n#include \"config.h\"\n\nAutoSeededX917RNG {\n  void IncorporateEntropy(const byte *input, size_t length) {Reseed(false, input, length);}\n}"
  },
  {
    "function_name": "CanIncorporateEntropy",
    "container": "AutoSeededX917RNG",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
    "lines": "107-107",
    "snippet": "bool CanIncorporateEntropy() const {return true;}",
    "includes": [
      "#include \"fips140.h\"",
      "#include \"sha.h\"",
      "#include \"aes.h\"",
      "#include \"rng.h\"",
      "#include \"randpool.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fips140.h\"\n#include \"sha.h\"\n#include \"aes.h\"\n#include \"rng.h\"\n#include \"randpool.h\"\n#include \"config.h\"\n\nAutoSeededX917RNG {\n  bool CanIncorporateEntropy() const {return true;}\n}"
  },
  {
    "function_name": "AutoSeededX917RNG",
    "container": "AutoSeededX917RNG",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/osrng.h",
    "lines": "101-102",
    "snippet": "explicit AutoSeededX917RNG(bool blocking = false, bool autoSeed = true)\n\t\t{if (autoSeed) Reseed(blocking);}",
    "includes": [
      "#include \"fips140.h\"",
      "#include \"sha.h\"",
      "#include \"aes.h\"",
      "#include \"rng.h\"",
      "#include \"randpool.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Reseed",
          "args": [
            "blocking"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fips140.h\"\n#include \"sha.h\"\n#include \"aes.h\"\n#include \"rng.h\"\n#include \"randpool.h\"\n#include \"config.h\"\n\nAutoSeededX917RNG {\n  explicit AutoSeededX917RNG(bool blocking = false, bool autoSeed = true)\n  \t\t{if (autoSeed) Reseed(blocking);}\n}"
  }
]