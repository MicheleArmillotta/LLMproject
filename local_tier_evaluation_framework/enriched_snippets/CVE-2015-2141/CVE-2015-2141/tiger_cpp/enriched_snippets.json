[
  {
    "function_name": "TruncatedFinal",
    "container": "Tiger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tiger.cpp",
    "lines": "17-31",
    "snippet": "void Tiger::TruncatedFinal(byte *hash, size_t size)\n{\n\tThrowIfInvalidTruncatedSize(size);\n\n\tPadLastBlock(56, 0x01);\n\tCorrectEndianess(m_data, m_data, 56);\n\n\tm_data[7] = GetBitCountLo();\n\n\tTransform(m_state, m_data);\n\tCorrectEndianess(m_state, m_state, DigestSize());\n\tmemcpy(hash, m_state, size);\n\n\tRestart();\t\t// reinit for next use\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"tiger.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Restart",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "Restart",
          "container": "IteratedHashBase<T, BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
          "lines": "120-124",
          "snippet": "void IteratedHashBase<T, BASE>::Restart()\n{\n\tm_countLo = m_countHi = 0;\n\tInit();\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  void IteratedHashBase<T, BASE>::Restart()\n  {\n  \tm_countLo = m_countHi = 0;\n  \tInit();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash",
            "m_state",
            "size"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CorrectEndianess",
          "args": [
            "m_state",
            "m_state",
            "DigestSize()"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DigestSize",
          "args": [],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Transform",
          "args": [
            "m_state",
            "m_data"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "LastPut",
          "container": "StreamTransformationFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "622-712",
          "snippet": "void StreamTransformationFilter::LastPut(const byte *inString, size_t length)\n{\n\tbyte *space = NULL;\n\t\n\tswitch (m_padding)\n\t{\n\tcase NO_PADDING:\n\tcase ZEROS_PADDING:\n\t\tif (length > 0)\n\t\t{\n\t\t\tsize_t minLastBlockSize = m_cipher.MinLastBlockSize();\n\t\t\tbool isForwardTransformation = m_cipher.IsForwardTransformation();\n\n\t\t\tif (isForwardTransformation && m_padding == ZEROS_PADDING && (minLastBlockSize == 0 || length < minLastBlockSize))\n\t\t\t{\n\t\t\t\t// do padding\n\t\t\t\tsize_t blockSize = STDMAX(minLastBlockSize, (size_t)m_cipher.MandatoryBlockSize());\n\t\t\t\tspace = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, blockSize);\n\t\t\t\tmemcpy(space, inString, length);\n\t\t\t\tmemset(space + length, 0, blockSize - length);\n\t\t\t\tm_cipher.ProcessLastBlock(space, space, blockSize);\n\t\t\t\tAttachedTransformation()->Put(space, blockSize);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (minLastBlockSize == 0)\n\t\t\t\t{\n\t\t\t\t\tif (isForwardTransformation)\n\t\t\t\t\t\tthrow InvalidDataFormat(\"StreamTransformationFilter: plaintext length is not a multiple of block size and NO_PADDING is specified\");\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow InvalidCiphertext(\"StreamTransformationFilter: ciphertext length is not a multiple of block size\");\n\t\t\t\t}\n\n\t\t\t\tspace = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, length, m_optimalBufferSize);\n\t\t\t\tm_cipher.ProcessLastBlock(space, inString, length);\n\t\t\t\tAttachedTransformation()->Put(space, length);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase PKCS_PADDING:\n\tcase ONE_AND_ZEROS_PADDING:\n\t\tunsigned int s;\n\t\ts = m_cipher.MandatoryBlockSize();\n\t\tassert(s > 1);\n\t\tspace = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, s, m_optimalBufferSize);\n\t\tif (m_cipher.IsForwardTransformation())\n\t\t{\n\t\t\tassert(length < s);\n\t\t\tmemcpy(space, inString, length);\n\t\t\tif (m_padding == PKCS_PADDING)\n\t\t\t{\n\t\t\t\tassert(s < 256);\n\t\t\t\tbyte pad = byte(s-length);\n\t\t\t\tmemset(space+length, pad, s-length);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tspace[length] = 0x80;\n\t\t\t\tmemset(space+length+1, 0, s-length-1);\n\t\t\t}\n\t\t\tm_cipher.ProcessData(space, space, s);\n\t\t\tAttachedTransformation()->Put(space, s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (length != s)\n\t\t\t\tthrow InvalidCiphertext(\"StreamTransformationFilter: ciphertext length is not a multiple of block size\");\n\t\t\tm_cipher.ProcessData(space, inString, s);\n\t\t\tif (m_padding == PKCS_PADDING)\n\t\t\t{\n\t\t\t\tbyte pad = space[s-1];\n\t\t\t\tif (pad < 1 || pad > s || std::find_if(space+s-pad, space+s, std::bind2nd(std::not_equal_to<byte>(), pad)) != space+s)\n\t\t\t\t\tthrow InvalidCiphertext(\"StreamTransformationFilter: invalid PKCS #7 block padding found\");\n\t\t\t\tlength = s-pad;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (length > 1 && space[length-1] == 0)\n\t\t\t\t\t--length;\n\t\t\t\tif (space[--length] != 0x80)\n\t\t\t\t\tthrow InvalidCiphertext(\"StreamTransformationFilter: invalid ones-and-zeros padding found\");\n\t\t\t}\n\t\t\tAttachedTransformation()->Put(space, length);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tassert(false);\n\t}\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nStreamTransformationFilter {\n  void StreamTransformationFilter::LastPut(const byte *inString, size_t length)\n  {\n  \tbyte *space = NULL;\n  \t\n  \tswitch (m_padding)\n  \t{\n  \tcase NO_PADDING:\n  \tcase ZEROS_PADDING:\n  \t\tif (length > 0)\n  \t\t{\n  \t\t\tsize_t minLastBlockSize = m_cipher.MinLastBlockSize();\n  \t\t\tbool isForwardTransformation = m_cipher.IsForwardTransformation();\n  \n  \t\t\tif (isForwardTransformation && m_padding == ZEROS_PADDING && (minLastBlockSize == 0 || length < minLastBlockSize))\n  \t\t\t{\n  \t\t\t\t// do padding\n  \t\t\t\tsize_t blockSize = STDMAX(minLastBlockSize, (size_t)m_cipher.MandatoryBlockSize());\n  \t\t\t\tspace = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, blockSize);\n  \t\t\t\tmemcpy(space, inString, length);\n  \t\t\t\tmemset(space + length, 0, blockSize - length);\n  \t\t\t\tm_cipher.ProcessLastBlock(space, space, blockSize);\n  \t\t\t\tAttachedTransformation()->Put(space, blockSize);\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tif (minLastBlockSize == 0)\n  \t\t\t\t{\n  \t\t\t\t\tif (isForwardTransformation)\n  \t\t\t\t\t\tthrow InvalidDataFormat(\"StreamTransformationFilter: plaintext length is not a multiple of block size and NO_PADDING is specified\");\n  \t\t\t\t\telse\n  \t\t\t\t\t\tthrow InvalidCiphertext(\"StreamTransformationFilter: ciphertext length is not a multiple of block size\");\n  \t\t\t\t}\n  \n  \t\t\t\tspace = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, length, m_optimalBufferSize);\n  \t\t\t\tm_cipher.ProcessLastBlock(space, inString, length);\n  \t\t\t\tAttachedTransformation()->Put(space, length);\n  \t\t\t}\n  \t\t}\n  \t\tbreak;\n  \n  \tcase PKCS_PADDING:\n  \tcase ONE_AND_ZEROS_PADDING:\n  \t\tunsigned int s;\n  \t\ts = m_cipher.MandatoryBlockSize();\n  \t\tassert(s > 1);\n  \t\tspace = HelpCreatePutSpace(*AttachedTransformation(), DEFAULT_CHANNEL, s, m_optimalBufferSize);\n  \t\tif (m_cipher.IsForwardTransformation())\n  \t\t{\n  \t\t\tassert(length < s);\n  \t\t\tmemcpy(space, inString, length);\n  \t\t\tif (m_padding == PKCS_PADDING)\n  \t\t\t{\n  \t\t\t\tassert(s < 256);\n  \t\t\t\tbyte pad = byte(s-length);\n  \t\t\t\tmemset(space+length, pad, s-length);\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tspace[length] = 0x80;\n  \t\t\t\tmemset(space+length+1, 0, s-length-1);\n  \t\t\t}\n  \t\t\tm_cipher.ProcessData(space, space, s);\n  \t\t\tAttachedTransformation()->Put(space, s);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tif (length != s)\n  \t\t\t\tthrow InvalidCiphertext(\"StreamTransformationFilter: ciphertext length is not a multiple of block size\");\n  \t\t\tm_cipher.ProcessData(space, inString, s);\n  \t\t\tif (m_padding == PKCS_PADDING)\n  \t\t\t{\n  \t\t\t\tbyte pad = space[s-1];\n  \t\t\t\tif (pad < 1 || pad > s || std::find_if(space+s-pad, space+s, std::bind2nd(std::not_equal_to<byte>(), pad)) != space+s)\n  \t\t\t\t\tthrow InvalidCiphertext(\"StreamTransformationFilter: invalid PKCS #7 block padding found\");\n  \t\t\t\tlength = s-pad;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\twhile (length > 1 && space[length-1] == 0)\n  \t\t\t\t\t--length;\n  \t\t\t\tif (space[--length] != 0x80)\n  \t\t\t\t\tthrow InvalidCiphertext(\"StreamTransformationFilter: invalid ones-and-zeros padding found\");\n  \t\t\t}\n  \t\t\tAttachedTransformation()->Put(space, length);\n  \t\t}\n  \t\tbreak;\n  \n  \tdefault:\n  \t\tassert(false);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBitCountLo",
          "args": [],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "GetBitCountLo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "36-36",
          "snippet": "inline T GetBitCountLo() const {return m_countLo << 3;}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\ninline T GetBitCountLo() const {return m_countLo << 3;}"
        }
      },
      {
        "call_info": {
          "callee": "CorrectEndianess",
          "args": [
            "m_data",
            "m_data",
            "56"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PadLastBlock",
          "args": [
            "56",
            "0x01"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "PadLastBlock",
          "container": "IteratedHashBase<T, BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
          "lines": "103-118",
          "snippet": "void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tunsigned int num = ModPowerOf2(m_countLo, blockSize);\n\tT* dataBuf = this->DataBuf();\n\tbyte* data = (byte *)dataBuf;\n\tdata[num++] = padFirst;\n\tif (num <= lastBlockSize)\n\t\tmemset(data+num, 0, lastBlockSize-num);\n\telse\n\t{\n\t\tmemset(data+num, 0, blockSize-num);\n\t\tHashBlock(dataBuf);\n\t\tmemset(data, 0, lastBlockSize);\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)\n  {\n  \tunsigned int blockSize = this->BlockSize();\n  \tunsigned int num = ModPowerOf2(m_countLo, blockSize);\n  \tT* dataBuf = this->DataBuf();\n  \tbyte* data = (byte *)dataBuf;\n  \tdata[num++] = padFirst;\n  \tif (num <= lastBlockSize)\n  \t\tmemset(data+num, 0, lastBlockSize-num);\n  \telse\n  \t{\n  \t\tmemset(data+num, 0, blockSize-num);\n  \t\tHashBlock(dataBuf);\n  \t\tmemset(data, 0, lastBlockSize);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThrowIfInvalidTruncatedSize",
          "args": [
            "size"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "ThrowIfInvalidTruncatedSize",
          "container": "HashTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "309-313",
          "snippet": "void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n{\n\tif (size > DigestSize())\n\t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nHashTransformation {\n  void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n  {\n  \tif (size > DigestSize())\n  \t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"tiger.h\"\n#include \"pch.h\"\n\nTiger {\n  void Tiger::TruncatedFinal(byte *hash, size_t size)\n  {\n  \tThrowIfInvalidTruncatedSize(size);\n  \n  \tPadLastBlock(56, 0x01);\n  \tCorrectEndianess(m_data, m_data, 56);\n  \n  \tm_data[7] = GetBitCountLo();\n  \n  \tTransform(m_state, m_data);\n  \tCorrectEndianess(m_state, m_state, DigestSize());\n  \tmemcpy(hash, m_state, size);\n  \n  \tRestart();\t\t// reinit for next use\n  }\n}"
  },
  {
    "function_name": "InitState",
    "container": "Tiger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tiger.cpp",
    "lines": "10-15",
    "snippet": "void Tiger::InitState(HashWordType *state)\n{\n\tstate[0] = W64LIT(0x0123456789ABCDEF);\n\tstate[1] = W64LIT(0xFEDCBA9876543210);\n\tstate[2] = W64LIT(0xF096A5B4C3B2E187);\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"tiger.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xF096A5B4C3B2E187"
          ],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0xFEDCBA9876543210"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "W64LIT",
          "args": [
            "0x0123456789ABCDEF"
          ],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"tiger.h\"\n#include \"pch.h\"\n\nTiger {\n  void Tiger::InitState(HashWordType *state)\n  {\n  \tstate[0] = W64LIT(0x0123456789ABCDEF);\n  \tstate[1] = W64LIT(0xFEDCBA9876543210);\n  \tstate[2] = W64LIT(0xF096A5B4C3B2E187);\n  }\n}"
  }
]