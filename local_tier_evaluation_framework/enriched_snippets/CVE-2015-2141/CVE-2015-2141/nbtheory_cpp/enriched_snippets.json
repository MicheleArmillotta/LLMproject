[
  {
    "function_name": "PrimeAndGenerator::Generate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "1036-1119",
    "snippet": "void PrimeAndGenerator::Generate(signed int delta, RandomNumberGenerator &rng, unsigned int pbits, unsigned int qbits)\n{\n\t// no prime exists for delta = -1, qbits = 4, and pbits = 5\n\tassert(qbits > 4);\n\tassert(pbits > qbits);\n\n\tif (qbits+1 == pbits)\n\t{\n\t\tInteger minP = Integer::Power2(pbits-1);\n\t\tInteger maxP = Integer::Power2(pbits) - 1;\n\t\tbool success = false;\n\n\t\twhile (!success)\n\t\t{\n\t\t\tp.Randomize(rng, minP, maxP, Integer::ANY, 6+5*delta, 12);\n\t\t\tPrimeSieve sieve(p, STDMIN(p+PrimeSearchInterval(maxP)*12, maxP), 12, delta);\n\n\t\t\twhile (sieve.NextCandidate(p))\n\t\t\t{\n\t\t\t\tassert(IsSmallPrime(p) || SmallDivisorsTest(p));\n\t\t\t\tq = (p-delta) >> 1;\n\t\t\t\tassert(IsSmallPrime(q) || SmallDivisorsTest(q));\n\t\t\t\tif (FastProbablePrimeTest(q) && FastProbablePrimeTest(p) && IsPrime(q) && IsPrime(p))\n\t\t\t\t{\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (delta == 1)\n\t\t{\n\t\t\t// find g such that g is a quadratic residue mod p, then g has order q\n\t\t\t// g=4 always works, but this way we get the smallest quadratic residue (other than 1)\n\t\t\tfor (g=2; Jacobi(g, p) != 1; ++g) {}\n\t\t\t// contributed by Walt Tuvell: g should be the following according to the Law of Quadratic Reciprocity\n\t\t\tassert((p%8==1 || p%8==7) ? g==2 : (p%12==1 || p%12==11) ? g==3 : g==4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(delta == -1);\n\t\t\t// find g such that g*g-4 is a quadratic non-residue, \n\t\t\t// and such that g has order q\n\t\t\tfor (g=3; ; ++g)\n\t\t\t\tif (Jacobi(g*g-4, p)==-1 && Lucas(q, g, p)==2)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tInteger minQ = Integer::Power2(qbits-1);\n\t\tInteger maxQ = Integer::Power2(qbits) - 1;\n\t\tInteger minP = Integer::Power2(pbits-1);\n\t\tInteger maxP = Integer::Power2(pbits) - 1;\n\n\t\tdo\n\t\t{\n\t\t\tq.Randomize(rng, minQ, maxQ, Integer::PRIME);\n\t\t} while (!p.Randomize(rng, minP, maxP, Integer::PRIME, delta%q, q));\n\n\t\t// find a random g of order q\n\t\tif (delta==1)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tInteger h(rng, 2, p-2, Integer::ANY);\n\t\t\t\tg = a_exp_b_mod_c(h, (p-1)/q, p);\n\t\t\t} while (g <= 1);\n\t\t\tassert(a_exp_b_mod_c(g, q, p)==1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(delta==-1);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tInteger h(rng, 3, p-1, Integer::ANY);\n\t\t\t\tif (Jacobi(h*h-4, p)==1)\n\t\t\t\t\tcontinue;\n\t\t\t\tg = Lucas((p+1)/q, h, p);\n\t\t\t} while (g <= 2);\n\t\t\tassert(Lucas(q, g, p) == 2);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Lucas(q, g, p) == 2"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "q",
            "g",
            "p"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "(p+1)/q",
            "h",
            "p"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "h*h-4",
            "p"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "delta==-1"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "a_exp_b_mod_c(g, q, p)==1"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "g",
            "q",
            "p"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "h",
            "(p-1)/q",
            "p"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.Randomize",
          "args": [
            "rng",
            "minP",
            "maxP",
            "Integer::PRIME",
            "delta%q",
            "q"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "q.Randomize",
          "args": [
            "rng",
            "minQ",
            "maxQ",
            "Integer::PRIME"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer::Power2",
          "args": [
            "pbits"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Power2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2846-2851",
          "snippet": "Integer Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "q",
            "g",
            "p"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "delta == -1"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(p%8==1 || p%8==7) ? g==2 : (p%12==1 || p%12==11) ? g==3 : g==4"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsPrime",
          "args": [
            "p"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "IsPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "237-245",
          "snippet": "bool IsPrime(const Integer &p)\n{\n\tif (p <= s_lastSmallPrime)\n\t\treturn IsSmallPrime(p);\n\telse if (p <= Singleton<Integer, NewLastSmallPrimeSquared>().Ref())\n\t\treturn SmallDivisorsTest(p);\n\telse\n\t\treturn SmallDivisorsTest(p) && IsStrongProbablePrime(p, 3) && IsStrongLucasProbablePrime(p);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsPrime(const Integer &p)\n{\n\tif (p <= s_lastSmallPrime)\n\t\treturn IsSmallPrime(p);\n\telse if (p <= Singleton<Integer, NewLastSmallPrimeSquared>().Ref())\n\t\treturn SmallDivisorsTest(p);\n\telse\n\t\treturn SmallDivisorsTest(p) && IsStrongProbablePrime(p, 3) && IsStrongLucasProbablePrime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FastProbablePrimeTest",
          "args": [
            "p"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "FastProbablePrimeTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "260-263",
          "snippet": "static inline bool FastProbablePrimeTest(const Integer &n)\n{\n\treturn IsStrongProbablePrime(n,2);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nstatic inline bool FastProbablePrimeTest(const Integer &n)\n{\n\treturn IsStrongProbablePrime(n,2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "IsSmallPrime(q) || SmallDivisorsTest(q)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SmallDivisorsTest",
          "args": [
            "q"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "SmallDivisorsTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "89-94",
          "snippet": "bool SmallDivisorsTest(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\treturn !TrialDivision(p, primeTable[primeTableSize-1]);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool SmallDivisorsTest(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\treturn !TrialDivision(p, primeTable[primeTableSize-1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsSmallPrime",
          "args": [
            "q"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "IsSmallPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "60-69",
          "snippet": "bool IsSmallPrime(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (p.IsPositive() && p <= primeTable[primeTableSize-1])\n\t\treturn std::binary_search(primeTable, primeTable+primeTableSize, (word16)p.ConvertToLong());\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsSmallPrime(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (p.IsPositive() && p <= primeTable[primeTableSize-1])\n\t\treturn std::binary_search(primeTable, primeTable+primeTableSize, (word16)p.ConvertToLong());\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "IsSmallPrime(p) || SmallDivisorsTest(p)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sieve.NextCandidate",
          "args": [
            "p"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "p+PrimeSearchInterval(maxP)*12",
            "maxP"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrimeSearchInterval",
          "args": [
            "maxP"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "PrimeSearchInterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "255-258",
          "snippet": "unsigned int PrimeSearchInterval(const Integer &max)\n{\n\treturn max.BitCount();\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nunsigned int PrimeSearchInterval(const Integer &max)\n{\n\treturn max.BitCount();\n}"
        }
      },
      {
        "call_info": {
          "callee": "p.Randomize",
          "args": [
            "rng",
            "minP",
            "maxP",
            "Integer::ANY",
            "6+5*delta",
            "12"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pbits > qbits"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "qbits > 4"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nvoid PrimeAndGenerator::Generate(signed int delta, RandomNumberGenerator &rng, unsigned int pbits, unsigned int qbits)\n{\n\t// no prime exists for delta = -1, qbits = 4, and pbits = 5\n\tassert(qbits > 4);\n\tassert(pbits > qbits);\n\n\tif (qbits+1 == pbits)\n\t{\n\t\tInteger minP = Integer::Power2(pbits-1);\n\t\tInteger maxP = Integer::Power2(pbits) - 1;\n\t\tbool success = false;\n\n\t\twhile (!success)\n\t\t{\n\t\t\tp.Randomize(rng, minP, maxP, Integer::ANY, 6+5*delta, 12);\n\t\t\tPrimeSieve sieve(p, STDMIN(p+PrimeSearchInterval(maxP)*12, maxP), 12, delta);\n\n\t\t\twhile (sieve.NextCandidate(p))\n\t\t\t{\n\t\t\t\tassert(IsSmallPrime(p) || SmallDivisorsTest(p));\n\t\t\t\tq = (p-delta) >> 1;\n\t\t\t\tassert(IsSmallPrime(q) || SmallDivisorsTest(q));\n\t\t\t\tif (FastProbablePrimeTest(q) && FastProbablePrimeTest(p) && IsPrime(q) && IsPrime(p))\n\t\t\t\t{\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (delta == 1)\n\t\t{\n\t\t\t// find g such that g is a quadratic residue mod p, then g has order q\n\t\t\t// g=4 always works, but this way we get the smallest quadratic residue (other than 1)\n\t\t\tfor (g=2; Jacobi(g, p) != 1; ++g) {}\n\t\t\t// contributed by Walt Tuvell: g should be the following according to the Law of Quadratic Reciprocity\n\t\t\tassert((p%8==1 || p%8==7) ? g==2 : (p%12==1 || p%12==11) ? g==3 : g==4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(delta == -1);\n\t\t\t// find g such that g*g-4 is a quadratic non-residue, \n\t\t\t// and such that g has order q\n\t\t\tfor (g=3; ; ++g)\n\t\t\t\tif (Jacobi(g*g-4, p)==-1 && Lucas(q, g, p)==2)\n\t\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\tInteger minQ = Integer::Power2(qbits-1);\n\t\tInteger maxQ = Integer::Power2(qbits) - 1;\n\t\tInteger minP = Integer::Power2(pbits-1);\n\t\tInteger maxP = Integer::Power2(pbits) - 1;\n\n\t\tdo\n\t\t{\n\t\t\tq.Randomize(rng, minQ, maxQ, Integer::PRIME);\n\t\t} while (!p.Randomize(rng, minP, maxP, Integer::PRIME, delta%q, q));\n\n\t\t// find a random g of order q\n\t\tif (delta==1)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tInteger h(rng, 2, p-2, Integer::ANY);\n\t\t\t\tg = a_exp_b_mod_c(h, (p-1)/q, p);\n\t\t\t} while (g <= 1);\n\t\t\tassert(a_exp_b_mod_c(g, q, p)==1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(delta==-1);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tInteger h(rng, 3, p-1, Integer::ANY);\n\t\t\t\tif (Jacobi(h*h-4, p)==1)\n\t\t\t\t\tcontinue;\n\t\t\t\tg = Lucas((p+1)/q, h, p);\n\t\t\t} while (g <= 2);\n\t\t\tassert(Lucas(q, g, p) == 2);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "DiscreteLogWorkFactor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "1027-1032",
    "snippet": "unsigned int DiscreteLogWorkFactor(unsigned int n)\n{\n\t// assuming discrete log takes about the same time as factoring\n\tif (n<5) return 0;\n\telse return (unsigned int)(2.4 * pow((double)n, 1.0/3.0) * pow(log(double(n)), 2.0/3.0) - 5);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "log(double(n))",
            "2.0/3.0"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "double(n)"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "double",
          "args": [
            "n"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "(double)n",
            "1.0/3.0"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nunsigned int DiscreteLogWorkFactor(unsigned int n)\n{\n\t// assuming discrete log takes about the same time as factoring\n\tif (n<5) return 0;\n\telse return (unsigned int)(2.4 * pow((double)n, 1.0/3.0) * pow(log(double(n)), 2.0/3.0) - 5);\n}"
  },
  {
    "function_name": "FactoringWorkFactor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "1019-1025",
    "snippet": "unsigned int FactoringWorkFactor(unsigned int n)\n{\n\t// extrapolated from the table in Odlyzko's \"The Future of Integer Factorization\"\n\t// updated to reflect the factoring of RSA-130\n\tif (n<5) return 0;\n\telse return (unsigned int)(2.4 * pow((double)n, 1.0/3.0) * pow(log(double(n)), 2.0/3.0) - 5);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "log(double(n))",
            "2.0/3.0"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "double(n)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "double",
          "args": [
            "n"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "(double)n",
            "1.0/3.0"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nunsigned int FactoringWorkFactor(unsigned int n)\n{\n\t// extrapolated from the table in Odlyzko's \"The Future of Integer Factorization\"\n\t// updated to reflect the factoring of RSA-130\n\tif (n<5) return 0;\n\telse return (unsigned int)(2.4 * pow((double)n, 1.0/3.0) * pow(log(double(n)), 2.0/3.0) - 5);\n}"
  },
  {
    "function_name": "InverseLucas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "998-1017",
    "snippet": "Integer InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q, const Integer &u)\n{\n\tInteger d = (m*m-4);\n\tInteger p2, q2;\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tp2 = p-Jacobi(d,p);\n\t\t\t\tp2 = Lucas(EuclideanMultiplicativeInverse(e,p2), m, p);\n\t\t\t}\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tq2 = q-Jacobi(d,q);\n\t\t\t\tq2 = Lucas(EuclideanMultiplicativeInverse(e,q2), m, q);\n\t\t\t}\n\t\t}\n\treturn CRT(p2, p, q2, q, u);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRT",
          "args": [
            "p2",
            "p",
            "q2",
            "q",
            "u"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "CRT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "553-570",
          "snippet": "Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "EuclideanMultiplicativeInverse(e,q2)",
            "m",
            "q"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EuclideanMultiplicativeInverse",
          "args": [
            "e",
            "q2"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "EuclideanMultiplicativeInverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "69-70",
          "snippet": "inline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)\n\t{return a.InverseMod(b);}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)\n\t{return a.InverseMod(b);}"
        }
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "d",
            "q"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "EuclideanMultiplicativeInverse(e,p2)",
            "m",
            "p"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q, const Integer &u)\n{\n\tInteger d = (m*m-4);\n\tInteger p2, q2;\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tp2 = p-Jacobi(d,p);\n\t\t\t\tp2 = Lucas(EuclideanMultiplicativeInverse(e,p2), m, p);\n\t\t\t}\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tq2 = q-Jacobi(d,q);\n\t\t\t\tq2 = Lucas(EuclideanMultiplicativeInverse(e,q2), m, q);\n\t\t\t}\n\t\t}\n\treturn CRT(p2, p, q2, q, u);\n}"
  },
  {
    "function_name": "Lucas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "812-841",
    "snippet": "Integer Lucas(const Integer &e, const Integer &pIn, const Integer &n)\n{\n\tunsigned i = e.BitCount();\n\tif (i==0)\n\t\treturn Integer::Two();\n\n\tMontgomeryRepresentation m(n);\n\tInteger p=m.ConvertIn(pIn%n), two=m.ConvertIn(Integer::Two());\n\tInteger v=p, v1=m.Subtract(m.Square(p), two);\n\n\ti--;\n\twhile (i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\t// v = (v*v1 - p) % m;\n\t\t\tv = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v1 = (v1*v1 - 2) % m;\n\t\t\tv1 = m.Subtract(m.Square(v1), two);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// v1 = (v*v1 - p) % m;\n\t\t\tv1 = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v = (v*v - 2) % m;\n\t\t\tv = m.Subtract(m.Square(v), two);\n\t\t}\n\t}\n\treturn m.ConvertOut(v);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m.ConvertOut",
          "args": [
            "v"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertOut",
          "container": "DL_GroupPrecomputation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eprecomp.h",
          "lines": "18-18",
          "snippet": "virtual Element ConvertOut(const Element &v) const {return v;}",
          "includes": [
            "#include \"eprecomp.cpp\"",
            "#include <vector>",
            "#include \"algebra.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eprecomp.cpp\"\n#include <vector>\n#include \"algebra.h\"\n#include \"integer.h\"\n\nDL_GroupPrecomputation {\n  virtual Element ConvertOut(const Element &v) const {return v;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m.Subtract",
          "args": [
            "m.Square(v)",
            "two"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "Subtract",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "35-36",
          "snippet": "Element Subtract(Element a, Element b) const\n\t\t{return a^b;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Subtract(Element a, Element b) const\n  \t\t{return a^b;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m.Square",
          "args": [
            "v"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "Square",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "49-50",
          "snippet": "Element Square(Element a) const\n\t\t{return Multiply(a, a);}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Square(Element a) const\n  \t\t{return Multiply(a, a);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m.Multiply",
          "args": [
            "v",
            "v1"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "Multiply",
          "container": "Word",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "309-314",
          "snippet": "static Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nWord {\n  static Word Multiply(hword a, hword b)\n  \t{\n  \t\tWord r;\n  \t\tr.m_whole = (word)a * b;\n  \t\treturn r;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "e.GetBit",
          "args": [
            "i"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m.ConvertIn",
          "args": [
            "Integer::Two()"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertIn",
          "container": "DL_GroupPrecomputation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eprecomp.h",
          "lines": "17-17",
          "snippet": "virtual Element ConvertIn(const Element &v) const {return v;}",
          "includes": [
            "#include \"eprecomp.cpp\"",
            "#include <vector>",
            "#include \"algebra.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"eprecomp.cpp\"\n#include <vector>\n#include \"algebra.h\"\n#include \"integer.h\"\n\nDL_GroupPrecomputation {\n  virtual Element ConvertIn(const Element &v) const {return v;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Two",
          "args": [],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer::Two",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.BitCount",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger Lucas(const Integer &e, const Integer &pIn, const Integer &n)\n{\n\tunsigned i = e.BitCount();\n\tif (i==0)\n\t\treturn Integer::Two();\n\n\tMontgomeryRepresentation m(n);\n\tInteger p=m.ConvertIn(pIn%n), two=m.ConvertIn(Integer::Two());\n\tInteger v=p, v1=m.Subtract(m.Square(p), two);\n\n\ti--;\n\twhile (i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\t// v = (v*v1 - p) % m;\n\t\t\tv = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v1 = (v1*v1 - 2) % m;\n\t\t\tv1 = m.Subtract(m.Square(v1), two);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// v1 = (v*v1 - p) % m;\n\t\t\tv1 = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v = (v*v - 2) % m;\n\t\t\tv = m.Subtract(m.Square(v), two);\n\t\t}\n\t}\n\treturn m.ConvertOut(v);\n}"
  },
  {
    "function_name": "Jacobi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "785-810",
    "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::swap",
          "args": [
            "a",
            "b"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "453-456",
          "snippet": "inline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\ninline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "a.GetBit",
          "args": [
            "i"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bIn.IsOdd()"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bIn.IsOdd",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
  },
  {
    "function_name": "ModularRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "661-669",
    "snippet": "Integer ModularRoot(const Integer &a, const Integer &e,\n\t\t\t\t\tconst Integer &p, const Integer &q)\n{\n\tInteger dp = EuclideanMultiplicativeInverse(e, p-1);\n\tInteger dq = EuclideanMultiplicativeInverse(e, q-1);\n\tInteger u = EuclideanMultiplicativeInverse(p, q);\n\tassert(!!dp && !!dq && !!u);\n\treturn ModularRoot(a, dp, dq, p, q, u);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!!dp && !!dq && !!u"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EuclideanMultiplicativeInverse",
          "args": [
            "p",
            "q"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "EuclideanMultiplicativeInverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "69-70",
          "snippet": "inline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)\n\t{return a.InverseMod(b);}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)\n\t{return a.InverseMod(b);}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger ModularRoot(const Integer &a, const Integer &e,\n\t\t\t\t\tconst Integer &p, const Integer &q)\n{\n\tInteger dp = EuclideanMultiplicativeInverse(e, p-1);\n\tInteger dq = EuclideanMultiplicativeInverse(e, q-1);\n\tInteger u = EuclideanMultiplicativeInverse(p, q);\n\tassert(!!dp && !!dq && !!u);\n\treturn ModularRoot(a, dp, dq, p, q, u);\n}"
  },
  {
    "function_name": "ModularRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "646-659",
    "snippet": "Integer ModularRoot(const Integer &a, const Integer &dp, const Integer &dq,\n\t\t\t\t\tconst Integer &p, const Integer &q, const Integer &u)\n{\n\tInteger p2, q2;\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tp2 = ModularExponentiation((a % p), dp, p);\n\t\t\t#pragma omp section\n\t\t\t\tq2 = ModularExponentiation((a % q), dq, q);\n\t\t}\n\treturn CRT(p2, p, q2, q, u);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRT",
          "args": [
            "p2",
            "p",
            "q2",
            "q",
            "u"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "CRT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "553-570",
          "snippet": "Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "ModularExponentiation",
          "args": [
            "(a % q)",
            "dq",
            "q"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ModularExponentiation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "84-85",
          "snippet": "inline Integer ModularExponentiation(const Integer &a, const Integer &e, const Integer &m)\n\t{return a_exp_b_mod_c(a, e, m);}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline Integer ModularExponentiation(const Integer &a, const Integer &e, const Integer &m)\n\t{return a_exp_b_mod_c(a, e, m);}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger ModularRoot(const Integer &a, const Integer &dp, const Integer &dq,\n\t\t\t\t\tconst Integer &p, const Integer &q, const Integer &u)\n{\n\tInteger p2, q2;\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tp2 = ModularExponentiation((a % p), dp, p);\n\t\t\t#pragma omp section\n\t\t\t\tq2 = ModularExponentiation((a % q), dq, q);\n\t\t}\n\treturn CRT(p2, p, q2, q, u);\n}"
  },
  {
    "function_name": "SolveModularQuadraticEquation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "621-644",
    "snippet": "bool SolveModularQuadraticEquation(Integer &r1, Integer &r2, const Integer &a, const Integer &b, const Integer &c, const Integer &p)\n{\n\tInteger D = (b.Squared() - 4*a*c) % p;\n\tswitch (Jacobi(D, p))\n\t{\n\tdefault:\n\t\tassert(false);\t// not reached\n\t\treturn false;\n\tcase -1:\n\t\treturn false;\n\tcase 0:\n\t\tr1 = r2 = (-b*(a+a).InverseMod(p)) % p;\n\t\tassert(((r1.Squared()*a + r1*b + c) % p).IsZero());\n\t\treturn true;\n\tcase 1:\n\t\tInteger s = ModularSquareRoot(D, p);\n\t\tInteger t = (a+a).InverseMod(p);\n\t\tr1 = (s-b)*t % p;\n\t\tr2 = (-s-b)*t % p;\n\t\tassert(((r1.Squared()*a + r1*b + c) % p).IsZero());\n\t\tassert(((r2.Squared()*a + r2*b + c) % p).IsZero());\n\t\treturn true;\n\t}\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "((r2.Squared()*a + r2*b + c) % p).IsZero()"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r2.Squared",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "((r1.Squared()*a + r1*b + c) % p).IsZero()"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "p"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModularSquareRoot",
          "args": [
            "D",
            "p"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ModularSquareRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "572-619",
          "snippet": "Integer ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "((r1.Squared()*a + r1*b + c) % p).IsZero()"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "p"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "D",
            "p"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool SolveModularQuadraticEquation(Integer &r1, Integer &r2, const Integer &a, const Integer &b, const Integer &c, const Integer &p)\n{\n\tInteger D = (b.Squared() - 4*a*c) % p;\n\tswitch (Jacobi(D, p))\n\t{\n\tdefault:\n\t\tassert(false);\t// not reached\n\t\treturn false;\n\tcase -1:\n\t\treturn false;\n\tcase 0:\n\t\tr1 = r2 = (-b*(a+a).InverseMod(p)) % p;\n\t\tassert(((r1.Squared()*a + r1*b + c) % p).IsZero());\n\t\treturn true;\n\tcase 1:\n\t\tInteger s = ModularSquareRoot(D, p);\n\t\tInteger t = (a+a).InverseMod(p);\n\t\tr1 = (s-b)*t % p;\n\t\tr2 = (-s-b)*t % p;\n\t\tassert(((r1.Squared()*a + r1*b + c) % p).IsZero());\n\t\tassert(((r2.Squared()*a + r2*b + c) % p).IsZero());\n\t\treturn true;\n\t}\n}"
  },
  {
    "function_name": "ModularSquareRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "572-619",
    "snippet": "Integer ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "x.Squared()%p == a"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x.Squared",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Zero",
          "args": [],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "Zero",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "23-24",
          "snippet": "Element Zero() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Zero() const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "a",
            "(q-1)/2",
            "p"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "n",
            "q",
            "p"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "n",
            "p"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "q.IsEven",
          "args": [],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "IsEven",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "209-209",
          "snippet": "bool IsEven() const {return GetBit(0) == 0;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsEven() const {return GetBit(0) == 0;}"
        }
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "a",
            "(p+1)/4",
            "p"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}"
  },
  {
    "function_name": "CRT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "553-570",
    "snippet": "Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}"
  },
  {
    "function_name": "MaurerProvablePrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "510-551",
    "snippet": "Integer MaurerProvablePrime(RandomNumberGenerator &rng, unsigned int bits)\n{\n\tconst unsigned smallPrimeBound = 29, c_opt=10;\n\tInteger p;\n\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (bits < smallPrimeBound)\n\t{\n\t\tdo\n\t\t\tp.Randomize(rng, Integer::Power2(bits-1), Integer::Power2(bits)-1, Integer::ANY, 1, 2);\n\t\twhile (TrialDivision(p, 1 << ((bits+1)/2)));\n\t}\n\telse\n\t{\n\t\tconst unsigned margin = bits > 50 ? 20 : (bits-10)/2;\n\t\tdouble relativeSize;\n\t\tdo\n\t\t\trelativeSize = pow(2.0, double(rng.GenerateWord32())/0xffffffff - 1);\n\t\twhile (bits * relativeSize >= bits - margin);\n\n\t\tInteger a,b;\n\t\tInteger q = MaurerProvablePrime(rng, unsigned(bits*relativeSize));\n\t\tInteger I = Integer::Power2(bits-2)/q;\n\t\tInteger I2 = I << 1;\n\t\tunsigned int trialDivisorBound = (unsigned int)STDMIN((unsigned long)primeTable[primeTableSize-1], (unsigned long)bits*bits/c_opt);\n\t\tbool success = false;\n\t\twhile (!success)\n\t\t{\n\t\t\tp.Randomize(rng, I, I2, Integer::ANY);\n\t\t\tp *= q; p <<= 1; ++p;\n\t\t\tif (!TrialDivision(p, trialDivisorBound))\n\t\t\t{\n\t\t\t\ta.Randomize(rng, 2, p-1, Integer::ANY);\n\t\t\t\tb = a_exp_b_mod_c(a, (p-1)/q, p);\n\t\t\t\tsuccess = (GCD(b-1, p) == 1) && (a_exp_b_mod_c(b, q, p) == 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "b",
            "q",
            "p"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GCD",
          "args": [
            "b-1",
            "p"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "GCD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "63-64",
          "snippet": "inline Integer GCD(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b);}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline Integer GCD(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b);}"
        }
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "a",
            "(p-1)/q",
            "p"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a.Randomize",
          "args": [
            "rng",
            "2",
            "p-1",
            "Integer::ANY"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TrialDivision",
          "args": [
            "p",
            "trialDivisorBound"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "TrialDivision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "71-87",
          "snippet": "bool TrialDivision(const Integer &p, unsigned bound)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTable[primeTableSize-1] >= bound);\n\n\tunsigned int i;\n\tfor (i = 0; primeTable[i]<bound; i++)\n\t\tif ((p % primeTable[i]) == 0)\n\t\t\treturn true;\n\n\tif (bound == primeTable[i])\n\t\treturn (p % bound == 0);\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool TrialDivision(const Integer &p, unsigned bound)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTable[primeTableSize-1] >= bound);\n\n\tunsigned int i;\n\tfor (i = 0; primeTable[i]<bound; i++)\n\t\tif ((p % primeTable[i]) == 0)\n\t\t\treturn true;\n\n\tif (bound == primeTable[i])\n\t\treturn (p % bound == 0);\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p.Randomize",
          "args": [
            "rng",
            "I",
            "I2",
            "Integer::ANY"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "(unsigned long)primeTable[primeTableSize-1]",
            "(unsigned long)bits*bits/c_opt"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer::Power2",
          "args": [
            "bits-2"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Power2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2846-2851",
          "snippet": "Integer Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unsigned",
          "args": [
            "bits*relativeSize"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "2.0",
            "double(rng.GenerateWord32())/0xffffffff - 1"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "double",
          "args": [
            "rng.GenerateWord32()"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rng.GenerateWord32",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.Randomize",
          "args": [
            "rng",
            "Integer::Power2(bits-1)",
            "Integer::Power2(bits)-1",
            "Integer::ANY",
            "1",
            "2"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPrimeTable",
          "args": [
            "primeTableSize"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger MaurerProvablePrime(RandomNumberGenerator &rng, unsigned int bits)\n{\n\tconst unsigned smallPrimeBound = 29, c_opt=10;\n\tInteger p;\n\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (bits < smallPrimeBound)\n\t{\n\t\tdo\n\t\t\tp.Randomize(rng, Integer::Power2(bits-1), Integer::Power2(bits)-1, Integer::ANY, 1, 2);\n\t\twhile (TrialDivision(p, 1 << ((bits+1)/2)));\n\t}\n\telse\n\t{\n\t\tconst unsigned margin = bits > 50 ? 20 : (bits-10)/2;\n\t\tdouble relativeSize;\n\t\tdo\n\t\t\trelativeSize = pow(2.0, double(rng.GenerateWord32())/0xffffffff - 1);\n\t\twhile (bits * relativeSize >= bits - margin);\n\n\t\tInteger a,b;\n\t\tInteger q = MaurerProvablePrime(rng, unsigned(bits*relativeSize));\n\t\tInteger I = Integer::Power2(bits-2)/q;\n\t\tInteger I2 = I << 1;\n\t\tunsigned int trialDivisorBound = (unsigned int)STDMIN((unsigned long)primeTable[primeTableSize-1], (unsigned long)bits*bits/c_opt);\n\t\tbool success = false;\n\t\twhile (!success)\n\t\t{\n\t\t\tp.Randomize(rng, I, I2, Integer::ANY);\n\t\t\tp *= q; p <<= 1; ++p;\n\t\t\tif (!TrialDivision(p, trialDivisorBound))\n\t\t\t{\n\t\t\t\ta.Randomize(rng, 2, p-1, Integer::ANY);\n\t\t\t\tb = a_exp_b_mod_c(a, (p-1)/q, p);\n\t\t\t\tsuccess = (GCD(b-1, p) == 1) && (a_exp_b_mod_c(b, q, p) == 1);\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "MihailescuProvablePrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "470-508",
    "snippet": "Integer MihailescuProvablePrime(RandomNumberGenerator &rng, unsigned int pbits)\n{\n\tInteger p;\n\tInteger minP = Integer::Power2(pbits-1);\n\tInteger maxP = Integer::Power2(pbits) - 1;\n\n\tif (maxP <= Integer(s_lastSmallPrime).Squared())\n\t{\n\t\t// Randomize() will generate a prime provable by trial division\n\t\tp.Randomize(rng, minP, maxP, Integer::PRIME);\n\t\treturn p;\n\t}\n\n\tunsigned int qbits = (pbits+2)/3 + 1 + rng.GenerateWord32(0, pbits/36);\n\tInteger q = MihailescuProvablePrime(rng, qbits);\n\tInteger q2 = q<<1;\n\n\twhile (true)\n\t{\n\t\t// this initializes the sieve to search in the arithmetic\n\t\t// progression p = p_0 + \\lambda * q2 = p_0 + 2 * \\lambda * q,\n\t\t// with q the recursively generated prime above. We will be able\n\t\t// to use Lucas tets for proving primality. A trick of Quisquater\n\t\t// allows taking q > cubic_root(p) rather then square_root: this\n\t\t// decreases the recursion.\n\n\t\tp.Randomize(rng, minP, maxP, Integer::ANY, 1, q2);\n\t\tPrimeSieve sieve(p, STDMIN(p+PrimeSearchInterval(maxP)*q2, maxP), q2);\n\n\t\twhile (sieve.NextCandidate(p))\n\t\t{\n\t\t\tif (FastProbablePrimeTest(p) && ProvePrime(p, q))\n\t\t\t\treturn p;\n\t\t}\n\t}\n\n\t// not reached\n\treturn p;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProvePrime",
          "args": [
            "p",
            "q"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "ProvePrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "443-468",
          "snippet": "static bool ProvePrime(const Integer &p, const Integer &q)\n{\n\tassert(p < q*q*q);\n\tassert(p % q == 1);\n\n// this is the Quisquater test. Numbers p having passed the Lucas - Lehmer test\n// for q and verifying p < q^3 can only be built up of two factors, both = 1 mod q,\n// or be prime. The next two lines build the discriminant of a quadratic equation\n// which holds iff p is built up of two factors (excercise ... )\n\n\tInteger r = (p-1)/q;\n\tif (((r%q).Squared()-4*(r/q)).IsSquare())\n\t\treturn false;\n\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTableSize >= 50);\n\tfor (int i=0; i<50; i++) \n\t{\n\t\tInteger b = a_exp_b_mod_c(primeTable[i], r, p);\n\t\tif (b != 1) \n\t\t\treturn a_exp_b_mod_c(b, q, p) == 1;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nstatic bool ProvePrime(const Integer &p, const Integer &q)\n{\n\tassert(p < q*q*q);\n\tassert(p % q == 1);\n\n// this is the Quisquater test. Numbers p having passed the Lucas - Lehmer test\n// for q and verifying p < q^3 can only be built up of two factors, both = 1 mod q,\n// or be prime. The next two lines build the discriminant of a quadratic equation\n// which holds iff p is built up of two factors (excercise ... )\n\n\tInteger r = (p-1)/q;\n\tif (((r%q).Squared()-4*(r/q)).IsSquare())\n\t\treturn false;\n\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTableSize >= 50);\n\tfor (int i=0; i<50; i++) \n\t{\n\t\tInteger b = a_exp_b_mod_c(primeTable[i], r, p);\n\t\tif (b != 1) \n\t\t\treturn a_exp_b_mod_c(b, q, p) == 1;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FastProbablePrimeTest",
          "args": [
            "p"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "FastProbablePrimeTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "260-263",
          "snippet": "static inline bool FastProbablePrimeTest(const Integer &n)\n{\n\treturn IsStrongProbablePrime(n,2);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nstatic inline bool FastProbablePrimeTest(const Integer &n)\n{\n\treturn IsStrongProbablePrime(n,2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sieve.NextCandidate",
          "args": [
            "p"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "p+PrimeSearchInterval(maxP)*q2",
            "maxP"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrimeSearchInterval",
          "args": [
            "maxP"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "PrimeSearchInterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "255-258",
          "snippet": "unsigned int PrimeSearchInterval(const Integer &max)\n{\n\treturn max.BitCount();\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nunsigned int PrimeSearchInterval(const Integer &max)\n{\n\treturn max.BitCount();\n}"
        }
      },
      {
        "call_info": {
          "callee": "p.Randomize",
          "args": [
            "rng",
            "minP",
            "maxP",
            "Integer::ANY",
            "1",
            "q2"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rng.GenerateWord32",
          "args": [
            "0",
            "pbits/36"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.Randomize",
          "args": [
            "rng",
            "minP",
            "maxP",
            "Integer::PRIME"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2757-2761",
          "snippet": "Integer::Integer()\n\t: reg(2), sign(POSITIVE)\n{\n\treg[0] = reg[1] = 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger::Integer()\n\t: reg(2), sign(POSITIVE)\n{\n\treg[0] = reg[1] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Power2",
          "args": [
            "pbits"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Power2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2846-2851",
          "snippet": "Integer Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger MihailescuProvablePrime(RandomNumberGenerator &rng, unsigned int pbits)\n{\n\tInteger p;\n\tInteger minP = Integer::Power2(pbits-1);\n\tInteger maxP = Integer::Power2(pbits) - 1;\n\n\tif (maxP <= Integer(s_lastSmallPrime).Squared())\n\t{\n\t\t// Randomize() will generate a prime provable by trial division\n\t\tp.Randomize(rng, minP, maxP, Integer::PRIME);\n\t\treturn p;\n\t}\n\n\tunsigned int qbits = (pbits+2)/3 + 1 + rng.GenerateWord32(0, pbits/36);\n\tInteger q = MihailescuProvablePrime(rng, qbits);\n\tInteger q2 = q<<1;\n\n\twhile (true)\n\t{\n\t\t// this initializes the sieve to search in the arithmetic\n\t\t// progression p = p_0 + \\lambda * q2 = p_0 + 2 * \\lambda * q,\n\t\t// with q the recursively generated prime above. We will be able\n\t\t// to use Lucas tets for proving primality. A trick of Quisquater\n\t\t// allows taking q > cubic_root(p) rather then square_root: this\n\t\t// decreases the recursion.\n\n\t\tp.Randomize(rng, minP, maxP, Integer::ANY, 1, q2);\n\t\tPrimeSieve sieve(p, STDMIN(p+PrimeSearchInterval(maxP)*q2, maxP), q2);\n\n\t\twhile (sieve.NextCandidate(p))\n\t\t{\n\t\t\tif (FastProbablePrimeTest(p) && ProvePrime(p, q))\n\t\t\t\treturn p;\n\t\t}\n\t}\n\n\t// not reached\n\treturn p;\n}"
  },
  {
    "function_name": "ProvePrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "443-468",
    "snippet": "static bool ProvePrime(const Integer &p, const Integer &q)\n{\n\tassert(p < q*q*q);\n\tassert(p % q == 1);\n\n// this is the Quisquater test. Numbers p having passed the Lucas - Lehmer test\n// for q and verifying p < q^3 can only be built up of two factors, both = 1 mod q,\n// or be prime. The next two lines build the discriminant of a quadratic equation\n// which holds iff p is built up of two factors (excercise ... )\n\n\tInteger r = (p-1)/q;\n\tif (((r%q).Squared()-4*(r/q)).IsSquare())\n\t\treturn false;\n\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTableSize >= 50);\n\tfor (int i=0; i<50; i++) \n\t{\n\t\tInteger b = a_exp_b_mod_c(primeTable[i], r, p);\n\t\tif (b != 1) \n\t\t\treturn a_exp_b_mod_c(b, q, p) == 1;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "b",
            "q",
            "p"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "primeTable[i]",
            "r",
            "p"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "primeTableSize >= 50"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPrimeTable",
          "args": [
            "primeTableSize"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p % q == 1"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p < q*q*q"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nstatic bool ProvePrime(const Integer &p, const Integer &q)\n{\n\tassert(p < q*q*q);\n\tassert(p % q == 1);\n\n// this is the Quisquater test. Numbers p having passed the Lucas - Lehmer test\n// for q and verifying p < q^3 can only be built up of two factors, both = 1 mod q,\n// or be prime. The next two lines build the discriminant of a quadratic equation\n// which holds iff p is built up of two factors (excercise ... )\n\n\tInteger r = (p-1)/q;\n\tif (((r%q).Squared()-4*(r/q)).IsSquare())\n\t\treturn false;\n\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTableSize >= 50);\n\tfor (int i=0; i<50; i++) \n\t{\n\t\tInteger b = a_exp_b_mod_c(primeTable[i], r, p);\n\t\tif (b != 1) \n\t\t\treturn a_exp_b_mod_c(b, q, p) == 1;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "FirstPrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "379-440",
    "snippet": "bool FirstPrime(Integer &p, const Integer &max, const Integer &equiv, const Integer &mod, const PrimeSelector *pSelector)\n{\n\tassert(!equiv.IsNegative() && equiv < mod);\n\n\tInteger gcd = GCD(equiv, mod);\n\tif (gcd != Integer::One())\n\t{\n\t\t// the only possible prime p such that p%mod==equiv where GCD(mod,equiv)!=1 is GCD(mod,equiv)\n\t\tif (p <= gcd && gcd <= max && IsPrime(gcd) && (!pSelector || pSelector->IsAcceptable(gcd)))\n\t\t{\n\t\t\tp = gcd;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (p <= primeTable[primeTableSize-1])\n\t{\n\t\tconst word16 *pItr;\n\n\t\t--p;\n\t\tif (p.IsPositive())\n\t\t\tpItr = std::upper_bound(primeTable, primeTable+primeTableSize, (word)p.ConvertToLong());\n\t\telse\n\t\t\tpItr = primeTable;\n\n\t\twhile (pItr < primeTable+primeTableSize && !(*pItr%mod == equiv && (!pSelector || pSelector->IsAcceptable(*pItr))))\n\t\t\t++pItr;\n\n\t\tif (pItr < primeTable+primeTableSize)\n\t\t{\n\t\t\tp = *pItr;\n\t\t\treturn p <= max;\n\t\t}\n\n\t\tp = primeTable[primeTableSize-1]+1;\n\t}\n\n\tassert(p > primeTable[primeTableSize-1]);\n\n\tif (mod.IsOdd())\n\t\treturn FirstPrime(p, max, CRT(equiv, mod, 1, 2, 1), mod<<1, pSelector);\n\n\tp += (equiv-p)%mod;\n\n\tif (p>max)\n\t\treturn false;\n\n\tPrimeSieve sieve(p, max, mod);\n\n\twhile (sieve.NextCandidate(p))\n\t{\n\t\tif ((!pSelector || pSelector->IsAcceptable(p)) && FastProbablePrimeTest(p) && IsPrime(p))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsPrime",
          "args": [
            "p"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "IsPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "237-245",
          "snippet": "bool IsPrime(const Integer &p)\n{\n\tif (p <= s_lastSmallPrime)\n\t\treturn IsSmallPrime(p);\n\telse if (p <= Singleton<Integer, NewLastSmallPrimeSquared>().Ref())\n\t\treturn SmallDivisorsTest(p);\n\telse\n\t\treturn SmallDivisorsTest(p) && IsStrongProbablePrime(p, 3) && IsStrongLucasProbablePrime(p);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsPrime(const Integer &p)\n{\n\tif (p <= s_lastSmallPrime)\n\t\treturn IsSmallPrime(p);\n\telse if (p <= Singleton<Integer, NewLastSmallPrimeSquared>().Ref())\n\t\treturn SmallDivisorsTest(p);\n\telse\n\t\treturn SmallDivisorsTest(p) && IsStrongProbablePrime(p, 3) && IsStrongLucasProbablePrime(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FastProbablePrimeTest",
          "args": [
            "p"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "FastProbablePrimeTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "260-263",
          "snippet": "static inline bool FastProbablePrimeTest(const Integer &n)\n{\n\treturn IsStrongProbablePrime(n,2);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nstatic inline bool FastProbablePrimeTest(const Integer &n)\n{\n\treturn IsStrongProbablePrime(n,2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pSelector->IsAcceptable",
          "args": [
            "p"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "IsAcceptable",
          "container": "LUCPrimeSelector",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
          "lines": "100-103",
          "snippet": "bool IsAcceptable(const Integer &candidate) const\n\t{\n\t\treturn RelativelyPrime(m_e, candidate+1) && RelativelyPrime(m_e, candidate-1);\n\t}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"sha.h\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"luc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCPrimeSelector {\n  bool IsAcceptable(const Integer &candidate) const\n  \t{\n  \t\treturn RelativelyPrime(m_e, candidate+1) && RelativelyPrime(m_e, candidate-1);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sieve.NextCandidate",
          "args": [
            "p"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FirstPrime",
          "args": [
            "p",
            "max",
            "CRT(equiv, mod, 1, 2, 1)",
            "mod<<1",
            "pSelector"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRT",
          "args": [
            "equiv",
            "mod",
            "1",
            "2",
            "1"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "CRT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "553-570",
          "snippet": "Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod.IsOdd",
          "args": [],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p > primeTable[primeTableSize-1]"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::upper_bound",
          "args": [
            "primeTable",
            "primeTable+primeTableSize",
            "(word)p.ConvertToLong()"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.ConvertToLong",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.IsPositive",
          "args": [],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "IsPositive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "205-205",
          "snippet": "bool IsPositive() const {return NotNegative() && NotZero();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsPositive() const {return NotNegative() && NotZero();}"
        }
      },
      {
        "call_info": {
          "callee": "GetPrimeTable",
          "args": [
            "primeTableSize"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GCD",
          "args": [
            "equiv",
            "mod"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "GCD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "63-64",
          "snippet": "inline Integer GCD(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b);}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline Integer GCD(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b);}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!equiv.IsNegative() && equiv < mod"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equiv.IsNegative",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "IsNegative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "201-201",
          "snippet": "bool IsNegative() const {return sign == NEGATIVE;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsNegative() const {return sign == NEGATIVE;}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool FirstPrime(Integer &p, const Integer &max, const Integer &equiv, const Integer &mod, const PrimeSelector *pSelector)\n{\n\tassert(!equiv.IsNegative() && equiv < mod);\n\n\tInteger gcd = GCD(equiv, mod);\n\tif (gcd != Integer::One())\n\t{\n\t\t// the only possible prime p such that p%mod==equiv where GCD(mod,equiv)!=1 is GCD(mod,equiv)\n\t\tif (p <= gcd && gcd <= max && IsPrime(gcd) && (!pSelector || pSelector->IsAcceptable(gcd)))\n\t\t{\n\t\t\tp = gcd;\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (p <= primeTable[primeTableSize-1])\n\t{\n\t\tconst word16 *pItr;\n\n\t\t--p;\n\t\tif (p.IsPositive())\n\t\t\tpItr = std::upper_bound(primeTable, primeTable+primeTableSize, (word)p.ConvertToLong());\n\t\telse\n\t\t\tpItr = primeTable;\n\n\t\twhile (pItr < primeTable+primeTableSize && !(*pItr%mod == equiv && (!pSelector || pSelector->IsAcceptable(*pItr))))\n\t\t\t++pItr;\n\n\t\tif (pItr < primeTable+primeTableSize)\n\t\t{\n\t\t\tp = *pItr;\n\t\t\treturn p <= max;\n\t\t}\n\n\t\tp = primeTable[primeTableSize-1]+1;\n\t}\n\n\tassert(p > primeTable[primeTableSize-1]);\n\n\tif (mod.IsOdd())\n\t\treturn FirstPrime(p, max, CRT(equiv, mod, 1, 2, 1), mod<<1, pSelector);\n\n\tp += (equiv-p)%mod;\n\n\tif (p>max)\n\t\treturn false;\n\n\tPrimeSieve sieve(p, max, mod);\n\n\twhile (sieve.NextCandidate(p))\n\t{\n\t\tif ((!pSelector || pSelector->IsAcceptable(p)) && FastProbablePrimeTest(p) && IsPrime(p))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "PrimeSieve::DoSieve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "346-377",
    "snippet": "void PrimeSieve::DoSieve()\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tconst unsigned int maxSieveSize = 32768;\n\tunsigned int sieveSize = STDMIN(Integer(maxSieveSize), (m_last-m_first)/m_step+1).ConvertToLong();\n\n\tm_sieve.clear();\n\tm_sieve.resize(sieveSize, false);\n\n\tif (m_delta == 0)\n\t{\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t\tSieveSingle(m_sieve, primeTable[i], m_first, m_step, (word16)m_step.InverseMod(primeTable[i]));\n\t}\n\telse\n\t{\n\t\tassert(m_step%2==0);\n\t\tInteger qFirst = (m_first-m_delta) >> 1;\n\t\tInteger halfStep = m_step >> 1;\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t{\n\t\t\tword16 p = primeTable[i];\n\t\t\tword16 stepInv = (word16)m_step.InverseMod(p);\n\t\t\tSieveSingle(m_sieve, p, m_first, m_step, stepInv);\n\n\t\t\tword16 halfStepInv = 2*stepInv < p ? 2*stepInv : 2*stepInv-p;\n\t\t\tSieveSingle(m_sieve, p, qFirst, halfStep, halfStepInv);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SieveSingle",
          "args": [
            "m_sieve",
            "p",
            "qFirst",
            "halfStep",
            "halfStepInv"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "PrimeSieve::SieveSingle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "332-344",
          "snippet": "void PrimeSieve::SieveSingle(std::vector<bool> &sieve, word16 p, const Integer &first, const Integer &step, word16 stepInv)\n{\n\tif (stepInv)\n\t{\n\t\tsize_t sieveSize = sieve.size();\n\t\tsize_t j = (word32(p-(first%p))*stepInv) % p;\n\t\t// if the first multiple of p is p, skip it\n\t\tif (first.WordCount() <= 1 && first + step*long(j) == p)\n\t\t\tj += p;\n\t\tfor (; j < sieveSize; j += p)\n\t\t\tsieve[j] = true;\n\t}\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nvoid PrimeSieve::SieveSingle(std::vector<bool> &sieve, word16 p, const Integer &first, const Integer &step, word16 stepInv)\n{\n\tif (stepInv)\n\t{\n\t\tsize_t sieveSize = sieve.size();\n\t\tsize_t j = (word32(p-(first%p))*stepInv) % p;\n\t\t// if the first multiple of p is p, skip it\n\t\tif (first.WordCount() <= 1 && first + step*long(j) == p)\n\t\t\tj += p;\n\t\tfor (; j < sieveSize; j += p)\n\t\t\tsieve[j] = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_step.InverseMod",
          "args": [
            "p"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_step%2==0"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_step.InverseMod",
          "args": [
            "primeTable[i]"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sieve.resize",
          "args": [
            "sieveSize",
            "false"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sieve.clear",
          "args": [],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "Integer(maxSieveSize)",
            "(m_last-m_first)/m_step+1"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "maxSieveSize"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3034-3038",
          "snippet": "Integer::Integer(const wchar_t *str)\n\t: reg(2), sign(POSITIVE)\n{\n\t*this = StringToInteger(str);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger::Integer(const wchar_t *str)\n\t: reg(2), sign(POSITIVE)\n{\n\t*this = StringToInteger(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetPrimeTable",
          "args": [
            "primeTableSize"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nvoid PrimeSieve::DoSieve()\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tconst unsigned int maxSieveSize = 32768;\n\tunsigned int sieveSize = STDMIN(Integer(maxSieveSize), (m_last-m_first)/m_step+1).ConvertToLong();\n\n\tm_sieve.clear();\n\tm_sieve.resize(sieveSize, false);\n\n\tif (m_delta == 0)\n\t{\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t\tSieveSingle(m_sieve, primeTable[i], m_first, m_step, (word16)m_step.InverseMod(primeTable[i]));\n\t}\n\telse\n\t{\n\t\tassert(m_step%2==0);\n\t\tInteger qFirst = (m_first-m_delta) >> 1;\n\t\tInteger halfStep = m_step >> 1;\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t{\n\t\t\tword16 p = primeTable[i];\n\t\t\tword16 stepInv = (word16)m_step.InverseMod(p);\n\t\t\tSieveSingle(m_sieve, p, m_first, m_step, stepInv);\n\n\t\t\tword16 halfStepInv = 2*stepInv < p ? 2*stepInv : 2*stepInv-p;\n\t\t\tSieveSingle(m_sieve, p, qFirst, halfStep, halfStepInv);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "PrimeSieve::SieveSingle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "332-344",
    "snippet": "void PrimeSieve::SieveSingle(std::vector<bool> &sieve, word16 p, const Integer &first, const Integer &step, word16 stepInv)\n{\n\tif (stepInv)\n\t{\n\t\tsize_t sieveSize = sieve.size();\n\t\tsize_t j = (word32(p-(first%p))*stepInv) % p;\n\t\t// if the first multiple of p is p, skip it\n\t\tif (first.WordCount() <= 1 && first + step*long(j) == p)\n\t\t\tj += p;\n\t\tfor (; j < sieveSize; j += p)\n\t\t\tsieve[j] = true;\n\t}\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "long",
          "args": [
            "j"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "first.WordCount",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "p-(first%p)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sieve.size",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nvoid PrimeSieve::SieveSingle(std::vector<bool> &sieve, word16 p, const Integer &first, const Integer &step, word16 stepInv)\n{\n\tif (stepInv)\n\t{\n\t\tsize_t sieveSize = sieve.size();\n\t\tsize_t j = (word32(p-(first%p))*stepInv) % p;\n\t\t// if the first multiple of p is p, skip it\n\t\tif (first.WordCount() <= 1 && first + step*long(j) == p)\n\t\t\tj += p;\n\t\tfor (; j < sieveSize; j += p)\n\t\t\tsieve[j] = true;\n\t}\n}"
  },
  {
    "function_name": "PrimeSieve::NextCandidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "308-330",
    "snippet": "bool PrimeSieve::NextCandidate(Integer &c)\n{\n\tbool safe = SafeConvert(std::find(m_sieve.begin()+m_next, m_sieve.end(), false) - m_sieve.begin(), m_next);\n\tassert(safe);\n\tif (m_next == m_sieve.size())\n\t{\n\t\tm_first += long(m_sieve.size())*m_step;\n\t\tif (m_first > m_last)\n\t\t\treturn false;\n\t\telse\n\t\t{\n\t\t\tm_next = 0;\n\t\t\tDoSieve();\n\t\t\treturn NextCandidate(c);\n\t\t}\n\t}\n\telse\n\t{\n\t\tc = m_first + long(m_next)*m_step;\n\t\t++m_next;\n\t\treturn true;\n\t}\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "long",
          "args": [
            "m_next"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DoSieve",
          "args": [],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "PrimeSieve::DoSieve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "346-377",
          "snippet": "void PrimeSieve::DoSieve()\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tconst unsigned int maxSieveSize = 32768;\n\tunsigned int sieveSize = STDMIN(Integer(maxSieveSize), (m_last-m_first)/m_step+1).ConvertToLong();\n\n\tm_sieve.clear();\n\tm_sieve.resize(sieveSize, false);\n\n\tif (m_delta == 0)\n\t{\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t\tSieveSingle(m_sieve, primeTable[i], m_first, m_step, (word16)m_step.InverseMod(primeTable[i]));\n\t}\n\telse\n\t{\n\t\tassert(m_step%2==0);\n\t\tInteger qFirst = (m_first-m_delta) >> 1;\n\t\tInteger halfStep = m_step >> 1;\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t{\n\t\t\tword16 p = primeTable[i];\n\t\t\tword16 stepInv = (word16)m_step.InverseMod(p);\n\t\t\tSieveSingle(m_sieve, p, m_first, m_step, stepInv);\n\n\t\t\tword16 halfStepInv = 2*stepInv < p ? 2*stepInv : 2*stepInv-p;\n\t\t\tSieveSingle(m_sieve, p, qFirst, halfStep, halfStepInv);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nvoid PrimeSieve::DoSieve()\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tconst unsigned int maxSieveSize = 32768;\n\tunsigned int sieveSize = STDMIN(Integer(maxSieveSize), (m_last-m_first)/m_step+1).ConvertToLong();\n\n\tm_sieve.clear();\n\tm_sieve.resize(sieveSize, false);\n\n\tif (m_delta == 0)\n\t{\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t\tSieveSingle(m_sieve, primeTable[i], m_first, m_step, (word16)m_step.InverseMod(primeTable[i]));\n\t}\n\telse\n\t{\n\t\tassert(m_step%2==0);\n\t\tInteger qFirst = (m_first-m_delta) >> 1;\n\t\tInteger halfStep = m_step >> 1;\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t{\n\t\t\tword16 p = primeTable[i];\n\t\t\tword16 stepInv = (word16)m_step.InverseMod(p);\n\t\t\tSieveSingle(m_sieve, p, m_first, m_step, stepInv);\n\n\t\t\tword16 halfStepInv = 2*stepInv < p ? 2*stepInv : 2*stepInv-p;\n\t\t\tSieveSingle(m_sieve, p, qFirst, halfStep, halfStepInv);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "long",
          "args": [
            "m_sieve.size()"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sieve.size",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "safe"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SafeConvert",
          "args": [
            "std::find(m_sieve.begin()+m_next, m_sieve.end(), false) - m_sieve.begin()",
            "m_next"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "SafeConvert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "299-305",
          "snippet": "inline bool SafeConvert(T1 from, T2 &to)\n{\n\tto = (T2)from;\n\tif (from != to || (from > 0) != (to > 0))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool SafeConvert(T1 from, T2 &to)\n{\n\tto = (T2)from;\n\tif (from != to || (from > 0) != (to > 0))\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_sieve.begin",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::find",
          "args": [
            "m_sieve.begin()+m_next",
            "m_sieve.end()",
            "false"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_sieve.end",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool PrimeSieve::NextCandidate(Integer &c)\n{\n\tbool safe = SafeConvert(std::find(m_sieve.begin()+m_next, m_sieve.end(), false) - m_sieve.begin(), m_next);\n\tassert(safe);\n\tif (m_next == m_sieve.size())\n\t{\n\t\tm_first += long(m_sieve.size())*m_step;\n\t\tif (m_first > m_last)\n\t\t\treturn false;\n\t\telse\n\t\t{\n\t\t\tm_next = 0;\n\t\t\tDoSieve();\n\t\t\treturn NextCandidate(c);\n\t\t}\n\t}\n\telse\n\t{\n\t\tc = m_first + long(m_next)*m_step;\n\t\t++m_next;\n\t\treturn true;\n\t}\n}"
  },
  {
    "function_name": "PrimeSieve::PrimeSieve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "302-306",
    "snippet": "PrimeSieve::PrimeSieve(const Integer &first, const Integer &last, const Integer &step, signed int delta)\n\t: m_first(first), m_last(last), m_step(step), m_delta(delta), m_next(0)\n{\n\tDoSieve();\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoSieve",
          "args": [],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "PrimeSieve::DoSieve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "346-377",
          "snippet": "void PrimeSieve::DoSieve()\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tconst unsigned int maxSieveSize = 32768;\n\tunsigned int sieveSize = STDMIN(Integer(maxSieveSize), (m_last-m_first)/m_step+1).ConvertToLong();\n\n\tm_sieve.clear();\n\tm_sieve.resize(sieveSize, false);\n\n\tif (m_delta == 0)\n\t{\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t\tSieveSingle(m_sieve, primeTable[i], m_first, m_step, (word16)m_step.InverseMod(primeTable[i]));\n\t}\n\telse\n\t{\n\t\tassert(m_step%2==0);\n\t\tInteger qFirst = (m_first-m_delta) >> 1;\n\t\tInteger halfStep = m_step >> 1;\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t{\n\t\t\tword16 p = primeTable[i];\n\t\t\tword16 stepInv = (word16)m_step.InverseMod(p);\n\t\t\tSieveSingle(m_sieve, p, m_first, m_step, stepInv);\n\n\t\t\tword16 halfStepInv = 2*stepInv < p ? 2*stepInv : 2*stepInv-p;\n\t\t\tSieveSingle(m_sieve, p, qFirst, halfStep, halfStepInv);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nvoid PrimeSieve::DoSieve()\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tconst unsigned int maxSieveSize = 32768;\n\tunsigned int sieveSize = STDMIN(Integer(maxSieveSize), (m_last-m_first)/m_step+1).ConvertToLong();\n\n\tm_sieve.clear();\n\tm_sieve.resize(sieveSize, false);\n\n\tif (m_delta == 0)\n\t{\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t\tSieveSingle(m_sieve, primeTable[i], m_first, m_step, (word16)m_step.InverseMod(primeTable[i]));\n\t}\n\telse\n\t{\n\t\tassert(m_step%2==0);\n\t\tInteger qFirst = (m_first-m_delta) >> 1;\n\t\tInteger halfStep = m_step >> 1;\n\t\tfor (unsigned int i = 0; i < primeTableSize; ++i)\n\t\t{\n\t\t\tword16 p = primeTable[i];\n\t\t\tword16 stepInv = (word16)m_step.InverseMod(p);\n\t\t\tSieveSingle(m_sieve, p, m_first, m_step, stepInv);\n\n\t\t\tword16 halfStepInv = 2*stepInv < p ? 2*stepInv : 2*stepInv-p;\n\t\t\tSieveSingle(m_sieve, p, qFirst, halfStep, halfStepInv);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nPrimeSieve::PrimeSieve(const Integer &first, const Integer &last, const Integer &step, signed int delta)\n\t: m_first(first), m_last(last), m_step(step), m_delta(delta), m_next(0)\n{\n\tDoSieve();\n}"
  },
  {
    "function_name": "MakeParametersForTwoPrimesOfEqualSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "265-284",
    "snippet": "AlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"Max\"",
            "maxP"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "181"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3034-3038",
          "snippet": "Integer::Integer(const wchar_t *str)\n\t: reg(2), sign(POSITIVE)\n{\n\t*this = StringToInteger(str);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger::Integer(const wchar_t *str)\n\t: reg(2), sign(POSITIVE)\n{\n\t*this = StringToInteger(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Power2",
          "args": [
            "(productBitLength-1)/2"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Power2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2846-2851",
          "snippet": "Integer Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger Integer::Power2(size_t e)\n{\n\tInteger r((word)0, BitsToWords(e+1));\n\tr.SetBit(e);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"invalid bit length\""
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nAlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}"
  },
  {
    "function_name": "FastProbablePrimeTest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "260-263",
    "snippet": "static inline bool FastProbablePrimeTest(const Integer &n)\n{\n\treturn IsStrongProbablePrime(n,2);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsStrongProbablePrime",
          "args": [
            "n",
            "2"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "IsStrongProbablePrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "105-136",
          "snippet": "bool IsStrongProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\n\tif ((n.IsEven() && n!=2) || GCD(b, n) != 1)\n\t\treturn false;\n\n\tInteger nminus1 = (n-1);\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides (n-1)\n\tfor (a=0; ; a++)\n\t\tif (nminus1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = nminus1>>a;\n\n\tInteger z = a_exp_b_mod_c(b, m, n);\n\tif (z==1 || z==nminus1)\n\t\treturn true;\n\tfor (unsigned j=1; j<a; j++)\n\t{\n\t\tz = z.Squared()%n;\n\t\tif (z==nminus1)\n\t\t\treturn true;\n\t\tif (z==1)\n\t\t\treturn false;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsStrongProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\n\tif ((n.IsEven() && n!=2) || GCD(b, n) != 1)\n\t\treturn false;\n\n\tInteger nminus1 = (n-1);\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides (n-1)\n\tfor (a=0; ; a++)\n\t\tif (nminus1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = nminus1>>a;\n\n\tInteger z = a_exp_b_mod_c(b, m, n);\n\tif (z==1 || z==nminus1)\n\t\treturn true;\n\tfor (unsigned j=1; j<a; j++)\n\t{\n\t\tz = z.Squared()%n;\n\t\tif (z==nminus1)\n\t\t\treturn true;\n\t\tif (z==1)\n\t\t\treturn false;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nstatic inline bool FastProbablePrimeTest(const Integer &n)\n{\n\treturn IsStrongProbablePrime(n,2);\n}"
  },
  {
    "function_name": "PrimeSearchInterval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "255-258",
    "snippet": "unsigned int PrimeSearchInterval(const Integer &max)\n{\n\treturn max.BitCount();\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max.BitCount",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nunsigned int PrimeSearchInterval(const Integer &max)\n{\n\treturn max.BitCount();\n}"
  },
  {
    "function_name": "VerifyPrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "247-253",
    "snippet": "bool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RabinMillerTest",
          "args": [
            "rng",
            "p",
            "10"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "RabinMillerTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "138-153",
          "snippet": "bool RabinMillerTest(RandomNumberGenerator &rng, const Integer &n, unsigned int rounds)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3);\n\n\tInteger b;\n\tfor (unsigned int i=0; i<rounds; i++)\n\t{\n\t\tb.Randomize(rng, 2, n-2);\n\t\tif (!IsStrongProbablePrime(n, b))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool RabinMillerTest(RandomNumberGenerator &rng, const Integer &n, unsigned int rounds)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3);\n\n\tInteger b;\n\tfor (unsigned int i=0; i<rounds; i++)\n\t{\n\t\tb.Randomize(rng, 2, n-2);\n\t\tif (!IsStrongProbablePrime(n, b))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsPrime",
          "args": [
            "p"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "IsPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "237-245",
          "snippet": "bool IsPrime(const Integer &p)\n{\n\tif (p <= s_lastSmallPrime)\n\t\treturn IsSmallPrime(p);\n\telse if (p <= Singleton<Integer, NewLastSmallPrimeSquared>().Ref())\n\t\treturn SmallDivisorsTest(p);\n\telse\n\t\treturn SmallDivisorsTest(p) && IsStrongProbablePrime(p, 3) && IsStrongLucasProbablePrime(p);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsPrime(const Integer &p)\n{\n\tif (p <= s_lastSmallPrime)\n\t\treturn IsSmallPrime(p);\n\telse if (p <= Singleton<Integer, NewLastSmallPrimeSquared>().Ref())\n\t\treturn SmallDivisorsTest(p);\n\telse\n\t\treturn SmallDivisorsTest(p) && IsStrongProbablePrime(p, 3) && IsStrongLucasProbablePrime(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}"
  },
  {
    "function_name": "IsPrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "237-245",
    "snippet": "bool IsPrime(const Integer &p)\n{\n\tif (p <= s_lastSmallPrime)\n\t\treturn IsSmallPrime(p);\n\telse if (p <= Singleton<Integer, NewLastSmallPrimeSquared>().Ref())\n\t\treturn SmallDivisorsTest(p);\n\telse\n\t\treturn SmallDivisorsTest(p) && IsStrongProbablePrime(p, 3) && IsStrongLucasProbablePrime(p);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsStrongLucasProbablePrime",
          "args": [
            "p"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "IsStrongLucasProbablePrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "182-227",
          "snippet": "bool IsStrongLucasProbablePrime(const Integer &n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\n\tif (n.IsEven())\n\t\treturn n==2;\n\n\tassert(n>2);\n\n\tInteger b=3;\n\tunsigned int i=0;\n\tint j;\n\n\twhile ((j=Jacobi(b.Squared()-4, n)) == 1)\n\t{\n\t\tif (++i==64 && n.IsSquare())\t// avoid infinite loop if n is a square\n\t\t\treturn false;\n\t\t++b; ++b;\n\t}\n\n\tif (j==0) \n\t\treturn false;\n\n\tInteger n1 = n+1;\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides n1\n\tfor (a=0; ; a++)\n\t\tif (n1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = n1>>a;\n\n\tInteger z = Lucas(m, b, n);\n\tif (z==2 || z==n-2)\n\t\treturn true;\n\tfor (i=1; i<a; i++)\n\t{\n\t\tz = (z.Squared()-2)%n;\n\t\tif (z==n-2)\n\t\t\treturn true;\n\t\tif (z==2)\n\t\t\treturn false;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsStrongLucasProbablePrime(const Integer &n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\n\tif (n.IsEven())\n\t\treturn n==2;\n\n\tassert(n>2);\n\n\tInteger b=3;\n\tunsigned int i=0;\n\tint j;\n\n\twhile ((j=Jacobi(b.Squared()-4, n)) == 1)\n\t{\n\t\tif (++i==64 && n.IsSquare())\t// avoid infinite loop if n is a square\n\t\t\treturn false;\n\t\t++b; ++b;\n\t}\n\n\tif (j==0) \n\t\treturn false;\n\n\tInteger n1 = n+1;\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides n1\n\tfor (a=0; ; a++)\n\t\tif (n1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = n1>>a;\n\n\tInteger z = Lucas(m, b, n);\n\tif (z==2 || z==n-2)\n\t\treturn true;\n\tfor (i=1; i<a; i++)\n\t{\n\t\tz = (z.Squared()-2)%n;\n\t\tif (z==n-2)\n\t\t\treturn true;\n\t\tif (z==2)\n\t\t\treturn false;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsStrongProbablePrime",
          "args": [
            "p",
            "3"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "IsStrongProbablePrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "105-136",
          "snippet": "bool IsStrongProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\n\tif ((n.IsEven() && n!=2) || GCD(b, n) != 1)\n\t\treturn false;\n\n\tInteger nminus1 = (n-1);\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides (n-1)\n\tfor (a=0; ; a++)\n\t\tif (nminus1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = nminus1>>a;\n\n\tInteger z = a_exp_b_mod_c(b, m, n);\n\tif (z==1 || z==nminus1)\n\t\treturn true;\n\tfor (unsigned j=1; j<a; j++)\n\t{\n\t\tz = z.Squared()%n;\n\t\tif (z==nminus1)\n\t\t\treturn true;\n\t\tif (z==1)\n\t\t\treturn false;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsStrongProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\n\tif ((n.IsEven() && n!=2) || GCD(b, n) != 1)\n\t\treturn false;\n\n\tInteger nminus1 = (n-1);\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides (n-1)\n\tfor (a=0; ; a++)\n\t\tif (nminus1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = nminus1>>a;\n\n\tInteger z = a_exp_b_mod_c(b, m, n);\n\tif (z==1 || z==nminus1)\n\t\treturn true;\n\tfor (unsigned j=1; j<a; j++)\n\t{\n\t\tz = z.Squared()%n;\n\t\tif (z==nminus1)\n\t\t\treturn true;\n\t\tif (z==1)\n\t\t\treturn false;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SmallDivisorsTest",
          "args": [
            "p"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "SmallDivisorsTest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "89-94",
          "snippet": "bool SmallDivisorsTest(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\treturn !TrialDivision(p, primeTable[primeTableSize-1]);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool SmallDivisorsTest(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\treturn !TrialDivision(p, primeTable[primeTableSize-1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Singleton<Integer, NewLastSmallPrimeSquared>",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "Singleton",
          "container": "Singleton",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "111-111",
          "snippet": "Singleton(F objectFactory = F()) : m_objectFactory(objectFactory) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nSingleton {\n  Singleton(F objectFactory = F()) : m_objectFactory(objectFactory) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsSmallPrime",
          "args": [
            "p"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "IsSmallPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "60-69",
          "snippet": "bool IsSmallPrime(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (p.IsPositive() && p <= primeTable[primeTableSize-1])\n\t\treturn std::binary_search(primeTable, primeTable+primeTableSize, (word16)p.ConvertToLong());\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsSmallPrime(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (p.IsPositive() && p <= primeTable[primeTableSize-1])\n\t\treturn std::binary_search(primeTable, primeTable+primeTableSize, (word16)p.ConvertToLong());\n\telse\n\t\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsPrime(const Integer &p)\n{\n\tif (p <= s_lastSmallPrime)\n\t\treturn IsSmallPrime(p);\n\telse if (p <= Singleton<Integer, NewLastSmallPrimeSquared>().Ref())\n\t\treturn SmallDivisorsTest(p);\n\telse\n\t\treturn SmallDivisorsTest(p) && IsStrongProbablePrime(p, 3) && IsStrongLucasProbablePrime(p);\n}"
  },
  {
    "function_name": "IsStrongLucasProbablePrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "182-227",
    "snippet": "bool IsStrongLucasProbablePrime(const Integer &n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\n\tif (n.IsEven())\n\t\treturn n==2;\n\n\tassert(n>2);\n\n\tInteger b=3;\n\tunsigned int i=0;\n\tint j;\n\n\twhile ((j=Jacobi(b.Squared()-4, n)) == 1)\n\t{\n\t\tif (++i==64 && n.IsSquare())\t// avoid infinite loop if n is a square\n\t\t\treturn false;\n\t\t++b; ++b;\n\t}\n\n\tif (j==0) \n\t\treturn false;\n\n\tInteger n1 = n+1;\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides n1\n\tfor (a=0; ; a++)\n\t\tif (n1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = n1>>a;\n\n\tInteger z = Lucas(m, b, n);\n\tif (z==2 || z==n-2)\n\t\treturn true;\n\tfor (i=1; i<a; i++)\n\t{\n\t\tz = (z.Squared()-2)%n;\n\t\tif (z==n-2)\n\t\t\treturn true;\n\t\tif (z==2)\n\t\t\treturn false;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z.Squared",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "m",
            "b",
            "n"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n1.GetBit",
          "args": [
            "a"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.IsSquare",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "b.Squared()-4",
            "n"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n>2"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.IsEven",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "IsEven",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "209-209",
          "snippet": "bool IsEven() const {return GetBit(0) == 0;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsEven() const {return GetBit(0) == 0;}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsStrongLucasProbablePrime(const Integer &n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\n\tif (n.IsEven())\n\t\treturn n==2;\n\n\tassert(n>2);\n\n\tInteger b=3;\n\tunsigned int i=0;\n\tint j;\n\n\twhile ((j=Jacobi(b.Squared()-4, n)) == 1)\n\t{\n\t\tif (++i==64 && n.IsSquare())\t// avoid infinite loop if n is a square\n\t\t\treturn false;\n\t\t++b; ++b;\n\t}\n\n\tif (j==0) \n\t\treturn false;\n\n\tInteger n1 = n+1;\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides n1\n\tfor (a=0; ; a++)\n\t\tif (n1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = n1>>a;\n\n\tInteger z = Lucas(m, b, n);\n\tif (z==2 || z==n-2)\n\t\treturn true;\n\tfor (i=1; i<a; i++)\n\t{\n\t\tz = (z.Squared()-2)%n;\n\t\tif (z==n-2)\n\t\t\treturn true;\n\t\tif (z==2)\n\t\t\treturn false;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "IsLucasProbablePrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "155-180",
    "snippet": "bool IsLucasProbablePrime(const Integer &n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\n\tif (n.IsEven())\n\t\treturn n==2;\n\n\tassert(n>2);\n\n\tInteger b=3;\n\tunsigned int i=0;\n\tint j;\n\n\twhile ((j=Jacobi(b.Squared()-4, n)) == 1)\n\t{\n\t\tif (++i==64 && n.IsSquare())\t// avoid infinite loop if n is a square\n\t\t\treturn false;\n\t\t++b; ++b;\n\t}\n\n\tif (j==0) \n\t\treturn false;\n\telse\n\t\treturn Lucas(n+1, b, n)==2;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "n+1",
            "b",
            "n"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.IsSquare",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "b.Squared()-4",
            "n"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "b.Squared",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n>2"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n.IsEven",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "IsEven",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "209-209",
          "snippet": "bool IsEven() const {return GetBit(0) == 0;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsEven() const {return GetBit(0) == 0;}"
        }
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsLucasProbablePrime(const Integer &n)\n{\n\tif (n <= 1)\n\t\treturn false;\n\n\tif (n.IsEven())\n\t\treturn n==2;\n\n\tassert(n>2);\n\n\tInteger b=3;\n\tunsigned int i=0;\n\tint j;\n\n\twhile ((j=Jacobi(b.Squared()-4, n)) == 1)\n\t{\n\t\tif (++i==64 && n.IsSquare())\t// avoid infinite loop if n is a square\n\t\t\treturn false;\n\t\t++b; ++b;\n\t}\n\n\tif (j==0) \n\t\treturn false;\n\telse\n\t\treturn Lucas(n+1, b, n)==2;\n}"
  },
  {
    "function_name": "RabinMillerTest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "138-153",
    "snippet": "bool RabinMillerTest(RandomNumberGenerator &rng, const Integer &n, unsigned int rounds)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3);\n\n\tInteger b;\n\tfor (unsigned int i=0; i<rounds; i++)\n\t{\n\t\tb.Randomize(rng, 2, n-2);\n\t\tif (!IsStrongProbablePrime(n, b))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsStrongProbablePrime",
          "args": [
            "n",
            "b"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "IsStrongProbablePrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "105-136",
          "snippet": "bool IsStrongProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\n\tif ((n.IsEven() && n!=2) || GCD(b, n) != 1)\n\t\treturn false;\n\n\tInteger nminus1 = (n-1);\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides (n-1)\n\tfor (a=0; ; a++)\n\t\tif (nminus1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = nminus1>>a;\n\n\tInteger z = a_exp_b_mod_c(b, m, n);\n\tif (z==1 || z==nminus1)\n\t\treturn true;\n\tfor (unsigned j=1; j<a; j++)\n\t{\n\t\tz = z.Squared()%n;\n\t\tif (z==nminus1)\n\t\t\treturn true;\n\t\tif (z==1)\n\t\t\treturn false;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsStrongProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\n\tif ((n.IsEven() && n!=2) || GCD(b, n) != 1)\n\t\treturn false;\n\n\tInteger nminus1 = (n-1);\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides (n-1)\n\tfor (a=0; ; a++)\n\t\tif (nminus1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = nminus1>>a;\n\n\tInteger z = a_exp_b_mod_c(b, m, n);\n\tif (z==1 || z==nminus1)\n\t\treturn true;\n\tfor (unsigned j=1; j<a; j++)\n\t{\n\t\tz = z.Squared()%n;\n\t\tif (z==nminus1)\n\t\t\treturn true;\n\t\tif (z==1)\n\t\t\treturn false;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "b.Randomize",
          "args": [
            "rng",
            "2",
            "n-2"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n>3"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool RabinMillerTest(RandomNumberGenerator &rng, const Integer &n, unsigned int rounds)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3);\n\n\tInteger b;\n\tfor (unsigned int i=0; i<rounds; i++)\n\t{\n\t\tb.Randomize(rng, 2, n-2);\n\t\tif (!IsStrongProbablePrime(n, b))\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "IsStrongProbablePrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "105-136",
    "snippet": "bool IsStrongProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\n\tif ((n.IsEven() && n!=2) || GCD(b, n) != 1)\n\t\treturn false;\n\n\tInteger nminus1 = (n-1);\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides (n-1)\n\tfor (a=0; ; a++)\n\t\tif (nminus1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = nminus1>>a;\n\n\tInteger z = a_exp_b_mod_c(b, m, n);\n\tif (z==1 || z==nminus1)\n\t\treturn true;\n\tfor (unsigned j=1; j<a; j++)\n\t{\n\t\tz = z.Squared()%n;\n\t\tif (z==nminus1)\n\t\t\treturn true;\n\t\tif (z==1)\n\t\t\treturn false;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z.Squared",
          "args": [],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "b",
            "m",
            "n"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nminus1.GetBit",
          "args": [
            "a"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GCD",
          "args": [
            "b",
            "n"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "GCD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "63-64",
          "snippet": "inline Integer GCD(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b);}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline Integer GCD(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b);}"
        }
      },
      {
        "call_info": {
          "callee": "n.IsEven",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "IsEven",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "209-209",
          "snippet": "bool IsEven() const {return GetBit(0) == 0;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsEven() const {return GetBit(0) == 0;}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n>3 && b>1 && b<n-1"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsStrongProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\n\tif ((n.IsEven() && n!=2) || GCD(b, n) != 1)\n\t\treturn false;\n\n\tInteger nminus1 = (n-1);\n\tunsigned int a;\n\n\t// calculate a = largest power of 2 that divides (n-1)\n\tfor (a=0; ; a++)\n\t\tif (nminus1.GetBit(a))\n\t\t\tbreak;\n\tInteger m = nminus1>>a;\n\n\tInteger z = a_exp_b_mod_c(b, m, n);\n\tif (z==1 || z==nminus1)\n\t\treturn true;\n\tfor (unsigned j=1; j<a; j++)\n\t{\n\t\tz = z.Squared()%n;\n\t\tif (z==nminus1)\n\t\t\treturn true;\n\t\tif (z==1)\n\t\t\treturn false;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "IsFermatProbablePrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "96-103",
    "snippet": "bool IsFermatProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\treturn a_exp_b_mod_c(b, n-1, n)==1;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "b",
            "n-1",
            "n"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n>3 && b>1 && b<n-1"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsFermatProbablePrime(const Integer &n, const Integer &b)\n{\n\tif (n <= 3)\n\t\treturn n==2 || n==3;\n\n\tassert(n>3 && b>1 && b<n-1);\n\treturn a_exp_b_mod_c(b, n-1, n)==1;\n}"
  },
  {
    "function_name": "SmallDivisorsTest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "89-94",
    "snippet": "bool SmallDivisorsTest(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\treturn !TrialDivision(p, primeTable[primeTableSize-1]);\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TrialDivision",
          "args": [
            "p",
            "primeTable[primeTableSize-1]"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "TrialDivision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "71-87",
          "snippet": "bool TrialDivision(const Integer &p, unsigned bound)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTable[primeTableSize-1] >= bound);\n\n\tunsigned int i;\n\tfor (i = 0; primeTable[i]<bound; i++)\n\t\tif ((p % primeTable[i]) == 0)\n\t\t\treturn true;\n\n\tif (bound == primeTable[i])\n\t\treturn (p % bound == 0);\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool TrialDivision(const Integer &p, unsigned bound)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTable[primeTableSize-1] >= bound);\n\n\tunsigned int i;\n\tfor (i = 0; primeTable[i]<bound; i++)\n\t\tif ((p % primeTable[i]) == 0)\n\t\t\treturn true;\n\n\tif (bound == primeTable[i])\n\t\treturn (p % bound == 0);\n\telse\n\t\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetPrimeTable",
          "args": [
            "primeTableSize"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool SmallDivisorsTest(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\treturn !TrialDivision(p, primeTable[primeTableSize-1]);\n}"
  },
  {
    "function_name": "TrialDivision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "71-87",
    "snippet": "bool TrialDivision(const Integer &p, unsigned bound)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTable[primeTableSize-1] >= bound);\n\n\tunsigned int i;\n\tfor (i = 0; primeTable[i]<bound; i++)\n\t\tif ((p % primeTable[i]) == 0)\n\t\t\treturn true;\n\n\tif (bound == primeTable[i])\n\t\treturn (p % bound == 0);\n\telse\n\t\treturn false;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "primeTable[primeTableSize-1] >= bound"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPrimeTable",
          "args": [
            "primeTableSize"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool TrialDivision(const Integer &p, unsigned bound)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tassert(primeTable[primeTableSize-1] >= bound);\n\n\tunsigned int i;\n\tfor (i = 0; primeTable[i]<bound; i++)\n\t\tif ((p % primeTable[i]) == 0)\n\t\t\treturn true;\n\n\tif (bound == primeTable[i])\n\t\treturn (p % bound == 0);\n\telse\n\t\treturn false;\n}"
  },
  {
    "function_name": "IsSmallPrime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
    "lines": "60-69",
    "snippet": "bool IsSmallPrime(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (p.IsPositive() && p <= primeTable[primeTableSize-1])\n\t\treturn std::binary_search(primeTable, primeTable+primeTableSize, (word16)p.ConvertToLong());\n\telse\n\t\treturn false;\n}",
    "includes": [
      "#include <omp.h>",
      "#include <vector>",
      "#include <math.h>",
      "#include \"algparam.h\"",
      "#include \"modarith.h\"",
      "#include \"nbtheory.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::binary_search",
          "args": [
            "primeTable",
            "primeTable+primeTableSize",
            "(word16)p.ConvertToLong()"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.ConvertToLong",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.IsPositive",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "IsPositive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "205-205",
          "snippet": "bool IsPositive() const {return NotNegative() && NotZero();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsPositive() const {return NotNegative() && NotZero();}"
        }
      },
      {
        "call_info": {
          "callee": "GetPrimeTable",
          "args": [
            "primeTableSize"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool IsSmallPrime(const Integer &p)\n{\n\tunsigned int primeTableSize;\n\tconst word16 * primeTable = GetPrimeTable(primeTableSize);\n\n\tif (p.IsPositive() && p <= primeTable[primeTableSize-1])\n\t\treturn std::binary_search(primeTable, primeTable+primeTableSize, (word16)p.ConvertToLong());\n\telse\n\t\treturn false;\n}"
  }
]