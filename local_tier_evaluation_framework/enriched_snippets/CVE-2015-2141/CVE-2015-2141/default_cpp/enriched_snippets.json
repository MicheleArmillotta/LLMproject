[
  {
    "function_name": "LastPut",
    "container": "DefaultDecryptorWithMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "251-256",
    "snippet": "void DefaultDecryptorWithMAC::LastPut(const byte *inString, size_t length)\n{\n\tm_filter->MessageEnd();\n\tif (m_throwException && !CheckLastMAC())\n\t\tthrow MACBadErr();\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MACBadErr",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "MACBadErr",
          "container": "DefaultDecryptorWithMAC::MACBadErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.h",
          "lines": "84-84",
          "snippet": "MACBadErr() : DefaultDecryptor::Err(\"DefaultDecryptorWithMAC: MAC check failed\") {}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"filters.h\"",
            "#include \"des.h\"",
            "#include \"hmac.h\"",
            "#include \"sha.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"filters.h\"\n#include \"des.h\"\n#include \"hmac.h\"\n#include \"sha.h\"\n\nDefaultDecryptorWithMAC {\n  MACBadErr {\n    MACBadErr() : DefaultDecryptor::Err(\"DefaultDecryptorWithMAC: MAC check failed\") {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckLastMAC",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "CheckLastMAC",
          "container": "DefaultDecryptorWithMAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
          "lines": "246-249",
          "snippet": "bool DefaultDecryptorWithMAC::CheckLastMAC() const\n{\n\treturn m_hashVerifier->GetLastResult();\n}",
          "includes": [
            "#include <memory>",
            "#include <time.h>",
            "#include \"queue.h\"",
            "#include \"default.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultDecryptorWithMAC {\n  bool DefaultDecryptorWithMAC::CheckLastMAC() const\n  {\n  \treturn m_hashVerifier->GetLastResult();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_filter->MessageEnd",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultDecryptorWithMAC {\n  void DefaultDecryptorWithMAC::LastPut(const byte *inString, size_t length)\n  {\n  \tm_filter->MessageEnd();\n  \tif (m_throwException && !CheckLastMAC())\n  \t\tthrow MACBadErr();\n  }\n}"
  },
  {
    "function_name": "CheckLastMAC",
    "container": "DefaultDecryptorWithMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "246-249",
    "snippet": "bool DefaultDecryptorWithMAC::CheckLastMAC() const\n{\n\treturn m_hashVerifier->GetLastResult();\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_hashVerifier->GetLastResult",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "374-374",
          "snippet": "bool GetLastResult() const {return m_hashVerifier.GetLastResult();}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nbool GetLastResult() const {return m_hashVerifier.GetLastResult();}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultDecryptorWithMAC {\n  bool DefaultDecryptorWithMAC::CheckLastMAC() const\n  {\n  \treturn m_hashVerifier->GetLastResult();\n  }\n}"
  },
  {
    "function_name": "CurrentState",
    "container": "DefaultDecryptorWithMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "241-244",
    "snippet": "DefaultDecryptor::State DefaultDecryptorWithMAC::CurrentState() const\n{\n\treturn static_cast<const DefaultDecryptor *>(m_filter.get())->CurrentState();\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<const DefaultDecryptor *>",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const DefaultDecryptor *>",
          "args": [
            "m_filter.get()"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_filter.get",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultDecryptorWithMAC {\n  DefaultDecryptor::State DefaultDecryptorWithMAC::CurrentState() const\n  {\n  \treturn static_cast<const DefaultDecryptor *>(m_filter.get())->CurrentState();\n  }\n}"
  },
  {
    "function_name": "DefaultDecryptorWithMAC",
    "container": "DefaultDecryptorWithMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "233-239",
    "snippet": "DefaultDecryptorWithMAC::DefaultDecryptorWithMAC(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment, bool throwException)\n\t: ProxyFilter(NULL, 0, 0, attachment)\n\t, m_mac(NewDefaultEncryptorMAC(passphrase, passphraseLength))\n\t, m_throwException(throwException)\n{\n\tSetFilter(new DefaultDecryptor(passphrase, passphraseLength, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException));\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetFilter",
          "args": [
            "new DefaultDecryptor(passphrase, passphraseLength, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "SetFilter",
          "container": "ProxyFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "473-483",
          "snippet": "void ProxyFilter::SetFilter(Filter *filter)\n{\n\tm_filter.reset(filter);\n\tif (filter)\n\t{\n\t\tOutputProxy *proxy;\n\t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n\t\tm_filter->TransferAllTo(*proxy);\n\t\tm_filter->Attach(temp.release());\n\t}\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nProxyFilter {\n  void ProxyFilter::SetFilter(Filter *filter)\n  {\n  \tm_filter.reset(filter);\n  \tif (filter)\n  \t{\n  \t\tOutputProxy *proxy;\n  \t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n  \t\tm_filter->TransferAllTo(*proxy);\n  \t\tm_filter->Attach(temp.release());\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewDefaultEncryptorMAC",
          "args": [
            "passphrase",
            "passphraseLength"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultDecryptorWithMAC {\n  DefaultDecryptorWithMAC::DefaultDecryptorWithMAC(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment, bool throwException)\n  \t: ProxyFilter(NULL, 0, 0, attachment)\n  \t, m_mac(NewDefaultEncryptorMAC(passphrase, passphraseLength))\n  \t, m_throwException(throwException)\n  {\n  \tSetFilter(new DefaultDecryptor(passphrase, passphraseLength, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException));\n  }\n}"
  },
  {
    "function_name": "DefaultDecryptorWithMAC",
    "container": "DefaultDecryptorWithMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "225-231",
    "snippet": "DefaultDecryptorWithMAC::DefaultDecryptorWithMAC(const char *passphrase, BufferedTransformation *attachment, bool throwException)\n\t: ProxyFilter(NULL, 0, 0, attachment)\n\t, m_mac(NewDefaultEncryptorMAC((const byte *)passphrase, strlen(passphrase)))\n\t, m_throwException(throwException)\n{\n\tSetFilter(new DefaultDecryptor(passphrase, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException));\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetFilter",
          "args": [
            "new DefaultDecryptor(passphrase, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException)"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "SetFilter",
          "container": "ProxyFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "473-483",
          "snippet": "void ProxyFilter::SetFilter(Filter *filter)\n{\n\tm_filter.reset(filter);\n\tif (filter)\n\t{\n\t\tOutputProxy *proxy;\n\t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n\t\tm_filter->TransferAllTo(*proxy);\n\t\tm_filter->Attach(temp.release());\n\t}\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nProxyFilter {\n  void ProxyFilter::SetFilter(Filter *filter)\n  {\n  \tm_filter.reset(filter);\n  \tif (filter)\n  \t{\n  \t\tOutputProxy *proxy;\n  \t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n  \t\tm_filter->TransferAllTo(*proxy);\n  \t\tm_filter->Attach(temp.release());\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewDefaultEncryptorMAC",
          "args": [
            "(const byte *)passphrase",
            "strlen(passphrase)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultDecryptorWithMAC {\n  DefaultDecryptorWithMAC::DefaultDecryptorWithMAC(const char *passphrase, BufferedTransformation *attachment, bool throwException)\n  \t: ProxyFilter(NULL, 0, 0, attachment)\n  \t, m_mac(NewDefaultEncryptorMAC((const byte *)passphrase, strlen(passphrase)))\n  \t, m_throwException(throwException)\n  {\n  \tSetFilter(new DefaultDecryptor(passphrase, m_hashVerifier=new HashVerifier(*m_mac, NULL, HashVerifier::PUT_MESSAGE), throwException));\n  }\n}"
  },
  {
    "function_name": "LastPut",
    "container": "DefaultEncryptorWithMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "218-221",
    "snippet": "void DefaultEncryptorWithMAC::LastPut(const byte *inString, size_t length)\n{\n\tm_filter->MessageEnd();\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_filter->MessageEnd",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultEncryptorWithMAC {\n  void DefaultEncryptorWithMAC::LastPut(const byte *inString, size_t length)\n  {\n  \tm_filter->MessageEnd();\n  }\n}"
  },
  {
    "function_name": "DefaultEncryptorWithMAC",
    "container": "DefaultEncryptorWithMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "211-216",
    "snippet": "DefaultEncryptorWithMAC::DefaultEncryptorWithMAC(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment)\n\t: ProxyFilter(NULL, 0, 0, attachment)\n\t, m_mac(NewDefaultEncryptorMAC(passphrase, passphraseLength))\n{\n\tSetFilter(new HashFilter(*m_mac, new DefaultEncryptor(passphrase, passphraseLength), true));\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetFilter",
          "args": [
            "new HashFilter(*m_mac, new DefaultEncryptor(passphrase, passphraseLength), true)"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "SetFilter",
          "container": "ProxyFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "473-483",
          "snippet": "void ProxyFilter::SetFilter(Filter *filter)\n{\n\tm_filter.reset(filter);\n\tif (filter)\n\t{\n\t\tOutputProxy *proxy;\n\t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n\t\tm_filter->TransferAllTo(*proxy);\n\t\tm_filter->Attach(temp.release());\n\t}\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nProxyFilter {\n  void ProxyFilter::SetFilter(Filter *filter)\n  {\n  \tm_filter.reset(filter);\n  \tif (filter)\n  \t{\n  \t\tOutputProxy *proxy;\n  \t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n  \t\tm_filter->TransferAllTo(*proxy);\n  \t\tm_filter->Attach(temp.release());\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewDefaultEncryptorMAC",
          "args": [
            "passphrase",
            "passphraseLength"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultEncryptorWithMAC {\n  DefaultEncryptorWithMAC::DefaultEncryptorWithMAC(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment)\n  \t: ProxyFilter(NULL, 0, 0, attachment)\n  \t, m_mac(NewDefaultEncryptorMAC(passphrase, passphraseLength))\n  {\n  \tSetFilter(new HashFilter(*m_mac, new DefaultEncryptor(passphrase, passphraseLength), true));\n  }\n}"
  },
  {
    "function_name": "DefaultEncryptorWithMAC",
    "container": "DefaultEncryptorWithMAC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "204-209",
    "snippet": "DefaultEncryptorWithMAC::DefaultEncryptorWithMAC(const char *passphrase, BufferedTransformation *attachment)\n\t: ProxyFilter(NULL, 0, 0, attachment)\n\t, m_mac(NewDefaultEncryptorMAC((const byte *)passphrase, strlen(passphrase)))\n{\n\tSetFilter(new HashFilter(*m_mac, new DefaultEncryptor(passphrase), true));\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetFilter",
          "args": [
            "new HashFilter(*m_mac, new DefaultEncryptor(passphrase), true)"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "SetFilter",
          "container": "ProxyFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "473-483",
          "snippet": "void ProxyFilter::SetFilter(Filter *filter)\n{\n\tm_filter.reset(filter);\n\tif (filter)\n\t{\n\t\tOutputProxy *proxy;\n\t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n\t\tm_filter->TransferAllTo(*proxy);\n\t\tm_filter->Attach(temp.release());\n\t}\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nProxyFilter {\n  void ProxyFilter::SetFilter(Filter *filter)\n  {\n  \tm_filter.reset(filter);\n  \tif (filter)\n  \t{\n  \t\tOutputProxy *proxy;\n  \t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n  \t\tm_filter->TransferAllTo(*proxy);\n  \t\tm_filter->Attach(temp.release());\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewDefaultEncryptorMAC",
          "args": [
            "(const byte *)passphrase",
            "strlen(passphrase)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultEncryptorWithMAC {\n  DefaultEncryptorWithMAC::DefaultEncryptorWithMAC(const char *passphrase, BufferedTransformation *attachment)\n  \t: ProxyFilter(NULL, 0, 0, attachment)\n  \t, m_mac(NewDefaultEncryptorMAC((const byte *)passphrase, strlen(passphrase)))\n  {\n  \tSetFilter(new HashFilter(*m_mac, new DefaultEncryptor(passphrase), true));\n  }\n}"
  },
  {
    "function_name": "CheckKey",
    "container": "DefaultDecryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "161-191",
    "snippet": "void DefaultDecryptor::CheckKey(const byte *salt, const byte *keyCheck)\n{\n\tSecByteBlock check(STDMAX((unsigned int)2*BLOCKSIZE, (unsigned int)DefaultHashModule::DIGESTSIZE));\n\n\tDefaultHashModule hash;\n\thash.Update(m_passphrase, m_passphrase.size());\n\thash.Update(salt, SALTLENGTH);\n\thash.Final(check);\n\n\tSecByteBlock key(KEYLENGTH);\n\tSecByteBlock IV(BLOCKSIZE);\n\tGenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);\n\n\tm_cipher.SetKeyWithIV(key, key.size(), IV);\n\tstd::auto_ptr<StreamTransformationFilter> decryptor(new StreamTransformationFilter(m_cipher));\n\n\tdecryptor->Put(keyCheck, BLOCKSIZE);\n\tdecryptor->ForceNextPut();\n\tdecryptor->Get(check+BLOCKSIZE, BLOCKSIZE);\n\n\tSetFilter(decryptor.release());\n\n\tif (!VerifyBufsEqual(check, check+BLOCKSIZE, BLOCKSIZE))\n\t{\n\t\tm_state = KEY_BAD;\n\t\tif (m_throwException)\n\t\t\tthrow KeyBadErr();\n\t}\n\telse\n\t\tm_state = KEY_GOOD;\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int SALTLENGTH = 8;",
      "static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;",
      "static const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KeyBadErr",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "KeyBadErr",
          "container": "DefaultDecryptor::KeyBadErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.h",
          "lines": "45-45",
          "snippet": "KeyBadErr() : Err(\"DefaultDecryptor: cannot decrypt message with this passphrase\") {}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"filters.h\"",
            "#include \"des.h\"",
            "#include \"hmac.h\"",
            "#include \"sha.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"filters.h\"\n#include \"des.h\"\n#include \"hmac.h\"\n#include \"sha.h\"\n\nDefaultDecryptor {\n  KeyBadErr {\n    KeyBadErr() : Err(\"DefaultDecryptor: cannot decrypt message with this passphrase\") {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VerifyBufsEqual",
          "args": [
            "check",
            "check+BLOCKSIZE",
            "BLOCKSIZE"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyBufsEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "79-113",
          "snippet": "bool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nbool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\tbyte acc8 = 0;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tword32 acc32 = 0;\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tword64 acc64 = 0;\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\tacc64 |= ((word64*)buf)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn acc64 == 0;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t\tacc32 = word32(acc64) | word32(acc64>>32);\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\tacc32 |= ((word32*)buf)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn acc32 == 0;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t\tacc8 = byte(acc32) | byte(acc32>>8) | byte(acc32>>16) | byte(acc32>>24);\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tacc8 |= buf[i] ^ mask[i];\n\treturn acc8 == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetFilter",
          "args": [
            "decryptor.release()"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "SetFilter",
          "container": "ProxyFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "473-483",
          "snippet": "void ProxyFilter::SetFilter(Filter *filter)\n{\n\tm_filter.reset(filter);\n\tif (filter)\n\t{\n\t\tOutputProxy *proxy;\n\t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n\t\tm_filter->TransferAllTo(*proxy);\n\t\tm_filter->Attach(temp.release());\n\t}\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nProxyFilter {\n  void ProxyFilter::SetFilter(Filter *filter)\n  {\n  \tm_filter.reset(filter);\n  \tif (filter)\n  \t{\n  \t\tOutputProxy *proxy;\n  \t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n  \t\tm_filter->TransferAllTo(*proxy);\n  \t\tm_filter->Attach(temp.release());\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decryptor.release",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor->Get",
          "args": [
            "check+BLOCKSIZE",
            "BLOCKSIZE"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "ByteQueue::Walker",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "492-496",
          "snippet": "size_t ByteQueue::Walker::Get(byte *outString, size_t getMax)\n{\n\tArraySink sink(outString, getMax);\n\treturn (size_t)TransferTo(sink, getMax);\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  Walker {\n    size_t ByteQueue::Walker::Get(byte *outString, size_t getMax)\n    {\n    \tArraySink sink(outString, getMax);\n    \treturn (size_t)TransferTo(sink, getMax);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decryptor->ForceNextPut",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ForceNextPut",
          "container": "FilterWithBufferedInput",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "418-434",
          "snippet": "void FilterWithBufferedInput::ForceNextPut()\n{\n\tif (!m_firstInputDone)\n\t\treturn;\n\t\n\tif (m_blockSize > 1)\n\t{\n\t\twhile (m_queue.CurrentSize() >= m_blockSize)\n\t\t\tNextPutModifiable(m_queue.GetBlock(), m_blockSize);\n\t}\n\telse\n\t{\n\t\tsize_t len;\n\t\twhile ((len = m_queue.CurrentSize()) > 0)\n\t\t\tNextPutModifiable(m_queue.GetContigousBlocks(len), len);\n\t}\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilterWithBufferedInput {\n  void FilterWithBufferedInput::ForceNextPut()\n  {\n  \tif (!m_firstInputDone)\n  \t\treturn;\n  \t\n  \tif (m_blockSize > 1)\n  \t{\n  \t\twhile (m_queue.CurrentSize() >= m_blockSize)\n  \t\t\tNextPutModifiable(m_queue.GetBlock(), m_blockSize);\n  \t}\n  \telse\n  \t{\n  \t\tsize_t len;\n  \t\twhile ((len = m_queue.CurrentSize()) > 0)\n  \t\t\tNextPutModifiable(m_queue.GetContigousBlocks(len), len);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decryptor->Put",
          "args": [
            "keyCheck",
            "BLOCKSIZE"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher.SetKeyWithIV",
          "args": [
            "key",
            "key.size()",
            "IV"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.size",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenerateKeyIV",
          "args": [
            "m_passphrase",
            "m_passphrase.size()",
            "salt",
            "SALTLENGTH",
            "key",
            "IV"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateKeyIV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
          "lines": "59-68",
          "snippet": "static void GenerateKeyIV(const byte *passphrase, size_t passphraseLength, const byte *salt, size_t saltLength, byte *key, byte *IV)\n{\n\tSecByteBlock temp(passphraseLength+saltLength);\n\tmemcpy(temp, passphrase, passphraseLength);\n\tmemcpy(temp+passphraseLength, salt, saltLength);\n\tSecByteBlock keyIV(KEYLENGTH+BLOCKSIZE);\n\tMash(temp, passphraseLength + saltLength, keyIV, KEYLENGTH+BLOCKSIZE, MASH_ITERATIONS);\n\tmemcpy(key, keyIV, KEYLENGTH);\n\tmemcpy(IV, keyIV+KEYLENGTH, BLOCKSIZE);\n}",
          "includes": [
            "#include <memory>",
            "#include <time.h>",
            "#include \"queue.h\"",
            "#include \"default.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int MASH_ITERATIONS = 200;",
            "static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;",
            "static const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int MASH_ITERATIONS = 200;\nstatic const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;\nstatic const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;\n\nstatic void GenerateKeyIV(const byte *passphrase, size_t passphraseLength, const byte *salt, size_t saltLength, byte *key, byte *IV)\n{\n\tSecByteBlock temp(passphraseLength+saltLength);\n\tmemcpy(temp, passphrase, passphraseLength);\n\tmemcpy(temp+passphraseLength, salt, saltLength);\n\tSecByteBlock keyIV(KEYLENGTH+BLOCKSIZE);\n\tMash(temp, passphraseLength + saltLength, keyIV, KEYLENGTH+BLOCKSIZE, MASH_ITERATIONS);\n\tmemcpy(key, keyIV, KEYLENGTH);\n\tmemcpy(IV, keyIV+KEYLENGTH, BLOCKSIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.Final",
          "args": [
            "check"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.Update",
          "args": [
            "salt",
            "SALTLENGTH"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMAX",
          "args": [
            "(unsigned int)2*BLOCKSIZE",
            "(unsigned int)DefaultHashModule::DIGESTSIZE"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int SALTLENGTH = 8;\nstatic const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;\nstatic const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;\n\nDefaultDecryptor {\n  void DefaultDecryptor::CheckKey(const byte *salt, const byte *keyCheck)\n  {\n  \tSecByteBlock check(STDMAX((unsigned int)2*BLOCKSIZE, (unsigned int)DefaultHashModule::DIGESTSIZE));\n  \n  \tDefaultHashModule hash;\n  \thash.Update(m_passphrase, m_passphrase.size());\n  \thash.Update(salt, SALTLENGTH);\n  \thash.Final(check);\n  \n  \tSecByteBlock key(KEYLENGTH);\n  \tSecByteBlock IV(BLOCKSIZE);\n  \tGenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);\n  \n  \tm_cipher.SetKeyWithIV(key, key.size(), IV);\n  \tstd::auto_ptr<StreamTransformationFilter> decryptor(new StreamTransformationFilter(m_cipher));\n  \n  \tdecryptor->Put(keyCheck, BLOCKSIZE);\n  \tdecryptor->ForceNextPut();\n  \tdecryptor->Get(check+BLOCKSIZE, BLOCKSIZE);\n  \n  \tSetFilter(decryptor.release());\n  \n  \tif (!VerifyBufsEqual(check, check+BLOCKSIZE, BLOCKSIZE))\n  \t{\n  \t\tm_state = KEY_BAD;\n  \t\tif (m_throwException)\n  \t\t\tthrow KeyBadErr();\n  \t}\n  \telse\n  \t\tm_state = KEY_GOOD;\n  }\n}"
  },
  {
    "function_name": "LastPut",
    "container": "DefaultDecryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "146-159",
    "snippet": "void DefaultDecryptor::LastPut(const byte *inString, size_t length)\n{\n\tif (m_filter.get() == NULL)\n\t{\n\t\tm_state = KEY_BAD;\n\t\tif (m_throwException)\n\t\t\tthrow KeyBadErr();\n\t}\n\telse\n\t{\n\t\tm_filter->MessageEnd();\n\t\tm_state = WAITING_FOR_KEYCHECK;\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_filter->MessageEnd",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeyBadErr",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "KeyBadErr",
          "container": "DefaultDecryptor::KeyBadErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.h",
          "lines": "45-45",
          "snippet": "KeyBadErr() : Err(\"DefaultDecryptor: cannot decrypt message with this passphrase\") {}",
          "includes": [
            "#include \"modes.h\"",
            "#include \"filters.h\"",
            "#include \"des.h\"",
            "#include \"hmac.h\"",
            "#include \"sha.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modes.h\"\n#include \"filters.h\"\n#include \"des.h\"\n#include \"hmac.h\"\n#include \"sha.h\"\n\nDefaultDecryptor {\n  KeyBadErr {\n    KeyBadErr() : Err(\"DefaultDecryptor: cannot decrypt message with this passphrase\") {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_filter.get",
          "args": [],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultDecryptor {\n  void DefaultDecryptor::LastPut(const byte *inString, size_t length)\n  {\n  \tif (m_filter.get() == NULL)\n  \t{\n  \t\tm_state = KEY_BAD;\n  \t\tif (m_throwException)\n  \t\t\tthrow KeyBadErr();\n  \t}\n  \telse\n  \t{\n  \t\tm_filter->MessageEnd();\n  \t\tm_state = WAITING_FOR_KEYCHECK;\n  \t}\n  }\n}"
  },
  {
    "function_name": "FirstPut",
    "container": "DefaultDecryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "141-144",
    "snippet": "void DefaultDecryptor::FirstPut(const byte *inString)\n{\n\tCheckKey(inString, inString+SALTLENGTH);\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int SALTLENGTH = 8;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckKey",
          "args": [
            "inString",
            "inString+SALTLENGTH"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "CheckKey",
          "container": "DefaultDecryptor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
          "lines": "161-191",
          "snippet": "void DefaultDecryptor::CheckKey(const byte *salt, const byte *keyCheck)\n{\n\tSecByteBlock check(STDMAX((unsigned int)2*BLOCKSIZE, (unsigned int)DefaultHashModule::DIGESTSIZE));\n\n\tDefaultHashModule hash;\n\thash.Update(m_passphrase, m_passphrase.size());\n\thash.Update(salt, SALTLENGTH);\n\thash.Final(check);\n\n\tSecByteBlock key(KEYLENGTH);\n\tSecByteBlock IV(BLOCKSIZE);\n\tGenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);\n\n\tm_cipher.SetKeyWithIV(key, key.size(), IV);\n\tstd::auto_ptr<StreamTransformationFilter> decryptor(new StreamTransformationFilter(m_cipher));\n\n\tdecryptor->Put(keyCheck, BLOCKSIZE);\n\tdecryptor->ForceNextPut();\n\tdecryptor->Get(check+BLOCKSIZE, BLOCKSIZE);\n\n\tSetFilter(decryptor.release());\n\n\tif (!VerifyBufsEqual(check, check+BLOCKSIZE, BLOCKSIZE))\n\t{\n\t\tm_state = KEY_BAD;\n\t\tif (m_throwException)\n\t\t\tthrow KeyBadErr();\n\t}\n\telse\n\t\tm_state = KEY_GOOD;\n}",
          "includes": [
            "#include <memory>",
            "#include <time.h>",
            "#include \"queue.h\"",
            "#include \"default.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int SALTLENGTH = 8;",
            "static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;",
            "static const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int SALTLENGTH = 8;\nstatic const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;\nstatic const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;\n\nDefaultDecryptor {\n  void DefaultDecryptor::CheckKey(const byte *salt, const byte *keyCheck)\n  {\n  \tSecByteBlock check(STDMAX((unsigned int)2*BLOCKSIZE, (unsigned int)DefaultHashModule::DIGESTSIZE));\n  \n  \tDefaultHashModule hash;\n  \thash.Update(m_passphrase, m_passphrase.size());\n  \thash.Update(salt, SALTLENGTH);\n  \thash.Final(check);\n  \n  \tSecByteBlock key(KEYLENGTH);\n  \tSecByteBlock IV(BLOCKSIZE);\n  \tGenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);\n  \n  \tm_cipher.SetKeyWithIV(key, key.size(), IV);\n  \tstd::auto_ptr<StreamTransformationFilter> decryptor(new StreamTransformationFilter(m_cipher));\n  \n  \tdecryptor->Put(keyCheck, BLOCKSIZE);\n  \tdecryptor->ForceNextPut();\n  \tdecryptor->Get(check+BLOCKSIZE, BLOCKSIZE);\n  \n  \tSetFilter(decryptor.release());\n  \n  \tif (!VerifyBufsEqual(check, check+BLOCKSIZE, BLOCKSIZE))\n  \t{\n  \t\tm_state = KEY_BAD;\n  \t\tif (m_throwException)\n  \t\t\tthrow KeyBadErr();\n  \t}\n  \telse\n  \t\tm_state = KEY_GOOD;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int SALTLENGTH = 8;\n\nDefaultDecryptor {\n  void DefaultDecryptor::FirstPut(const byte *inString)\n  {\n  \tCheckKey(inString, inString+SALTLENGTH);\n  }\n}"
  },
  {
    "function_name": "DefaultDecryptor",
    "container": "DefaultDecryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "133-139",
    "snippet": "DefaultDecryptor::DefaultDecryptor(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment, bool throwException)\n\t: ProxyFilter(NULL, SALTLENGTH+BLOCKSIZE, 0, attachment)\n\t, m_state(WAITING_FOR_KEYCHECK)\n\t, m_passphrase(passphrase, passphraseLength)\n\t, m_throwException(throwException)\n{\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int SALTLENGTH = 8;",
      "static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int SALTLENGTH = 8;\nstatic const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;\n\nDefaultDecryptor {\n  DefaultDecryptor::DefaultDecryptor(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment, bool throwException)\n  \t: ProxyFilter(NULL, SALTLENGTH+BLOCKSIZE, 0, attachment)\n  \t, m_state(WAITING_FOR_KEYCHECK)\n  \t, m_passphrase(passphrase, passphraseLength)\n  \t, m_throwException(throwException)\n  {\n  }\n}"
  },
  {
    "function_name": "DefaultDecryptor",
    "container": "DefaultDecryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "125-131",
    "snippet": "DefaultDecryptor::DefaultDecryptor(const char *p, BufferedTransformation *attachment, bool throwException)\n\t: ProxyFilter(NULL, SALTLENGTH+BLOCKSIZE, 0, attachment)\n\t, m_state(WAITING_FOR_KEYCHECK)\n\t, m_passphrase((const byte *)p, strlen(p))\n\t, m_throwException(throwException)\n{\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int SALTLENGTH = 8;",
      "static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int SALTLENGTH = 8;\nstatic const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;\n\nDefaultDecryptor {\n  DefaultDecryptor::DefaultDecryptor(const char *p, BufferedTransformation *attachment, bool throwException)\n  \t: ProxyFilter(NULL, SALTLENGTH+BLOCKSIZE, 0, attachment)\n  \t, m_state(WAITING_FOR_KEYCHECK)\n  \t, m_passphrase((const byte *)p, strlen(p))\n  \t, m_throwException(throwException)\n  {\n  }\n}"
  },
  {
    "function_name": "LastPut",
    "container": "DefaultEncryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "118-121",
    "snippet": "void DefaultEncryptor::LastPut(const byte *inString, size_t length)\n{\n\tm_filter->MessageEnd();\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_filter->MessageEnd",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultEncryptor {\n  void DefaultEncryptor::LastPut(const byte *inString, size_t length)\n  {\n  \tm_filter->MessageEnd();\n  }\n}"
  },
  {
    "function_name": "FirstPut",
    "container": "DefaultEncryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "83-116",
    "snippet": "void DefaultEncryptor::FirstPut(const byte *)\n{\n\t// VC60 workaround: __LINE__ expansion bug\n\tCRYPTOPP_COMPILE_ASSERT_INSTANCE(SALTLENGTH <= DefaultHashModule::DIGESTSIZE, 1);\n\tCRYPTOPP_COMPILE_ASSERT_INSTANCE(BLOCKSIZE <= DefaultHashModule::DIGESTSIZE, 2);\n\n\tSecByteBlock salt(DefaultHashModule::DIGESTSIZE), keyCheck(DefaultHashModule::DIGESTSIZE);\n\tDefaultHashModule hash;\n\n\t// use hash(passphrase | time | clock) as salt\n\thash.Update(m_passphrase, m_passphrase.size());\n\ttime_t t=time(0);\n\thash.Update((byte *)&t, sizeof(t));\n\tclock_t c=clock();\n\thash.Update((byte *)&c, sizeof(c));\n\thash.Final(salt);\n\n\t// use hash(passphrase | salt) as key check\n\thash.Update(m_passphrase, m_passphrase.size());\n\thash.Update(salt, SALTLENGTH);\n\thash.Final(keyCheck);\n\n\tAttachedTransformation()->Put(salt, SALTLENGTH);\n\n\t// mash passphrase and salt together into key and IV\n\tSecByteBlock key(KEYLENGTH);\n\tSecByteBlock IV(BLOCKSIZE);\n\tGenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);\n\n\tm_cipher.SetKeyWithIV(key, key.size(), IV);\n\tSetFilter(new StreamTransformationFilter(m_cipher));\n\n\tm_filter->Put(keyCheck, BLOCKSIZE);\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int SALTLENGTH = 8;",
      "static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;",
      "static const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_filter->Put",
          "args": [
            "keyCheck",
            "BLOCKSIZE"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetFilter",
          "args": [
            "new StreamTransformationFilter(m_cipher)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "SetFilter",
          "container": "ProxyFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "473-483",
          "snippet": "void ProxyFilter::SetFilter(Filter *filter)\n{\n\tm_filter.reset(filter);\n\tif (filter)\n\t{\n\t\tOutputProxy *proxy;\n\t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n\t\tm_filter->TransferAllTo(*proxy);\n\t\tm_filter->Attach(temp.release());\n\t}\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nProxyFilter {\n  void ProxyFilter::SetFilter(Filter *filter)\n  {\n  \tm_filter.reset(filter);\n  \tif (filter)\n  \t{\n  \t\tOutputProxy *proxy;\n  \t\tstd::auto_ptr<OutputProxy> temp(proxy = new OutputProxy(*this, false));\n  \t\tm_filter->TransferAllTo(*proxy);\n  \t\tm_filter->Attach(temp.release());\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher.SetKeyWithIV",
          "args": [
            "key",
            "key.size()",
            "IV"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.size",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenerateKeyIV",
          "args": [
            "m_passphrase",
            "m_passphrase.size()",
            "salt",
            "SALTLENGTH",
            "key",
            "IV"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateKeyIV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
          "lines": "59-68",
          "snippet": "static void GenerateKeyIV(const byte *passphrase, size_t passphraseLength, const byte *salt, size_t saltLength, byte *key, byte *IV)\n{\n\tSecByteBlock temp(passphraseLength+saltLength);\n\tmemcpy(temp, passphrase, passphraseLength);\n\tmemcpy(temp+passphraseLength, salt, saltLength);\n\tSecByteBlock keyIV(KEYLENGTH+BLOCKSIZE);\n\tMash(temp, passphraseLength + saltLength, keyIV, KEYLENGTH+BLOCKSIZE, MASH_ITERATIONS);\n\tmemcpy(key, keyIV, KEYLENGTH);\n\tmemcpy(IV, keyIV+KEYLENGTH, BLOCKSIZE);\n}",
          "includes": [
            "#include <memory>",
            "#include <time.h>",
            "#include \"queue.h\"",
            "#include \"default.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int MASH_ITERATIONS = 200;",
            "static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;",
            "static const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int MASH_ITERATIONS = 200;\nstatic const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;\nstatic const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;\n\nstatic void GenerateKeyIV(const byte *passphrase, size_t passphraseLength, const byte *salt, size_t saltLength, byte *key, byte *IV)\n{\n\tSecByteBlock temp(passphraseLength+saltLength);\n\tmemcpy(temp, passphrase, passphraseLength);\n\tmemcpy(temp+passphraseLength, salt, saltLength);\n\tSecByteBlock keyIV(KEYLENGTH+BLOCKSIZE);\n\tMash(temp, passphraseLength + saltLength, keyIV, KEYLENGTH+BLOCKSIZE, MASH_ITERATIONS);\n\tmemcpy(key, keyIV, KEYLENGTH);\n\tmemcpy(IV, keyIV+KEYLENGTH, BLOCKSIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "salt",
            "SALTLENGTH"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.Final",
          "args": [
            "keyCheck"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.Update",
          "args": [
            "salt",
            "SALTLENGTH"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.Final",
          "args": [
            "salt"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clock",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "0"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_COMPILE_ASSERT_INSTANCE",
          "args": [
            "BLOCKSIZE <= DefaultHashModule::DIGESTSIZE",
            "2"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_COMPILE_ASSERT_INSTANCE",
          "args": [
            "SALTLENGTH <= DefaultHashModule::DIGESTSIZE",
            "1"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int SALTLENGTH = 8;\nstatic const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;\nstatic const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;\n\nDefaultEncryptor {\n  void DefaultEncryptor::FirstPut(const byte *)\n  {\n  \t// VC60 workaround: __LINE__ expansion bug\n  \tCRYPTOPP_COMPILE_ASSERT_INSTANCE(SALTLENGTH <= DefaultHashModule::DIGESTSIZE, 1);\n  \tCRYPTOPP_COMPILE_ASSERT_INSTANCE(BLOCKSIZE <= DefaultHashModule::DIGESTSIZE, 2);\n  \n  \tSecByteBlock salt(DefaultHashModule::DIGESTSIZE), keyCheck(DefaultHashModule::DIGESTSIZE);\n  \tDefaultHashModule hash;\n  \n  \t// use hash(passphrase | time | clock) as salt\n  \thash.Update(m_passphrase, m_passphrase.size());\n  \ttime_t t=time(0);\n  \thash.Update((byte *)&t, sizeof(t));\n  \tclock_t c=clock();\n  \thash.Update((byte *)&c, sizeof(c));\n  \thash.Final(salt);\n  \n  \t// use hash(passphrase | salt) as key check\n  \thash.Update(m_passphrase, m_passphrase.size());\n  \thash.Update(salt, SALTLENGTH);\n  \thash.Final(keyCheck);\n  \n  \tAttachedTransformation()->Put(salt, SALTLENGTH);\n  \n  \t// mash passphrase and salt together into key and IV\n  \tSecByteBlock key(KEYLENGTH);\n  \tSecByteBlock IV(BLOCKSIZE);\n  \tGenerateKeyIV(m_passphrase, m_passphrase.size(), salt, SALTLENGTH, key, IV);\n  \n  \tm_cipher.SetKeyWithIV(key, key.size(), IV);\n  \tSetFilter(new StreamTransformationFilter(m_cipher));\n  \n  \tm_filter->Put(keyCheck, BLOCKSIZE);\n  }\n}"
  },
  {
    "function_name": "DefaultEncryptor",
    "container": "DefaultEncryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "77-80",
    "snippet": "DefaultEncryptor::DefaultEncryptor(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment)\n\t: ProxyFilter(NULL, 0, 0, attachment), m_passphrase(passphrase, passphraseLength)\n{\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultEncryptor {\n  DefaultEncryptor::DefaultEncryptor(const byte *passphrase, size_t passphraseLength, BufferedTransformation *attachment)\n  \t: ProxyFilter(NULL, 0, 0, attachment), m_passphrase(passphrase, passphraseLength)\n  {\n  }\n}"
  },
  {
    "function_name": "DefaultEncryptor",
    "container": "DefaultEncryptor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "72-75",
    "snippet": "DefaultEncryptor::DefaultEncryptor(const char *passphrase, BufferedTransformation *attachment)\n\t: ProxyFilter(NULL, 0, 0, attachment), m_passphrase((const byte *)passphrase, strlen(passphrase))\n{\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "passphrase"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nDefaultEncryptor {\n  DefaultEncryptor::DefaultEncryptor(const char *passphrase, BufferedTransformation *attachment)\n  \t: ProxyFilter(NULL, 0, 0, attachment), m_passphrase((const byte *)passphrase, strlen(passphrase))\n  {\n  }\n}"
  },
  {
    "function_name": "GenerateKeyIV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "59-68",
    "snippet": "static void GenerateKeyIV(const byte *passphrase, size_t passphraseLength, const byte *salt, size_t saltLength, byte *key, byte *IV)\n{\n\tSecByteBlock temp(passphraseLength+saltLength);\n\tmemcpy(temp, passphrase, passphraseLength);\n\tmemcpy(temp+passphraseLength, salt, saltLength);\n\tSecByteBlock keyIV(KEYLENGTH+BLOCKSIZE);\n\tMash(temp, passphraseLength + saltLength, keyIV, KEYLENGTH+BLOCKSIZE, MASH_ITERATIONS);\n\tmemcpy(key, keyIV, KEYLENGTH);\n\tmemcpy(IV, keyIV+KEYLENGTH, BLOCKSIZE);\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int MASH_ITERATIONS = 200;",
      "static const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;",
      "static const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "IV",
            "keyIV+KEYLENGTH",
            "BLOCKSIZE"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key",
            "keyIV",
            "KEYLENGTH"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Mash",
          "args": [
            "temp",
            "passphraseLength + saltLength",
            "keyIV",
            "KEYLENGTH+BLOCKSIZE",
            "MASH_ITERATIONS"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "Mash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
          "lines": "22-57",
          "snippet": "static void Mash(const byte *in, size_t inLen, byte *out, size_t outLen, int iterations)\n{\n\tif (BytePrecision(outLen) > 2)\n\t\tthrow InvalidArgument(\"Mash: output legnth too large\");\n\n\tsize_t bufSize = RoundUpToMultipleOf(outLen, (size_t)DefaultHashModule::DIGESTSIZE);\n\tbyte b[2];\n\tSecByteBlock buf(bufSize);\n\tSecByteBlock outBuf(bufSize);\n\tDefaultHashModule hash;\n\n\tunsigned int i;\n\tfor(i=0; i<outLen; i+=DefaultHashModule::DIGESTSIZE)\n\t{\n\t\tb[0] = (byte) (i >> 8);\n\t\tb[1] = (byte) i;\n\t\thash.Update(b, 2);\n\t\thash.Update(in, inLen);\n\t\thash.Final(outBuf+i);\n\t}\n\n\twhile (iterations-- > 1)\n\t{\n\t\tmemcpy(buf, outBuf, bufSize);\n\t\tfor (i=0; i<bufSize; i+=DefaultHashModule::DIGESTSIZE)\n\t\t{\n\t\t\tb[0] = (byte) (i >> 8);\n\t\t\tb[1] = (byte) i;\n\t\t\thash.Update(b, 2);\n\t\t\thash.Update(buf, bufSize);\n\t\t\thash.Final(outBuf+i);\n\t\t}\n\t}\n\n\tmemcpy(out, outBuf, outLen);\n}",
          "includes": [
            "#include <memory>",
            "#include <time.h>",
            "#include \"queue.h\"",
            "#include \"default.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic void Mash(const byte *in, size_t inLen, byte *out, size_t outLen, int iterations)\n{\n\tif (BytePrecision(outLen) > 2)\n\t\tthrow InvalidArgument(\"Mash: output legnth too large\");\n\n\tsize_t bufSize = RoundUpToMultipleOf(outLen, (size_t)DefaultHashModule::DIGESTSIZE);\n\tbyte b[2];\n\tSecByteBlock buf(bufSize);\n\tSecByteBlock outBuf(bufSize);\n\tDefaultHashModule hash;\n\n\tunsigned int i;\n\tfor(i=0; i<outLen; i+=DefaultHashModule::DIGESTSIZE)\n\t{\n\t\tb[0] = (byte) (i >> 8);\n\t\tb[1] = (byte) i;\n\t\thash.Update(b, 2);\n\t\thash.Update(in, inLen);\n\t\thash.Final(outBuf+i);\n\t}\n\n\twhile (iterations-- > 1)\n\t{\n\t\tmemcpy(buf, outBuf, bufSize);\n\t\tfor (i=0; i<bufSize; i+=DefaultHashModule::DIGESTSIZE)\n\t\t{\n\t\t\tb[0] = (byte) (i >> 8);\n\t\t\tb[1] = (byte) i;\n\t\t\thash.Update(b, 2);\n\t\t\thash.Update(buf, bufSize);\n\t\t\thash.Final(outBuf+i);\n\t\t}\n\t}\n\n\tmemcpy(out, outBuf, outLen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "temp+passphraseLength",
            "salt",
            "saltLength"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "temp",
            "passphrase",
            "passphraseLength"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic const unsigned int MASH_ITERATIONS = 200;\nstatic const unsigned int BLOCKSIZE = Default_BlockCipher::Encryption::BLOCKSIZE;\nstatic const unsigned int KEYLENGTH = Default_BlockCipher::Encryption::DEFAULT_KEYLENGTH;\n\nstatic void GenerateKeyIV(const byte *passphrase, size_t passphraseLength, const byte *salt, size_t saltLength, byte *key, byte *IV)\n{\n\tSecByteBlock temp(passphraseLength+saltLength);\n\tmemcpy(temp, passphrase, passphraseLength);\n\tmemcpy(temp+passphraseLength, salt, saltLength);\n\tSecByteBlock keyIV(KEYLENGTH+BLOCKSIZE);\n\tMash(temp, passphraseLength + saltLength, keyIV, KEYLENGTH+BLOCKSIZE, MASH_ITERATIONS);\n\tmemcpy(key, keyIV, KEYLENGTH);\n\tmemcpy(IV, keyIV+KEYLENGTH, BLOCKSIZE);\n}"
  },
  {
    "function_name": "Mash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/default.cpp",
    "lines": "22-57",
    "snippet": "static void Mash(const byte *in, size_t inLen, byte *out, size_t outLen, int iterations)\n{\n\tif (BytePrecision(outLen) > 2)\n\t\tthrow InvalidArgument(\"Mash: output legnth too large\");\n\n\tsize_t bufSize = RoundUpToMultipleOf(outLen, (size_t)DefaultHashModule::DIGESTSIZE);\n\tbyte b[2];\n\tSecByteBlock buf(bufSize);\n\tSecByteBlock outBuf(bufSize);\n\tDefaultHashModule hash;\n\n\tunsigned int i;\n\tfor(i=0; i<outLen; i+=DefaultHashModule::DIGESTSIZE)\n\t{\n\t\tb[0] = (byte) (i >> 8);\n\t\tb[1] = (byte) i;\n\t\thash.Update(b, 2);\n\t\thash.Update(in, inLen);\n\t\thash.Final(outBuf+i);\n\t}\n\n\twhile (iterations-- > 1)\n\t{\n\t\tmemcpy(buf, outBuf, bufSize);\n\t\tfor (i=0; i<bufSize; i+=DefaultHashModule::DIGESTSIZE)\n\t\t{\n\t\t\tb[0] = (byte) (i >> 8);\n\t\t\tb[1] = (byte) i;\n\t\t\thash.Update(b, 2);\n\t\t\thash.Update(buf, bufSize);\n\t\t\thash.Final(outBuf+i);\n\t\t}\n\t}\n\n\tmemcpy(out, outBuf, outLen);\n}",
    "includes": [
      "#include <memory>",
      "#include <time.h>",
      "#include \"queue.h\"",
      "#include \"default.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "outBuf",
            "outLen"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.Final",
          "args": [
            "outBuf+i"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.Update",
          "args": [
            "buf",
            "bufSize"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "Update",
          "container": "Adler32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/adler32.cpp",
          "lines": "8-54",
          "snippet": "void Adler32::Update(const byte *input, size_t length)\n{\n\tconst unsigned long BASE = 65521;\n\n\tunsigned long s1 = m_s1;\n\tunsigned long s2 = m_s2;\n\n\tif (length % 8 != 0)\n\t{\n\t\tdo\n\t\t{\n\t\t\ts1 += *input++;\n\t\t\ts2 += s1;\n\t\t\tlength--;\n\t\t} while (length % 8 != 0);\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\ts2 %= BASE;\n\t}\n\n\twhile (length > 0)\n\t{\n\t\ts1 += input[0]; s2 += s1;\n\t\ts1 += input[1]; s2 += s1;\n\t\ts1 += input[2]; s2 += s1;\n\t\ts1 += input[3]; s2 += s1;\n\t\ts1 += input[4]; s2 += s1;\n\t\ts1 += input[5]; s2 += s1;\n\t\ts1 += input[6]; s2 += s1;\n\t\ts1 += input[7]; s2 += s1;\n\n\t\tlength -= 8;\n\t\tinput += 8;\n\n\t\tif (s1 >= BASE)\n\t\t\ts1 -= BASE;\n\t\tif (length % 0x8000 == 0)\n\t\t\ts2 %= BASE;\n\t}\n\n\tassert(s1 < BASE);\n\tassert(s2 < BASE);\n\n\tm_s1 = (word16)s1;\n\tm_s2 = (word16)s2;\n}",
          "includes": [
            "#include \"adler32.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"adler32.h\"\n#include \"pch.h\"\n\nAdler32 {\n  void Adler32::Update(const byte *input, size_t length)\n  {\n  \tconst unsigned long BASE = 65521;\n  \n  \tunsigned long s1 = m_s1;\n  \tunsigned long s2 = m_s2;\n  \n  \tif (length % 8 != 0)\n  \t{\n  \t\tdo\n  \t\t{\n  \t\t\ts1 += *input++;\n  \t\t\ts2 += s1;\n  \t\t\tlength--;\n  \t\t} while (length % 8 != 0);\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\ts2 %= BASE;\n  \t}\n  \n  \twhile (length > 0)\n  \t{\n  \t\ts1 += input[0]; s2 += s1;\n  \t\ts1 += input[1]; s2 += s1;\n  \t\ts1 += input[2]; s2 += s1;\n  \t\ts1 += input[3]; s2 += s1;\n  \t\ts1 += input[4]; s2 += s1;\n  \t\ts1 += input[5]; s2 += s1;\n  \t\ts1 += input[6]; s2 += s1;\n  \t\ts1 += input[7]; s2 += s1;\n  \n  \t\tlength -= 8;\n  \t\tinput += 8;\n  \n  \t\tif (s1 >= BASE)\n  \t\t\ts1 -= BASE;\n  \t\tif (length % 0x8000 == 0)\n  \t\t\ts2 %= BASE;\n  \t}\n  \n  \tassert(s1 < BASE);\n  \tassert(s2 < BASE);\n  \n  \tm_s1 = (word16)s1;\n  \tm_s2 = (word16)s2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "i >> 8"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "outBuf",
            "bufSize"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.Final",
          "args": [
            "outBuf+i"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "i >> 8"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "outLen",
            "(size_t)DefaultHashModule::DIGESTSIZE"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"Mash: output legnth too large\""
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BytePrecision",
          "args": [
            "outLen"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "BytePrecision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "218-235",
          "snippet": "unsigned int BytePrecision(const T &value)\n{\n\tif (!value)\n\t\treturn 0;\n\n\tunsigned int l=0, h=8*sizeof(value);\n\n\twhile (h-l > 8)\n\t{\n\t\tunsigned int t = (l+h)/2;\n\t\tif (value >> t)\n\t\t\tl = t;\n\t\telse\n\t\t\th = t;\n\t}\n\n\treturn h/8;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nunsigned int BytePrecision(const T &value)\n{\n\tif (!value)\n\t\treturn 0;\n\n\tunsigned int l=0, h=8*sizeof(value);\n\n\twhile (h-l > 8)\n\t{\n\t\tunsigned int t = (l+h)/2;\n\t\tif (value >> t)\n\t\t\tl = t;\n\t\telse\n\t\t\th = t;\n\t}\n\n\treturn h/8;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <time.h>\n#include \"queue.h\"\n#include \"default.h\"\n#include \"pch.h\"\n\nstatic void Mash(const byte *in, size_t inLen, byte *out, size_t outLen, int iterations)\n{\n\tif (BytePrecision(outLen) > 2)\n\t\tthrow InvalidArgument(\"Mash: output legnth too large\");\n\n\tsize_t bufSize = RoundUpToMultipleOf(outLen, (size_t)DefaultHashModule::DIGESTSIZE);\n\tbyte b[2];\n\tSecByteBlock buf(bufSize);\n\tSecByteBlock outBuf(bufSize);\n\tDefaultHashModule hash;\n\n\tunsigned int i;\n\tfor(i=0; i<outLen; i+=DefaultHashModule::DIGESTSIZE)\n\t{\n\t\tb[0] = (byte) (i >> 8);\n\t\tb[1] = (byte) i;\n\t\thash.Update(b, 2);\n\t\thash.Update(in, inLen);\n\t\thash.Final(outBuf+i);\n\t}\n\n\twhile (iterations-- > 1)\n\t{\n\t\tmemcpy(buf, outBuf, bufSize);\n\t\tfor (i=0; i<bufSize; i+=DefaultHashModule::DIGESTSIZE)\n\t\t{\n\t\t\tb[0] = (byte) (i >> 8);\n\t\t\tb[1] = (byte) i;\n\t\t\thash.Update(b, 2);\n\t\t\thash.Update(buf, bufSize);\n\t\t\thash.Final(outBuf+i);\n\t\t}\n\t}\n\n\tmemcpy(out, outBuf, outLen);\n}"
  }
]