[
  {
    "function_name": "AssignFrom",
    "container": "InvertibleRabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "212-219",
    "snippet": "void InvertibleRabinFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper<RabinFunction>(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "MultiplicativeInverseOfPrime2ModPrime1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Prime2"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Prime1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper<RabinFunction>",
          "args": [
            "this",
            "source"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  void InvertibleRabinFunction::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper<RabinFunction>(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "GetVoidValue",
    "container": "InvertibleRabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "203-210",
    "snippet": "bool InvertibleRabinFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper<RabinFunction>(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "MultiplicativeInverseOfPrime2ModPrime1"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Prime2"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Prime1"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper<RabinFunction>",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper<RabinFunction>",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  bool InvertibleRabinFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n  {\n  \treturn GetValueHelper<RabinFunction>(this, name, valueType, pValue).Assignable()\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime1)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime2)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "Validate",
    "container": "InvertibleRabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "183-201",
    "snippet": "bool InvertibleRabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = RabinFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p%4 == 3 && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q%4 == 3 && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t\tpass = pass && Jacobi(m_r, m_p) == 1;\n\t\tpass = pass && Jacobi(m_r, m_q) == -1;\n\t\tpass = pass && Jacobi(m_s, m_p) == -1;\n\t\tpass = pass && Jacobi(m_s, m_q) == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyPrime",
          "args": [
            "rng",
            "m_q",
            "level-2"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "247-253",
          "snippet": "bool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "m_s",
            "m_q"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.IsPositive",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "IsPositive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "205-205",
          "snippet": "bool IsPositive() const {return NotNegative() && NotZero();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsPositive() const {return NotNegative() && NotZero();}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RabinFunction::Validate",
          "args": [
            "rng",
            "level"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "Validate",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "183-201",
          "snippet": "bool InvertibleRabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = RabinFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p%4 == 3 && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q%4 == 3 && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t\tpass = pass && Jacobi(m_r, m_p) == 1;\n\t\tpass = pass && Jacobi(m_r, m_q) == -1;\n\t\tpass = pass && Jacobi(m_s, m_p) == -1;\n\t\tpass = pass && Jacobi(m_s, m_q) == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  bool InvertibleRabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = RabinFunction::Validate(rng, level);\n  \tpass = pass && m_p > Integer::One() && m_p%4 == 3 && m_p < m_n;\n  \tpass = pass && m_q > Integer::One() && m_q%4 == 3 && m_q < m_n;\n  \tpass = pass && m_u.IsPositive() && m_u < m_p;\n  \tif (level >= 1)\n  \t{\n  \t\tpass = pass && m_p * m_q == m_n;\n  \t\tpass = pass && m_u * m_q % m_p == 1;\n  \t\tpass = pass && Jacobi(m_r, m_p) == 1;\n  \t\tpass = pass && Jacobi(m_r, m_q) == -1;\n  \t\tpass = pass && Jacobi(m_s, m_p) == -1;\n  \t\tpass = pass && Jacobi(m_s, m_q) == 1;\n  \t}\n  \tif (level >= 2)\n  \t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "CalculateInverse",
    "container": "InvertibleRabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "140-181",
    "snippet": "Integer InvertibleRabinFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &in) const\n{\n\tDoQuickSanityCheck();\n\n\tModularArithmetic modn(m_n);\n\tInteger r(rng, Integer::One(), m_n - Integer::One());\n\tr = modn.Square(r);\n\tInteger r2 = modn.Square(r);\n\tInteger c = modn.Multiply(in, r2);\t\t// blind\n\n\tInteger cp=c%m_p, cq=c%m_q;\n\n\tint jp = Jacobi(cp, m_p);\n\tint jq = Jacobi(cq, m_q);\n\n\tif (jq==-1)\n\t{\n\t\tcp = cp*EuclideanMultiplicativeInverse(m_r, m_p)%m_p;\n\t\tcq = cq*EuclideanMultiplicativeInverse(m_r, m_q)%m_q;\n\t}\n\n\tif (jp==-1)\n\t{\n\t\tcp = cp*EuclideanMultiplicativeInverse(m_s, m_p)%m_p;\n\t\tcq = cq*EuclideanMultiplicativeInverse(m_s, m_q)%m_q;\n\t}\n\n\tcp = ModularSquareRoot(cp, m_p);\n\tcq = ModularSquareRoot(cq, m_q);\n\n\tif (jp==-1)\n\t\tcp = m_p-cp;\n\n\tInteger out = CRT(cq, m_q, cp, m_p, m_u);\n\n\tout = modn.Divide(out, r);\t// unblind\n\n\tif ((jq==-1 && out.IsEven()) || (jq==1 && out.IsOdd()))\n\t\tout = m_n-out;\n\n\treturn out;\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "out.IsOdd",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "out.IsEven",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "IsEven",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "209-209",
          "snippet": "bool IsEven() const {return GetBit(0) == 0;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsEven() const {return GetBit(0) == 0;}"
        }
      },
      {
        "call_info": {
          "callee": "modn.Divide",
          "args": [
            "out",
            "r"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "Divide",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "57-58",
          "snippet": "Element Divide(Element a, Element b) const\n\t\t{return Multiply(a, MultiplicativeInverse(b));}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Divide(Element a, Element b) const\n  \t\t{return Multiply(a, MultiplicativeInverse(b));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CRT",
          "args": [
            "cq",
            "m_q",
            "cp",
            "m_p",
            "m_u"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "CRT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "553-570",
          "snippet": "Integer CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}"
        }
      },
      {
        "call_info": {
          "callee": "ModularSquareRoot",
          "args": [
            "cq",
            "m_q"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ModularSquareRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "572-619",
          "snippet": "Integer ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EuclideanMultiplicativeInverse",
          "args": [
            "m_s",
            "m_q"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "EuclideanMultiplicativeInverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "69-70",
          "snippet": "inline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)\n\t{return a.InverseMod(b);}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline Integer EuclideanMultiplicativeInverse(const Integer &a, const Integer &b)\n\t{return a.InverseMod(b);}"
        }
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "cq",
            "m_q"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "modn.Multiply",
          "args": [
            "in",
            "r2"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "Multiply",
          "container": "Word",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "309-314",
          "snippet": "static Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nWord {\n  static Word Multiply(hword a, hword b)\n  \t{\n  \t\tWord r;\n  \t\tr.m_whole = (word)a * b;\n  \t\treturn r;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "modn.Square",
          "args": [
            "r"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "Square",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "49-50",
          "snippet": "Element Square(Element a) const\n\t\t{return Multiply(a, a);}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Square(Element a) const\n  \t\t{return Multiply(a, a);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoQuickSanityCheck",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  Integer InvertibleRabinFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &in) const\n  {\n  \tDoQuickSanityCheck();\n  \n  \tModularArithmetic modn(m_n);\n  \tInteger r(rng, Integer::One(), m_n - Integer::One());\n  \tr = modn.Square(r);\n  \tInteger r2 = modn.Square(r);\n  \tInteger c = modn.Multiply(in, r2);\t\t// blind\n  \n  \tInteger cp=c%m_p, cq=c%m_q;\n  \n  \tint jp = Jacobi(cp, m_p);\n  \tint jq = Jacobi(cq, m_q);\n  \n  \tif (jq==-1)\n  \t{\n  \t\tcp = cp*EuclideanMultiplicativeInverse(m_r, m_p)%m_p;\n  \t\tcq = cq*EuclideanMultiplicativeInverse(m_r, m_q)%m_q;\n  \t}\n  \n  \tif (jp==-1)\n  \t{\n  \t\tcp = cp*EuclideanMultiplicativeInverse(m_s, m_p)%m_p;\n  \t\tcq = cq*EuclideanMultiplicativeInverse(m_s, m_q)%m_q;\n  \t}\n  \n  \tcp = ModularSquareRoot(cp, m_p);\n  \tcq = ModularSquareRoot(cq, m_q);\n  \n  \tif (jp==-1)\n  \t\tcp = m_p-cp;\n  \n  \tInteger out = CRT(cq, m_q, cp, m_p, m_u);\n  \n  \tout = modn.Divide(out, r);\t// unblind\n  \n  \tif ((jq==-1 && out.IsEven()) || (jq==1 && out.IsOdd()))\n  \t\tout = m_n-out;\n  \n  \treturn out;\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "InvertibleRabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "128-138",
    "snippet": "void InvertibleRabinFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_r.DEREncode(seq);\n\tm_s.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.DEREncode",
          "args": [
            "seq"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "128-138",
          "snippet": "void InvertibleRabinFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_r.DEREncode(seq);\n\tm_s.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  void InvertibleRabinFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tm_n.DEREncode(seq);\n  \tm_r.DEREncode(seq);\n  \tm_s.DEREncode(seq);\n  \tm_p.DEREncode(seq);\n  \tm_q.DEREncode(seq);\n  \tm_u.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "BERDecode",
    "container": "InvertibleRabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "116-126",
    "snippet": "void InvertibleRabinFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_r.BERDecode(seq);\n\tm_s.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.BERDecode",
          "args": [
            "seq"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "116-126",
          "snippet": "void InvertibleRabinFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_r.BERDecode(seq);\n\tm_s.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  void InvertibleRabinFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_n.BERDecode(seq);\n  \tm_r.BERDecode(seq);\n  \tm_s.BERDecode(seq);\n  \tm_p.BERDecode(seq);\n  \tm_q.BERDecode(seq);\n  \tm_u.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "GenerateRandom",
    "container": "InvertibleRabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "75-114",
    "snippet": "void InvertibleRabinFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleRabinFunction: specified modulus size is too small\");\n\n\t// VC70 workaround: putting these after primeParam causes overlapped stack allocation\n\tbool rFound=false, sFound=false;\n\tInteger t=2;\n\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"EquivalentTo\", 3)(\"Mod\", 4);\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\twhile (!(rFound && sFound))\n\t{\n\t\tint jp = Jacobi(t, m_p);\n\t\tint jq = Jacobi(t, m_q);\n\n\t\tif (!rFound && jp==1 && jq==-1)\n\t\t{\n\t\t\tm_r = t;\n\t\t\trFound = true;\n\t\t}\n\n\t\tif (!sFound && jp==-1 && jq==1)\n\t\t{\n\t\t\tm_s = t;\n\t\t\tsFound = true;\n\t\t}\n\n\t\t++t;\n\t}\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_q.InverseMod",
          "args": [
            "m_p"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "InverseMod",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3983-4006",
          "snippet": "word Integer::InverseMod(word mod) const\n{\n\tword g0 = mod, g1 = *this % mod;\n\tword v0 = 0, v1 = 1;\n\tword y;\n\n\twhile (g1)\n\t{\n\t\tif (g1 == 1)\n\t\t\treturn v1;\n\t\ty = g0 / g1;\n\t\tg0 = g0 % g1;\n\t\tv0 += y * v1;\n\n\t\tif (!g0)\n\t\t\tbreak;\n\t\tif (g0 == 1)\n\t\t\treturn mod-v0;\n\t\ty = g1 / g0;\n\t\tg1 = g1 % g0;\n\t\tv1 += y * v0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  word Integer::InverseMod(word mod) const\n  {\n  \tword g0 = mod, g1 = *this % mod;\n  \tword v0 = 0, v1 = 1;\n  \tword y;\n  \n  \twhile (g1)\n  \t{\n  \t\tif (g1 == 1)\n  \t\t\treturn v1;\n  \t\ty = g0 / g1;\n  \t\tg0 = g0 % g1;\n  \t\tv0 += y * v1;\n  \n  \t\tif (!g0)\n  \t\t\tbreak;\n  \t\tif (g0 == 1)\n  \t\t\treturn mod-v0;\n  \t\ty = g1 / g0;\n  \t\tg1 = g1 % g0;\n  \t\tv1 += y * v0;\n  \t}\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "t",
            "m_q"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_q.GenerateRandom",
          "args": [
            "rng",
            "primeParam"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateRandom",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "75-114",
          "snippet": "void InvertibleRabinFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleRabinFunction: specified modulus size is too small\");\n\n\t// VC70 workaround: putting these after primeParam causes overlapped stack allocation\n\tbool rFound=false, sFound=false;\n\tInteger t=2;\n\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"EquivalentTo\", 3)(\"Mod\", 4);\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\twhile (!(rFound && sFound))\n\t{\n\t\tint jp = Jacobi(t, m_p);\n\t\tint jq = Jacobi(t, m_q);\n\n\t\tif (!rFound && jp==1 && jq==-1)\n\t\t{\n\t\t\tm_r = t;\n\t\t\trFound = true;\n\t\t}\n\n\t\tif (!sFound && jp==-1 && jq==1)\n\t\t{\n\t\t\tm_s = t;\n\t\t\tsFound = true;\n\t\t}\n\n\t\t++t;\n\t}\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "MakeParametersForTwoPrimesOfEqualSize",
          "args": [
            "\"Mod\"",
            "4"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParametersForTwoPrimesOfEqualSize",
          "args": [
            "\"EquivalentTo\"",
            "3"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParametersForTwoPrimesOfEqualSize",
          "args": [
            "modulusSize"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParametersForTwoPrimesOfEqualSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "265-284",
          "snippet": "AlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nAlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"InvertibleRabinFunction: specified modulus size is too small\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alg.GetIntValue",
          "args": [
            "\"KeySize\"",
            "modulusSize"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alg.GetIntValue",
          "args": [
            "\"ModulusSize\"",
            "modulusSize"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  void InvertibleRabinFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n  {\n  \tint modulusSize = 2048;\n  \talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n  \n  \tif (modulusSize < 16)\n  \t\tthrow InvalidArgument(\"InvertibleRabinFunction: specified modulus size is too small\");\n  \n  \t// VC70 workaround: putting these after primeParam causes overlapped stack allocation\n  \tbool rFound=false, sFound=false;\n  \tInteger t=2;\n  \n  \tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n  \t\t(\"EquivalentTo\", 3)(\"Mod\", 4);\n  \tm_p.GenerateRandom(rng, primeParam);\n  \tm_q.GenerateRandom(rng, primeParam);\n  \n  \twhile (!(rFound && sFound))\n  \t{\n  \t\tint jp = Jacobi(t, m_p);\n  \t\tint jq = Jacobi(t, m_q);\n  \n  \t\tif (!rFound && jp==1 && jq==-1)\n  \t\t{\n  \t\t\tm_r = t;\n  \t\t\trFound = true;\n  \t\t}\n  \n  \t\tif (!sFound && jp==-1 && jq==1)\n  \t\t{\n  \t\t\tm_s = t;\n  \t\t\tsFound = true;\n  \t\t}\n  \n  \t\t++t;\n  \t}\n  \n  \tm_n = m_p * m_q;\n  \tm_u = m_q.InverseMod(m_p);\n  }\n}"
  },
  {
    "function_name": "AssignFrom",
    "container": "RabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "62-69",
    "snippet": "void RabinFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(QuadraticResidueModPrime1)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(QuadraticResidueModPrime2)\n\t\t;\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "QuadraticResidueModPrime2"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "QuadraticResidueModPrime1"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper",
          "args": [
            "this",
            "source"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nRabinFunction {\n  void RabinFunction::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(QuadraticResidueModPrime1)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(QuadraticResidueModPrime2)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "GetVoidValue",
    "container": "RabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "53-60",
    "snippet": "bool RabinFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(QuadraticResidueModPrime1)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(QuadraticResidueModPrime2)\n\t\t;\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "QuadraticResidueModPrime2"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "QuadraticResidueModPrime1"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nRabinFunction {\n  bool RabinFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n  {\n  \treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(QuadraticResidueModPrime1)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(QuadraticResidueModPrime2)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "Validate",
    "container": "RabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "42-51",
    "snippet": "bool RabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = true;\n\tpass = pass && m_n > Integer::One() && m_n%4 == 1;\n\tpass = pass && m_r > Integer::One() && m_r < m_n;\n\tpass = pass && m_s > Integer::One() && m_s < m_n;\n\tif (level >= 1)\n\t\tpass = pass && Jacobi(m_r, m_n) == -1 && Jacobi(m_s, m_n) == -1;\n\treturn pass;\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "m_s",
            "m_n"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nRabinFunction {\n  bool RabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = true;\n  \tpass = pass && m_n > Integer::One() && m_n%4 == 1;\n  \tpass = pass && m_r > Integer::One() && m_r < m_n;\n  \tpass = pass && m_s > Integer::One() && m_s < m_n;\n  \tif (level >= 1)\n  \t\tpass = pass && Jacobi(m_r, m_n) == -1 && Jacobi(m_s, m_n) == -1;\n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "ApplyFunction",
    "container": "RabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "30-40",
    "snippet": "Integer RabinFunction::ApplyFunction(const Integer &in) const\n{\n\tDoQuickSanityCheck();\n\n\tInteger out = in.Squared()%m_n;\n\tif (in.IsOdd())\n\t\tout = out*m_r%m_n;\n\tif (Jacobi(in, m_n)==-1)\n\t\tout = out*m_s%m_n;\n\treturn out;\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Jacobi",
          "args": [
            "in",
            "m_n"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "Jacobi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "785-810",
          "snippet": "int Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.IsOdd",
          "args": [],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "in.Squared",
          "args": [],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoQuickSanityCheck",
          "args": [],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nRabinFunction {\n  Integer RabinFunction::ApplyFunction(const Integer &in) const\n  {\n  \tDoQuickSanityCheck();\n  \n  \tInteger out = in.Squared()%m_n;\n  \tif (in.IsOdd())\n  \t\tout = out*m_r%m_n;\n  \tif (Jacobi(in, m_n)==-1)\n  \t\tout = out*m_s%m_n;\n  \treturn out;\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "RabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "21-28",
    "snippet": "void RabinFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_r.DEREncode(seq);\n\tm_s.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_s.DEREncode",
          "args": [
            "seq"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "128-138",
          "snippet": "void InvertibleRabinFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_r.DEREncode(seq);\n\tm_s.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "includes": [
            "#include \"modarith.h\"",
            "#include \"sha.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rabin.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  void InvertibleRabinFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tm_n.DEREncode(seq);\n  \tm_r.DEREncode(seq);\n  \tm_s.DEREncode(seq);\n  \tm_p.DEREncode(seq);\n  \tm_q.DEREncode(seq);\n  \tm_u.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nRabinFunction {\n  void RabinFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tm_n.DEREncode(seq);\n  \tm_r.DEREncode(seq);\n  \tm_s.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "BERDecode",
    "container": "RabinFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
    "lines": "12-19",
    "snippet": "void RabinFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_r.BERDecode(seq);\n\tm_s.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"modarith.h\"",
      "#include \"sha.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"rabin.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_s.BERDecode",
          "args": [
            "seq"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "116-126",
          "snippet": "void InvertibleRabinFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_r.BERDecode(seq);\n\tm_s.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
          "includes": [
            "#include \"modarith.h\"",
            "#include \"sha.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rabin.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  void InvertibleRabinFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_n.BERDecode(seq);\n  \tm_r.BERDecode(seq);\n  \tm_s.BERDecode(seq);\n  \tm_p.BERDecode(seq);\n  \tm_q.BERDecode(seq);\n  \tm_u.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nRabinFunction {\n  void RabinFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_n.BERDecode(seq);\n  \tm_r.BERDecode(seq);\n  \tm_s.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  }
]