[
  {
    "function_name": "swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "450-453",
    "snippet": "inline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)\n{\n\ta.swap(b);\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a.swap",
          "args": [
            "b"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "403-408",
          "snippet": "void swap(SecBlock<T, A> &b)\n\t{\n\t\tstd::swap(m_alloc, b.m_alloc);\n\t\tstd::swap(m_size, b.m_size);\n\t\tstd::swap(m_ptr, b.m_ptr);\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void swap(SecBlock<T, A> &b)\n  \t{\n  \t\tstd::swap(m_alloc, b.m_alloc);\n  \t\tstd::swap(m_size, b.m_size);\n  \t\tstd::swap(m_ptr, b.m_ptr);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\ninline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)\n{\n\ta.swap(b);\n}"
  },
  {
    "function_name": "SecBlockWithHint",
    "container": "SecBlockWithHint",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "438-438",
    "snippet": "explicit SecBlockWithHint(size_t size) : SecBlock<T, A>(size) {}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlockWithHint {\n  explicit SecBlockWithHint(size_t size) : SecBlock<T, A>(size) {}\n}"
  },
  {
    "function_name": "FixedSizeSecBlock",
    "container": "FixedSizeSecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "425-425",
    "snippet": "explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeSecBlock {\n  explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}\n}"
  },
  {
    "function_name": "swap",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "403-408",
    "snippet": "void swap(SecBlock<T, A> &b)\n\t{\n\t\tstd::swap(m_alloc, b.m_alloc);\n\t\tstd::swap(m_size, b.m_size);\n\t\tstd::swap(m_ptr, b.m_ptr);\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::swap",
          "args": [
            "m_ptr",
            "b.m_ptr"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "450-453",
          "snippet": "inline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)\n{\n\ta.swap(b);\n}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\ninline void swap(CryptoPP::SecBlock<T, A> &a, CryptoPP::SecBlock<T, A> &b)\n{\n\ta.swap(b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void swap(SecBlock<T, A> &b)\n  \t{\n  \t\tstd::swap(m_alloc, b.m_alloc);\n  \t\tstd::swap(m_size, b.m_size);\n  \t\tstd::swap(m_ptr, b.m_ptr);\n  \t}\n}"
  },
  {
    "function_name": "resize",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "396-400",
    "snippet": "void resize(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n\t\tm_size = newSize;\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_alloc.reallocate",
          "args": [
            "m_ptr",
            "m_size",
            "newSize",
            "true"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "reallocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "205-220",
          "snippet": "pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n\t{\n\t\tif (p == GetAlignedArray() && newSize <= S)\n\t\t{\n\t\t\tassert(oldSize <= S);\n\t\t\tif (oldSize > newSize)\n\t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n\t\t\treturn p;\n\t\t}\n\n\t\tpointer newPointer = allocate(newSize, NULL);\n\t\tif (preserve)\n\t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\tdeallocate(p, oldSize);\n\t\treturn newPointer;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n  \t{\n  \t\tif (p == GetAlignedArray() && newSize <= S)\n  \t\t{\n  \t\t\tassert(oldSize <= S);\n  \t\t\tif (oldSize > newSize)\n  \t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n  \t\t\treturn p;\n  \t\t}\n  \n  \t\tpointer newPointer = allocate(newSize, NULL);\n  \t\tif (preserve)\n  \t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n  \t\tdeallocate(p, oldSize);\n  \t\treturn newPointer;\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void resize(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n  \t\tm_size = newSize;\n  \t}\n}"
  },
  {
    "function_name": "CleanGrow",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "385-393",
    "snippet": "void CleanGrow(size_type newSize)\n\t{\n\t\tif (newSize > m_size)\n\t\t{\n\t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n\t\t\tmemset(m_ptr+m_size, 0, (newSize-m_size)*sizeof(T));\n\t\t\tm_size = newSize;\n\t\t}\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_ptr+m_size",
            "0",
            "(newSize-m_size)*sizeof(T)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_alloc.reallocate",
          "args": [
            "m_ptr",
            "m_size",
            "newSize",
            "true"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "reallocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "205-220",
          "snippet": "pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n\t{\n\t\tif (p == GetAlignedArray() && newSize <= S)\n\t\t{\n\t\t\tassert(oldSize <= S);\n\t\t\tif (oldSize > newSize)\n\t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n\t\t\treturn p;\n\t\t}\n\n\t\tpointer newPointer = allocate(newSize, NULL);\n\t\tif (preserve)\n\t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\tdeallocate(p, oldSize);\n\t\treturn newPointer;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n  \t{\n  \t\tif (p == GetAlignedArray() && newSize <= S)\n  \t\t{\n  \t\t\tassert(oldSize <= S);\n  \t\t\tif (oldSize > newSize)\n  \t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n  \t\t\treturn p;\n  \t\t}\n  \n  \t\tpointer newPointer = allocate(newSize, NULL);\n  \t\tif (preserve)\n  \t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n  \t\tdeallocate(p, oldSize);\n  \t\treturn newPointer;\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void CleanGrow(size_type newSize)\n  \t{\n  \t\tif (newSize > m_size)\n  \t\t{\n  \t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n  \t\t\tmemset(m_ptr+m_size, 0, (newSize-m_size)*sizeof(T));\n  \t\t\tm_size = newSize;\n  \t\t}\n  \t}\n}"
  },
  {
    "function_name": "Grow",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "375-382",
    "snippet": "void Grow(size_type newSize)\n\t{\n\t\tif (newSize > m_size)\n\t\t{\n\t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n\t\t\tm_size = newSize;\n\t\t}\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_alloc.reallocate",
          "args": [
            "m_ptr",
            "m_size",
            "newSize",
            "true"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "reallocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "205-220",
          "snippet": "pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n\t{\n\t\tif (p == GetAlignedArray() && newSize <= S)\n\t\t{\n\t\t\tassert(oldSize <= S);\n\t\t\tif (oldSize > newSize)\n\t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n\t\t\treturn p;\n\t\t}\n\n\t\tpointer newPointer = allocate(newSize, NULL);\n\t\tif (preserve)\n\t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\tdeallocate(p, oldSize);\n\t\treturn newPointer;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n  \t{\n  \t\tif (p == GetAlignedArray() && newSize <= S)\n  \t\t{\n  \t\t\tassert(oldSize <= S);\n  \t\t\tif (oldSize > newSize)\n  \t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n  \t\t\treturn p;\n  \t\t}\n  \n  \t\tpointer newPointer = allocate(newSize, NULL);\n  \t\tif (preserve)\n  \t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n  \t\tdeallocate(p, oldSize);\n  \t\treturn newPointer;\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Grow(size_type newSize)\n  \t{\n  \t\tif (newSize > m_size)\n  \t\t{\n  \t\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, true);\n  \t\t\tm_size = newSize;\n  \t\t}\n  \t}\n}"
  },
  {
    "function_name": "CleanNew",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "368-372",
    "snippet": "void CleanNew(size_type newSize)\n\t{\n\t\tNew(newSize);\n\t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset_z",
          "args": [
            "m_ptr",
            "0",
            "m_size*sizeof(T)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "New",
          "args": [
            "newSize"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "CleanNew",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "368-372",
          "snippet": "void CleanNew(size_type newSize)\n\t{\n\t\tNew(newSize);\n\t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n\t}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void CleanNew(size_type newSize)\n  \t{\n  \t\tNew(newSize);\n  \t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n  \t}\n}"
  },
  {
    "function_name": "New",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "361-365",
    "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_alloc.reallocate",
          "args": [
            "m_ptr",
            "m_size",
            "newSize",
            "false"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "reallocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "205-220",
          "snippet": "pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n\t{\n\t\tif (p == GetAlignedArray() && newSize <= S)\n\t\t{\n\t\t\tassert(oldSize <= S);\n\t\t\tif (oldSize > newSize)\n\t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n\t\t\treturn p;\n\t\t}\n\n\t\tpointer newPointer = allocate(newSize, NULL);\n\t\tif (preserve)\n\t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\tdeallocate(p, oldSize);\n\t\treturn newPointer;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n  \t{\n  \t\tif (p == GetAlignedArray() && newSize <= S)\n  \t\t{\n  \t\t\tassert(oldSize <= S);\n  \t\t\tif (oldSize > newSize)\n  \t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n  \t\t\treturn p;\n  \t\t}\n  \n  \t\tpointer newPointer = allocate(newSize, NULL);\n  \t\tif (preserve)\n  \t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n  \t\tdeallocate(p, oldSize);\n  \t\treturn newPointer;\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
  },
  {
    "function_name": "Assign",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "317-324",
    "snippet": "void Assign(const SecBlock<T, A> &t)\n\t{\n\t\tif (this != &t)\n\t\t{\n\t\t\tNew(t.m_size);\n\t\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));\n\t\t}\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "m_ptr",
            "m_size*sizeof(T)",
            "t.m_ptr",
            "m_size*sizeof(T)"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "New",
          "args": [
            "t.m_size"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "CleanNew",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "368-372",
          "snippet": "void CleanNew(size_type newSize)\n\t{\n\t\tNew(newSize);\n\t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void CleanNew(size_type newSize)\n  \t{\n  \t\tNew(newSize);\n  \t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Assign(const SecBlock<T, A> &t)\n  \t{\n  \t\tif (this != &t)\n  \t\t{\n  \t\t\tNew(t.m_size);\n  \t\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));\n  \t\t}\n  \t}\n}"
  },
  {
    "function_name": "Assign",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "310-314",
    "snippet": "void Assign(const T *t, size_type len)\n\t{\n\t\tNew(len);\n\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "m_ptr",
            "m_size*sizeof(T)",
            "t",
            "len*sizeof(T)"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "New",
          "args": [
            "len"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "CleanNew",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "368-372",
          "snippet": "void CleanNew(size_type newSize)\n\t{\n\t\tNew(newSize);\n\t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void CleanNew(size_type newSize)\n  \t{\n  \t\tNew(newSize);\n  \t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Assign(const T *t, size_type len)\n  \t{\n  \t\tNew(len);\n  \t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n  \t}\n}"
  },
  {
    "function_name": "SizeInBytes",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "307-307",
    "snippet": "size_type SizeInBytes() const {return m_size*sizeof(T);}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  size_type SizeInBytes() const {return m_size*sizeof(T);}\n}"
  },
  {
    "function_name": "empty",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "303-303",
    "snippet": "bool empty() const {return m_size == 0;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
  },
  {
    "function_name": "size",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "302-302",
    "snippet": "size_type size() const {return m_size;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  size_type size() const {return m_size;}\n}"
  },
  {
    "function_name": "data",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "300-300",
    "snippet": "typename A::const_pointer data() const {return m_ptr;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
  },
  {
    "function_name": "data",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "299-299",
    "snippet": "typename A::pointer data() {return m_ptr;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::pointer data() {return m_ptr;}\n}"
  },
  {
    "function_name": "end",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "296-297",
    "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
  },
  {
    "function_name": "end",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "294-295",
    "snippet": "iterator end()\n\t\t{return m_ptr+m_size;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  iterator end()\n  \t\t{return m_ptr+m_size;}\n}"
  },
  {
    "function_name": "begin",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "292-293",
    "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
  },
  {
    "function_name": "begin",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "290-291",
    "snippet": "iterator begin()\n\t\t{return m_ptr;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  iterator begin()\n  \t\t{return m_ptr;}\n}"
  },
  {
    "function_name": "SecBlock",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "250-258",
    "snippet": "SecBlock(const T *t, size_type len)\n\t\t: m_size(len)\n\t{\n\t\tm_ptr = m_alloc.allocate(len, NULL);\n\t\tif (t == NULL)\n\t\t\tmemset_z(m_ptr, 0, len*sizeof(T));\n\t\telse\n\t\t\tmemcpy(m_ptr, t, len*sizeof(T));\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_ptr",
            "t",
            "len*sizeof(T)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset_z",
          "args": [
            "m_ptr",
            "0",
            "len*sizeof(T)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_alloc.allocate",
          "args": [
            "len",
            "NULL"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "181-190",
          "snippet": "pointer allocate(size_type n, const void *hint)\n\t{\n\t\tif (n <= S && !m_allocated)\n\t\t{\n\t\t\tm_allocated = true;\n\t\t\treturn GetAlignedArray();\n\t\t}\n\t\telse\n\t\t\treturn m_fallbackAllocator.allocate(n, hint);\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer allocate(size_type n, const void *hint)\n  \t{\n  \t\tif (n <= S && !m_allocated)\n  \t\t{\n  \t\t\tm_allocated = true;\n  \t\t\treturn GetAlignedArray();\n  \t\t}\n  \t\telse\n  \t\t\treturn m_fallbackAllocator.allocate(n, hint);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  SecBlock(const T *t, size_type len)\n  \t\t: m_size(len)\n  \t{\n  \t\tm_ptr = m_alloc.allocate(len, NULL);\n  \t\tif (t == NULL)\n  \t\t\tmemset_z(m_ptr, 0, len*sizeof(T));\n  \t\telse\n  \t\t\tmemcpy(m_ptr, t, len*sizeof(T));\n  \t}\n}"
  },
  {
    "function_name": "SecBlock",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "248-249",
    "snippet": "SecBlock(const SecBlock<T, A> &t)\n\t\t: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "m_ptr",
            "m_size*sizeof(T)",
            "t.m_ptr",
            "m_size*sizeof(T)"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_alloc.allocate",
          "args": [
            "m_size",
            "NULL"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "181-190",
          "snippet": "pointer allocate(size_type n, const void *hint)\n\t{\n\t\tif (n <= S && !m_allocated)\n\t\t{\n\t\t\tm_allocated = true;\n\t\t\treturn GetAlignedArray();\n\t\t}\n\t\telse\n\t\t\treturn m_fallbackAllocator.allocate(n, hint);\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer allocate(size_type n, const void *hint)\n  \t{\n  \t\tif (n <= S && !m_allocated)\n  \t\t{\n  \t\t\tm_allocated = true;\n  \t\t\treturn GetAlignedArray();\n  \t\t}\n  \t\telse\n  \t\t\treturn m_fallbackAllocator.allocate(n, hint);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  SecBlock(const SecBlock<T, A> &t)\n  \t\t: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}\n}"
  },
  {
    "function_name": "SecBlock",
    "container": "SecBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "246-247",
    "snippet": "explicit SecBlock(size_type size=0)\n\t\t: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_alloc.allocate",
          "args": [
            "size",
            "NULL"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "181-190",
          "snippet": "pointer allocate(size_type n, const void *hint)\n\t{\n\t\tif (n <= S && !m_allocated)\n\t\t{\n\t\t\tm_allocated = true;\n\t\t\treturn GetAlignedArray();\n\t\t}\n\t\telse\n\t\t\treturn m_fallbackAllocator.allocate(n, hint);\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer allocate(size_type n, const void *hint)\n  \t{\n  \t\tif (n <= S && !m_allocated)\n  \t\t{\n  \t\t\tm_allocated = true;\n  \t\t\treturn GetAlignedArray();\n  \t\t}\n  \t\telse\n  \t\t\treturn m_fallbackAllocator.allocate(n, hint);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  explicit SecBlock(size_type size=0)\n  \t\t: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}\n}"
  },
  {
    "function_name": "max_size",
    "container": "FixedSizeAllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "222-222",
    "snippet": "size_type max_size() const {return STDMAX(m_fallbackAllocator.max_size(), S);}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STDMAX",
          "args": [
            "m_fallbackAllocator.max_size()",
            "S"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_fallbackAllocator.max_size",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "max_size",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "222-222",
          "snippet": "size_type max_size() const {return STDMAX(m_fallbackAllocator.max_size(), S);}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  size_type max_size() const {return STDMAX(m_fallbackAllocator.max_size(), S);}\n}"
  },
  {
    "function_name": "reallocate",
    "container": "FixedSizeAllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "205-220",
    "snippet": "pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n\t{\n\t\tif (p == GetAlignedArray() && newSize <= S)\n\t\t{\n\t\t\tassert(oldSize <= S);\n\t\t\tif (oldSize > newSize)\n\t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n\t\t\treturn p;\n\t\t}\n\n\t\tpointer newPointer = allocate(newSize, NULL);\n\t\tif (preserve)\n\t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\tdeallocate(p, oldSize);\n\t\treturn newPointer;\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deallocate",
          "args": [
            "p",
            "oldSize"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "deallocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "192-203",
          "snippet": "void deallocate(void *p, size_type n)\n\t{\n\t\tif (p == GetAlignedArray())\n\t\t{\n\t\t\tassert(n <= S);\n\t\t\tassert(m_allocated);\n\t\t\tm_allocated = false;\n\t\t\tSecureWipeArray((pointer)p, n);\n\t\t}\n\t\telse\n\t\t\tm_fallbackAllocator.deallocate(p, n);\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  void deallocate(void *p, size_type n)\n  \t{\n  \t\tif (p == GetAlignedArray())\n  \t\t{\n  \t\t\tassert(n <= S);\n  \t\t\tassert(m_allocated);\n  \t\t\tm_allocated = false;\n  \t\t\tSecureWipeArray((pointer)p, n);\n  \t\t}\n  \t\telse\n  \t\t\tm_fallbackAllocator.deallocate(p, n);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newPointer",
            "p",
            "sizeof(T)*STDMIN(oldSize, newSize)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "oldSize",
            "newSize"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SecureWipeArray",
          "args": [
            "p+newSize",
            "oldSize-newSize"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "SecureWipeArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "535-545",
          "snippet": "inline void SecureWipeArray(T *buf, size_t n)\n{\n\tif (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)\n\t\tSecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));\n\telse if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)\n\t\tSecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));\n\telse if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)\n\t\tSecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));\n\telse\n\t\tSecureWipeBuffer((byte *)buf, n * sizeof(T));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeArray(T *buf, size_t n)\n{\n\tif (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)\n\t\tSecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));\n\telse if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)\n\t\tSecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));\n\telse if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)\n\t\tSecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));\n\telse\n\t\tSecureWipeBuffer((byte *)buf, n * sizeof(T));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "oldSize <= S"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAlignedArray",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer reallocate(pointer p, size_type oldSize, size_type newSize, bool preserve)\n  \t{\n  \t\tif (p == GetAlignedArray() && newSize <= S)\n  \t\t{\n  \t\t\tassert(oldSize <= S);\n  \t\t\tif (oldSize > newSize)\n  \t\t\t\tSecureWipeArray(p+newSize, oldSize-newSize);\n  \t\t\treturn p;\n  \t\t}\n  \n  \t\tpointer newPointer = allocate(newSize, NULL);\n  \t\tif (preserve)\n  \t\t\tmemcpy(newPointer, p, sizeof(T)*STDMIN(oldSize, newSize));\n  \t\tdeallocate(p, oldSize);\n  \t\treturn newPointer;\n  \t}\n}"
  },
  {
    "function_name": "deallocate",
    "container": "FixedSizeAllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "192-203",
    "snippet": "void deallocate(void *p, size_type n)\n\t{\n\t\tif (p == GetAlignedArray())\n\t\t{\n\t\t\tassert(n <= S);\n\t\t\tassert(m_allocated);\n\t\t\tm_allocated = false;\n\t\t\tSecureWipeArray((pointer)p, n);\n\t\t}\n\t\telse\n\t\t\tm_fallbackAllocator.deallocate(p, n);\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fallbackAllocator.deallocate",
          "args": [
            "p",
            "n"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "deallocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "192-203",
          "snippet": "void deallocate(void *p, size_type n)\n\t{\n\t\tif (p == GetAlignedArray())\n\t\t{\n\t\t\tassert(n <= S);\n\t\t\tassert(m_allocated);\n\t\t\tm_allocated = false;\n\t\t\tSecureWipeArray((pointer)p, n);\n\t\t}\n\t\telse\n\t\t\tm_fallbackAllocator.deallocate(p, n);\n\t}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "SecureWipeArray",
          "args": [
            "(pointer)p",
            "n"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "SecureWipeArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "535-545",
          "snippet": "inline void SecureWipeArray(T *buf, size_t n)\n{\n\tif (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)\n\t\tSecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));\n\telse if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)\n\t\tSecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));\n\telse if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)\n\t\tSecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));\n\telse\n\t\tSecureWipeBuffer((byte *)buf, n * sizeof(T));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeArray(T *buf, size_t n)\n{\n\tif (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)\n\t\tSecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));\n\telse if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)\n\t\tSecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));\n\telse if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)\n\t\tSecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));\n\telse\n\t\tSecureWipeBuffer((byte *)buf, n * sizeof(T));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_allocated"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n <= S"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAlignedArray",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  void deallocate(void *p, size_type n)\n  \t{\n  \t\tif (p == GetAlignedArray())\n  \t\t{\n  \t\t\tassert(n <= S);\n  \t\t\tassert(m_allocated);\n  \t\t\tm_allocated = false;\n  \t\t\tSecureWipeArray((pointer)p, n);\n  \t\t}\n  \t\telse\n  \t\t\tm_fallbackAllocator.deallocate(p, n);\n  \t}\n}"
  },
  {
    "function_name": "allocate",
    "container": "FixedSizeAllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "181-190",
    "snippet": "pointer allocate(size_type n, const void *hint)\n\t{\n\t\tif (n <= S && !m_allocated)\n\t\t{\n\t\t\tm_allocated = true;\n\t\t\treturn GetAlignedArray();\n\t\t}\n\t\telse\n\t\t\treturn m_fallbackAllocator.allocate(n, hint);\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fallbackAllocator.allocate",
          "args": [
            "n",
            "hint"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "181-190",
          "snippet": "pointer allocate(size_type n, const void *hint)\n\t{\n\t\tif (n <= S && !m_allocated)\n\t\t{\n\t\t\tm_allocated = true;\n\t\t\treturn GetAlignedArray();\n\t\t}\n\t\telse\n\t\t\treturn m_fallbackAllocator.allocate(n, hint);\n\t}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "GetAlignedArray",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer allocate(size_type n, const void *hint)\n  \t{\n  \t\tif (n <= S && !m_allocated)\n  \t\t{\n  \t\t\tm_allocated = true;\n  \t\t\treturn GetAlignedArray();\n  \t\t}\n  \t\telse\n  \t\t\treturn m_fallbackAllocator.allocate(n, hint);\n  \t}\n}"
  },
  {
    "function_name": "allocate",
    "container": "FixedSizeAllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "168-179",
    "snippet": "pointer allocate(size_type n)\n\t{\n\t\tassert(IsAlignedOn(m_array, 8));\n\n\t\tif (n <= S && !m_allocated)\n\t\t{\n\t\t\tm_allocated = true;\n\t\t\treturn GetAlignedArray();\n\t\t}\n\t\telse\n\t\t\treturn m_fallbackAllocator.allocate(n);\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_fallbackAllocator.allocate",
          "args": [
            "n"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "168-179",
          "snippet": "pointer allocate(size_type n)\n\t{\n\t\tassert(IsAlignedOn(m_array, 8));\n\n\t\tif (n <= S && !m_allocated)\n\t\t{\n\t\t\tm_allocated = true;\n\t\t\treturn GetAlignedArray();\n\t\t}\n\t\telse\n\t\t\treturn m_fallbackAllocator.allocate(n);\n\t}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "GetAlignedArray",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "IsAlignedOn(m_array, 8)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAlignedOn",
          "args": [
            "m_array",
            "8"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "IsAlignedOn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "381-384",
          "snippet": "inline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer allocate(size_type n)\n  \t{\n  \t\tassert(IsAlignedOn(m_array, 8));\n  \n  \t\tif (n <= S && !m_allocated)\n  \t\t{\n  \t\t\tm_allocated = true;\n  \t\t\treturn GetAlignedArray();\n  \t\t}\n  \t\telse\n  \t\t\treturn m_fallbackAllocator.allocate(n);\n  \t}\n}"
  },
  {
    "function_name": "FixedSizeAllocatorWithCleanup",
    "container": "FixedSizeAllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "164-166",
    "snippet": "CRYPTOPP_INHERIT_ALLOCATOR_TYPES\n\n\tFixedSizeAllocatorWithCleanup() : m_allocated(false) {}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES\t\\\ntypedef typename AllocatorBase<T>::value_type value_type;\\\ntypedef typename AllocatorBase<T>::size_type size_type;\\\ntypedef typename AllocatorBase<T>::difference_type difference_type;\\\ntypedef typename AllocatorBase<T>::pointer pointer;\\\ntypedef typename AllocatorBase<T>::const_pointer const_pointer;\\\ntypedef typename AllocatorBase<T>::reference reference;\\\ntypedef typename AllocatorBase<T>::const_reference const_reference;"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_allocated",
          "args": [
            "false"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\n#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES\t\\\ntypedef typename AllocatorBase<T>::value_type value_type;\\\ntypedef typename AllocatorBase<T>::size_type size_type;\\\ntypedef typename AllocatorBase<T>::difference_type difference_type;\\\ntypedef typename AllocatorBase<T>::pointer pointer;\\\ntypedef typename AllocatorBase<T>::const_pointer const_pointer;\\\ntypedef typename AllocatorBase<T>::reference reference;\\\ntypedef typename AllocatorBase<T>::const_reference const_reference;\n\nFixedSizeAllocatorWithCleanup {\n  CRYPTOPP_INHERIT_ALLOCATOR_TYPES\n  \n  \tFixedSizeAllocatorWithCleanup() : m_allocated(false) {}\n}"
  },
  {
    "function_name": "max_size",
    "container": "NullAllocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "154-154",
    "snippet": "size_type max_size() const {return 0;}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nNullAllocator {\n  size_type max_size() const {return 0;}\n}"
  },
  {
    "function_name": "deallocate",
    "container": "NullAllocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "149-152",
    "snippet": "void deallocate(void *p, size_type n)\n\t{\n\t\tassert(false);\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nNullAllocator {\n  void deallocate(void *p, size_type n)\n  \t{\n  \t\tassert(false);\n  \t}\n}"
  },
  {
    "function_name": "allocate",
    "container": "NullAllocator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "141-147",
    "snippet": "CRYPTOPP_INHERIT_ALLOCATOR_TYPES\n\n\tpointer allocate(size_type n, const void * = NULL)\n\t{\n\t\tassert(false);\n\t\treturn NULL;\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES\t\\\ntypedef typename AllocatorBase<T>::value_type value_type;\\\ntypedef typename AllocatorBase<T>::size_type size_type;\\\ntypedef typename AllocatorBase<T>::difference_type difference_type;\\\ntypedef typename AllocatorBase<T>::pointer pointer;\\\ntypedef typename AllocatorBase<T>::const_pointer const_pointer;\\\ntypedef typename AllocatorBase<T>::reference reference;\\\ntypedef typename AllocatorBase<T>::const_reference const_reference;"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\n#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES\t\\\ntypedef typename AllocatorBase<T>::value_type value_type;\\\ntypedef typename AllocatorBase<T>::size_type size_type;\\\ntypedef typename AllocatorBase<T>::difference_type difference_type;\\\ntypedef typename AllocatorBase<T>::pointer pointer;\\\ntypedef typename AllocatorBase<T>::const_pointer const_pointer;\\\ntypedef typename AllocatorBase<T>::reference reference;\\\ntypedef typename AllocatorBase<T>::const_reference const_reference;\n\nNullAllocator {\n  CRYPTOPP_INHERIT_ALLOCATOR_TYPES\n  \n  \tpointer allocate(size_type n, const void * = NULL)\n  \t{\n  \t\tassert(false);\n  \t\treturn NULL;\n  \t}\n}"
  },
  {
    "function_name": "AllocatorWithCleanup",
    "container": "AllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "125-125",
    "snippet": "AllocatorWithCleanup(const AllocatorWithCleanup<U, A> &) {}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorWithCleanup {\n  AllocatorWithCleanup(const AllocatorWithCleanup<U, A> &) {}\n}"
  },
  {
    "function_name": "AllocatorWithCleanup",
    "container": "AllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "124-124",
    "snippet": "AllocatorWithCleanup() {}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorWithCleanup {\n  AllocatorWithCleanup() {}\n}"
  },
  {
    "function_name": "reallocate",
    "container": "AllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "115-118",
    "snippet": "pointer reallocate(T *p, size_type oldSize, size_type newSize, bool preserve)\n\t{\n\t\treturn StandardReallocate(*this, p, oldSize, newSize, preserve);\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StandardReallocate",
          "args": [
            "*this",
            "p",
            "oldSize",
            "newSize",
            "preserve"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "StandardReallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "60-77",
          "snippet": "typename A::pointer StandardReallocate(A& a, T *p, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)\n{\n\tif (oldSize == newSize)\n\t\treturn p;\n\n\tif (preserve)\n\t{\n\t\ttypename A::pointer newPointer = a.allocate(newSize, NULL);\n\t\tmemcpy_s(newPointer, sizeof(T)*newSize, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\ta.deallocate(p, oldSize);\n\t\treturn newPointer;\n\t}\n\telse\n\t{\n\t\ta.deallocate(p, oldSize);\n\t\treturn a.allocate(newSize, NULL);\n\t}\n}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\ntypename A::pointer StandardReallocate(A& a, T *p, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)\n{\n\tif (oldSize == newSize)\n\t\treturn p;\n\n\tif (preserve)\n\t{\n\t\ttypename A::pointer newPointer = a.allocate(newSize, NULL);\n\t\tmemcpy_s(newPointer, sizeof(T)*newSize, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\ta.deallocate(p, oldSize);\n\t\treturn newPointer;\n\t}\n\telse\n\t{\n\t\ta.deallocate(p, oldSize);\n\t\treturn a.allocate(newSize, NULL);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorWithCleanup {\n  pointer reallocate(T *p, size_type oldSize, size_type newSize, bool preserve)\n  \t{\n  \t\treturn StandardReallocate(*this, p, oldSize, newSize, preserve);\n  \t}\n}"
  },
  {
    "function_name": "deallocate",
    "container": "AllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "103-113",
    "snippet": "void deallocate(void *p, size_type n)\n\t{\n\t\tSecureWipeArray((pointer)p, n);\n\n#if CRYPTOPP_BOOL_ALIGN16_ENABLED\n\t\tif (T_Align16 && n*sizeof(T) >= 16)\n\t\t\treturn AlignedDeallocate(p);\n#endif\n\n\t\tUnalignedDeallocate(p);\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UnalignedDeallocate",
          "args": [
            "p"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "UnalignedDeallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "180-183",
          "snippet": "void UnalignedDeallocate(void *p)\n{\n\tfree(p);\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid UnalignedDeallocate(void *p)\n{\n\tfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AlignedDeallocate",
          "args": [
            "p"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "AlignedDeallocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "158-168",
          "snippet": "void AlignedDeallocate(void *p)\n{\n#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE\n\t_mm_free(p);\n#elif defined(CRYPTOPP_NO_ALIGNED_ALLOC)\n\tp = (byte *)p - ((byte *)p)[-1];\n\tfree(p);\n#else\n\tfree(p);\n#endif\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid AlignedDeallocate(void *p)\n{\n#ifdef CRYPTOPP_MM_MALLOC_AVAILABLE\n\t_mm_free(p);\n#elif defined(CRYPTOPP_NO_ALIGNED_ALLOC)\n\tp = (byte *)p - ((byte *)p)[-1];\n\tfree(p);\n#else\n\tfree(p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SecureWipeArray",
          "args": [
            "(pointer)p",
            "n"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "SecureWipeArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "535-545",
          "snippet": "inline void SecureWipeArray(T *buf, size_t n)\n{\n\tif (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)\n\t\tSecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));\n\telse if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)\n\t\tSecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));\n\telse if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)\n\t\tSecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));\n\telse\n\t\tSecureWipeBuffer((byte *)buf, n * sizeof(T));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void SecureWipeArray(T *buf, size_t n)\n{\n\tif (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)\n\t\tSecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));\n\telse if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)\n\t\tSecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));\n\telse if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)\n\t\tSecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));\n\telse\n\t\tSecureWipeBuffer((byte *)buf, n * sizeof(T));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorWithCleanup {\n  void deallocate(void *p, size_type n)\n  \t{\n  \t\tSecureWipeArray((pointer)p, n);\n  \n  #if CRYPTOPP_BOOL_ALIGN16_ENABLED\n  \t\tif (T_Align16 && n*sizeof(T) >= 16)\n  \t\t\treturn AlignedDeallocate(p);\n  #endif\n  \n  \t\tUnalignedDeallocate(p);\n  \t}\n}"
  },
  {
    "function_name": "allocate",
    "container": "AllocatorWithCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "87-101",
    "snippet": "CRYPTOPP_INHERIT_ALLOCATOR_TYPES\n\n\tpointer allocate(size_type n, const void * = NULL)\n\t{\n\t\tthis->CheckSize(n);\n\t\tif (n == 0)\n\t\t\treturn NULL;\n\n#if CRYPTOPP_BOOL_ALIGN16_ENABLED\n\t\tif (T_Align16 && n*sizeof(T) >= 16)\n\t\t\treturn (pointer)AlignedAllocate(n*sizeof(T));\n#endif\n\n\t\treturn (pointer)UnalignedAllocate(n*sizeof(T));\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [
      "#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES\t\\\ntypedef typename AllocatorBase<T>::value_type value_type;\\\ntypedef typename AllocatorBase<T>::size_type size_type;\\\ntypedef typename AllocatorBase<T>::difference_type difference_type;\\\ntypedef typename AllocatorBase<T>::pointer pointer;\\\ntypedef typename AllocatorBase<T>::const_pointer const_pointer;\\\ntypedef typename AllocatorBase<T>::reference reference;\\\ntypedef typename AllocatorBase<T>::const_reference const_reference;"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UnalignedAllocate",
          "args": [
            "n*sizeof(T)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlignedAllocate",
          "args": [
            "n*sizeof(T)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->CheckSize",
          "args": [
            "n"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "CheckSize",
          "container": "AllocatorBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "37-41",
          "snippet": "static void CheckSize(size_t n)\n\t{\n\t\tif (n > ~size_t(0) / sizeof(T))\n\t\t\tthrow InvalidArgument(\"AllocatorBase: requested size would cause integer overflow\");\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorBase {\n  static void CheckSize(size_t n)\n  \t{\n  \t\tif (n > ~size_t(0) / sizeof(T))\n  \t\t\tthrow InvalidArgument(\"AllocatorBase: requested size would cause integer overflow\");\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\n#define CRYPTOPP_INHERIT_ALLOCATOR_TYPES\t\\\ntypedef typename AllocatorBase<T>::value_type value_type;\\\ntypedef typename AllocatorBase<T>::size_type size_type;\\\ntypedef typename AllocatorBase<T>::difference_type difference_type;\\\ntypedef typename AllocatorBase<T>::pointer pointer;\\\ntypedef typename AllocatorBase<T>::const_pointer const_pointer;\\\ntypedef typename AllocatorBase<T>::reference reference;\\\ntypedef typename AllocatorBase<T>::const_reference const_reference;\n\nAllocatorWithCleanup {\n  CRYPTOPP_INHERIT_ALLOCATOR_TYPES\n  \n  \tpointer allocate(size_type n, const void * = NULL)\n  \t{\n  \t\tthis->CheckSize(n);\n  \t\tif (n == 0)\n  \t\t\treturn NULL;\n  \n  #if CRYPTOPP_BOOL_ALIGN16_ENABLED\n  \t\tif (T_Align16 && n*sizeof(T) >= 16)\n  \t\t\treturn (pointer)AlignedAllocate(n*sizeof(T));\n  #endif\n  \n  \t\treturn (pointer)UnalignedAllocate(n*sizeof(T));\n  \t}\n}"
  },
  {
    "function_name": "StandardReallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "60-77",
    "snippet": "typename A::pointer StandardReallocate(A& a, T *p, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)\n{\n\tif (oldSize == newSize)\n\t\treturn p;\n\n\tif (preserve)\n\t{\n\t\ttypename A::pointer newPointer = a.allocate(newSize, NULL);\n\t\tmemcpy_s(newPointer, sizeof(T)*newSize, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\ta.deallocate(p, oldSize);\n\t\treturn newPointer;\n\t}\n\telse\n\t{\n\t\ta.deallocate(p, oldSize);\n\t\treturn a.allocate(newSize, NULL);\n\t}\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a.allocate",
          "args": [
            "newSize",
            "NULL"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "allocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "181-190",
          "snippet": "pointer allocate(size_type n, const void *hint)\n\t{\n\t\tif (n <= S && !m_allocated)\n\t\t{\n\t\t\tm_allocated = true;\n\t\t\treturn GetAlignedArray();\n\t\t}\n\t\telse\n\t\t\treturn m_fallbackAllocator.allocate(n, hint);\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  pointer allocate(size_type n, const void *hint)\n  \t{\n  \t\tif (n <= S && !m_allocated)\n  \t\t{\n  \t\t\tm_allocated = true;\n  \t\t\treturn GetAlignedArray();\n  \t\t}\n  \t\telse\n  \t\t\treturn m_fallbackAllocator.allocate(n, hint);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "a.deallocate",
          "args": [
            "p",
            "oldSize"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "deallocate",
          "container": "FixedSizeAllocatorWithCleanup",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "192-203",
          "snippet": "void deallocate(void *p, size_type n)\n\t{\n\t\tif (p == GetAlignedArray())\n\t\t{\n\t\t\tassert(n <= S);\n\t\t\tassert(m_allocated);\n\t\t\tm_allocated = false;\n\t\t\tSecureWipeArray((pointer)p, n);\n\t\t}\n\t\telse\n\t\t\tm_fallbackAllocator.deallocate(p, n);\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nFixedSizeAllocatorWithCleanup {\n  void deallocate(void *p, size_type n)\n  \t{\n  \t\tif (p == GetAlignedArray())\n  \t\t{\n  \t\t\tassert(n <= S);\n  \t\t\tassert(m_allocated);\n  \t\t\tm_allocated = false;\n  \t\t\tSecureWipeArray((pointer)p, n);\n  \t\t}\n  \t\telse\n  \t\t\tm_fallbackAllocator.deallocate(p, n);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "newPointer",
            "sizeof(T)*newSize",
            "p",
            "sizeof(T)*STDMIN(oldSize, newSize)"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "oldSize",
            "newSize"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\ntypename A::pointer StandardReallocate(A& a, T *p, typename A::size_type oldSize, typename A::size_type newSize, bool preserve)\n{\n\tif (oldSize == newSize)\n\t\treturn p;\n\n\tif (preserve)\n\t{\n\t\ttypename A::pointer newPointer = a.allocate(newSize, NULL);\n\t\tmemcpy_s(newPointer, sizeof(T)*newSize, p, sizeof(T)*STDMIN(oldSize, newSize));\n\t\ta.deallocate(p, oldSize);\n\t\treturn newPointer;\n\t}\n\telse\n\t{\n\t\ta.deallocate(p, oldSize);\n\t\treturn a.allocate(newSize, NULL);\n\t}\n}"
  },
  {
    "function_name": "CheckSize",
    "container": "AllocatorBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "37-41",
    "snippet": "static void CheckSize(size_t n)\n\t{\n\t\tif (n > ~size_t(0) / sizeof(T))\n\t\t\tthrow InvalidArgument(\"AllocatorBase: requested size would cause integer overflow\");\n\t}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"AllocatorBase: requested size would cause integer overflow\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "0"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorBase {\n  static void CheckSize(size_t n)\n  \t{\n  \t\tif (n > ~size_t(0) / sizeof(T))\n  \t\t\tthrow InvalidArgument(\"AllocatorBase: requested size would cause integer overflow\");\n  \t}\n}"
  },
  {
    "function_name": "max_size",
    "container": "AllocatorBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "34-34",
    "snippet": "size_type max_size() const {return ~size_type(0)/sizeof(T);}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "size_type",
          "args": [
            "0"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorBase {\n  size_type max_size() const {return ~size_type(0)/sizeof(T);}\n}"
  },
  {
    "function_name": "destroy",
    "container": "AllocatorBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "33-33",
    "snippet": "void destroy(pointer p) {p->~T();}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p->~T",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorBase {\n  void destroy(pointer p) {p->~T();}\n}"
  },
  {
    "function_name": "construct",
    "container": "AllocatorBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "32-32",
    "snippet": "void construct(pointer p, const T& val) {new (p) T(val);}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorBase {\n  void construct(pointer p, const T& val) {new (p) T(val);}\n}"
  },
  {
    "function_name": "address",
    "container": "AllocatorBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "31-31",
    "snippet": "const_pointer address(const_reference r) const {return (&r); }",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorBase {\n  const_pointer address(const_reference r) const {return (&r); }\n}"
  },
  {
    "function_name": "address",
    "container": "AllocatorBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
    "lines": "30-30",
    "snippet": "pointer address(reference r) const {return (&r);}",
    "includes": [
      "#include <assert.h>",
      "#include \"misc.h\"",
      "#include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nAllocatorBase {\n  pointer address(reference r) const {return (&r);}\n}"
  }
]