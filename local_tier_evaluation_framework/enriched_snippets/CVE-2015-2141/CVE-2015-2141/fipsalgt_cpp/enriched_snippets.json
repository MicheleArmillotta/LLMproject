[
  {
    "function_name": "FIPS_140_AlgorithmTest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "1207-1286",
    "snippet": "int FIPS_140_AlgorithmTest(int argc, char **argv)\n{\n\targc--;\n\targv++;\n\n\tstd::string algorithm = argv[1];\n\tstd::string pathname = argv[2];\n\tunsigned int i = pathname.find_last_of(\"\\\\/\");\n\tstd::string filename = pathname.substr(i == std::string::npos ? 0 : i+1);\n\tstd::string dirname = pathname.substr(0, i);\n\n\tif (algorithm == \"auto\")\n\t{\n\t\tstring algTable[] = {\"AES\", \"ECDSA\", \"DSA\", \"HMAC\", \"RNG\", \"RSA\", \"TDES\", \"SKIPJACK\", \"SHA\"};\t// order is important here\n\t\tfor (i=0; i<sizeof(algTable)/sizeof(algTable[0]); i++)\n\t\t{\n\t\t\tif (dirname.find(algTable[i]) != std::string::npos)\n\t\t\t{\n\t\t\t\talgorithm = algTable[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ttry\n\t{\n\t\tstd::string mode;\n\t\tif (algorithm == \"SHA\")\n\t\t\tmode = IntToString(atol(filename.substr(3, 3).c_str()));\n\t\telse if (algorithm == \"RSA\")\n\t\t\tmode = filename.substr(6, 1);\n\t\telse if (filename[0] == 'S' || filename[0] == 'T')\n\t\t\tmode = filename.substr(1, 3);\n\t\telse\n\t\t\tmode = filename.substr(0, 3);\n\t\tfor (i = 0; i<mode.size(); i++)\n\t\t\tmode[i] = toupper(mode[i]);\n\t\tunsigned int feedbackSize = mode == \"CFB\" ? atoi(filename.substr(filename.find_first_of(\"0123456789\")).c_str()) : 0;\n\t\tstd::string test;\n\t\tif (algorithm == \"DSA\" || algorithm == \"ECDSA\")\n\t\t\ttest = filename.substr(0, filename.size() - 4);\n\t\telse if (algorithm == \"RSA\")\n\t\t\ttest = filename.substr(3, 3);\n\t\telse if (filename.find(\"Monte\") != std::string::npos)\n\t\t\ttest = \"MONTE\";\n\t\telse if (filename.find(\"MCT\") != std::string::npos)\n\t\t\ttest = \"MCT\";\n\t\telse\n\t\t\ttest = \"KAT\";\n\t\tbool encrypt = (filename.find(\"vrct\") == std::string::npos);\n\n\t\tBufferedTransformation *pSink = NULL;\n\n\t\tif (argc > 3)\n\t\t{\n\t\t\tstd::string outDir = argv[3];\n\n\t\t\tif (outDir == \"auto\")\n\t\t\t{\n\t\t\t\tif (dirname.substr(dirname.size()-3) == \"req\")\n\t\t\t\t\toutDir = dirname.substr(0, dirname.size()-3) + \"resp\";\n\t\t\t}\n\n\t\t\tif (*outDir.rbegin() != '\\\\' && *outDir.rbegin() != '/')\n\t\t\t\toutDir += '/';\n\t\t\tstd::string outPathname = outDir + filename.substr(0, filename.size() - 3) + \"rsp\";\n\t\t\tpSink = new FileSink(outPathname.c_str(), false);\n\t\t}\n\t\telse\n\t\t\tpSink = new FileSink(cout);\n\n\t\tFileSource(pathname.c_str(), true, new LineBreakParser(new TestDataParser(algorithm, test, mode, feedbackSize, encrypt, pSink)), false);\n\t}\n\tcatch (...)\n\t{\n\t\tcout << \"file: \" << filename << endl;\n\t\tthrow;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FileSource",
          "args": [
            "pathname.c_str()",
            "true",
            "new LineBreakParser(new TestDataParser(algorithm, test, mode, feedbackSize, encrypt, pSink))",
            "false"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathname.c_str",
          "args": [],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outPathname.c_str",
          "args": [],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "0",
            "filename.size() - 3"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.size",
          "args": [],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "outDir.rbegin",
          "args": [],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "outDir.rbegin",
          "args": [],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirname.substr",
          "args": [
            "0",
            "dirname.size()-3"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirname.substr",
          "args": [
            "dirname.size()-3"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.find",
          "args": [
            "\"vrct\""
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.find",
          "args": [
            "\"MCT\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.find",
          "args": [
            "\"Monte\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "3",
            "3"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "0",
            "filename.size() - 4"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "filename.substr(filename.find_first_of(\"0123456789\")).c_str()"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "filename.find_first_of(\"0123456789\")"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.find_first_of",
          "args": [
            "\"0123456789\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "mode[i]"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "0",
            "3"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "1",
            "3"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "6",
            "1"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "atol(filename.substr(3, 3).c_str())"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "filename.substr(3, 3).c_str()"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.substr",
          "args": [
            "3",
            "3"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirname.find",
          "args": [
            "algTable[i]"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathname.substr",
          "args": [
            "0",
            "i"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathname.substr",
          "args": [
            "i == std::string::npos ? 0 : i+1"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathname.find_last_of",
          "args": [
            "\"\\\\/\""
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nint FIPS_140_AlgorithmTest(int argc, char **argv)\n{\n\targc--;\n\targv++;\n\n\tstd::string algorithm = argv[1];\n\tstd::string pathname = argv[2];\n\tunsigned int i = pathname.find_last_of(\"\\\\/\");\n\tstd::string filename = pathname.substr(i == std::string::npos ? 0 : i+1);\n\tstd::string dirname = pathname.substr(0, i);\n\n\tif (algorithm == \"auto\")\n\t{\n\t\tstring algTable[] = {\"AES\", \"ECDSA\", \"DSA\", \"HMAC\", \"RNG\", \"RSA\", \"TDES\", \"SKIPJACK\", \"SHA\"};\t// order is important here\n\t\tfor (i=0; i<sizeof(algTable)/sizeof(algTable[0]); i++)\n\t\t{\n\t\t\tif (dirname.find(algTable[i]) != std::string::npos)\n\t\t\t{\n\t\t\t\talgorithm = algTable[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\ttry\n\t{\n\t\tstd::string mode;\n\t\tif (algorithm == \"SHA\")\n\t\t\tmode = IntToString(atol(filename.substr(3, 3).c_str()));\n\t\telse if (algorithm == \"RSA\")\n\t\t\tmode = filename.substr(6, 1);\n\t\telse if (filename[0] == 'S' || filename[0] == 'T')\n\t\t\tmode = filename.substr(1, 3);\n\t\telse\n\t\t\tmode = filename.substr(0, 3);\n\t\tfor (i = 0; i<mode.size(); i++)\n\t\t\tmode[i] = toupper(mode[i]);\n\t\tunsigned int feedbackSize = mode == \"CFB\" ? atoi(filename.substr(filename.find_first_of(\"0123456789\")).c_str()) : 0;\n\t\tstd::string test;\n\t\tif (algorithm == \"DSA\" || algorithm == \"ECDSA\")\n\t\t\ttest = filename.substr(0, filename.size() - 4);\n\t\telse if (algorithm == \"RSA\")\n\t\t\ttest = filename.substr(3, 3);\n\t\telse if (filename.find(\"Monte\") != std::string::npos)\n\t\t\ttest = \"MONTE\";\n\t\telse if (filename.find(\"MCT\") != std::string::npos)\n\t\t\ttest = \"MCT\";\n\t\telse\n\t\t\ttest = \"KAT\";\n\t\tbool encrypt = (filename.find(\"vrct\") == std::string::npos);\n\n\t\tBufferedTransformation *pSink = NULL;\n\n\t\tif (argc > 3)\n\t\t{\n\t\t\tstd::string outDir = argv[3];\n\n\t\t\tif (outDir == \"auto\")\n\t\t\t{\n\t\t\t\tif (dirname.substr(dirname.size()-3) == \"req\")\n\t\t\t\t\toutDir = dirname.substr(0, dirname.size()-3) + \"resp\";\n\t\t\t}\n\n\t\t\tif (*outDir.rbegin() != '\\\\' && *outDir.rbegin() != '/')\n\t\t\t\toutDir += '/';\n\t\t\tstd::string outPathname = outDir + filename.substr(0, filename.size() - 3) + \"rsp\";\n\t\t\tpSink = new FileSink(outPathname.c_str(), false);\n\t\t}\n\t\telse\n\t\t\tpSink = new FileSink(cout);\n\n\t\tFileSource(pathname.c_str(), true, new LineBreakParser(new TestDataParser(algorithm, test, mode, feedbackSize, encrypt, pSink)), false);\n\t}\n\tcatch (...)\n\t{\n\t\tcout << \"file: \" << filename << endl;\n\t\tthrow;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "DecodeHex",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "1181-1186",
    "snippet": "static SecByteBlock DecodeHex(const std::string &data)\n\t{\n\t\tSecByteBlock data2(data.size() / 2);\n\t\tStringSource(data, true, new HexDecoder(new ArraySink(data2, data2.size())));\n\t\treturn data2;\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "data",
            "true",
            "new HexDecoder(new ArraySink(data2, data2.size()))"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data2.size",
          "args": [],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  static SecByteBlock DecodeHex(const std::string &data)\n  \t{\n  \t\tSecByteBlock data2(data.size() / 2);\n  \t\tStringSource(data, true, new HexDecoder(new ArraySink(data2, data2.size())));\n  \t\treturn data2;\n  \t}\n}"
  },
  {
    "function_name": "IsolatedMessageEnd",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "1071-1174",
    "snippet": "bool IsolatedMessageEnd(bool blocking)\n\t{\n\t\tif (!blocking)\n\t\t\tthrow BlockingInputOnly(\"TestDataParser\");\n\n\t\tm_line.resize(0);\n\t\tm_inQueue.TransferTo(StringSink(m_line).Ref());\n\n\t\tif (m_line[0] == '#')\n\t\t\treturn false;\n\n\t\tbool copyLine = false;\n\n\t\tif (m_line[0] == '[')\n\t\t{\n\t\t\tm_bracketString = m_line.substr(1, m_line.size()-2);\n\t\t\tif (m_bracketString == \"ENCRYPT\")\n\t\t\t\tSetEncrypt(true);\n\t\t\tif (m_bracketString == \"DECRYPT\")\n\t\t\t\tSetEncrypt(false);\n\t\t\tcopyLine = true;\n\t\t}\n\n\t\tif (m_line.substr(0, 2) == \"H>\")\n\t\t{\n\t\t\tassert(m_test == \"sha\");\n\t\t\tm_bracketString = m_line.substr(2, m_line.size()-4);\n\t\t\tm_line = m_line.substr(0, 13) + \"Hashes<H\";\n\t\t\tcopyLine = true;\n\t\t}\n\n\t\tif (m_line == \"D>\")\n\t\t\tcopyLine = true;\n\n\t\tif (m_line == \"<D\")\n\t\t{\n\t\t\tm_line += \"\\n\";\n\t\t\tcopyLine = true;\n\t\t}\n\n\t\tif (copyLine)\n\t\t{\n\t\t\tm_line += '\\n';\n\t\t\tAttachedTransformation()->Put((byte *)m_line.data(), m_line.size(), blocking);\n\t\t\treturn false;\n\t\t}\n\n\t\tstd::vector<std::string> tokens = Tokenize(m_line);\n\n\t\tif (m_algorithm == \"DSA\" && m_test == \"sha\")\n\t\t{\n\t\t\tfor (unsigned int i = 0; i < tokens.size(); i++)\n\t\t\t{\n\t\t\t\tif (tokens[i] == \"^\")\n\t\t\t\t\tDoTest();\n\t\t\t\telse if (tokens[i] != \"\")\n\t\t\t\t\tm_compactString.push_back(atol(tokens[i].c_str()));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!m_line.empty() && ((m_algorithm == \"RSA\" && m_test != \"Gen\") || m_algorithm == \"RNG\" || m_algorithm == \"HMAC\" || m_algorithm == \"SHA\" || (m_algorithm == \"ECDSA\" && m_test != \"KeyPair\") || (m_algorithm == \"DSA\" && (m_test == \"PQGVer\" || m_test == \"SigVer\"))))\n\t\t\t{\n\t\t\t\t// copy input to output\n\t\t\t\tstd::string output = m_line + '\\n';\n\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t}\n\n\t\t\tfor (unsigned int i = 0; i < tokens.size(); i++)\n\t\t\t{\n\t\t\t\tif (m_firstLine && m_algorithm != \"DSA\")\n\t\t\t\t{\n\t\t\t\t\tif (tokens[i] == \"Encrypt\" || tokens[i] == \"OFB\")\n\t\t\t\t\t\tSetEncrypt(true);\n\t\t\t\t\telse if (tokens[i] == \"Decrypt\")\n\t\t\t\t\t\tSetEncrypt(false);\n\t\t\t\t\telse if (tokens[i] == \"Modes\")\n\t\t\t\t\t\tm_test = \"MONTE\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (tokens[i] != \"=\")\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected data: \" + m_line);\n\n\t\t\t\t\tconst std::string &key = tokens[i-1];\n\t\t\t\t\tstd::string &data = m_data[key];\n\t\t\t\t\tdata = (tokens.size() > i+1) ? tokens[i+1] : \"\";\n\t\t\t\t\tDataType t = m_nameToType[key];\n\t\t\t\t\tm_typeToName[t] = key;\n\t\t\t\t\tm_data2[t] = DecodeHex(data);\n\n\t\t\t\t\tif (key == m_trigger || (t == OUTPUT && !m_data2[INPUT].empty() && !isspace(m_line[0])))\n\t\t\t\t\t\tDoTest();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tm_firstLine = false;\n\n\t\treturn false;\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoTest",
          "args": [],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "m_line[0]"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data2[INPUT].empty",
          "args": [],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeHex",
          "args": [
            "data"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeHex",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "1181-1186",
          "snippet": "static SecByteBlock DecodeHex(const std::string &data)\n\t{\n\t\tSecByteBlock data2(data.size() / 2);\n\t\tStringSource(data, true, new HexDecoder(new ArraySink(data2, data2.size())));\n\t\treturn data2;\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  static SecByteBlock DecodeHex(const std::string &data)\n  \t{\n  \t\tSecByteBlock data2(data.size() / 2);\n  \t\tStringSource(data, true, new HexDecoder(new ArraySink(data2, data2.size())));\n  \t\treturn data2;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tokens.size",
          "args": [],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"TestDataParser: unexpected data: \" + m_line"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetEncrypt",
          "args": [
            "false"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "SetEncrypt",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "108-140",
          "snippet": "void SetEncrypt(bool encrypt)\n\t{\n\t\tm_encrypt = encrypt;\n\t\tif (encrypt)\n\t\t{\n\t\t\tm_nameToType[\"PLAINTEXT\"] = INPUT;\n\t\t\tm_nameToType[\"CIPHERTEXT\"] = OUTPUT;\n\t\t\tm_nameToType[\"PT\"] = INPUT;\n\t\t\tm_nameToType[\"CT\"] = OUTPUT;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_nameToType[\"PLAINTEXT\"] = OUTPUT;\n\t\t\tm_nameToType[\"CIPHERTEXT\"] = INPUT;\n\t\t\tm_nameToType[\"PT\"] = OUTPUT;\n\t\t\tm_nameToType[\"CT\"] = INPUT;\n\t\t}\n\n\t\tif (m_algorithm == \"AES\" || m_algorithm == \"TDES\")\n\t\t{\n\t\t\tif (encrypt)\n\t\t\t{\n\t\t\t\tm_trigger = \"PLAINTEXT\";\n\t\t\t\tm_typeToName[OUTPUT] = \"CIPHERTEXT\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_trigger = \"CIPHERTEXT\";\n\t\t\t\tm_typeToName[OUTPUT] = \"PLAINTEXT\";\n\t\t\t}\n\t\t\tm_count = 0;\n\t\t}\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void SetEncrypt(bool encrypt)\n  \t{\n  \t\tm_encrypt = encrypt;\n  \t\tif (encrypt)\n  \t\t{\n  \t\t\tm_nameToType[\"PLAINTEXT\"] = INPUT;\n  \t\t\tm_nameToType[\"CIPHERTEXT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"PT\"] = INPUT;\n  \t\t\tm_nameToType[\"CT\"] = OUTPUT;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tm_nameToType[\"PLAINTEXT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"CIPHERTEXT\"] = INPUT;\n  \t\t\tm_nameToType[\"PT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"CT\"] = INPUT;\n  \t\t}\n  \n  \t\tif (m_algorithm == \"AES\" || m_algorithm == \"TDES\")\n  \t\t{\n  \t\t\tif (encrypt)\n  \t\t\t{\n  \t\t\t\tm_trigger = \"PLAINTEXT\";\n  \t\t\t\tm_typeToName[OUTPUT] = \"CIPHERTEXT\";\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tm_trigger = \"CIPHERTEXT\";\n  \t\t\t\tm_typeToName[OUTPUT] = \"PLAINTEXT\";\n  \t\t\t}\n  \t\t\tm_count = 0;\n  \t\t}\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.data",
          "args": [],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "300-300",
          "snippet": "typename A::const_pointer data() const {return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_compactString.push_back",
          "args": [
            "atol(tokens[i].c_str())"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "tokens[i].c_str()"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tokens[i].c_str",
          "args": [],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DoTest",
          "args": [],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tokenize",
          "args": [
            "m_line"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "Tokenize",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "1050-1069",
          "snippet": "std::vector<std::string> Tokenize(const std::string &line)\n\t{\n\t\tstd::vector<std::string> result;\n\t\tstd::string s;\n\t\tfor (unsigned int i=0; i<line.size(); i++)\n\t\t{\n\t\t\tif (isalnum(line[i]) || line[i] == '^')\n\t\t\t\ts += line[i];\n\t\t\telse if (!s.empty())\n\t\t\t{\n\t\t\t\tresult.push_back(s);\n\t\t\t\ts = \"\";\n\t\t\t}\n\t\t\tif (line[i] == '=')\n\t\t\t\tresult.push_back(\"=\");\n\t\t}\n\t\tif (!s.empty())\n\t\t\tresult.push_back(s);\n\t\treturn result;\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  std::vector<std::string> Tokenize(const std::string &line)\n  \t{\n  \t\tstd::vector<std::string> result;\n  \t\tstd::string s;\n  \t\tfor (unsigned int i=0; i<line.size(); i++)\n  \t\t{\n  \t\t\tif (isalnum(line[i]) || line[i] == '^')\n  \t\t\t\ts += line[i];\n  \t\t\telse if (!s.empty())\n  \t\t\t{\n  \t\t\t\tresult.push_back(s);\n  \t\t\t\ts = \"\";\n  \t\t\t}\n  \t\t\tif (line[i] == '=')\n  \t\t\t\tresult.push_back(\"=\");\n  \t\t}\n  \t\tif (!s.empty())\n  \t\t\tresult.push_back(s);\n  \t\treturn result;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)m_line.data()",
            "m_line.size()",
            "blocking"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_line.substr",
          "args": [
            "0",
            "13"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_line.substr",
          "args": [
            "2",
            "m_line.size()-4"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_test == \"sha\""
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_line.substr",
          "args": [
            "0",
            "2"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_line.substr",
          "args": [
            "1",
            "m_line.size()-2"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inQueue.TransferTo",
          "args": [
            "StringSink(m_line).Ref()"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "TransferTo",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "95-101",
          "snippet": "inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n\t{\n\t\tsize_t len = m_tail-m_head;\n\t\ttarget.ChannelPutModifiable(channel, buf+m_head, len);\n\t\tm_head = m_tail;\n\t\treturn len;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n  \t{\n  \t\tsize_t len = m_tail-m_head;\n  \t\ttarget.ChannelPutModifiable(channel, buf+m_head, len);\n  \t\tm_head = m_tail;\n  \t\treturn len;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [
            "m_line"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "StringSinkTemplate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "594-595",
          "snippet": "void IsolatedInitialize(const NameValuePairs &parameters)\n\t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringSinkTemplate {\n  void IsolatedInitialize(const NameValuePairs &parameters)\n  \t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_line.resize",
          "args": [
            "0"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"TestDataParser\""
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  bool IsolatedMessageEnd(bool blocking)\n  \t{\n  \t\tif (!blocking)\n  \t\t\tthrow BlockingInputOnly(\"TestDataParser\");\n  \n  \t\tm_line.resize(0);\n  \t\tm_inQueue.TransferTo(StringSink(m_line).Ref());\n  \n  \t\tif (m_line[0] == '#')\n  \t\t\treturn false;\n  \n  \t\tbool copyLine = false;\n  \n  \t\tif (m_line[0] == '[')\n  \t\t{\n  \t\t\tm_bracketString = m_line.substr(1, m_line.size()-2);\n  \t\t\tif (m_bracketString == \"ENCRYPT\")\n  \t\t\t\tSetEncrypt(true);\n  \t\t\tif (m_bracketString == \"DECRYPT\")\n  \t\t\t\tSetEncrypt(false);\n  \t\t\tcopyLine = true;\n  \t\t}\n  \n  \t\tif (m_line.substr(0, 2) == \"H>\")\n  \t\t{\n  \t\t\tassert(m_test == \"sha\");\n  \t\t\tm_bracketString = m_line.substr(2, m_line.size()-4);\n  \t\t\tm_line = m_line.substr(0, 13) + \"Hashes<H\";\n  \t\t\tcopyLine = true;\n  \t\t}\n  \n  \t\tif (m_line == \"D>\")\n  \t\t\tcopyLine = true;\n  \n  \t\tif (m_line == \"<D\")\n  \t\t{\n  \t\t\tm_line += \"\\n\";\n  \t\t\tcopyLine = true;\n  \t\t}\n  \n  \t\tif (copyLine)\n  \t\t{\n  \t\t\tm_line += '\\n';\n  \t\t\tAttachedTransformation()->Put((byte *)m_line.data(), m_line.size(), blocking);\n  \t\t\treturn false;\n  \t\t}\n  \n  \t\tstd::vector<std::string> tokens = Tokenize(m_line);\n  \n  \t\tif (m_algorithm == \"DSA\" && m_test == \"sha\")\n  \t\t{\n  \t\t\tfor (unsigned int i = 0; i < tokens.size(); i++)\n  \t\t\t{\n  \t\t\t\tif (tokens[i] == \"^\")\n  \t\t\t\t\tDoTest();\n  \t\t\t\telse if (tokens[i] != \"\")\n  \t\t\t\t\tm_compactString.push_back(atol(tokens[i].c_str()));\n  \t\t\t}\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tif (!m_line.empty() && ((m_algorithm == \"RSA\" && m_test != \"Gen\") || m_algorithm == \"RNG\" || m_algorithm == \"HMAC\" || m_algorithm == \"SHA\" || (m_algorithm == \"ECDSA\" && m_test != \"KeyPair\") || (m_algorithm == \"DSA\" && (m_test == \"PQGVer\" || m_test == \"SigVer\"))))\n  \t\t\t{\n  \t\t\t\t// copy input to output\n  \t\t\t\tstd::string output = m_line + '\\n';\n  \t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t}\n  \n  \t\t\tfor (unsigned int i = 0; i < tokens.size(); i++)\n  \t\t\t{\n  \t\t\t\tif (m_firstLine && m_algorithm != \"DSA\")\n  \t\t\t\t{\n  \t\t\t\t\tif (tokens[i] == \"Encrypt\" || tokens[i] == \"OFB\")\n  \t\t\t\t\t\tSetEncrypt(true);\n  \t\t\t\t\telse if (tokens[i] == \"Decrypt\")\n  \t\t\t\t\t\tSetEncrypt(false);\n  \t\t\t\t\telse if (tokens[i] == \"Modes\")\n  \t\t\t\t\t\tm_test = \"MONTE\";\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\tif (tokens[i] != \"=\")\n  \t\t\t\t\t\tcontinue;\n  \n  \t\t\t\t\tif (i == 0)\n  \t\t\t\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected data: \" + m_line);\n  \n  \t\t\t\t\tconst std::string &key = tokens[i-1];\n  \t\t\t\t\tstd::string &data = m_data[key];\n  \t\t\t\t\tdata = (tokens.size() > i+1) ? tokens[i+1] : \"\";\n  \t\t\t\t\tDataType t = m_nameToType[key];\n  \t\t\t\t\tm_typeToName[t] = key;\n  \t\t\t\t\tm_data2[t] = DecodeHex(data);\n  \n  \t\t\t\t\tif (key == m_trigger || (t == OUTPUT && !m_data2[INPUT].empty() && !isspace(m_line[0])))\n  \t\t\t\t\t\tDoTest();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \n  \t\tm_firstLine = false;\n  \n  \t\treturn false;\n  \t}\n}"
  },
  {
    "function_name": "Tokenize",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "1050-1069",
    "snippet": "std::vector<std::string> Tokenize(const std::string &line)\n\t{\n\t\tstd::vector<std::string> result;\n\t\tstd::string s;\n\t\tfor (unsigned int i=0; i<line.size(); i++)\n\t\t{\n\t\t\tif (isalnum(line[i]) || line[i] == '^')\n\t\t\t\ts += line[i];\n\t\t\telse if (!s.empty())\n\t\t\t{\n\t\t\t\tresult.push_back(s);\n\t\t\t\ts = \"\";\n\t\t\t}\n\t\t\tif (line[i] == '=')\n\t\t\t\tresult.push_back(\"=\");\n\t\t}\n\t\tif (!s.empty())\n\t\t\tresult.push_back(s);\n\t\treturn result;\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "s"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.empty",
          "args": [],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "\"=\""
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "s"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "line[i]"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.size",
          "args": [],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  std::vector<std::string> Tokenize(const std::string &line)\n  \t{\n  \t\tstd::vector<std::string> result;\n  \t\tstd::string s;\n  \t\tfor (unsigned int i=0; i<line.size(); i++)\n  \t\t{\n  \t\t\tif (isalnum(line[i]) || line[i] == '^')\n  \t\t\t\ts += line[i];\n  \t\t\telse if (!s.empty())\n  \t\t\t{\n  \t\t\t\tresult.push_back(s);\n  \t\t\t\ts = \"\";\n  \t\t\t}\n  \t\t\tif (line[i] == '=')\n  \t\t\t\tresult.push_back(\"=\");\n  \t\t}\n  \t\tif (!s.empty())\n  \t\t\tresult.push_back(s);\n  \t\treturn result;\n  \t}\n}"
  },
  {
    "function_name": "DoTest",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "419-1048",
    "snippet": "virtual void DoTest()\n\t{\n\t\tstd::string output;\n\n\t\tif (m_algorithm == \"DSA\")\n\t\t{\n\t\t\tif (m_test == \"KeyPair\")\n\t\t\t{\n\t\t\t\tDL_GroupParameters_DSA pqg;\n\t\t\t\tint modLen = atol(m_bracketString.substr(6).c_str());\n\t\t\t\tpqg.GenerateRandomWithKeySize(m_rng, modLen);\n\n\t\t\t\tOutputData(output, \"P \", pqg.GetModulus());\n\t\t\t\tOutputData(output, \"Q \", pqg.GetSubgroupOrder());\n\t\t\t\tOutputData(output, \"G \", pqg.GetSubgroupGenerator());\n\n\t\t\t\tint n = atol(m_data[\"N\"].c_str());\n\t\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\t{\n\t\t\t\t\tDSA::Signer priv;\n\t\t\t\t\tpriv.AccessKey().GenerateRandom(m_rng, pqg);\n\t\t\t\t\tDSA::Verifier pub(priv);\n\n\t\t\t\t\tOutputData(output, \"X \", priv.GetKey().GetPrivateExponent());\n\t\t\t\t\tOutputData(output, \"Y \", pub.GetKey().GetPublicElement());\n\t\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\t\toutput.resize(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (m_test == \"PQGGen\")\n\t\t\t{\n\t\t\t\tint n = atol(m_data[\"N\"].c_str());\n\t\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\t{\n\t\t\t\t\tInteger p, q, h, g;\n\t\t\t\t\tint counter;\n\t\t\t\t\t\n\t\t\t\t\tSecByteBlock seed(SHA::DIGESTSIZE);\n\t\t\t\t\tdo\n\t\t\t\t\t{\n\t\t\t\t\t\tm_rng.GenerateBlock(seed, seed.size());\n\t\t\t\t\t}\n\t\t\t\t\twhile (!DSA::GeneratePrimes(seed, seed.size()*8, counter, p, 1024, q));\n\t\t\t\t\th.Randomize(m_rng, 2, p-2);\n\t\t\t\t\tg = a_exp_b_mod_c(h, (p-1)/q, p);\n\n\t\t\t\t\tOutputData(output, \"P \", p);\n\t\t\t\t\tOutputData(output, \"Q \", q);\n\t\t\t\t\tOutputData(output, \"G \", g);\n\t\t\t\t\tOutputData(output, \"Seed \", seed);\n\t\t\t\t\tOutputData(output, \"c \", counter);\n\t\t\t\t\tOutputData(output, \"H \", h, p.ByteCount());\n\t\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\t\toutput.resize(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (m_test == \"SigGen\")\n\t\t\t{\n\t\t\t\tstd::string &encodedKey = m_data[\"PrivKey\"];\n\t\t\t\tint modLen = atol(m_bracketString.substr(6).c_str());\n\t\t\t\tDSA::PrivateKey priv;\n\n\t\t\t\tif (!encodedKey.empty())\n\t\t\t\t{\n\t\t\t\t\tStringStore s(encodedKey);\n\t\t\t\t\tpriv.BERDecode(s);\n\t\t\t\t\tif (priv.GetGroupParameters().GetModulus().BitCount() != modLen)\n\t\t\t\t\t\tencodedKey.clear();\n\t\t\t\t}\n\n\t\t\t\tif (encodedKey.empty())\n\t\t\t\t{\n\t\t\t\t\tpriv.Initialize(m_rng, modLen);\n\t\t\t\t\tStringSink s(encodedKey);\n\t\t\t\t\tpriv.DEREncode(s);\n\t\t\t\t\tOutputData(output, \"P \", priv.GetGroupParameters().GetModulus());\n\t\t\t\t\tOutputData(output, \"Q \", priv.GetGroupParameters().GetSubgroupOrder());\n\t\t\t\t\tOutputData(output, \"G \", priv.GetGroupParameters().GetSubgroupGenerator());\n\t\t\t\t}\n\n\t\t\t\tDSA::Signer signer(priv);\n\t\t\t\tDSA::Verifier pub(signer);\n\t\t\t\tOutputData(output, \"Msg \", m_data[\"Msg\"]);\n\t\t\t\tOutputData(output, \"Y \", pub.GetKey().GetPublicElement());\n\n\t\t\t\tSecByteBlock sig(signer.SignatureLength());\n\t\t\t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new SignerFilter(m_rng, signer, new ArraySink(sig, sig.size()))));\n\t\t\t\tSecByteBlock R(sig, sig.size()/2), S(sig+sig.size()/2, sig.size()/2);\n\t\t\t\tOutputData(output, \"R \", R);\n\t\t\t\tOutputData(output, \"S \", S);\n\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\toutput.resize(0);\n\t\t\t}\n\t\t\telse if (m_test == \"SigVer\")\n\t\t\t{\n\t\t\t\tInteger p((m_data[\"P\"] + \"h\").c_str());\n\t\t\t\tInteger\tq((m_data[\"Q\"] + \"h\").c_str());\n\t\t\t\tInteger g((m_data[\"G\"] + \"h\").c_str());\n\t\t\t\tInteger y((m_data[\"Y\"] + \"h\").c_str());\n\t\t\t\tDSA::Verifier verifier(p, q, g, y);\n\n\t\t\t\tHexDecoder filter(new SignatureVerificationFilter(verifier));\n\t\t\t\tStringSource(m_data[\"R\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n\t\t\t\tStringSource(m_data[\"S\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n\t\t\t\tStringSource(m_data[\"Msg\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n\t\t\t\tfilter.MessageEnd();\n\t\t\t\tbyte b;\n\t\t\t\tfilter.Get(b);\n\t\t\t\tOutputData(output, \"Result \", b ? \"P\" : \"F\");\n\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\toutput.resize(0);\n\t\t\t}\n\t\t\telse if (m_test == \"PQGVer\")\n\t\t\t{\n\t\t\t\tInteger p((m_data[\"P\"] + \"h\").c_str());\n\t\t\t\tInteger\tq((m_data[\"Q\"] + \"h\").c_str());\n\t\t\t\tInteger g((m_data[\"G\"] + \"h\").c_str());\n\t\t\t\tInteger h((m_data[\"H\"] + \"h\").c_str());\n\t\t\t\tint c = atol(m_data[\"c\"].c_str());\n\t\t\t\tSecByteBlock seed(m_data[\"Seed\"].size()/2);\n\t\t\t\tStringSource(m_data[\"Seed\"], true, new HexDecoder(new ArraySink(seed, seed.size())));\n\n\t\t\t\tInteger p1, q1;\n\t\t\t\tbool result = DSA::GeneratePrimes(seed, seed.size()*8, c, p1, 1024, q1, true);\n\t\t\t\tresult = result && (p1 == p && q1 == q);\n\t\t\t\tresult = result && g == a_exp_b_mod_c(h, (p-1)/q, p);\n\n\t\t\t\tOutputData(output, \"Result \", result ? \"P\" : \"F\");\n\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\toutput.resize(0);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_algorithm == \"ECDSA\")\n\t\t{\n\t\t\tstd::map<std::string, OID> name2oid;\n\t\t\tname2oid[\"P-192\"] = ASN1::secp192r1();\n\t\t\tname2oid[\"P-224\"] = ASN1::secp224r1();\n\t\t\tname2oid[\"P-256\"] = ASN1::secp256r1();\n\t\t\tname2oid[\"P-384\"] = ASN1::secp384r1();\n\t\t\tname2oid[\"P-521\"] = ASN1::secp521r1();\n\t\t\tname2oid[\"K-163\"] = ASN1::sect163k1();\n\t\t\tname2oid[\"K-233\"] = ASN1::sect233k1();\n\t\t\tname2oid[\"K-283\"] = ASN1::sect283k1();\n\t\t\tname2oid[\"K-409\"] = ASN1::sect409k1();\n\t\t\tname2oid[\"K-571\"] = ASN1::sect571k1();\n\t\t\tname2oid[\"B-163\"] = ASN1::sect163r2();\n\t\t\tname2oid[\"B-233\"] = ASN1::sect233r1();\n\t\t\tname2oid[\"B-283\"] = ASN1::sect283r1();\n\t\t\tname2oid[\"B-409\"] = ASN1::sect409r1();\n\t\t\tname2oid[\"B-571\"] = ASN1::sect571r1();\n\n\t\t\tif (m_test == \"PKV\")\n\t\t\t{\n\t\t\t\tbool pass;\n\t\t\t\tif (m_bracketString[0] == 'P')\n\t\t\t\t\tpass = EC_PKV<ECP>(m_rng, DecodeHex(m_data[\"Qx\"]), DecodeHex(m_data[\"Qy\"]), name2oid[m_bracketString]);\n\t\t\t\telse\n\t\t\t\t\tpass = EC_PKV<EC2N>(m_rng, DecodeHex(m_data[\"Qx\"]), DecodeHex(m_data[\"Qy\"]), name2oid[m_bracketString]);\n\n\t\t\t\tOutputData(output, \"Result \", pass ? \"P\" : \"F\");\n\t\t\t}\n\t\t\telse if (m_test == \"KeyPair\")\n\t\t\t{\n\t\t\t\tif (m_bracketString[0] == 'P')\n\t\t\t\t\tEC_KeyPair<ECP>(output, atol(m_data[\"N\"].c_str()), name2oid[m_bracketString]);\n\t\t\t\telse\n\t\t\t\t\tEC_KeyPair<EC2N>(output, atol(m_data[\"N\"].c_str()), name2oid[m_bracketString]);\n\t\t\t}\n\t\t\telse if (m_test == \"SigGen\")\n\t\t\t{\n\t\t\t\tif (m_bracketString[0] == 'P')\n\t\t\t\t\tEC_SigGen<ECP>(output, name2oid[m_bracketString]);\n\t\t\t\telse\n\t\t\t\t\tEC_SigGen<EC2N>(output, name2oid[m_bracketString]);\n\t\t\t}\n\t\t\telse if (m_test == \"SigVer\")\n\t\t\t{\n\t\t\t\tif (m_bracketString[0] == 'P')\n\t\t\t\t\tEC_SigVer<ECP>(output, name2oid[m_bracketString]);\n\t\t\t\telse\n\t\t\t\t\tEC_SigVer<EC2N>(output, name2oid[m_bracketString]);\n\t\t\t}\n\n\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\toutput.resize(0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_algorithm == \"RSA\")\n\t\t{\n\t\t\tstd::string shaAlg = m_data[\"SHAAlg\"].substr(3);\n\n\t\t\tif (m_test == \"Ver\")\n\t\t\t{\n\t\t\t\tInteger n((m_data[\"n\"] + \"h\").c_str());\n\t\t\t\tInteger e((m_data[\"e\"] + \"h\").c_str());\n\t\t\t\tRSA::PublicKey pub;\n\t\t\t\tpub.Initialize(n, e);\n\n\t\t\t\tmember_ptr<PK_Verifier> pV(CreateRSA<PK_Verifier>(m_mode, shaAlg));\n\t\t\t\tpV->AccessMaterial().AssignFrom(pub);\n\n\t\t\t\tHexDecoder filter(new SignatureVerificationFilter(*pV));\n\t\t\t\tfor (unsigned int i=m_data[\"S\"].size(); i<pV->SignatureLength()*2; i++)\n\t\t\t\t\tfilter.Put('0');\n\t\t\t\tStringSource(m_data[\"S\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n\t\t\t\tStringSource(m_data[\"Msg\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n\t\t\t\tfilter.MessageEnd();\n\t\t\t\tbyte b;\n\t\t\t\tfilter.Get(b);\n\t\t\t\tOutputData(output, \"Result \", b ? \"P\" : \"F\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tassert(m_test == \"Gen\");\n\t\t\t\tint modLen = atol(m_bracketString.substr(6).c_str());\n\t\t\t\tstd::string &encodedKey = m_data[\"PrivKey\"];\n\t\t\t\tRSA::PrivateKey priv;\n\n\t\t\t\tif (!encodedKey.empty())\n\t\t\t\t{\n\t\t\t\t\tStringStore s(encodedKey);\n\t\t\t\t\tpriv.BERDecode(s);\n\t\t\t\t\tif (priv.GetModulus().BitCount() != modLen)\n\t\t\t\t\t\tencodedKey.clear();\n\t\t\t\t}\n\n\t\t\t\tif (encodedKey.empty())\n\t\t\t\t{\n\t\t\t\t\tpriv.Initialize(m_rng, modLen);\n\t\t\t\t\tStringSink s(encodedKey);\n\t\t\t\t\tpriv.DEREncode(s);\n\t\t\t\t\tOutputData(output, \"n \", priv.GetModulus());\n\t\t\t\t\tOutputData(output, \"e \", priv.GetPublicExponent(), modLen/8);\n\t\t\t\t}\n\n\t\t\t\tmember_ptr<PK_Signer> pS(CreateRSA<PK_Signer>(m_mode, shaAlg));\n\t\t\t\tpS->AccessMaterial().AssignFrom(priv);\n\n\t\t\t\tSecByteBlock sig(pS->SignatureLength());\n\t\t\t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new SignerFilter(m_rng, *pS, new ArraySink(sig, sig.size()))));\n\t\t\t\tOutputData(output, \"SHAAlg \", m_data[\"SHAAlg\"]);\n\t\t\t\tOutputData(output, \"Msg \", m_data[\"Msg\"]);\n\t\t\t\tOutputData(output, \"S \", sig);\n\t\t\t}\n\n\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\toutput.resize(0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_algorithm == \"SHA\")\n\t\t{\n\t\t\tmember_ptr<HashFunction> pHF;\n\n\t\t\tif (m_mode == \"1\")\n\t\t\t\tpHF.reset(new SHA1);\n\t\t\telse if (m_mode == \"224\")\n\t\t\t\tpHF.reset(new SHA224);\n\t\t\telse if (m_mode == \"256\")\n\t\t\t\tpHF.reset(new SHA256);\n\t\t\telse if (m_mode == \"384\")\n\t\t\t\tpHF.reset(new SHA384);\n\t\t\telse if (m_mode == \"512\")\n\t\t\t\tpHF.reset(new SHA512);\n\n\t\t\tif (m_test == \"MONTE\")\n\t\t\t{\n\t\t\t\tSecByteBlock seed = m_data2[INPUT];\n\t\t\t\tSecByteBlock MD[1003];\n\t\t\t\tint i,j;\n\n\t\t\t\tfor (j=0; j<100; j++)\n\t\t\t\t{\n\t\t\t\t\tMD[0] = MD[1] = MD[2] = seed;\n\t\t\t\t\tfor (i=3; i<1003; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tSecByteBlock Mi = MD[i-3] + MD[i-2] + MD[i-1];\n\t\t\t\t\t\tMD[i].resize(pHF->DigestSize());\n\t\t\t\t\t\tpHF->CalculateDigest(MD[i], Mi, Mi.size());\n\t\t\t\t\t}\n\t\t\t\t\tseed = MD[1002];\n\t\t\t\t\tOutputData(output, \"COUNT \", j);\n\t\t\t\t\tOutputData(output, \"MD \", seed);\n\t\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\t\toutput.resize(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSecByteBlock tag(pHF->DigestSize());\n\t\t\t\tSecByteBlock &msg(m_data2[INPUT]);\n\t\t\t\tint len = atol(m_data[\"Len\"].c_str());\n\t\t\t\tStringSource(msg.begin(), len/8, true, new HashFilter(*pHF, new ArraySink(tag, tag.size())));\n\t\t\t\tOutputData(output, \"MD \", tag);\n\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\toutput.resize(0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tSecByteBlock &key = m_data2[KEY_T];\n\n\t\tif (m_algorithm == \"TDES\")\n\t\t{\n\t\t\tif (!m_data[\"KEY1\"].empty())\n\t\t\t{\n\t\t\t\tconst std::string keys[3] = {m_data[\"KEY1\"], m_data[\"KEY2\"], m_data[\"KEY3\"]};\n\t\t\t\tkey.resize(24);\n\t\t\t\tHexDecoder hexDec(new ArraySink(key, key.size()));\n\t\t\t\tfor (int i=0; i<3; i++)\n\t\t\t\t\thexDec.Put((byte *)keys[i].data(), keys[i].size());\n\n\t\t\t\tif (keys[0] == keys[2])\n\t\t\t\t{\n\t\t\t\t\tif (keys[0] == keys[1])\n\t\t\t\t\t\tkey.resize(8);\n\t\t\t\t\telse\n\t\t\t\t\t\tkey.resize(16);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tkey.resize(24);\n\t\t\t}\n\t\t}\n\n\t\tif (m_algorithm == \"RNG\")\n\t\t{\n\t\t\tkey.resize(24);\n\t\t\tStringSource(m_data[\"Key1\"] + m_data[\"Key2\"] + m_data[\"Key3\"], true, new HexDecoder(new ArraySink(key, key.size())));\n\n\t\t\tSecByteBlock seed(m_data2[INPUT]), dt(m_data2[IV]), r(8);\n\t\t\tX917RNG rng(new DES_EDE3::Encryption(key, key.size()), seed, dt);\n\n\t\t\tif (m_test == \"MCT\")\n\t\t\t{\n\t\t\t\tfor (int i=0; i<10000; i++)\n\t\t\t\t\trng.GenerateBlock(r, r.size());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trng.GenerateBlock(r, r.size());\n\t\t\t}\n\n\t\t\tOutputData(output, \"R \", r);\n\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\toutput.resize(0);\n\t\t\treturn;\n\t\t}\n\n\t\tif (m_algorithm == \"HMAC\")\n\t\t{\n\t\t\tmember_ptr<MessageAuthenticationCode> pMAC;\n\n\t\t\tif (m_bracketString == \"L=20\")\n\t\t\t\tpMAC.reset(new HMAC<SHA1>);\n\t\t\telse if (m_bracketString == \"L=28\")\n\t\t\t\tpMAC.reset(new HMAC<SHA224>);\n\t\t\telse if (m_bracketString == \"L=32\")\n\t\t\t\tpMAC.reset(new HMAC<SHA256>);\n\t\t\telse if (m_bracketString == \"L=48\")\n\t\t\t\tpMAC.reset(new HMAC<SHA384>);\n\t\t\telse if (m_bracketString == \"L=64\")\n\t\t\t\tpMAC.reset(new HMAC<SHA512>);\n\t\t\telse\n\t\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected HMAC bracket string: \" + m_bracketString);\n\n\t\t\tpMAC->SetKey(key, key.size());\n\t\t\tint Tlen = atol(m_data[\"Tlen\"].c_str());\n\t\t\tSecByteBlock tag(Tlen);\n\t\t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new HashFilter(*pMAC, new ArraySink(tag, Tlen), false, Tlen)));\n\t\t\tOutputData(output, \"Mac \", tag);\n\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\toutput.resize(0);\n\t\t\treturn;\n\t\t}\n\n\t\tmember_ptr<BlockCipher> pBT;\n\t\tif (m_algorithm == \"DES\")\n\t\t\tpBT.reset(NewBT((DES*)0));\n\t\telse if (m_algorithm == \"TDES\")\n\t\t{\n\t\t\tif (key.size() == 8)\n\t\t\t\tpBT.reset(NewBT((DES*)0));\n\t\t\telse if (key.size() == 16)\n\t\t\t\tpBT.reset(NewBT((DES_EDE2*)0));\n\t\t\telse\n\t\t\t\tpBT.reset(NewBT((DES_EDE3*)0));\n\t\t}\n\t\telse if (m_algorithm == \"SKIPJACK\")\n\t\t\tpBT.reset(NewBT((SKIPJACK*)0));\n\t\telse if (m_algorithm == \"AES\")\n\t\t\tpBT.reset(NewBT((AES*)0));\n\t\telse\n\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected algorithm: \" + m_algorithm);\n\n\t\tif (!pBT->IsValidKeyLength(key.size()))\n\t\t\tkey.CleanNew(pBT->DefaultKeyLength());\t// for Scbcvrct\n\t\tpBT->SetKey(key.data(), key.size());\n\n\t\tSecByteBlock &iv = m_data2[IV];\n\t\tif (iv.empty())\n\t\t\tiv.CleanNew(pBT->BlockSize());\n\n\t\tmember_ptr<SymmetricCipher> pCipher;\n\t\tunsigned int K = m_feedbackSize;\n\n\t\tif (m_mode == \"ECB\")\n\t\t\tpCipher.reset(NewMode((ECB_Mode_ExternalCipher*)0, *pBT, iv));\n\t\telse if (m_mode == \"CBC\")\n\t\t\tpCipher.reset(NewMode((CBC_Mode_ExternalCipher*)0, *pBT, iv));\n\t\telse if (m_mode == \"CFB\")\n\t\t\tpCipher.reset(NewMode((CFB_Mode_ExternalCipher*)0, *pBT, iv));\n\t\telse if (m_mode == \"OFB\")\n\t\t\tpCipher.reset(NewMode((OFB_Mode_ExternalCipher*)0, *pBT, iv));\n\t\telse\n\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected mode: \" + m_mode);\n\n\t\tbool encrypt = m_encrypt;\n\n\t\tif (m_test == \"MONTE\")\n\t\t{\n\t\t\tSecByteBlock KEY[401];\n\t\t\tKEY[0] = key;\n\t\t\tint keySize = key.size();\n\t\t\tint blockSize = pBT->BlockSize();\n\n\t\t\tstd::vector<SecByteBlock> IB(10001), OB(10001), PT(10001), CT(10001), RESULT(10001), TXT(10001), CV(10001);\n\t\t\tPT[0] = GetData(\"PLAINTEXT\");\n\t\t\tCT[0] = GetData(\"CIPHERTEXT\");\n\t\t\tCV[0] = IB[0] = iv;\n\t\t\tTXT[0] = GetData(\"TEXT\");\n\n\t\t\tint outerCount = (m_algorithm == \"AES\") ? 100 : 400;\n\t\t\tint innerCount = (m_algorithm == \"AES\") ? 1000 : 10000;\n\n\t\t\tfor (int i=0; i<outerCount; i++)\n\t\t\t{\n\t\t\t\tpBT->SetKey(KEY[i], keySize);\n\n\t\t\t\tfor (int j=0; j<innerCount; j++)\n\t\t\t\t{\n\t\t\t\t\tif (m_mode == \"ECB\")\n\t\t\t\t\t{\n\t\t\t\t\t\tif (encrypt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIB[j] = PT[j];\n\t\t\t\t\t\t\tCT[j].resize(blockSize);\n\t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], CT[j]);\n\t\t\t\t\t\t\tPT[j+1] = CT[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIB[j] = CT[j];\n\t\t\t\t\t\t\tPT[j].resize(blockSize);\n\t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], PT[j]);\n\t\t\t\t\t\t\tCT[j+1] = PT[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (m_mode == \"OFB\")\n\t\t\t\t\t{\n\t\t\t\t\t\tOB[j].resize(blockSize);\n\t\t\t\t\t\tpBT->ProcessBlock(IB[j], OB[j]);\n\t\t\t\t\t\tXor(RESULT[j], OB[j], TXT[j]);\n\t\t\t\t\t\tTXT[j+1] = IB[j];\n\t\t\t\t\t\tIB[j+1] = OB[j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (m_mode == \"CBC\")\n\t\t\t\t\t{\n\t\t\t\t\t\tif (encrypt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tXor(IB[j], PT[j], CV[j]);\n\t\t\t\t\t\t\tCT[j].resize(blockSize);\n\t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], CT[j]);\n\t\t\t\t\t\t\tPT[j+1] = CV[j];\n\t\t\t\t\t\t\tCV[j+1] = CT[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIB[j] = CT[j];\n\t\t\t\t\t\t\tOB[j].resize(blockSize);\n\t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], OB[j]);\n\t\t\t\t\t\t\tXor(PT[j], OB[j], CV[j]);\n\t\t\t\t\t\t\tCV[j+1] = CT[j];\n\t\t\t\t\t\t\tCT[j+1] = PT[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (m_mode == \"CFB\")\n\t\t\t\t\t{\n\t\t\t\t\t\tif (encrypt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOB[j].resize(blockSize);\n\t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], OB[j]);\n\t\t\t\t\t\t\tAssignLeftMostBits(CT[j], OB[j], K);\n\t\t\t\t\t\t\tXor(CT[j], CT[j], PT[j]);\n\t\t\t\t\t\t\tAssignLeftMostBits(PT[j+1], IB[j], K);\n\t\t\t\t\t\t\tIB[j+1].resize(blockSize);\n\t\t\t\t\t\t\tmemcpy(IB[j+1], IB[j]+K/8, blockSize-K/8);\n\t\t\t\t\t\t\tmemcpy(IB[j+1]+blockSize-K/8, CT[j], K/8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOB[j].resize(blockSize);\n\t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], OB[j]);\n\t\t\t\t\t\t\tAssignLeftMostBits(PT[j], OB[j], K);\n\t\t\t\t\t\t\tXor(PT[j], PT[j], CT[j]);\n\t\t\t\t\t\t\tIB[j+1].resize(blockSize);\n\t\t\t\t\t\t\tmemcpy(IB[j+1], IB[j]+K/8, blockSize-K/8);\n\t\t\t\t\t\t\tmemcpy(IB[j+1]+blockSize-K/8, CT[j], K/8);\n\t\t\t\t\t\t\tAssignLeftMostBits(CT[j+1], OB[j], K);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected mode: \" + m_mode);\n\t\t\t\t}\n\n\t\t\t\tOutputData(output, COUNT, IntToString(i));\n\t\t\t\tOutputData(output, KEY_T, KEY[i]);\n\t\t\t\tif (m_mode == \"CBC\")\n\t\t\t\t\tOutputData(output, IV, CV[0]);\n\t\t\t\tif (m_mode == \"OFB\" || m_mode == \"CFB\")\n\t\t\t\t\tOutputData(output, IV, IB[0]);\n\t\t\t\tif (m_mode == \"ECB\" || m_mode == \"CBC\" || m_mode == \"CFB\")\n\t\t\t\t{\n\t\t\t\t\tif (encrypt)\n\t\t\t\t\t{\n\t\t\t\t\t\tOutputData(output, INPUT, PT[0]);\n\t\t\t\t\t\tOutputData(output, OUTPUT, CT[innerCount-1]);\n\t\t\t\t\t\tKEY[i+1] = UpdateKey(KEY[i], &CT[0]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tOutputData(output, INPUT, CT[0]);\n\t\t\t\t\t\tOutputData(output, OUTPUT, PT[innerCount-1]);\n\t\t\t\t\t\tKEY[i+1] = UpdateKey(KEY[i], &PT[0]);\n\t\t\t\t\t}\n\t\t\t\t\tPT[0] = PT[innerCount];\n\t\t\t\t\tIB[0] = IB[innerCount];\n\t\t\t\t\tCV[0] = CV[innerCount];\n\t\t\t\t\tCT[0] = CT[innerCount];\n\t\t\t\t}\n\t\t\t\telse if (m_mode == \"OFB\")\n\t\t\t\t{\n\t\t\t\t\tOutputData(output, INPUT, TXT[0]);\n\t\t\t\t\tOutputData(output, OUTPUT, RESULT[innerCount-1]);\n\t\t\t\t\tKEY[i+1] = UpdateKey(KEY[i], &RESULT[0]);\n\t\t\t\t\tXor(TXT[0], TXT[0], IB[innerCount-1]);\n\t\t\t\t\tIB[0] = OB[innerCount-1];\n\t\t\t\t}\n\t\t\t\toutput += \"\\n\";\n\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\toutput.resize(0);\n\t\t\t}\n\t\t}\n\t\telse if (m_test == \"MCT\")\n\t\t{\n\t\t\tSecByteBlock KEY[101];\n\t\t\tKEY[0] = key;\n\t\t\tint keySize = key.size();\n\t\t\tint blockSize = pBT->BlockSize();\n\n\t\t\tSecByteBlock ivs[101], inputs[1001], outputs[1001];\n\t\t\tivs[0] = iv;\n\t\t\tinputs[0] = m_data2[INPUT];\n\n\t\t\tfor (int i=0; i<100; i++)\n\t\t\t{\n\t\t\t\tpCipher->SetKey(KEY[i], keySize, MakeParameters(Name::IV(), (const byte *)ivs[i])(Name::FeedbackSize(), (int)K/8, false));\n\n\t\t\t\tfor (int j=0; j<1000; j++)\n\t\t\t\t{\n\t\t\t\t\toutputs[j] = inputs[j];\n\t\t\t\t\tpCipher->ProcessString(outputs[j], outputs[j].size());\n\t\t\t\t\tif (K==8 && m_mode == \"CFB\")\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j<16)\n\t\t\t\t\t\t\tinputs[j+1].Assign(ivs[i]+j, 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinputs[j+1] = outputs[j-16];\n\t\t\t\t\t}\n\t\t\t\t\telse if (m_mode == \"ECB\")\n\t\t\t\t\t\tinputs[j+1] = outputs[j];\n\t\t\t\t\telse if (j == 0)\n\t\t\t\t\t\tinputs[j+1] = ivs[i];\n\t\t\t\t\telse\n\t\t\t\t\t\tinputs[j+1] = outputs[j-1];\n\t\t\t\t}\n\n\t\t\t\tif (m_algorithm == \"AES\")\n\t\t\t\t\tOutputData(output, COUNT, m_count++);\n\t\t\t\tOutputData(output, KEY_T, KEY[i]);\n\t\t\t\tif (m_mode != \"ECB\")\n\t\t\t\t\tOutputData(output, IV, ivs[i]);\n\t\t\t\tOutputData(output, INPUT, inputs[0]);\n\t\t\t\tOutputData(output, OUTPUT, outputs[999]);\n\t\t\t\toutput += \"\\n\";\n\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t\t\toutput.resize(0);\n\n\t\t\t\tKEY[i+1] = UpdateKey(KEY[i], outputs);\n\t\t\t\tivs[i+1].CleanNew(pCipher->IVSize());\n\t\t\t\tivs[i+1] = UpdateKey(ivs[i+1], outputs);\n\t\t\t\tif (K==8 && m_mode == \"CFB\")\n\t\t\t\t\tinputs[0] = outputs[999-16];\n\t\t\t\telse if (m_mode == \"ECB\")\n\t\t\t\t\tinputs[0] = outputs[999];\n\t\t\t\telse\n\t\t\t\t\tinputs[0] = outputs[998];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert(m_test == \"KAT\");\n\n\t\t\tSecByteBlock &input = m_data2[INPUT];\n\t\t\tSecByteBlock result(input.size());\n\t\t\tmember_ptr<Filter> pFilter(new StreamTransformationFilter(*pCipher, new ArraySink(result, result.size()), StreamTransformationFilter::NO_PADDING));\n\t\t\tStringSource(input.data(), input.size(), true, pFilter.release());\n\n\t\t\tOutputGivenData(output, COUNT, true);\n\t\t\tOutputData(output, KEY_T, key);\n\t\t\tOutputGivenData(output, IV, true);\n\t\t\tOutputGivenData(output, INPUT);\n\t\t\tOutputData(output, OUTPUT, result);\n\t\t\toutput += \"\\n\";\n\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n\t\t}\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.size",
          "args": [],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "output.data",
          "args": [],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "300-300",
          "snippet": "typename A::const_pointer data() const {return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "OUTPUT",
            "result"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "OutputData",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "222-227",
          "snippet": "void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n\t{\n\t\tstd::string hexData;\n\t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n\t\tOutputData(output, t, hexData);\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n  \t{\n  \t\tstd::string hexData;\n  \t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n  \t\tOutputData(output, t, hexData);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputGivenData",
          "args": [
            "output",
            "INPUT"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "OutputGivenData",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "229-239",
          "snippet": "void OutputGivenData(std::string &output, DataType t, bool optional = false)\n\t{\n\t\tif (m_data.find(m_typeToName[t]) == m_data.end())\n\t\t{\n\t\t\tif (optional)\n\t\t\t\treturn;\n\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: key not found: \" + m_typeToName[t]);\n\t\t}\n\n\t\tOutputData(output, t, m_data[m_typeToName[t]]);\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputGivenData(std::string &output, DataType t, bool optional = false)\n  \t{\n  \t\tif (m_data.find(m_typeToName[t]) == m_data.end())\n  \t\t{\n  \t\t\tif (optional)\n  \t\t\t\treturn;\n  \t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: key not found: \" + m_typeToName[t]);\n  \t\t}\n  \n  \t\tOutputData(output, t, m_data[m_typeToName[t]]);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputGivenData",
          "args": [
            "output",
            "IV",
            "true"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputGivenData",
          "args": [
            "output",
            "COUNT",
            "true"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "input.data()",
            "input.size()",
            "true",
            "pFilter.release()"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pFilter.release",
          "args": [],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_test == \"KAT\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpdateKey",
          "args": [
            "ivs[i+1]",
            "outputs"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ivs[i+1].CleanNew",
          "args": [
            "pCipher->IVSize()"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "CleanNew",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "368-372",
          "snippet": "void CleanNew(size_type newSize)\n\t{\n\t\tNew(newSize);\n\t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void CleanNew(size_type newSize)\n  \t{\n  \t\tNew(newSize);\n  \t\tmemset_z(m_ptr, 0, m_size*sizeof(T));\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pCipher->IVSize",
          "args": [],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "IVSize",
          "container": "FixedBlockSize::FixedRounds",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/seckey.h",
          "lines": "139-139",
          "snippet": "unsigned int IVSize() const {return INFO::IV_LENGTH;}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nFixedBlockSize {\n  FixedRounds {\n    unsigned int IVSize() const {return INFO::IV_LENGTH;}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpdateKey",
          "args": [
            "KEY[i]",
            "outputs"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "output.resize",
          "args": [
            "0"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inputs[j+1].Assign",
          "args": [
            "ivs[i]+j",
            "1"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "Assign",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "310-314",
          "snippet": "void Assign(const T *t, size_type len)\n\t{\n\t\tNew(len);\n\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Assign(const T *t, size_type len)\n  \t{\n  \t\tNew(len);\n  \t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pCipher->ProcessString",
          "args": [
            "outputs[j]",
            "outputs[j].size()"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pCipher->SetKey",
          "args": [
            "KEY[i]",
            "keySize",
            "MakeParameters(Name::IV(), (const byte *)ivs[i])(Name::FeedbackSize(), (int)K/8, false)"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "Name::FeedbackSize()",
            "(int)K/8",
            "false"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::FeedbackSize",
          "args": [],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "Name::IV()",
            "(const byte *)ivs[i]"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Name::IV",
          "args": [],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->BlockSize",
          "args": [],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Xor",
          "args": [
            "TXT[0]",
            "TXT[0]",
            "IB[innerCount-1]"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "Xor",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "259-264",
          "snippet": "static inline void Xor(SecByteBlock &z, const SecByteBlock &x, const SecByteBlock &y)\n\t{\n\t\tassert(x.size() == y.size());\n\t\tz.resize(x.size());\n\t\txorbuf(z, x, y, x.size());\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  static inline void Xor(SecByteBlock &z, const SecByteBlock &x, const SecByteBlock &y)\n  \t{\n  \t\tassert(x.size() == y.size());\n  \t\tz.resize(x.size());\n  \t\txorbuf(z, x, y, x.size());\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpdateKey",
          "args": [
            "KEY[i]",
            "&RESULT[0]"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpdateKey",
          "args": [
            "KEY[i]",
            "&PT[0]"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpdateKey",
          "args": [
            "KEY[i]",
            "&CT[0]"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "i"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"TestDataParser: unexpected mode: \" + m_mode"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignLeftMostBits",
          "args": [
            "CT[j+1]",
            "OB[j]",
            "K"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "AssignLeftMostBits",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "292-295",
          "snippet": "static inline void AssignLeftMostBits(SecByteBlock &z, const SecByteBlock &x, unsigned int K)\n\t{\n\t\tz.Assign(x, K/8);\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  static inline void AssignLeftMostBits(SecByteBlock &z, const SecByteBlock &x, unsigned int K)\n  \t{\n  \t\tz.Assign(x, K/8);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "IB[j+1]+blockSize-K/8",
            "CT[j]",
            "K/8"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "IB[j+1]",
            "IB[j]+K/8",
            "blockSize-K/8"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->ProcessBlock",
          "args": [
            "IB[j]",
            "OB[j]"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "IB[j+1]+blockSize-K/8",
            "CT[j]",
            "K/8"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "IB[j+1]",
            "IB[j]+K/8",
            "blockSize-K/8"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->ProcessBlock",
          "args": [
            "IB[j]",
            "OB[j]"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->ProcessBlock",
          "args": [
            "IB[j]",
            "OB[j]"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->ProcessBlock",
          "args": [
            "IB[j]",
            "CT[j]"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->ProcessBlock",
          "args": [
            "IB[j]",
            "OB[j]"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->ProcessBlock",
          "args": [
            "IB[j]",
            "PT[j]"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->ProcessBlock",
          "args": [
            "IB[j]",
            "CT[j]"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->SetKey",
          "args": [
            "KEY[i]",
            "keySize"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetData",
          "args": [
            "\"TEXT\""
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetData",
          "args": [
            "\"CIPHERTEXT\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetData",
          "args": [
            "\"PLAINTEXT\""
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"TestDataParser: unexpected mode: \" + m_mode"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pCipher.reset",
          "args": [
            "NewMode((OFB_Mode_ExternalCipher*)0, *pBT, iv)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewMode",
          "args": [
            "(OFB_Mode_ExternalCipher*)0",
            "*pBT",
            "iv"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pCipher.reset",
          "args": [
            "NewMode((CFB_Mode_ExternalCipher*)0, *pBT, iv)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewMode",
          "args": [
            "(CFB_Mode_ExternalCipher*)0",
            "*pBT",
            "iv"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pCipher.reset",
          "args": [
            "NewMode((CBC_Mode_ExternalCipher*)0, *pBT, iv)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewMode",
          "args": [
            "(CBC_Mode_ExternalCipher*)0",
            "*pBT",
            "iv"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pCipher.reset",
          "args": [
            "NewMode((ECB_Mode_ExternalCipher*)0, *pBT, iv)"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewMode",
          "args": [
            "(ECB_Mode_ExternalCipher*)0",
            "*pBT",
            "iv"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iv.empty",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pBT->SetKey",
          "args": [
            "key.data()",
            "key.size()"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT->DefaultKeyLength",
          "args": [],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "DefaultKeyLength",
          "container": "FixedBlockSize::FixedRounds",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/seckey.h",
          "lines": "136-136",
          "snippet": "size_t DefaultKeyLength() const {return INFO::DEFAULT_KEYLENGTH;}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nFixedBlockSize {\n  FixedRounds {\n    size_t DefaultKeyLength() const {return INFO::DEFAULT_KEYLENGTH;}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pBT->IsValidKeyLength",
          "args": [
            "key.size()"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "IsValidKeyLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/eax.h",
          "lines": "25-26",
          "snippet": "bool IsValidKeyLength(size_t n) const\n\t\t{return GetMAC().IsValidKeyLength(n);}",
          "includes": [
            "#include \"cmac.h\"",
            "#include \"modes.h\"",
            "#include \"authenc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cmac.h\"\n#include \"modes.h\"\n#include \"authenc.h\"\n\nbool IsValidKeyLength(size_t n) const\n\t\t{return GetMAC().IsValidKeyLength(n);}"
        }
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"TestDataParser: unexpected algorithm: \" + m_algorithm"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT.reset",
          "args": [
            "NewBT((AES*)0)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewBT",
          "args": [
            "(AES*)0"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT.reset",
          "args": [
            "NewBT((SKIPJACK*)0)"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewBT",
          "args": [
            "(SKIPJACK*)0"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT.reset",
          "args": [
            "NewBT((DES_EDE3*)0)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewBT",
          "args": [
            "(DES_EDE3*)0"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT.reset",
          "args": [
            "NewBT((DES_EDE2*)0)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewBT",
          "args": [
            "(DES_EDE2*)0"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT.reset",
          "args": [
            "NewBT((DES*)0)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewBT",
          "args": [
            "(DES*)0"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pBT.reset",
          "args": [
            "NewBT((DES*)0)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewBT",
          "args": [
            "(DES*)0"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Msg\"]",
            "true",
            "new HexDecoder(new HashFilter(*pMAC, new ArraySink(tag, Tlen), false, Tlen))"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_data[\"Tlen\"].c_str()"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data[\"Tlen\"].c_str",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pMAC->SetKey",
          "args": [
            "key",
            "key.size()"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"TestDataParser: unexpected HMAC bracket string: \" + m_bracketString"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pMAC.reset",
          "args": [
            "new HMAC<SHA512>"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pMAC.reset",
          "args": [
            "new HMAC<SHA384>"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pMAC.reset",
          "args": [
            "new HMAC<SHA256>"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pMAC.reset",
          "args": [
            "new HMAC<SHA224>"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pMAC.reset",
          "args": [
            "new HMAC<SHA1>"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rng.GenerateBlock",
          "args": [
            "r",
            "r.size()"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateBlock",
          "container": "KDF2_RNG",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3241-3246",
          "snippet": "void GenerateBlock(byte *output, size_t size)\n\t{\n\t\tPutWord(false, BIG_ENDIAN_ORDER, m_counterAndSeed, m_counter);\n\t\t++m_counter;\n\t\tP1363_KDF2<SHA1>::DeriveKey(output, size, m_counterAndSeed, m_counterAndSeed.size(), NULL, 0);\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nKDF2_RNG {\n  void GenerateBlock(byte *output, size_t size)\n  \t{\n  \t\tPutWord(false, BIG_ENDIAN_ORDER, m_counterAndSeed, m_counter);\n  \t\t++m_counter;\n  \t\tP1363_KDF2<SHA1>::DeriveKey(output, size, m_counterAndSeed, m_counterAndSeed.size(), NULL, 0);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Key1\"] + m_data[\"Key2\"] + m_data[\"Key3\"]",
            "true",
            "new HexDecoder(new ArraySink(key, key.size()))"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hexDec.Put",
          "args": [
            "(byte *)keys[i].data()",
            "keys[i].size()"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "42-49",
          "snippet": "inline size_t Put(const byte *begin, size_t length)\n\t{\n\t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n\t\tif (buf+m_tail != begin)\n\t\t\tmemcpy(buf+m_tail, begin, l);\n\t\tm_tail += l;\n\t\treturn l;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t Put(const byte *begin, size_t length)\n  \t{\n  \t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n  \t\tif (buf+m_tail != begin)\n  \t\t\tmemcpy(buf+m_tail, begin, l);\n  \t\tm_tail += l;\n  \t\treturn l;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "msg.begin()",
            "len/8",
            "true",
            "new HashFilter(*pHF, new ArraySink(tag, tag.size()))"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg.begin",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_data[\"Len\"].c_str()"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data[\"Len\"].c_str",
          "args": [],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pHF->DigestSize",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pHF->CalculateDigest",
          "args": [
            "MD[i]",
            "Mi",
            "Mi.size()"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pHF.reset",
          "args": [
            "new SHA512"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pHF.reset",
          "args": [
            "new SHA384"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pHF.reset",
          "args": [
            "new SHA256"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pHF.reset",
          "args": [
            "new SHA224"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pHF.reset",
          "args": [
            "new SHA1"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Msg\"]",
            "true",
            "new HexDecoder(new SignerFilter(m_rng, *pS, new ArraySink(sig, sig.size())))"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pS->SignatureLength",
          "args": [],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pS->AccessMaterial",
          "args": [
            "priv"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pS->AccessMaterial",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"e \"",
            "priv.GetPublicExponent()",
            "modLen/8"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetPublicExponent",
          "args": [],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetModulus",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.DEREncode",
          "args": [
            "s"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rsa.h",
          "lines": "67-68",
          "snippet": "void DEREncode(BufferedTransformation &bt) const\n\t\t{PKCS8PrivateKey::DEREncode(bt);}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\"",
            "#include \"asn.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n#include \"asn.h\"\n#include \"pubkey.h\"\n\nvoid DEREncode(BufferedTransformation &bt) const\n\t\t{PKCS8PrivateKey::DEREncode(bt);}"
        }
      },
      {
        "call_info": {
          "callee": "priv.Initialize",
          "args": [
            "m_rng",
            "modLen"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "Initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.h",
          "lines": "54-55",
          "snippet": "void Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}",
          "includes": [
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n\nvoid Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}"
        }
      },
      {
        "call_info": {
          "callee": "encodedKey.clear",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetModulus",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetModulus",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.BERDecode",
          "args": [
            "s"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rsa.h",
          "lines": "65-66",
          "snippet": "void BERDecode(BufferedTransformation &bt)\n\t\t{PKCS8PrivateKey::BERDecode(bt);}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\"",
            "#include \"asn.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n#include \"asn.h\"\n#include \"pubkey.h\"\n\nvoid BERDecode(BufferedTransformation &bt)\n\t\t{PKCS8PrivateKey::BERDecode(bt);}"
        }
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_bracketString.substr(6).c_str()"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_bracketString.substr",
          "args": [],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_bracketString.substr",
          "args": [
            "6"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_test == \"Gen\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter.Get",
          "args": [
            "b"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter.MessageEnd",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "807-808",
          "snippet": "bool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nbool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Msg\"]",
            "true",
            "new Redirector(filter, Redirector::DATA_ONLY)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"S\"]",
            "true",
            "new Redirector(filter, Redirector::DATA_ONLY)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter.Put",
          "args": [
            "'0'"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "pV->SignatureLength",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pV->AccessMaterial",
          "args": [
            "pub"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pV->AccessMaterial",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data[\"SHAAlg\"].substr",
          "args": [
            "3"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_SigVer<EC2N>",
          "args": [
            "output",
            "name2oid[m_bracketString]"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_SigVer<ECP>",
          "args": [
            "output",
            "name2oid[m_bracketString]"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_SigGen<EC2N>",
          "args": [
            "output",
            "name2oid[m_bracketString]"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_SigGen<ECP>",
          "args": [
            "output",
            "name2oid[m_bracketString]"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KeyPair<EC2N>",
          "args": [
            "output",
            "atol(m_data[\"N\"].c_str())",
            "name2oid[m_bracketString]"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_data[\"N\"].c_str()"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data[\"N\"].c_str",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KeyPair<ECP>",
          "args": [
            "output",
            "atol(m_data[\"N\"].c_str())",
            "name2oid[m_bracketString]"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_data[\"N\"].c_str()"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data[\"N\"].c_str",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_PKV<EC2N>",
          "args": [
            "m_rng",
            "DecodeHex(m_data[\"Qx\"])",
            "DecodeHex(m_data[\"Qy\"])",
            "name2oid[m_bracketString]"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeHex",
          "args": [
            "m_data[\"Qy\"]"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeHex",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "1181-1186",
          "snippet": "static SecByteBlock DecodeHex(const std::string &data)\n\t{\n\t\tSecByteBlock data2(data.size() / 2);\n\t\tStringSource(data, true, new HexDecoder(new ArraySink(data2, data2.size())));\n\t\treturn data2;\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  static SecByteBlock DecodeHex(const std::string &data)\n  \t{\n  \t\tSecByteBlock data2(data.size() / 2);\n  \t\tStringSource(data, true, new HexDecoder(new ArraySink(data2, data2.size())));\n  \t\treturn data2;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_PKV<ECP>",
          "args": [
            "m_rng",
            "DecodeHex(m_data[\"Qx\"])",
            "DecodeHex(m_data[\"Qy\"])",
            "name2oid[m_bracketString]"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect571r1",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect409r1",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect283r1",
          "args": [],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect233r1",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect163r2",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect571k1",
          "args": [],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect409k1",
          "args": [],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect283k1",
          "args": [],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect233k1",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::sect163k1",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::secp521r1",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::secp384r1",
          "args": [],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::secp256r1",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::secp224r1",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASN1::secp192r1",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "h",
            "(p-1)/q",
            "p"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA::GeneratePrimes",
          "args": [
            "seed",
            "seed.size()*8",
            "c",
            "p1",
            "1024",
            "q1",
            "true"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Seed\"]",
            "true",
            "new HexDecoder(new ArraySink(seed, seed.size()))"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_data[\"c\"].c_str()"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data[\"c\"].c_str",
          "args": [],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Msg\"]",
            "true",
            "new Redirector(filter, Redirector::DATA_ONLY)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"S\"]",
            "true",
            "new Redirector(filter, Redirector::DATA_ONLY)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"R\"]",
            "true",
            "new Redirector(filter, Redirector::DATA_ONLY)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Msg\"]",
            "true",
            "new HexDecoder(new SignerFilter(m_rng, signer, new ArraySink(sig, sig.size())))"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer.SignatureLength",
          "args": [],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetKey",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetKey",
          "args": [],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encodedKey.clear",
          "args": [],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetGroupParameters",
          "args": [],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_bracketString.substr(6).c_str()"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_bracketString.substr",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_bracketString.substr",
          "args": [
            "6"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"H \"",
            "h",
            "p.ByteCount()"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p.ByteCount",
          "args": [],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_exp_b_mod_c",
          "args": [
            "h",
            "(p-1)/q",
            "p"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h.Randomize",
          "args": [
            "m_rng",
            "2",
            "p-2"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DSA::GeneratePrimes",
          "args": [
            "seed",
            "seed.size()*8",
            "counter",
            "p",
            "1024",
            "q"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_data[\"N\"].c_str()"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data[\"N\"].c_str",
          "args": [],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "(byte *)output.data()",
            "output.size()"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetKey",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetKey",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetKey",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.GetKey",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.AccessKey",
          "args": [
            "m_rng",
            "pqg"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.AccessKey",
          "args": [],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_data[\"N\"].c_str()"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data[\"N\"].c_str",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pqg.GetSubgroupGenerator",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pqg.GetSubgroupOrder",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pqg.GetModulus",
          "args": [],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pqg.GenerateRandomWithKeySize",
          "args": [
            "m_rng",
            "modLen"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "m_bracketString.substr(6).c_str()"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_bracketString.substr",
          "args": [],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_bracketString.substr",
          "args": [
            "6"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  virtual void DoTest()\n  \t{\n  \t\tstd::string output;\n  \n  \t\tif (m_algorithm == \"DSA\")\n  \t\t{\n  \t\t\tif (m_test == \"KeyPair\")\n  \t\t\t{\n  \t\t\t\tDL_GroupParameters_DSA pqg;\n  \t\t\t\tint modLen = atol(m_bracketString.substr(6).c_str());\n  \t\t\t\tpqg.GenerateRandomWithKeySize(m_rng, modLen);\n  \n  \t\t\t\tOutputData(output, \"P \", pqg.GetModulus());\n  \t\t\t\tOutputData(output, \"Q \", pqg.GetSubgroupOrder());\n  \t\t\t\tOutputData(output, \"G \", pqg.GetSubgroupGenerator());\n  \n  \t\t\t\tint n = atol(m_data[\"N\"].c_str());\n  \t\t\t\tfor (int i=0; i<n; i++)\n  \t\t\t\t{\n  \t\t\t\t\tDSA::Signer priv;\n  \t\t\t\t\tpriv.AccessKey().GenerateRandom(m_rng, pqg);\n  \t\t\t\t\tDSA::Verifier pub(priv);\n  \n  \t\t\t\t\tOutputData(output, \"X \", priv.GetKey().GetPrivateExponent());\n  \t\t\t\t\tOutputData(output, \"Y \", pub.GetKey().GetPublicElement());\n  \t\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\t\toutput.resize(0);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse if (m_test == \"PQGGen\")\n  \t\t\t{\n  \t\t\t\tint n = atol(m_data[\"N\"].c_str());\n  \t\t\t\tfor (int i=0; i<n; i++)\n  \t\t\t\t{\n  \t\t\t\t\tInteger p, q, h, g;\n  \t\t\t\t\tint counter;\n  \t\t\t\t\t\n  \t\t\t\t\tSecByteBlock seed(SHA::DIGESTSIZE);\n  \t\t\t\t\tdo\n  \t\t\t\t\t{\n  \t\t\t\t\t\tm_rng.GenerateBlock(seed, seed.size());\n  \t\t\t\t\t}\n  \t\t\t\t\twhile (!DSA::GeneratePrimes(seed, seed.size()*8, counter, p, 1024, q));\n  \t\t\t\t\th.Randomize(m_rng, 2, p-2);\n  \t\t\t\t\tg = a_exp_b_mod_c(h, (p-1)/q, p);\n  \n  \t\t\t\t\tOutputData(output, \"P \", p);\n  \t\t\t\t\tOutputData(output, \"Q \", q);\n  \t\t\t\t\tOutputData(output, \"G \", g);\n  \t\t\t\t\tOutputData(output, \"Seed \", seed);\n  \t\t\t\t\tOutputData(output, \"c \", counter);\n  \t\t\t\t\tOutputData(output, \"H \", h, p.ByteCount());\n  \t\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\t\toutput.resize(0);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse if (m_test == \"SigGen\")\n  \t\t\t{\n  \t\t\t\tstd::string &encodedKey = m_data[\"PrivKey\"];\n  \t\t\t\tint modLen = atol(m_bracketString.substr(6).c_str());\n  \t\t\t\tDSA::PrivateKey priv;\n  \n  \t\t\t\tif (!encodedKey.empty())\n  \t\t\t\t{\n  \t\t\t\t\tStringStore s(encodedKey);\n  \t\t\t\t\tpriv.BERDecode(s);\n  \t\t\t\t\tif (priv.GetGroupParameters().GetModulus().BitCount() != modLen)\n  \t\t\t\t\t\tencodedKey.clear();\n  \t\t\t\t}\n  \n  \t\t\t\tif (encodedKey.empty())\n  \t\t\t\t{\n  \t\t\t\t\tpriv.Initialize(m_rng, modLen);\n  \t\t\t\t\tStringSink s(encodedKey);\n  \t\t\t\t\tpriv.DEREncode(s);\n  \t\t\t\t\tOutputData(output, \"P \", priv.GetGroupParameters().GetModulus());\n  \t\t\t\t\tOutputData(output, \"Q \", priv.GetGroupParameters().GetSubgroupOrder());\n  \t\t\t\t\tOutputData(output, \"G \", priv.GetGroupParameters().GetSubgroupGenerator());\n  \t\t\t\t}\n  \n  \t\t\t\tDSA::Signer signer(priv);\n  \t\t\t\tDSA::Verifier pub(signer);\n  \t\t\t\tOutputData(output, \"Msg \", m_data[\"Msg\"]);\n  \t\t\t\tOutputData(output, \"Y \", pub.GetKey().GetPublicElement());\n  \n  \t\t\t\tSecByteBlock sig(signer.SignatureLength());\n  \t\t\t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new SignerFilter(m_rng, signer, new ArraySink(sig, sig.size()))));\n  \t\t\t\tSecByteBlock R(sig, sig.size()/2), S(sig+sig.size()/2, sig.size()/2);\n  \t\t\t\tOutputData(output, \"R \", R);\n  \t\t\t\tOutputData(output, \"S \", S);\n  \t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\toutput.resize(0);\n  \t\t\t}\n  \t\t\telse if (m_test == \"SigVer\")\n  \t\t\t{\n  \t\t\t\tInteger p((m_data[\"P\"] + \"h\").c_str());\n  \t\t\t\tInteger\tq((m_data[\"Q\"] + \"h\").c_str());\n  \t\t\t\tInteger g((m_data[\"G\"] + \"h\").c_str());\n  \t\t\t\tInteger y((m_data[\"Y\"] + \"h\").c_str());\n  \t\t\t\tDSA::Verifier verifier(p, q, g, y);\n  \n  \t\t\t\tHexDecoder filter(new SignatureVerificationFilter(verifier));\n  \t\t\t\tStringSource(m_data[\"R\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n  \t\t\t\tStringSource(m_data[\"S\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n  \t\t\t\tStringSource(m_data[\"Msg\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n  \t\t\t\tfilter.MessageEnd();\n  \t\t\t\tbyte b;\n  \t\t\t\tfilter.Get(b);\n  \t\t\t\tOutputData(output, \"Result \", b ? \"P\" : \"F\");\n  \t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\toutput.resize(0);\n  \t\t\t}\n  \t\t\telse if (m_test == \"PQGVer\")\n  \t\t\t{\n  \t\t\t\tInteger p((m_data[\"P\"] + \"h\").c_str());\n  \t\t\t\tInteger\tq((m_data[\"Q\"] + \"h\").c_str());\n  \t\t\t\tInteger g((m_data[\"G\"] + \"h\").c_str());\n  \t\t\t\tInteger h((m_data[\"H\"] + \"h\").c_str());\n  \t\t\t\tint c = atol(m_data[\"c\"].c_str());\n  \t\t\t\tSecByteBlock seed(m_data[\"Seed\"].size()/2);\n  \t\t\t\tStringSource(m_data[\"Seed\"], true, new HexDecoder(new ArraySink(seed, seed.size())));\n  \n  \t\t\t\tInteger p1, q1;\n  \t\t\t\tbool result = DSA::GeneratePrimes(seed, seed.size()*8, c, p1, 1024, q1, true);\n  \t\t\t\tresult = result && (p1 == p && q1 == q);\n  \t\t\t\tresult = result && g == a_exp_b_mod_c(h, (p-1)/q, p);\n  \n  \t\t\t\tOutputData(output, \"Result \", result ? \"P\" : \"F\");\n  \t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\toutput.resize(0);\n  \t\t\t}\n  \n  \t\t\treturn;\n  \t\t}\n  \n  \t\tif (m_algorithm == \"ECDSA\")\n  \t\t{\n  \t\t\tstd::map<std::string, OID> name2oid;\n  \t\t\tname2oid[\"P-192\"] = ASN1::secp192r1();\n  \t\t\tname2oid[\"P-224\"] = ASN1::secp224r1();\n  \t\t\tname2oid[\"P-256\"] = ASN1::secp256r1();\n  \t\t\tname2oid[\"P-384\"] = ASN1::secp384r1();\n  \t\t\tname2oid[\"P-521\"] = ASN1::secp521r1();\n  \t\t\tname2oid[\"K-163\"] = ASN1::sect163k1();\n  \t\t\tname2oid[\"K-233\"] = ASN1::sect233k1();\n  \t\t\tname2oid[\"K-283\"] = ASN1::sect283k1();\n  \t\t\tname2oid[\"K-409\"] = ASN1::sect409k1();\n  \t\t\tname2oid[\"K-571\"] = ASN1::sect571k1();\n  \t\t\tname2oid[\"B-163\"] = ASN1::sect163r2();\n  \t\t\tname2oid[\"B-233\"] = ASN1::sect233r1();\n  \t\t\tname2oid[\"B-283\"] = ASN1::sect283r1();\n  \t\t\tname2oid[\"B-409\"] = ASN1::sect409r1();\n  \t\t\tname2oid[\"B-571\"] = ASN1::sect571r1();\n  \n  \t\t\tif (m_test == \"PKV\")\n  \t\t\t{\n  \t\t\t\tbool pass;\n  \t\t\t\tif (m_bracketString[0] == 'P')\n  \t\t\t\t\tpass = EC_PKV<ECP>(m_rng, DecodeHex(m_data[\"Qx\"]), DecodeHex(m_data[\"Qy\"]), name2oid[m_bracketString]);\n  \t\t\t\telse\n  \t\t\t\t\tpass = EC_PKV<EC2N>(m_rng, DecodeHex(m_data[\"Qx\"]), DecodeHex(m_data[\"Qy\"]), name2oid[m_bracketString]);\n  \n  \t\t\t\tOutputData(output, \"Result \", pass ? \"P\" : \"F\");\n  \t\t\t}\n  \t\t\telse if (m_test == \"KeyPair\")\n  \t\t\t{\n  \t\t\t\tif (m_bracketString[0] == 'P')\n  \t\t\t\t\tEC_KeyPair<ECP>(output, atol(m_data[\"N\"].c_str()), name2oid[m_bracketString]);\n  \t\t\t\telse\n  \t\t\t\t\tEC_KeyPair<EC2N>(output, atol(m_data[\"N\"].c_str()), name2oid[m_bracketString]);\n  \t\t\t}\n  \t\t\telse if (m_test == \"SigGen\")\n  \t\t\t{\n  \t\t\t\tif (m_bracketString[0] == 'P')\n  \t\t\t\t\tEC_SigGen<ECP>(output, name2oid[m_bracketString]);\n  \t\t\t\telse\n  \t\t\t\t\tEC_SigGen<EC2N>(output, name2oid[m_bracketString]);\n  \t\t\t}\n  \t\t\telse if (m_test == \"SigVer\")\n  \t\t\t{\n  \t\t\t\tif (m_bracketString[0] == 'P')\n  \t\t\t\t\tEC_SigVer<ECP>(output, name2oid[m_bracketString]);\n  \t\t\t\telse\n  \t\t\t\t\tEC_SigVer<EC2N>(output, name2oid[m_bracketString]);\n  \t\t\t}\n  \n  \t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\toutput.resize(0);\n  \t\t\treturn;\n  \t\t}\n  \n  \t\tif (m_algorithm == \"RSA\")\n  \t\t{\n  \t\t\tstd::string shaAlg = m_data[\"SHAAlg\"].substr(3);\n  \n  \t\t\tif (m_test == \"Ver\")\n  \t\t\t{\n  \t\t\t\tInteger n((m_data[\"n\"] + \"h\").c_str());\n  \t\t\t\tInteger e((m_data[\"e\"] + \"h\").c_str());\n  \t\t\t\tRSA::PublicKey pub;\n  \t\t\t\tpub.Initialize(n, e);\n  \n  \t\t\t\tmember_ptr<PK_Verifier> pV(CreateRSA<PK_Verifier>(m_mode, shaAlg));\n  \t\t\t\tpV->AccessMaterial().AssignFrom(pub);\n  \n  \t\t\t\tHexDecoder filter(new SignatureVerificationFilter(*pV));\n  \t\t\t\tfor (unsigned int i=m_data[\"S\"].size(); i<pV->SignatureLength()*2; i++)\n  \t\t\t\t\tfilter.Put('0');\n  \t\t\t\tStringSource(m_data[\"S\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n  \t\t\t\tStringSource(m_data[\"Msg\"], true, new Redirector(filter, Redirector::DATA_ONLY));\n  \t\t\t\tfilter.MessageEnd();\n  \t\t\t\tbyte b;\n  \t\t\t\tfilter.Get(b);\n  \t\t\t\tOutputData(output, \"Result \", b ? \"P\" : \"F\");\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tassert(m_test == \"Gen\");\n  \t\t\t\tint modLen = atol(m_bracketString.substr(6).c_str());\n  \t\t\t\tstd::string &encodedKey = m_data[\"PrivKey\"];\n  \t\t\t\tRSA::PrivateKey priv;\n  \n  \t\t\t\tif (!encodedKey.empty())\n  \t\t\t\t{\n  \t\t\t\t\tStringStore s(encodedKey);\n  \t\t\t\t\tpriv.BERDecode(s);\n  \t\t\t\t\tif (priv.GetModulus().BitCount() != modLen)\n  \t\t\t\t\t\tencodedKey.clear();\n  \t\t\t\t}\n  \n  \t\t\t\tif (encodedKey.empty())\n  \t\t\t\t{\n  \t\t\t\t\tpriv.Initialize(m_rng, modLen);\n  \t\t\t\t\tStringSink s(encodedKey);\n  \t\t\t\t\tpriv.DEREncode(s);\n  \t\t\t\t\tOutputData(output, \"n \", priv.GetModulus());\n  \t\t\t\t\tOutputData(output, \"e \", priv.GetPublicExponent(), modLen/8);\n  \t\t\t\t}\n  \n  \t\t\t\tmember_ptr<PK_Signer> pS(CreateRSA<PK_Signer>(m_mode, shaAlg));\n  \t\t\t\tpS->AccessMaterial().AssignFrom(priv);\n  \n  \t\t\t\tSecByteBlock sig(pS->SignatureLength());\n  \t\t\t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new SignerFilter(m_rng, *pS, new ArraySink(sig, sig.size()))));\n  \t\t\t\tOutputData(output, \"SHAAlg \", m_data[\"SHAAlg\"]);\n  \t\t\t\tOutputData(output, \"Msg \", m_data[\"Msg\"]);\n  \t\t\t\tOutputData(output, \"S \", sig);\n  \t\t\t}\n  \n  \t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\toutput.resize(0);\n  \t\t\treturn;\n  \t\t}\n  \n  \t\tif (m_algorithm == \"SHA\")\n  \t\t{\n  \t\t\tmember_ptr<HashFunction> pHF;\n  \n  \t\t\tif (m_mode == \"1\")\n  \t\t\t\tpHF.reset(new SHA1);\n  \t\t\telse if (m_mode == \"224\")\n  \t\t\t\tpHF.reset(new SHA224);\n  \t\t\telse if (m_mode == \"256\")\n  \t\t\t\tpHF.reset(new SHA256);\n  \t\t\telse if (m_mode == \"384\")\n  \t\t\t\tpHF.reset(new SHA384);\n  \t\t\telse if (m_mode == \"512\")\n  \t\t\t\tpHF.reset(new SHA512);\n  \n  \t\t\tif (m_test == \"MONTE\")\n  \t\t\t{\n  \t\t\t\tSecByteBlock seed = m_data2[INPUT];\n  \t\t\t\tSecByteBlock MD[1003];\n  \t\t\t\tint i,j;\n  \n  \t\t\t\tfor (j=0; j<100; j++)\n  \t\t\t\t{\n  \t\t\t\t\tMD[0] = MD[1] = MD[2] = seed;\n  \t\t\t\t\tfor (i=3; i<1003; i++)\n  \t\t\t\t\t{\n  \t\t\t\t\t\tSecByteBlock Mi = MD[i-3] + MD[i-2] + MD[i-1];\n  \t\t\t\t\t\tMD[i].resize(pHF->DigestSize());\n  \t\t\t\t\t\tpHF->CalculateDigest(MD[i], Mi, Mi.size());\n  \t\t\t\t\t}\n  \t\t\t\t\tseed = MD[1002];\n  \t\t\t\t\tOutputData(output, \"COUNT \", j);\n  \t\t\t\t\tOutputData(output, \"MD \", seed);\n  \t\t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\t\toutput.resize(0);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tSecByteBlock tag(pHF->DigestSize());\n  \t\t\t\tSecByteBlock &msg(m_data2[INPUT]);\n  \t\t\t\tint len = atol(m_data[\"Len\"].c_str());\n  \t\t\t\tStringSource(msg.begin(), len/8, true, new HashFilter(*pHF, new ArraySink(tag, tag.size())));\n  \t\t\t\tOutputData(output, \"MD \", tag);\n  \t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\toutput.resize(0);\n  \t\t\t}\n  \t\t\treturn;\n  \t\t}\n  \n  \t\tSecByteBlock &key = m_data2[KEY_T];\n  \n  \t\tif (m_algorithm == \"TDES\")\n  \t\t{\n  \t\t\tif (!m_data[\"KEY1\"].empty())\n  \t\t\t{\n  \t\t\t\tconst std::string keys[3] = {m_data[\"KEY1\"], m_data[\"KEY2\"], m_data[\"KEY3\"]};\n  \t\t\t\tkey.resize(24);\n  \t\t\t\tHexDecoder hexDec(new ArraySink(key, key.size()));\n  \t\t\t\tfor (int i=0; i<3; i++)\n  \t\t\t\t\thexDec.Put((byte *)keys[i].data(), keys[i].size());\n  \n  \t\t\t\tif (keys[0] == keys[2])\n  \t\t\t\t{\n  \t\t\t\t\tif (keys[0] == keys[1])\n  \t\t\t\t\t\tkey.resize(8);\n  \t\t\t\t\telse\n  \t\t\t\t\t\tkey.resize(16);\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t\tkey.resize(24);\n  \t\t\t}\n  \t\t}\n  \n  \t\tif (m_algorithm == \"RNG\")\n  \t\t{\n  \t\t\tkey.resize(24);\n  \t\t\tStringSource(m_data[\"Key1\"] + m_data[\"Key2\"] + m_data[\"Key3\"], true, new HexDecoder(new ArraySink(key, key.size())));\n  \n  \t\t\tSecByteBlock seed(m_data2[INPUT]), dt(m_data2[IV]), r(8);\n  \t\t\tX917RNG rng(new DES_EDE3::Encryption(key, key.size()), seed, dt);\n  \n  \t\t\tif (m_test == \"MCT\")\n  \t\t\t{\n  \t\t\t\tfor (int i=0; i<10000; i++)\n  \t\t\t\t\trng.GenerateBlock(r, r.size());\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\trng.GenerateBlock(r, r.size());\n  \t\t\t}\n  \n  \t\t\tOutputData(output, \"R \", r);\n  \t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\toutput.resize(0);\n  \t\t\treturn;\n  \t\t}\n  \n  \t\tif (m_algorithm == \"HMAC\")\n  \t\t{\n  \t\t\tmember_ptr<MessageAuthenticationCode> pMAC;\n  \n  \t\t\tif (m_bracketString == \"L=20\")\n  \t\t\t\tpMAC.reset(new HMAC<SHA1>);\n  \t\t\telse if (m_bracketString == \"L=28\")\n  \t\t\t\tpMAC.reset(new HMAC<SHA224>);\n  \t\t\telse if (m_bracketString == \"L=32\")\n  \t\t\t\tpMAC.reset(new HMAC<SHA256>);\n  \t\t\telse if (m_bracketString == \"L=48\")\n  \t\t\t\tpMAC.reset(new HMAC<SHA384>);\n  \t\t\telse if (m_bracketString == \"L=64\")\n  \t\t\t\tpMAC.reset(new HMAC<SHA512>);\n  \t\t\telse\n  \t\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected HMAC bracket string: \" + m_bracketString);\n  \n  \t\t\tpMAC->SetKey(key, key.size());\n  \t\t\tint Tlen = atol(m_data[\"Tlen\"].c_str());\n  \t\t\tSecByteBlock tag(Tlen);\n  \t\t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new HashFilter(*pMAC, new ArraySink(tag, Tlen), false, Tlen)));\n  \t\t\tOutputData(output, \"Mac \", tag);\n  \t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\toutput.resize(0);\n  \t\t\treturn;\n  \t\t}\n  \n  \t\tmember_ptr<BlockCipher> pBT;\n  \t\tif (m_algorithm == \"DES\")\n  \t\t\tpBT.reset(NewBT((DES*)0));\n  \t\telse if (m_algorithm == \"TDES\")\n  \t\t{\n  \t\t\tif (key.size() == 8)\n  \t\t\t\tpBT.reset(NewBT((DES*)0));\n  \t\t\telse if (key.size() == 16)\n  \t\t\t\tpBT.reset(NewBT((DES_EDE2*)0));\n  \t\t\telse\n  \t\t\t\tpBT.reset(NewBT((DES_EDE3*)0));\n  \t\t}\n  \t\telse if (m_algorithm == \"SKIPJACK\")\n  \t\t\tpBT.reset(NewBT((SKIPJACK*)0));\n  \t\telse if (m_algorithm == \"AES\")\n  \t\t\tpBT.reset(NewBT((AES*)0));\n  \t\telse\n  \t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected algorithm: \" + m_algorithm);\n  \n  \t\tif (!pBT->IsValidKeyLength(key.size()))\n  \t\t\tkey.CleanNew(pBT->DefaultKeyLength());\t// for Scbcvrct\n  \t\tpBT->SetKey(key.data(), key.size());\n  \n  \t\tSecByteBlock &iv = m_data2[IV];\n  \t\tif (iv.empty())\n  \t\t\tiv.CleanNew(pBT->BlockSize());\n  \n  \t\tmember_ptr<SymmetricCipher> pCipher;\n  \t\tunsigned int K = m_feedbackSize;\n  \n  \t\tif (m_mode == \"ECB\")\n  \t\t\tpCipher.reset(NewMode((ECB_Mode_ExternalCipher*)0, *pBT, iv));\n  \t\telse if (m_mode == \"CBC\")\n  \t\t\tpCipher.reset(NewMode((CBC_Mode_ExternalCipher*)0, *pBT, iv));\n  \t\telse if (m_mode == \"CFB\")\n  \t\t\tpCipher.reset(NewMode((CFB_Mode_ExternalCipher*)0, *pBT, iv));\n  \t\telse if (m_mode == \"OFB\")\n  \t\t\tpCipher.reset(NewMode((OFB_Mode_ExternalCipher*)0, *pBT, iv));\n  \t\telse\n  \t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected mode: \" + m_mode);\n  \n  \t\tbool encrypt = m_encrypt;\n  \n  \t\tif (m_test == \"MONTE\")\n  \t\t{\n  \t\t\tSecByteBlock KEY[401];\n  \t\t\tKEY[0] = key;\n  \t\t\tint keySize = key.size();\n  \t\t\tint blockSize = pBT->BlockSize();\n  \n  \t\t\tstd::vector<SecByteBlock> IB(10001), OB(10001), PT(10001), CT(10001), RESULT(10001), TXT(10001), CV(10001);\n  \t\t\tPT[0] = GetData(\"PLAINTEXT\");\n  \t\t\tCT[0] = GetData(\"CIPHERTEXT\");\n  \t\t\tCV[0] = IB[0] = iv;\n  \t\t\tTXT[0] = GetData(\"TEXT\");\n  \n  \t\t\tint outerCount = (m_algorithm == \"AES\") ? 100 : 400;\n  \t\t\tint innerCount = (m_algorithm == \"AES\") ? 1000 : 10000;\n  \n  \t\t\tfor (int i=0; i<outerCount; i++)\n  \t\t\t{\n  \t\t\t\tpBT->SetKey(KEY[i], keySize);\n  \n  \t\t\t\tfor (int j=0; j<innerCount; j++)\n  \t\t\t\t{\n  \t\t\t\t\tif (m_mode == \"ECB\")\n  \t\t\t\t\t{\n  \t\t\t\t\t\tif (encrypt)\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tIB[j] = PT[j];\n  \t\t\t\t\t\t\tCT[j].resize(blockSize);\n  \t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], CT[j]);\n  \t\t\t\t\t\t\tPT[j+1] = CT[j];\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\telse\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tIB[j] = CT[j];\n  \t\t\t\t\t\t\tPT[j].resize(blockSize);\n  \t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], PT[j]);\n  \t\t\t\t\t\t\tCT[j+1] = PT[j];\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t\telse if (m_mode == \"OFB\")\n  \t\t\t\t\t{\n  \t\t\t\t\t\tOB[j].resize(blockSize);\n  \t\t\t\t\t\tpBT->ProcessBlock(IB[j], OB[j]);\n  \t\t\t\t\t\tXor(RESULT[j], OB[j], TXT[j]);\n  \t\t\t\t\t\tTXT[j+1] = IB[j];\n  \t\t\t\t\t\tIB[j+1] = OB[j];\n  \t\t\t\t\t}\n  \t\t\t\t\telse if (m_mode == \"CBC\")\n  \t\t\t\t\t{\n  \t\t\t\t\t\tif (encrypt)\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tXor(IB[j], PT[j], CV[j]);\n  \t\t\t\t\t\t\tCT[j].resize(blockSize);\n  \t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], CT[j]);\n  \t\t\t\t\t\t\tPT[j+1] = CV[j];\n  \t\t\t\t\t\t\tCV[j+1] = CT[j];\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\telse\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tIB[j] = CT[j];\n  \t\t\t\t\t\t\tOB[j].resize(blockSize);\n  \t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], OB[j]);\n  \t\t\t\t\t\t\tXor(PT[j], OB[j], CV[j]);\n  \t\t\t\t\t\t\tCV[j+1] = CT[j];\n  \t\t\t\t\t\t\tCT[j+1] = PT[j];\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t\telse if (m_mode == \"CFB\")\n  \t\t\t\t\t{\n  \t\t\t\t\t\tif (encrypt)\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tOB[j].resize(blockSize);\n  \t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], OB[j]);\n  \t\t\t\t\t\t\tAssignLeftMostBits(CT[j], OB[j], K);\n  \t\t\t\t\t\t\tXor(CT[j], CT[j], PT[j]);\n  \t\t\t\t\t\t\tAssignLeftMostBits(PT[j+1], IB[j], K);\n  \t\t\t\t\t\t\tIB[j+1].resize(blockSize);\n  \t\t\t\t\t\t\tmemcpy(IB[j+1], IB[j]+K/8, blockSize-K/8);\n  \t\t\t\t\t\t\tmemcpy(IB[j+1]+blockSize-K/8, CT[j], K/8);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t\telse\n  \t\t\t\t\t\t{\n  \t\t\t\t\t\t\tOB[j].resize(blockSize);\n  \t\t\t\t\t\t\tpBT->ProcessBlock(IB[j], OB[j]);\n  \t\t\t\t\t\t\tAssignLeftMostBits(PT[j], OB[j], K);\n  \t\t\t\t\t\t\tXor(PT[j], PT[j], CT[j]);\n  \t\t\t\t\t\t\tIB[j+1].resize(blockSize);\n  \t\t\t\t\t\t\tmemcpy(IB[j+1], IB[j]+K/8, blockSize-K/8);\n  \t\t\t\t\t\t\tmemcpy(IB[j+1]+blockSize-K/8, CT[j], K/8);\n  \t\t\t\t\t\t\tAssignLeftMostBits(CT[j+1], OB[j], K);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: unexpected mode: \" + m_mode);\n  \t\t\t\t}\n  \n  \t\t\t\tOutputData(output, COUNT, IntToString(i));\n  \t\t\t\tOutputData(output, KEY_T, KEY[i]);\n  \t\t\t\tif (m_mode == \"CBC\")\n  \t\t\t\t\tOutputData(output, IV, CV[0]);\n  \t\t\t\tif (m_mode == \"OFB\" || m_mode == \"CFB\")\n  \t\t\t\t\tOutputData(output, IV, IB[0]);\n  \t\t\t\tif (m_mode == \"ECB\" || m_mode == \"CBC\" || m_mode == \"CFB\")\n  \t\t\t\t{\n  \t\t\t\t\tif (encrypt)\n  \t\t\t\t\t{\n  \t\t\t\t\t\tOutputData(output, INPUT, PT[0]);\n  \t\t\t\t\t\tOutputData(output, OUTPUT, CT[innerCount-1]);\n  \t\t\t\t\t\tKEY[i+1] = UpdateKey(KEY[i], &CT[0]);\n  \t\t\t\t\t}\n  \t\t\t\t\telse\n  \t\t\t\t\t{\n  \t\t\t\t\t\tOutputData(output, INPUT, CT[0]);\n  \t\t\t\t\t\tOutputData(output, OUTPUT, PT[innerCount-1]);\n  \t\t\t\t\t\tKEY[i+1] = UpdateKey(KEY[i], &PT[0]);\n  \t\t\t\t\t}\n  \t\t\t\t\tPT[0] = PT[innerCount];\n  \t\t\t\t\tIB[0] = IB[innerCount];\n  \t\t\t\t\tCV[0] = CV[innerCount];\n  \t\t\t\t\tCT[0] = CT[innerCount];\n  \t\t\t\t}\n  \t\t\t\telse if (m_mode == \"OFB\")\n  \t\t\t\t{\n  \t\t\t\t\tOutputData(output, INPUT, TXT[0]);\n  \t\t\t\t\tOutputData(output, OUTPUT, RESULT[innerCount-1]);\n  \t\t\t\t\tKEY[i+1] = UpdateKey(KEY[i], &RESULT[0]);\n  \t\t\t\t\tXor(TXT[0], TXT[0], IB[innerCount-1]);\n  \t\t\t\t\tIB[0] = OB[innerCount-1];\n  \t\t\t\t}\n  \t\t\t\toutput += \"\\n\";\n  \t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\toutput.resize(0);\n  \t\t\t}\n  \t\t}\n  \t\telse if (m_test == \"MCT\")\n  \t\t{\n  \t\t\tSecByteBlock KEY[101];\n  \t\t\tKEY[0] = key;\n  \t\t\tint keySize = key.size();\n  \t\t\tint blockSize = pBT->BlockSize();\n  \n  \t\t\tSecByteBlock ivs[101], inputs[1001], outputs[1001];\n  \t\t\tivs[0] = iv;\n  \t\t\tinputs[0] = m_data2[INPUT];\n  \n  \t\t\tfor (int i=0; i<100; i++)\n  \t\t\t{\n  \t\t\t\tpCipher->SetKey(KEY[i], keySize, MakeParameters(Name::IV(), (const byte *)ivs[i])(Name::FeedbackSize(), (int)K/8, false));\n  \n  \t\t\t\tfor (int j=0; j<1000; j++)\n  \t\t\t\t{\n  \t\t\t\t\toutputs[j] = inputs[j];\n  \t\t\t\t\tpCipher->ProcessString(outputs[j], outputs[j].size());\n  \t\t\t\t\tif (K==8 && m_mode == \"CFB\")\n  \t\t\t\t\t{\n  \t\t\t\t\t\tif (j<16)\n  \t\t\t\t\t\t\tinputs[j+1].Assign(ivs[i]+j, 1);\n  \t\t\t\t\t\telse\n  \t\t\t\t\t\t\tinputs[j+1] = outputs[j-16];\n  \t\t\t\t\t}\n  \t\t\t\t\telse if (m_mode == \"ECB\")\n  \t\t\t\t\t\tinputs[j+1] = outputs[j];\n  \t\t\t\t\telse if (j == 0)\n  \t\t\t\t\t\tinputs[j+1] = ivs[i];\n  \t\t\t\t\telse\n  \t\t\t\t\t\tinputs[j+1] = outputs[j-1];\n  \t\t\t\t}\n  \n  \t\t\t\tif (m_algorithm == \"AES\")\n  \t\t\t\t\tOutputData(output, COUNT, m_count++);\n  \t\t\t\tOutputData(output, KEY_T, KEY[i]);\n  \t\t\t\tif (m_mode != \"ECB\")\n  \t\t\t\t\tOutputData(output, IV, ivs[i]);\n  \t\t\t\tOutputData(output, INPUT, inputs[0]);\n  \t\t\t\tOutputData(output, OUTPUT, outputs[999]);\n  \t\t\t\toutput += \"\\n\";\n  \t\t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t\t\toutput.resize(0);\n  \n  \t\t\t\tKEY[i+1] = UpdateKey(KEY[i], outputs);\n  \t\t\t\tivs[i+1].CleanNew(pCipher->IVSize());\n  \t\t\t\tivs[i+1] = UpdateKey(ivs[i+1], outputs);\n  \t\t\t\tif (K==8 && m_mode == \"CFB\")\n  \t\t\t\t\tinputs[0] = outputs[999-16];\n  \t\t\t\telse if (m_mode == \"ECB\")\n  \t\t\t\t\tinputs[0] = outputs[999];\n  \t\t\t\telse\n  \t\t\t\t\tinputs[0] = outputs[998];\n  \t\t\t}\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tassert(m_test == \"KAT\");\n  \n  \t\t\tSecByteBlock &input = m_data2[INPUT];\n  \t\t\tSecByteBlock result(input.size());\n  \t\t\tmember_ptr<Filter> pFilter(new StreamTransformationFilter(*pCipher, new ArraySink(result, result.size()), StreamTransformationFilter::NO_PADDING));\n  \t\t\tStringSource(input.data(), input.size(), true, pFilter.release());\n  \n  \t\t\tOutputGivenData(output, COUNT, true);\n  \t\t\tOutputData(output, KEY_T, key);\n  \t\t\tOutputGivenData(output, IV, true);\n  \t\t\tOutputGivenData(output, INPUT);\n  \t\t\tOutputData(output, OUTPUT, result);\n  \t\t\toutput += \"\\n\";\n  \t\t\tAttachedTransformation()->Put((byte *)output.data(), output.size());\n  \t\t}\n  \t}\n}"
  },
  {
    "function_name": "EC_PKV",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "365-375",
    "snippet": "static bool EC_PKV(RandomNumberGenerator &rng, const SecByteBlock &x, const SecByteBlock &y, const OID &oid)\n\t{\n\t\ttypename EC::FieldElement Qx(x, x.size());\n\t\ttypename EC::FieldElement Qy(y, y.size());\n\t\ttypename EC::Element Q(Qx, Qy);\n\n\t\tDL_GroupParameters_EC<EC> params(oid);\n\t\ttypename ECDSA<EC, SHA1>::PublicKey pub;\n\t\tpub.Initialize(params, Q);\n\t\treturn pub.Validate(rng, 3);\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pub.Validate",
          "args": [
            "rng",
            "3"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "Validate",
          "container": "DL_PublicKeyImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "845-850",
          "snippet": "bool Validate(RandomNumberGenerator &rng, unsigned int level) const\n\t{\n\t\tbool pass = GetAbstractGroupParameters().Validate(rng, level);\n\t\tpass = pass && GetAbstractGroupParameters().ValidateElement(level, this->GetPublicElement(), &GetPublicPrecomputation());\n\t\treturn pass;\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nDL_PublicKeyImpl {\n  bool Validate(RandomNumberGenerator &rng, unsigned int level) const\n  \t{\n  \t\tbool pass = GetAbstractGroupParameters().Validate(rng, level);\n  \t\tpass = pass && GetAbstractGroupParameters().ValidateElement(level, this->GetPublicElement(), &GetPublicPrecomputation());\n  \t\treturn pass;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pub.Initialize",
          "args": [
            "params",
            "Q"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "Initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.h",
          "lines": "54-55",
          "snippet": "void Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}",
          "includes": [
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n\nvoid Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}"
        }
      },
      {
        "call_info": {
          "callee": "y.size",
          "args": [],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ByteArrayParameter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "63-63",
          "snippet": "size_t size() const {return m_size;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nByteArrayParameter {\n  size_t size() const {return m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x.size",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  static bool EC_PKV(RandomNumberGenerator &rng, const SecByteBlock &x, const SecByteBlock &y, const OID &oid)\n  \t{\n  \t\ttypename EC::FieldElement Qx(x, x.size());\n  \t\ttypename EC::FieldElement Qy(y, y.size());\n  \t\ttypename EC::Element Q(Qx, Qy);\n  \n  \t\tDL_GroupParameters_EC<EC> params(oid);\n  \t\ttypename ECDSA<EC, SHA1>::PublicKey pub;\n  \t\tpub.Initialize(params, Q);\n  \t\treturn pub.Validate(rng, 3);\n  \t}\n}"
  },
  {
    "function_name": "EC_SigVer",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "335-362",
    "snippet": "void EC_SigVer(string &output, const OID &oid)\n\t{\n\t\tSecByteBlock x(DecodeHex(m_data[\"Qx\"]));\n\t\tSecByteBlock y(DecodeHex(m_data[\"Qy\"]));\n\t\tInteger r((m_data[\"R\"]+\"h\").c_str());\n\t\tInteger s((m_data[\"S\"]+\"h\").c_str());\n\n\t\ttypename EC::FieldElement Qx(x, x.size());\n\t\ttypename EC::FieldElement Qy(y, y.size());\n\t\ttypename EC::Element Q(Qx, Qy);\n\n\t\tDL_GroupParameters_EC<EC> params(oid);\n\t\ttypename ECDSA<EC, SHA1>::PublicKey pub;\n\t\tpub.Initialize(params, Q);\n\t\ttypename ECDSA<EC, SHA1>::Verifier verifier(pub);\n\n\t\tSecByteBlock sig(verifier.SignatureLength());\n\t\tr.Encode(sig, sig.size()/2);\n\t\ts.Encode(sig+sig.size()/2, sig.size()/2);\n\n\t\tSignatureVerificationFilter filter(verifier);\n\t\tfilter.Put(sig, sig.size());\n\t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new Redirector(filter, Redirector::DATA_ONLY)));\n\t\tfilter.MessageEnd();\n\t\tbyte b;\n\t\tfilter.Get(b);\n\t\tOutputData(output, \"Result \", b ? \"P\" : \"F\");\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"Result \"",
            "b ? \"P\" : \"F\""
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "OutputData",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "222-227",
          "snippet": "void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n\t{\n\t\tstd::string hexData;\n\t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n\t\tOutputData(output, t, hexData);\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n  \t{\n  \t\tstd::string hexData;\n  \t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n  \t\tOutputData(output, t, hexData);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter.Get",
          "args": [
            "b"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter.MessageEnd",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "807-808",
          "snippet": "bool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nbool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Msg\"]",
            "true",
            "new HexDecoder(new Redirector(filter, Redirector::DATA_ONLY))"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter.Put",
          "args": [
            "sig",
            "sig.size()"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "42-49",
          "snippet": "inline size_t Put(const byte *begin, size_t length)\n\t{\n\t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n\t\tif (buf+m_tail != begin)\n\t\t\tmemcpy(buf+m_tail, begin, l);\n\t\tm_tail += l;\n\t\treturn l;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t Put(const byte *begin, size_t length)\n  \t{\n  \t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n  \t\tif (buf+m_tail != begin)\n  \t\t\tmemcpy(buf+m_tail, begin, l);\n  \t\tm_tail += l;\n  \t\treturn l;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig.size",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.Encode",
          "args": [
            "sig+sig.size()/2",
            "sig.size()/2"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "verifier.SignatureLength",
          "args": [],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.Initialize",
          "args": [
            "params",
            "Q"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "Initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.h",
          "lines": "54-55",
          "snippet": "void Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}",
          "includes": [
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n\nvoid Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}"
        }
      },
      {
        "call_info": {
          "callee": "y.size",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ByteArrayParameter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "63-63",
          "snippet": "size_t size() const {return m_size;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nByteArrayParameter {\n  size_t size() const {return m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void EC_SigVer(string &output, const OID &oid)\n  \t{\n  \t\tSecByteBlock x(DecodeHex(m_data[\"Qx\"]));\n  \t\tSecByteBlock y(DecodeHex(m_data[\"Qy\"]));\n  \t\tInteger r((m_data[\"R\"]+\"h\").c_str());\n  \t\tInteger s((m_data[\"S\"]+\"h\").c_str());\n  \n  \t\ttypename EC::FieldElement Qx(x, x.size());\n  \t\ttypename EC::FieldElement Qy(y, y.size());\n  \t\ttypename EC::Element Q(Qx, Qy);\n  \n  \t\tDL_GroupParameters_EC<EC> params(oid);\n  \t\ttypename ECDSA<EC, SHA1>::PublicKey pub;\n  \t\tpub.Initialize(params, Q);\n  \t\ttypename ECDSA<EC, SHA1>::Verifier verifier(pub);\n  \n  \t\tSecByteBlock sig(verifier.SignatureLength());\n  \t\tr.Encode(sig, sig.size()/2);\n  \t\ts.Encode(sig+sig.size()/2, sig.size()/2);\n  \n  \t\tSignatureVerificationFilter filter(verifier);\n  \t\tfilter.Put(sig, sig.size());\n  \t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new Redirector(filter, Redirector::DATA_ONLY)));\n  \t\tfilter.MessageEnd();\n  \t\tbyte b;\n  \t\tfilter.Get(b);\n  \t\tOutputData(output, \"Result \", b ? \"P\" : \"F\");\n  \t}\n}"
  },
  {
    "function_name": "EC_SigGen",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "315-332",
    "snippet": "void EC_SigGen(string &output, const OID &oid)\n\t{\n\t\tDL_GroupParameters_EC<EC> params(oid);\n\t\ttypename ECDSA<EC, SHA1>::PrivateKey priv;\n\t\ttypename ECDSA<EC, SHA1>::PublicKey pub;\n\t\tpriv.Initialize(m_rng, params);\n\t\tpriv.MakePublicKey(pub);\n\n\t\ttypename ECDSA<EC, SHA1>::Signer signer(priv);\n\t\tSecByteBlock sig(signer.SignatureLength());\n\t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new SignerFilter(m_rng, signer, new ArraySink(sig, sig.size()))));\n\t\tSecByteBlock R(sig, sig.size()/2), S(sig+sig.size()/2, sig.size()/2);\n\n\t\tOutputData(output, \"Qx \", pub.GetPublicElement().x, params.GetCurve().GetField().MaxElementByteLength());\n\t\tOutputData(output, \"Qy \", pub.GetPublicElement().y, params.GetCurve().GetField().MaxElementByteLength());\n\t\tOutputData(output, \"R \", R);\n\t\tOutputData(output, \"S \", S);\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"S \"",
            "S"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "OutputData",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "222-227",
          "snippet": "void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n\t{\n\t\tstd::string hexData;\n\t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n\t\tOutputData(output, t, hexData);\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n  \t{\n  \t\tstd::string hexData;\n  \t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n  \t\tOutputData(output, t, hexData);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"Qy \"",
            "pub.GetPublicElement().y",
            "params.GetCurve().GetField().MaxElementByteLength()"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetPublicElement",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"Qx \"",
            "pub.GetPublicElement().x",
            "params.GetCurve().GetField().MaxElementByteLength()"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetPublicElement",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig.size",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "m_data[\"Msg\"]",
            "true",
            "new HexDecoder(new SignerFilter(m_rng, signer, new ArraySink(sig, sig.size())))"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer.SignatureLength",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.MakePublicKey",
          "args": [
            "pub"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.Initialize",
          "args": [
            "m_rng",
            "params"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "Initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.h",
          "lines": "54-55",
          "snippet": "void Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}",
          "includes": [
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n\nvoid Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void EC_SigGen(string &output, const OID &oid)\n  \t{\n  \t\tDL_GroupParameters_EC<EC> params(oid);\n  \t\ttypename ECDSA<EC, SHA1>::PrivateKey priv;\n  \t\ttypename ECDSA<EC, SHA1>::PublicKey pub;\n  \t\tpriv.Initialize(m_rng, params);\n  \t\tpriv.MakePublicKey(pub);\n  \n  \t\ttypename ECDSA<EC, SHA1>::Signer signer(priv);\n  \t\tSecByteBlock sig(signer.SignatureLength());\n  \t\tStringSource(m_data[\"Msg\"], true, new HexDecoder(new SignerFilter(m_rng, signer, new ArraySink(sig, sig.size()))));\n  \t\tSecByteBlock R(sig, sig.size()/2), S(sig+sig.size()/2, sig.size()/2);\n  \n  \t\tOutputData(output, \"Qx \", pub.GetPublicElement().x, params.GetCurve().GetField().MaxElementByteLength());\n  \t\tOutputData(output, \"Qy \", pub.GetPublicElement().y, params.GetCurve().GetField().MaxElementByteLength());\n  \t\tOutputData(output, \"R \", R);\n  \t\tOutputData(output, \"S \", S);\n  \t}\n}"
  },
  {
    "function_name": "EC_KeyPair",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "298-312",
    "snippet": "void EC_KeyPair(string &output, int n, const OID &oid)\n\t{\n\t\tDL_GroupParameters_EC<EC> params(oid);\n\t\tfor (int i=0; i<n; i++)\n\t\t{\n\t\t\tDL_PrivateKey_EC<EC> priv;\n\t\t\tDL_PublicKey_EC<EC> pub;\n\t\t\tpriv.Initialize(m_rng, params);\n\t\t\tpriv.MakePublicKey(pub);\n\n\t\t\tOutputData(output, \"d \", priv.GetPrivateExponent());\n\t\t\tOutputData(output, \"Qx \", pub.GetPublicElement().x, params.GetCurve().GetField().MaxElementByteLength());\n\t\t\tOutputData(output, \"Qy \", pub.GetPublicElement().y, params.GetCurve().GetField().MaxElementByteLength());\n\t\t}\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"Qy \"",
            "pub.GetPublicElement().y",
            "params.GetCurve().GetField().MaxElementByteLength()"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetPublicElement",
          "args": [],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"Qx \"",
            "pub.GetPublicElement().x",
            "params.GetCurve().GetField().MaxElementByteLength()"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetCurve",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pub.GetPublicElement",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "\"d \"",
            "priv.GetPrivateExponent()"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "OutputData",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "222-227",
          "snippet": "void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n\t{\n\t\tstd::string hexData;\n\t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n\t\tOutputData(output, t, hexData);\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n  \t{\n  \t\tstd::string hexData;\n  \t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n  \t\tOutputData(output, t, hexData);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "priv.GetPrivateExponent",
          "args": [],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.MakePublicKey",
          "args": [
            "pub"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "priv.Initialize",
          "args": [
            "m_rng",
            "params"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "Initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.h",
          "lines": "54-55",
          "snippet": "void Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}",
          "includes": [
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n\nvoid Initialize(RandomNumberGenerator &rng, unsigned int modulusBits)\n\t\t{GenerateRandomWithKeySize(rng, modulusBits);}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void EC_KeyPair(string &output, int n, const OID &oid)\n  \t{\n  \t\tDL_GroupParameters_EC<EC> params(oid);\n  \t\tfor (int i=0; i<n; i++)\n  \t\t{\n  \t\t\tDL_PrivateKey_EC<EC> priv;\n  \t\t\tDL_PublicKey_EC<EC> pub;\n  \t\t\tpriv.Initialize(m_rng, params);\n  \t\t\tpriv.MakePublicKey(pub);\n  \n  \t\t\tOutputData(output, \"d \", priv.GetPrivateExponent());\n  \t\t\tOutputData(output, \"Qx \", pub.GetPublicElement().x, params.GetCurve().GetField().MaxElementByteLength());\n  \t\t\tOutputData(output, \"Qy \", pub.GetPublicElement().y, params.GetCurve().GetField().MaxElementByteLength());\n  \t\t}\n  \t}\n}"
  },
  {
    "function_name": "AssignLeftMostBits",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "292-295",
    "snippet": "static inline void AssignLeftMostBits(SecByteBlock &z, const SecByteBlock &x, unsigned int K)\n\t{\n\t\tz.Assign(x, K/8);\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z.Assign",
          "args": [
            "x",
            "K/8"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "Assign",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "310-314",
          "snippet": "void Assign(const T *t, size_type len)\n\t{\n\t\tNew(len);\n\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Assign(const T *t, size_type len)\n  \t{\n  \t\tNew(len);\n  \t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  static inline void AssignLeftMostBits(SecByteBlock &z, const SecByteBlock &x, unsigned int K)\n  \t{\n  \t\tz.Assign(x, K/8);\n  \t}\n}"
  },
  {
    "function_name": "UpdateKey",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "266-290",
    "snippet": "SecByteBlock UpdateKey(SecByteBlock key, const SecByteBlock *text)\n\t{\n\t\tunsigned int innerCount = (m_algorithm == \"AES\") ? 1000 : 10000;\n\t\tint keySize = key.size(), blockSize = text[0].size();\n\t\tSecByteBlock x(keySize);\n\t\tfor (int k=0; k<keySize;)\n\t\t{\n\t\t\tint pos = innerCount * blockSize - keySize + k;\n\t\t\tmemcpy(x + k, text[pos / blockSize] + pos % blockSize, blockSize - pos % blockSize);\n\t\t\tk += blockSize - pos % blockSize;\n\t\t}\n\n\t\tif (m_algorithm == \"TDES\" || m_algorithm == \"DES\")\n\t\t{\n\t\t\tfor (int i=0; i<keySize; i+=8)\n\t\t\t{\n\t\t\t\txorbuf(key+i, x+keySize-8-i, 8);\n\t\t\t\tDES::CorrectKeyParityBits(key+i);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\txorbuf(key, x, keySize);\n\n\t\treturn key;\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "key",
            "x",
            "keySize"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "DES::CorrectKeyParityBits",
          "args": [
            "key+i"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "DES::CorrectKeyParityBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/des.cpp",
          "lines": "412-417",
          "snippet": "void DES::CorrectKeyParityBits(byte *key)\n{\n\tfor (unsigned int i=0; i<8; i++)\n\t\tif (!CheckParity(key[i]))\n\t\t\tkey[i] ^= 1;\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid DES::CorrectKeyParityBits(byte *key)\n{\n\tfor (unsigned int i=0; i<8; i++)\n\t\tif (!CheckParity(key[i]))\n\t\t\tkey[i] ^= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "x + k",
            "text[pos / blockSize] + pos % blockSize",
            "blockSize - pos % blockSize"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text[0].size",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  SecByteBlock UpdateKey(SecByteBlock key, const SecByteBlock *text)\n  \t{\n  \t\tunsigned int innerCount = (m_algorithm == \"AES\") ? 1000 : 10000;\n  \t\tint keySize = key.size(), blockSize = text[0].size();\n  \t\tSecByteBlock x(keySize);\n  \t\tfor (int k=0; k<keySize;)\n  \t\t{\n  \t\t\tint pos = innerCount * blockSize - keySize + k;\n  \t\t\tmemcpy(x + k, text[pos / blockSize] + pos % blockSize, blockSize - pos % blockSize);\n  \t\t\tk += blockSize - pos % blockSize;\n  \t\t}\n  \n  \t\tif (m_algorithm == \"TDES\" || m_algorithm == \"DES\")\n  \t\t{\n  \t\t\tfor (int i=0; i<keySize; i+=8)\n  \t\t\t{\n  \t\t\t\txorbuf(key+i, x+keySize-8-i, 8);\n  \t\t\t\tDES::CorrectKeyParityBits(key+i);\n  \t\t\t}\n  \t\t}\n  \t\telse\n  \t\t\txorbuf(key, x, keySize);\n  \n  \t\treturn key;\n  \t}\n}"
  },
  {
    "function_name": "Xor",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "259-264",
    "snippet": "static inline void Xor(SecByteBlock &z, const SecByteBlock &x, const SecByteBlock &y)\n\t{\n\t\tassert(x.size() == y.size());\n\t\tz.resize(x.size());\n\t\txorbuf(z, x, y, x.size());\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "z",
            "x",
            "y",
            "x.size()"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "47-77",
          "snippet": "void xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "x.size",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "z.resize",
          "args": [
            "x.size()"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "x.size() == y.size()"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y.size",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "ByteArrayParameter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "63-63",
          "snippet": "size_t size() const {return m_size;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nByteArrayParameter {\n  size_t size() const {return m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  static inline void Xor(SecByteBlock &z, const SecByteBlock &x, const SecByteBlock &y)\n  \t{\n  \t\tassert(x.size() == y.size());\n  \t\tz.resize(x.size());\n  \t\txorbuf(z, x, y, x.size());\n  \t}\n}"
  },
  {
    "function_name": "OutputGivenData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "229-239",
    "snippet": "void OutputGivenData(std::string &output, DataType t, bool optional = false)\n\t{\n\t\tif (m_data.find(m_typeToName[t]) == m_data.end())\n\t\t{\n\t\t\tif (optional)\n\t\t\t\treturn;\n\t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: key not found: \" + m_typeToName[t]);\n\t\t}\n\n\t\tOutputData(output, t, m_data[m_typeToName[t]]);\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OutputData",
          "args": [
            "output",
            "t",
            "m_data[m_typeToName[t]]"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "OutputData",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "222-227",
          "snippet": "void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n\t{\n\t\tstd::string hexData;\n\t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n\t\tOutputData(output, t, hexData);\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n  \t{\n  \t\tstd::string hexData;\n  \t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n  \t\tOutputData(output, t, hexData);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"TestDataParser: key not found: \" + m_typeToName[t]"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data.end",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_data.find",
          "args": [
            "m_typeToName[t]"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputGivenData(std::string &output, DataType t, bool optional = false)\n  \t{\n  \t\tif (m_data.find(m_typeToName[t]) == m_data.end())\n  \t\t{\n  \t\t\tif (optional)\n  \t\t\t\treturn;\n  \t\t\tthrow Exception(Exception::OTHER_ERROR, \"TestDataParser: key not found: \" + m_typeToName[t]);\n  \t\t}\n  \n  \t\tOutputData(output, t, m_data[m_typeToName[t]]);\n  \t}\n}"
  },
  {
    "function_name": "OutputData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "222-227",
    "snippet": "void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n\t{\n\t\tstd::string hexData;\n\t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n\t\tOutputData(output, t, hexData);\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "data.begin()",
            "data.size()",
            "true",
            "new HexEncoder(new StringSink(hexData), false)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, DataType t, const SecByteBlock &data)\n  \t{\n  \t\tstd::string hexData;\n  \t\tStringSource(data.begin(), data.size(), true, new HexEncoder(new StringSink(hexData), false));\n  \t\tOutputData(output, t, hexData);\n  \t}\n}"
  },
  {
    "function_name": "OutputData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "217-220",
    "snippet": "void OutputData(std::string &output, DataType t, int i)\n\t{\n\t\tOutputData(output, t, IntToString(i));\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "i"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, DataType t, int i)\n  \t{\n  \t\tOutputData(output, t, IntToString(i));\n  \t}\n}"
  },
  {
    "function_name": "OutputData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "178-215",
    "snippet": "void OutputData(std::string &output, DataType t, const std::string &data)\n\t{\n\t\tif (m_algorithm == \"SKIPJACK\")\n\t\t{\n\t\t\tif (m_test == \"KAT\")\n\t\t\t{\n\t\t\t\tif (t == OUTPUT)\n\t\t\t\t\toutput = m_line + data + \"\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (t != COUNT)\n\t\t\t\t{\n\t\t\t\t\toutput += m_typeToName[t];\n\t\t\t\t\toutput += \"=\";\n\t\t\t\t}\n\t\t\t\toutput += data;\n\t\t\t\toutput += t == OUTPUT ? \"\\n\" : \"  \";\n\t\t\t}\n\t\t}\n\t\telse if (m_algorithm == \"TDES\" && t == KEY_T && m_typeToName[KEY_T].empty())\n\t\t{\n\t\t\toutput += \"KEY1 = \";\n\t\t\toutput += data.substr(0, 16);\n\t\t\toutput += \"\\nKEY2 = \";\n\t\t\toutput += data.size() > 16 ? data.substr(16, 16) : data.substr(0, 16);\n\t\t\toutput += \"\\nKEY3 = \";\n\t\t\toutput += data.size() > 32 ? data.substr(32, 16) : data.substr(0, 16);\n\t\t\toutput += \"\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\toutput += m_typeToName[t];\n\t\t\toutput += \" = \";\n\t\t\toutput += data;\n\t\t\toutput += \"\\n\";\n\t\t}\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data.substr",
          "args": [
            "0",
            "16"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.substr",
          "args": [
            "32",
            "16"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.substr",
          "args": [
            "0",
            "16"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.substr",
          "args": [
            "16",
            "16"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.substr",
          "args": [
            "0",
            "16"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_typeToName[KEY_T].empty",
          "args": [],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, DataType t, const std::string &data)\n  \t{\n  \t\tif (m_algorithm == \"SKIPJACK\")\n  \t\t{\n  \t\t\tif (m_test == \"KAT\")\n  \t\t\t{\n  \t\t\t\tif (t == OUTPUT)\n  \t\t\t\t\toutput = m_line + data + \"\\n\";\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tif (t != COUNT)\n  \t\t\t\t{\n  \t\t\t\t\toutput += m_typeToName[t];\n  \t\t\t\t\toutput += \"=\";\n  \t\t\t\t}\n  \t\t\t\toutput += data;\n  \t\t\t\toutput += t == OUTPUT ? \"\\n\" : \"  \";\n  \t\t\t}\n  \t\t}\n  \t\telse if (m_algorithm == \"TDES\" && t == KEY_T && m_typeToName[KEY_T].empty())\n  \t\t{\n  \t\t\toutput += \"KEY1 = \";\n  \t\t\toutput += data.substr(0, 16);\n  \t\t\toutput += \"\\nKEY2 = \";\n  \t\t\toutput += data.size() > 16 ? data.substr(16, 16) : data.substr(0, 16);\n  \t\t\toutput += \"\\nKEY3 = \";\n  \t\t\toutput += data.size() > 32 ? data.substr(32, 16) : data.substr(0, 16);\n  \t\t\toutput += \"\\n\";\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\toutput += m_typeToName[t];\n  \t\t\toutput += \" = \";\n  \t\t\toutput += data;\n  \t\t\toutput += \"\\n\";\n  \t\t}\n  \t}\n}"
  },
  {
    "function_name": "OutputData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "171-176",
    "snippet": "void OutputData(std::string &output, const std::string &key, const PolynomialMod2 &data, int size=-1)\n\t{\n\t\tSecByteBlock s(size < 0 ? data.MinEncodedSize() : size);\n\t\tdata.Encode(s, s.size());\n\t\tOutputData(output, key, s);\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data.Encode",
          "args": [
            "s",
            "s.size()"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.size",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.MinEncodedSize",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, const std::string &key, const PolynomialMod2 &data, int size=-1)\n  \t{\n  \t\tSecByteBlock s(size < 0 ? data.MinEncodedSize() : size);\n  \t\tdata.Encode(s, s.size());\n  \t\tOutputData(output, key, s);\n  \t}\n}"
  },
  {
    "function_name": "OutputData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "164-169",
    "snippet": "void OutputData(std::string &output, const std::string &key, const Integer &data, int size=-1)\n\t{\n\t\tSecByteBlock s(size < 0 ? data.MinEncodedSize() : size);\n\t\tdata.Encode(s, s.size());\n\t\tOutputData(output, key, s);\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data.Encode",
          "args": [
            "s",
            "s.size()"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.size",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.MinEncodedSize",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, const std::string &key, const Integer &data, int size=-1)\n  \t{\n  \t\tSecByteBlock s(size < 0 ? data.MinEncodedSize() : size);\n  \t\tdata.Encode(s, s.size());\n  \t\tOutputData(output, key, s);\n  \t}\n}"
  },
  {
    "function_name": "OutputData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "156-162",
    "snippet": "void OutputData(std::string &output, const std::string &key, const SecByteBlock &data)\n\t{\n\t\toutput += key;\n\t\toutput += \"= \";\n\t\tHexEncoder(new StringSink(output), false).Put(data, data.size());\n\t\toutput += \"\\n\";\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HexEncoder",
          "args": [
            "data",
            "data.size()"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "HexEncoder",
          "args": [
            "new StringSink(output)",
            "false"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, const std::string &key, const SecByteBlock &data)\n  \t{\n  \t\toutput += key;\n  \t\toutput += \"= \";\n  \t\tHexEncoder(new StringSink(output), false).Put(data, data.size());\n  \t\toutput += \"\\n\";\n  \t}\n}"
  },
  {
    "function_name": "OutputData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "151-154",
    "snippet": "void OutputData(std::string &output, const std::string &key, int data)\n\t{\n\t\tOutputData(output, key, IntToString(data));\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "data"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, const std::string &key, int data)\n  \t{\n  \t\tOutputData(output, key, IntToString(data));\n  \t}\n}"
  },
  {
    "function_name": "OutputData",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "143-149",
    "snippet": "void OutputData(std::string &output, const std::string &key, const std::string &data)\n\t{\n\t\toutput += key;\n\t\toutput += \"= \";\n\t\toutput += data;\n\t\toutput += \"\\n\";\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void OutputData(std::string &output, const std::string &key, const std::string &data)\n  \t{\n  \t\toutput += key;\n  \t\toutput += \"= \";\n  \t\toutput += data;\n  \t\toutput += \"\\n\";\n  \t}\n}"
  },
  {
    "function_name": "SetEncrypt",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "108-140",
    "snippet": "void SetEncrypt(bool encrypt)\n\t{\n\t\tm_encrypt = encrypt;\n\t\tif (encrypt)\n\t\t{\n\t\t\tm_nameToType[\"PLAINTEXT\"] = INPUT;\n\t\t\tm_nameToType[\"CIPHERTEXT\"] = OUTPUT;\n\t\t\tm_nameToType[\"PT\"] = INPUT;\n\t\t\tm_nameToType[\"CT\"] = OUTPUT;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_nameToType[\"PLAINTEXT\"] = OUTPUT;\n\t\t\tm_nameToType[\"CIPHERTEXT\"] = INPUT;\n\t\t\tm_nameToType[\"PT\"] = OUTPUT;\n\t\t\tm_nameToType[\"CT\"] = INPUT;\n\t\t}\n\n\t\tif (m_algorithm == \"AES\" || m_algorithm == \"TDES\")\n\t\t{\n\t\t\tif (encrypt)\n\t\t\t{\n\t\t\t\tm_trigger = \"PLAINTEXT\";\n\t\t\t\tm_typeToName[OUTPUT] = \"CIPHERTEXT\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_trigger = \"CIPHERTEXT\";\n\t\t\t\tm_typeToName[OUTPUT] = \"PLAINTEXT\";\n\t\t\t}\n\t\t\tm_count = 0;\n\t\t}\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void SetEncrypt(bool encrypt)\n  \t{\n  \t\tm_encrypt = encrypt;\n  \t\tif (encrypt)\n  \t\t{\n  \t\t\tm_nameToType[\"PLAINTEXT\"] = INPUT;\n  \t\t\tm_nameToType[\"CIPHERTEXT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"PT\"] = INPUT;\n  \t\t\tm_nameToType[\"CT\"] = OUTPUT;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tm_nameToType[\"PLAINTEXT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"CIPHERTEXT\"] = INPUT;\n  \t\t\tm_nameToType[\"PT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"CT\"] = INPUT;\n  \t\t}\n  \n  \t\tif (m_algorithm == \"AES\" || m_algorithm == \"TDES\")\n  \t\t{\n  \t\t\tif (encrypt)\n  \t\t\t{\n  \t\t\t\tm_trigger = \"PLAINTEXT\";\n  \t\t\t\tm_typeToName[OUTPUT] = \"CIPHERTEXT\";\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tm_trigger = \"CIPHERTEXT\";\n  \t\t\t\tm_typeToName[OUTPUT] = \"PLAINTEXT\";\n  \t\t\t}\n  \t\t\tm_count = 0;\n  \t\t}\n  \t}\n}"
  },
  {
    "function_name": "TestDataParser",
    "container": "TestDataParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "57-106",
    "snippet": "TestDataParser(std::string algorithm, std::string test, std::string mode, unsigned int feedbackSize, bool encrypt, BufferedTransformation *attachment)\n\t\t: m_algorithm(algorithm), m_test(test), m_mode(mode), m_feedbackSize(feedbackSize)\n\t\t, m_firstLine(true), m_blankLineTransition(0)\n\t{\n\t\tDetach(attachment);\n\n\t\tm_typeToName[COUNT] = \"COUNT\";\n\n\t\tm_nameToType[\"COUNT\"] = COUNT;\n\t\tm_nameToType[\"KEY\"] = KEY_T;\n\t\tm_nameToType[\"KEYs\"] = KEY_T;\n\t\tm_nameToType[\"key\"] = KEY_T;\n\t\tm_nameToType[\"Key\"] = KEY_T;\n\t\tm_nameToType[\"IV\"] = IV;\n\t\tm_nameToType[\"IV1\"] = IV;\n\t\tm_nameToType[\"CV\"] = IV;\n\t\tm_nameToType[\"CV1\"] = IV;\n\t\tm_nameToType[\"IB\"] = IV;\n\t\tm_nameToType[\"TEXT\"] = INPUT;\n\t\tm_nameToType[\"RESULT\"] = OUTPUT;\n\t\tm_nameToType[\"Msg\"] = INPUT;\n\t\tm_nameToType[\"Seed\"] = INPUT;\n\t\tm_nameToType[\"V\"] = INPUT;\n\t\tm_nameToType[\"DT\"] = IV;\n\t\tSetEncrypt(encrypt);\n\n\t\tif (m_algorithm == \"DSA\" || m_algorithm == \"ECDSA\")\n\t\t{\n\t\t\tif (m_test == \"PKV\")\n\t\t\t\tm_trigger = \"Qy\";\n\t\t\telse if (m_test == \"KeyPair\")\n\t\t\t\tm_trigger = \"N\";\n\t\t\telse if (m_test == \"SigGen\")\n\t\t\t\tm_trigger = \"Msg\";\n\t\t\telse if (m_test == \"SigVer\")\n\t\t\t\tm_trigger = \"S\";\n\t\t\telse if (m_test == \"PQGGen\")\n\t\t\t\tm_trigger = \"N\";\n\t\t\telse if (m_test == \"PQGVer\")\n\t\t\t\tm_trigger = \"H\";\n\t\t}\n\t\telse if (m_algorithm == \"HMAC\")\n\t\t\tm_trigger = \"Msg\";\n\t\telse if (m_algorithm == \"SHA\")\n\t\t\tm_trigger = (m_test == \"MONTE\") ? \"Seed\" : \"Msg\";\n\t\telse if (m_algorithm == \"RNG\")\n\t\t\tm_trigger = \"V\";\n\t\telse if (m_algorithm == \"RSA\")\n\t\t\tm_trigger = (m_test == \"Ver\") ? \"S\" : \"Msg\";\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetEncrypt",
          "args": [
            "encrypt"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "SetEncrypt",
          "container": "TestDataParser",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
          "lines": "108-140",
          "snippet": "void SetEncrypt(bool encrypt)\n\t{\n\t\tm_encrypt = encrypt;\n\t\tif (encrypt)\n\t\t{\n\t\t\tm_nameToType[\"PLAINTEXT\"] = INPUT;\n\t\t\tm_nameToType[\"CIPHERTEXT\"] = OUTPUT;\n\t\t\tm_nameToType[\"PT\"] = INPUT;\n\t\t\tm_nameToType[\"CT\"] = OUTPUT;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_nameToType[\"PLAINTEXT\"] = OUTPUT;\n\t\t\tm_nameToType[\"CIPHERTEXT\"] = INPUT;\n\t\t\tm_nameToType[\"PT\"] = OUTPUT;\n\t\t\tm_nameToType[\"CT\"] = INPUT;\n\t\t}\n\n\t\tif (m_algorithm == \"AES\" || m_algorithm == \"TDES\")\n\t\t{\n\t\t\tif (encrypt)\n\t\t\t{\n\t\t\t\tm_trigger = \"PLAINTEXT\";\n\t\t\t\tm_typeToName[OUTPUT] = \"CIPHERTEXT\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_trigger = \"CIPHERTEXT\";\n\t\t\t\tm_typeToName[OUTPUT] = \"PLAINTEXT\";\n\t\t\t}\n\t\t\tm_count = 0;\n\t\t}\n\t}",
          "includes": [
            "#include \"oids.h\"",
            "#include \"dll.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  void SetEncrypt(bool encrypt)\n  \t{\n  \t\tm_encrypt = encrypt;\n  \t\tif (encrypt)\n  \t\t{\n  \t\t\tm_nameToType[\"PLAINTEXT\"] = INPUT;\n  \t\t\tm_nameToType[\"CIPHERTEXT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"PT\"] = INPUT;\n  \t\t\tm_nameToType[\"CT\"] = OUTPUT;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tm_nameToType[\"PLAINTEXT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"CIPHERTEXT\"] = INPUT;\n  \t\t\tm_nameToType[\"PT\"] = OUTPUT;\n  \t\t\tm_nameToType[\"CT\"] = INPUT;\n  \t\t}\n  \n  \t\tif (m_algorithm == \"AES\" || m_algorithm == \"TDES\")\n  \t\t{\n  \t\t\tif (encrypt)\n  \t\t\t{\n  \t\t\t\tm_trigger = \"PLAINTEXT\";\n  \t\t\t\tm_typeToName[OUTPUT] = \"CIPHERTEXT\";\n  \t\t\t}\n  \t\t\telse\n  \t\t\t{\n  \t\t\t\tm_trigger = \"CIPHERTEXT\";\n  \t\t\t\tm_typeToName[OUTPUT] = \"PLAINTEXT\";\n  \t\t\t}\n  \t\t\tm_count = 0;\n  \t\t}\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Detach",
          "args": [
            "attachment"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "Filter::Detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "40-43",
          "snippet": "void Filter::Detach(BufferedTransformation *newOut)\n{\n\tm_attachment.reset(newOut);\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nvoid Filter::Detach(BufferedTransformation *newOut)\n{\n\tm_attachment.reset(newOut);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nTestDataParser {\n  TestDataParser(std::string algorithm, std::string test, std::string mode, unsigned int feedbackSize, bool encrypt, BufferedTransformation *attachment)\n  \t\t: m_algorithm(algorithm), m_test(test), m_mode(mode), m_feedbackSize(feedbackSize)\n  \t\t, m_firstLine(true), m_blankLineTransition(0)\n  \t{\n  \t\tDetach(attachment);\n  \n  \t\tm_typeToName[COUNT] = \"COUNT\";\n  \n  \t\tm_nameToType[\"COUNT\"] = COUNT;\n  \t\tm_nameToType[\"KEY\"] = KEY_T;\n  \t\tm_nameToType[\"KEYs\"] = KEY_T;\n  \t\tm_nameToType[\"key\"] = KEY_T;\n  \t\tm_nameToType[\"Key\"] = KEY_T;\n  \t\tm_nameToType[\"IV\"] = IV;\n  \t\tm_nameToType[\"IV1\"] = IV;\n  \t\tm_nameToType[\"CV\"] = IV;\n  \t\tm_nameToType[\"CV1\"] = IV;\n  \t\tm_nameToType[\"IB\"] = IV;\n  \t\tm_nameToType[\"TEXT\"] = INPUT;\n  \t\tm_nameToType[\"RESULT\"] = OUTPUT;\n  \t\tm_nameToType[\"Msg\"] = INPUT;\n  \t\tm_nameToType[\"Seed\"] = INPUT;\n  \t\tm_nameToType[\"V\"] = INPUT;\n  \t\tm_nameToType[\"DT\"] = IV;\n  \t\tSetEncrypt(encrypt);\n  \n  \t\tif (m_algorithm == \"DSA\" || m_algorithm == \"ECDSA\")\n  \t\t{\n  \t\t\tif (m_test == \"PKV\")\n  \t\t\t\tm_trigger = \"Qy\";\n  \t\t\telse if (m_test == \"KeyPair\")\n  \t\t\t\tm_trigger = \"N\";\n  \t\t\telse if (m_test == \"SigGen\")\n  \t\t\t\tm_trigger = \"Msg\";\n  \t\t\telse if (m_test == \"SigVer\")\n  \t\t\t\tm_trigger = \"S\";\n  \t\t\telse if (m_test == \"PQGGen\")\n  \t\t\t\tm_trigger = \"N\";\n  \t\t\telse if (m_test == \"PQGVer\")\n  \t\t\t\tm_trigger = \"H\";\n  \t\t}\n  \t\telse if (m_algorithm == \"HMAC\")\n  \t\t\tm_trigger = \"Msg\";\n  \t\telse if (m_algorithm == \"SHA\")\n  \t\t\tm_trigger = (m_test == \"MONTE\") ? \"Seed\" : \"Msg\";\n  \t\telse if (m_algorithm == \"RNG\")\n  \t\t\tm_trigger = \"V\";\n  \t\telse if (m_algorithm == \"RSA\")\n  \t\t\tm_trigger = (m_test == \"Ver\") ? \"S\" : \"Msg\";\n  \t}\n}"
  },
  {
    "function_name": "Put2",
    "container": "LineBreakParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "22-46",
    "snippet": "size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)\n\t{\n\t\tif (!blocking)\n\t\t\tthrow BlockingInputOnly(\"LineBreakParser\");\n\t\t\n\t\tunsigned int i, last = 0;\n\t\tfor (i=0; i<length; i++)\n\t\t{\n\t\t\tif (begin[i] == m_lineEnd)\n\t\t\t{\n\t\t\t\tAttachedTransformation()->Put2(begin+last, i-last, GetAutoSignalPropagation(), blocking);\n\t\t\t\tlast = i+1;\n\t\t\t}\n\t\t}\n\t\tif (last != i)\n\t\t\tAttachedTransformation()->Put2(begin+last, i-last, 0, blocking);\n\n\t\tif (messageEnd && GetAutoSignalPropagation())\n\t\t{\n\t\t\tAttachedTransformation()->MessageEnd(GetAutoSignalPropagation()-1, blocking);\n\t\t\tAttachedTransformation()->MessageSeriesEnd(GetAutoSignalPropagation()-1, blocking);\n\t\t}\n\n\t\treturn 0;\n\t}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "GetAutoSignalPropagation()-1",
            "blocking"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAutoSignalPropagation",
          "args": [],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "GetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "860-860",
          "snippet": "virtual int GetAutoSignalPropagation() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual int GetAutoSignalPropagation() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "GetAutoSignalPropagation()-1",
            "blocking"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "begin+last",
            "i-last",
            "0",
            "blocking"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [
            "begin+last",
            "i-last",
            "GetAutoSignalPropagation()",
            "blocking"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"LineBreakParser\""
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nLineBreakParser {\n  size_t Put2(const byte *begin, size_t length, int messageEnd, bool blocking)\n  \t{\n  \t\tif (!blocking)\n  \t\t\tthrow BlockingInputOnly(\"LineBreakParser\");\n  \t\t\n  \t\tunsigned int i, last = 0;\n  \t\tfor (i=0; i<length; i++)\n  \t\t{\n  \t\t\tif (begin[i] == m_lineEnd)\n  \t\t\t{\n  \t\t\t\tAttachedTransformation()->Put2(begin+last, i-last, GetAutoSignalPropagation(), blocking);\n  \t\t\t\tlast = i+1;\n  \t\t\t}\n  \t\t}\n  \t\tif (last != i)\n  \t\t\tAttachedTransformation()->Put2(begin+last, i-last, 0, blocking);\n  \n  \t\tif (messageEnd && GetAutoSignalPropagation())\n  \t\t{\n  \t\t\tAttachedTransformation()->MessageEnd(GetAutoSignalPropagation()-1, blocking);\n  \t\t\tAttachedTransformation()->MessageSeriesEnd(GetAutoSignalPropagation()-1, blocking);\n  \t\t}\n  \n  \t\treturn 0;\n  \t}\n}"
  },
  {
    "function_name": "LineBreakParser",
    "container": "LineBreakParser",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/fipsalgt.cpp",
    "lines": "19-20",
    "snippet": "LineBreakParser(BufferedTransformation *attachment=NULL, byte lineEnd='\\n')\n\t\t: m_lineEnd(lineEnd) {Detach(attachment);}",
    "includes": [
      "#include \"oids.h\"",
      "#include \"dll.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Detach",
          "args": [
            "attachment"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "Filter::Detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "40-43",
          "snippet": "void Filter::Detach(BufferedTransformation *newOut)\n{\n\tm_attachment.reset(newOut);\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nvoid Filter::Detach(BufferedTransformation *newOut)\n{\n\tm_attachment.reset(newOut);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"oids.h\"\n#include \"dll.h\"\n\nLineBreakParser {\n  LineBreakParser(BufferedTransformation *attachment=NULL, byte lineEnd='\\n')\n  \t\t: m_lineEnd(lineEnd) {Detach(attachment);}\n}"
  }
]