[
  {
    "function_name": "ProcessAndXorBlock",
    "container": "BTEA::Dec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tea.cpp",
    "lines": "132-157",
    "snippet": "void BTEA::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tunsigned int n = m_blockSize / 4;\n\tword32 *v = (word32*)outBlock;\n\tConditionalByteReverse(BIG_ENDIAN_ORDER, v, (const word32*)inBlock, m_blockSize);\n\n\tword32 y = v[0], z = v[n-1], e;\n\tword32 p, q = 6+52/n;\n\tword32 sum = q * DELTA;\n\n\twhile (sum != 0)\n\t{   \n\t\te = sum>>2 & 3;\n\t\tfor (p = n-1; p > 0; p--)\n\t\t{\n\t\t\tz = v[p-1];\n\t\t\ty = v[p] -= MX;\n\t\t}\n\n\t\tz = v[n-1];\n\t\ty = v[0] -= MX;\n\t\tsum -= DELTA;\n\t}\n\n\tConditionalByteReverse(BIG_ENDIAN_ORDER, v, v, m_blockSize);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"tea.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define MX (z>>5^y<<2)+(y>>3^z<<4)^(sum^y)+(m_k[p&3^e]^z)"
    ],
    "globals_used": [
      "static const word32 DELTA = 0x9e3779b9;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ConditionalByteReverse",
          "args": [
            "BIG_ENDIAN_ORDER",
            "v",
            "v",
            "m_blockSize"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "937-943",
          "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"tea.h\"\n#include \"pch.h\"\n\n#define MX (z>>5^y<<2)+(y>>3^z<<4)^(sum^y)+(m_k[p&3^e]^z)\n\nstatic const word32 DELTA = 0x9e3779b9;\n\nBTEA {\n  Dec {\n    void BTEA::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tunsigned int n = m_blockSize / 4;\n    \tword32 *v = (word32*)outBlock;\n    \tConditionalByteReverse(BIG_ENDIAN_ORDER, v, (const word32*)inBlock, m_blockSize);\n    \n    \tword32 y = v[0], z = v[n-1], e;\n    \tword32 p, q = 6+52/n;\n    \tword32 sum = q * DELTA;\n    \n    \twhile (sum != 0)\n    \t{   \n    \t\te = sum>>2 & 3;\n    \t\tfor (p = n-1; p > 0; p--)\n    \t\t{\n    \t\t\tz = v[p-1];\n    \t\t\ty = v[p] -= MX;\n    \t\t}\n    \n    \t\tz = v[n-1];\n    \t\ty = v[0] -= MX;\n    \t\tsum -= DELTA;\n    \t}\n    \n    \tConditionalByteReverse(BIG_ENDIAN_ORDER, v, v, m_blockSize);\n    }\n  }\n}"
  },
  {
    "function_name": "ProcessAndXorBlock",
    "container": "BTEA::Enc",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tea.cpp",
    "lines": "106-130",
    "snippet": "void BTEA::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tunsigned int n = m_blockSize / 4;\n\tword32 *v = (word32*)outBlock;\n\tConditionalByteReverse(BIG_ENDIAN_ORDER, v, (const word32*)inBlock, m_blockSize);\n\n\tword32 y = v[0], z = v[n-1], e;\n\tword32 p, q = 6+52/n;\n\tword32 sum = 0;\n\t\n\twhile (q-- > 0)\n\t{   \n\t\tsum += DELTA;\n\t\te = sum>>2 & 3;\n\t\tfor (p = 0; p < n-1; p++)\n\t\t{\n\t\t\ty = v[p+1];\n\t\t\tz = v[p] += MX;\n\t\t}\n\t\ty = v[0];\n\t\tz = v[n-1] += MX;\n\t}\n\n\tConditionalByteReverse(BIG_ENDIAN_ORDER, v, v, m_blockSize);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"tea.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define MX (z>>5^y<<2)+(y>>3^z<<4)^(sum^y)+(m_k[p&3^e]^z)"
    ],
    "globals_used": [
      "static const word32 DELTA = 0x9e3779b9;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ConditionalByteReverse",
          "args": [
            "BIG_ENDIAN_ORDER",
            "v",
            "v",
            "m_blockSize"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "937-943",
          "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"tea.h\"\n#include \"pch.h\"\n\n#define MX (z>>5^y<<2)+(y>>3^z<<4)^(sum^y)+(m_k[p&3^e]^z)\n\nstatic const word32 DELTA = 0x9e3779b9;\n\nBTEA {\n  Enc {\n    void BTEA::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tunsigned int n = m_blockSize / 4;\n    \tword32 *v = (word32*)outBlock;\n    \tConditionalByteReverse(BIG_ENDIAN_ORDER, v, (const word32*)inBlock, m_blockSize);\n    \n    \tword32 y = v[0], z = v[n-1], e;\n    \tword32 p, q = 6+52/n;\n    \tword32 sum = 0;\n    \t\n    \twhile (q-- > 0)\n    \t{   \n    \t\tsum += DELTA;\n    \t\te = sum>>2 & 3;\n    \t\tfor (p = 0; p < n-1; p++)\n    \t\t{\n    \t\t\ty = v[p+1];\n    \t\t\tz = v[p] += MX;\n    \t\t}\n    \t\ty = v[0];\n    \t\tz = v[n-1] += MX;\n    \t}\n    \n    \tConditionalByteReverse(BIG_ENDIAN_ORDER, v, v, m_blockSize);\n    }\n  }\n}"
  },
  {
    "function_name": "ProcessAndXorBlock",
    "container": "XTEA::Dec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tea.cpp",
    "lines": "82-102",
    "snippet": "void XTEA::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tword32 y, z;\n\tBlock::Get(inBlock)(y)(z);\n\n#ifdef __SUNPRO_CC\n\t// workaround needed on Sun Studio 12u1 Sun C++ 5.10 SunOS_i386 128229-02 2009/09/21\n\tsize_t sum = m_limit;\n\twhile ((sum&0xffffffff) != 0)\n#else\n\tword32 sum = m_limit;\n\twhile (sum != 0)\n#endif\n\t{\n\t\tz -= (y<<4 ^ y>>5) + y ^ sum + m_k[sum>>11 & 3];\n\t\tsum -= DELTA;\n\t\ty -= (z<<4 ^ z>>5) + z ^ sum + m_k[sum&3];\n\t}\n\n\tBlock::Put(xorBlock, outBlock)(y)(z);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"tea.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const word32 DELTA = 0x9e3779b9;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "z"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "xorBlock",
            "outBlock"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Get",
          "args": [
            "z"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"tea.h\"\n#include \"pch.h\"\n\nstatic const word32 DELTA = 0x9e3779b9;\n\nXTEA {\n  Dec {\n    void XTEA::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tword32 y, z;\n    \tBlock::Get(inBlock)(y)(z);\n    \n    #ifdef __SUNPRO_CC\n    \t// workaround needed on Sun Studio 12u1 Sun C++ 5.10 SunOS_i386 128229-02 2009/09/21\n    \tsize_t sum = m_limit;\n    \twhile ((sum&0xffffffff) != 0)\n    #else\n    \tword32 sum = m_limit;\n    \twhile (sum != 0)\n    #endif\n    \t{\n    \t\tz -= (y<<4 ^ y>>5) + y ^ sum + m_k[sum>>11 & 3];\n    \t\tsum -= DELTA;\n    \t\ty -= (z<<4 ^ z>>5) + z ^ sum + m_k[sum&3];\n    \t}\n    \n    \tBlock::Put(xorBlock, outBlock)(y)(z);\n    }\n  }\n}"
  },
  {
    "function_name": "ProcessAndXorBlock",
    "container": "XTEA::Enc",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tea.cpp",
    "lines": "60-80",
    "snippet": "void XTEA::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tword32 y, z;\n\tBlock::Get(inBlock)(y)(z);\n\n#ifdef __SUNPRO_CC\n\t// workaround needed on Sun Studio 12u1 Sun C++ 5.10 SunOS_i386 128229-02 2009/09/21\n\tsize_t sum = 0;\n\twhile ((sum&0xffffffff) != m_limit)\n#else\n\tword32 sum = 0;\n\twhile (sum != m_limit)\n#endif\n\t{   \n\t\ty += (z<<4 ^ z>>5) + z ^ sum + m_k[sum&3];\n\t\tsum += DELTA;\n\t\tz += (y<<4 ^ y>>5) + y ^ sum + m_k[sum>>11 & 3];\n\t}\n\n\tBlock::Put(xorBlock, outBlock)(y)(z);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"tea.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const word32 DELTA = 0x9e3779b9;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "z"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "xorBlock",
            "outBlock"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Get",
          "args": [
            "z"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"tea.h\"\n#include \"pch.h\"\n\nstatic const word32 DELTA = 0x9e3779b9;\n\nXTEA {\n  Enc {\n    void XTEA::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tword32 y, z;\n    \tBlock::Get(inBlock)(y)(z);\n    \n    #ifdef __SUNPRO_CC\n    \t// workaround needed on Sun Studio 12u1 Sun C++ 5.10 SunOS_i386 128229-02 2009/09/21\n    \tsize_t sum = 0;\n    \twhile ((sum&0xffffffff) != m_limit)\n    #else\n    \tword32 sum = 0;\n    \twhile (sum != m_limit)\n    #endif\n    \t{   \n    \t\ty += (z<<4 ^ z>>5) + z ^ sum + m_k[sum&3];\n    \t\tsum += DELTA;\n    \t\tz += (y<<4 ^ y>>5) + y ^ sum + m_k[sum>>11 & 3];\n    \t}\n    \n    \tBlock::Put(xorBlock, outBlock)(y)(z);\n    }\n  }\n}"
  },
  {
    "function_name": "UncheckedSetKey",
    "container": "XTEA::Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tea.cpp",
    "lines": "52-58",
    "snippet": "void XTEA::Base::UncheckedSetKey(const byte *userKey, unsigned int length,  const NameValuePairs &params)\n{\n\tAssertValidKeyLength(length);\n\n\tGetUserKey(BIG_ENDIAN_ORDER, m_k.begin(), 4, userKey, KEYLENGTH);\n\tm_limit = GetRoundsAndThrowIfInvalid(params, this) * DELTA;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"tea.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const word32 DELTA = 0x9e3779b9;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetRoundsAndThrowIfInvalid",
          "args": [
            "params",
            "this"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "GetRoundsAndThrowIfInvalid",
          "container": "FixedBlockSize::FixedRounds::VariableRounds",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/seckey.h",
          "lines": "54-59",
          "snippet": "inline unsigned int GetRoundsAndThrowIfInvalid(const NameValuePairs &param, const Algorithm *alg)\n\t{\n\t\tint rounds = param.GetIntValueWithDefault(\"Rounds\", DEFAULT_ROUNDS);\n\t\tThrowIfInvalidRounds(rounds, alg);\n\t\treturn (unsigned int)rounds;\n\t}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nFixedBlockSize {\n  FixedRounds {\n    VariableRounds {\n      inline unsigned int GetRoundsAndThrowIfInvalid(const NameValuePairs &param, const Algorithm *alg)\n      \t{\n      \t\tint rounds = param.GetIntValueWithDefault(\"Rounds\", DEFAULT_ROUNDS);\n      \t\tThrowIfInvalidRounds(rounds, alg);\n      \t\treturn (unsigned int)rounds;\n      \t}\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserKey",
          "args": [
            "BIG_ENDIAN_ORDER",
            "m_k.begin()",
            "4",
            "userKey",
            "KEYLENGTH"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "946-953",
          "snippet": "inline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n{\n\tconst size_t U = sizeof(T);\n\tassert(inlen <= outlen*U);\n\tmemcpy_s(out, outlen*U, in, inlen);\n\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n{\n\tconst size_t U = sizeof(T);\n\tassert(inlen <= outlen*U);\n\tmemcpy_s(out, outlen*U, in, inlen);\n\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_k.begin",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertValidKeyLength",
          "args": [
            "length"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"tea.h\"\n#include \"pch.h\"\n\nstatic const word32 DELTA = 0x9e3779b9;\n\nXTEA {\n  Base {\n    void XTEA::Base::UncheckedSetKey(const byte *userKey, unsigned int length,  const NameValuePairs &params)\n    {\n    \tAssertValidKeyLength(length);\n    \n    \tGetUserKey(BIG_ENDIAN_ORDER, m_k.begin(), 4, userKey, KEYLENGTH);\n    \tm_limit = GetRoundsAndThrowIfInvalid(params, this) * DELTA;\n    }\n  }\n}"
  },
  {
    "function_name": "ProcessAndXorBlock",
    "container": "TEA::Dec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tea.cpp",
    "lines": "36-50",
    "snippet": "void TEA::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tword32 y, z;\n\tBlock::Get(inBlock)(y)(z);\n\n\tword32 sum = m_limit;\n\twhile (sum != 0)\n\t{\n\t\tz -= (y << 4) + m_k[2] ^ y + sum ^ (y >> 5) + m_k[3]; \n\t\ty -= (z << 4) + m_k[0] ^ z + sum ^ (z >> 5) + m_k[1];\n\t\tsum -= DELTA;\n\t}\n\n\tBlock::Put(xorBlock, outBlock)(y)(z);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"tea.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const word32 DELTA = 0x9e3779b9;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "z"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "xorBlock",
            "outBlock"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Get",
          "args": [
            "z"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"tea.h\"\n#include \"pch.h\"\n\nstatic const word32 DELTA = 0x9e3779b9;\n\nTEA {\n  Dec {\n    void TEA::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tword32 y, z;\n    \tBlock::Get(inBlock)(y)(z);\n    \n    \tword32 sum = m_limit;\n    \twhile (sum != 0)\n    \t{\n    \t\tz -= (y << 4) + m_k[2] ^ y + sum ^ (y >> 5) + m_k[3]; \n    \t\ty -= (z << 4) + m_k[0] ^ z + sum ^ (z >> 5) + m_k[1];\n    \t\tsum -= DELTA;\n    \t}\n    \n    \tBlock::Put(xorBlock, outBlock)(y)(z);\n    }\n  }\n}"
  },
  {
    "function_name": "ProcessAndXorBlock",
    "container": "TEA::Enc",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tea.cpp",
    "lines": "20-34",
    "snippet": "void TEA::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tword32 y, z;\n\tBlock::Get(inBlock)(y)(z);\n\n\tword32 sum = 0;\n\twhile (sum != m_limit)\n\t{   \n\t\tsum += DELTA;\n\t\ty += (z << 4) + m_k[0] ^ z + sum ^ (z >> 5) + m_k[1];\n\t\tz += (y << 4) + m_k[2] ^ y + sum ^ (y >> 5) + m_k[3];\n\t}\n\n\tBlock::Put(xorBlock, outBlock)(y)(z);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"tea.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const word32 DELTA = 0x9e3779b9;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "z"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "785-786",
          "snippet": "size_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t Put(byte inByte, bool blocking=true)\n\t\t\t{return Put(&inByte, 1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Put",
          "args": [
            "xorBlock",
            "outBlock"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Block::Get",
          "args": [
            "z"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"tea.h\"\n#include \"pch.h\"\n\nstatic const word32 DELTA = 0x9e3779b9;\n\nTEA {\n  Enc {\n    void TEA::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tword32 y, z;\n    \tBlock::Get(inBlock)(y)(z);\n    \n    \tword32 sum = 0;\n    \twhile (sum != m_limit)\n    \t{   \n    \t\tsum += DELTA;\n    \t\ty += (z << 4) + m_k[0] ^ z + sum ^ (z >> 5) + m_k[1];\n    \t\tz += (y << 4) + m_k[2] ^ y + sum ^ (y >> 5) + m_k[3];\n    \t}\n    \n    \tBlock::Put(xorBlock, outBlock)(y)(z);\n    }\n  }\n}"
  },
  {
    "function_name": "UncheckedSetKey",
    "container": "TEA::Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/tea.cpp",
    "lines": "12-18",
    "snippet": "void TEA::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &params)\n{\n\tAssertValidKeyLength(length);\n\n\tGetUserKey(BIG_ENDIAN_ORDER, m_k.begin(), 4, userKey, KEYLENGTH);\n\tm_limit = GetRoundsAndThrowIfInvalid(params, this) * DELTA;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"tea.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const word32 DELTA = 0x9e3779b9;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetRoundsAndThrowIfInvalid",
          "args": [
            "params",
            "this"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "GetRoundsAndThrowIfInvalid",
          "container": "FixedBlockSize::FixedRounds::VariableRounds",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/seckey.h",
          "lines": "54-59",
          "snippet": "inline unsigned int GetRoundsAndThrowIfInvalid(const NameValuePairs &param, const Algorithm *alg)\n\t{\n\t\tint rounds = param.GetIntValueWithDefault(\"Rounds\", DEFAULT_ROUNDS);\n\t\tThrowIfInvalidRounds(rounds, alg);\n\t\treturn (unsigned int)rounds;\n\t}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nFixedBlockSize {\n  FixedRounds {\n    VariableRounds {\n      inline unsigned int GetRoundsAndThrowIfInvalid(const NameValuePairs &param, const Algorithm *alg)\n      \t{\n      \t\tint rounds = param.GetIntValueWithDefault(\"Rounds\", DEFAULT_ROUNDS);\n      \t\tThrowIfInvalidRounds(rounds, alg);\n      \t\treturn (unsigned int)rounds;\n      \t}\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserKey",
          "args": [
            "BIG_ENDIAN_ORDER",
            "m_k.begin()",
            "4",
            "userKey",
            "KEYLENGTH"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "946-953",
          "snippet": "inline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n{\n\tconst size_t U = sizeof(T);\n\tassert(inlen <= outlen*U);\n\tmemcpy_s(out, outlen*U, in, inlen);\n\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void GetUserKey(ByteOrder order, T *out, size_t outlen, const byte *in, size_t inlen)\n{\n\tconst size_t U = sizeof(T);\n\tassert(inlen <= outlen*U);\n\tmemcpy_s(out, outlen*U, in, inlen);\n\tmemset_z((byte *)out+inlen, 0, outlen*U-inlen);\n\tConditionalByteReverse(order, out, out, RoundUpToMultipleOf(inlen, U));\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_k.begin",
          "args": [],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertValidKeyLength",
          "args": [
            "length"
          ],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"tea.h\"\n#include \"pch.h\"\n\nstatic const word32 DELTA = 0x9e3779b9;\n\nTEA {\n  Base {\n    void TEA::Base::UncheckedSetKey(const byte *userKey, unsigned int length, const NameValuePairs &params)\n    {\n    \tAssertValidKeyLength(length);\n    \n    \tGetUserKey(BIG_ENDIAN_ORDER, m_k.begin(), 4, userKey, KEYLENGTH);\n    \tm_limit = GetRoundsAndThrowIfInvalid(params, this) * DELTA;\n    }\n  }\n}"
  }
]