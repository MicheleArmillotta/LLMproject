[
  {
    "function_name": "FlushOutput",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "574-582",
    "snippet": "void Inflator::FlushOutput()\n{\n\tif (m_state != PRE_STREAM)\n\t{\n\t\tassert(m_current >= m_lastFlush);\n\t\tProcessDecompressedData(m_window + m_lastFlush, m_current - m_lastFlush);\n\t\tm_lastFlush = m_current;\n\t}\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessDecompressedData",
          "args": [
            "m_window + m_lastFlush",
            "m_current - m_lastFlush"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessDecompressedData",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "114-115",
          "snippet": "virtual void ProcessDecompressedData(const byte *string, size_t length)\n\t\t{AttachedTransformation()->Put(string, length);}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  virtual void ProcessDecompressedData(const byte *string, size_t length)\n  \t\t{AttachedTransformation()->Put(string, length);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_current >= m_lastFlush"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::FlushOutput()\n  {\n  \tif (m_state != PRE_STREAM)\n  \t{\n  \t\tassert(m_current >= m_lastFlush);\n  \t\tProcessDecompressedData(m_window + m_lastFlush, m_current - m_lastFlush);\n  \t\tm_lastFlush = m_current;\n  \t}\n  }\n}"
  },
  {
    "function_name": "DecodeBody",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "464-572",
    "snippet": "bool Inflator::DecodeBody()\n{\n\tbool blockEnd = false;\n\tswitch (m_blockType)\n\t{\n\tcase 0:\t// stored\n\t\tassert(m_reader.BitsBuffered() == 0);\n\t\twhile (!m_inQueue.IsEmpty() && !blockEnd)\n\t\t{\n\t\t\tsize_t size;\n\t\t\tconst byte *block = m_inQueue.Spy(size);\n\t\t\tsize = UnsignedMin(m_storedLen, size);\n\t\t\tOutputString(block, size);\n\t\t\tm_inQueue.Skip(size);\n\t\t\tm_storedLen -= (word16)size;\n\t\t\tif (m_storedLen == 0)\n\t\t\t\tblockEnd = true;\n\t\t}\n\t\tbreak;\n\tcase 1:\t// fixed codes\n\tcase 2:\t// dynamic codes\n\t\tstatic const unsigned int lengthStarts[] = {\n\t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceStarts[] = {\n\t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t\t\t8193, 12289, 16385, 24577};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanDecoder& literalDecoder = GetLiteralDecoder();\n\t\tconst HuffmanDecoder& distanceDecoder = GetDistanceDecoder();\n\n\t\tswitch (m_nextDecode)\n\t\t{\n\t\tcase LITERAL:\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (!literalDecoder.Decode(m_reader, m_literal))\n\t\t\t\t{\n\t\t\t\t\tm_nextDecode = LITERAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (m_literal < 256)\n\t\t\t\t\tOutputByte((byte)m_literal);\n\t\t\t\telse if (m_literal == 256)\t// end of block\n\t\t\t\t{\n\t\t\t\t\tblockEnd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (m_literal > 285)\n\t\t\t\t\t\tthrow BadBlockErr();\n\t\t\t\t\tunsigned int bits;\n\t\tcase LENGTH_BITS:\n\t\t\t\t\tbits = lengthExtraBits[m_literal-257];\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = LENGTH_BITS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tm_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];\n\t\tcase DISTANCE:\n\t\t\t\t\tif (!distanceDecoder.Decode(m_reader, m_distance))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = DISTANCE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\tcase DISTANCE_BITS:\n\t\t\t\t\tbits = distanceExtraBits[m_distance];\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\n\t\t\t\t\tOutputPast(m_literal, m_distance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (blockEnd)\n\t{\n\t\tif (m_eof)\n\t\t{\n\t\t\tFlushOutput();\n\t\t\tm_reader.SkipBits(m_reader.BitsBuffered()%8);\n\t\t\tif (m_reader.BitsBuffered())\n\t\t\t{\n\t\t\t\t// undo too much lookahead\n\t\t\t\tSecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);\n\t\t\t\tfor (unsigned int i=0; i<buffer.size(); i++)\n\t\t\t\t\tbuffer[i] = (byte)m_reader.GetBits(8);\n\t\t\t\tm_inQueue.Unget(buffer, buffer.size());\n\t\t\t}\n\t\t\tm_state = POST_STREAM;\n\t\t}\n\t\telse\n\t\t\tm_state = WAIT_HEADER;\n\t}\n\treturn blockEnd;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_inQueue.Unget",
          "args": [
            "buffer",
            "buffer.size()"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "Unget",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "383-397",
          "snippet": "void ByteQueue::Unget(const byte *inString, size_t length)\n{\n\tsize_t len = STDMIN(length, m_head->m_head);\n\tlength -= len;\n\tm_head->m_head -= len;\n\tmemcpy(m_head->buf + m_head->m_head, inString + length, len);\n\n\tif (length > 0)\n\t{\n\t\tByteQueueNode *newHead = new ByteQueueNode(length);\n\t\tnewHead->next = m_head;\n\t\tm_head = newHead;\n\t\tm_head->Put(inString, length);\n\t}\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  void ByteQueue::Unget(const byte *inString, size_t length)\n  {\n  \tsize_t len = STDMIN(length, m_head->m_head);\n  \tlength -= len;\n  \tm_head->m_head -= len;\n  \tmemcpy(m_head->buf + m_head->m_head, inString + length, len);\n  \n  \tif (length > 0)\n  \t{\n  \t\tByteQueueNode *newHead = new ByteQueueNode(length);\n  \t\tnewHead->next = m_head;\n  \t\tm_head = newHead;\n  \t\tm_head->Put(inString, length);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer.size",
          "args": [],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_reader.GetBits",
          "args": [
            "8"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "GetBits",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "50-55",
          "snippet": "inline unsigned long LowFirstBitReader::GetBits(unsigned int length)\n{\n\tunsigned long result = PeekBits(length);\n\tSkipBits(length);\n\treturn result;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline unsigned long LowFirstBitReader::GetBits(unsigned int length)\n  {\n  \tunsigned long result = PeekBits(length);\n  \tSkipBits(length);\n  \treturn result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_reader.BitsBuffered",
          "args": [],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "BitsBuffered",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "16-16",
          "snippet": "unsigned int BitsBuffered() const {return m_bitsBuffered;}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nLowFirstBitReader {\n  unsigned int BitsBuffered() const {return m_bitsBuffered;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_reader.SkipBits",
          "args": [
            "m_reader.BitsBuffered()%8"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "SkipBits",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "43-48",
          "snippet": "inline void LowFirstBitReader::SkipBits(unsigned int length)\n{\n\tassert(m_bitsBuffered >= length);\n\tm_buffer >>= length;\n\tm_bitsBuffered -= length;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline void LowFirstBitReader::SkipBits(unsigned int length)\n  {\n  \tassert(m_bitsBuffered >= length);\n  \tm_buffer >>= length;\n  \tm_bitsBuffered -= length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FlushOutput",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "FlushOutput",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "574-582",
          "snippet": "void Inflator::FlushOutput()\n{\n\tif (m_state != PRE_STREAM)\n\t{\n\t\tassert(m_current >= m_lastFlush);\n\t\tProcessDecompressedData(m_window + m_lastFlush, m_current - m_lastFlush);\n\t\tm_lastFlush = m_current;\n\t}\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::FlushOutput()\n  {\n  \tif (m_state != PRE_STREAM)\n  \t{\n  \t\tassert(m_current >= m_lastFlush);\n  \t\tProcessDecompressedData(m_window + m_lastFlush, m_current - m_lastFlush);\n  \t\tm_lastFlush = m_current;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputPast",
          "args": [
            "m_literal",
            "m_distance"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "OutputPast",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "260-287",
          "snippet": "void Inflator::OutputPast(unsigned int length, unsigned int distance)\n{\n\tsize_t start;\n\tif (distance <= m_current)\n\t\tstart = m_current - distance;\n\telse if (m_wrappedAround && distance <= m_window.size())\n\t\tstart = m_current + m_window.size() - distance;\n\telse\n\t\tthrow BadBlockErr();\n\n\tif (start + length > m_window.size())\n\t{\n\t\tfor (; start < m_window.size(); start++, length--)\n\t\t\tOutputByte(m_window[start]);\n\t\tstart = 0;\n\t}\n\n\tif (start + length > m_current || m_current + length >= m_window.size())\n\t{\n\t\twhile (length--)\n\t\t\tOutputByte(m_window[start++]);\n\t}\n\telse\n\t{\n\t\tmemcpy(m_window + m_current, m_window + start, length);\n\t\tm_current += length;\n\t}\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::OutputPast(unsigned int length, unsigned int distance)\n  {\n  \tsize_t start;\n  \tif (distance <= m_current)\n  \t\tstart = m_current - distance;\n  \telse if (m_wrappedAround && distance <= m_window.size())\n  \t\tstart = m_current + m_window.size() - distance;\n  \telse\n  \t\tthrow BadBlockErr();\n  \n  \tif (start + length > m_window.size())\n  \t{\n  \t\tfor (; start < m_window.size(); start++, length--)\n  \t\t\tOutputByte(m_window[start]);\n  \t\tstart = 0;\n  \t}\n  \n  \tif (start + length > m_current || m_current + length >= m_window.size())\n  \t{\n  \t\twhile (length--)\n  \t\t\tOutputByte(m_window[start++]);\n  \t}\n  \telse\n  \t{\n  \t\tmemcpy(m_window + m_current, m_window + start, length);\n  \t\tm_current += length;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_reader.FillBuffer",
          "args": [
            "bits"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "FillBuffer",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "22-34",
          "snippet": "inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n{\n\twhile (m_bitsBuffered < length)\n\t{\n\t\tbyte b;\n\t\tif (!m_store.Get(b))\n\t\t\treturn false;\n\t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n\t\tm_bitsBuffered += 8;\n\t}\n\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\treturn true;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n  {\n  \twhile (m_bitsBuffered < length)\n  \t{\n  \t\tbyte b;\n  \t\tif (!m_store.Get(b))\n  \t\t\treturn false;\n  \t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n  \t\tm_bitsBuffered += 8;\n  \t}\n  \tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "distanceDecoder.Decode",
          "args": [
            "m_reader",
            "m_distance"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "Decode",
          "container": "HuffmanDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "202-210",
          "snippet": "bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n{\n\treader.FillBuffer(m_maxCodeBits);\n\tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n\tif (codeBits > reader.BitsBuffered())\n\t\treturn false;\n\treader.SkipBits(codeBits);\n\treturn true;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n  {\n  \treader.FillBuffer(m_maxCodeBits);\n  \tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n  \tif (codeBits > reader.BitsBuffered())\n  \t\treturn false;\n  \treader.SkipBits(codeBits);\n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BadBlockErr",
          "args": [],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "BadBlockErr",
          "container": "Inflator::BadBlockErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "95-95",
          "snippet": "BadBlockErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in compressed block\") {}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  BadBlockErr {\n    BadBlockErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in compressed block\") {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputByte",
          "args": [
            "(byte)m_literal"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "OutputByte",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "229-239",
          "snippet": "void Inflator::OutputByte(byte b)\n{\n\tm_window[m_current++] = b;\n\tif (m_current == m_window.size())\n\t{\n\t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n\t\tm_lastFlush = 0;\n\t\tm_current = 0;\n\t\tm_wrappedAround = true;\n\t}\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::OutputByte(byte b)\n  {\n  \tm_window[m_current++] = b;\n  \tif (m_current == m_window.size())\n  \t{\n  \t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n  \t\tm_lastFlush = 0;\n  \t\tm_current = 0;\n  \t\tm_wrappedAround = true;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDistanceDecoder",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLiteralDecoder",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inQueue.Skip",
          "args": [
            "size"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "Skip",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "168-179",
          "snippet": "lword FileStore::Skip(lword skipMax)\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tlword oldPos = m_stream->tellg();\n\tstd::istream::off_type offset;\n\tif (!SafeConvert(skipMax, offset))\n\t\tthrow InvalidArgument(\"FileStore: maximum seek offset exceeded\");\n\tm_stream->seekg(offset, ios::cur);\n\treturn (lword)m_stream->tellg() - oldPos;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::Skip(lword skipMax)\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tlword oldPos = m_stream->tellg();\n  \tstd::istream::off_type offset;\n  \tif (!SafeConvert(skipMax, offset))\n  \t\tthrow InvalidArgument(\"FileStore: maximum seek offset exceeded\");\n  \tm_stream->seekg(offset, ios::cur);\n  \treturn (lword)m_stream->tellg() - oldPos;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputString",
          "args": [
            "block",
            "size"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "OutputString",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "241-258",
          "snippet": "void Inflator::OutputString(const byte *string, size_t length)\n{\n\twhile (length)\n\t{\n\t\tsize_t len = UnsignedMin(length, m_window.size() - m_current);\n\t\tmemcpy(m_window + m_current, string, len);\n\t\tm_current += len;\n\t\tif (m_current == m_window.size())\n\t\t{\n\t\t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n\t\t\tm_lastFlush = 0;\n\t\t\tm_current = 0;\n\t\t\tm_wrappedAround = true;\n\t\t}\n\t\tstring += len;\n\t\tlength -= len;\n\t}\t\t\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::OutputString(const byte *string, size_t length)\n  {\n  \twhile (length)\n  \t{\n  \t\tsize_t len = UnsignedMin(length, m_window.size() - m_current);\n  \t\tmemcpy(m_window + m_current, string, len);\n  \t\tm_current += len;\n  \t\tif (m_current == m_window.size())\n  \t\t{\n  \t\t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n  \t\t\tm_lastFlush = 0;\n  \t\t\tm_current = 0;\n  \t\t\tm_wrappedAround = true;\n  \t\t}\n  \t\tstring += len;\n  \t\tlength -= len;\n  \t}\t\t\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "m_storedLen",
            "size"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inQueue.Spy",
          "args": [
            "size"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inQueue.IsEmpty",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "IsEmpty",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "198-201",
          "snippet": "bool ByteQueue::IsEmpty() const\n{\n\treturn m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  bool ByteQueue::IsEmpty() const\n  {\n  \treturn m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_reader.BitsBuffered() == 0"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  bool Inflator::DecodeBody()\n  {\n  \tbool blockEnd = false;\n  \tswitch (m_blockType)\n  \t{\n  \tcase 0:\t// stored\n  \t\tassert(m_reader.BitsBuffered() == 0);\n  \t\twhile (!m_inQueue.IsEmpty() && !blockEnd)\n  \t\t{\n  \t\t\tsize_t size;\n  \t\t\tconst byte *block = m_inQueue.Spy(size);\n  \t\t\tsize = UnsignedMin(m_storedLen, size);\n  \t\t\tOutputString(block, size);\n  \t\t\tm_inQueue.Skip(size);\n  \t\t\tm_storedLen -= (word16)size;\n  \t\t\tif (m_storedLen == 0)\n  \t\t\t\tblockEnd = true;\n  \t\t}\n  \t\tbreak;\n  \tcase 1:\t// fixed codes\n  \tcase 2:\t// dynamic codes\n  \t\tstatic const unsigned int lengthStarts[] = {\n  \t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  \t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n  \t\tstatic const unsigned int lengthExtraBits[] = {\n  \t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n  \t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n  \t\tstatic const unsigned int distanceStarts[] = {\n  \t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  \t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  \t\t\t8193, 12289, 16385, 24577};\n  \t\tstatic const unsigned int distanceExtraBits[] = {\n  \t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n  \t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n  \t\t\t12, 12, 13, 13};\n  \n  \t\tconst HuffmanDecoder& literalDecoder = GetLiteralDecoder();\n  \t\tconst HuffmanDecoder& distanceDecoder = GetDistanceDecoder();\n  \n  \t\tswitch (m_nextDecode)\n  \t\t{\n  \t\tcase LITERAL:\n  \t\t\twhile (true)\n  \t\t\t{\n  \t\t\t\tif (!literalDecoder.Decode(m_reader, m_literal))\n  \t\t\t\t{\n  \t\t\t\t\tm_nextDecode = LITERAL;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tif (m_literal < 256)\n  \t\t\t\t\tOutputByte((byte)m_literal);\n  \t\t\t\telse if (m_literal == 256)\t// end of block\n  \t\t\t\t{\n  \t\t\t\t\tblockEnd = true;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\tif (m_literal > 285)\n  \t\t\t\t\t\tthrow BadBlockErr();\n  \t\t\t\t\tunsigned int bits;\n  \t\tcase LENGTH_BITS:\n  \t\t\t\t\tbits = lengthExtraBits[m_literal-257];\n  \t\t\t\t\tif (!m_reader.FillBuffer(bits))\n  \t\t\t\t\t{\n  \t\t\t\t\t\tm_nextDecode = LENGTH_BITS;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t\tm_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];\n  \t\tcase DISTANCE:\n  \t\t\t\t\tif (!distanceDecoder.Decode(m_reader, m_distance))\n  \t\t\t\t\t{\n  \t\t\t\t\t\tm_nextDecode = DISTANCE;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\tcase DISTANCE_BITS:\n  \t\t\t\t\tbits = distanceExtraBits[m_distance];\n  \t\t\t\t\tif (!m_reader.FillBuffer(bits))\n  \t\t\t\t\t{\n  \t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\n  \t\t\t\t\tOutputPast(m_literal, m_distance);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (blockEnd)\n  \t{\n  \t\tif (m_eof)\n  \t\t{\n  \t\t\tFlushOutput();\n  \t\t\tm_reader.SkipBits(m_reader.BitsBuffered()%8);\n  \t\t\tif (m_reader.BitsBuffered())\n  \t\t\t{\n  \t\t\t\t// undo too much lookahead\n  \t\t\t\tSecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);\n  \t\t\t\tfor (unsigned int i=0; i<buffer.size(); i++)\n  \t\t\t\t\tbuffer[i] = (byte)m_reader.GetBits(8);\n  \t\t\t\tm_inQueue.Unget(buffer, buffer.size());\n  \t\t\t}\n  \t\t\tm_state = POST_STREAM;\n  \t\t}\n  \t\telse\n  \t\t\tm_state = WAIT_HEADER;\n  \t}\n  \treturn blockEnd;\n  }\n}"
  },
  {
    "function_name": "DecodeHeader",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "362-462",
    "snippet": "void Inflator::DecodeHeader()\n{\n\tif (!m_reader.FillBuffer(3))\n\t\tthrow UnexpectedEndErr();\n\tm_eof = m_reader.GetBits(1) != 0;\n\tm_blockType = (byte)m_reader.GetBits(2);\n\tswitch (m_blockType)\n\t{\n\tcase 0:\t// stored\n\t\t{\n\t\tm_reader.SkipBits(m_reader.BitsBuffered() % 8);\n\t\tif (!m_reader.FillBuffer(32))\n\t\t\tthrow UnexpectedEndErr();\n\t\tm_storedLen = (word16)m_reader.GetBits(16);\n\t\tword16 nlen = (word16)m_reader.GetBits(16);\n\t\tif (nlen != (word16)~m_storedLen)\n\t\t\tthrow BadBlockErr();\n\t\tbreak;\n\t\t}\n\tcase 1:\t// fixed codes\n\t\tm_nextDecode = LITERAL;\n\t\tbreak;\n\tcase 2:\t// dynamic codes\n\t\t{\n\t\tif (!m_reader.FillBuffer(5+5+4))\n\t\t\tthrow UnexpectedEndErr();\n\t\tunsigned int hlit = m_reader.GetBits(5);\n\t\tunsigned int hdist = m_reader.GetBits(5);\n\t\tunsigned int hclen = m_reader.GetBits(4);\n\n\t\tFixedSizeSecBlock<unsigned int, 286+32> codeLengths;\n\t\tunsigned int i;\n\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\tstd::fill(codeLengths.begin(), codeLengths+19, 0);\n\t\tfor (i=0; i<hclen+4; i++)\n\t\t\tcodeLengths[border[i]] = m_reader.GetBits(3);\n\n\t\ttry\n\t\t{\n\t\t\tHuffmanDecoder codeLengthDecoder(codeLengths, 19);\n\t\t\tfor (i = 0; i < hlit+257+hdist+1; )\n\t\t\t{\n\t\t\t\tunsigned int k, count, repeater;\n\t\t\t\tbool result = codeLengthDecoder.Decode(m_reader, k);\n\t\t\t\tif (!result)\n\t\t\t\t\tthrow UnexpectedEndErr();\n\t\t\t\tif (k <= 15)\n\t\t\t\t{\n\t\t\t\t\tcount = 1;\n\t\t\t\t\trepeater = k;\n\t\t\t\t}\n\t\t\t\telse switch (k)\n\t\t\t\t{\n\t\t\t\tcase 16:\n\t\t\t\t\tif (!m_reader.FillBuffer(2))\n\t\t\t\t\t\tthrow UnexpectedEndErr();\n\t\t\t\t\tcount = 3 + m_reader.GetBits(2);\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t\tthrow BadBlockErr();\n\t\t\t\t\trepeater = codeLengths[i-1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 17:\n\t\t\t\t\tif (!m_reader.FillBuffer(3))\n\t\t\t\t\t\tthrow UnexpectedEndErr();\n\t\t\t\t\tcount = 3 + m_reader.GetBits(3);\n\t\t\t\t\trepeater = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\t\tif (!m_reader.FillBuffer(7))\n\t\t\t\t\t\tthrow UnexpectedEndErr();\n\t\t\t\t\tcount = 11 + m_reader.GetBits(7);\n\t\t\t\t\trepeater = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i + count > hlit+257+hdist+1)\n\t\t\t\t\tthrow BadBlockErr();\n\t\t\t\tstd::fill(codeLengths + i, codeLengths + i + count, repeater);\n\t\t\t\ti += count;\n\t\t\t}\n\t\t\tm_dynamicLiteralDecoder.Initialize(codeLengths, hlit+257);\n\t\t\tif (hdist == 0 && codeLengths[hlit+257] == 0)\n\t\t\t{\n\t\t\t\tif (hlit != 0)\t// a single zero distance code length means all literals\n\t\t\t\t\tthrow BadBlockErr();\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_dynamicDistanceDecoder.Initialize(codeLengths+hlit+257, hdist+1);\n\t\t\tm_nextDecode = LITERAL;\n\t\t}\n\t\tcatch (HuffmanDecoder::Err &)\n\t\t{\n\t\t\tthrow BadBlockErr();\n\t\t}\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\tthrow BadBlockErr();\t// reserved block type\n\t}\n\tm_state = DECODING_BODY;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BadBlockErr",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "BadBlockErr",
          "container": "Inflator::BadBlockErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "95-95",
          "snippet": "BadBlockErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in compressed block\") {}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  BadBlockErr {\n    BadBlockErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in compressed block\") {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_dynamicDistanceDecoder.Initialize",
          "args": [
            "codeLengths+hlit+257",
            "hdist+1"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "Initialize",
          "container": "HuffmanDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "62-146",
          "snippet": "void HuffmanDecoder::Initialize(const unsigned int *codeBits, unsigned int nCodes)\n{\n\t// the Huffman codes are represented in 3 ways in this code:\n\t//\n\t// 1. most significant code bit (i.e. top of code tree) in the least significant bit position\n\t// 2. most significant code bit (i.e. top of code tree) in the most significant bit position\n\t// 3. most significant code bit (i.e. top of code tree) in n-th least significant bit position,\n\t//    where n is the maximum code length for this code tree\n\t//\n\t// (1) is the way the codes come in from the deflate stream\n\t// (2) is used to sort codes so they can be binary searched\n\t// (3) is used in this function to compute codes from code lengths\n\t//\n\t// a code in representation (2) is called \"normalized\" here\n\t// The BitReverse() function is used to convert between (1) and (2)\n\t// The NormalizeCode() function is used to convert from (3) to (2)\n\n\tif (nCodes == 0)\n\t\tthrow Err(\"null code\");\n\n\tm_maxCodeBits = *std::max_element(codeBits, codeBits+nCodes);\n\n\tif (m_maxCodeBits > MAX_CODE_BITS)\n\t\tthrow Err(\"code length exceeds maximum\");\n\n\tif (m_maxCodeBits == 0)\n\t\tthrow Err(\"null code\");\n\n\t// count number of codes of each length\n\tSecBlockWithHint<unsigned int, 15+1> blCount(m_maxCodeBits+1);\n\tstd::fill(blCount.begin(), blCount.end(), 0);\n\tunsigned int i;\n\tfor (i=0; i<nCodes; i++)\n\t\tblCount[codeBits[i]]++;\n\n\t// compute the starting code of each length\n\tcode_t code = 0;\n\tSecBlockWithHint<code_t, 15+1> nextCode(m_maxCodeBits+1);\n\tnextCode[1] = 0;\n\tfor (i=2; i<=m_maxCodeBits; i++)\n\t{\n\t\t// compute this while checking for overflow: code = (code + blCount[i-1]) << 1\n\t\tif (code > code + blCount[i-1])\n\t\t\tthrow Err(\"codes oversubscribed\");\n\t\tcode += blCount[i-1];\n\t\tif (code > (code << 1))\n\t\t\tthrow Err(\"codes oversubscribed\");\n\t\tcode <<= 1;\n\t\tnextCode[i] = code;\n\t}\n\n\tif (code > (1 << m_maxCodeBits) - blCount[m_maxCodeBits])\n\t\tthrow Err(\"codes oversubscribed\");\n\telse if (m_maxCodeBits != 1 && code < (1 << m_maxCodeBits) - blCount[m_maxCodeBits])\n\t\tthrow Err(\"codes incomplete\");\n\n\t// compute a vector of <code, length, value> triples sorted by code\n\tm_codeToValue.resize(nCodes - blCount[0]);\n\tunsigned int j=0;\n\tfor (i=0; i<nCodes; i++) \n\t{\n\t\tunsigned int len = codeBits[i];\n\t\tif (len != 0)\n\t\t{\n\t\t\tcode = NormalizeCode(nextCode[len]++, len);\n\t\t\tm_codeToValue[j].code = code;\n\t\t\tm_codeToValue[j].len = len;\n\t\t\tm_codeToValue[j].value = i;\n\t\t\tj++;\n\t\t}\n\t}\n\tstd::sort(m_codeToValue.begin(), m_codeToValue.end());\n\n\t// initialize the decoding cache\n\tm_cacheBits = STDMIN(9U, m_maxCodeBits);\n\tm_cacheMask = (1 << m_cacheBits) - 1;\n\tm_normalizedCacheMask = NormalizeCode(m_cacheMask, m_cacheBits);\n\tassert(m_normalizedCacheMask == BitReverse(m_cacheMask));\n\n\tif (m_cache.size() != size_t(1) << m_cacheBits)\n\t\tm_cache.resize(1 << m_cacheBits);\n\n\tfor (i=0; i<m_cache.size(); i++)\n\t\tm_cache[i].type = 0;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  void HuffmanDecoder::Initialize(const unsigned int *codeBits, unsigned int nCodes)\n  {\n  \t// the Huffman codes are represented in 3 ways in this code:\n  \t//\n  \t// 1. most significant code bit (i.e. top of code tree) in the least significant bit position\n  \t// 2. most significant code bit (i.e. top of code tree) in the most significant bit position\n  \t// 3. most significant code bit (i.e. top of code tree) in n-th least significant bit position,\n  \t//    where n is the maximum code length for this code tree\n  \t//\n  \t// (1) is the way the codes come in from the deflate stream\n  \t// (2) is used to sort codes so they can be binary searched\n  \t// (3) is used in this function to compute codes from code lengths\n  \t//\n  \t// a code in representation (2) is called \"normalized\" here\n  \t// The BitReverse() function is used to convert between (1) and (2)\n  \t// The NormalizeCode() function is used to convert from (3) to (2)\n  \n  \tif (nCodes == 0)\n  \t\tthrow Err(\"null code\");\n  \n  \tm_maxCodeBits = *std::max_element(codeBits, codeBits+nCodes);\n  \n  \tif (m_maxCodeBits > MAX_CODE_BITS)\n  \t\tthrow Err(\"code length exceeds maximum\");\n  \n  \tif (m_maxCodeBits == 0)\n  \t\tthrow Err(\"null code\");\n  \n  \t// count number of codes of each length\n  \tSecBlockWithHint<unsigned int, 15+1> blCount(m_maxCodeBits+1);\n  \tstd::fill(blCount.begin(), blCount.end(), 0);\n  \tunsigned int i;\n  \tfor (i=0; i<nCodes; i++)\n  \t\tblCount[codeBits[i]]++;\n  \n  \t// compute the starting code of each length\n  \tcode_t code = 0;\n  \tSecBlockWithHint<code_t, 15+1> nextCode(m_maxCodeBits+1);\n  \tnextCode[1] = 0;\n  \tfor (i=2; i<=m_maxCodeBits; i++)\n  \t{\n  \t\t// compute this while checking for overflow: code = (code + blCount[i-1]) << 1\n  \t\tif (code > code + blCount[i-1])\n  \t\t\tthrow Err(\"codes oversubscribed\");\n  \t\tcode += blCount[i-1];\n  \t\tif (code > (code << 1))\n  \t\t\tthrow Err(\"codes oversubscribed\");\n  \t\tcode <<= 1;\n  \t\tnextCode[i] = code;\n  \t}\n  \n  \tif (code > (1 << m_maxCodeBits) - blCount[m_maxCodeBits])\n  \t\tthrow Err(\"codes oversubscribed\");\n  \telse if (m_maxCodeBits != 1 && code < (1 << m_maxCodeBits) - blCount[m_maxCodeBits])\n  \t\tthrow Err(\"codes incomplete\");\n  \n  \t// compute a vector of <code, length, value> triples sorted by code\n  \tm_codeToValue.resize(nCodes - blCount[0]);\n  \tunsigned int j=0;\n  \tfor (i=0; i<nCodes; i++) \n  \t{\n  \t\tunsigned int len = codeBits[i];\n  \t\tif (len != 0)\n  \t\t{\n  \t\t\tcode = NormalizeCode(nextCode[len]++, len);\n  \t\t\tm_codeToValue[j].code = code;\n  \t\t\tm_codeToValue[j].len = len;\n  \t\t\tm_codeToValue[j].value = i;\n  \t\t\tj++;\n  \t\t}\n  \t}\n  \tstd::sort(m_codeToValue.begin(), m_codeToValue.end());\n  \n  \t// initialize the decoding cache\n  \tm_cacheBits = STDMIN(9U, m_maxCodeBits);\n  \tm_cacheMask = (1 << m_cacheBits) - 1;\n  \tm_normalizedCacheMask = NormalizeCode(m_cacheMask, m_cacheBits);\n  \tassert(m_normalizedCacheMask == BitReverse(m_cacheMask));\n  \n  \tif (m_cache.size() != size_t(1) << m_cacheBits)\n  \t\tm_cache.resize(1 << m_cacheBits);\n  \n  \tfor (i=0; i<m_cache.size(); i++)\n  \t\tm_cache[i].type = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::fill",
          "args": [
            "codeLengths + i",
            "codeLengths + i + count",
            "repeater"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_reader.GetBits",
          "args": [
            "7"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "GetBits",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "50-55",
          "snippet": "inline unsigned long LowFirstBitReader::GetBits(unsigned int length)\n{\n\tunsigned long result = PeekBits(length);\n\tSkipBits(length);\n\treturn result;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline unsigned long LowFirstBitReader::GetBits(unsigned int length)\n  {\n  \tunsigned long result = PeekBits(length);\n  \tSkipBits(length);\n  \treturn result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnexpectedEndErr",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "UnexpectedEndErr",
          "container": "Inflator::UnexpectedEndErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "94-94",
          "snippet": "UnexpectedEndErr() : Err(INVALID_DATA_FORMAT, \"Inflator: unexpected end of compressed block\") {}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  UnexpectedEndErr {\n    UnexpectedEndErr() : Err(INVALID_DATA_FORMAT, \"Inflator: unexpected end of compressed block\") {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_reader.FillBuffer",
          "args": [
            "7"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "FillBuffer",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "22-34",
          "snippet": "inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n{\n\twhile (m_bitsBuffered < length)\n\t{\n\t\tbyte b;\n\t\tif (!m_store.Get(b))\n\t\t\treturn false;\n\t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n\t\tm_bitsBuffered += 8;\n\t}\n\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\treturn true;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n  {\n  \twhile (m_bitsBuffered < length)\n  \t{\n  \t\tbyte b;\n  \t\tif (!m_store.Get(b))\n  \t\t\treturn false;\n  \t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n  \t\tm_bitsBuffered += 8;\n  \t}\n  \tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "codeLengthDecoder.Decode",
          "args": [
            "m_reader",
            "k"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "Decode",
          "container": "HuffmanDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "202-210",
          "snippet": "bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n{\n\treader.FillBuffer(m_maxCodeBits);\n\tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n\tif (codeBits > reader.BitsBuffered())\n\t\treturn false;\n\treader.SkipBits(codeBits);\n\treturn true;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n  {\n  \treader.FillBuffer(m_maxCodeBits);\n  \tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n  \tif (codeBits > reader.BitsBuffered())\n  \t\treturn false;\n  \treader.SkipBits(codeBits);\n  \treturn true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::fill",
          "args": [
            "codeLengths.begin()",
            "codeLengths+19",
            "0"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "codeLengths.begin",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_reader.SkipBits",
          "args": [
            "m_reader.BitsBuffered() % 8"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "SkipBits",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "43-48",
          "snippet": "inline void LowFirstBitReader::SkipBits(unsigned int length)\n{\n\tassert(m_bitsBuffered >= length);\n\tm_buffer >>= length;\n\tm_bitsBuffered -= length;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline void LowFirstBitReader::SkipBits(unsigned int length)\n  {\n  \tassert(m_bitsBuffered >= length);\n  \tm_buffer >>= length;\n  \tm_bitsBuffered -= length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_reader.BitsBuffered",
          "args": [],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "BitsBuffered",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "16-16",
          "snippet": "unsigned int BitsBuffered() const {return m_bitsBuffered;}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nLowFirstBitReader {\n  unsigned int BitsBuffered() const {return m_bitsBuffered;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::DecodeHeader()\n  {\n  \tif (!m_reader.FillBuffer(3))\n  \t\tthrow UnexpectedEndErr();\n  \tm_eof = m_reader.GetBits(1) != 0;\n  \tm_blockType = (byte)m_reader.GetBits(2);\n  \tswitch (m_blockType)\n  \t{\n  \tcase 0:\t// stored\n  \t\t{\n  \t\tm_reader.SkipBits(m_reader.BitsBuffered() % 8);\n  \t\tif (!m_reader.FillBuffer(32))\n  \t\t\tthrow UnexpectedEndErr();\n  \t\tm_storedLen = (word16)m_reader.GetBits(16);\n  \t\tword16 nlen = (word16)m_reader.GetBits(16);\n  \t\tif (nlen != (word16)~m_storedLen)\n  \t\t\tthrow BadBlockErr();\n  \t\tbreak;\n  \t\t}\n  \tcase 1:\t// fixed codes\n  \t\tm_nextDecode = LITERAL;\n  \t\tbreak;\n  \tcase 2:\t// dynamic codes\n  \t\t{\n  \t\tif (!m_reader.FillBuffer(5+5+4))\n  \t\t\tthrow UnexpectedEndErr();\n  \t\tunsigned int hlit = m_reader.GetBits(5);\n  \t\tunsigned int hdist = m_reader.GetBits(5);\n  \t\tunsigned int hclen = m_reader.GetBits(4);\n  \n  \t\tFixedSizeSecBlock<unsigned int, 286+32> codeLengths;\n  \t\tunsigned int i;\n  \t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n  \t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n  \t\tstd::fill(codeLengths.begin(), codeLengths+19, 0);\n  \t\tfor (i=0; i<hclen+4; i++)\n  \t\t\tcodeLengths[border[i]] = m_reader.GetBits(3);\n  \n  \t\ttry\n  \t\t{\n  \t\t\tHuffmanDecoder codeLengthDecoder(codeLengths, 19);\n  \t\t\tfor (i = 0; i < hlit+257+hdist+1; )\n  \t\t\t{\n  \t\t\t\tunsigned int k, count, repeater;\n  \t\t\t\tbool result = codeLengthDecoder.Decode(m_reader, k);\n  \t\t\t\tif (!result)\n  \t\t\t\t\tthrow UnexpectedEndErr();\n  \t\t\t\tif (k <= 15)\n  \t\t\t\t{\n  \t\t\t\t\tcount = 1;\n  \t\t\t\t\trepeater = k;\n  \t\t\t\t}\n  \t\t\t\telse switch (k)\n  \t\t\t\t{\n  \t\t\t\tcase 16:\n  \t\t\t\t\tif (!m_reader.FillBuffer(2))\n  \t\t\t\t\t\tthrow UnexpectedEndErr();\n  \t\t\t\t\tcount = 3 + m_reader.GetBits(2);\n  \t\t\t\t\tif (i == 0)\n  \t\t\t\t\t\tthrow BadBlockErr();\n  \t\t\t\t\trepeater = codeLengths[i-1];\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase 17:\n  \t\t\t\t\tif (!m_reader.FillBuffer(3))\n  \t\t\t\t\t\tthrow UnexpectedEndErr();\n  \t\t\t\t\tcount = 3 + m_reader.GetBits(3);\n  \t\t\t\t\trepeater = 0;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase 18:\n  \t\t\t\t\tif (!m_reader.FillBuffer(7))\n  \t\t\t\t\t\tthrow UnexpectedEndErr();\n  \t\t\t\t\tcount = 11 + m_reader.GetBits(7);\n  \t\t\t\t\trepeater = 0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tif (i + count > hlit+257+hdist+1)\n  \t\t\t\t\tthrow BadBlockErr();\n  \t\t\t\tstd::fill(codeLengths + i, codeLengths + i + count, repeater);\n  \t\t\t\ti += count;\n  \t\t\t}\n  \t\t\tm_dynamicLiteralDecoder.Initialize(codeLengths, hlit+257);\n  \t\t\tif (hdist == 0 && codeLengths[hlit+257] == 0)\n  \t\t\t{\n  \t\t\t\tif (hlit != 0)\t// a single zero distance code length means all literals\n  \t\t\t\t\tthrow BadBlockErr();\n  \t\t\t}\n  \t\t\telse\n  \t\t\t\tm_dynamicDistanceDecoder.Initialize(codeLengths+hlit+257, hdist+1);\n  \t\t\tm_nextDecode = LITERAL;\n  \t\t}\n  \t\tcatch (HuffmanDecoder::Err &)\n  \t\t{\n  \t\t\tthrow BadBlockErr();\n  \t\t}\n  \t\tbreak;\n  \t\t}\n  \tdefault:\n  \t\tthrow BadBlockErr();\t// reserved block type\n  \t}\n  \tm_state = DECODING_BODY;\n  }\n}"
  },
  {
    "function_name": "ProcessInput",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "317-360",
    "snippet": "void Inflator::ProcessInput(bool flush)\n{\n\twhile (true)\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase PRE_STREAM:\n\t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPrestreamHeaderSize())\n\t\t\t\treturn;\n\t\t\tProcessPrestreamHeader();\n\t\t\tm_state = WAIT_HEADER;\n\t\t\tm_wrappedAround = false;\n\t\t\tm_current = 0;\n\t\t\tm_lastFlush = 0;\n\t\t\tm_window.New(1 << GetLog2WindowSize());\n\t\t\tbreak;\n\t\tcase WAIT_HEADER:\n\t\t\t{\n\t\t\t// maximum number of bytes before actual compressed data starts\n\t\t\tconst size_t MAX_HEADER_SIZE = BitsToBytes(3+5+5+4+19*7+286*15+19*15);\n\t\t\tif (m_inQueue.CurrentSize() < (flush ? 1 : MAX_HEADER_SIZE))\n\t\t\t\treturn;\n\t\t\tDecodeHeader();\n\t\t\tbreak;\n\t\t\t}\n\t\tcase DECODING_BODY:\n\t\t\tif (!DecodeBody())\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase POST_STREAM:\n\t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPoststreamTailSize())\n\t\t\t\treturn;\n\t\t\tProcessPoststreamTail();\n\t\t\tm_state = m_repeat ? PRE_STREAM : AFTER_END;\n\t\t\tOutput(0, NULL, 0, GetAutoSignalPropagation(), true);\t// TODO: non-blocking\n\t\t\tif (m_inQueue.IsEmpty())\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase AFTER_END:\n\t\t\tm_inQueue.TransferTo(*AttachedTransformation());\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_inQueue.TransferTo",
          "args": [
            "*AttachedTransformation()"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "TransferTo",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "95-101",
          "snippet": "inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n\t{\n\t\tsize_t len = m_tail-m_head;\n\t\ttarget.ChannelPutModifiable(channel, buf+m_head, len);\n\t\tm_head = m_tail;\n\t\treturn len;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t TransferTo(BufferedTransformation &target, const std::string &channel=DEFAULT_CHANNEL)\n  \t{\n  \t\tsize_t len = m_tail-m_head;\n  \t\ttarget.ChannelPutModifiable(channel, buf+m_head, len);\n  \t\tm_head = m_tail;\n  \t\treturn len;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttachedTransformation",
          "args": [],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_inQueue.IsEmpty",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "IsEmpty",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "198-201",
          "snippet": "bool ByteQueue::IsEmpty() const\n{\n\treturn m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  bool ByteQueue::IsEmpty() const\n  {\n  \treturn m_head==m_tail && m_head->CurrentSize()==0 && m_lazyLength==0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Output",
          "args": [
            "0",
            "NULL",
            "0",
            "GetAutoSignalPropagation()",
            "true"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "OutputFlush",
          "container": "Filter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "120-129",
          "snippet": "bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n{\n\tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n\t{\n\t\tm_continueAt = outputSite;\n\t\treturn true;\n\t}\n\tm_continueAt = 0;\n\treturn false;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilter {\n  bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n  {\n  \tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n  \t{\n  \t\tm_continueAt = outputSite;\n  \t\treturn true;\n  \t}\n  \tm_continueAt = 0;\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAutoSignalPropagation",
          "args": [],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "GetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "860-860",
          "snippet": "virtual int GetAutoSignalPropagation() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual int GetAutoSignalPropagation() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessPoststreamTail",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessPoststreamTail",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "117-117",
          "snippet": "virtual void ProcessPoststreamTail() {}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  virtual void ProcessPoststreamTail() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaxPoststreamTailSize",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "MaxPoststreamTailSize",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "116-116",
          "snippet": "virtual unsigned int MaxPoststreamTailSize() const {return 0;}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  virtual unsigned int MaxPoststreamTailSize() const {return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inQueue.CurrentSize",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentSize",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "188-196",
          "snippet": "lword ByteQueue::CurrentSize() const\n{\n\tlword size=0;\n\n\tfor (ByteQueueNode *current=m_head; current; current=current->next)\n\t\tsize += current->CurrentSize();\n\n\treturn size + m_lazyLength;\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  lword ByteQueue::CurrentSize() const\n  {\n  \tlword size=0;\n  \n  \tfor (ByteQueueNode *current=m_head; current; current=current->next)\n  \t\tsize += current->CurrentSize();\n  \n  \treturn size + m_lazyLength;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeBody",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeBody",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "464-572",
          "snippet": "bool Inflator::DecodeBody()\n{\n\tbool blockEnd = false;\n\tswitch (m_blockType)\n\t{\n\tcase 0:\t// stored\n\t\tassert(m_reader.BitsBuffered() == 0);\n\t\twhile (!m_inQueue.IsEmpty() && !blockEnd)\n\t\t{\n\t\t\tsize_t size;\n\t\t\tconst byte *block = m_inQueue.Spy(size);\n\t\t\tsize = UnsignedMin(m_storedLen, size);\n\t\t\tOutputString(block, size);\n\t\t\tm_inQueue.Skip(size);\n\t\t\tm_storedLen -= (word16)size;\n\t\t\tif (m_storedLen == 0)\n\t\t\t\tblockEnd = true;\n\t\t}\n\t\tbreak;\n\tcase 1:\t// fixed codes\n\tcase 2:\t// dynamic codes\n\t\tstatic const unsigned int lengthStarts[] = {\n\t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n\t\tstatic const unsigned int lengthExtraBits[] = {\n\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n\t\tstatic const unsigned int distanceStarts[] = {\n\t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t\t\t8193, 12289, 16385, 24577};\n\t\tstatic const unsigned int distanceExtraBits[] = {\n\t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n\t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n\t\t\t12, 12, 13, 13};\n\n\t\tconst HuffmanDecoder& literalDecoder = GetLiteralDecoder();\n\t\tconst HuffmanDecoder& distanceDecoder = GetDistanceDecoder();\n\n\t\tswitch (m_nextDecode)\n\t\t{\n\t\tcase LITERAL:\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tif (!literalDecoder.Decode(m_reader, m_literal))\n\t\t\t\t{\n\t\t\t\t\tm_nextDecode = LITERAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (m_literal < 256)\n\t\t\t\t\tOutputByte((byte)m_literal);\n\t\t\t\telse if (m_literal == 256)\t// end of block\n\t\t\t\t{\n\t\t\t\t\tblockEnd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (m_literal > 285)\n\t\t\t\t\t\tthrow BadBlockErr();\n\t\t\t\t\tunsigned int bits;\n\t\tcase LENGTH_BITS:\n\t\t\t\t\tbits = lengthExtraBits[m_literal-257];\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = LENGTH_BITS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tm_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];\n\t\tcase DISTANCE:\n\t\t\t\t\tif (!distanceDecoder.Decode(m_reader, m_distance))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = DISTANCE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\tcase DISTANCE_BITS:\n\t\t\t\t\tbits = distanceExtraBits[m_distance];\n\t\t\t\t\tif (!m_reader.FillBuffer(bits))\n\t\t\t\t\t{\n\t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\n\t\t\t\t\tOutputPast(m_literal, m_distance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (blockEnd)\n\t{\n\t\tif (m_eof)\n\t\t{\n\t\t\tFlushOutput();\n\t\t\tm_reader.SkipBits(m_reader.BitsBuffered()%8);\n\t\t\tif (m_reader.BitsBuffered())\n\t\t\t{\n\t\t\t\t// undo too much lookahead\n\t\t\t\tSecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);\n\t\t\t\tfor (unsigned int i=0; i<buffer.size(); i++)\n\t\t\t\t\tbuffer[i] = (byte)m_reader.GetBits(8);\n\t\t\t\tm_inQueue.Unget(buffer, buffer.size());\n\t\t\t}\n\t\t\tm_state = POST_STREAM;\n\t\t}\n\t\telse\n\t\t\tm_state = WAIT_HEADER;\n\t}\n\treturn blockEnd;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  bool Inflator::DecodeBody()\n  {\n  \tbool blockEnd = false;\n  \tswitch (m_blockType)\n  \t{\n  \tcase 0:\t// stored\n  \t\tassert(m_reader.BitsBuffered() == 0);\n  \t\twhile (!m_inQueue.IsEmpty() && !blockEnd)\n  \t\t{\n  \t\t\tsize_t size;\n  \t\t\tconst byte *block = m_inQueue.Spy(size);\n  \t\t\tsize = UnsignedMin(m_storedLen, size);\n  \t\t\tOutputString(block, size);\n  \t\t\tm_inQueue.Skip(size);\n  \t\t\tm_storedLen -= (word16)size;\n  \t\t\tif (m_storedLen == 0)\n  \t\t\t\tblockEnd = true;\n  \t\t}\n  \t\tbreak;\n  \tcase 1:\t// fixed codes\n  \tcase 2:\t// dynamic codes\n  \t\tstatic const unsigned int lengthStarts[] = {\n  \t\t\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  \t\t\t35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258};\n  \t\tstatic const unsigned int lengthExtraBits[] = {\n  \t\t\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n  \t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};\n  \t\tstatic const unsigned int distanceStarts[] = {\n  \t\t\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  \t\t\t257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  \t\t\t8193, 12289, 16385, 24577};\n  \t\tstatic const unsigned int distanceExtraBits[] = {\n  \t\t\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n  \t\t\t7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n  \t\t\t12, 12, 13, 13};\n  \n  \t\tconst HuffmanDecoder& literalDecoder = GetLiteralDecoder();\n  \t\tconst HuffmanDecoder& distanceDecoder = GetDistanceDecoder();\n  \n  \t\tswitch (m_nextDecode)\n  \t\t{\n  \t\tcase LITERAL:\n  \t\t\twhile (true)\n  \t\t\t{\n  \t\t\t\tif (!literalDecoder.Decode(m_reader, m_literal))\n  \t\t\t\t{\n  \t\t\t\t\tm_nextDecode = LITERAL;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tif (m_literal < 256)\n  \t\t\t\t\tOutputByte((byte)m_literal);\n  \t\t\t\telse if (m_literal == 256)\t// end of block\n  \t\t\t\t{\n  \t\t\t\t\tblockEnd = true;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\telse\n  \t\t\t\t{\n  \t\t\t\t\tif (m_literal > 285)\n  \t\t\t\t\t\tthrow BadBlockErr();\n  \t\t\t\t\tunsigned int bits;\n  \t\tcase LENGTH_BITS:\n  \t\t\t\t\tbits = lengthExtraBits[m_literal-257];\n  \t\t\t\t\tif (!m_reader.FillBuffer(bits))\n  \t\t\t\t\t{\n  \t\t\t\t\t\tm_nextDecode = LENGTH_BITS;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t\tm_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257];\n  \t\tcase DISTANCE:\n  \t\t\t\t\tif (!distanceDecoder.Decode(m_reader, m_distance))\n  \t\t\t\t\t{\n  \t\t\t\t\t\tm_nextDecode = DISTANCE;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\tcase DISTANCE_BITS:\n  \t\t\t\t\tbits = distanceExtraBits[m_distance];\n  \t\t\t\t\tif (!m_reader.FillBuffer(bits))\n  \t\t\t\t\t{\n  \t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\n  \t\t\t\t\t\tbreak;\n  \t\t\t\t\t}\n  \t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\n  \t\t\t\t\tOutputPast(m_literal, m_distance);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t}\n  \tif (blockEnd)\n  \t{\n  \t\tif (m_eof)\n  \t\t{\n  \t\t\tFlushOutput();\n  \t\t\tm_reader.SkipBits(m_reader.BitsBuffered()%8);\n  \t\t\tif (m_reader.BitsBuffered())\n  \t\t\t{\n  \t\t\t\t// undo too much lookahead\n  \t\t\t\tSecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8);\n  \t\t\t\tfor (unsigned int i=0; i<buffer.size(); i++)\n  \t\t\t\t\tbuffer[i] = (byte)m_reader.GetBits(8);\n  \t\t\t\tm_inQueue.Unget(buffer, buffer.size());\n  \t\t\t}\n  \t\t\tm_state = POST_STREAM;\n  \t\t}\n  \t\telse\n  \t\t\tm_state = WAIT_HEADER;\n  \t}\n  \treturn blockEnd;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeHeader",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeHeader",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "362-462",
          "snippet": "void Inflator::DecodeHeader()\n{\n\tif (!m_reader.FillBuffer(3))\n\t\tthrow UnexpectedEndErr();\n\tm_eof = m_reader.GetBits(1) != 0;\n\tm_blockType = (byte)m_reader.GetBits(2);\n\tswitch (m_blockType)\n\t{\n\tcase 0:\t// stored\n\t\t{\n\t\tm_reader.SkipBits(m_reader.BitsBuffered() % 8);\n\t\tif (!m_reader.FillBuffer(32))\n\t\t\tthrow UnexpectedEndErr();\n\t\tm_storedLen = (word16)m_reader.GetBits(16);\n\t\tword16 nlen = (word16)m_reader.GetBits(16);\n\t\tif (nlen != (word16)~m_storedLen)\n\t\t\tthrow BadBlockErr();\n\t\tbreak;\n\t\t}\n\tcase 1:\t// fixed codes\n\t\tm_nextDecode = LITERAL;\n\t\tbreak;\n\tcase 2:\t// dynamic codes\n\t\t{\n\t\tif (!m_reader.FillBuffer(5+5+4))\n\t\t\tthrow UnexpectedEndErr();\n\t\tunsigned int hlit = m_reader.GetBits(5);\n\t\tunsigned int hdist = m_reader.GetBits(5);\n\t\tunsigned int hclen = m_reader.GetBits(4);\n\n\t\tFixedSizeSecBlock<unsigned int, 286+32> codeLengths;\n\t\tunsigned int i;\n\t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n\t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n\t\tstd::fill(codeLengths.begin(), codeLengths+19, 0);\n\t\tfor (i=0; i<hclen+4; i++)\n\t\t\tcodeLengths[border[i]] = m_reader.GetBits(3);\n\n\t\ttry\n\t\t{\n\t\t\tHuffmanDecoder codeLengthDecoder(codeLengths, 19);\n\t\t\tfor (i = 0; i < hlit+257+hdist+1; )\n\t\t\t{\n\t\t\t\tunsigned int k, count, repeater;\n\t\t\t\tbool result = codeLengthDecoder.Decode(m_reader, k);\n\t\t\t\tif (!result)\n\t\t\t\t\tthrow UnexpectedEndErr();\n\t\t\t\tif (k <= 15)\n\t\t\t\t{\n\t\t\t\t\tcount = 1;\n\t\t\t\t\trepeater = k;\n\t\t\t\t}\n\t\t\t\telse switch (k)\n\t\t\t\t{\n\t\t\t\tcase 16:\n\t\t\t\t\tif (!m_reader.FillBuffer(2))\n\t\t\t\t\t\tthrow UnexpectedEndErr();\n\t\t\t\t\tcount = 3 + m_reader.GetBits(2);\n\t\t\t\t\tif (i == 0)\n\t\t\t\t\t\tthrow BadBlockErr();\n\t\t\t\t\trepeater = codeLengths[i-1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 17:\n\t\t\t\t\tif (!m_reader.FillBuffer(3))\n\t\t\t\t\t\tthrow UnexpectedEndErr();\n\t\t\t\t\tcount = 3 + m_reader.GetBits(3);\n\t\t\t\t\trepeater = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 18:\n\t\t\t\t\tif (!m_reader.FillBuffer(7))\n\t\t\t\t\t\tthrow UnexpectedEndErr();\n\t\t\t\t\tcount = 11 + m_reader.GetBits(7);\n\t\t\t\t\trepeater = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (i + count > hlit+257+hdist+1)\n\t\t\t\t\tthrow BadBlockErr();\n\t\t\t\tstd::fill(codeLengths + i, codeLengths + i + count, repeater);\n\t\t\t\ti += count;\n\t\t\t}\n\t\t\tm_dynamicLiteralDecoder.Initialize(codeLengths, hlit+257);\n\t\t\tif (hdist == 0 && codeLengths[hlit+257] == 0)\n\t\t\t{\n\t\t\t\tif (hlit != 0)\t// a single zero distance code length means all literals\n\t\t\t\t\tthrow BadBlockErr();\n\t\t\t}\n\t\t\telse\n\t\t\t\tm_dynamicDistanceDecoder.Initialize(codeLengths+hlit+257, hdist+1);\n\t\t\tm_nextDecode = LITERAL;\n\t\t}\n\t\tcatch (HuffmanDecoder::Err &)\n\t\t{\n\t\t\tthrow BadBlockErr();\n\t\t}\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\tthrow BadBlockErr();\t// reserved block type\n\t}\n\tm_state = DECODING_BODY;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::DecodeHeader()\n  {\n  \tif (!m_reader.FillBuffer(3))\n  \t\tthrow UnexpectedEndErr();\n  \tm_eof = m_reader.GetBits(1) != 0;\n  \tm_blockType = (byte)m_reader.GetBits(2);\n  \tswitch (m_blockType)\n  \t{\n  \tcase 0:\t// stored\n  \t\t{\n  \t\tm_reader.SkipBits(m_reader.BitsBuffered() % 8);\n  \t\tif (!m_reader.FillBuffer(32))\n  \t\t\tthrow UnexpectedEndErr();\n  \t\tm_storedLen = (word16)m_reader.GetBits(16);\n  \t\tword16 nlen = (word16)m_reader.GetBits(16);\n  \t\tif (nlen != (word16)~m_storedLen)\n  \t\t\tthrow BadBlockErr();\n  \t\tbreak;\n  \t\t}\n  \tcase 1:\t// fixed codes\n  \t\tm_nextDecode = LITERAL;\n  \t\tbreak;\n  \tcase 2:\t// dynamic codes\n  \t\t{\n  \t\tif (!m_reader.FillBuffer(5+5+4))\n  \t\t\tthrow UnexpectedEndErr();\n  \t\tunsigned int hlit = m_reader.GetBits(5);\n  \t\tunsigned int hdist = m_reader.GetBits(5);\n  \t\tunsigned int hclen = m_reader.GetBits(4);\n  \n  \t\tFixedSizeSecBlock<unsigned int, 286+32> codeLengths;\n  \t\tunsigned int i;\n  \t\tstatic const unsigned int border[] = {    // Order of the bit length code lengths\n  \t\t\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};\n  \t\tstd::fill(codeLengths.begin(), codeLengths+19, 0);\n  \t\tfor (i=0; i<hclen+4; i++)\n  \t\t\tcodeLengths[border[i]] = m_reader.GetBits(3);\n  \n  \t\ttry\n  \t\t{\n  \t\t\tHuffmanDecoder codeLengthDecoder(codeLengths, 19);\n  \t\t\tfor (i = 0; i < hlit+257+hdist+1; )\n  \t\t\t{\n  \t\t\t\tunsigned int k, count, repeater;\n  \t\t\t\tbool result = codeLengthDecoder.Decode(m_reader, k);\n  \t\t\t\tif (!result)\n  \t\t\t\t\tthrow UnexpectedEndErr();\n  \t\t\t\tif (k <= 15)\n  \t\t\t\t{\n  \t\t\t\t\tcount = 1;\n  \t\t\t\t\trepeater = k;\n  \t\t\t\t}\n  \t\t\t\telse switch (k)\n  \t\t\t\t{\n  \t\t\t\tcase 16:\n  \t\t\t\t\tif (!m_reader.FillBuffer(2))\n  \t\t\t\t\t\tthrow UnexpectedEndErr();\n  \t\t\t\t\tcount = 3 + m_reader.GetBits(2);\n  \t\t\t\t\tif (i == 0)\n  \t\t\t\t\t\tthrow BadBlockErr();\n  \t\t\t\t\trepeater = codeLengths[i-1];\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase 17:\n  \t\t\t\t\tif (!m_reader.FillBuffer(3))\n  \t\t\t\t\t\tthrow UnexpectedEndErr();\n  \t\t\t\t\tcount = 3 + m_reader.GetBits(3);\n  \t\t\t\t\trepeater = 0;\n  \t\t\t\t\tbreak;\n  \t\t\t\tcase 18:\n  \t\t\t\t\tif (!m_reader.FillBuffer(7))\n  \t\t\t\t\t\tthrow UnexpectedEndErr();\n  \t\t\t\t\tcount = 11 + m_reader.GetBits(7);\n  \t\t\t\t\trepeater = 0;\n  \t\t\t\t\tbreak;\n  \t\t\t\t}\n  \t\t\t\tif (i + count > hlit+257+hdist+1)\n  \t\t\t\t\tthrow BadBlockErr();\n  \t\t\t\tstd::fill(codeLengths + i, codeLengths + i + count, repeater);\n  \t\t\t\ti += count;\n  \t\t\t}\n  \t\t\tm_dynamicLiteralDecoder.Initialize(codeLengths, hlit+257);\n  \t\t\tif (hdist == 0 && codeLengths[hlit+257] == 0)\n  \t\t\t{\n  \t\t\t\tif (hlit != 0)\t// a single zero distance code length means all literals\n  \t\t\t\t\tthrow BadBlockErr();\n  \t\t\t}\n  \t\t\telse\n  \t\t\t\tm_dynamicDistanceDecoder.Initialize(codeLengths+hlit+257, hdist+1);\n  \t\t\tm_nextDecode = LITERAL;\n  \t\t}\n  \t\tcatch (HuffmanDecoder::Err &)\n  \t\t{\n  \t\t\tthrow BadBlockErr();\n  \t\t}\n  \t\tbreak;\n  \t\t}\n  \tdefault:\n  \t\tthrow BadBlockErr();\t// reserved block type\n  \t}\n  \tm_state = DECODING_BODY;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitsToBytes",
          "args": [
            "3+5+5+4+19*7+286*15+19*15"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "BitsToBytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "307-310",
          "snippet": "inline size_t BitsToBytes(size_t bitCount)\n{\n\treturn ((bitCount+7)/(8));\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline size_t BitsToBytes(size_t bitCount)\n{\n\treturn ((bitCount+7)/(8));\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_window.New",
          "args": [
            "1 << GetLog2WindowSize()"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLog2WindowSize",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "GetLog2WindowSize",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "106-106",
          "snippet": "virtual unsigned int GetLog2WindowSize() const {return 15;}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  virtual unsigned int GetLog2WindowSize() const {return 15;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessPrestreamHeader",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessPrestreamHeader",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "113-113",
          "snippet": "virtual void ProcessPrestreamHeader() {}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  virtual void ProcessPrestreamHeader() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaxPrestreamHeaderSize",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "MaxPrestreamHeaderSize",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "112-112",
          "snippet": "virtual unsigned int MaxPrestreamHeaderSize() const {return 0;}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  virtual unsigned int MaxPrestreamHeaderSize() const {return 0;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::ProcessInput(bool flush)\n  {\n  \twhile (true)\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase PRE_STREAM:\n  \t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPrestreamHeaderSize())\n  \t\t\t\treturn;\n  \t\t\tProcessPrestreamHeader();\n  \t\t\tm_state = WAIT_HEADER;\n  \t\t\tm_wrappedAround = false;\n  \t\t\tm_current = 0;\n  \t\t\tm_lastFlush = 0;\n  \t\t\tm_window.New(1 << GetLog2WindowSize());\n  \t\t\tbreak;\n  \t\tcase WAIT_HEADER:\n  \t\t\t{\n  \t\t\t// maximum number of bytes before actual compressed data starts\n  \t\t\tconst size_t MAX_HEADER_SIZE = BitsToBytes(3+5+5+4+19*7+286*15+19*15);\n  \t\t\tif (m_inQueue.CurrentSize() < (flush ? 1 : MAX_HEADER_SIZE))\n  \t\t\t\treturn;\n  \t\t\tDecodeHeader();\n  \t\t\tbreak;\n  \t\t\t}\n  \t\tcase DECODING_BODY:\n  \t\t\tif (!DecodeBody())\n  \t\t\t\treturn;\n  \t\t\tbreak;\n  \t\tcase POST_STREAM:\n  \t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPoststreamTailSize())\n  \t\t\t\treturn;\n  \t\t\tProcessPoststreamTail();\n  \t\t\tm_state = m_repeat ? PRE_STREAM : AFTER_END;\n  \t\t\tOutput(0, NULL, 0, GetAutoSignalPropagation(), true);\t// TODO: non-blocking\n  \t\t\tif (m_inQueue.IsEmpty())\n  \t\t\t\treturn;\n  \t\t\tbreak;\n  \t\tcase AFTER_END:\n  \t\t\tm_inQueue.TransferTo(*AttachedTransformation());\n  \t\t\treturn;\n  \t\t}\n  \t}\n  }\n}"
  },
  {
    "function_name": "IsolatedFlush",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "305-315",
    "snippet": "bool Inflator::IsolatedFlush(bool hardFlush, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"Inflator\");\n\n\tif (hardFlush)\n\t\tProcessInput(true);\n\tFlushOutput();\n\n\treturn false;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FlushOutput",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "FlushOutput",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "574-582",
          "snippet": "void Inflator::FlushOutput()\n{\n\tif (m_state != PRE_STREAM)\n\t{\n\t\tassert(m_current >= m_lastFlush);\n\t\tProcessDecompressedData(m_window + m_lastFlush, m_current - m_lastFlush);\n\t\tm_lastFlush = m_current;\n\t}\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::FlushOutput()\n  {\n  \tif (m_state != PRE_STREAM)\n  \t{\n  \t\tassert(m_current >= m_lastFlush);\n  \t\tProcessDecompressedData(m_window + m_lastFlush, m_current - m_lastFlush);\n  \t\tm_lastFlush = m_current;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessInput",
          "args": [
            "true"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessInput",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "317-360",
          "snippet": "void Inflator::ProcessInput(bool flush)\n{\n\twhile (true)\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase PRE_STREAM:\n\t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPrestreamHeaderSize())\n\t\t\t\treturn;\n\t\t\tProcessPrestreamHeader();\n\t\t\tm_state = WAIT_HEADER;\n\t\t\tm_wrappedAround = false;\n\t\t\tm_current = 0;\n\t\t\tm_lastFlush = 0;\n\t\t\tm_window.New(1 << GetLog2WindowSize());\n\t\t\tbreak;\n\t\tcase WAIT_HEADER:\n\t\t\t{\n\t\t\t// maximum number of bytes before actual compressed data starts\n\t\t\tconst size_t MAX_HEADER_SIZE = BitsToBytes(3+5+5+4+19*7+286*15+19*15);\n\t\t\tif (m_inQueue.CurrentSize() < (flush ? 1 : MAX_HEADER_SIZE))\n\t\t\t\treturn;\n\t\t\tDecodeHeader();\n\t\t\tbreak;\n\t\t\t}\n\t\tcase DECODING_BODY:\n\t\t\tif (!DecodeBody())\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase POST_STREAM:\n\t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPoststreamTailSize())\n\t\t\t\treturn;\n\t\t\tProcessPoststreamTail();\n\t\t\tm_state = m_repeat ? PRE_STREAM : AFTER_END;\n\t\t\tOutput(0, NULL, 0, GetAutoSignalPropagation(), true);\t// TODO: non-blocking\n\t\t\tif (m_inQueue.IsEmpty())\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase AFTER_END:\n\t\t\tm_inQueue.TransferTo(*AttachedTransformation());\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::ProcessInput(bool flush)\n  {\n  \twhile (true)\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase PRE_STREAM:\n  \t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPrestreamHeaderSize())\n  \t\t\t\treturn;\n  \t\t\tProcessPrestreamHeader();\n  \t\t\tm_state = WAIT_HEADER;\n  \t\t\tm_wrappedAround = false;\n  \t\t\tm_current = 0;\n  \t\t\tm_lastFlush = 0;\n  \t\t\tm_window.New(1 << GetLog2WindowSize());\n  \t\t\tbreak;\n  \t\tcase WAIT_HEADER:\n  \t\t\t{\n  \t\t\t// maximum number of bytes before actual compressed data starts\n  \t\t\tconst size_t MAX_HEADER_SIZE = BitsToBytes(3+5+5+4+19*7+286*15+19*15);\n  \t\t\tif (m_inQueue.CurrentSize() < (flush ? 1 : MAX_HEADER_SIZE))\n  \t\t\t\treturn;\n  \t\t\tDecodeHeader();\n  \t\t\tbreak;\n  \t\t\t}\n  \t\tcase DECODING_BODY:\n  \t\t\tif (!DecodeBody())\n  \t\t\t\treturn;\n  \t\t\tbreak;\n  \t\tcase POST_STREAM:\n  \t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPoststreamTailSize())\n  \t\t\t\treturn;\n  \t\t\tProcessPoststreamTail();\n  \t\t\tm_state = m_repeat ? PRE_STREAM : AFTER_END;\n  \t\t\tOutput(0, NULL, 0, GetAutoSignalPropagation(), true);\t// TODO: non-blocking\n  \t\t\tif (m_inQueue.IsEmpty())\n  \t\t\t\treturn;\n  \t\t\tbreak;\n  \t\tcase AFTER_END:\n  \t\t\tm_inQueue.TransferTo(*AttachedTransformation());\n  \t\t\treturn;\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"Inflator\""
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  bool Inflator::IsolatedFlush(bool hardFlush, bool blocking)\n  {\n  \tif (!blocking)\n  \t\tthrow BlockingInputOnly(\"Inflator\");\n  \n  \tif (hardFlush)\n  \t\tProcessInput(true);\n  \tFlushOutput();\n  \n  \treturn false;\n  }\n}"
  },
  {
    "function_name": "Put2",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "289-303",
    "snippet": "size_t Inflator::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"Inflator\");\n\n\tLazyPutter lp(m_inQueue, inString, length);\n\tProcessInput(messageEnd != 0);\n\n\tif (messageEnd)\n\t\tif (!(m_state == PRE_STREAM || m_state == AFTER_END))\n\t\t\tthrow UnexpectedEndErr();\n\n\tOutput(0, NULL, 0, messageEnd, blocking);\n\treturn 0;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Output",
          "args": [
            "0",
            "NULL",
            "0",
            "messageEnd",
            "blocking"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "OutputFlush",
          "container": "Filter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "120-129",
          "snippet": "bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n{\n\tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n\t{\n\t\tm_continueAt = outputSite;\n\t\treturn true;\n\t}\n\tm_continueAt = 0;\n\treturn false;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilter {\n  bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n  {\n  \tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n  \t{\n  \t\tm_continueAt = outputSite;\n  \t\treturn true;\n  \t}\n  \tm_continueAt = 0;\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnexpectedEndErr",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "UnexpectedEndErr",
          "container": "Inflator::UnexpectedEndErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "94-94",
          "snippet": "UnexpectedEndErr() : Err(INVALID_DATA_FORMAT, \"Inflator: unexpected end of compressed block\") {}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  UnexpectedEndErr {\n    UnexpectedEndErr() : Err(INVALID_DATA_FORMAT, \"Inflator: unexpected end of compressed block\") {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessInput",
          "args": [
            "messageEnd != 0"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessInput",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "317-360",
          "snippet": "void Inflator::ProcessInput(bool flush)\n{\n\twhile (true)\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase PRE_STREAM:\n\t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPrestreamHeaderSize())\n\t\t\t\treturn;\n\t\t\tProcessPrestreamHeader();\n\t\t\tm_state = WAIT_HEADER;\n\t\t\tm_wrappedAround = false;\n\t\t\tm_current = 0;\n\t\t\tm_lastFlush = 0;\n\t\t\tm_window.New(1 << GetLog2WindowSize());\n\t\t\tbreak;\n\t\tcase WAIT_HEADER:\n\t\t\t{\n\t\t\t// maximum number of bytes before actual compressed data starts\n\t\t\tconst size_t MAX_HEADER_SIZE = BitsToBytes(3+5+5+4+19*7+286*15+19*15);\n\t\t\tif (m_inQueue.CurrentSize() < (flush ? 1 : MAX_HEADER_SIZE))\n\t\t\t\treturn;\n\t\t\tDecodeHeader();\n\t\t\tbreak;\n\t\t\t}\n\t\tcase DECODING_BODY:\n\t\t\tif (!DecodeBody())\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase POST_STREAM:\n\t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPoststreamTailSize())\n\t\t\t\treturn;\n\t\t\tProcessPoststreamTail();\n\t\t\tm_state = m_repeat ? PRE_STREAM : AFTER_END;\n\t\t\tOutput(0, NULL, 0, GetAutoSignalPropagation(), true);\t// TODO: non-blocking\n\t\t\tif (m_inQueue.IsEmpty())\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tcase AFTER_END:\n\t\t\tm_inQueue.TransferTo(*AttachedTransformation());\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::ProcessInput(bool flush)\n  {\n  \twhile (true)\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase PRE_STREAM:\n  \t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPrestreamHeaderSize())\n  \t\t\t\treturn;\n  \t\t\tProcessPrestreamHeader();\n  \t\t\tm_state = WAIT_HEADER;\n  \t\t\tm_wrappedAround = false;\n  \t\t\tm_current = 0;\n  \t\t\tm_lastFlush = 0;\n  \t\t\tm_window.New(1 << GetLog2WindowSize());\n  \t\t\tbreak;\n  \t\tcase WAIT_HEADER:\n  \t\t\t{\n  \t\t\t// maximum number of bytes before actual compressed data starts\n  \t\t\tconst size_t MAX_HEADER_SIZE = BitsToBytes(3+5+5+4+19*7+286*15+19*15);\n  \t\t\tif (m_inQueue.CurrentSize() < (flush ? 1 : MAX_HEADER_SIZE))\n  \t\t\t\treturn;\n  \t\t\tDecodeHeader();\n  \t\t\tbreak;\n  \t\t\t}\n  \t\tcase DECODING_BODY:\n  \t\t\tif (!DecodeBody())\n  \t\t\t\treturn;\n  \t\t\tbreak;\n  \t\tcase POST_STREAM:\n  \t\t\tif (!flush && m_inQueue.CurrentSize() < MaxPoststreamTailSize())\n  \t\t\t\treturn;\n  \t\t\tProcessPoststreamTail();\n  \t\t\tm_state = m_repeat ? PRE_STREAM : AFTER_END;\n  \t\t\tOutput(0, NULL, 0, GetAutoSignalPropagation(), true);\t// TODO: non-blocking\n  \t\t\tif (m_inQueue.IsEmpty())\n  \t\t\t\treturn;\n  \t\t\tbreak;\n  \t\tcase AFTER_END:\n  \t\t\tm_inQueue.TransferTo(*AttachedTransformation());\n  \t\t\treturn;\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"Inflator\""
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  size_t Inflator::Put2(const byte *inString, size_t length, int messageEnd, bool blocking)\n  {\n  \tif (!blocking)\n  \t\tthrow BlockingInputOnly(\"Inflator\");\n  \n  \tLazyPutter lp(m_inQueue, inString, length);\n  \tProcessInput(messageEnd != 0);\n  \n  \tif (messageEnd)\n  \t\tif (!(m_state == PRE_STREAM || m_state == AFTER_END))\n  \t\t\tthrow UnexpectedEndErr();\n  \n  \tOutput(0, NULL, 0, messageEnd, blocking);\n  \treturn 0;\n  }\n}"
  },
  {
    "function_name": "OutputPast",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "260-287",
    "snippet": "void Inflator::OutputPast(unsigned int length, unsigned int distance)\n{\n\tsize_t start;\n\tif (distance <= m_current)\n\t\tstart = m_current - distance;\n\telse if (m_wrappedAround && distance <= m_window.size())\n\t\tstart = m_current + m_window.size() - distance;\n\telse\n\t\tthrow BadBlockErr();\n\n\tif (start + length > m_window.size())\n\t{\n\t\tfor (; start < m_window.size(); start++, length--)\n\t\t\tOutputByte(m_window[start]);\n\t\tstart = 0;\n\t}\n\n\tif (start + length > m_current || m_current + length >= m_window.size())\n\t{\n\t\twhile (length--)\n\t\t\tOutputByte(m_window[start++]);\n\t}\n\telse\n\t{\n\t\tmemcpy(m_window + m_current, m_window + start, length);\n\t\tm_current += length;\n\t}\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_window + m_current",
            "m_window + start",
            "length"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputByte",
          "args": [
            "m_window[start++]"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "OutputByte",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "229-239",
          "snippet": "void Inflator::OutputByte(byte b)\n{\n\tm_window[m_current++] = b;\n\tif (m_current == m_window.size())\n\t{\n\t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n\t\tm_lastFlush = 0;\n\t\tm_current = 0;\n\t\tm_wrappedAround = true;\n\t}\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::OutputByte(byte b)\n  {\n  \tm_window[m_current++] = b;\n  \tif (m_current == m_window.size())\n  \t{\n  \t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n  \t\tm_lastFlush = 0;\n  \t\tm_current = 0;\n  \t\tm_wrappedAround = true;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_window.size",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BadBlockErr",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "BadBlockErr",
          "container": "Inflator::BadBlockErr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "95-95",
          "snippet": "BadBlockErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in compressed block\") {}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  BadBlockErr {\n    BadBlockErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in compressed block\") {}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::OutputPast(unsigned int length, unsigned int distance)\n  {\n  \tsize_t start;\n  \tif (distance <= m_current)\n  \t\tstart = m_current - distance;\n  \telse if (m_wrappedAround && distance <= m_window.size())\n  \t\tstart = m_current + m_window.size() - distance;\n  \telse\n  \t\tthrow BadBlockErr();\n  \n  \tif (start + length > m_window.size())\n  \t{\n  \t\tfor (; start < m_window.size(); start++, length--)\n  \t\t\tOutputByte(m_window[start]);\n  \t\tstart = 0;\n  \t}\n  \n  \tif (start + length > m_current || m_current + length >= m_window.size())\n  \t{\n  \t\twhile (length--)\n  \t\t\tOutputByte(m_window[start++]);\n  \t}\n  \telse\n  \t{\n  \t\tmemcpy(m_window + m_current, m_window + start, length);\n  \t\tm_current += length;\n  \t}\n  }\n}"
  },
  {
    "function_name": "OutputString",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "241-258",
    "snippet": "void Inflator::OutputString(const byte *string, size_t length)\n{\n\twhile (length)\n\t{\n\t\tsize_t len = UnsignedMin(length, m_window.size() - m_current);\n\t\tmemcpy(m_window + m_current, string, len);\n\t\tm_current += len;\n\t\tif (m_current == m_window.size())\n\t\t{\n\t\t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n\t\t\tm_lastFlush = 0;\n\t\t\tm_current = 0;\n\t\t\tm_wrappedAround = true;\n\t\t}\n\t\tstring += len;\n\t\tlength -= len;\n\t}\t\t\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessDecompressedData",
          "args": [
            "m_window + m_lastFlush",
            "m_window.size() - m_lastFlush"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessDecompressedData",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "114-115",
          "snippet": "virtual void ProcessDecompressedData(const byte *string, size_t length)\n\t\t{AttachedTransformation()->Put(string, length);}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  virtual void ProcessDecompressedData(const byte *string, size_t length)\n  \t\t{AttachedTransformation()->Put(string, length);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_window.size",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_window + m_current",
            "string",
            "len"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "length",
            "m_window.size() - m_current"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::OutputString(const byte *string, size_t length)\n  {\n  \twhile (length)\n  \t{\n  \t\tsize_t len = UnsignedMin(length, m_window.size() - m_current);\n  \t\tmemcpy(m_window + m_current, string, len);\n  \t\tm_current += len;\n  \t\tif (m_current == m_window.size())\n  \t\t{\n  \t\t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n  \t\t\tm_lastFlush = 0;\n  \t\t\tm_current = 0;\n  \t\t\tm_wrappedAround = true;\n  \t\t}\n  \t\tstring += len;\n  \t\tlength -= len;\n  \t}\t\t\n  }\n}"
  },
  {
    "function_name": "OutputByte",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "229-239",
    "snippet": "void Inflator::OutputByte(byte b)\n{\n\tm_window[m_current++] = b;\n\tif (m_current == m_window.size())\n\t{\n\t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n\t\tm_lastFlush = 0;\n\t\tm_current = 0;\n\t\tm_wrappedAround = true;\n\t}\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessDecompressedData",
          "args": [
            "m_window + m_lastFlush",
            "m_window.size() - m_lastFlush"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessDecompressedData",
          "container": "Inflator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "114-115",
          "snippet": "virtual void ProcessDecompressedData(const byte *string, size_t length)\n\t\t{AttachedTransformation()->Put(string, length);}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nInflator {\n  virtual void ProcessDecompressedData(const byte *string, size_t length)\n  \t\t{AttachedTransformation()->Put(string, length);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_window.size",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::OutputByte(byte b)\n  {\n  \tm_window[m_current++] = b;\n  \tif (m_current == m_window.size())\n  \t{\n  \t\tProcessDecompressedData(m_window + m_lastFlush, m_window.size() - m_lastFlush);\n  \t\tm_lastFlush = 0;\n  \t\tm_current = 0;\n  \t\tm_wrappedAround = true;\n  \t}\n  }\n}"
  },
  {
    "function_name": "IsolatedInitialize",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "221-227",
    "snippet": "void Inflator::IsolatedInitialize(const NameValuePairs &parameters)\n{\n\tm_state = PRE_STREAM;\n\tparameters.GetValue(\"Repeat\", m_repeat);\n\tm_inQueue.Clear();\n\tm_reader.SkipBits(m_reader.BitsBuffered());\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_reader.SkipBits",
          "args": [
            "m_reader.BitsBuffered()"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "SkipBits",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "43-48",
          "snippet": "inline void LowFirstBitReader::SkipBits(unsigned int length)\n{\n\tassert(m_bitsBuffered >= length);\n\tm_buffer >>= length;\n\tm_bitsBuffered -= length;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline void LowFirstBitReader::SkipBits(unsigned int length)\n  {\n  \tassert(m_bitsBuffered >= length);\n  \tm_buffer >>= length;\n  \tm_bitsBuffered -= length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_reader.BitsBuffered",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "BitsBuffered",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "16-16",
          "snippet": "unsigned int BitsBuffered() const {return m_bitsBuffered;}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nLowFirstBitReader {\n  unsigned int BitsBuffered() const {return m_bitsBuffered;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_inQueue.Clear",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "ByteQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "203-215",
          "snippet": "void ByteQueue::Clear()\n{\n\tfor (ByteQueueNode *next, *current=m_head->next; current; current=next)\n\t{\n\t\tnext=current->next;\n\t\tdelete current;\n\t}\n\n\tm_tail = m_head;\n\tm_head->Clear();\n\tm_head->next = NULL;\n\tm_lazyLength = 0;\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  void ByteQueue::Clear()\n  {\n  \tfor (ByteQueueNode *next, *current=m_head->next; current; current=next)\n  \t{\n  \t\tnext=current->next;\n  \t\tdelete current;\n  \t}\n  \n  \tm_tail = m_head;\n  \tm_head->Clear();\n  \tm_head->next = NULL;\n  \tm_lazyLength = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "parameters.GetValue",
          "args": [
            "\"Repeat\"",
            "m_repeat"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  void Inflator::IsolatedInitialize(const NameValuePairs &parameters)\n  {\n  \tm_state = PRE_STREAM;\n  \tparameters.GetValue(\"Repeat\", m_repeat);\n  \tm_inQueue.Clear();\n  \tm_reader.SkipBits(m_reader.BitsBuffered());\n  }\n}"
  },
  {
    "function_name": "Inflator",
    "container": "Inflator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "214-219",
    "snippet": "Inflator::Inflator(BufferedTransformation *attachment, bool repeat, int propagation)\n\t: AutoSignaling<Filter>(propagation)\n\t, m_state(PRE_STREAM), m_repeat(repeat), m_reader(m_inQueue)\n{\n\tDetach(attachment);\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Detach",
          "args": [
            "attachment"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "Detach",
          "container": "Filter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "40-43",
          "snippet": "void Filter::Detach(BufferedTransformation *newOut)\n{\n\tm_attachment.reset(newOut);\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilter {\n  void Filter::Detach(BufferedTransformation *newOut)\n  {\n  \tm_attachment.reset(newOut);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nInflator {\n  Inflator::Inflator(BufferedTransformation *attachment, bool repeat, int propagation)\n  \t: AutoSignaling<Filter>(propagation)\n  \t, m_state(PRE_STREAM), m_repeat(repeat), m_reader(m_inQueue)\n  {\n  \tDetach(attachment);\n  }\n}"
  },
  {
    "function_name": "Decode",
    "container": "HuffmanDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "202-210",
    "snippet": "bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n{\n\treader.FillBuffer(m_maxCodeBits);\n\tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n\tif (codeBits > reader.BitsBuffered())\n\t\treturn false;\n\treader.SkipBits(codeBits);\n\treturn true;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reader.SkipBits",
          "args": [
            "codeBits"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "SkipBits",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "43-48",
          "snippet": "inline void LowFirstBitReader::SkipBits(unsigned int length)\n{\n\tassert(m_bitsBuffered >= length);\n\tm_buffer >>= length;\n\tm_bitsBuffered -= length;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline void LowFirstBitReader::SkipBits(unsigned int length)\n  {\n  \tassert(m_bitsBuffered >= length);\n  \tm_buffer >>= length;\n  \tm_bitsBuffered -= length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.BitsBuffered",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "BitsBuffered",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "16-16",
          "snippet": "unsigned int BitsBuffered() const {return m_bitsBuffered;}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nLowFirstBitReader {\n  unsigned int BitsBuffered() const {return m_bitsBuffered;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Decode",
          "args": [
            "reader.PeekBuffer()",
            "value"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "Decode",
          "container": "HuffmanDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "202-210",
          "snippet": "bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n{\n\treader.FillBuffer(m_maxCodeBits);\n\tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n\tif (codeBits > reader.BitsBuffered())\n\t\treturn false;\n\treader.SkipBits(codeBits);\n\treturn true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "reader.PeekBuffer",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "PeekBuffer",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "17-17",
          "snippet": "unsigned long PeekBuffer() const {return m_buffer;}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nLowFirstBitReader {\n  unsigned long PeekBuffer() const {return m_buffer;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.FillBuffer",
          "args": [
            "m_maxCodeBits"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "FillBuffer",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "22-34",
          "snippet": "inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n{\n\twhile (m_bitsBuffered < length)\n\t{\n\t\tbyte b;\n\t\tif (!m_store.Get(b))\n\t\t\treturn false;\n\t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n\t\tm_bitsBuffered += 8;\n\t}\n\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\treturn true;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n  {\n  \twhile (m_bitsBuffered < length)\n  \t{\n  \t\tbyte b;\n  \t\tif (!m_store.Get(b))\n  \t\t\treturn false;\n  \t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n  \t\tm_bitsBuffered += 8;\n  \t}\n  \tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n  \treturn true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  bool HuffmanDecoder::Decode(LowFirstBitReader &reader, value_t &value) const\n  {\n  \treader.FillBuffer(m_maxCodeBits);\n  \tunsigned int codeBits = Decode(reader.PeekBuffer(), value);\n  \tif (codeBits > reader.BitsBuffered())\n  \t\treturn false;\n  \treader.SkipBits(codeBits);\n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "Decode",
    "container": "HuffmanDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "175-200",
    "snippet": "inline unsigned int HuffmanDecoder::Decode(code_t code, /* out */ value_t &value) const\n{\n\tassert(m_codeToValue.size() > 0);\n\tLookupEntry &entry = m_cache[code & m_cacheMask];\n\n\tcode_t normalizedCode;\n\tif (entry.type != 1)\n\t\tnormalizedCode = BitReverse(code);\n\n\tif (entry.type == 0)\n\t\tFillCacheEntry(entry, normalizedCode);\n\n\tif (entry.type == 1)\n\t{\n\t\tvalue = entry.value;\n\t\treturn entry.len;\n\t}\n\telse\n\t{\n\t\tconst CodeInfo &codeInfo = (entry.type == 2)\n\t\t\t? entry.begin[(normalizedCode << m_cacheBits) >> (MAX_CODE_BITS - (entry.len - m_cacheBits))]\n\t\t\t: *(std::upper_bound(entry.begin, entry.end, normalizedCode, CodeLessThan())-1);\n\t\tvalue = codeInfo.value;\n\t\treturn codeInfo.len;\n\t}\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::upper_bound",
          "args": [
            "entry.begin",
            "entry.end",
            "normalizedCode",
            "CodeLessThan()"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CodeLessThan",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FillCacheEntry",
          "args": [
            "entry",
            "normalizedCode"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "FillCacheEntry",
          "container": "HuffmanDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "148-173",
          "snippet": "void HuffmanDecoder::FillCacheEntry(LookupEntry &entry, code_t normalizedCode) const\n{\n\tnormalizedCode &= m_normalizedCacheMask;\n\tconst CodeInfo &codeInfo = *(std::upper_bound(m_codeToValue.begin(), m_codeToValue.end(), normalizedCode, CodeLessThan())-1);\n\tif (codeInfo.len <= m_cacheBits)\n\t{\n\t\tentry.type = 1;\n\t\tentry.value = codeInfo.value;\n\t\tentry.len = codeInfo.len;\n\t}\n\telse\n\t{\n\t\tentry.begin = &codeInfo;\n\t\tconst CodeInfo *last = & *(std::upper_bound(m_codeToValue.begin(), m_codeToValue.end(), normalizedCode + ~m_normalizedCacheMask, CodeLessThan())-1);\n\t\tif (codeInfo.len == last->len)\n\t\t{\n\t\t\tentry.type = 2;\n\t\t\tentry.len = codeInfo.len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tentry.type = 3;\n\t\t\tentry.end = last+1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  void HuffmanDecoder::FillCacheEntry(LookupEntry &entry, code_t normalizedCode) const\n  {\n  \tnormalizedCode &= m_normalizedCacheMask;\n  \tconst CodeInfo &codeInfo = *(std::upper_bound(m_codeToValue.begin(), m_codeToValue.end(), normalizedCode, CodeLessThan())-1);\n  \tif (codeInfo.len <= m_cacheBits)\n  \t{\n  \t\tentry.type = 1;\n  \t\tentry.value = codeInfo.value;\n  \t\tentry.len = codeInfo.len;\n  \t}\n  \telse\n  \t{\n  \t\tentry.begin = &codeInfo;\n  \t\tconst CodeInfo *last = & *(std::upper_bound(m_codeToValue.begin(), m_codeToValue.end(), normalizedCode + ~m_normalizedCacheMask, CodeLessThan())-1);\n  \t\tif (codeInfo.len == last->len)\n  \t\t{\n  \t\t\tentry.type = 2;\n  \t\t\tentry.len = codeInfo.len;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tentry.type = 3;\n  \t\t\tentry.end = last+1;\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BitReverse",
          "args": [
            "code"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "BitReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "906-919",
          "snippet": "inline T BitReverse(T value)\n{\n\tif (sizeof(T) == 1)\n\t\treturn (T)BitReverse((byte)value);\n\telse if (sizeof(T) == 2)\n\t\treturn (T)BitReverse((word16)value);\n\telse if (sizeof(T) == 4)\n\t\treturn (T)BitReverse((word32)value);\n\telse\n\t{\n\t\tassert(sizeof(T) == 8);\n\t\treturn (T)BitReverse((word64)value);\n\t}\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T BitReverse(T value)\n{\n\tif (sizeof(T) == 1)\n\t\treturn (T)BitReverse((byte)value);\n\telse if (sizeof(T) == 2)\n\t\treturn (T)BitReverse((word16)value);\n\telse if (sizeof(T) == 4)\n\t\treturn (T)BitReverse((word32)value);\n\telse\n\t{\n\t\tassert(sizeof(T) == 8);\n\t\treturn (T)BitReverse((word64)value);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_codeToValue.size() > 0"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codeToValue.size",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  inline unsigned int HuffmanDecoder::Decode(code_t code, /* out */ value_t &value) const\n  {\n  \tassert(m_codeToValue.size() > 0);\n  \tLookupEntry &entry = m_cache[code & m_cacheMask];\n  \n  \tcode_t normalizedCode;\n  \tif (entry.type != 1)\n  \t\tnormalizedCode = BitReverse(code);\n  \n  \tif (entry.type == 0)\n  \t\tFillCacheEntry(entry, normalizedCode);\n  \n  \tif (entry.type == 1)\n  \t{\n  \t\tvalue = entry.value;\n  \t\treturn entry.len;\n  \t}\n  \telse\n  \t{\n  \t\tconst CodeInfo &codeInfo = (entry.type == 2)\n  \t\t\t? entry.begin[(normalizedCode << m_cacheBits) >> (MAX_CODE_BITS - (entry.len - m_cacheBits))]\n  \t\t\t: *(std::upper_bound(entry.begin, entry.end, normalizedCode, CodeLessThan())-1);\n  \t\tvalue = codeInfo.value;\n  \t\treturn codeInfo.len;\n  \t}\n  }\n}"
  },
  {
    "function_name": "FillCacheEntry",
    "container": "HuffmanDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "148-173",
    "snippet": "void HuffmanDecoder::FillCacheEntry(LookupEntry &entry, code_t normalizedCode) const\n{\n\tnormalizedCode &= m_normalizedCacheMask;\n\tconst CodeInfo &codeInfo = *(std::upper_bound(m_codeToValue.begin(), m_codeToValue.end(), normalizedCode, CodeLessThan())-1);\n\tif (codeInfo.len <= m_cacheBits)\n\t{\n\t\tentry.type = 1;\n\t\tentry.value = codeInfo.value;\n\t\tentry.len = codeInfo.len;\n\t}\n\telse\n\t{\n\t\tentry.begin = &codeInfo;\n\t\tconst CodeInfo *last = & *(std::upper_bound(m_codeToValue.begin(), m_codeToValue.end(), normalizedCode + ~m_normalizedCacheMask, CodeLessThan())-1);\n\t\tif (codeInfo.len == last->len)\n\t\t{\n\t\t\tentry.type = 2;\n\t\t\tentry.len = codeInfo.len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tentry.type = 3;\n\t\t\tentry.end = last+1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::upper_bound",
          "args": [
            "m_codeToValue.begin()",
            "m_codeToValue.end()",
            "normalizedCode + ~m_normalizedCacheMask",
            "CodeLessThan()"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CodeLessThan",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codeToValue.end",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_codeToValue.begin",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::upper_bound",
          "args": [
            "m_codeToValue.begin()",
            "m_codeToValue.end()",
            "normalizedCode",
            "CodeLessThan()"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CodeLessThan",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  void HuffmanDecoder::FillCacheEntry(LookupEntry &entry, code_t normalizedCode) const\n  {\n  \tnormalizedCode &= m_normalizedCacheMask;\n  \tconst CodeInfo &codeInfo = *(std::upper_bound(m_codeToValue.begin(), m_codeToValue.end(), normalizedCode, CodeLessThan())-1);\n  \tif (codeInfo.len <= m_cacheBits)\n  \t{\n  \t\tentry.type = 1;\n  \t\tentry.value = codeInfo.value;\n  \t\tentry.len = codeInfo.len;\n  \t}\n  \telse\n  \t{\n  \t\tentry.begin = &codeInfo;\n  \t\tconst CodeInfo *last = & *(std::upper_bound(m_codeToValue.begin(), m_codeToValue.end(), normalizedCode + ~m_normalizedCacheMask, CodeLessThan())-1);\n  \t\tif (codeInfo.len == last->len)\n  \t\t{\n  \t\t\tentry.type = 2;\n  \t\t\tentry.len = codeInfo.len;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tentry.type = 3;\n  \t\t\tentry.end = last+1;\n  \t\t}\n  \t}\n  }\n}"
  },
  {
    "function_name": "Initialize",
    "container": "HuffmanDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "62-146",
    "snippet": "void HuffmanDecoder::Initialize(const unsigned int *codeBits, unsigned int nCodes)\n{\n\t// the Huffman codes are represented in 3 ways in this code:\n\t//\n\t// 1. most significant code bit (i.e. top of code tree) in the least significant bit position\n\t// 2. most significant code bit (i.e. top of code tree) in the most significant bit position\n\t// 3. most significant code bit (i.e. top of code tree) in n-th least significant bit position,\n\t//    where n is the maximum code length for this code tree\n\t//\n\t// (1) is the way the codes come in from the deflate stream\n\t// (2) is used to sort codes so they can be binary searched\n\t// (3) is used in this function to compute codes from code lengths\n\t//\n\t// a code in representation (2) is called \"normalized\" here\n\t// The BitReverse() function is used to convert between (1) and (2)\n\t// The NormalizeCode() function is used to convert from (3) to (2)\n\n\tif (nCodes == 0)\n\t\tthrow Err(\"null code\");\n\n\tm_maxCodeBits = *std::max_element(codeBits, codeBits+nCodes);\n\n\tif (m_maxCodeBits > MAX_CODE_BITS)\n\t\tthrow Err(\"code length exceeds maximum\");\n\n\tif (m_maxCodeBits == 0)\n\t\tthrow Err(\"null code\");\n\n\t// count number of codes of each length\n\tSecBlockWithHint<unsigned int, 15+1> blCount(m_maxCodeBits+1);\n\tstd::fill(blCount.begin(), blCount.end(), 0);\n\tunsigned int i;\n\tfor (i=0; i<nCodes; i++)\n\t\tblCount[codeBits[i]]++;\n\n\t// compute the starting code of each length\n\tcode_t code = 0;\n\tSecBlockWithHint<code_t, 15+1> nextCode(m_maxCodeBits+1);\n\tnextCode[1] = 0;\n\tfor (i=2; i<=m_maxCodeBits; i++)\n\t{\n\t\t// compute this while checking for overflow: code = (code + blCount[i-1]) << 1\n\t\tif (code > code + blCount[i-1])\n\t\t\tthrow Err(\"codes oversubscribed\");\n\t\tcode += blCount[i-1];\n\t\tif (code > (code << 1))\n\t\t\tthrow Err(\"codes oversubscribed\");\n\t\tcode <<= 1;\n\t\tnextCode[i] = code;\n\t}\n\n\tif (code > (1 << m_maxCodeBits) - blCount[m_maxCodeBits])\n\t\tthrow Err(\"codes oversubscribed\");\n\telse if (m_maxCodeBits != 1 && code < (1 << m_maxCodeBits) - blCount[m_maxCodeBits])\n\t\tthrow Err(\"codes incomplete\");\n\n\t// compute a vector of <code, length, value> triples sorted by code\n\tm_codeToValue.resize(nCodes - blCount[0]);\n\tunsigned int j=0;\n\tfor (i=0; i<nCodes; i++) \n\t{\n\t\tunsigned int len = codeBits[i];\n\t\tif (len != 0)\n\t\t{\n\t\t\tcode = NormalizeCode(nextCode[len]++, len);\n\t\t\tm_codeToValue[j].code = code;\n\t\t\tm_codeToValue[j].len = len;\n\t\t\tm_codeToValue[j].value = i;\n\t\t\tj++;\n\t\t}\n\t}\n\tstd::sort(m_codeToValue.begin(), m_codeToValue.end());\n\n\t// initialize the decoding cache\n\tm_cacheBits = STDMIN(9U, m_maxCodeBits);\n\tm_cacheMask = (1 << m_cacheBits) - 1;\n\tm_normalizedCacheMask = NormalizeCode(m_cacheMask, m_cacheBits);\n\tassert(m_normalizedCacheMask == BitReverse(m_cacheMask));\n\n\tif (m_cache.size() != size_t(1) << m_cacheBits)\n\t\tm_cache.resize(1 << m_cacheBits);\n\n\tfor (i=0; i<m_cache.size(); i++)\n\t\tm_cache[i].type = 0;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_cache.size",
          "args": [],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cache.resize",
          "args": [
            "1 << m_cacheBits"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "size_t",
          "args": [
            "1"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_normalizedCacheMask == BitReverse(m_cacheMask)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BitReverse",
          "args": [
            "m_cacheMask"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "BitReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "906-919",
          "snippet": "inline T BitReverse(T value)\n{\n\tif (sizeof(T) == 1)\n\t\treturn (T)BitReverse((byte)value);\n\telse if (sizeof(T) == 2)\n\t\treturn (T)BitReverse((word16)value);\n\telse if (sizeof(T) == 4)\n\t\treturn (T)BitReverse((word32)value);\n\telse\n\t{\n\t\tassert(sizeof(T) == 8);\n\t\treturn (T)BitReverse((word64)value);\n\t}\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T BitReverse(T value)\n{\n\tif (sizeof(T) == 1)\n\t\treturn (T)BitReverse((byte)value);\n\telse if (sizeof(T) == 2)\n\t\treturn (T)BitReverse((word16)value);\n\telse if (sizeof(T) == 4)\n\t\treturn (T)BitReverse((word32)value);\n\telse\n\t{\n\t\tassert(sizeof(T) == 8);\n\t\treturn (T)BitReverse((word64)value);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NormalizeCode",
          "args": [
            "m_cacheMask",
            "m_cacheBits"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "NormalizeCode",
          "container": "HuffmanDecoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "57-60",
          "snippet": "inline HuffmanDecoder::code_t HuffmanDecoder::NormalizeCode(HuffmanDecoder::code_t code, unsigned int codeBits)\n{\n\treturn code << (MAX_CODE_BITS - codeBits);\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  inline HuffmanDecoder::code_t HuffmanDecoder::NormalizeCode(HuffmanDecoder::code_t code, unsigned int codeBits)\n  {\n  \treturn code << (MAX_CODE_BITS - codeBits);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "9U",
            "m_maxCodeBits"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "m_codeToValue.begin()",
            "m_codeToValue.end()"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_codeToValue.end",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_codeToValue.begin",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "\"codes incomplete\""
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "Err",
          "container": "HuffmanDecoder::Err",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.h",
          "lines": "39-39",
          "snippet": "Err(const std::string &what) : Exception(INVALID_DATA_FORMAT, \"HuffmanDecoder: \" + what) {}",
          "includes": [
            "#include <vector>",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"filters.h\"\n\nHuffmanDecoder {\n  Err {\n    Err(const std::string &what) : Exception(INVALID_DATA_FORMAT, \"HuffmanDecoder: \" + what) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::fill",
          "args": [
            "blCount.begin()",
            "blCount.end()",
            "0"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::max_element",
          "args": [
            "codeBits",
            "codeBits+nCodes"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  void HuffmanDecoder::Initialize(const unsigned int *codeBits, unsigned int nCodes)\n  {\n  \t// the Huffman codes are represented in 3 ways in this code:\n  \t//\n  \t// 1. most significant code bit (i.e. top of code tree) in the least significant bit position\n  \t// 2. most significant code bit (i.e. top of code tree) in the most significant bit position\n  \t// 3. most significant code bit (i.e. top of code tree) in n-th least significant bit position,\n  \t//    where n is the maximum code length for this code tree\n  \t//\n  \t// (1) is the way the codes come in from the deflate stream\n  \t// (2) is used to sort codes so they can be binary searched\n  \t// (3) is used in this function to compute codes from code lengths\n  \t//\n  \t// a code in representation (2) is called \"normalized\" here\n  \t// The BitReverse() function is used to convert between (1) and (2)\n  \t// The NormalizeCode() function is used to convert from (3) to (2)\n  \n  \tif (nCodes == 0)\n  \t\tthrow Err(\"null code\");\n  \n  \tm_maxCodeBits = *std::max_element(codeBits, codeBits+nCodes);\n  \n  \tif (m_maxCodeBits > MAX_CODE_BITS)\n  \t\tthrow Err(\"code length exceeds maximum\");\n  \n  \tif (m_maxCodeBits == 0)\n  \t\tthrow Err(\"null code\");\n  \n  \t// count number of codes of each length\n  \tSecBlockWithHint<unsigned int, 15+1> blCount(m_maxCodeBits+1);\n  \tstd::fill(blCount.begin(), blCount.end(), 0);\n  \tunsigned int i;\n  \tfor (i=0; i<nCodes; i++)\n  \t\tblCount[codeBits[i]]++;\n  \n  \t// compute the starting code of each length\n  \tcode_t code = 0;\n  \tSecBlockWithHint<code_t, 15+1> nextCode(m_maxCodeBits+1);\n  \tnextCode[1] = 0;\n  \tfor (i=2; i<=m_maxCodeBits; i++)\n  \t{\n  \t\t// compute this while checking for overflow: code = (code + blCount[i-1]) << 1\n  \t\tif (code > code + blCount[i-1])\n  \t\t\tthrow Err(\"codes oversubscribed\");\n  \t\tcode += blCount[i-1];\n  \t\tif (code > (code << 1))\n  \t\t\tthrow Err(\"codes oversubscribed\");\n  \t\tcode <<= 1;\n  \t\tnextCode[i] = code;\n  \t}\n  \n  \tif (code > (1 << m_maxCodeBits) - blCount[m_maxCodeBits])\n  \t\tthrow Err(\"codes oversubscribed\");\n  \telse if (m_maxCodeBits != 1 && code < (1 << m_maxCodeBits) - blCount[m_maxCodeBits])\n  \t\tthrow Err(\"codes incomplete\");\n  \n  \t// compute a vector of <code, length, value> triples sorted by code\n  \tm_codeToValue.resize(nCodes - blCount[0]);\n  \tunsigned int j=0;\n  \tfor (i=0; i<nCodes; i++) \n  \t{\n  \t\tunsigned int len = codeBits[i];\n  \t\tif (len != 0)\n  \t\t{\n  \t\t\tcode = NormalizeCode(nextCode[len]++, len);\n  \t\t\tm_codeToValue[j].code = code;\n  \t\t\tm_codeToValue[j].len = len;\n  \t\t\tm_codeToValue[j].value = i;\n  \t\t\tj++;\n  \t\t}\n  \t}\n  \tstd::sort(m_codeToValue.begin(), m_codeToValue.end());\n  \n  \t// initialize the decoding cache\n  \tm_cacheBits = STDMIN(9U, m_maxCodeBits);\n  \tm_cacheMask = (1 << m_cacheBits) - 1;\n  \tm_normalizedCacheMask = NormalizeCode(m_cacheMask, m_cacheBits);\n  \tassert(m_normalizedCacheMask == BitReverse(m_cacheMask));\n  \n  \tif (m_cache.size() != size_t(1) << m_cacheBits)\n  \t\tm_cache.resize(1 << m_cacheBits);\n  \n  \tfor (i=0; i<m_cache.size(); i++)\n  \t\tm_cache[i].type = 0;\n  }\n}"
  },
  {
    "function_name": "NormalizeCode",
    "container": "HuffmanDecoder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "57-60",
    "snippet": "inline HuffmanDecoder::code_t HuffmanDecoder::NormalizeCode(HuffmanDecoder::code_t code, unsigned int codeBits)\n{\n\treturn code << (MAX_CODE_BITS - codeBits);\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nHuffmanDecoder {\n  inline HuffmanDecoder::code_t HuffmanDecoder::NormalizeCode(HuffmanDecoder::code_t code, unsigned int codeBits)\n  {\n  \treturn code << (MAX_CODE_BITS - codeBits);\n  }\n}"
  },
  {
    "function_name": "GetBits",
    "container": "LowFirstBitReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "50-55",
    "snippet": "inline unsigned long LowFirstBitReader::GetBits(unsigned int length)\n{\n\tunsigned long result = PeekBits(length);\n\tSkipBits(length);\n\treturn result;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SkipBits",
          "args": [
            "length"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "SkipBits",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "43-48",
          "snippet": "inline void LowFirstBitReader::SkipBits(unsigned int length)\n{\n\tassert(m_bitsBuffered >= length);\n\tm_buffer >>= length;\n\tm_bitsBuffered -= length;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline void LowFirstBitReader::SkipBits(unsigned int length)\n  {\n  \tassert(m_bitsBuffered >= length);\n  \tm_buffer >>= length;\n  \tm_bitsBuffered -= length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PeekBits",
          "args": [
            "length"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "PeekBits",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "36-41",
          "snippet": "inline unsigned long LowFirstBitReader::PeekBits(unsigned int length)\n{\n\tbool result = FillBuffer(length);\n\tassert(result);\n\treturn m_buffer & (((unsigned long)1 << length) - 1);\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline unsigned long LowFirstBitReader::PeekBits(unsigned int length)\n  {\n  \tbool result = FillBuffer(length);\n  \tassert(result);\n  \treturn m_buffer & (((unsigned long)1 << length) - 1);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline unsigned long LowFirstBitReader::GetBits(unsigned int length)\n  {\n  \tunsigned long result = PeekBits(length);\n  \tSkipBits(length);\n  \treturn result;\n  }\n}"
  },
  {
    "function_name": "SkipBits",
    "container": "LowFirstBitReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "43-48",
    "snippet": "inline void LowFirstBitReader::SkipBits(unsigned int length)\n{\n\tassert(m_bitsBuffered >= length);\n\tm_buffer >>= length;\n\tm_bitsBuffered -= length;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_bitsBuffered >= length"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline void LowFirstBitReader::SkipBits(unsigned int length)\n  {\n  \tassert(m_bitsBuffered >= length);\n  \tm_buffer >>= length;\n  \tm_bitsBuffered -= length;\n  }\n}"
  },
  {
    "function_name": "PeekBits",
    "container": "LowFirstBitReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "36-41",
    "snippet": "inline unsigned long LowFirstBitReader::PeekBits(unsigned int length)\n{\n\tbool result = FillBuffer(length);\n\tassert(result);\n\treturn m_buffer & (((unsigned long)1 << length) - 1);\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "result"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FillBuffer",
          "args": [
            "length"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "FillBuffer",
          "container": "LowFirstBitReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
          "lines": "22-34",
          "snippet": "inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n{\n\twhile (m_bitsBuffered < length)\n\t{\n\t\tbyte b;\n\t\tif (!m_store.Get(b))\n\t\t\treturn false;\n\t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n\t\tm_bitsBuffered += 8;\n\t}\n\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\treturn true;\n}",
          "includes": [
            "#include \"zinflate.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n  {\n  \twhile (m_bitsBuffered < length)\n  \t{\n  \t\tbyte b;\n  \t\tif (!m_store.Get(b))\n  \t\t\treturn false;\n  \t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n  \t\tm_bitsBuffered += 8;\n  \t}\n  \tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n  \treturn true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline unsigned long LowFirstBitReader::PeekBits(unsigned int length)\n  {\n  \tbool result = FillBuffer(length);\n  \tassert(result);\n  \treturn m_buffer & (((unsigned long)1 << length) - 1);\n  }\n}"
  },
  {
    "function_name": "FillBuffer",
    "container": "LowFirstBitReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/zinflate.cpp",
    "lines": "22-34",
    "snippet": "inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n{\n\twhile (m_bitsBuffered < length)\n\t{\n\t\tbyte b;\n\t\tif (!m_store.Get(b))\n\t\t\treturn false;\n\t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n\t\tm_bitsBuffered += 8;\n\t}\n\tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n\treturn true;\n}",
    "includes": [
      "#include \"zinflate.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_bitsBuffered <= sizeof(unsigned long)*8"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_store.Get",
          "args": [
            "b"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"zinflate.h\"\n#include \"pch.h\"\n\nLowFirstBitReader {\n  inline bool LowFirstBitReader::FillBuffer(unsigned int length)\n  {\n  \twhile (m_bitsBuffered < length)\n  \t{\n  \t\tbyte b;\n  \t\tif (!m_store.Get(b))\n  \t\t\treturn false;\n  \t\tm_buffer |= (unsigned long)b << m_bitsBuffered;\n  \t\tm_bitsBuffered += 8;\n  \t}\n  \tassert(m_bitsBuffered <= sizeof(unsigned long)*8);\n  \treturn true;\n  }\n}"
  }
]