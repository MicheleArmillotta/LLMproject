[
  {
    "function_name": "ProcessAndXorBlock",
    "container": "SHARK::Dec",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
    "lines": "131-134",
    "snippet": "void SHARK::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tSharkProcessAndXorBlock<sbox, cbox>(m_roundKeys, m_rounds, inBlock, xorBlock, outBlock);\n}",
    "includes": [
      "#include \"gf256.h\"",
      "#include \"modes.h\"",
      "#include \"misc.h\"",
      "#include \"shark.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SharkProcessAndXorBlock<sbox, cbox>",
          "args": [
            "m_roundKeys",
            "m_rounds",
            "inBlock",
            "xorBlock",
            "outBlock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "SharkProcessAndXorBlock",
          "container": "SharkProcessAndXorBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
          "lines": "93-124",
          "snippet": "inline SharkProcessAndXorBlock(const word64 *roundKeys, unsigned int rounds, const byte *inBlock, const byte *xorBlock, byte *outBlock)\n{\n\tword64 tmp = *(word64 *)inBlock ^ roundKeys[0];\n\n\tByteOrder order = GetNativeByteOrder();\n\ttmp = cbox[0][GetByte(order, tmp, 0)] ^ cbox[1][GetByte(order, tmp, 1)] \n\t\t^ cbox[2][GetByte(order, tmp, 2)] ^ cbox[3][GetByte(order, tmp, 3)] \n\t\t^ cbox[4][GetByte(order, tmp, 4)] ^ cbox[5][GetByte(order, tmp, 5)] \n\t\t^ cbox[6][GetByte(order, tmp, 6)] ^ cbox[7][GetByte(order, tmp, 7)]\n\t\t^ roundKeys[1];\n\n\tfor(unsigned int i=2; i<rounds; i++) \n\t{\n\t\ttmp = cbox[0][GETBYTE(tmp, 7)] ^ cbox[1][GETBYTE(tmp, 6)] \n\t\t\t^ cbox[2][GETBYTE(tmp, 5)] ^ cbox[3][GETBYTE(tmp, 4)] \n\t\t\t^ cbox[4][GETBYTE(tmp, 3)] ^ cbox[5][GETBYTE(tmp, 2)] \n\t\t\t^ cbox[6][GETBYTE(tmp, 1)] ^ cbox[7][GETBYTE(tmp, 0)]\n\t\t\t^ roundKeys[i];\n\t}\n\n\tPutBlock<byte, BigEndian>(xorBlock, outBlock)\n\t\t(sbox[GETBYTE(tmp, 7)])\n\t\t(sbox[GETBYTE(tmp, 6)])\n\t\t(sbox[GETBYTE(tmp, 5)])\n\t\t(sbox[GETBYTE(tmp, 4)])\n\t\t(sbox[GETBYTE(tmp, 3)])\n\t\t(sbox[GETBYTE(tmp, 2)])\n\t\t(sbox[GETBYTE(tmp, 1)])\n\t\t(sbox[GETBYTE(tmp, 0)]);\n\n\t*(word64 *)outBlock ^= roundKeys[rounds];\n}",
          "includes": [
            "#include \"gf256.h\"",
            "#include \"modes.h\"",
            "#include \"misc.h\"",
            "#include \"shark.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nSharkProcessAndXorBlock {\n  inline SharkProcessAndXorBlock(const word64 *roundKeys, unsigned int rounds, const byte *inBlock, const byte *xorBlock, byte *outBlock)\n  {\n  \tword64 tmp = *(word64 *)inBlock ^ roundKeys[0];\n  \n  \tByteOrder order = GetNativeByteOrder();\n  \ttmp = cbox[0][GetByte(order, tmp, 0)] ^ cbox[1][GetByte(order, tmp, 1)] \n  \t\t^ cbox[2][GetByte(order, tmp, 2)] ^ cbox[3][GetByte(order, tmp, 3)] \n  \t\t^ cbox[4][GetByte(order, tmp, 4)] ^ cbox[5][GetByte(order, tmp, 5)] \n  \t\t^ cbox[6][GetByte(order, tmp, 6)] ^ cbox[7][GetByte(order, tmp, 7)]\n  \t\t^ roundKeys[1];\n  \n  \tfor(unsigned int i=2; i<rounds; i++) \n  \t{\n  \t\ttmp = cbox[0][GETBYTE(tmp, 7)] ^ cbox[1][GETBYTE(tmp, 6)] \n  \t\t\t^ cbox[2][GETBYTE(tmp, 5)] ^ cbox[3][GETBYTE(tmp, 4)] \n  \t\t\t^ cbox[4][GETBYTE(tmp, 3)] ^ cbox[5][GETBYTE(tmp, 2)] \n  \t\t\t^ cbox[6][GETBYTE(tmp, 1)] ^ cbox[7][GETBYTE(tmp, 0)]\n  \t\t\t^ roundKeys[i];\n  \t}\n  \n  \tPutBlock<byte, BigEndian>(xorBlock, outBlock)\n  \t\t(sbox[GETBYTE(tmp, 7)])\n  \t\t(sbox[GETBYTE(tmp, 6)])\n  \t\t(sbox[GETBYTE(tmp, 5)])\n  \t\t(sbox[GETBYTE(tmp, 4)])\n  \t\t(sbox[GETBYTE(tmp, 3)])\n  \t\t(sbox[GETBYTE(tmp, 2)])\n  \t\t(sbox[GETBYTE(tmp, 1)])\n  \t\t(sbox[GETBYTE(tmp, 0)]);\n  \n  \t*(word64 *)outBlock ^= roundKeys[rounds];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nSHARK {\n  Dec {\n    void SHARK::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tSharkProcessAndXorBlock<sbox, cbox>(m_roundKeys, m_rounds, inBlock, xorBlock, outBlock);\n    }\n  }\n}"
  },
  {
    "function_name": "ProcessAndXorBlock",
    "container": "SHARK::Enc",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
    "lines": "126-129",
    "snippet": "void SHARK::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tSharkProcessAndXorBlock<sbox, cbox>(m_roundKeys, m_rounds, inBlock, xorBlock, outBlock);\n}",
    "includes": [
      "#include \"gf256.h\"",
      "#include \"modes.h\"",
      "#include \"misc.h\"",
      "#include \"shark.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SharkProcessAndXorBlock<sbox, cbox>",
          "args": [
            "m_roundKeys",
            "m_rounds",
            "inBlock",
            "xorBlock",
            "outBlock"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "SharkProcessAndXorBlock",
          "container": "SharkProcessAndXorBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
          "lines": "93-124",
          "snippet": "inline SharkProcessAndXorBlock(const word64 *roundKeys, unsigned int rounds, const byte *inBlock, const byte *xorBlock, byte *outBlock)\n{\n\tword64 tmp = *(word64 *)inBlock ^ roundKeys[0];\n\n\tByteOrder order = GetNativeByteOrder();\n\ttmp = cbox[0][GetByte(order, tmp, 0)] ^ cbox[1][GetByte(order, tmp, 1)] \n\t\t^ cbox[2][GetByte(order, tmp, 2)] ^ cbox[3][GetByte(order, tmp, 3)] \n\t\t^ cbox[4][GetByte(order, tmp, 4)] ^ cbox[5][GetByte(order, tmp, 5)] \n\t\t^ cbox[6][GetByte(order, tmp, 6)] ^ cbox[7][GetByte(order, tmp, 7)]\n\t\t^ roundKeys[1];\n\n\tfor(unsigned int i=2; i<rounds; i++) \n\t{\n\t\ttmp = cbox[0][GETBYTE(tmp, 7)] ^ cbox[1][GETBYTE(tmp, 6)] \n\t\t\t^ cbox[2][GETBYTE(tmp, 5)] ^ cbox[3][GETBYTE(tmp, 4)] \n\t\t\t^ cbox[4][GETBYTE(tmp, 3)] ^ cbox[5][GETBYTE(tmp, 2)] \n\t\t\t^ cbox[6][GETBYTE(tmp, 1)] ^ cbox[7][GETBYTE(tmp, 0)]\n\t\t\t^ roundKeys[i];\n\t}\n\n\tPutBlock<byte, BigEndian>(xorBlock, outBlock)\n\t\t(sbox[GETBYTE(tmp, 7)])\n\t\t(sbox[GETBYTE(tmp, 6)])\n\t\t(sbox[GETBYTE(tmp, 5)])\n\t\t(sbox[GETBYTE(tmp, 4)])\n\t\t(sbox[GETBYTE(tmp, 3)])\n\t\t(sbox[GETBYTE(tmp, 2)])\n\t\t(sbox[GETBYTE(tmp, 1)])\n\t\t(sbox[GETBYTE(tmp, 0)]);\n\n\t*(word64 *)outBlock ^= roundKeys[rounds];\n}",
          "includes": [
            "#include \"gf256.h\"",
            "#include \"modes.h\"",
            "#include \"misc.h\"",
            "#include \"shark.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nSharkProcessAndXorBlock {\n  inline SharkProcessAndXorBlock(const word64 *roundKeys, unsigned int rounds, const byte *inBlock, const byte *xorBlock, byte *outBlock)\n  {\n  \tword64 tmp = *(word64 *)inBlock ^ roundKeys[0];\n  \n  \tByteOrder order = GetNativeByteOrder();\n  \ttmp = cbox[0][GetByte(order, tmp, 0)] ^ cbox[1][GetByte(order, tmp, 1)] \n  \t\t^ cbox[2][GetByte(order, tmp, 2)] ^ cbox[3][GetByte(order, tmp, 3)] \n  \t\t^ cbox[4][GetByte(order, tmp, 4)] ^ cbox[5][GetByte(order, tmp, 5)] \n  \t\t^ cbox[6][GetByte(order, tmp, 6)] ^ cbox[7][GetByte(order, tmp, 7)]\n  \t\t^ roundKeys[1];\n  \n  \tfor(unsigned int i=2; i<rounds; i++) \n  \t{\n  \t\ttmp = cbox[0][GETBYTE(tmp, 7)] ^ cbox[1][GETBYTE(tmp, 6)] \n  \t\t\t^ cbox[2][GETBYTE(tmp, 5)] ^ cbox[3][GETBYTE(tmp, 4)] \n  \t\t\t^ cbox[4][GETBYTE(tmp, 3)] ^ cbox[5][GETBYTE(tmp, 2)] \n  \t\t\t^ cbox[6][GETBYTE(tmp, 1)] ^ cbox[7][GETBYTE(tmp, 0)]\n  \t\t\t^ roundKeys[i];\n  \t}\n  \n  \tPutBlock<byte, BigEndian>(xorBlock, outBlock)\n  \t\t(sbox[GETBYTE(tmp, 7)])\n  \t\t(sbox[GETBYTE(tmp, 6)])\n  \t\t(sbox[GETBYTE(tmp, 5)])\n  \t\t(sbox[GETBYTE(tmp, 4)])\n  \t\t(sbox[GETBYTE(tmp, 3)])\n  \t\t(sbox[GETBYTE(tmp, 2)])\n  \t\t(sbox[GETBYTE(tmp, 1)])\n  \t\t(sbox[GETBYTE(tmp, 0)]);\n  \n  \t*(word64 *)outBlock ^= roundKeys[rounds];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nSHARK {\n  Enc {\n    void SHARK::Enc::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tSharkProcessAndXorBlock<sbox, cbox>(m_roundKeys, m_rounds, inBlock, xorBlock, outBlock);\n    }\n  }\n}"
  },
  {
    "function_name": "SharkProcessAndXorBlock",
    "container": "SharkProcessAndXorBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
    "lines": "93-124",
    "snippet": "inline SharkProcessAndXorBlock(const word64 *roundKeys, unsigned int rounds, const byte *inBlock, const byte *xorBlock, byte *outBlock)\n{\n\tword64 tmp = *(word64 *)inBlock ^ roundKeys[0];\n\n\tByteOrder order = GetNativeByteOrder();\n\ttmp = cbox[0][GetByte(order, tmp, 0)] ^ cbox[1][GetByte(order, tmp, 1)] \n\t\t^ cbox[2][GetByte(order, tmp, 2)] ^ cbox[3][GetByte(order, tmp, 3)] \n\t\t^ cbox[4][GetByte(order, tmp, 4)] ^ cbox[5][GetByte(order, tmp, 5)] \n\t\t^ cbox[6][GetByte(order, tmp, 6)] ^ cbox[7][GetByte(order, tmp, 7)]\n\t\t^ roundKeys[1];\n\n\tfor(unsigned int i=2; i<rounds; i++) \n\t{\n\t\ttmp = cbox[0][GETBYTE(tmp, 7)] ^ cbox[1][GETBYTE(tmp, 6)] \n\t\t\t^ cbox[2][GETBYTE(tmp, 5)] ^ cbox[3][GETBYTE(tmp, 4)] \n\t\t\t^ cbox[4][GETBYTE(tmp, 3)] ^ cbox[5][GETBYTE(tmp, 2)] \n\t\t\t^ cbox[6][GETBYTE(tmp, 1)] ^ cbox[7][GETBYTE(tmp, 0)]\n\t\t\t^ roundKeys[i];\n\t}\n\n\tPutBlock<byte, BigEndian>(xorBlock, outBlock)\n\t\t(sbox[GETBYTE(tmp, 7)])\n\t\t(sbox[GETBYTE(tmp, 6)])\n\t\t(sbox[GETBYTE(tmp, 5)])\n\t\t(sbox[GETBYTE(tmp, 4)])\n\t\t(sbox[GETBYTE(tmp, 3)])\n\t\t(sbox[GETBYTE(tmp, 2)])\n\t\t(sbox[GETBYTE(tmp, 1)])\n\t\t(sbox[GETBYTE(tmp, 0)]);\n\n\t*(word64 *)outBlock ^= roundKeys[rounds];\n}",
    "includes": [
      "#include \"gf256.h\"",
      "#include \"modes.h\"",
      "#include \"misc.h\"",
      "#include \"shark.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "sbox[GETBYTE(tmp, 0)]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "sbox[GETBYTE(tmp, 1)]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "1"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "sbox[GETBYTE(tmp, 2)]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "2"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "sbox[GETBYTE(tmp, 3)]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "3"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "sbox[GETBYTE(tmp, 4)]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "4"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "sbox[GETBYTE(tmp, 5)]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "5"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "sbox[GETBYTE(tmp, 6)]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "6"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "sbox[GETBYTE(tmp, 7)]"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "7"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutBlock<byte, BigEndian>",
          "args": [
            "xorBlock",
            "outBlock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "PutBlock",
          "container": "PutBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1179-1180",
          "snippet": "PutBlock(const void *xorBlock, void *block)\n\t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nPutBlock {\n  PutBlock(const void *xorBlock, void *block)\n  \t\t: m_xorBlock((const byte *)xorBlock), m_block((byte *)block) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "0"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "2"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "3"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "4"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "5"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "6"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETBYTE",
          "args": [
            "tmp",
            "7"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "order",
            "tmp",
            "7"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "807-813",
          "snippet": "inline unsigned int GetByte(ByteOrder order, T value, unsigned int index)\n{\n\tif (order == LITTLE_ENDIAN_ORDER)\n\t\treturn GETBYTE(value, index);\n\telse\n\t\treturn GETBYTE(value, sizeof(T)-index-1);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline unsigned int GetByte(ByteOrder order, T value, unsigned int index)\n{\n\tif (order == LITTLE_ENDIAN_ORDER)\n\t\treturn GETBYTE(value, index);\n\telse\n\t\treturn GETBYTE(value, sizeof(T)-index-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetNativeByteOrder",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "GetNativeByteOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "398-401",
          "snippet": "inline ByteOrder GetNativeByteOrder()\n{\n\treturn NativeByteOrder::ToEnum();\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline ByteOrder GetNativeByteOrder()\n{\n\treturn NativeByteOrder::ToEnum();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nSharkProcessAndXorBlock {\n  inline SharkProcessAndXorBlock(const word64 *roundKeys, unsigned int rounds, const byte *inBlock, const byte *xorBlock, byte *outBlock)\n  {\n  \tword64 tmp = *(word64 *)inBlock ^ roundKeys[0];\n  \n  \tByteOrder order = GetNativeByteOrder();\n  \ttmp = cbox[0][GetByte(order, tmp, 0)] ^ cbox[1][GetByte(order, tmp, 1)] \n  \t\t^ cbox[2][GetByte(order, tmp, 2)] ^ cbox[3][GetByte(order, tmp, 3)] \n  \t\t^ cbox[4][GetByte(order, tmp, 4)] ^ cbox[5][GetByte(order, tmp, 5)] \n  \t\t^ cbox[6][GetByte(order, tmp, 6)] ^ cbox[7][GetByte(order, tmp, 7)]\n  \t\t^ roundKeys[1];\n  \n  \tfor(unsigned int i=2; i<rounds; i++) \n  \t{\n  \t\ttmp = cbox[0][GETBYTE(tmp, 7)] ^ cbox[1][GETBYTE(tmp, 6)] \n  \t\t\t^ cbox[2][GETBYTE(tmp, 5)] ^ cbox[3][GETBYTE(tmp, 4)] \n  \t\t\t^ cbox[4][GETBYTE(tmp, 3)] ^ cbox[5][GETBYTE(tmp, 2)] \n  \t\t\t^ cbox[6][GETBYTE(tmp, 1)] ^ cbox[7][GETBYTE(tmp, 0)]\n  \t\t\t^ roundKeys[i];\n  \t}\n  \n  \tPutBlock<byte, BigEndian>(xorBlock, outBlock)\n  \t\t(sbox[GETBYTE(tmp, 7)])\n  \t\t(sbox[GETBYTE(tmp, 6)])\n  \t\t(sbox[GETBYTE(tmp, 5)])\n  \t\t(sbox[GETBYTE(tmp, 4)])\n  \t\t(sbox[GETBYTE(tmp, 3)])\n  \t\t(sbox[GETBYTE(tmp, 2)])\n  \t\t(sbox[GETBYTE(tmp, 1)])\n  \t\t(sbox[GETBYTE(tmp, 0)]);\n  \n  \t*(word64 *)outBlock ^= roundKeys[rounds];\n  }\n}"
  },
  {
    "function_name": "InitForKeySetup",
    "container": "SHARK::Enc",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
    "lines": "73-87",
    "snippet": "void SHARK::Enc::InitForKeySetup()\n{\n\tm_rounds = DEFAULT_ROUNDS;\n\tm_roundKeys.New(DEFAULT_ROUNDS+1);\n\n\tfor (unsigned int i=0; i<DEFAULT_ROUNDS; i++)\n\t\tm_roundKeys[i] = cbox[0][i];\n\n\tm_roundKeys[DEFAULT_ROUNDS] = SHARKTransform(cbox[0][DEFAULT_ROUNDS]);\n\n#ifdef IS_LITTLE_ENDIAN\n\tm_roundKeys[0] = ByteReverse(m_roundKeys[0]);\n\tm_roundKeys[m_rounds] = ByteReverse(m_roundKeys[m_rounds]);\n#endif\n}",
    "includes": [
      "#include \"gf256.h\"",
      "#include \"modes.h\"",
      "#include \"misc.h\"",
      "#include \"shark.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "m_roundKeys[m_rounds]"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SHARKTransform",
          "args": [
            "cbox[0][DEFAULT_ROUNDS]"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "SHARKTransform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
          "lines": "11-30",
          "snippet": "static word64 SHARKTransform(word64 a)\n{\n\tstatic const byte iG[8][8] = {\n\t\t0xe7, 0x30, 0x90, 0x85, 0xd0, 0x4b, 0x91, 0x41, \n\t\t0x53, 0x95, 0x9b, 0xa5, 0x96, 0xbc, 0xa1, 0x68, \n\t\t0x02, 0x45, 0xf7, 0x65, 0x5c, 0x1f, 0xb6, 0x52, \n\t\t0xa2, 0xca, 0x22, 0x94, 0x44, 0x63, 0x2a, 0xa2, \n\t\t0xfc, 0x67, 0x8e, 0x10, 0x29, 0x75, 0x85, 0x71, \n\t\t0x24, 0x45, 0xa2, 0xcf, 0x2f, 0x22, 0xc1, 0x0e, \n\t\t0xa1, 0xf1, 0x71, 0x40, 0x91, 0x27, 0x18, 0xa5, \n\t\t0x56, 0xf4, 0xaf, 0x32, 0xd2, 0xa4, 0xdc, 0x71, \n\t};\n\n\tword64 result=0;\n\tGF256 gf256(0xf5);\n\tfor (unsigned int i=0; i<8; i++)\n\t\tfor(unsigned int j=0; j<8; j++) \n\t\t\tresult ^= word64(gf256.Multiply(iG[i][j], GF256::Element(a>>(56-8*j)))) << (56-8*i);\n\treturn result;\n}",
          "includes": [
            "#include \"gf256.h\"",
            "#include \"modes.h\"",
            "#include \"misc.h\"",
            "#include \"shark.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nstatic word64 SHARKTransform(word64 a)\n{\n\tstatic const byte iG[8][8] = {\n\t\t0xe7, 0x30, 0x90, 0x85, 0xd0, 0x4b, 0x91, 0x41, \n\t\t0x53, 0x95, 0x9b, 0xa5, 0x96, 0xbc, 0xa1, 0x68, \n\t\t0x02, 0x45, 0xf7, 0x65, 0x5c, 0x1f, 0xb6, 0x52, \n\t\t0xa2, 0xca, 0x22, 0x94, 0x44, 0x63, 0x2a, 0xa2, \n\t\t0xfc, 0x67, 0x8e, 0x10, 0x29, 0x75, 0x85, 0x71, \n\t\t0x24, 0x45, 0xa2, 0xcf, 0x2f, 0x22, 0xc1, 0x0e, \n\t\t0xa1, 0xf1, 0x71, 0x40, 0x91, 0x27, 0x18, 0xa5, \n\t\t0x56, 0xf4, 0xaf, 0x32, 0xd2, 0xa4, 0xdc, 0x71, \n\t};\n\n\tword64 result=0;\n\tGF256 gf256(0xf5);\n\tfor (unsigned int i=0; i<8; i++)\n\t\tfor(unsigned int j=0; j<8; j++) \n\t\t\tresult ^= word64(gf256.Multiply(iG[i][j], GF256::Element(a>>(56-8*j)))) << (56-8*i);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_roundKeys.New",
          "args": [
            "DEFAULT_ROUNDS+1"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nSHARK {\n  Enc {\n    void SHARK::Enc::InitForKeySetup()\n    {\n    \tm_rounds = DEFAULT_ROUNDS;\n    \tm_roundKeys.New(DEFAULT_ROUNDS+1);\n    \n    \tfor (unsigned int i=0; i<DEFAULT_ROUNDS; i++)\n    \t\tm_roundKeys[i] = cbox[0][i];\n    \n    \tm_roundKeys[DEFAULT_ROUNDS] = SHARKTransform(cbox[0][DEFAULT_ROUNDS]);\n    \n    #ifdef IS_LITTLE_ENDIAN\n    \tm_roundKeys[0] = ByteReverse(m_roundKeys[0]);\n    \tm_roundKeys[m_rounds] = ByteReverse(m_roundKeys[m_rounds]);\n    #endif\n    }\n  }\n}"
  },
  {
    "function_name": "UncheckedSetKey",
    "container": "SHARK::Base",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
    "lines": "32-70",
    "snippet": "void SHARK::Base::UncheckedSetKey(const byte *key, unsigned int keyLen, const NameValuePairs &params)\n{\n\tAssertValidKeyLength(keyLen);\n\n\tm_rounds = GetRoundsAndThrowIfInvalid(params, this);\n\tm_roundKeys.New(m_rounds+1);\n\n\t// concatenate key enought times to fill a\n\tfor (unsigned int i=0; i<(m_rounds+1)*8; i++)\n\t\t((byte *)m_roundKeys.begin())[i] = key[i%keyLen];\n\n\tSHARK::Encryption e;\n\te.InitForKeySetup();\n\tbyte IV[8] = {0,0,0,0,0,0,0,0};\n\tCFB_Mode_ExternalCipher::Encryption cfb(e, IV);\n\n\tcfb.ProcessString((byte *)m_roundKeys.begin(), (m_rounds+1)*8);\n\n\tConditionalByteReverse(BIG_ENDIAN_ORDER, m_roundKeys.begin(), m_roundKeys.begin(), (m_rounds+1)*8);\n\n\tm_roundKeys[m_rounds] = SHARKTransform(m_roundKeys[m_rounds]);\n\n\tif (!IsForwardTransformation())\n\t{\n\t\tunsigned int i;\n\n\t\t// transform encryption round keys into decryption round keys\n\t\tfor (i=0; i<m_rounds/2; i++)\n\t\t\tstd::swap(m_roundKeys[i], m_roundKeys[m_rounds-i]);\n\n\t\tfor (i=1; i<m_rounds; i++)\n\t\t\tm_roundKeys[i] = SHARKTransform(m_roundKeys[i]);\n\t}\n\n#ifdef IS_LITTLE_ENDIAN\n\tm_roundKeys[0] = ByteReverse(m_roundKeys[0]);\n\tm_roundKeys[m_rounds] = ByteReverse(m_roundKeys[m_rounds]);\n#endif\n}",
    "includes": [
      "#include \"gf256.h\"",
      "#include \"modes.h\"",
      "#include \"misc.h\"",
      "#include \"shark.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "m_roundKeys[m_rounds]"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "852-868",
          "snippet": "inline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define CRYPTOPP_BYTESWAP_AVAILABLE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define CRYPTOPP_BYTESWAP_AVAILABLE\n\ninline word64 ByteReverse(word64 value)\n{\n#if defined(__GNUC__) && defined(CRYPTOPP_X86_ASM_AVAILABLE) && defined(__x86_64__)\n\t__asm__ (\"bswap %0\" : \"=r\" (value) : \"0\" (value));\n\treturn value;\n#elif defined(CRYPTOPP_BYTESWAP_AVAILABLE)\n\treturn bswap_64(value);\n#elif defined(_MSC_VER) && _MSC_VER >= 1300\n\treturn _byteswap_uint64(value);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn (word64(ByteReverse(word32(value))) << 32) | ByteReverse(word32(value>>32));\n#else\n\tvalue = ((value & W64LIT(0xFF00FF00FF00FF00)) >> 8) | ((value & W64LIT(0x00FF00FF00FF00FF)) << 8);\n\tvalue = ((value & W64LIT(0xFFFF0000FFFF0000)) >> 16) | ((value & W64LIT(0x0000FFFF0000FFFF)) << 16);\n\treturn rotlFixed(value, 32U);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SHARKTransform",
          "args": [
            "m_roundKeys[i]"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "SHARKTransform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
          "lines": "11-30",
          "snippet": "static word64 SHARKTransform(word64 a)\n{\n\tstatic const byte iG[8][8] = {\n\t\t0xe7, 0x30, 0x90, 0x85, 0xd0, 0x4b, 0x91, 0x41, \n\t\t0x53, 0x95, 0x9b, 0xa5, 0x96, 0xbc, 0xa1, 0x68, \n\t\t0x02, 0x45, 0xf7, 0x65, 0x5c, 0x1f, 0xb6, 0x52, \n\t\t0xa2, 0xca, 0x22, 0x94, 0x44, 0x63, 0x2a, 0xa2, \n\t\t0xfc, 0x67, 0x8e, 0x10, 0x29, 0x75, 0x85, 0x71, \n\t\t0x24, 0x45, 0xa2, 0xcf, 0x2f, 0x22, 0xc1, 0x0e, \n\t\t0xa1, 0xf1, 0x71, 0x40, 0x91, 0x27, 0x18, 0xa5, \n\t\t0x56, 0xf4, 0xaf, 0x32, 0xd2, 0xa4, 0xdc, 0x71, \n\t};\n\n\tword64 result=0;\n\tGF256 gf256(0xf5);\n\tfor (unsigned int i=0; i<8; i++)\n\t\tfor(unsigned int j=0; j<8; j++) \n\t\t\tresult ^= word64(gf256.Multiply(iG[i][j], GF256::Element(a>>(56-8*j)))) << (56-8*i);\n\treturn result;\n}",
          "includes": [
            "#include \"gf256.h\"",
            "#include \"modes.h\"",
            "#include \"misc.h\"",
            "#include \"shark.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nstatic word64 SHARKTransform(word64 a)\n{\n\tstatic const byte iG[8][8] = {\n\t\t0xe7, 0x30, 0x90, 0x85, 0xd0, 0x4b, 0x91, 0x41, \n\t\t0x53, 0x95, 0x9b, 0xa5, 0x96, 0xbc, 0xa1, 0x68, \n\t\t0x02, 0x45, 0xf7, 0x65, 0x5c, 0x1f, 0xb6, 0x52, \n\t\t0xa2, 0xca, 0x22, 0x94, 0x44, 0x63, 0x2a, 0xa2, \n\t\t0xfc, 0x67, 0x8e, 0x10, 0x29, 0x75, 0x85, 0x71, \n\t\t0x24, 0x45, 0xa2, 0xcf, 0x2f, 0x22, 0xc1, 0x0e, \n\t\t0xa1, 0xf1, 0x71, 0x40, 0x91, 0x27, 0x18, 0xa5, \n\t\t0x56, 0xf4, 0xaf, 0x32, 0xd2, 0xa4, 0xdc, 0x71, \n\t};\n\n\tword64 result=0;\n\tGF256 gf256(0xf5);\n\tfor (unsigned int i=0; i<8; i++)\n\t\tfor(unsigned int j=0; j<8; j++) \n\t\t\tresult ^= word64(gf256.Multiply(iG[i][j], GF256::Element(a>>(56-8*j)))) << (56-8*i);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::swap",
          "args": [
            "m_roundKeys[i]",
            "m_roundKeys[m_rounds-i]"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "453-456",
          "snippet": "inline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\ninline void swap(CryptoPP::PolynomialOverFixedRing<T,i> &a, CryptoPP::PolynomialOverFixedRing<T,i> &b)\n{\n\ta.swap(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsForwardTransformation",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "IsForwardTransformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/arc4.h",
          "lines": "25-25",
          "snippet": "bool IsForwardTransformation() const {return true;}",
          "includes": [
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n\nbool IsForwardTransformation() const {return true;}"
        }
      },
      {
        "call_info": {
          "callee": "ConditionalByteReverse",
          "args": [
            "BIG_ENDIAN_ORDER",
            "m_roundKeys.begin()",
            "m_roundKeys.begin()",
            "(m_rounds+1)*8"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "937-943",
          "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_roundKeys.begin",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfb.ProcessString",
          "args": [
            "(byte *)m_roundKeys.begin()",
            "(m_rounds+1)*8"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.InitForKeySetup",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "InitForKeySetup",
          "container": "SHARK::Enc",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
          "lines": "73-87",
          "snippet": "void SHARK::Enc::InitForKeySetup()\n{\n\tm_rounds = DEFAULT_ROUNDS;\n\tm_roundKeys.New(DEFAULT_ROUNDS+1);\n\n\tfor (unsigned int i=0; i<DEFAULT_ROUNDS; i++)\n\t\tm_roundKeys[i] = cbox[0][i];\n\n\tm_roundKeys[DEFAULT_ROUNDS] = SHARKTransform(cbox[0][DEFAULT_ROUNDS]);\n\n#ifdef IS_LITTLE_ENDIAN\n\tm_roundKeys[0] = ByteReverse(m_roundKeys[0]);\n\tm_roundKeys[m_rounds] = ByteReverse(m_roundKeys[m_rounds]);\n#endif\n}",
          "includes": [
            "#include \"gf256.h\"",
            "#include \"modes.h\"",
            "#include \"misc.h\"",
            "#include \"shark.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nSHARK {\n  Enc {\n    void SHARK::Enc::InitForKeySetup()\n    {\n    \tm_rounds = DEFAULT_ROUNDS;\n    \tm_roundKeys.New(DEFAULT_ROUNDS+1);\n    \n    \tfor (unsigned int i=0; i<DEFAULT_ROUNDS; i++)\n    \t\tm_roundKeys[i] = cbox[0][i];\n    \n    \tm_roundKeys[DEFAULT_ROUNDS] = SHARKTransform(cbox[0][DEFAULT_ROUNDS]);\n    \n    #ifdef IS_LITTLE_ENDIAN\n    \tm_roundKeys[0] = ByteReverse(m_roundKeys[0]);\n    \tm_roundKeys[m_rounds] = ByteReverse(m_roundKeys[m_rounds]);\n    #endif\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_roundKeys.New",
          "args": [
            "m_rounds+1"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRoundsAndThrowIfInvalid",
          "args": [
            "params",
            "this"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "GetRoundsAndThrowIfInvalid",
          "container": "FixedBlockSize::FixedRounds::VariableRounds",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/seckey.h",
          "lines": "54-59",
          "snippet": "inline unsigned int GetRoundsAndThrowIfInvalid(const NameValuePairs &param, const Algorithm *alg)\n\t{\n\t\tint rounds = param.GetIntValueWithDefault(\"Rounds\", DEFAULT_ROUNDS);\n\t\tThrowIfInvalidRounds(rounds, alg);\n\t\treturn (unsigned int)rounds;\n\t}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nFixedBlockSize {\n  FixedRounds {\n    VariableRounds {\n      inline unsigned int GetRoundsAndThrowIfInvalid(const NameValuePairs &param, const Algorithm *alg)\n      \t{\n      \t\tint rounds = param.GetIntValueWithDefault(\"Rounds\", DEFAULT_ROUNDS);\n      \t\tThrowIfInvalidRounds(rounds, alg);\n      \t\treturn (unsigned int)rounds;\n      \t}\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AssertValidKeyLength",
          "args": [
            "keyLen"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nSHARK {\n  Base {\n    void SHARK::Base::UncheckedSetKey(const byte *key, unsigned int keyLen, const NameValuePairs &params)\n    {\n    \tAssertValidKeyLength(keyLen);\n    \n    \tm_rounds = GetRoundsAndThrowIfInvalid(params, this);\n    \tm_roundKeys.New(m_rounds+1);\n    \n    \t// concatenate key enought times to fill a\n    \tfor (unsigned int i=0; i<(m_rounds+1)*8; i++)\n    \t\t((byte *)m_roundKeys.begin())[i] = key[i%keyLen];\n    \n    \tSHARK::Encryption e;\n    \te.InitForKeySetup();\n    \tbyte IV[8] = {0,0,0,0,0,0,0,0};\n    \tCFB_Mode_ExternalCipher::Encryption cfb(e, IV);\n    \n    \tcfb.ProcessString((byte *)m_roundKeys.begin(), (m_rounds+1)*8);\n    \n    \tConditionalByteReverse(BIG_ENDIAN_ORDER, m_roundKeys.begin(), m_roundKeys.begin(), (m_rounds+1)*8);\n    \n    \tm_roundKeys[m_rounds] = SHARKTransform(m_roundKeys[m_rounds]);\n    \n    \tif (!IsForwardTransformation())\n    \t{\n    \t\tunsigned int i;\n    \n    \t\t// transform encryption round keys into decryption round keys\n    \t\tfor (i=0; i<m_rounds/2; i++)\n    \t\t\tstd::swap(m_roundKeys[i], m_roundKeys[m_rounds-i]);\n    \n    \t\tfor (i=1; i<m_rounds; i++)\n    \t\t\tm_roundKeys[i] = SHARKTransform(m_roundKeys[i]);\n    \t}\n    \n    #ifdef IS_LITTLE_ENDIAN\n    \tm_roundKeys[0] = ByteReverse(m_roundKeys[0]);\n    \tm_roundKeys[m_rounds] = ByteReverse(m_roundKeys[m_rounds]);\n    #endif\n    }\n  }\n}"
  },
  {
    "function_name": "SHARKTransform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/shark.cpp",
    "lines": "11-30",
    "snippet": "static word64 SHARKTransform(word64 a)\n{\n\tstatic const byte iG[8][8] = {\n\t\t0xe7, 0x30, 0x90, 0x85, 0xd0, 0x4b, 0x91, 0x41, \n\t\t0x53, 0x95, 0x9b, 0xa5, 0x96, 0xbc, 0xa1, 0x68, \n\t\t0x02, 0x45, 0xf7, 0x65, 0x5c, 0x1f, 0xb6, 0x52, \n\t\t0xa2, 0xca, 0x22, 0x94, 0x44, 0x63, 0x2a, 0xa2, \n\t\t0xfc, 0x67, 0x8e, 0x10, 0x29, 0x75, 0x85, 0x71, \n\t\t0x24, 0x45, 0xa2, 0xcf, 0x2f, 0x22, 0xc1, 0x0e, \n\t\t0xa1, 0xf1, 0x71, 0x40, 0x91, 0x27, 0x18, 0xa5, \n\t\t0x56, 0xf4, 0xaf, 0x32, 0xd2, 0xa4, 0xdc, 0x71, \n\t};\n\n\tword64 result=0;\n\tGF256 gf256(0xf5);\n\tfor (unsigned int i=0; i<8; i++)\n\t\tfor(unsigned int j=0; j<8; j++) \n\t\t\tresult ^= word64(gf256.Multiply(iG[i][j], GF256::Element(a>>(56-8*j)))) << (56-8*i);\n\treturn result;\n}",
    "includes": [
      "#include \"gf256.h\"",
      "#include \"modes.h\"",
      "#include \"misc.h\"",
      "#include \"shark.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "word64",
          "args": [
            "gf256.Multiply(iG[i][j], GF256::Element(a>>(56-8*j)))"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gf256.Multiply",
          "args": [
            "iG[i][j]",
            "GF256::Element(a>>(56-8*j))"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "Multiply",
          "container": "Word",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "309-314",
          "snippet": "static Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nWord {\n  static Word Multiply(hword a, hword b)\n  \t{\n  \t\tWord r;\n  \t\tr.m_whole = (word)a * b;\n  \t\treturn r;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GF256::Element",
          "args": [
            "a>>(56-8*j)"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"gf256.h\"\n#include \"modes.h\"\n#include \"misc.h\"\n#include \"shark.h\"\n#include \"pch.h\"\n\nstatic word64 SHARKTransform(word64 a)\n{\n\tstatic const byte iG[8][8] = {\n\t\t0xe7, 0x30, 0x90, 0x85, 0xd0, 0x4b, 0x91, 0x41, \n\t\t0x53, 0x95, 0x9b, 0xa5, 0x96, 0xbc, 0xa1, 0x68, \n\t\t0x02, 0x45, 0xf7, 0x65, 0x5c, 0x1f, 0xb6, 0x52, \n\t\t0xa2, 0xca, 0x22, 0x94, 0x44, 0x63, 0x2a, 0xa2, \n\t\t0xfc, 0x67, 0x8e, 0x10, 0x29, 0x75, 0x85, 0x71, \n\t\t0x24, 0x45, 0xa2, 0xcf, 0x2f, 0x22, 0xc1, 0x0e, \n\t\t0xa1, 0xf1, 0x71, 0x40, 0x91, 0x27, 0x18, 0xa5, \n\t\t0x56, 0xf4, 0xaf, 0x32, 0xd2, 0xa4, 0xdc, 0x71, \n\t};\n\n\tword64 result=0;\n\tGF256 gf256(0xf5);\n\tfor (unsigned int i=0; i<8; i++)\n\t\tfor(unsigned int j=0; j<8; j++) \n\t\t\tresult ^= word64(gf256.Multiply(iG[i][j], GF256::Element(a>>(56-8*j)))) << (56-8*i);\n\treturn result;\n}"
  }
]