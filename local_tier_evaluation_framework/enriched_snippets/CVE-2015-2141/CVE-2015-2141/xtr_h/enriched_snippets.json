[
  {
    "function_name": "RaiseToPthPower",
    "container": "GFP2_ONB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "173-176",
    "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a.c1.swap",
          "args": [
            "a.c2"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "30-34",
          "snippet": "void swap(GFP2Element &a)\n\t{\n\t\tc1.swap(a.c1);\n\t\tc2.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void swap(GFP2Element &a)\n  \t{\n  \t\tc1.swap(a.c1);\n  \t\tc2.swap(a.c2);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
  },
  {
    "function_name": "Exponentiate",
    "container": "GFP2_ONB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "158-164",
    "snippet": "Element Exponentiate(const Element &a, const Integer &e) const\n\t{\n\t\tInteger edivp, emodp;\n\t\tInteger::Divide(emodp, edivp, e, modp.GetModulus());\n\t\tElement b = PthPower(a);\n\t\treturn AbstractRing<GFP2Element>::CascadeExponentiate(a, emodp, b, edivp);\n\t}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AbstractRing<GFP2Element>::CascadeExponentiate",
          "args": [
            "a",
            "emodp",
            "b",
            "edivp"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "CascadeExponentiate",
          "container": "DL_GroupParameters_LUC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.h",
          "lines": "158-159",
          "snippet": "Element CascadeExponentiate(const Element &element1, const Integer &exponent1, const Element &element2, const Integer &exponent2) const\n\t\t{throw NotImplemented(\"LUC_GroupParameters: MultiplyElements can not be implemented\");}",
          "includes": [
            "#include <limits.h>",
            "#include \"dh.h\"",
            "#include \"integer.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"dh.h\"\n#include \"integer.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n\nDL_GroupParameters_LUC {\n  Element CascadeExponentiate(const Element &element1, const Integer &exponent1, const Element &element2, const Integer &exponent2) const\n  \t\t{throw NotImplemented(\"LUC_GroupParameters: MultiplyElements can not be implemented\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PthPower",
          "args": [
            "a"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Divide",
          "args": [
            "emodp",
            "edivp",
            "e",
            "modp.GetModulus()"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Divide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3794-3828",
          "snippet": "void Integer::Divide(word &remainder, Integer &quotient, const Integer &dividend, word divisor)\n{\n\tif (!divisor)\n\t\tthrow Integer::DivideByZero();\n\n\tassert(divisor);\n\n\tif ((divisor & (divisor-1)) == 0)\t// divisor is a power of 2\n\t{\n\t\tquotient = dividend >> (BitPrecision(divisor)-1);\n\t\tremainder = dividend.reg[0] & (divisor-1);\n\t\treturn;\n\t}\n\n\tunsigned int i = dividend.WordCount();\n\tquotient.reg.CleanNew(RoundupSize(i));\n\tremainder = 0;\n\twhile (i--)\n\t{\n\t\tquotient.reg[i] = DWord(dividend.reg[i], remainder) / divisor;\n\t\tremainder = DWord(dividend.reg[i], remainder) % divisor;\n\t}\n\n\tif (dividend.NotNegative())\n\t\tquotient.sign = POSITIVE;\n\telse\n\t{\n\t\tquotient.sign = NEGATIVE;\n\t\tif (remainder)\n\t\t{\n\t\t\t--quotient;\n\t\t\tremainder = divisor - remainder;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nvoid Integer::Divide(word &remainder, Integer &quotient, const Integer &dividend, word divisor)\n{\n\tif (!divisor)\n\t\tthrow Integer::DivideByZero();\n\n\tassert(divisor);\n\n\tif ((divisor & (divisor-1)) == 0)\t// divisor is a power of 2\n\t{\n\t\tquotient = dividend >> (BitPrecision(divisor)-1);\n\t\tremainder = dividend.reg[0] & (divisor-1);\n\t\treturn;\n\t}\n\n\tunsigned int i = dividend.WordCount();\n\tquotient.reg.CleanNew(RoundupSize(i));\n\tremainder = 0;\n\twhile (i--)\n\t{\n\t\tquotient.reg[i] = DWord(dividend.reg[i], remainder) / divisor;\n\t\tremainder = DWord(dividend.reg[i], remainder) % divisor;\n\t}\n\n\tif (dividend.NotNegative())\n\t\tquotient.sign = POSITIVE;\n\telse\n\t{\n\t\tquotient.sign = NEGATIVE;\n\t\tif (remainder)\n\t\t{\n\t\t\t--quotient;\n\t\t\tremainder = divisor - remainder;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "modp.GetModulus",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  Element Exponentiate(const Element &a, const Integer &e) const\n  \t{\n  \t\tInteger edivp, emodp;\n  \t\tInteger::Divide(emodp, edivp, e, modp.GetModulus());\n  \t\tElement b = PthPower(a);\n  \t\treturn AbstractRing<GFP2Element>::CascadeExponentiate(a, emodp, b, edivp);\n  \t}\n}"
  },
  {
    "function_name": "IsUnit",
    "container": "GFP2_ONB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "120-123",
    "snippet": "bool IsUnit(const Element &a) const\n\t{\n\t\treturn a.c1.NotZero() || a.c2.NotZero();\n\t}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "a.c2.NotZero",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "NotZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "199-199",
          "snippet": "bool NotZero() const {return !IsZero();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool NotZero() const {return !IsZero();}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  bool IsUnit(const Element &a) const\n  \t{\n  \t\treturn a.c1.NotZero() || a.c2.NotZero();\n  \t}\n}"
  },
  {
    "function_name": "Equal",
    "container": "GFP2_ONB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "68-71",
    "snippet": "bool Equal(const GFP2Element &a, const GFP2Element &b) const\n\t{\n\t\treturn modp.Equal(a.c1, b.c1) && modp.Equal(a.c2, b.c2);\n\t}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  bool Equal(const GFP2Element &a, const GFP2Element &b) const\n  \t{\n  \t\treturn modp.Equal(a.c1, b.c1) && modp.Equal(a.c2, b.c2);\n  \t}\n}"
  },
  {
    "function_name": "ConvertOut",
    "container": "GFP2_ONB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "65-66",
    "snippet": "GFP2Element ConvertOut(const GFP2Element &a) const\n\t\t{return GFP2Element(modp.ConvertOut(a.c1), modp.ConvertOut(a.c2));}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GFP2Element",
          "args": [
            "modp.ConvertOut(a.c1)",
            "modp.ConvertOut(a.c2)"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  GFP2Element ConvertOut(const GFP2Element &a) const\n  \t\t{return GFP2Element(modp.ConvertOut(a.c1), modp.ConvertOut(a.c2));}\n}"
  },
  {
    "function_name": "ConvertIn",
    "container": "GFP2_ONB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "62-63",
    "snippet": "GFP2Element ConvertIn(const GFP2Element &a) const\n\t\t{return GFP2Element(modp.ConvertIn(a.c1), modp.ConvertIn(a.c2));}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GFP2Element",
          "args": [
            "modp.ConvertIn(a.c1)",
            "modp.ConvertIn(a.c2)"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  GFP2Element ConvertIn(const GFP2Element &a) const\n  \t\t{return GFP2Element(modp.ConvertIn(a.c1), modp.ConvertIn(a.c2));}\n}"
  },
  {
    "function_name": "ConvertIn",
    "container": "GFP2_ONB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "56-60",
    "snippet": "GFP2Element ConvertIn(const Integer &a) const\n\t{\n\t\tt = modp.Inverse(modp.ConvertIn(a));\n\t\treturn GFP2Element(t, t);\n\t}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GFP2Element",
          "args": [
            "t",
            "t"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "modp.Inverse",
          "args": [
            "modp.ConvertIn(a)"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "Inverse",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "32-33",
          "snippet": "Element Inverse(Element a) const\n\t\t{return a;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Inverse(Element a) const\n  \t\t{return a;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  GFP2Element ConvertIn(const Integer &a) const\n  \t{\n  \t\tt = modp.Inverse(modp.ConvertIn(a));\n  \t\treturn GFP2Element(t, t);\n  \t}\n}"
  },
  {
    "function_name": "GFP2_ONB",
    "container": "GFP2_ONB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "48-52",
    "snippet": "GFP2_ONB(const Integer &p) : modp(p)\n\t{\n\t\tif (p%3 != 2)\n\t\t\tthrow InvalidArgument(\"GFP2_ONB: modulus must be equivalent to 2 mod 3\");\n\t}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"GFP2_ONB: modulus must be equivalent to 2 mod 3\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  GFP2_ONB(const Integer &p) : modp(p)\n  \t{\n  \t\tif (p%3 != 2)\n  \t\t\tthrow InvalidArgument(\"GFP2_ONB: modulus must be equivalent to 2 mod 3\");\n  \t}\n}"
  },
  {
    "function_name": "swap",
    "container": "GFP2Element",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "30-34",
    "snippet": "void swap(GFP2Element &a)\n\t{\n\t\tc1.swap(a.c1);\n\t\tc2.swap(a.c2);\n\t}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void swap(GFP2Element &a)\n  \t{\n  \t\tc1.swap(a.c1);\n  \t\tc2.swap(a.c2);\n  \t}\n}"
  },
  {
    "function_name": "Encode",
    "container": "GFP2Element",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "21-25",
    "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
  },
  {
    "function_name": "GFP2Element",
    "container": "GFP2Element",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "18-19",
    "snippet": "GFP2Element(const byte *encodedElement, unsigned int size)\n\t\t: c1(encodedElement, size/2), c2(encodedElement+size/2, size/2) {}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  GFP2Element(const byte *encodedElement, unsigned int size)\n  \t\t: c1(encodedElement, size/2), c2(encodedElement+size/2, size/2) {}\n}"
  },
  {
    "function_name": "GFP2Element",
    "container": "GFP2Element",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "17-17",
    "snippet": "GFP2Element(const Integer &c1, const Integer &c2) : c1(c1), c2(c2) {}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  GFP2Element(const Integer &c1, const Integer &c2) : c1(c1), c2(c2) {}\n}"
  },
  {
    "function_name": "GFP2Element",
    "container": "GFP2Element",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
    "lines": "16-16",
    "snippet": "GFP2Element() {}",
    "includes": [
      "#include \"modarith.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  GFP2Element() {}\n}"
  }
]