[
  {
    "function_name": "HandleMismatchDetected",
    "container": "EqualityComparisonFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "164-170",
    "snippet": "bool EqualityComparisonFilter::HandleMismatchDetected(bool blocking)\n{\n\tm_mismatchDetected = true;\n\tif (m_throwIfNotEqual)\n\t\tthrow MismatchDetected();\n\treturn Output(1, (const byte *)\"\\0\", 1, 0, blocking) != 0;\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Output",
          "args": [
            "1",
            "(const byte *)\"\\0\"",
            "1",
            "0",
            "blocking"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "OutputFlush",
          "container": "Filter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "120-129",
          "snippet": "bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n{\n\tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n\t{\n\t\tm_continueAt = outputSite;\n\t\treturn true;\n\t}\n\tm_continueAt = 0;\n\treturn false;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilter {\n  bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n  {\n  \tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n  \t{\n  \t\tm_continueAt = outputSite;\n  \t\treturn true;\n  \t}\n  \tm_continueAt = 0;\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MismatchDetected",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nEqualityComparisonFilter {\n  bool EqualityComparisonFilter::HandleMismatchDetected(bool blocking)\n  {\n  \tm_mismatchDetected = true;\n  \tif (m_throwIfNotEqual)\n  \t\tthrow MismatchDetected();\n  \treturn Output(1, (const byte *)\"\\0\", 1, 0, blocking) != 0;\n  }\n}"
  },
  {
    "function_name": "ChannelMessageSeriesEnd",
    "container": "EqualityComparisonFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "135-162",
    "snippet": "bool EqualityComparisonFilter::ChannelMessageSeriesEnd(const std::string &channel, int propagation, bool blocking)\n{\n\tunsigned int i = MapChannel(channel);\n\n\tif (i == 2)\n\t{\n\t\tOutputMessageSeriesEnd(4, propagation, blocking, channel);\n\t\treturn false;\n\t}\n\telse if (m_mismatchDetected)\n\t\treturn false;\n\telse\n\t{\n\t\tMessageQueue &q1 = m_q[i], &q2 = m_q[1-i];\n\n\t\tif (q2.AnyRetrievable() || q2.AnyMessages())\n\t\t\tgoto mismatch;\n\t\telse if (q2.NumberOfMessageSeries() > 0)\n\t\t\treturn Output(2, (const byte *)\"\\1\", 1, 0, blocking) != 0;\n\t\telse\n\t\t\tq1.MessageSeriesEnd();\n\n\t\treturn false;\n\nmismatch:\n\t\treturn HandleMismatchDetected(blocking);\n\t}\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleMismatchDetected",
          "args": [
            "blocking"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "HandleMismatchDetected",
          "container": "EqualityComparisonFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "164-170",
          "snippet": "bool EqualityComparisonFilter::HandleMismatchDetected(bool blocking)\n{\n\tm_mismatchDetected = true;\n\tif (m_throwIfNotEqual)\n\t\tthrow MismatchDetected();\n\treturn Output(1, (const byte *)\"\\0\", 1, 0, blocking) != 0;\n}",
          "includes": [
            "#include \"mqueue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nEqualityComparisonFilter {\n  bool EqualityComparisonFilter::HandleMismatchDetected(bool blocking)\n  {\n  \tm_mismatchDetected = true;\n  \tif (m_throwIfNotEqual)\n  \t\tthrow MismatchDetected();\n  \treturn Output(1, (const byte *)\"\\0\", 1, 0, blocking) != 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q1.MessageSeriesEnd",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Output",
          "args": [
            "2",
            "(const byte *)\"\\1\"",
            "1",
            "0",
            "blocking"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "OutputFlush",
          "container": "Filter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "120-129",
          "snippet": "bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n{\n\tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n\t{\n\t\tm_continueAt = outputSite;\n\t\treturn true;\n\t}\n\tm_continueAt = 0;\n\treturn false;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilter {\n  bool Filter::OutputFlush(int outputSite, bool hardFlush, int propagation, bool blocking, const std::string &channel)\n  {\n  \tif (propagation && AttachedTransformation()->ChannelFlush(channel, hardFlush, propagation-1, blocking))\n  \t{\n  \t\tm_continueAt = outputSite;\n  \t\treturn true;\n  \t}\n  \tm_continueAt = 0;\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q2.NumberOfMessageSeries",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "NumberOfMessageSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "951-951",
          "snippet": "virtual unsigned int NumberOfMessageSeries() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual unsigned int NumberOfMessageSeries() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "q2.AnyMessages",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "AnyMessages",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "467-473",
          "snippet": "bool BufferedTransformation::AnyMessages() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyMessages();\n\telse\n\t\treturn NumberOfMessages() != 0;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyMessages() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyMessages();\n  \telse\n  \t\treturn NumberOfMessages() != 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q2.AnyRetrievable",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "AnyRetrievable",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "394-403",
          "snippet": "bool BufferedTransformation::AnyRetrievable() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyRetrievable();\n\telse\n\t{\n\t\tbyte b;\n\t\treturn Peek(b) != 0;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyRetrievable() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyRetrievable();\n  \telse\n  \t{\n  \t\tbyte b;\n  \t\treturn Peek(b) != 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputMessageSeriesEnd",
          "args": [
            "4",
            "propagation",
            "blocking",
            "channel"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "OutputMessageSeriesEnd",
          "container": "Filter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "131-140",
          "snippet": "bool Filter::OutputMessageSeriesEnd(int outputSite, int propagation, bool blocking, const std::string &channel)\n{\n\tif (propagation && AttachedTransformation()->ChannelMessageSeriesEnd(channel, propagation-1, blocking))\n\t{\n\t\tm_continueAt = outputSite;\n\t\treturn true;\n\t}\n\tm_continueAt = 0;\n\treturn false;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilter {\n  bool Filter::OutputMessageSeriesEnd(int outputSite, int propagation, bool blocking, const std::string &channel)\n  {\n  \tif (propagation && AttachedTransformation()->ChannelMessageSeriesEnd(channel, propagation-1, blocking))\n  \t{\n  \t\tm_continueAt = outputSite;\n  \t\treturn true;\n  \t}\n  \tm_continueAt = 0;\n  \treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MapChannel",
          "args": [
            "channel"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "MapChannel",
          "container": "EqualityComparisonFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "74-82",
          "snippet": "unsigned int EqualityComparisonFilter::MapChannel(const std::string &channel) const\n{\n\tif (channel == m_firstChannel)\n\t\treturn 0;\n\telse if (channel == m_secondChannel)\n\t\treturn 1;\n\telse\n\t\treturn 2;\n}",
          "includes": [
            "#include \"mqueue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nEqualityComparisonFilter {\n  unsigned int EqualityComparisonFilter::MapChannel(const std::string &channel) const\n  {\n  \tif (channel == m_firstChannel)\n  \t\treturn 0;\n  \telse if (channel == m_secondChannel)\n  \t\treturn 1;\n  \telse\n  \t\treturn 2;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nEqualityComparisonFilter {\n  bool EqualityComparisonFilter::ChannelMessageSeriesEnd(const std::string &channel, int propagation, bool blocking)\n  {\n  \tunsigned int i = MapChannel(channel);\n  \n  \tif (i == 2)\n  \t{\n  \t\tOutputMessageSeriesEnd(4, propagation, blocking, channel);\n  \t\treturn false;\n  \t}\n  \telse if (m_mismatchDetected)\n  \t\treturn false;\n  \telse\n  \t{\n  \t\tMessageQueue &q1 = m_q[i], &q2 = m_q[1-i];\n  \n  \t\tif (q2.AnyRetrievable() || q2.AnyMessages())\n  \t\t\tgoto mismatch;\n  \t\telse if (q2.NumberOfMessageSeries() > 0)\n  \t\t\treturn Output(2, (const byte *)\"\\1\", 1, 0, blocking) != 0;\n  \t\telse\n  \t\t\tq1.MessageSeriesEnd();\n  \n  \t\treturn false;\n  \n  mismatch:\n  \t\treturn HandleMismatchDetected(blocking);\n  \t}\n  }\n}"
  },
  {
    "function_name": "ChannelPut2",
    "container": "EqualityComparisonFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "84-133",
    "snippet": "size_t EqualityComparisonFilter::ChannelPut2(const std::string &channel, const byte *inString, size_t length, int messageEnd, bool blocking)\n{\n\tif (!blocking)\n\t\tthrow BlockingInputOnly(\"EqualityComparisonFilter\");\n\n\tunsigned int i = MapChannel(channel);\n\n\tif (i == 2)\n\t\treturn Output(3, inString, length, messageEnd, blocking, channel);\n\telse if (m_mismatchDetected)\n\t\treturn 0;\n\telse\n\t{\n\t\tMessageQueue &q1 = m_q[i], &q2 = m_q[1-i];\n\n\t\tif (q2.AnyMessages() && q2.MaxRetrievable() < length)\n\t\t\tgoto mismatch;\n\n\t\twhile (length > 0 && q2.AnyRetrievable())\n\t\t{\n\t\t\tsize_t len = length;\n\t\t\tconst byte *data = q2.Spy(len);\n\t\t\tlen = STDMIN(len, length);\n\t\t\tif (memcmp(inString, data, len) != 0)\n\t\t\t\tgoto mismatch;\n\t\t\tinString += len;\n\t\t\tlength -= len;\n\t\t\tq2.Skip(len);\n\t\t}\n\n\t\tq1.Put(inString, length);\n\n\t\tif (messageEnd)\n\t\t{\n\t\t\tif (q2.AnyRetrievable())\n\t\t\t\tgoto mismatch;\n\t\t\telse if (q2.AnyMessages())\n\t\t\t\tq2.GetNextMessage();\n\t\t\telse if (q2.NumberOfMessageSeries() > 0)\n\t\t\t\tgoto mismatch;\n\t\t\telse\n\t\t\t\tq1.MessageEnd();\n\t\t}\n\n\t\treturn 0;\n\nmismatch:\n\t\treturn HandleMismatchDetected(blocking);\n\t}\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HandleMismatchDetected",
          "args": [
            "blocking"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "HandleMismatchDetected",
          "container": "EqualityComparisonFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "164-170",
          "snippet": "bool EqualityComparisonFilter::HandleMismatchDetected(bool blocking)\n{\n\tm_mismatchDetected = true;\n\tif (m_throwIfNotEqual)\n\t\tthrow MismatchDetected();\n\treturn Output(1, (const byte *)\"\\0\", 1, 0, blocking) != 0;\n}",
          "includes": [
            "#include \"mqueue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nEqualityComparisonFilter {\n  bool EqualityComparisonFilter::HandleMismatchDetected(bool blocking)\n  {\n  \tm_mismatchDetected = true;\n  \tif (m_throwIfNotEqual)\n  \t\tthrow MismatchDetected();\n  \treturn Output(1, (const byte *)\"\\0\", 1, 0, blocking) != 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q1.MessageEnd",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q2.NumberOfMessageSeries",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "NumberOfMessageSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "951-951",
          "snippet": "virtual unsigned int NumberOfMessageSeries() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual unsigned int NumberOfMessageSeries() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "q2.GetNextMessage",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "GetNextMessage",
          "container": "MessageQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "32-43",
          "snippet": "bool MessageQueue::GetNextMessage()\n{\n\tif (NumberOfMessages() > 0 && !AnyRetrievable())\n\t{\n\t\tm_lengths.pop_front();\n\t\tif (m_messageCounts[0] == 0 && m_messageCounts.size() > 1)\n\t\t\tm_messageCounts.pop_front();\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}",
          "includes": [
            "#include \"mqueue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nMessageQueue {\n  bool MessageQueue::GetNextMessage()\n  {\n  \tif (NumberOfMessages() > 0 && !AnyRetrievable())\n  \t{\n  \t\tm_lengths.pop_front();\n  \t\tif (m_messageCounts[0] == 0 && m_messageCounts.size() > 1)\n  \t\t\tm_messageCounts.pop_front();\n  \t\treturn true;\n  \t}\n  \telse\n  \t\treturn false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q2.AnyMessages",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "AnyMessages",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "467-473",
          "snippet": "bool BufferedTransformation::AnyMessages() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyMessages();\n\telse\n\t\treturn NumberOfMessages() != 0;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyMessages() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyMessages();\n  \telse\n  \t\treturn NumberOfMessages() != 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q2.AnyRetrievable",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "AnyRetrievable",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "394-403",
          "snippet": "bool BufferedTransformation::AnyRetrievable() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyRetrievable();\n\telse\n\t{\n\t\tbyte b;\n\t\treturn Peek(b) != 0;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyRetrievable() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyRetrievable();\n  \telse\n  \t{\n  \t\tbyte b;\n  \t\treturn Peek(b) != 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q1.Put",
          "args": [
            "inString",
            "length"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "q2.Skip",
          "args": [
            "len"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "Skip",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "168-179",
          "snippet": "lword FileStore::Skip(lword skipMax)\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tlword oldPos = m_stream->tellg();\n\tstd::istream::off_type offset;\n\tif (!SafeConvert(skipMax, offset))\n\t\tthrow InvalidArgument(\"FileStore: maximum seek offset exceeded\");\n\tm_stream->seekg(offset, ios::cur);\n\treturn (lword)m_stream->tellg() - oldPos;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::Skip(lword skipMax)\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tlword oldPos = m_stream->tellg();\n  \tstd::istream::off_type offset;\n  \tif (!SafeConvert(skipMax, offset))\n  \t\tthrow InvalidArgument(\"FileStore: maximum seek offset exceeded\");\n  \tm_stream->seekg(offset, ios::cur);\n  \treturn (lword)m_stream->tellg() - oldPos;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "inString",
            "data",
            "len"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "len",
            "length"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "q2.Spy",
          "args": [
            "len"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "q2.MaxRetrievable",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Output",
          "args": [
            "3",
            "inString",
            "length",
            "messageEnd",
            "blocking",
            "channel"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "Output",
          "container": "Filter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "111-118",
          "snippet": "size_t Filter::Output(int outputSite, const byte *inString, size_t length, int messageEnd, bool blocking, const std::string &channel)\n{\n\tif (messageEnd)\n\t\tmessageEnd--;\n\tsize_t result = AttachedTransformation()->ChannelPut2(channel, inString, length, messageEnd, blocking);\n\tm_continueAt = result ? outputSite : 0;\n\treturn result;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nFilter {\n  size_t Filter::Output(int outputSite, const byte *inString, size_t length, int messageEnd, bool blocking, const std::string &channel)\n  {\n  \tif (messageEnd)\n  \t\tmessageEnd--;\n  \tsize_t result = AttachedTransformation()->ChannelPut2(channel, inString, length, messageEnd, blocking);\n  \tm_continueAt = result ? outputSite : 0;\n  \treturn result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MapChannel",
          "args": [
            "channel"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "MapChannel",
          "container": "EqualityComparisonFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "74-82",
          "snippet": "unsigned int EqualityComparisonFilter::MapChannel(const std::string &channel) const\n{\n\tif (channel == m_firstChannel)\n\t\treturn 0;\n\telse if (channel == m_secondChannel)\n\t\treturn 1;\n\telse\n\t\treturn 2;\n}",
          "includes": [
            "#include \"mqueue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nEqualityComparisonFilter {\n  unsigned int EqualityComparisonFilter::MapChannel(const std::string &channel) const\n  {\n  \tif (channel == m_firstChannel)\n  \t\treturn 0;\n  \telse if (channel == m_secondChannel)\n  \t\treturn 1;\n  \telse\n  \t\treturn 2;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockingInputOnly",
          "args": [
            "\"EqualityComparisonFilter\""
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "BlockingInputOnly",
          "container": "BlockingInputOnly",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "822-822",
          "snippet": "BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nBlockingInputOnly {\n  BlockingInputOnly(const std::string &s) : NotImplemented(s + \": Nonblocking input is not implemented by this object.\") {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nEqualityComparisonFilter {\n  size_t EqualityComparisonFilter::ChannelPut2(const std::string &channel, const byte *inString, size_t length, int messageEnd, bool blocking)\n  {\n  \tif (!blocking)\n  \t\tthrow BlockingInputOnly(\"EqualityComparisonFilter\");\n  \n  \tunsigned int i = MapChannel(channel);\n  \n  \tif (i == 2)\n  \t\treturn Output(3, inString, length, messageEnd, blocking, channel);\n  \telse if (m_mismatchDetected)\n  \t\treturn 0;\n  \telse\n  \t{\n  \t\tMessageQueue &q1 = m_q[i], &q2 = m_q[1-i];\n  \n  \t\tif (q2.AnyMessages() && q2.MaxRetrievable() < length)\n  \t\t\tgoto mismatch;\n  \n  \t\twhile (length > 0 && q2.AnyRetrievable())\n  \t\t{\n  \t\t\tsize_t len = length;\n  \t\t\tconst byte *data = q2.Spy(len);\n  \t\t\tlen = STDMIN(len, length);\n  \t\t\tif (memcmp(inString, data, len) != 0)\n  \t\t\t\tgoto mismatch;\n  \t\t\tinString += len;\n  \t\t\tlength -= len;\n  \t\t\tq2.Skip(len);\n  \t\t}\n  \n  \t\tq1.Put(inString, length);\n  \n  \t\tif (messageEnd)\n  \t\t{\n  \t\t\tif (q2.AnyRetrievable())\n  \t\t\t\tgoto mismatch;\n  \t\t\telse if (q2.AnyMessages())\n  \t\t\t\tq2.GetNextMessage();\n  \t\t\telse if (q2.NumberOfMessageSeries() > 0)\n  \t\t\t\tgoto mismatch;\n  \t\t\telse\n  \t\t\t\tq1.MessageEnd();\n  \t\t}\n  \n  \t\treturn 0;\n  \n  mismatch:\n  \t\treturn HandleMismatchDetected(blocking);\n  \t}\n  }\n}"
  },
  {
    "function_name": "MapChannel",
    "container": "EqualityComparisonFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "74-82",
    "snippet": "unsigned int EqualityComparisonFilter::MapChannel(const std::string &channel) const\n{\n\tif (channel == m_firstChannel)\n\t\treturn 0;\n\telse if (channel == m_secondChannel)\n\t\treturn 1;\n\telse\n\t\treturn 2;\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nEqualityComparisonFilter {\n  unsigned int EqualityComparisonFilter::MapChannel(const std::string &channel) const\n  {\n  \tif (channel == m_firstChannel)\n  \t\treturn 0;\n  \telse if (channel == m_secondChannel)\n  \t\treturn 1;\n  \telse\n  \t\treturn 2;\n  }\n}"
  },
  {
    "function_name": "swap",
    "container": "MessageQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "59-63",
    "snippet": "void MessageQueue::swap(MessageQueue &rhs)\n{\n\tm_queue.swap(rhs.m_queue);\n\tm_lengths.swap(rhs.m_lengths);\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_lengths.swap",
          "args": [
            "rhs.m_lengths"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": "MessageQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "59-63",
          "snippet": "void MessageQueue::swap(MessageQueue &rhs)\n{\n\tm_queue.swap(rhs.m_queue);\n\tm_lengths.swap(rhs.m_lengths);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nMessageQueue {\n  void MessageQueue::swap(MessageQueue &rhs)\n  {\n  \tm_queue.swap(rhs.m_queue);\n  \tm_lengths.swap(rhs.m_lengths);\n  }\n}"
  },
  {
    "function_name": "CopyMessagesTo",
    "container": "MessageQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "45-57",
    "snippet": "unsigned int MessageQueue::CopyMessagesTo(BufferedTransformation &target, unsigned int count, const std::string &channel) const\n{\n\tByteQueue::Walker walker(m_queue);\n\tstd::deque<lword>::const_iterator it = m_lengths.begin();\n\tunsigned int i;\n\tfor (i=0; i<count && it != --m_lengths.end(); ++i, ++it)\n\t{\n\t\twalker.TransferTo(target, *it, channel);\n\t\tif (GetAutoSignalPropagation())\n\t\t\ttarget.ChannelMessageEnd(channel, GetAutoSignalPropagation()-1);\n\t}\n\treturn i;\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "target.ChannelMessageEnd",
          "args": [
            "channel",
            "GetAutoSignalPropagation()-1"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAutoSignalPropagation",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "GetAutoSignalPropagation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "860-860",
          "snippet": "virtual int GetAutoSignalPropagation() const {return 0;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nvirtual int GetAutoSignalPropagation() const {return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "walker.TransferTo",
          "args": [
            "target",
            "*it",
            "channel"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_lengths.end",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_lengths.begin",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nMessageQueue {\n  unsigned int MessageQueue::CopyMessagesTo(BufferedTransformation &target, unsigned int count, const std::string &channel) const\n  {\n  \tByteQueue::Walker walker(m_queue);\n  \tstd::deque<lword>::const_iterator it = m_lengths.begin();\n  \tunsigned int i;\n  \tfor (i=0; i<count && it != --m_lengths.end(); ++i, ++it)\n  \t{\n  \t\twalker.TransferTo(target, *it, channel);\n  \t\tif (GetAutoSignalPropagation())\n  \t\t\ttarget.ChannelMessageEnd(channel, GetAutoSignalPropagation()-1);\n  \t}\n  \treturn i;\n  }\n}"
  },
  {
    "function_name": "GetNextMessage",
    "container": "MessageQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "32-43",
    "snippet": "bool MessageQueue::GetNextMessage()\n{\n\tif (NumberOfMessages() > 0 && !AnyRetrievable())\n\t{\n\t\tm_lengths.pop_front();\n\t\tif (m_messageCounts[0] == 0 && m_messageCounts.size() > 1)\n\t\t\tm_messageCounts.pop_front();\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_messageCounts.pop_front",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_messageCounts.size",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_lengths.pop_front",
          "args": [],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AnyRetrievable",
          "args": [],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "AnyRetrievable",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "394-403",
          "snippet": "bool BufferedTransformation::AnyRetrievable() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->AnyRetrievable();\n\telse\n\t{\n\t\tbyte b;\n\t\treturn Peek(b) != 0;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  bool BufferedTransformation::AnyRetrievable() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->AnyRetrievable();\n  \telse\n  \t{\n  \t\tbyte b;\n  \t\treturn Peek(b) != 0;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "NumberOfMessages",
          "args": [],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "NumberOfMessages",
          "container": "BufferedTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "459-465",
          "snippet": "unsigned int BufferedTransformation::NumberOfMessages() const\n{\n\tif (AttachedTransformation())\n\t\treturn AttachedTransformation()->NumberOfMessages();\n\telse\n\t\treturn CopyMessagesTo(TheBitBucket());\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBufferedTransformation {\n  unsigned int BufferedTransformation::NumberOfMessages() const\n  {\n  \tif (AttachedTransformation())\n  \t\treturn AttachedTransformation()->NumberOfMessages();\n  \telse\n  \t\treturn CopyMessagesTo(TheBitBucket());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nMessageQueue {\n  bool MessageQueue::GetNextMessage()\n  {\n  \tif (NumberOfMessages() > 0 && !AnyRetrievable())\n  \t{\n  \t\tm_lengths.pop_front();\n  \t\tif (m_messageCounts[0] == 0 && m_messageCounts.size() > 1)\n  \t\t\tm_messageCounts.pop_front();\n  \t\treturn true;\n  \t}\n  \telse\n  \t\treturn false;\n  }\n}"
  },
  {
    "function_name": "TransferTo2",
    "container": "MessageQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "24-30",
    "snippet": "size_t MessageQueue::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)\n{\n\ttransferBytes = STDMIN(MaxRetrievable(), transferBytes);\n\tsize_t blockedBytes = m_queue.TransferTo2(target, transferBytes, channel, blocking);\n\tm_lengths.front() -= transferBytes;\n\treturn blockedBytes;\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_lengths.front",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_queue.TransferTo2",
          "args": [
            "target",
            "transferBytes",
            "channel",
            "blocking"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "TransferTo2",
          "container": "MessageQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "24-30",
          "snippet": "size_t MessageQueue::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)\n{\n\ttransferBytes = STDMIN(MaxRetrievable(), transferBytes);\n\tsize_t blockedBytes = m_queue.TransferTo2(target, transferBytes, channel, blocking);\n\tm_lengths.front() -= transferBytes;\n\treturn blockedBytes;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "MaxRetrievable()",
            "transferBytes"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxRetrievable",
          "args": [],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nMessageQueue {\n  size_t MessageQueue::TransferTo2(BufferedTransformation &target, lword &transferBytes, const std::string &channel, bool blocking)\n  {\n  \ttransferBytes = STDMIN(MaxRetrievable(), transferBytes);\n  \tsize_t blockedBytes = m_queue.TransferTo2(target, transferBytes, channel, blocking);\n  \tm_lengths.front() -= transferBytes;\n  \treturn blockedBytes;\n  }\n}"
  },
  {
    "function_name": "CopyRangeTo2",
    "container": "MessageQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "16-22",
    "snippet": "size_t MessageQueue::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const\n{\n\tif (begin >= MaxRetrievable())\n\t\treturn 0;\n\n\treturn m_queue.CopyRangeTo2(target, begin, STDMIN(MaxRetrievable(), end), channel, blocking);\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_queue.CopyRangeTo2",
          "args": [
            "target",
            "begin",
            "STDMIN(MaxRetrievable(), end)",
            "channel",
            "blocking"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "CopyRangeTo2",
          "container": "MessageQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
          "lines": "16-22",
          "snippet": "size_t MessageQueue::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const\n{\n\tif (begin >= MaxRetrievable())\n\t\treturn 0;\n\n\treturn m_queue.CopyRangeTo2(target, begin, STDMIN(MaxRetrievable(), end), channel, blocking);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "MaxRetrievable()",
            "end"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxRetrievable",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nMessageQueue {\n  size_t MessageQueue::CopyRangeTo2(BufferedTransformation &target, lword &begin, lword end, const std::string &channel, bool blocking) const\n  {\n  \tif (begin >= MaxRetrievable())\n  \t\treturn 0;\n  \n  \treturn m_queue.CopyRangeTo2(target, begin, STDMIN(MaxRetrievable(), end), channel, blocking);\n  }\n}"
  },
  {
    "function_name": "MessageQueue",
    "container": "MessageQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/mqueue.cpp",
    "lines": "11-14",
    "snippet": "MessageQueue::MessageQueue(unsigned int nodeSize)\n\t: m_queue(nodeSize), m_lengths(1, 0U), m_messageCounts(1, 0U)\n{\n}",
    "includes": [
      "#include \"mqueue.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"mqueue.h\"\n#include \"pch.h\"\n\nMessageQueue {\n  MessageQueue::MessageQueue(unsigned int nodeSize)\n  \t: m_queue(nodeSize), m_lengths(1, 0U), m_messageCounts(1, 0U)\n  {\n  }\n}"
  }
]