[
  {
    "function_name": "OperateKeystream",
    "container": "PanamaCipherPolicy<B>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
    "lines": "488-496",
    "snippet": "void PanamaCipherPolicy<B>::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)\n{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n\t\tPanama_SSE2_Pull(iterationCount, this->m_state, (word32 *)output, (const word32 *)input);\n\telse\n#endif\n\t\tthis->Iterate(iterationCount, NULL, output, input, operation);\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"panama.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->Iterate",
          "args": [
            "iterationCount",
            "NULL",
            "output",
            "input",
            "operation"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "Iterate",
          "container": "Panama<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "318-411",
          "snippet": "void Panama<B>::Iterate(size_t count, const word32 *p, byte *output, const byte *input, KeystreamOperation operation)\n{\n\tword32 bstart = m_state[17];\n\tword32 *const aPtr = m_state;\n\tword32 cPtr[17];\n\n#define bPtr ((byte *)(aPtr+20))\n\n// reorder the state for SSE2\n// a and c: 4 8 12 16 | 3 7 11 15 | 2 6 10 14 | 1 5 9 13 | 0\n//\t\t\txmm0\t\txmm1\t\txmm2\t\txmm3\t\teax\n#define a(i) aPtr[((i)*13+16) % 17]\t\t// 13 is inverse of 4 mod 17\n#define c(i) cPtr[((i)*13+16) % 17]\n// b: 0 4 | 1 5 | 2 6 | 3 7\n#define b(i, j) b##i[(j)*2%8 + (j)/4]\n\n// buffer update\n#define US(i) {word32 t=b(0,i); b(0,i)=ConditionalByteReverse(B::ToEnum(), p[i])^t; b(25,(i+6)%8)^=t;}\n#define UL(i) {word32 t=b(0,i); b(0,i)=a(i+1)^t; b(25,(i+6)%8)^=t;}\n// gamma and pi\n#define GP(i) c(5*i%17) = rotlFixed(a(i) ^ (a((i+1)%17) | ~a((i+2)%17)), ((5*i%17)*((5*i%17)+1)/2)%32)\n// theta and sigma\n#define T(i,x) a(i) = c(i) ^ c((i+1)%17) ^ c((i+4)%17) ^ x\n#define TS1S(i) T(i+1, ConditionalByteReverse(B::ToEnum(), p[i]))\n#define TS1L(i) T(i+1, b(4,i))\n#define TS2(i) T(i+9, b(16,i))\n\n\twhile (count--)\n\t{\n\t\tif (output)\n\t\t{\n#define PANAMA_OUTPUT(x)\t\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 0, a(0+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 1, a(1+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 2, a(2+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 3, a(3+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 4, a(4+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 5, a(5+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 6, a(6+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 7, a(7+9));\n\n\t\t\ttypedef word32 WordType;\n\t\t\tCRYPTOPP_KEYSTREAM_OUTPUT_SWITCH(PANAMA_OUTPUT, 4*8);\n\t\t}\n\n\t\tword32 *const b16 = (word32 *)(bPtr+((bstart+16*32) & 31*32));\n\t\tword32 *const b4 = (word32 *)(bPtr+((bstart+(32-4)*32) & 31*32));\n       \tbstart += 32;\n\t\tword32 *const b0 = (word32 *)(bPtr+((bstart) & 31*32));\n\t\tword32 *const b25 = (word32 *)(bPtr+((bstart+(32-25)*32) & 31*32));\n\n\t\tif (p)\n\t\t{\n\t\t\tUS(0); US(1); US(2); US(3); US(4); US(5); US(6); US(7);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUL(0); UL(1); UL(2); UL(3); UL(4); UL(5); UL(6); UL(7);\n\t\t}\n\n\t\tGP(0); \n\t\tGP(1); \n\t\tGP(2); \n\t\tGP(3); \n\t\tGP(4); \n\t\tGP(5); \n\t\tGP(6); \n\t\tGP(7);\n\t\tGP(8); \n\t\tGP(9); \n\t\tGP(10); \n\t\tGP(11); \n\t\tGP(12); \n\t\tGP(13); \n\t\tGP(14); \n\t\tGP(15); \n\t\tGP(16);\n\n\t\tT(0,1);\n\n\t\tif (p)\n\t\t{\n\t\t\tTS1S(0); TS1S(1); TS1S(2); TS1S(3); TS1S(4); TS1S(5); TS1S(6); TS1S(7);\n\t\t\tp += 8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTS1L(0); TS1L(1); TS1L(2); TS1L(3); TS1L(4); TS1L(5); TS1L(6); TS1L(7);\n\t\t}\n\n\t\tTS2(0); TS2(1); TS2(2); TS2(3); TS2(4); TS2(5); TS2(6); TS2(7);\n\t}\n\tm_state[17] = bstart;\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [
            "#define bPtr ((byte *)(aPtr+20))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\n#define bPtr ((byte *)(aPtr+20))\n\nPanama<B> {\n  void Panama<B>::Iterate(size_t count, const word32 *p, byte *output, const byte *input, KeystreamOperation operation)\n  {\n  \tword32 bstart = m_state[17];\n  \tword32 *const aPtr = m_state;\n  \tword32 cPtr[17];\n  \n  #define bPtr ((byte *)(aPtr+20))\n  \n  // reorder the state for SSE2\n  // a and c: 4 8 12 16 | 3 7 11 15 | 2 6 10 14 | 1 5 9 13 | 0\n  //\t\t\txmm0\t\txmm1\t\txmm2\t\txmm3\t\teax\n  #define a(i) aPtr[((i)*13+16) % 17]\t\t// 13 is inverse of 4 mod 17\n  #define c(i) cPtr[((i)*13+16) % 17]\n  // b: 0 4 | 1 5 | 2 6 | 3 7\n  #define b(i, j) b##i[(j)*2%8 + (j)/4]\n  \n  // buffer update\n  #define US(i) {word32 t=b(0,i); b(0,i)=ConditionalByteReverse(B::ToEnum(), p[i])^t; b(25,(i+6)%8)^=t;}\n  #define UL(i) {word32 t=b(0,i); b(0,i)=a(i+1)^t; b(25,(i+6)%8)^=t;}\n  // gamma and pi\n  #define GP(i) c(5*i%17) = rotlFixed(a(i) ^ (a((i+1)%17) | ~a((i+2)%17)), ((5*i%17)*((5*i%17)+1)/2)%32)\n  // theta and sigma\n  #define T(i,x) a(i) = c(i) ^ c((i+1)%17) ^ c((i+4)%17) ^ x\n  #define TS1S(i) T(i+1, ConditionalByteReverse(B::ToEnum(), p[i]))\n  #define TS1L(i) T(i+1, b(4,i))\n  #define TS2(i) T(i+9, b(16,i))\n  \n  \twhile (count--)\n  \t{\n  \t\tif (output)\n  \t\t{\n  #define PANAMA_OUTPUT(x)\t\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 0, a(0+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 1, a(1+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 2, a(2+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 3, a(3+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 4, a(4+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 5, a(5+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 6, a(6+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 7, a(7+9));\n  \n  \t\t\ttypedef word32 WordType;\n  \t\t\tCRYPTOPP_KEYSTREAM_OUTPUT_SWITCH(PANAMA_OUTPUT, 4*8);\n  \t\t}\n  \n  \t\tword32 *const b16 = (word32 *)(bPtr+((bstart+16*32) & 31*32));\n  \t\tword32 *const b4 = (word32 *)(bPtr+((bstart+(32-4)*32) & 31*32));\n         \tbstart += 32;\n  \t\tword32 *const b0 = (word32 *)(bPtr+((bstart) & 31*32));\n  \t\tword32 *const b25 = (word32 *)(bPtr+((bstart+(32-25)*32) & 31*32));\n  \n  \t\tif (p)\n  \t\t{\n  \t\t\tUS(0); US(1); US(2); US(3); US(4); US(5); US(6); US(7);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tUL(0); UL(1); UL(2); UL(3); UL(4); UL(5); UL(6); UL(7);\n  \t\t}\n  \n  \t\tGP(0); \n  \t\tGP(1); \n  \t\tGP(2); \n  \t\tGP(3); \n  \t\tGP(4); \n  \t\tGP(5); \n  \t\tGP(6); \n  \t\tGP(7);\n  \t\tGP(8); \n  \t\tGP(9); \n  \t\tGP(10); \n  \t\tGP(11); \n  \t\tGP(12); \n  \t\tGP(13); \n  \t\tGP(14); \n  \t\tGP(15); \n  \t\tGP(16);\n  \n  \t\tT(0,1);\n  \n  \t\tif (p)\n  \t\t{\n  \t\t\tTS1S(0); TS1S(1); TS1S(2); TS1S(3); TS1S(4); TS1S(5); TS1S(6); TS1S(7);\n  \t\t\tp += 8;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tTS1L(0); TS1L(1); TS1L(2); TS1L(3); TS1L(4); TS1L(5); TS1L(6); TS1L(7);\n  \t\t}\n  \n  \t\tTS2(0); TS2(1); TS2(2); TS2(3); TS2(4); TS2(5); TS2(6); TS2(7);\n  \t}\n  \tm_state[17] = bstart;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Panama_SSE2_Pull",
          "args": [
            "iterationCount",
            "this->m_state",
            "(word32 *)output",
            "(const word32 *)input"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HasSSE2",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "HasSSE2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "123-128",
          "snippet": "inline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B::ToEnum",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ToEnum",
          "container": "EnumToType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "102-102",
          "snippet": "static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nEnumToType {\n  static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  void PanamaCipherPolicy<B>::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)\n  {\n  #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n  \tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n  \t\tPanama_SSE2_Pull(iterationCount, this->m_state, (word32 *)output, (const word32 *)input);\n  \telse\n  #endif\n  \t\tthis->Iterate(iterationCount, NULL, output, input, operation);\n  }\n}"
  },
  {
    "function_name": "GetAlignment",
    "container": "PanamaCipherPolicy<B>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
    "lines": "476-484",
    "snippet": "unsigned int PanamaCipherPolicy<B>::GetAlignment() const\n{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n\t\treturn 16;\n\telse\n#endif\n\t\treturn 1;\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"panama.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HasSSE2",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "HasSSE2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "123-128",
          "snippet": "inline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B::ToEnum",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ToEnum",
          "container": "EnumToType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "102-102",
          "snippet": "static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nEnumToType {\n  static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  unsigned int PanamaCipherPolicy<B>::GetAlignment() const\n  {\n  #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n  \tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n  \t\treturn 16;\n  \telse\n  #endif\n  \t\treturn 1;\n  }\n}"
  },
  {
    "function_name": "CipherResynchronize",
    "container": "PanamaCipherPolicy<B>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
    "lines": "449-472",
    "snippet": "void PanamaCipherPolicy<B>::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n{\n\tassert(length==32);\n\tthis->Reset();\n\tthis->Iterate(1, m_key);\n\tif (iv && IsAligned<word32>(iv))\n\t\tthis->Iterate(1, (const word32 *)iv);\n\telse\n\t{\n\t\tFixedSizeSecBlock<word32, 8> buf;\n\t\tif (iv)\n\t\t\tmemcpy(buf, iv, 32);\n\t\telse\n\t\t\tmemset(buf, 0, 32);\n\t\tthis->Iterate(1, buf);\n\t}\n\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2() && !IsP4())\t\t// SSE2 code is slower on P4 Prescott\n\t\tPanama_SSE2_Pull(32, this->m_state, NULL, NULL);\n\telse\n#endif\n\t\tthis->Iterate(32);\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"panama.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->Iterate",
          "args": [
            "32"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Panama_SSE2_Pull",
          "args": [
            "32",
            "this->m_state",
            "NULL",
            "NULL"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsP4",
          "args": [],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "IsP4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "167-172",
          "snippet": "inline bool IsP4()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_isP4;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool IsP4()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_isP4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HasSSE2",
          "args": [],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "HasSSE2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "123-128",
          "snippet": "inline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasSSE2()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSE2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "B::ToEnum",
          "args": [],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ToEnum",
          "container": "EnumToType",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "102-102",
          "snippet": "static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nEnumToType {\n  static ENUM_TYPE ToEnum() {return (ENUM_TYPE)VALUE;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->Iterate",
          "args": [
            "1",
            "buf"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "32"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "iv",
            "32"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->Iterate",
          "args": [
            "1",
            "(const word32 *)iv"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAligned<word32>",
          "args": [
            "iv"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->Iterate",
          "args": [
            "1",
            "m_key"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->Reset",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "Reset",
          "container": "Panama<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "16-22",
          "snippet": "void Panama<B>::Reset()\n{\n\tmemset(m_state, 0, m_state.SizeInBytes());\n#if CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE\n\tm_state[17] = HasSSSE3();\n#endif\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanama<B> {\n  void Panama<B>::Reset()\n  {\n  \tmemset(m_state, 0, m_state.SizeInBytes());\n  #if CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE\n  \tm_state[17] = HasSSSE3();\n  #endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length==32"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  void PanamaCipherPolicy<B>::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n  {\n  \tassert(length==32);\n  \tthis->Reset();\n  \tthis->Iterate(1, m_key);\n  \tif (iv && IsAligned<word32>(iv))\n  \t\tthis->Iterate(1, (const word32 *)iv);\n  \telse\n  \t{\n  \t\tFixedSizeSecBlock<word32, 8> buf;\n  \t\tif (iv)\n  \t\t\tmemcpy(buf, iv, 32);\n  \t\telse\n  \t\t\tmemset(buf, 0, 32);\n  \t\tthis->Iterate(1, buf);\n  \t}\n  \n  #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n  \tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2() && !IsP4())\t\t// SSE2 code is slower on P4 Prescott\n  \t\tPanama_SSE2_Pull(32, this->m_state, NULL, NULL);\n  \telse\n  #endif\n  \t\tthis->Iterate(32);\n  }\n}"
  },
  {
    "function_name": "CipherSetKey",
    "container": "PanamaCipherPolicy<B>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
    "lines": "442-446",
    "snippet": "void PanamaCipherPolicy<B>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)\n{\n\tassert(length==32);\n\tmemcpy(m_key, key, 32);\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"panama.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_key",
            "key",
            "32"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length==32"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  void PanamaCipherPolicy<B>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)\n  {\n  \tassert(length==32);\n  \tmemcpy(m_key, key, 32);\n  }\n}"
  },
  {
    "function_name": "TruncatedFinal",
    "container": "PanamaHash<B>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
    "lines": "422-438",
    "snippet": "void PanamaHash<B>::TruncatedFinal(byte *hash, size_t size)\n{\n\tthis->ThrowIfInvalidTruncatedSize(size);\n\n\tthis->PadLastBlock(this->BLOCKSIZE, 0x01);\n\t\n\tHashEndianCorrectedBlock(this->m_data);\n\n\tthis->Iterate(32);\t// pull\n\n\tFixedSizeSecBlock<word32, 8> buf;\n\tthis->Iterate(1, NULL, buf.BytePtr(), NULL);\n\n\tmemcpy(hash, buf, size);\n\n\tthis->Restart();\t\t// reinit for next use\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"panama.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->Restart",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "Restart",
          "container": "HermeticHashFunctionMAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.h",
          "lines": "55-59",
          "snippet": "void Restart()\n\t{\n\t\tm_hash.Restart();\n\t\tm_keyed = false;\n\t}",
          "includes": [
            "#include \"iterhash.h\"",
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"iterhash.h\"\n#include \"strciphr.h\"\n\nHermeticHashFunctionMAC {\n  void Restart()\n  \t{\n  \t\tm_hash.Restart();\n  \t\tm_keyed = false;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "hash",
            "buf",
            "size"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->Iterate",
          "args": [
            "1",
            "NULL",
            "buf.BytePtr()",
            "NULL"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "Iterate",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "27-46",
          "snippet": "void CFB_ModePolicy::Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount)\n{\n\tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tassert(m_feedbackSize == BlockSize());\n\n\tunsigned int s = BlockSize();\n\tif (dir == ENCRYPTION)\n\t{\n\t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n\t\tm_cipher->AdvancedProcessBlocks(output, input+s, output+s, (iterationCount-1)*s, 0);\n\t\tmemcpy(m_register, output+(iterationCount-1)*s, s);\n\t}\n\telse\n\t{\n\t\tmemcpy(m_temp, input+(iterationCount-1)*s, s);\t// make copy first in case of in-place decryption\n\t\tm_cipher->AdvancedProcessBlocks(input, input+s, output+s, (iterationCount-1)*s, BlockTransformation::BT_ReverseDirection);\n\t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n\t\tmemcpy(m_register, m_temp, s);\n\t}\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount)\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tassert(m_feedbackSize == BlockSize());\n  \n  \tunsigned int s = BlockSize();\n  \tif (dir == ENCRYPTION)\n  \t{\n  \t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n  \t\tm_cipher->AdvancedProcessBlocks(output, input+s, output+s, (iterationCount-1)*s, 0);\n  \t\tmemcpy(m_register, output+(iterationCount-1)*s, s);\n  \t}\n  \telse\n  \t{\n  \t\tmemcpy(m_temp, input+(iterationCount-1)*s, s);\t// make copy first in case of in-place decryption\n  \t\tm_cipher->AdvancedProcessBlocks(input, input+s, output+s, (iterationCount-1)*s, BlockTransformation::BT_ReverseDirection);\n  \t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n  \t\tmemcpy(m_register, m_temp, s);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buf.BytePtr",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->Iterate",
          "args": [
            "32"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashEndianCorrectedBlock",
          "args": [
            "this->m_data"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "HashEndianCorrectedBlock",
          "container": "PanamaHash",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.h",
          "lines": "38-38",
          "snippet": "void HashEndianCorrectedBlock(const word32 *data) {this->Iterate(1, data);}",
          "includes": [
            "#include \"iterhash.h\"",
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"iterhash.h\"\n#include \"strciphr.h\"\n\nPanamaHash {\n  void HashEndianCorrectedBlock(const word32 *data) {this->Iterate(1, data);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->PadLastBlock",
          "args": [
            "this->BLOCKSIZE",
            "0x01"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "PadLastBlock",
          "container": "IteratedHashBase<T, BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
          "lines": "103-118",
          "snippet": "void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tunsigned int num = ModPowerOf2(m_countLo, blockSize);\n\tT* dataBuf = this->DataBuf();\n\tbyte* data = (byte *)dataBuf;\n\tdata[num++] = padFirst;\n\tif (num <= lastBlockSize)\n\t\tmemset(data+num, 0, lastBlockSize-num);\n\telse\n\t{\n\t\tmemset(data+num, 0, blockSize-num);\n\t\tHashBlock(dataBuf);\n\t\tmemset(data, 0, lastBlockSize);\n\t}\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)\n  {\n  \tunsigned int blockSize = this->BlockSize();\n  \tunsigned int num = ModPowerOf2(m_countLo, blockSize);\n  \tT* dataBuf = this->DataBuf();\n  \tbyte* data = (byte *)dataBuf;\n  \tdata[num++] = padFirst;\n  \tif (num <= lastBlockSize)\n  \t\tmemset(data+num, 0, lastBlockSize-num);\n  \telse\n  \t{\n  \t\tmemset(data+num, 0, blockSize-num);\n  \t\tHashBlock(dataBuf);\n  \t\tmemset(data, 0, lastBlockSize);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->ThrowIfInvalidTruncatedSize",
          "args": [
            "size"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ThrowIfInvalidTruncatedSize",
          "container": "HashTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "309-313",
          "snippet": "void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n{\n\tif (size > DigestSize())\n\t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nHashTransformation {\n  void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n  {\n  \tif (size > DigestSize())\n  \t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaHash<B> {\n  void PanamaHash<B>::TruncatedFinal(byte *hash, size_t size)\n  {\n  \tthis->ThrowIfInvalidTruncatedSize(size);\n  \n  \tthis->PadLastBlock(this->BLOCKSIZE, 0x01);\n  \t\n  \tHashEndianCorrectedBlock(this->m_data);\n  \n  \tthis->Iterate(32);\t// pull\n  \n  \tFixedSizeSecBlock<word32, 8> buf;\n  \tthis->Iterate(1, NULL, buf.BytePtr(), NULL);\n  \n  \tmemcpy(hash, buf, size);\n  \n  \tthis->Restart();\t\t// reinit for next use\n  }\n}"
  },
  {
    "function_name": "HashMultipleBlocks",
    "container": "PanamaHash<B>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
    "lines": "415-419",
    "snippet": "size_t PanamaHash<B>::HashMultipleBlocks(const word32 *input, size_t length)\n{\n\tthis->Iterate(length / this->BLOCKSIZE, input);\n\treturn length % this->BLOCKSIZE;\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"panama.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->Iterate",
          "args": [
            "length / this->BLOCKSIZE",
            "input"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaHash<B> {\n  size_t PanamaHash<B>::HashMultipleBlocks(const word32 *input, size_t length)\n  {\n  \tthis->Iterate(length / this->BLOCKSIZE, input);\n  \treturn length % this->BLOCKSIZE;\n  }\n}"
  },
  {
    "function_name": "Iterate",
    "container": "Panama<B>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
    "lines": "318-411",
    "snippet": "void Panama<B>::Iterate(size_t count, const word32 *p, byte *output, const byte *input, KeystreamOperation operation)\n{\n\tword32 bstart = m_state[17];\n\tword32 *const aPtr = m_state;\n\tword32 cPtr[17];\n\n#define bPtr ((byte *)(aPtr+20))\n\n// reorder the state for SSE2\n// a and c: 4 8 12 16 | 3 7 11 15 | 2 6 10 14 | 1 5 9 13 | 0\n//\t\t\txmm0\t\txmm1\t\txmm2\t\txmm3\t\teax\n#define a(i) aPtr[((i)*13+16) % 17]\t\t// 13 is inverse of 4 mod 17\n#define c(i) cPtr[((i)*13+16) % 17]\n// b: 0 4 | 1 5 | 2 6 | 3 7\n#define b(i, j) b##i[(j)*2%8 + (j)/4]\n\n// buffer update\n#define US(i) {word32 t=b(0,i); b(0,i)=ConditionalByteReverse(B::ToEnum(), p[i])^t; b(25,(i+6)%8)^=t;}\n#define UL(i) {word32 t=b(0,i); b(0,i)=a(i+1)^t; b(25,(i+6)%8)^=t;}\n// gamma and pi\n#define GP(i) c(5*i%17) = rotlFixed(a(i) ^ (a((i+1)%17) | ~a((i+2)%17)), ((5*i%17)*((5*i%17)+1)/2)%32)\n// theta and sigma\n#define T(i,x) a(i) = c(i) ^ c((i+1)%17) ^ c((i+4)%17) ^ x\n#define TS1S(i) T(i+1, ConditionalByteReverse(B::ToEnum(), p[i]))\n#define TS1L(i) T(i+1, b(4,i))\n#define TS2(i) T(i+9, b(16,i))\n\n\twhile (count--)\n\t{\n\t\tif (output)\n\t\t{\n#define PANAMA_OUTPUT(x)\t\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 0, a(0+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 1, a(1+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 2, a(2+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 3, a(3+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 4, a(4+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 5, a(5+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 6, a(6+9));\\\n\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 7, a(7+9));\n\n\t\t\ttypedef word32 WordType;\n\t\t\tCRYPTOPP_KEYSTREAM_OUTPUT_SWITCH(PANAMA_OUTPUT, 4*8);\n\t\t}\n\n\t\tword32 *const b16 = (word32 *)(bPtr+((bstart+16*32) & 31*32));\n\t\tword32 *const b4 = (word32 *)(bPtr+((bstart+(32-4)*32) & 31*32));\n       \tbstart += 32;\n\t\tword32 *const b0 = (word32 *)(bPtr+((bstart) & 31*32));\n\t\tword32 *const b25 = (word32 *)(bPtr+((bstart+(32-25)*32) & 31*32));\n\n\t\tif (p)\n\t\t{\n\t\t\tUS(0); US(1); US(2); US(3); US(4); US(5); US(6); US(7);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tUL(0); UL(1); UL(2); UL(3); UL(4); UL(5); UL(6); UL(7);\n\t\t}\n\n\t\tGP(0); \n\t\tGP(1); \n\t\tGP(2); \n\t\tGP(3); \n\t\tGP(4); \n\t\tGP(5); \n\t\tGP(6); \n\t\tGP(7);\n\t\tGP(8); \n\t\tGP(9); \n\t\tGP(10); \n\t\tGP(11); \n\t\tGP(12); \n\t\tGP(13); \n\t\tGP(14); \n\t\tGP(15); \n\t\tGP(16);\n\n\t\tT(0,1);\n\n\t\tif (p)\n\t\t{\n\t\t\tTS1S(0); TS1S(1); TS1S(2); TS1S(3); TS1S(4); TS1S(5); TS1S(6); TS1S(7);\n\t\t\tp += 8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTS1L(0); TS1L(1); TS1L(2); TS1L(3); TS1L(4); TS1L(5); TS1L(6); TS1L(7);\n\t\t}\n\n\t\tTS2(0); TS2(1); TS2(2); TS2(3); TS2(4); TS2(5); TS2(6); TS2(7);\n\t}\n\tm_state[17] = bstart;\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"panama.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [
      "#define bPtr ((byte *)(aPtr+20))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TS2",
          "args": [
            "7"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS2",
          "args": [
            "6"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS2",
          "args": [
            "5"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS2",
          "args": [
            "4"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS2",
          "args": [
            "3"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS2",
          "args": [
            "2"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS2",
          "args": [
            "1"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS2",
          "args": [
            "0"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1L",
          "args": [
            "7"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1L",
          "args": [
            "6"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1L",
          "args": [
            "5"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1L",
          "args": [
            "4"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1L",
          "args": [
            "3"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1L",
          "args": [
            "2"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1L",
          "args": [
            "1"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1L",
          "args": [
            "0"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1S",
          "args": [
            "7"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1S",
          "args": [
            "6"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1S",
          "args": [
            "5"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1S",
          "args": [
            "4"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1S",
          "args": [
            "3"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1S",
          "args": [
            "2"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1S",
          "args": [
            "1"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS1S",
          "args": [
            "0"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T",
          "args": [
            "0",
            "1"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "TruncatedFinal",
          "container": "PanamaHash<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "422-438",
          "snippet": "void PanamaHash<B>::TruncatedFinal(byte *hash, size_t size)\n{\n\tthis->ThrowIfInvalidTruncatedSize(size);\n\n\tthis->PadLastBlock(this->BLOCKSIZE, 0x01);\n\t\n\tHashEndianCorrectedBlock(this->m_data);\n\n\tthis->Iterate(32);\t// pull\n\n\tFixedSizeSecBlock<word32, 8> buf;\n\tthis->Iterate(1, NULL, buf.BytePtr(), NULL);\n\n\tmemcpy(hash, buf, size);\n\n\tthis->Restart();\t\t// reinit for next use\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaHash<B> {\n  void PanamaHash<B>::TruncatedFinal(byte *hash, size_t size)\n  {\n  \tthis->ThrowIfInvalidTruncatedSize(size);\n  \n  \tthis->PadLastBlock(this->BLOCKSIZE, 0x01);\n  \t\n  \tHashEndianCorrectedBlock(this->m_data);\n  \n  \tthis->Iterate(32);\t// pull\n  \n  \tFixedSizeSecBlock<word32, 8> buf;\n  \tthis->Iterate(1, NULL, buf.BytePtr(), NULL);\n  \n  \tmemcpy(hash, buf, size);\n  \n  \tthis->Restart();\t\t// reinit for next use\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GP",
          "args": [
            "16"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "OpenPGPDecode",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3192-3198",
          "snippet": "void Integer::OpenPGPDecode(BufferedTransformation &bt)\n{\n\tword16 bitCount;\n\tif (bt.GetWord16(bitCount) != 2 || bt.MaxRetrievable() < BitsToBytes(bitCount))\n\t\tthrow OpenPGPDecodeErr();\n\tDecode(bt, BitsToBytes(bitCount));\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::OpenPGPDecode(BufferedTransformation &bt)\n  {\n  \tword16 bitCount;\n  \tif (bt.GetWord16(bitCount) != 2 || bt.MaxRetrievable() < BitsToBytes(bitCount))\n  \t\tthrow OpenPGPDecodeErr();\n  \tDecode(bt, BitsToBytes(bitCount));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UL",
          "args": [
            "7"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UL",
          "args": [
            "6"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UL",
          "args": [
            "5"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UL",
          "args": [
            "4"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UL",
          "args": [
            "3"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UL",
          "args": [
            "2"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UL",
          "args": [
            "1"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UL",
          "args": [
            "0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "US",
          "args": [
            "7"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "US",
          "args": [
            "6"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "US",
          "args": [
            "5"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "US",
          "args": [
            "4"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "US",
          "args": [
            "3"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "US",
          "args": [
            "2"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "US",
          "args": [
            "1"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "US",
          "args": [
            "0"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_KEYSTREAM_OUTPUT_SWITCH",
          "args": [
            "PANAMA_OUTPUT",
            "4*8"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\n#define bPtr ((byte *)(aPtr+20))\n\nPanama<B> {\n  void Panama<B>::Iterate(size_t count, const word32 *p, byte *output, const byte *input, KeystreamOperation operation)\n  {\n  \tword32 bstart = m_state[17];\n  \tword32 *const aPtr = m_state;\n  \tword32 cPtr[17];\n  \n  #define bPtr ((byte *)(aPtr+20))\n  \n  // reorder the state for SSE2\n  // a and c: 4 8 12 16 | 3 7 11 15 | 2 6 10 14 | 1 5 9 13 | 0\n  //\t\t\txmm0\t\txmm1\t\txmm2\t\txmm3\t\teax\n  #define a(i) aPtr[((i)*13+16) % 17]\t\t// 13 is inverse of 4 mod 17\n  #define c(i) cPtr[((i)*13+16) % 17]\n  // b: 0 4 | 1 5 | 2 6 | 3 7\n  #define b(i, j) b##i[(j)*2%8 + (j)/4]\n  \n  // buffer update\n  #define US(i) {word32 t=b(0,i); b(0,i)=ConditionalByteReverse(B::ToEnum(), p[i])^t; b(25,(i+6)%8)^=t;}\n  #define UL(i) {word32 t=b(0,i); b(0,i)=a(i+1)^t; b(25,(i+6)%8)^=t;}\n  // gamma and pi\n  #define GP(i) c(5*i%17) = rotlFixed(a(i) ^ (a((i+1)%17) | ~a((i+2)%17)), ((5*i%17)*((5*i%17)+1)/2)%32)\n  // theta and sigma\n  #define T(i,x) a(i) = c(i) ^ c((i+1)%17) ^ c((i+4)%17) ^ x\n  #define TS1S(i) T(i+1, ConditionalByteReverse(B::ToEnum(), p[i]))\n  #define TS1L(i) T(i+1, b(4,i))\n  #define TS2(i) T(i+9, b(16,i))\n  \n  \twhile (count--)\n  \t{\n  \t\tif (output)\n  \t\t{\n  #define PANAMA_OUTPUT(x)\t\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 0, a(0+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 1, a(1+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 2, a(2+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 3, a(3+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 4, a(4+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 5, a(5+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 6, a(6+9));\\\n  \tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 7, a(7+9));\n  \n  \t\t\ttypedef word32 WordType;\n  \t\t\tCRYPTOPP_KEYSTREAM_OUTPUT_SWITCH(PANAMA_OUTPUT, 4*8);\n  \t\t}\n  \n  \t\tword32 *const b16 = (word32 *)(bPtr+((bstart+16*32) & 31*32));\n  \t\tword32 *const b4 = (word32 *)(bPtr+((bstart+(32-4)*32) & 31*32));\n         \tbstart += 32;\n  \t\tword32 *const b0 = (word32 *)(bPtr+((bstart) & 31*32));\n  \t\tword32 *const b25 = (word32 *)(bPtr+((bstart+(32-25)*32) & 31*32));\n  \n  \t\tif (p)\n  \t\t{\n  \t\t\tUS(0); US(1); US(2); US(3); US(4); US(5); US(6); US(7);\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tUL(0); UL(1); UL(2); UL(3); UL(4); UL(5); UL(6); UL(7);\n  \t\t}\n  \n  \t\tGP(0); \n  \t\tGP(1); \n  \t\tGP(2); \n  \t\tGP(3); \n  \t\tGP(4); \n  \t\tGP(5); \n  \t\tGP(6); \n  \t\tGP(7);\n  \t\tGP(8); \n  \t\tGP(9); \n  \t\tGP(10); \n  \t\tGP(11); \n  \t\tGP(12); \n  \t\tGP(13); \n  \t\tGP(14); \n  \t\tGP(15); \n  \t\tGP(16);\n  \n  \t\tT(0,1);\n  \n  \t\tif (p)\n  \t\t{\n  \t\t\tTS1S(0); TS1S(1); TS1S(2); TS1S(3); TS1S(4); TS1S(5); TS1S(6); TS1S(7);\n  \t\t\tp += 8;\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tTS1L(0); TS1L(1); TS1L(2); TS1L(3); TS1L(4); TS1L(5); TS1L(6); TS1L(7);\n  \t\t}\n  \n  \t\tTS2(0); TS2(1); TS2(2); TS2(3); TS2(4); TS2(5); TS2(6); TS2(7);\n  \t}\n  \tm_state[17] = bstart;\n  }\n}"
  },
  {
    "function_name": "Reset",
    "container": "Panama<B>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
    "lines": "16-22",
    "snippet": "void Panama<B>::Reset()\n{\n\tmemset(m_state, 0, m_state.SizeInBytes());\n#if CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE\n\tm_state[17] = HasSSSE3();\n#endif\n}",
    "includes": [
      "#include \"cpu.h\"",
      "#include \"misc.h\"",
      "#include \"panama.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "HasSSSE3",
          "args": [],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "HasSSSE3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cpu.h",
          "lines": "146-151",
          "snippet": "inline bool HasSSSE3()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSSE3;\n}",
          "includes": [
            "#include <wmmintrin.h>",
            "#include <smmintrin.h>",
            "#include <tmmintrin.h>",
            "#include <emmintrin.h>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <wmmintrin.h>\n#include <smmintrin.h>\n#include <tmmintrin.h>\n#include <emmintrin.h>\n#include \"config.h\"\n\ninline bool HasSSSE3()\n{\n\tif (!g_x86DetectionDone)\n\t\tDetectX86Features();\n\treturn g_hasSSSE3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "m_state",
            "0",
            "m_state.SizeInBytes()"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_state.SizeInBytes",
          "args": [],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "SizeInBytes",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "307-307",
          "snippet": "size_type SizeInBytes() const {return m_size*sizeof(T);}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  size_type SizeInBytes() const {return m_size*sizeof(T);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanama<B> {\n  void Panama<B>::Reset()\n  {\n  \tmemset(m_state, 0, m_state.SizeInBytes());\n  #if CRYPTOPP_BOOL_SSSE3_ASM_AVAILABLE\n  \tm_state[17] = HasSSSE3();\n  #endif\n  }\n}"
  }
]