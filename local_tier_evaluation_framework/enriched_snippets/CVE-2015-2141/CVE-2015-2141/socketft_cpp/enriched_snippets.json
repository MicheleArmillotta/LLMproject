[
  {
    "function_name": "SocketSender::GetWaitObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "522-525",
    "snippet": "void SocketSender::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tcontainer.AddWriteFd(m_s, CallStack(\"SocketSender::GetWaitObjects()\", &callStack));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.AddWriteFd",
          "args": [
            "m_s",
            "CallStack(\"SocketSender::GetWaitObjects()\", &callStack)"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"SocketSender::GetWaitObjects()\"",
            "&callStack"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid SocketSender::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tcontainer.AddWriteFd(m_s, CallStack(\"SocketSender::GetWaitObjects()\", &callStack));\n}"
  },
  {
    "function_name": "SocketSender::GetSendResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "517-520",
    "snippet": "unsigned int SocketSender::GetSendResult()\n{\n\treturn m_lastResult;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nunsigned int SocketSender::GetSendResult()\n{\n\treturn m_lastResult;\n}"
  },
  {
    "function_name": "SocketSender::SendEof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "512-515",
    "snippet": "void SocketSender::SendEof()\n{\n\tm_s.ShutDown(SD_SEND);\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_s.ShutDown",
          "args": [
            "SD_SEND"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid SocketSender::SendEof()\n{\n\tm_s.ShutDown(SD_SEND);\n}"
  },
  {
    "function_name": "SocketSender::Send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "507-510",
    "snippet": "void SocketSender::Send(const byte* buf, size_t bufLen)\n{\n\tm_lastResult = m_s.Send(buf, bufLen);\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_s.Send",
          "args": [
            "buf",
            "bufLen"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid SocketSender::Send(const byte* buf, size_t bufLen)\n{\n\tm_lastResult = m_s.Send(buf, bufLen);\n}"
  },
  {
    "function_name": "SocketSender::SocketSender",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "502-505",
    "snippet": "SocketSender::SocketSender(Socket &s)\n\t: m_s(s), m_lastResult(0)\n{\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocketSender::SocketSender(Socket &s)\n\t: m_s(s), m_lastResult(0)\n{\n}"
  },
  {
    "function_name": "SocketReceiver::GetReceiveResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "497-500",
    "snippet": "unsigned int SocketReceiver::GetReceiveResult()\n{\n\treturn m_lastResult;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nunsigned int SocketReceiver::GetReceiveResult()\n{\n\treturn m_lastResult;\n}"
  },
  {
    "function_name": "SocketReceiver::Receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "489-495",
    "snippet": "bool SocketReceiver::Receive(byte* buf, size_t bufLen)\n{\n\tm_lastResult = m_s.Receive(buf, bufLen);\n\tif (bufLen > 0 && m_lastResult == 0)\n\t\tm_eofReceived = true;\n\treturn true;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_s.Receive",
          "args": [
            "buf",
            "bufLen"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nbool SocketReceiver::Receive(byte* buf, size_t bufLen)\n{\n\tm_lastResult = m_s.Receive(buf, bufLen);\n\tif (bufLen > 0 && m_lastResult == 0)\n\t\tm_eofReceived = true;\n\treturn true;\n}"
  },
  {
    "function_name": "SocketReceiver::GetWaitObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "483-487",
    "snippet": "void SocketReceiver::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (!m_eofReceived)\n\t\tcontainer.AddReadFd(m_s, CallStack(\"SocketReceiver::GetWaitObjects()\", &callStack));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.AddReadFd",
          "args": [
            "m_s",
            "CallStack(\"SocketReceiver::GetWaitObjects()\", &callStack)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"SocketReceiver::GetWaitObjects()\"",
            "&callStack"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid SocketReceiver::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (!m_eofReceived)\n\t\tcontainer.AddReadFd(m_s, CallStack(\"SocketReceiver::GetWaitObjects()\", &callStack));\n}"
  },
  {
    "function_name": "SocketReceiver::SocketReceiver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "478-481",
    "snippet": "SocketReceiver::SocketReceiver(Socket &s)\n\t: m_s(s), m_eofReceived(false), m_lastResult(0)\n{\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocketReceiver::SocketReceiver(Socket &s)\n\t: m_s(s), m_eofReceived(false), m_lastResult(0)\n{\n}"
  },
  {
    "function_name": "SocketSender::GetSendResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "462-472",
    "snippet": "unsigned int SocketSender::GetSendResult()\n{\n\tif (m_resultPending)\n\t{\n\t\tDWORD flags = 0;\n\t\tBOOL result = WSAGetOverlappedResult(m_s, &m_overlapped, &m_lastResult, false, &flags);\n\t\tm_s.CheckAndHandleError(\"WSAGetOverlappedResult\", result);\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError",
          "args": [
            "\"WSAGetOverlappedResult\"",
            "result"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "97-98",
          "snippet": "void CheckAndHandleError(const char *operation, bool result) const\n\t\t{if (!result) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError(const char *operation, bool result) const\n  \t\t{if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAGetOverlappedResult",
          "args": [
            "m_s",
            "&m_overlapped",
            "&m_lastResult",
            "false",
            "&flags"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nunsigned int SocketSender::GetSendResult()\n{\n\tif (m_resultPending)\n\t{\n\t\tDWORD flags = 0;\n\t\tBOOL result = WSAGetOverlappedResult(m_s, &m_overlapped, &m_lastResult, false, &flags);\n\t\tm_s.CheckAndHandleError(\"WSAGetOverlappedResult\", result);\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult;\n}"
  },
  {
    "function_name": "SocketSender::GetWaitObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "454-460",
    "snippet": "void SocketSender::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (m_resultPending)\n\t\tcontainer.AddHandle(m_event, CallStack(\"SocketSender::GetWaitObjects() - result pending\", &callStack));\n\telse\n\t\tcontainer.SetNoWait(CallStack(\"SocketSender::GetWaitObjects() - result ready\", &callStack));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.SetNoWait",
          "args": [
            "CallStack(\"SocketSender::GetWaitObjects() - result ready\", &callStack)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"SocketSender::GetWaitObjects() - result ready\"",
            "&callStack"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container.AddHandle",
          "args": [
            "m_event",
            "CallStack(\"SocketSender::GetWaitObjects() - result pending\", &callStack)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid SocketSender::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (m_resultPending)\n\t\tcontainer.AddHandle(m_event, CallStack(\"SocketSender::GetWaitObjects() - result pending\", &callStack));\n\telse\n\t\tcontainer.SetNoWait(CallStack(\"SocketSender::GetWaitObjects() - result ready\", &callStack));\n}"
  },
  {
    "function_name": "SocketSender::EofSent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "439-452",
    "snippet": "bool SocketSender::EofSent()\n{\n\tif (m_resultPending)\n\t{\n\t\tWSANETWORKEVENTS events;\n\t\tm_s.CheckAndHandleError_int(\"WSAEnumNetworkEvents\", WSAEnumNetworkEvents(m_s, m_event, &events));\n\t\tif ((events.lNetworkEvents & FD_CLOSE) != FD_CLOSE)\n\t\t\tthrow Socket::Err(m_s, \"WSAEnumNetworkEvents (FD_CLOSE not present)\", E_FAIL);\n\t\tif (events.iErrorCode[FD_CLOSE_BIT] != 0)\n\t\t\tthrow Socket::Err(m_s, \"FD_CLOSE (via WSAEnumNetworkEvents)\", events.iErrorCode[FD_CLOSE_BIT]);\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult != 0;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Socket::Err",
          "args": [
            "m_s",
            "\"FD_CLOSE (via WSAEnumNetworkEvents)\"",
            "events.iErrorCode[FD_CLOSE_BIT]"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Socket::Err",
          "args": [
            "m_s",
            "\"WSAEnumNetworkEvents (FD_CLOSE not present)\"",
            "E_FAIL"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError_int",
          "args": [
            "\"WSAEnumNetworkEvents\"",
            "WSAEnumNetworkEvents(m_s, m_event, &events)"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAEnumNetworkEvents",
          "args": [
            "m_s",
            "m_event",
            "&events"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nbool SocketSender::EofSent()\n{\n\tif (m_resultPending)\n\t{\n\t\tWSANETWORKEVENTS events;\n\t\tm_s.CheckAndHandleError_int(\"WSAEnumNetworkEvents\", WSAEnumNetworkEvents(m_s, m_event, &events));\n\t\tif ((events.lNetworkEvents & FD_CLOSE) != FD_CLOSE)\n\t\t\tthrow Socket::Err(m_s, \"WSAEnumNetworkEvents (FD_CLOSE not present)\", E_FAIL);\n\t\tif (events.iErrorCode[FD_CLOSE_BIT] != 0)\n\t\t\tthrow Socket::Err(m_s, \"FD_CLOSE (via WSAEnumNetworkEvents)\", events.iErrorCode[FD_CLOSE_BIT]);\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult != 0;\n}"
  },
  {
    "function_name": "SocketSender::SendEof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "430-437",
    "snippet": "void SocketSender::SendEof()\n{\n\tassert(!m_resultPending);\n\tm_s.ShutDown(SD_SEND);\n\tm_s.CheckAndHandleError(\"ResetEvent\", ResetEvent(m_event));\n\tm_s.CheckAndHandleError_int(\"WSAEventSelect\", WSAEventSelect(m_s, m_event, FD_CLOSE));\n\tm_resultPending = true;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError_int",
          "args": [
            "\"WSAEventSelect\"",
            "WSAEventSelect(m_s, m_event, FD_CLOSE)"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAEventSelect",
          "args": [
            "m_s",
            "m_event",
            "FD_CLOSE"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError",
          "args": [
            "\"ResetEvent\"",
            "ResetEvent(m_event)"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "97-98",
          "snippet": "void CheckAndHandleError(const char *operation, bool result) const\n\t\t{if (!result) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError(const char *operation, bool result) const\n  \t\t{if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResetEvent",
          "args": [
            "m_event"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_s.ShutDown",
          "args": [
            "SD_SEND"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!m_resultPending"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid SocketSender::SendEof()\n{\n\tassert(!m_resultPending);\n\tm_s.ShutDown(SD_SEND);\n\tm_s.CheckAndHandleError(\"ResetEvent\", ResetEvent(m_event));\n\tm_s.CheckAndHandleError_int(\"WSAEventSelect\", WSAEventSelect(m_s, m_event, FD_CLOSE));\n\tm_resultPending = true;\n}"
  },
  {
    "function_name": "SocketSender::Send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "410-428",
    "snippet": "void SocketSender::Send(const byte* buf, size_t bufLen)\n{\n\tassert(!m_resultPending);\n\tDWORD written = 0;\n\t// don't queue too much at once, or we might use up non-paged memory\n\tWSABUF wsabuf = {UnsignedMin((u_long)128*1024, bufLen), (char *)buf};\n\tif (WSASend(m_s, &wsabuf, 1, &written, 0, &m_overlapped, NULL) == 0)\n\t{\n\t\tm_resultPending = false;\n\t\tm_lastResult = written;\n\t}\n\telse\n\t{\n\t\tif (WSAGetLastError() != WSA_IO_PENDING)\n\t\t\tm_s.CheckAndHandleError_int(\"WSASend\", SOCKET_ERROR);\n\n\t\tm_resultPending = true;\n\t}\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError_int",
          "args": [
            "\"WSASend\"",
            "SOCKET_ERROR"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSASend",
          "args": [
            "m_s",
            "&wsabuf",
            "1",
            "&written",
            "0",
            "&m_overlapped",
            "NULL"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "(u_long)128*1024",
            "bufLen"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!m_resultPending"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid SocketSender::Send(const byte* buf, size_t bufLen)\n{\n\tassert(!m_resultPending);\n\tDWORD written = 0;\n\t// don't queue too much at once, or we might use up non-paged memory\n\tWSABUF wsabuf = {UnsignedMin((u_long)128*1024, bufLen), (char *)buf};\n\tif (WSASend(m_s, &wsabuf, 1, &written, 0, &m_overlapped, NULL) == 0)\n\t{\n\t\tm_resultPending = false;\n\t\tm_lastResult = written;\n\t}\n\telse\n\t{\n\t\tif (WSAGetLastError() != WSA_IO_PENDING)\n\t\t\tm_s.CheckAndHandleError_int(\"WSASend\", SOCKET_ERROR);\n\n\t\tm_resultPending = true;\n\t}\n}"
  },
  {
    "function_name": "SocketSender::~SocketSender",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "403-408",
    "snippet": "SocketSender::~SocketSender()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tCancelIo((HANDLE) m_s.GetSocket());\n#endif\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CancelIo",
          "args": [
            "(HANDLE) m_s.GetSocket()"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_s.GetSocket",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "GetSocket",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "65-65",
          "snippet": "socket_t GetSocket() const {return m_s;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  socket_t GetSocket() const {return m_s;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocketSender::~SocketSender()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tCancelIo((HANDLE) m_s.GetSocket());\n#endif\n}"
  },
  {
    "function_name": "SocketSender::SocketSender",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "393-400",
    "snippet": "SocketSender::SocketSender(Socket &s)\n\t: m_s(s), m_resultPending(false), m_lastResult(0)\n{\n\tm_event.AttachHandle(CreateEvent(NULL, true, false, NULL), true);\n\tm_s.CheckAndHandleError(\"CreateEvent\", m_event.HandleValid());\n\tmemset(&m_overlapped, 0, sizeof(m_overlapped));\n\tm_overlapped.hEvent = m_event;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&m_overlapped",
            "0",
            "sizeof(m_overlapped)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError",
          "args": [
            "\"CreateEvent\"",
            "m_event.HandleValid()"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "97-98",
          "snippet": "void CheckAndHandleError(const char *operation, bool result) const\n\t\t{if (!result) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError(const char *operation, bool result) const\n  \t\t{if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_event.HandleValid",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_event.AttachHandle",
          "args": [
            "CreateEvent(NULL, true, false, NULL)",
            "true"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateEvent",
          "args": [
            "NULL",
            "true",
            "false",
            "NULL"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocketSender::SocketSender(Socket &s)\n\t: m_s(s), m_resultPending(false), m_lastResult(0)\n{\n\tm_event.AttachHandle(CreateEvent(NULL, true, false, NULL), true);\n\tm_s.CheckAndHandleError(\"CreateEvent\", m_event.HandleValid());\n\tmemset(&m_overlapped, 0, sizeof(m_overlapped));\n\tm_overlapped.hEvent = m_event;\n}"
  },
  {
    "function_name": "SocketReceiver::GetReceiveResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "365-389",
    "snippet": "unsigned int SocketReceiver::GetReceiveResult()\n{\n\tif (m_resultPending)\n\t{\n\t\tDWORD flags = 0;\n\t\tif (WSAGetOverlappedResult(m_s, &m_overlapped, &m_lastResult, false, &flags))\n\t\t{\n\t\t\tif (m_lastResult == 0)\n\t\t\t\tm_eofReceived = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (WSAGetLastError())\n\t\t\t{\n\t\t\tdefault:\n\t\t\t\tm_s.CheckAndHandleError(\"WSAGetOverlappedResult\", FALSE);\n\t\t\tcase WSAEDISCON:\n\t\t\t\tm_lastResult = 0;\n\t\t\t\tm_eofReceived = true;\n\t\t\t}\n\t\t}\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError",
          "args": [
            "\"WSAGetOverlappedResult\"",
            "FALSE"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "97-98",
          "snippet": "void CheckAndHandleError(const char *operation, bool result) const\n\t\t{if (!result) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError(const char *operation, bool result) const\n  \t\t{if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAGetOverlappedResult",
          "args": [
            "m_s",
            "&m_overlapped",
            "&m_lastResult",
            "false",
            "&flags"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nunsigned int SocketReceiver::GetReceiveResult()\n{\n\tif (m_resultPending)\n\t{\n\t\tDWORD flags = 0;\n\t\tif (WSAGetOverlappedResult(m_s, &m_overlapped, &m_lastResult, false, &flags))\n\t\t{\n\t\t\tif (m_lastResult == 0)\n\t\t\t\tm_eofReceived = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (WSAGetLastError())\n\t\t\t{\n\t\t\tdefault:\n\t\t\t\tm_s.CheckAndHandleError(\"WSAGetOverlappedResult\", FALSE);\n\t\t\tcase WSAEDISCON:\n\t\t\t\tm_lastResult = 0;\n\t\t\t\tm_eofReceived = true;\n\t\t\t}\n\t\t}\n\t\tm_resultPending = false;\n\t}\n\treturn m_lastResult;\n}"
  },
  {
    "function_name": "SocketReceiver::GetWaitObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "357-363",
    "snippet": "void SocketReceiver::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (m_resultPending)\n\t\tcontainer.AddHandle(m_event, CallStack(\"SocketReceiver::GetWaitObjects() - result pending\", &callStack));\n\telse if (!m_eofReceived)\n\t\tcontainer.SetNoWait(CallStack(\"SocketReceiver::GetWaitObjects() - result ready\", &callStack));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.SetNoWait",
          "args": [
            "CallStack(\"SocketReceiver::GetWaitObjects() - result ready\", &callStack)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"SocketReceiver::GetWaitObjects() - result ready\"",
            "&callStack"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container.AddHandle",
          "args": [
            "m_event",
            "CallStack(\"SocketReceiver::GetWaitObjects() - result pending\", &callStack)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid SocketReceiver::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (m_resultPending)\n\t\tcontainer.AddHandle(m_event, CallStack(\"SocketReceiver::GetWaitObjects() - result pending\", &callStack));\n\telse if (!m_eofReceived)\n\t\tcontainer.SetNoWait(CallStack(\"SocketReceiver::GetWaitObjects() - result ready\", &callStack));\n}"
  },
  {
    "function_name": "SocketReceiver::Receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "328-355",
    "snippet": "bool SocketReceiver::Receive(byte* buf, size_t bufLen)\n{\n\tassert(!m_resultPending && !m_eofReceived);\n\n\tDWORD flags = 0;\n\t// don't queue too much at once, or we might use up non-paged memory\n\tWSABUF wsabuf = {UnsignedMin((u_long)128*1024, bufLen), (char *)buf};\n\tif (WSARecv(m_s, &wsabuf, 1, &m_lastResult, &flags, &m_overlapped, NULL) == 0)\n\t{\n\t\tif (m_lastResult == 0)\n\t\t\tm_eofReceived = true;\n\t}\n\telse\n\t{\n\t\tswitch (WSAGetLastError())\n\t\t{\n\t\tdefault:\n\t\t\tm_s.CheckAndHandleError_int(\"WSARecv\", SOCKET_ERROR);\n\t\tcase WSAEDISCON:\n\t\t\tm_lastResult = 0;\n\t\t\tm_eofReceived = true;\n\t\t\tbreak;\n\t\tcase WSA_IO_PENDING:\n\t\t\tm_resultPending = true;\n\t\t}\n\t}\n\treturn !m_resultPending;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError_int",
          "args": [
            "\"WSARecv\"",
            "SOCKET_ERROR"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSARecv",
          "args": [
            "m_s",
            "&wsabuf",
            "1",
            "&m_lastResult",
            "&flags",
            "&m_overlapped",
            "NULL"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "(u_long)128*1024",
            "bufLen"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!m_resultPending && !m_eofReceived"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nbool SocketReceiver::Receive(byte* buf, size_t bufLen)\n{\n\tassert(!m_resultPending && !m_eofReceived);\n\n\tDWORD flags = 0;\n\t// don't queue too much at once, or we might use up non-paged memory\n\tWSABUF wsabuf = {UnsignedMin((u_long)128*1024, bufLen), (char *)buf};\n\tif (WSARecv(m_s, &wsabuf, 1, &m_lastResult, &flags, &m_overlapped, NULL) == 0)\n\t{\n\t\tif (m_lastResult == 0)\n\t\t\tm_eofReceived = true;\n\t}\n\telse\n\t{\n\t\tswitch (WSAGetLastError())\n\t\t{\n\t\tdefault:\n\t\t\tm_s.CheckAndHandleError_int(\"WSARecv\", SOCKET_ERROR);\n\t\tcase WSAEDISCON:\n\t\t\tm_lastResult = 0;\n\t\t\tm_eofReceived = true;\n\t\t\tbreak;\n\t\tcase WSA_IO_PENDING:\n\t\t\tm_resultPending = true;\n\t\t}\n\t}\n\treturn !m_resultPending;\n}"
  },
  {
    "function_name": "SocketReceiver::~SocketReceiver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "321-326",
    "snippet": "SocketReceiver::~SocketReceiver()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tCancelIo((HANDLE) m_s.GetSocket());\n#endif\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CancelIo",
          "args": [
            "(HANDLE) m_s.GetSocket()"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_s.GetSocket",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "GetSocket",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "65-65",
          "snippet": "socket_t GetSocket() const {return m_s;}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  socket_t GetSocket() const {return m_s;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocketReceiver::~SocketReceiver()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tCancelIo((HANDLE) m_s.GetSocket());\n#endif\n}"
  },
  {
    "function_name": "SocketReceiver::SocketReceiver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "312-319",
    "snippet": "SocketReceiver::SocketReceiver(Socket &s)\n\t: m_s(s), m_resultPending(false), m_eofReceived(false)\n{\n\tm_event.AttachHandle(CreateEvent(NULL, true, false, NULL), true);\n\tm_s.CheckAndHandleError(\"CreateEvent\", m_event.HandleValid());\n\tmemset(&m_overlapped, 0, sizeof(m_overlapped));\n\tm_overlapped.hEvent = m_event;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&m_overlapped",
            "0",
            "sizeof(m_overlapped)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_s.CheckAndHandleError",
          "args": [
            "\"CreateEvent\"",
            "m_event.HandleValid()"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "97-98",
          "snippet": "void CheckAndHandleError(const char *operation, bool result) const\n\t\t{if (!result) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError(const char *operation, bool result) const\n  \t\t{if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_event.HandleValid",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_event.AttachHandle",
          "args": [
            "CreateEvent(NULL, true, false, NULL)",
            "true"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateEvent",
          "args": [
            "NULL",
            "true",
            "false",
            "NULL"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocketReceiver::SocketReceiver(Socket &s)\n\t: m_s(s), m_resultPending(false), m_eofReceived(false)\n{\n\tm_event.AttachHandle(CreateEvent(NULL, true, false, NULL), true);\n\tm_s.CheckAndHandleError(\"CreateEvent\", m_event.HandleValid());\n\tmemset(&m_overlapped, 0, sizeof(m_overlapped));\n\tm_overlapped.hEvent = m_event;\n}"
  },
  {
    "function_name": "Socket::HandleError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "304-308",
    "snippet": "void Socket::HandleError(const char *operation) const\n{\n\tint err = GetLastError();\n\tthrow Err(m_s, operation, err);\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "m_s",
            "operation",
            "err"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::Err::Err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "30-34",
          "snippet": "Socket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::GetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nint Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::HandleError(const char *operation) const\n{\n\tint err = GetLastError();\n\tthrow Err(m_s, operation, err);\n}"
  },
  {
    "function_name": "Socket::SetLastError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "295-302",
    "snippet": "void Socket::SetLastError(int errorCode)\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tWSASetLastError(errorCode);\n#else\n\terrno = errorCode;\n#endif\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSASetLastError",
          "args": [
            "errorCode"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::SetLastError(int errorCode)\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tWSASetLastError(errorCode);\n#else\n\terrno = errorCode;\n#endif\n}"
  },
  {
    "function_name": "Socket::GetLastError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "286-293",
    "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nint Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}"
  },
  {
    "function_name": "Socket::ShutdownSockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "277-284",
    "snippet": "void Socket::ShutdownSockets()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tint result = WSACleanup();\n\tif (result != 0)\n\t\tthrow Err(INVALID_SOCKET, \"WSACleanup\", result);\n#endif\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "INVALID_SOCKET",
            "\"WSACleanup\"",
            "result"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::Err::Err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "30-34",
          "snippet": "Socket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSACleanup",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::ShutdownSockets()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tint result = WSACleanup();\n\tif (result != 0)\n\t\tthrow Err(INVALID_SOCKET, \"WSACleanup\", result);\n#endif\n}"
  },
  {
    "function_name": "Socket::StartSockets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "267-275",
    "snippet": "void Socket::StartSockets()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tWSADATA wsd;\n\tint result = WSAStartup(0x0202, &wsd);\n\tif (result != 0)\n\t\tthrow Err(INVALID_SOCKET, \"WSAStartup\", result);\n#endif\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "INVALID_SOCKET",
            "\"WSAStartup\"",
            "result"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::Err::Err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "30-34",
          "snippet": "Socket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAStartup",
          "args": [
            "0x0202",
            "&wsd"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::StartSockets()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tWSADATA wsd;\n\tint result = WSAStartup(0x0202, &wsd);\n\tif (result != 0)\n\t\tthrow Err(INVALID_SOCKET, \"WSAStartup\", result);\n#endif\n}"
  },
  {
    "function_name": "Socket::PortNameToNumber",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "255-265",
    "snippet": "unsigned int Socket::PortNameToNumber(const char *name, const char *protocol)\n{\n\tint port = atoi(name);\n\tif (IntToString(port) == name)\n\t\treturn port;\n\n\tservent *se = getservbyname(name, protocol);\n\tif (!se)\n\t\tthrow Err(INVALID_SOCKET, \"getservbyname\", SOCKET_EINVAL);\n\treturn ntohs(se->s_port);\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "se->s_port"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "INVALID_SOCKET",
            "\"getservbyname\"",
            "SOCKET_EINVAL"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::Err::Err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "30-34",
          "snippet": "Socket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "getservbyname",
          "args": [
            "name",
            "protocol"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "port"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "name"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nunsigned int Socket::PortNameToNumber(const char *name, const char *protocol)\n{\n\tint port = atoi(name);\n\tif (IntToString(port) == name)\n\t\treturn port;\n\n\tservent *se = getservbyname(name, protocol);\n\tif (!se)\n\t\tthrow Err(INVALID_SOCKET, \"getservbyname\", SOCKET_EINVAL);\n\treturn ntohs(se->s_port);\n}"
  },
  {
    "function_name": "Socket::ReceiveReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "238-253",
    "snippet": "bool Socket::ReceiveReady(const timeval *timeout)\n{\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(m_s, &fds);\n\tint ready;\n\tif (timeout == NULL)\n\t\tready = select((int)m_s+1, &fds, NULL, NULL, NULL);\n\telse\n\t{\n\t\ttimeval timeoutCopy = *timeout;\t// select() modified timeout on Linux\n\t\tready = select((int)m_s+1, &fds, NULL, NULL, &timeoutCopy);\n\t}\n\tCheckAndHandleError_int(\"select\", ready);\n\treturn ready > 0;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"select\"",
            "ready"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "(int)m_s+1",
            "&fds",
            "NULL",
            "NULL",
            "&timeoutCopy"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "(int)m_s+1",
            "&fds",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "m_s",
            "&fds"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nbool Socket::ReceiveReady(const timeval *timeout)\n{\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(m_s, &fds);\n\tint ready;\n\tif (timeout == NULL)\n\t\tready = select((int)m_s+1, &fds, NULL, NULL, NULL);\n\telse\n\t{\n\t\ttimeval timeoutCopy = *timeout;\t// select() modified timeout on Linux\n\t\tready = select((int)m_s+1, &fds, NULL, NULL, &timeoutCopy);\n\t}\n\tCheckAndHandleError_int(\"select\", ready);\n\treturn ready > 0;\n}"
  },
  {
    "function_name": "Socket::SendReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "221-236",
    "snippet": "bool Socket::SendReady(const timeval *timeout)\n{\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(m_s, &fds);\n\tint ready;\n\tif (timeout == NULL)\n\t\tready = select((int)m_s+1, NULL, &fds, NULL, NULL);\n\telse\n\t{\n\t\ttimeval timeoutCopy = *timeout;\t// select() modified timeout on Linux\n\t\tready = select((int)m_s+1, NULL, &fds, NULL, &timeoutCopy);\n\t}\n\tCheckAndHandleError_int(\"select\", ready);\n\treturn ready > 0;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"select\"",
            "ready"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "(int)m_s+1",
            "NULL",
            "&fds",
            "NULL",
            "&timeoutCopy"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "(int)m_s+1",
            "NULL",
            "&fds",
            "NULL",
            "NULL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "m_s",
            "&fds"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fds"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nbool Socket::SendReady(const timeval *timeout)\n{\n\tfd_set fds;\n\tFD_ZERO(&fds);\n\tFD_SET(m_s, &fds);\n\tint ready;\n\tif (timeout == NULL)\n\t\tready = select((int)m_s+1, NULL, &fds, NULL, NULL);\n\telse\n\t{\n\t\ttimeval timeoutCopy = *timeout;\t// select() modified timeout on Linux\n\t\tready = select((int)m_s+1, NULL, &fds, NULL, &timeoutCopy);\n\t}\n\tCheckAndHandleError_int(\"select\", ready);\n\treturn ready > 0;\n}"
  },
  {
    "function_name": "Socket::IOCtl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "211-219",
    "snippet": "void Socket::IOCtl(long cmd, unsigned long *argp)\n{\n\tassert(m_s != INVALID_SOCKET);\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tCheckAndHandleError_int(\"ioctlsocket\", ioctlsocket(m_s, cmd, argp));\n#else\n\tCheckAndHandleError_int(\"ioctl\", ioctl(m_s, cmd, argp));\n#endif\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"ioctl\"",
            "ioctl(m_s, cmd, argp)"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "m_s",
            "cmd",
            "argp"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctlsocket",
          "args": [
            "m_s",
            "cmd",
            "argp"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::IOCtl(long cmd, unsigned long *argp)\n{\n\tassert(m_s != INVALID_SOCKET);\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tCheckAndHandleError_int(\"ioctlsocket\", ioctlsocket(m_s, cmd, argp));\n#else\n\tCheckAndHandleError_int(\"ioctl\", ioctl(m_s, cmd, argp));\n#endif\n}"
  },
  {
    "function_name": "Socket::ShutDown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "204-209",
    "snippet": "void Socket::ShutDown(int how)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tint result = shutdown(m_s, how);\n\tCheckAndHandleError_int(\"shutdown\", result);\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"shutdown\"",
            "result"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "m_s",
            "how"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::ShutDown(int how)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tint result = shutdown(m_s, how);\n\tCheckAndHandleError_int(\"shutdown\", result);\n}"
  },
  {
    "function_name": "Socket::Receive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "196-202",
    "snippet": "unsigned int Socket::Receive(byte* buf, size_t bufLen, int flags)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tint result = recv(m_s, (char *)buf, UnsignedMin(INT_MAX, bufLen), flags);\n\tCheckAndHandleError_int(\"recv\", result);\n\treturn result;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"recv\"",
            "result"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "m_s",
            "(char *)buf",
            "UnsignedMin(INT_MAX, bufLen)",
            "flags"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "INT_MAX",
            "bufLen"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nunsigned int Socket::Receive(byte* buf, size_t bufLen, int flags)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tint result = recv(m_s, (char *)buf, UnsignedMin(INT_MAX, bufLen), flags);\n\tCheckAndHandleError_int(\"recv\", result);\n\treturn result;\n}"
  },
  {
    "function_name": "Socket::Send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "188-194",
    "snippet": "unsigned int Socket::Send(const byte* buf, size_t bufLen, int flags)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tint result = send(m_s, (const char *)buf, UnsignedMin(INT_MAX, bufLen), flags);\n\tCheckAndHandleError_int(\"send\", result);\n\treturn result;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"send\"",
            "result"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "m_s",
            "(const char *)buf",
            "UnsignedMin(INT_MAX, bufLen)",
            "flags"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "INT_MAX",
            "bufLen"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nunsigned int Socket::Send(const byte* buf, size_t bufLen, int flags)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tint result = send(m_s, (const char *)buf, UnsignedMin(INT_MAX, bufLen), flags);\n\tCheckAndHandleError_int(\"send\", result);\n\treturn result;\n}"
  },
  {
    "function_name": "Socket::GetPeerName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "182-186",
    "snippet": "void Socket::GetPeerName(sockaddr *psa, socklen_t *psaLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tCheckAndHandleError_int(\"getpeername\", getpeername(m_s, psa, psaLen));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"getpeername\"",
            "getpeername(m_s, psa, psaLen)"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "m_s",
            "psa",
            "psaLen"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::GetPeerName(sockaddr *psa, socklen_t *psaLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tCheckAndHandleError_int(\"getpeername\", getpeername(m_s, psa, psaLen));\n}"
  },
  {
    "function_name": "Socket::GetSockName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "176-180",
    "snippet": "void Socket::GetSockName(sockaddr *psa, socklen_t *psaLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tCheckAndHandleError_int(\"getsockname\", getsockname(m_s, psa, psaLen));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"getsockname\"",
            "getsockname(m_s, psa, psaLen)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "m_s",
            "psa",
            "psaLen"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::GetSockName(sockaddr *psa, socklen_t *psaLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tCheckAndHandleError_int(\"getsockname\", getsockname(m_s, psa, psaLen));\n}"
  },
  {
    "function_name": "Socket::Accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "165-174",
    "snippet": "bool Socket::Accept(Socket& target, sockaddr *psa, socklen_t *psaLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tsocket_t s = accept(m_s, psa, psaLen);\n\tif (s == INVALID_SOCKET && GetLastError() == SOCKET_EWOULDBLOCK)\n\t\treturn false;\n\tCheckAndHandleError(\"accept\", s);\n\ttarget.AttachSocket(s, true);\n\treturn true;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "target.AttachSocket",
          "args": [
            "s",
            "true"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckAndHandleError",
          "args": [
            "\"accept\"",
            "s"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "97-98",
          "snippet": "void CheckAndHandleError(const char *operation, bool result) const\n\t\t{if (!result) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError(const char *operation, bool result) const\n  \t\t{if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::GetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nint Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "m_s",
            "psa",
            "psaLen"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nbool Socket::Accept(Socket& target, sockaddr *psa, socklen_t *psaLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tsocket_t s = accept(m_s, psa, psaLen);\n\tif (s == INVALID_SOCKET && GetLastError() == SOCKET_EWOULDBLOCK)\n\t\treturn false;\n\tCheckAndHandleError(\"accept\", s);\n\ttarget.AttachSocket(s, true);\n\treturn true;\n}"
  },
  {
    "function_name": "Socket::Connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "155-163",
    "snippet": "bool Socket::Connect(const sockaddr* psa, socklen_t saLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tint result = connect(m_s, const_cast<sockaddr*>(psa), saLen);\n\tif (result == SOCKET_ERROR && GetLastError() == SOCKET_EWOULDBLOCK)\n\t\treturn false;\n\tCheckAndHandleError_int(\"connect\", result);\n\treturn true;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"connect\"",
            "result"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::GetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nint Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "m_s",
            "const_cast<sockaddr*>(psa)",
            "saLen"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<sockaddr*>",
          "args": [
            "psa"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nbool Socket::Connect(const sockaddr* psa, socklen_t saLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tint result = connect(m_s, const_cast<sockaddr*>(psa), saLen);\n\tif (result == SOCKET_ERROR && GetLastError() == SOCKET_EWOULDBLOCK)\n\t\treturn false;\n\tCheckAndHandleError_int(\"connect\", result);\n\treturn true;\n}"
  },
  {
    "function_name": "Socket::Connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "129-153",
    "snippet": "bool Socket::Connect(const char *addr, unsigned int port)\n{\n\tassert(addr != NULL);\n\n\tsockaddr_in sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sin_family = AF_INET;\n\tsa.sin_addr.s_addr = inet_addr(addr);\n\n\tif (sa.sin_addr.s_addr == static_cast<unsigned int>(-1))\t// Solaris doesn't have INADDR_NONE\n\t{\n\t\thostent *lphost = gethostbyname(addr);\n\t\tif (lphost == NULL)\n\t\t{\n\t\t\tSetLastError(SOCKET_EINVAL);\n\t\t\tCheckAndHandleError_int(\"gethostbyname\", SOCKET_ERROR);\n\t\t}\n\n\t\tsa.sin_addr.s_addr = ((in_addr *)lphost->h_addr)->s_addr;\n\t}\n\n\tsa.sin_port = htons((u_short)port);\n\n\treturn Connect((const sockaddr *)&sa, sizeof(sa));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "(u_short)port"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"gethostbyname\"",
            "SOCKET_ERROR"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetLastError",
          "args": [
            "SOCKET_EINVAL"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::SetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "295-302",
          "snippet": "void Socket::SetLastError(int errorCode)\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tWSASetLastError(errorCode);\n#else\n\terrno = errorCode;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::SetLastError(int errorCode)\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tWSASetLastError(errorCode);\n#else\n\terrno = errorCode;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "gethostbyname",
          "args": [
            "addr"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned int>",
          "args": [
            "-1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "addr"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sa",
            "0",
            "sizeof(sa)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "addr != NULL"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nbool Socket::Connect(const char *addr, unsigned int port)\n{\n\tassert(addr != NULL);\n\n\tsockaddr_in sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sin_family = AF_INET;\n\tsa.sin_addr.s_addr = inet_addr(addr);\n\n\tif (sa.sin_addr.s_addr == static_cast<unsigned int>(-1))\t// Solaris doesn't have INADDR_NONE\n\t{\n\t\thostent *lphost = gethostbyname(addr);\n\t\tif (lphost == NULL)\n\t\t{\n\t\t\tSetLastError(SOCKET_EINVAL);\n\t\t\tCheckAndHandleError_int(\"gethostbyname\", SOCKET_ERROR);\n\t\t}\n\n\t\tsa.sin_addr.s_addr = ((in_addr *)lphost->h_addr)->s_addr;\n\t}\n\n\tsa.sin_port = htons((u_short)port);\n\n\treturn Connect((const sockaddr *)&sa, sizeof(sa));\n}"
  },
  {
    "function_name": "Socket::Listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "123-127",
    "snippet": "void Socket::Listen(int backlog)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tCheckAndHandleError_int(\"listen\", listen(m_s, backlog));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"listen\"",
            "listen(m_s, backlog)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "m_s",
            "backlog"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::Listen(int backlog)\n{\n\tassert(m_s != INVALID_SOCKET);\n\tCheckAndHandleError_int(\"listen\", listen(m_s, backlog));\n}"
  },
  {
    "function_name": "Socket::Bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "116-121",
    "snippet": "void Socket::Bind(const sockaddr *psa, socklen_t saLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\t// cygwin workaround: needs const_cast\n\tCheckAndHandleError_int(\"bind\", bind(m_s, const_cast<sockaddr *>(psa), saLen));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"bind\"",
            "bind(m_s, const_cast<sockaddr *>(psa), saLen)"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "m_s",
            "const_cast<sockaddr *>(psa)",
            "saLen"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "const_cast<sockaddr *>",
          "args": [
            "psa"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s != INVALID_SOCKET"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::Bind(const sockaddr *psa, socklen_t saLen)\n{\n\tassert(m_s != INVALID_SOCKET);\n\t// cygwin workaround: needs const_cast\n\tCheckAndHandleError_int(\"bind\", bind(m_s, const_cast<sockaddr *>(psa), saLen));\n}"
  },
  {
    "function_name": "Socket::Bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "92-114",
    "snippet": "void Socket::Bind(unsigned int port, const char *addr)\n{\n\tsockaddr_in sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sin_family = AF_INET;\n\n\tif (addr == NULL)\n\t\tsa.sin_addr.s_addr = htonl(INADDR_ANY);\n\telse\n\t{\n\t\tunsigned long result = inet_addr(addr);\n\t\tif (result == static_cast<unsigned long>(-1))\t// Solaris doesn't have INADDR_NONE\n\t\t{\n\t\t\tSetLastError(SOCKET_EINVAL);\n\t\t\tCheckAndHandleError_int(\"inet_addr\", SOCKET_ERROR);\n\t\t}\n\t\tsa.sin_addr.s_addr = result;\n\t}\n\n\tsa.sin_port = htons((u_short)port);\n\n\tBind((sockaddr *)&sa, sizeof(sa));\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "(u_short)port"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"inet_addr\"",
            "SOCKET_ERROR"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetLastError",
          "args": [
            "SOCKET_EINVAL"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::SetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "295-302",
          "snippet": "void Socket::SetLastError(int errorCode)\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tWSASetLastError(errorCode);\n#else\n\terrno = errorCode;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::SetLastError(int errorCode)\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tWSASetLastError(errorCode);\n#else\n\terrno = errorCode;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned long>",
          "args": [
            "-1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_addr",
          "args": [
            "addr"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_ANY"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&sa",
            "0",
            "sizeof(sa)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::Bind(unsigned int port, const char *addr)\n{\n\tsockaddr_in sa;\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.sin_family = AF_INET;\n\n\tif (addr == NULL)\n\t\tsa.sin_addr.s_addr = htonl(INADDR_ANY);\n\telse\n\t{\n\t\tunsigned long result = inet_addr(addr);\n\t\tif (result == static_cast<unsigned long>(-1))\t// Solaris doesn't have INADDR_NONE\n\t\t{\n\t\t\tSetLastError(SOCKET_EINVAL);\n\t\t\tCheckAndHandleError_int(\"inet_addr\", SOCKET_ERROR);\n\t\t}\n\t\tsa.sin_addr.s_addr = result;\n\t}\n\n\tsa.sin_port = htons((u_short)port);\n\n\tBind((sockaddr *)&sa, sizeof(sa));\n}"
  },
  {
    "function_name": "Socket::CloseSocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "77-90",
    "snippet": "void Socket::CloseSocket()\n{\n\tif (m_s != INVALID_SOCKET)\n\t{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\t\tCancelIo((HANDLE) m_s);\n\t\tCheckAndHandleError_int(\"closesocket\", closesocket(m_s));\n#else\n\t\tCheckAndHandleError_int(\"close\", close(m_s));\n#endif\n\t\tm_s = INVALID_SOCKET;\n\t\tSocketChanged();\n\t}\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SocketChanged",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "SocketChanged",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "113-113",
          "snippet": "virtual void SocketChanged() {}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  virtual void SocketChanged() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckAndHandleError_int",
          "args": [
            "\"close\"",
            "close(m_s)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError_int",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "90-91",
          "snippet": "void CheckAndHandleError_int(const char *operation, int result) const\n\t\t{if (result == SOCKET_ERROR) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError_int(const char *operation, int result) const\n  \t\t{if (result == SOCKET_ERROR) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "m_s"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "m_s"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CancelIo",
          "args": [
            "(HANDLE) m_s"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::CloseSocket()\n{\n\tif (m_s != INVALID_SOCKET)\n\t{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\t\tCancelIo((HANDLE) m_s);\n\t\tCheckAndHandleError_int(\"closesocket\", closesocket(m_s));\n#else\n\t\tCheckAndHandleError_int(\"close\", close(m_s));\n#endif\n\t\tm_s = INVALID_SOCKET;\n\t\tSocketChanged();\n\t}\n}"
  },
  {
    "function_name": "Socket::Create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "68-75",
    "snippet": "void Socket::Create(int nType)\n{\n\tassert(m_s == INVALID_SOCKET);\n\tm_s = socket(AF_INET, nType, 0);\n\tCheckAndHandleError(\"socket\", m_s);\n\tm_own = true;\n\tSocketChanged();\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SocketChanged",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "SocketChanged",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "113-113",
          "snippet": "virtual void SocketChanged() {}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  virtual void SocketChanged() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckAndHandleError",
          "args": [
            "\"socket\"",
            "m_s"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "CheckAndHandleError",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "97-98",
          "snippet": "void CheckAndHandleError(const char *operation, bool result) const\n\t\t{if (!result) HandleError(operation);}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  void CheckAndHandleError(const char *operation, bool result) const\n  \t\t{if (!result) HandleError(operation);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "nType",
            "0"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_s == INVALID_SOCKET"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::Create(int nType)\n{\n\tassert(m_s == INVALID_SOCKET);\n\tm_s = socket(AF_INET, nType, 0);\n\tCheckAndHandleError(\"socket\", m_s);\n\tm_own = true;\n\tSocketChanged();\n}"
  },
  {
    "function_name": "Socket::DetachSocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "60-66",
    "snippet": "socket_t Socket::DetachSocket()\n{\n\tsocket_t s = m_s;\n\tm_s = INVALID_SOCKET;\n\tSocketChanged();\n\treturn s;\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SocketChanged",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "SocketChanged",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "113-113",
          "snippet": "virtual void SocketChanged() {}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  virtual void SocketChanged() {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nsocket_t Socket::DetachSocket()\n{\n\tsocket_t s = m_s;\n\tm_s = INVALID_SOCKET;\n\tSocketChanged();\n\treturn s;\n}"
  },
  {
    "function_name": "Socket::AttachSocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "50-58",
    "snippet": "void Socket::AttachSocket(socket_t s, bool own)\n{\n\tif (m_own)\n\t\tCloseSocket();\n\n\tm_s = s;\n\tm_own = own;\n\tSocketChanged();\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SocketChanged",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "SocketChanged",
          "container": "Socket",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.h",
          "lines": "113-113",
          "snippet": "virtual void SocketChanged() {}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include \"winpipes.h\"",
            "#include <winsock2.h>",
            "#include \"queue.h\"",
            "#include \"network.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include \"winpipes.h\"\n#include <winsock2.h>\n#include \"queue.h\"\n#include \"network.h\"\n#include \"config.h\"\n\nSocket {\n  virtual void SocketChanged() {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CloseSocket",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::CloseSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "77-90",
          "snippet": "void Socket::CloseSocket()\n{\n\tif (m_s != INVALID_SOCKET)\n\t{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\t\tCancelIo((HANDLE) m_s);\n\t\tCheckAndHandleError_int(\"closesocket\", closesocket(m_s));\n#else\n\t\tCheckAndHandleError_int(\"close\", close(m_s));\n#endif\n\t\tm_s = INVALID_SOCKET;\n\t\tSocketChanged();\n\t}\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::CloseSocket()\n{\n\tif (m_s != INVALID_SOCKET)\n\t{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\t\tCancelIo((HANDLE) m_s);\n\t\tCheckAndHandleError_int(\"closesocket\", closesocket(m_s));\n#else\n\t\tCheckAndHandleError_int(\"close\", close(m_s));\n#endif\n\t\tm_s = INVALID_SOCKET;\n\t\tSocketChanged();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::AttachSocket(socket_t s, bool own)\n{\n\tif (m_own)\n\t\tCloseSocket();\n\n\tm_s = s;\n\tm_own = own;\n\tSocketChanged();\n}"
  },
  {
    "function_name": "Socket::~Socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "36-48",
    "snippet": "Socket::~Socket()\n{\n\tif (m_own)\n\t{\n\t\ttry\n\t\t{\n\t\t\tCloseSocket();\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t}\n\t}\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CloseSocket",
          "args": [],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::CloseSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "77-90",
          "snippet": "void Socket::CloseSocket()\n{\n\tif (m_s != INVALID_SOCKET)\n\t{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\t\tCancelIo((HANDLE) m_s);\n\t\tCheckAndHandleError_int(\"closesocket\", closesocket(m_s));\n#else\n\t\tCheckAndHandleError_int(\"close\", close(m_s));\n#endif\n\t\tm_s = INVALID_SOCKET;\n\t\tSocketChanged();\n\t}\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nvoid Socket::CloseSocket()\n{\n\tif (m_s != INVALID_SOCKET)\n\t{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\t\tCancelIo((HANDLE) m_s);\n\t\tCheckAndHandleError_int(\"closesocket\", closesocket(m_s));\n#else\n\t\tCheckAndHandleError_int(\"close\", close(m_s));\n#endif\n\t\tm_s = INVALID_SOCKET;\n\t\tSocketChanged();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket::~Socket()\n{\n\tif (m_own)\n\t{\n\t\ttry\n\t\t{\n\t\t\tCloseSocket();\n\t\t}\n\t\tcatch (...)\n\t\t{\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "Socket::Err::Err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
    "lines": "30-34",
    "snippet": "Socket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}",
    "includes": [
      "#include <sys/ioctl.h>",
      "#include <netinet/in.h>",
      "#include <arpa/inet.h>",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <errno.h>",
      "#include \"wait.h\"",
      "#include \"socketft.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "error"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nSocket::Err::Err(socket_t s, const std::string& operation, int error)\n\t: OS_Error(IO_ERROR, \"Socket: \" + operation + \" operation failed with error \" + IntToString(error), operation, error)\n\t, m_s(s)\n{\n}"
  }
]