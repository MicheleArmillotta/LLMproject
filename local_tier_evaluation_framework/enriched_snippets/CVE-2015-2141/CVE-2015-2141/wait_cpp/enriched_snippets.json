[
  {
    "function_name": "Waitable::Wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "388-393",
    "snippet": "bool Waitable::Wait(unsigned long milliseconds, CallStack const& callStack)\n{\n\tWaitObjectContainer container;\n\tGetWaitObjects(container, callStack);\t// reduce clutter by not adding this func to stack\n\treturn container.Wait(milliseconds);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container.Wait",
          "args": [
            "milliseconds"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetWaitObjects",
          "args": [
            "container",
            "callStack"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "WindowsPipeSender::GetWaitObjects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/winpipes.cpp",
          "lines": "183-189",
          "snippet": "void WindowsPipeSender::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (m_resultPending)\n\t\tcontainer.AddHandle(m_event, CallStack(\"WindowsPipeSender::GetWaitObjects() - result pending\", &callStack));\n\telse\n\t\tcontainer.SetNoWait(CallStack(\"WindowsPipeSender::GetWaitObjects() - result ready\", &callStack));\n}",
          "includes": [
            "#include \"wait.h\"",
            "#include \"winpipes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wait.h\"\n#include \"winpipes.h\"\n#include \"pch.h\"\n\nvoid WindowsPipeSender::GetWaitObjects(WaitObjectContainer &container, CallStack const& callStack)\n{\n\tif (m_resultPending)\n\t\tcontainer.AddHandle(m_event, CallStack(\"WindowsPipeSender::GetWaitObjects() - result pending\", &callStack));\n\telse\n\t\tcontainer.SetNoWait(CallStack(\"WindowsPipeSender::GetWaitObjects() - result ready\", &callStack));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nbool Waitable::Wait(unsigned long milliseconds, CallStack const& callStack)\n{\n\tWaitObjectContainer container;\n\tGetWaitObjects(container, callStack);\t// reduce clutter by not adding this func to stack\n\treturn container.Wait(milliseconds);\n}"
  },
  {
    "function_name": "CallStackWithStr::Format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "383-386",
    "snippet": "std::string CallStackWithStr::Format() const\n{\n\treturn std::string(m_info) + \" / \" + std::string(m_z);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "m_z"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "m_info"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nstd::string CallStackWithStr::Format() const\n{\n\treturn std::string(m_info) + \" / \" + std::string(m_z);\n}"
  },
  {
    "function_name": "CallStackWithNr::Format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "378-381",
    "snippet": "std::string CallStackWithNr::Format() const\n{\n\treturn std::string(m_info) + \" / nr: \" + IntToString(m_nr);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "m_nr"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "m_info"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nstd::string CallStackWithNr::Format() const\n{\n\treturn std::string(m_info) + \" / nr: \" + IntToString(m_nr);\n}"
  },
  {
    "function_name": "CallStack::Format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "373-376",
    "snippet": "std::string CallStack::Format() const\n{\n\treturn m_info;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nstd::string CallStack::Format() const\n{\n\treturn m_info;\n}"
  },
  {
    "function_name": "WaitObjectContainer::Wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "331-367",
    "snippet": "bool WaitObjectContainer::Wait(unsigned long milliseconds)\n{\n\tif (m_noWait || (!m_maxFd && !m_firstEventTime))\n\t\treturn true;\n\n\tbool timeoutIsScheduledEvent = false;\n\n\tif (m_firstEventTime)\n\t{\n\t\tdouble timeToFirstEvent = SaturatingSubtract(m_firstEventTime, m_eventTimer.ElapsedTimeAsDouble());\n\t\tif (timeToFirstEvent <= milliseconds)\n\t\t{\n\t\t\tmilliseconds = (unsigned long)timeToFirstEvent;\n\t\t\ttimeoutIsScheduledEvent = true;\n\t\t}\n\t}\n\n\ttimeval tv, *timeout;\n\n\tif (milliseconds == INFINITE_TIME)\n\t\ttimeout = NULL;\n\telse\n\t{\n\t\ttv.tv_sec = milliseconds / 1000;\n\t\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\t\ttimeout = &tv;\n\t}\n\n\tint result = select(m_maxFd+1, &m_readfds, &m_writefds, NULL, timeout);\n\n\tif (result > 0)\n\t\treturn true;\n\telse if (result == 0)\n\t\treturn timeoutIsScheduledEvent;\n\telse\n\t\tthrow Err(\"WaitObjectContainer: select failed with error \" + IntToString(errno));\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "\"WaitObjectContainer: select failed with error \" + IntToString(errno)"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "Err",
          "container": "WaitObjectContainer::Err",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "157-157",
          "snippet": "Err(const std::string& s) : Exception(IO_ERROR, s) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nWaitObjectContainer {\n  Err {\n    Err(const std::string& s) : Exception(IO_ERROR, s) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "errno"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "m_maxFd+1",
            "&m_readfds",
            "&m_writefds",
            "NULL",
            "timeout"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "m_firstEventTime",
            "m_eventTimer.ElapsedTimeAsDouble()"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_eventTimer.ElapsedTimeAsDouble",
          "args": [],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nbool WaitObjectContainer::Wait(unsigned long milliseconds)\n{\n\tif (m_noWait || (!m_maxFd && !m_firstEventTime))\n\t\treturn true;\n\n\tbool timeoutIsScheduledEvent = false;\n\n\tif (m_firstEventTime)\n\t{\n\t\tdouble timeToFirstEvent = SaturatingSubtract(m_firstEventTime, m_eventTimer.ElapsedTimeAsDouble());\n\t\tif (timeToFirstEvent <= milliseconds)\n\t\t{\n\t\t\tmilliseconds = (unsigned long)timeToFirstEvent;\n\t\t\ttimeoutIsScheduledEvent = true;\n\t\t}\n\t}\n\n\ttimeval tv, *timeout;\n\n\tif (milliseconds == INFINITE_TIME)\n\t\ttimeout = NULL;\n\telse\n\t{\n\t\ttv.tv_sec = milliseconds / 1000;\n\t\ttv.tv_usec = (milliseconds % 1000) * 1000;\n\t\ttimeout = &tv;\n\t}\n\n\tint result = select(m_maxFd+1, &m_readfds, &m_writefds, NULL, timeout);\n\n\tif (result > 0)\n\t\treturn true;\n\telse if (result == 0)\n\t\treturn timeoutIsScheduledEvent;\n\telse\n\t\tthrow Err(\"WaitObjectContainer: select failed with error \" + IntToString(errno));\n}"
  },
  {
    "function_name": "WaitObjectContainer::AddWriteFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "325-329",
    "snippet": "void WaitObjectContainer::AddWriteFd(int fd, CallStack const& callStack) // TODO: do something with callStack\n{\n\tFD_SET(fd, &m_writefds);\n\tm_maxFd = STDMAX(m_maxFd, fd);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STDMAX",
          "args": [
            "m_maxFd",
            "fd"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fd",
            "&m_writefds"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::AddWriteFd(int fd, CallStack const& callStack) // TODO: do something with callStack\n{\n\tFD_SET(fd, &m_writefds);\n\tm_maxFd = STDMAX(m_maxFd, fd);\n}"
  },
  {
    "function_name": "WaitObjectContainer::AddReadFd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "319-323",
    "snippet": "void WaitObjectContainer::AddReadFd(int fd, CallStack const& callStack)\t// TODO: do something with callStack\n{\n\tFD_SET(fd, &m_readfds);\n\tm_maxFd = STDMAX(m_maxFd, fd);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STDMAX",
          "args": [
            "m_maxFd",
            "fd"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "fd",
            "&m_readfds"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::AddReadFd(int fd, CallStack const& callStack)\t// TODO: do something with callStack\n{\n\tFD_SET(fd, &m_readfds);\n\tm_maxFd = STDMAX(m_maxFd, fd);\n}"
  },
  {
    "function_name": "WaitObjectContainer::Wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "206-315",
    "snippet": "bool WaitObjectContainer::Wait(unsigned long milliseconds)\n{\n\tif (m_noWait || (m_handles.empty() && !m_firstEventTime))\n\t{\n\t\tSetLastResult(LASTRESULT_NOWAIT);\n\t\treturn true;\n\t}\n\n\tbool timeoutIsScheduledEvent = false;\n\n\tif (m_firstEventTime)\n\t{\n\t\tdouble timeToFirstEvent = SaturatingSubtract(m_firstEventTime, m_eventTimer.ElapsedTimeAsDouble());\n\n\t\tif (timeToFirstEvent <= milliseconds)\n\t\t{\n\t\t\tmilliseconds = (unsigned long)timeToFirstEvent;\n\t\t\ttimeoutIsScheduledEvent = true;\n\t\t}\n\n\t\tif (m_handles.empty() || !milliseconds)\n\t\t{\n\t\t\tif (milliseconds)\n\t\t\t\tSleep(milliseconds);\n\t\t\tSetLastResult(timeoutIsScheduledEvent ? LASTRESULT_SCHEDULED : LASTRESULT_TIMEOUT);\n\t\t\treturn timeoutIsScheduledEvent;\n\t\t}\n\t}\n\n\tif (m_handles.size() > MAXIMUM_WAIT_OBJECTS)\n\t{\n\t\t// too many wait objects for a single WaitForMultipleObjects call, so use multiple threads\n\t\tstatic const unsigned int WAIT_OBJECTS_PER_THREAD = MAXIMUM_WAIT_OBJECTS-1;\n\t\tunsigned int nThreads = (unsigned int)((m_handles.size() + WAIT_OBJECTS_PER_THREAD - 1) / WAIT_OBJECTS_PER_THREAD);\n\t\tif (nThreads > MAXIMUM_WAIT_OBJECTS)\t// still too many wait objects, maybe implement recursive threading later?\n\t\t\tthrow Err(\"WaitObjectContainer: number of wait objects exceeds limit\");\n\t\tCreateThreads(nThreads);\n\t\tDWORD error = S_OK;\n\t\t\n\t\tfor (unsigned int i=0; i<m_threads.size(); i++)\n\t\t{\n\t\t\tWaitingThreadData &thread = *m_threads[i];\n\t\t\twhile (!thread.waitingToWait)\t// spin until thread is in the initial \"waiting to wait\" state\n\t\t\t\tSleep(0);\n\t\t\tif (i<nThreads)\n\t\t\t{\n\t\t\t\tthread.waitHandles = &m_handles[i*WAIT_OBJECTS_PER_THREAD];\n\t\t\t\tthread.count = UnsignedMin(WAIT_OBJECTS_PER_THREAD, m_handles.size() - i*WAIT_OBJECTS_PER_THREAD);\n\t\t\t\tthread.error = &error;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthread.count = 0;\n\t\t}\n\n\t\tResetEvent(m_stopWaiting);\n\t\tPulseEvent(m_startWaiting);\n\n\t\tDWORD result = ::WaitForSingleObject(m_stopWaiting, milliseconds);\n\t\tif (result == WAIT_OBJECT_0)\n\t\t{\n\t\t\tif (error == S_OK)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\tthrow Err(\"WaitObjectContainer: WaitForMultipleObjects in thread failed with error \" + IntToString(error));\n\t\t}\n\t\tSetEvent(m_stopWaiting);\n\t\tif (result == WAIT_TIMEOUT)\n\t\t{\n\t\t\tSetLastResult(timeoutIsScheduledEvent ? LASTRESULT_SCHEDULED : LASTRESULT_TIMEOUT);\n\t\t\treturn timeoutIsScheduledEvent;\n\t\t}\n\t\telse\n\t\t\tthrow Err(\"WaitObjectContainer: WaitForSingleObject failed with error \" + IntToString(::GetLastError()));\n\t}\n\telse\n\t{\n#if TRACE_WAIT\n\t\tstatic Timer t(Timer::MICROSECONDS);\n\t\tstatic unsigned long lastTime = 0;\n\t\tunsigned long timeBeforeWait = t.ElapsedTime();\n#endif\n\t\tDWORD result = ::WaitForMultipleObjects((DWORD)m_handles.size(), &m_handles[0], FALSE, milliseconds);\n#if TRACE_WAIT\n\t\tif (milliseconds > 0)\n\t\t{\n\t\t\tunsigned long timeAfterWait = t.ElapsedTime();\n\t\t\tOutputDebugString((\"Handles \" + IntToString(m_handles.size()) + \", Woke up by \" + IntToString(result-WAIT_OBJECT_0) + \", Busied for \" + IntToString(timeBeforeWait-lastTime) + \" us, Waited for \" + IntToString(timeAfterWait-timeBeforeWait) + \" us, max \" + IntToString(milliseconds) + \"ms\\n\").c_str());\n\t\t\tlastTime = timeAfterWait;\n\t\t}\n#endif\n\t\tif (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + m_handles.size())\n\t\t{\n\t\t\tif (result == m_lastResult)\n\t\t\t\tm_sameResultCount++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_lastResult = result;\n\t\t\t\tm_sameResultCount = 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse if (result == WAIT_TIMEOUT)\n\t\t{\n\t\t\tSetLastResult(timeoutIsScheduledEvent ? LASTRESULT_SCHEDULED : LASTRESULT_TIMEOUT);\n\t\t\treturn timeoutIsScheduledEvent;\n\t\t}\n\t\telse\n\t\t\tthrow Err(\"WaitObjectContainer: WaitForMultipleObjects failed with error \" + IntToString(::GetLastError()));\n\t}\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Err",
          "args": [
            "\"WaitObjectContainer: WaitForMultipleObjects failed with error \" + IntToString(::GetLastError())"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "Err",
          "container": "WaitObjectContainer::Err",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "157-157",
          "snippet": "Err(const std::string& s) : Exception(IO_ERROR, s) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nWaitObjectContainer {\n  Err {\n    Err(const std::string& s) : Exception(IO_ERROR, s) {}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "::GetLastError()"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "::GetLastError",
          "args": [],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::GetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nint Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetLastResult",
          "args": [
            "timeoutIsScheduledEvent ? LASTRESULT_SCHEDULED : LASTRESULT_TIMEOUT"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "WaitObjectContainer::SetLastResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "48-57",
          "snippet": "inline void WaitObjectContainer::SetLastResult(LastResultType result)\n{\n\tif (result == m_lastResult)\n\t\tm_sameResultCount++;\n\telse\n\t{\n\t\tm_lastResult = result;\n\t\tm_sameResultCount = 0;\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\ninline void WaitObjectContainer::SetLastResult(LastResultType result)\n{\n\tif (result == m_lastResult)\n\t\tm_sameResultCount++;\n\telse\n\t{\n\t\tm_lastResult = result;\n\t\tm_sameResultCount = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_handles.size",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OutputDebugString",
          "args": [
            "(\"Handles \" + IntToString(m_handles.size()) + \", Woke up by \" + IntToString(result-WAIT_OBJECT_0) + \", Busied for \" + IntToString(timeBeforeWait-lastTime) + \" us, Waited for \" + IntToString(timeAfterWait-timeBeforeWait) + \" us, max \" + IntToString(milliseconds) + \"ms\\n\").c_str()"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.ElapsedTime",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::WaitForMultipleObjects",
          "args": [
            "(DWORD)m_handles.size()",
            "&m_handles[0]",
            "FALSE",
            "milliseconds"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t.ElapsedTime",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetEvent",
          "args": [
            "m_stopWaiting"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::WaitForSingleObject",
          "args": [
            "m_stopWaiting",
            "milliseconds"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PulseEvent",
          "args": [
            "m_startWaiting"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResetEvent",
          "args": [
            "m_stopWaiting"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "WAIT_OBJECTS_PER_THREAD",
            "m_handles.size() - i*WAIT_OBJECTS_PER_THREAD"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Sleep",
          "args": [
            "0"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateThreads",
          "args": [
            "nThreads"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "WaitObjectContainer::CreateThreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "181-204",
          "snippet": "void WaitObjectContainer::CreateThreads(unsigned int count)\n{\n\tsize_t currentCount = m_threads.size();\n\tif (currentCount == 0)\n\t{\n\t\tm_startWaiting = ::CreateEvent(NULL, TRUE, FALSE, NULL);\n\t\tm_stopWaiting = ::CreateEvent(NULL, TRUE, FALSE, NULL);\n\t}\n\n\tif (currentCount < count)\n\t{\n\t\tm_threads.resize(count);\n\t\tfor (size_t i=currentCount; i<count; i++)\n\t\t{\n\t\t\tm_threads[i] = new WaitingThreadData;\n\t\t\tWaitingThreadData &thread = *m_threads[i];\n\t\t\tthread.terminate = false;\n\t\t\tthread.startWaiting = m_startWaiting;\n\t\t\tthread.stopWaiting = m_stopWaiting;\n\t\t\tthread.waitingToWait = false;\n\t\t\tthread.threadHandle = CreateThread(NULL, 0, &WaitingThread, &thread, 0, &thread.threadId);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::CreateThreads(unsigned int count)\n{\n\tsize_t currentCount = m_threads.size();\n\tif (currentCount == 0)\n\t{\n\t\tm_startWaiting = ::CreateEvent(NULL, TRUE, FALSE, NULL);\n\t\tm_stopWaiting = ::CreateEvent(NULL, TRUE, FALSE, NULL);\n\t}\n\n\tif (currentCount < count)\n\t{\n\t\tm_threads.resize(count);\n\t\tfor (size_t i=currentCount; i<count; i++)\n\t\t{\n\t\t\tm_threads[i] = new WaitingThreadData;\n\t\t\tWaitingThreadData &thread = *m_threads[i];\n\t\t\tthread.terminate = false;\n\t\t\tthread.startWaiting = m_startWaiting;\n\t\t\tthread.stopWaiting = m_stopWaiting;\n\t\t\tthread.waitingToWait = false;\n\t\t\tthread.threadHandle = CreateThread(NULL, 0, &WaitingThread, &thread, 0, &thread.threadId);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Sleep",
          "args": [
            "milliseconds"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_handles.empty",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "m_firstEventTime",
            "m_eventTimer.ElapsedTimeAsDouble()"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_eventTimer.ElapsedTimeAsDouble",
          "args": [],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nbool WaitObjectContainer::Wait(unsigned long milliseconds)\n{\n\tif (m_noWait || (m_handles.empty() && !m_firstEventTime))\n\t{\n\t\tSetLastResult(LASTRESULT_NOWAIT);\n\t\treturn true;\n\t}\n\n\tbool timeoutIsScheduledEvent = false;\n\n\tif (m_firstEventTime)\n\t{\n\t\tdouble timeToFirstEvent = SaturatingSubtract(m_firstEventTime, m_eventTimer.ElapsedTimeAsDouble());\n\n\t\tif (timeToFirstEvent <= milliseconds)\n\t\t{\n\t\t\tmilliseconds = (unsigned long)timeToFirstEvent;\n\t\t\ttimeoutIsScheduledEvent = true;\n\t\t}\n\n\t\tif (m_handles.empty() || !milliseconds)\n\t\t{\n\t\t\tif (milliseconds)\n\t\t\t\tSleep(milliseconds);\n\t\t\tSetLastResult(timeoutIsScheduledEvent ? LASTRESULT_SCHEDULED : LASTRESULT_TIMEOUT);\n\t\t\treturn timeoutIsScheduledEvent;\n\t\t}\n\t}\n\n\tif (m_handles.size() > MAXIMUM_WAIT_OBJECTS)\n\t{\n\t\t// too many wait objects for a single WaitForMultipleObjects call, so use multiple threads\n\t\tstatic const unsigned int WAIT_OBJECTS_PER_THREAD = MAXIMUM_WAIT_OBJECTS-1;\n\t\tunsigned int nThreads = (unsigned int)((m_handles.size() + WAIT_OBJECTS_PER_THREAD - 1) / WAIT_OBJECTS_PER_THREAD);\n\t\tif (nThreads > MAXIMUM_WAIT_OBJECTS)\t// still too many wait objects, maybe implement recursive threading later?\n\t\t\tthrow Err(\"WaitObjectContainer: number of wait objects exceeds limit\");\n\t\tCreateThreads(nThreads);\n\t\tDWORD error = S_OK;\n\t\t\n\t\tfor (unsigned int i=0; i<m_threads.size(); i++)\n\t\t{\n\t\t\tWaitingThreadData &thread = *m_threads[i];\n\t\t\twhile (!thread.waitingToWait)\t// spin until thread is in the initial \"waiting to wait\" state\n\t\t\t\tSleep(0);\n\t\t\tif (i<nThreads)\n\t\t\t{\n\t\t\t\tthread.waitHandles = &m_handles[i*WAIT_OBJECTS_PER_THREAD];\n\t\t\t\tthread.count = UnsignedMin(WAIT_OBJECTS_PER_THREAD, m_handles.size() - i*WAIT_OBJECTS_PER_THREAD);\n\t\t\t\tthread.error = &error;\n\t\t\t}\n\t\t\telse\n\t\t\t\tthread.count = 0;\n\t\t}\n\n\t\tResetEvent(m_stopWaiting);\n\t\tPulseEvent(m_startWaiting);\n\n\t\tDWORD result = ::WaitForSingleObject(m_stopWaiting, milliseconds);\n\t\tif (result == WAIT_OBJECT_0)\n\t\t{\n\t\t\tif (error == S_OK)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\tthrow Err(\"WaitObjectContainer: WaitForMultipleObjects in thread failed with error \" + IntToString(error));\n\t\t}\n\t\tSetEvent(m_stopWaiting);\n\t\tif (result == WAIT_TIMEOUT)\n\t\t{\n\t\t\tSetLastResult(timeoutIsScheduledEvent ? LASTRESULT_SCHEDULED : LASTRESULT_TIMEOUT);\n\t\t\treturn timeoutIsScheduledEvent;\n\t\t}\n\t\telse\n\t\t\tthrow Err(\"WaitObjectContainer: WaitForSingleObject failed with error \" + IntToString(::GetLastError()));\n\t}\n\telse\n\t{\n#if TRACE_WAIT\n\t\tstatic Timer t(Timer::MICROSECONDS);\n\t\tstatic unsigned long lastTime = 0;\n\t\tunsigned long timeBeforeWait = t.ElapsedTime();\n#endif\n\t\tDWORD result = ::WaitForMultipleObjects((DWORD)m_handles.size(), &m_handles[0], FALSE, milliseconds);\n#if TRACE_WAIT\n\t\tif (milliseconds > 0)\n\t\t{\n\t\t\tunsigned long timeAfterWait = t.ElapsedTime();\n\t\t\tOutputDebugString((\"Handles \" + IntToString(m_handles.size()) + \", Woke up by \" + IntToString(result-WAIT_OBJECT_0) + \", Busied for \" + IntToString(timeBeforeWait-lastTime) + \" us, Waited for \" + IntToString(timeAfterWait-timeBeforeWait) + \" us, max \" + IntToString(milliseconds) + \"ms\\n\").c_str());\n\t\t\tlastTime = timeAfterWait;\n\t\t}\n#endif\n\t\tif (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + m_handles.size())\n\t\t{\n\t\t\tif (result == m_lastResult)\n\t\t\t\tm_sameResultCount++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_lastResult = result;\n\t\t\t\tm_sameResultCount = 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse if (result == WAIT_TIMEOUT)\n\t\t{\n\t\t\tSetLastResult(timeoutIsScheduledEvent ? LASTRESULT_SCHEDULED : LASTRESULT_TIMEOUT);\n\t\t\treturn timeoutIsScheduledEvent;\n\t\t}\n\t\telse\n\t\t\tthrow Err(\"WaitObjectContainer: WaitForMultipleObjects failed with error \" + IntToString(::GetLastError()));\n\t}\n}"
  },
  {
    "function_name": "WaitObjectContainer::CreateThreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "181-204",
    "snippet": "void WaitObjectContainer::CreateThreads(unsigned int count)\n{\n\tsize_t currentCount = m_threads.size();\n\tif (currentCount == 0)\n\t{\n\t\tm_startWaiting = ::CreateEvent(NULL, TRUE, FALSE, NULL);\n\t\tm_stopWaiting = ::CreateEvent(NULL, TRUE, FALSE, NULL);\n\t}\n\n\tif (currentCount < count)\n\t{\n\t\tm_threads.resize(count);\n\t\tfor (size_t i=currentCount; i<count; i++)\n\t\t{\n\t\t\tm_threads[i] = new WaitingThreadData;\n\t\t\tWaitingThreadData &thread = *m_threads[i];\n\t\t\tthread.terminate = false;\n\t\t\tthread.startWaiting = m_startWaiting;\n\t\t\tthread.stopWaiting = m_stopWaiting;\n\t\t\tthread.waitingToWait = false;\n\t\t\tthread.threadHandle = CreateThread(NULL, 0, &WaitingThread, &thread, 0, &thread.threadId);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CreateThread",
          "args": [
            "NULL",
            "0",
            "&WaitingThread",
            "&thread",
            "0",
            "&thread.threadId"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_threads.resize",
          "args": [
            "count"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "::CreateEvent",
          "args": [
            "NULL",
            "TRUE",
            "FALSE",
            "NULL"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::CreateEvent",
          "args": [
            "NULL",
            "TRUE",
            "FALSE",
            "NULL"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_threads.size",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::CreateThreads(unsigned int count)\n{\n\tsize_t currentCount = m_threads.size();\n\tif (currentCount == 0)\n\t{\n\t\tm_startWaiting = ::CreateEvent(NULL, TRUE, FALSE, NULL);\n\t\tm_stopWaiting = ::CreateEvent(NULL, TRUE, FALSE, NULL);\n\t}\n\n\tif (currentCount < count)\n\t{\n\t\tm_threads.resize(count);\n\t\tfor (size_t i=currentCount; i<count; i++)\n\t\t{\n\t\t\tm_threads[i] = new WaitingThreadData;\n\t\t\tWaitingThreadData &thread = *m_threads[i];\n\t\t\tthread.terminate = false;\n\t\t\tthread.startWaiting = m_startWaiting;\n\t\t\tthread.stopWaiting = m_stopWaiting;\n\t\t\tthread.waitingToWait = false;\n\t\t\tthread.threadHandle = CreateThread(NULL, 0, &WaitingThread, &thread, 0, &thread.threadId);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "WaitingThread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "145-179",
    "snippet": "DWORD WINAPI WaitingThread(LPVOID lParam)\n{\n\tstd::auto_ptr<WaitingThreadData> pThread((WaitingThreadData *)lParam);\n\tWaitingThreadData &thread = *pThread;\n\tstd::vector<HANDLE> handles;\n\n\twhile (true)\n\t{\n\t\tthread.waitingToWait = true;\n\t\t::WaitForSingleObject(thread.startWaiting, INFINITE);\n\t\tthread.waitingToWait = false;\n\n\t\tif (thread.terminate)\n\t\t\tbreak;\n\t\tif (!thread.count)\n\t\t\tcontinue;\n\n\t\thandles.resize(thread.count + 1);\n\t\thandles[0] = thread.stopWaiting;\n\t\tstd::copy(thread.waitHandles, thread.waitHandles+thread.count, handles.begin()+1);\n\n\t\tDWORD result = ::WaitForMultipleObjects((DWORD)handles.size(), &handles[0], FALSE, INFINITE);\n\n\t\tif (result == WAIT_OBJECT_0)\n\t\t\tcontinue;\t// another thread finished waiting first, so do nothing\n\t\tSetEvent(thread.stopWaiting);\n\t\tif (!(result > WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + handles.size()))\n\t\t{\n\t\t\tassert(!\"error in WaitingThread\");\t// break here so we can see which thread has an error\n\t\t\t*thread.error = ::GetLastError();\n\t\t}\n\t}\n\n\treturn S_OK;\t// return a value here to avoid compiler warning\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "::GetLastError",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "Socket::GetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/socketft.cpp",
          "lines": "286-293",
          "snippet": "int Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}",
          "includes": [
            "#include <sys/ioctl.h>",
            "#include <netinet/in.h>",
            "#include <arpa/inet.h>",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <errno.h>",
            "#include \"wait.h\"",
            "#include \"socketft.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/ioctl.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#include <errno.h>\n#include \"wait.h\"\n#include \"socketft.h\"\n#include \"pch.h\"\n\nint Socket::GetLastError()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn WSAGetLastError();\n#else\n\treturn errno;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!\"error in WaitingThread\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handles.size",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetEvent",
          "args": [
            "thread.stopWaiting"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "::WaitForMultipleObjects",
          "args": [
            "(DWORD)handles.size()",
            "&handles[0]",
            "FALSE",
            "INFINITE"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::copy",
          "args": [
            "thread.waitHandles",
            "thread.waitHandles+thread.count",
            "handles.begin()+1"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handles.begin",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handles.resize",
          "args": [
            "thread.count + 1"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "::WaitForSingleObject",
          "args": [
            "thread.startWaiting",
            "INFINITE"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nDWORD WINAPI WaitingThread(LPVOID lParam)\n{\n\tstd::auto_ptr<WaitingThreadData> pThread((WaitingThreadData *)lParam);\n\tWaitingThreadData &thread = *pThread;\n\tstd::vector<HANDLE> handles;\n\n\twhile (true)\n\t{\n\t\tthread.waitingToWait = true;\n\t\t::WaitForSingleObject(thread.startWaiting, INFINITE);\n\t\tthread.waitingToWait = false;\n\n\t\tif (thread.terminate)\n\t\t\tbreak;\n\t\tif (!thread.count)\n\t\t\tcontinue;\n\n\t\thandles.resize(thread.count + 1);\n\t\thandles[0] = thread.stopWaiting;\n\t\tstd::copy(thread.waitHandles, thread.waitHandles+thread.count, handles.begin()+1);\n\n\t\tDWORD result = ::WaitForMultipleObjects((DWORD)handles.size(), &handles[0], FALSE, INFINITE);\n\n\t\tif (result == WAIT_OBJECT_0)\n\t\t\tcontinue;\t// another thread finished waiting first, so do nothing\n\t\tSetEvent(thread.stopWaiting);\n\t\tif (!(result > WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + handles.size()))\n\t\t{\n\t\t\tassert(!\"error in WaitingThread\");\t// break here so we can see which thread has an error\n\t\t\t*thread.error = ::GetLastError();\n\t\t}\n\t}\n\n\treturn S_OK;\t// return a value here to avoid compiler warning\n}"
  },
  {
    "function_name": "WaitObjectContainer::AddHandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "139-143",
    "snippet": "void WaitObjectContainer::AddHandle(HANDLE handle, CallStack const& callStack)\n{\n\tDetectNoWait(m_handles.size(), CallStack(\"WaitObjectContainer::AddHandle()\", &callStack));\n\tm_handles.push_back(handle);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_handles.push_back",
          "args": [
            "handle"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DetectNoWait",
          "args": [
            "m_handles.size()",
            "CallStack(\"WaitObjectContainer::AddHandle()\", &callStack)"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "WaitObjectContainer::DetectNoWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "59-79",
          "snippet": "void WaitObjectContainer::DetectNoWait(LastResultType result, CallStack const& callStack)\n{\n\tif (result == m_lastResult && m_noWaitTimer.ElapsedTime() > 1000)\n\t{\n\t\tif (m_sameResultCount > m_noWaitTimer.ElapsedTime())\n\t\t{\n\t\t\tif (m_tracer)\n\t\t\t{\n\t\t\t\tstd::string desc = \"No wait loop detected - m_lastResult: \";\n\t\t\t\tdesc.append(IntToString(m_lastResult)).append(\", call stack:\");\n\t\t\t\tfor (CallStack const* cs = &callStack; cs; cs = cs->Prev())\n\t\t\t\t\tdesc.append(\"\\n- \").append(cs->Format());\n\t\t\t\tm_tracer->TraceNoWaitLoop(desc);\n\t\t\t}\n\t\t\ttry { throw 0; } catch (...) {}\t\t// help debugger break\n\t\t}\n\n\t\tm_noWaitTimer.StartTimer();\n\t\tm_sameResultCount = 0;\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::DetectNoWait(LastResultType result, CallStack const& callStack)\n{\n\tif (result == m_lastResult && m_noWaitTimer.ElapsedTime() > 1000)\n\t{\n\t\tif (m_sameResultCount > m_noWaitTimer.ElapsedTime())\n\t\t{\n\t\t\tif (m_tracer)\n\t\t\t{\n\t\t\t\tstd::string desc = \"No wait loop detected - m_lastResult: \";\n\t\t\t\tdesc.append(IntToString(m_lastResult)).append(\", call stack:\");\n\t\t\t\tfor (CallStack const* cs = &callStack; cs; cs = cs->Prev())\n\t\t\t\t\tdesc.append(\"\\n- \").append(cs->Format());\n\t\t\t\tm_tracer->TraceNoWaitLoop(desc);\n\t\t\t}\n\t\t\ttry { throw 0; } catch (...) {}\t\t// help debugger break\n\t\t}\n\n\t\tm_noWaitTimer.StartTimer();\n\t\tm_sameResultCount = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"WaitObjectContainer::AddHandle()\"",
            "&callStack"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_handles.size",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::AddHandle(HANDLE handle, CallStack const& callStack)\n{\n\tDetectNoWait(m_handles.size(), CallStack(\"WaitObjectContainer::AddHandle()\", &callStack));\n\tm_handles.push_back(handle);\n}"
  },
  {
    "function_name": "WaitObjectContainer::~WaitObjectContainer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "109-136",
    "snippet": "WaitObjectContainer::~WaitObjectContainer()\n{\n\ttry\t\t// don't let exceptions escape destructor\n\t{\n\t\tif (!m_threads.empty())\n\t\t{\n\t\t\tHANDLE threadHandles[MAXIMUM_WAIT_OBJECTS];\n\t\t\tunsigned int i;\n\t\t\tfor (i=0; i<m_threads.size(); i++)\n\t\t\t{\n\t\t\t\tWaitingThreadData &thread = *m_threads[i];\n\t\t\t\twhile (!thread.waitingToWait)\t// spin until thread is in the initial \"waiting to wait\" state\n\t\t\t\t\tSleep(0);\n\t\t\t\tthread.terminate = true;\n\t\t\t\tthreadHandles[i] = thread.threadHandle;\n\t\t\t}\n\t\t\tPulseEvent(m_startWaiting);\n\t\t\t::WaitForMultipleObjects((DWORD)m_threads.size(), threadHandles, TRUE, INFINITE);\n\t\t\tfor (i=0; i<m_threads.size(); i++)\n\t\t\t\tCloseHandle(threadHandles[i]);\n\t\t\tCloseHandle(m_startWaiting);\n\t\t\tCloseHandle(m_stopWaiting);\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t}\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "m_stopWaiting"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "m_startWaiting"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "threadHandles[i]"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_threads.size",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "::WaitForMultipleObjects",
          "args": [
            "(DWORD)m_threads.size()",
            "threadHandles",
            "TRUE",
            "INFINITE"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PulseEvent",
          "args": [
            "m_startWaiting"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Sleep",
          "args": [
            "0"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_threads.empty",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer::~WaitObjectContainer()\n{\n\ttry\t\t// don't let exceptions escape destructor\n\t{\n\t\tif (!m_threads.empty())\n\t\t{\n\t\t\tHANDLE threadHandles[MAXIMUM_WAIT_OBJECTS];\n\t\t\tunsigned int i;\n\t\t\tfor (i=0; i<m_threads.size(); i++)\n\t\t\t{\n\t\t\t\tWaitingThreadData &thread = *m_threads[i];\n\t\t\t\twhile (!thread.waitingToWait)\t// spin until thread is in the initial \"waiting to wait\" state\n\t\t\t\t\tSleep(0);\n\t\t\t\tthread.terminate = true;\n\t\t\t\tthreadHandles[i] = thread.threadHandle;\n\t\t\t}\n\t\t\tPulseEvent(m_startWaiting);\n\t\t\t::WaitForMultipleObjects((DWORD)m_threads.size(), threadHandles, TRUE, INFINITE);\n\t\t\tfor (i=0; i<m_threads.size(); i++)\n\t\t\t\tCloseHandle(threadHandles[i]);\n\t\t\tCloseHandle(m_startWaiting);\n\t\t\tCloseHandle(m_stopWaiting);\n\t\t}\n\t}\n\tcatch (...)\n\t{\n\t}\n}"
  },
  {
    "function_name": "WaitObjectContainer::ScheduleEvent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "87-94",
    "snippet": "void WaitObjectContainer::ScheduleEvent(double milliseconds, CallStack const& callStack)\n{\n\tif (milliseconds <= 3)\n\t\tDetectNoWait(LASTRESULT_SCHEDULED, CallStack(\"WaitObjectContainer::ScheduleEvent()\", &callStack));\n\tdouble thisEventTime = m_eventTimer.ElapsedTimeAsDouble() + milliseconds;\n\tif (!m_firstEventTime || thisEventTime < m_firstEventTime)\n\t\tm_firstEventTime = thisEventTime;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_eventTimer.ElapsedTimeAsDouble",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DetectNoWait",
          "args": [
            "LASTRESULT_SCHEDULED",
            "CallStack(\"WaitObjectContainer::ScheduleEvent()\", &callStack)"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "WaitObjectContainer::DetectNoWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "59-79",
          "snippet": "void WaitObjectContainer::DetectNoWait(LastResultType result, CallStack const& callStack)\n{\n\tif (result == m_lastResult && m_noWaitTimer.ElapsedTime() > 1000)\n\t{\n\t\tif (m_sameResultCount > m_noWaitTimer.ElapsedTime())\n\t\t{\n\t\t\tif (m_tracer)\n\t\t\t{\n\t\t\t\tstd::string desc = \"No wait loop detected - m_lastResult: \";\n\t\t\t\tdesc.append(IntToString(m_lastResult)).append(\", call stack:\");\n\t\t\t\tfor (CallStack const* cs = &callStack; cs; cs = cs->Prev())\n\t\t\t\t\tdesc.append(\"\\n- \").append(cs->Format());\n\t\t\t\tm_tracer->TraceNoWaitLoop(desc);\n\t\t\t}\n\t\t\ttry { throw 0; } catch (...) {}\t\t// help debugger break\n\t\t}\n\n\t\tm_noWaitTimer.StartTimer();\n\t\tm_sameResultCount = 0;\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::DetectNoWait(LastResultType result, CallStack const& callStack)\n{\n\tif (result == m_lastResult && m_noWaitTimer.ElapsedTime() > 1000)\n\t{\n\t\tif (m_sameResultCount > m_noWaitTimer.ElapsedTime())\n\t\t{\n\t\t\tif (m_tracer)\n\t\t\t{\n\t\t\t\tstd::string desc = \"No wait loop detected - m_lastResult: \";\n\t\t\t\tdesc.append(IntToString(m_lastResult)).append(\", call stack:\");\n\t\t\t\tfor (CallStack const* cs = &callStack; cs; cs = cs->Prev())\n\t\t\t\t\tdesc.append(\"\\n- \").append(cs->Format());\n\t\t\t\tm_tracer->TraceNoWaitLoop(desc);\n\t\t\t}\n\t\t\ttry { throw 0; } catch (...) {}\t\t// help debugger break\n\t\t}\n\n\t\tm_noWaitTimer.StartTimer();\n\t\tm_sameResultCount = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"WaitObjectContainer::ScheduleEvent()\"",
            "&callStack"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::ScheduleEvent(double milliseconds, CallStack const& callStack)\n{\n\tif (milliseconds <= 3)\n\t\tDetectNoWait(LASTRESULT_SCHEDULED, CallStack(\"WaitObjectContainer::ScheduleEvent()\", &callStack));\n\tdouble thisEventTime = m_eventTimer.ElapsedTimeAsDouble() + milliseconds;\n\tif (!m_firstEventTime || thisEventTime < m_firstEventTime)\n\t\tm_firstEventTime = thisEventTime;\n}"
  },
  {
    "function_name": "WaitObjectContainer::SetNoWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "81-85",
    "snippet": "void WaitObjectContainer::SetNoWait(CallStack const& callStack)\n{\n\tDetectNoWait(LASTRESULT_NOWAIT, CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack));\n\tm_noWait = true;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DetectNoWait",
          "args": [
            "LASTRESULT_NOWAIT",
            "CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack)"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "WaitObjectContainer::DetectNoWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "59-79",
          "snippet": "void WaitObjectContainer::DetectNoWait(LastResultType result, CallStack const& callStack)\n{\n\tif (result == m_lastResult && m_noWaitTimer.ElapsedTime() > 1000)\n\t{\n\t\tif (m_sameResultCount > m_noWaitTimer.ElapsedTime())\n\t\t{\n\t\t\tif (m_tracer)\n\t\t\t{\n\t\t\t\tstd::string desc = \"No wait loop detected - m_lastResult: \";\n\t\t\t\tdesc.append(IntToString(m_lastResult)).append(\", call stack:\");\n\t\t\t\tfor (CallStack const* cs = &callStack; cs; cs = cs->Prev())\n\t\t\t\t\tdesc.append(\"\\n- \").append(cs->Format());\n\t\t\t\tm_tracer->TraceNoWaitLoop(desc);\n\t\t\t}\n\t\t\ttry { throw 0; } catch (...) {}\t\t// help debugger break\n\t\t}\n\n\t\tm_noWaitTimer.StartTimer();\n\t\tm_sameResultCount = 0;\n\t}\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::DetectNoWait(LastResultType result, CallStack const& callStack)\n{\n\tif (result == m_lastResult && m_noWaitTimer.ElapsedTime() > 1000)\n\t{\n\t\tif (m_sameResultCount > m_noWaitTimer.ElapsedTime())\n\t\t{\n\t\t\tif (m_tracer)\n\t\t\t{\n\t\t\t\tstd::string desc = \"No wait loop detected - m_lastResult: \";\n\t\t\t\tdesc.append(IntToString(m_lastResult)).append(\", call stack:\");\n\t\t\t\tfor (CallStack const* cs = &callStack; cs; cs = cs->Prev())\n\t\t\t\t\tdesc.append(\"\\n- \").append(cs->Format());\n\t\t\t\tm_tracer->TraceNoWaitLoop(desc);\n\t\t\t}\n\t\t\ttry { throw 0; } catch (...) {}\t\t// help debugger break\n\t\t}\n\n\t\tm_noWaitTimer.StartTimer();\n\t\tm_sameResultCount = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallStack",
          "args": [
            "\"WaitObjectContainer::SetNoWait()\"",
            "&callStack"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "CallStack",
          "container": "CallStack",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.h",
          "lines": "109-109",
          "snippet": "CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}",
          "includes": [
            "#include \"hrtimer.h\"",
            "# include <sys/select.h>",
            "# include <sys/types.h>",
            "# include <winsock2.h>",
            "#include <vector>",
            "#include \"cryptlib.h\"",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hrtimer.h\"\n# include <sys/select.h>\n# include <sys/types.h>\n# include <winsock2.h>\n#include <vector>\n#include \"cryptlib.h\"\n#include \"misc.h\"\n#include \"config.h\"\n\nCallStack {\n  CallStack(char const* i, CallStack const* p) : m_info(i), m_prev(p) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::SetNoWait(CallStack const& callStack)\n{\n\tDetectNoWait(LASTRESULT_NOWAIT, CallStack(\"WaitObjectContainer::SetNoWait()\", &callStack));\n\tm_noWait = true;\n}"
  },
  {
    "function_name": "WaitObjectContainer::DetectNoWait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "59-79",
    "snippet": "void WaitObjectContainer::DetectNoWait(LastResultType result, CallStack const& callStack)\n{\n\tif (result == m_lastResult && m_noWaitTimer.ElapsedTime() > 1000)\n\t{\n\t\tif (m_sameResultCount > m_noWaitTimer.ElapsedTime())\n\t\t{\n\t\t\tif (m_tracer)\n\t\t\t{\n\t\t\t\tstd::string desc = \"No wait loop detected - m_lastResult: \";\n\t\t\t\tdesc.append(IntToString(m_lastResult)).append(\", call stack:\");\n\t\t\t\tfor (CallStack const* cs = &callStack; cs; cs = cs->Prev())\n\t\t\t\t\tdesc.append(\"\\n- \").append(cs->Format());\n\t\t\t\tm_tracer->TraceNoWaitLoop(desc);\n\t\t\t}\n\t\t\ttry { throw 0; } catch (...) {}\t\t// help debugger break\n\t\t}\n\n\t\tm_noWaitTimer.StartTimer();\n\t\tm_sameResultCount = 0;\n\t}\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_noWaitTimer.StartTimer",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_tracer->TraceNoWaitLoop",
          "args": [
            "desc"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc.append",
          "args": [
            "cs->Format()"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->Format",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc.append",
          "args": [
            "\"\\n- \""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs->Prev",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc.append",
          "args": [
            "\", call stack:\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc.append",
          "args": [
            "IntToString(m_lastResult)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IntToString",
          "args": [
            "m_lastResult"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "IntToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "409-429",
          "snippet": "std::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nstd::string IntToString(T a, unsigned int base = 10)\n{\n\tif (a == 0)\n\t\treturn \"0\";\n\tbool negate = false;\n\tif (a < 0)\n\t{\n\t\tnegate = true;\n\t\ta = 0-a;\t// VC .NET does not like -a\n\t}\n\tstd::string result;\n\twhile (a > 0)\n\t{\n\t\tT digit = a % base;\n\t\tresult = char((digit < 10 ? '0' : ('a' - 10)) + digit) + result;\n\t\ta /= base;\n\t}\n\tif (negate)\n\t\tresult = \"-\" + result;\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_noWaitTimer.ElapsedTime",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_noWaitTimer.ElapsedTime",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::DetectNoWait(LastResultType result, CallStack const& callStack)\n{\n\tif (result == m_lastResult && m_noWaitTimer.ElapsedTime() > 1000)\n\t{\n\t\tif (m_sameResultCount > m_noWaitTimer.ElapsedTime())\n\t\t{\n\t\t\tif (m_tracer)\n\t\t\t{\n\t\t\t\tstd::string desc = \"No wait loop detected - m_lastResult: \";\n\t\t\t\tdesc.append(IntToString(m_lastResult)).append(\", call stack:\");\n\t\t\t\tfor (CallStack const* cs = &callStack; cs; cs = cs->Prev())\n\t\t\t\t\tdesc.append(\"\\n- \").append(cs->Format());\n\t\t\t\tm_tracer->TraceNoWaitLoop(desc);\n\t\t\t}\n\t\t\ttry { throw 0; } catch (...) {}\t\t// help debugger break\n\t\t}\n\n\t\tm_noWaitTimer.StartTimer();\n\t\tm_sameResultCount = 0;\n\t}\n}"
  },
  {
    "function_name": "WaitObjectContainer::SetLastResult",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "48-57",
    "snippet": "inline void WaitObjectContainer::SetLastResult(LastResultType result)\n{\n\tif (result == m_lastResult)\n\t\tm_sameResultCount++;\n\telse\n\t{\n\t\tm_lastResult = result;\n\t\tm_sameResultCount = 0;\n\t}\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\ninline void WaitObjectContainer::SetLastResult(LastResultType result)\n{\n\tif (result == m_lastResult)\n\t\tm_sameResultCount++;\n\telse\n\t{\n\t\tm_lastResult = result;\n\t\tm_sameResultCount = 0;\n\t}\n}"
  },
  {
    "function_name": "WaitObjectContainer::Clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "35-46",
    "snippet": "void WaitObjectContainer::Clear()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tm_handles.clear();\n#else\n\tm_maxFd = 0;\n\tFD_ZERO(&m_readfds);\n\tFD_ZERO(&m_writefds);\n#endif\n\tm_noWait = false;\n\tm_firstEventTime = 0;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&m_writefds"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&m_readfds"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_handles.clear",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::Clear()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tm_handles.clear();\n#else\n\tm_maxFd = 0;\n\tFD_ZERO(&m_readfds);\n\tFD_ZERO(&m_writefds);\n#endif\n\tm_noWait = false;\n\tm_firstEventTime = 0;\n}"
  },
  {
    "function_name": "WaitObjectContainer::WaitObjectContainer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "27-33",
    "snippet": "WaitObjectContainer::WaitObjectContainer(WaitObjectsTracer* tracer)\n\t: m_tracer(tracer), m_eventTimer(Timer::MILLISECONDS)\n\t, m_sameResultCount(0), m_noWaitTimer(Timer::MILLISECONDS)\n{\n\tClear();\n\tm_eventTimer.StartTimer();\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_eventTimer.StartTimer",
          "args": [],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Clear",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "WaitObjectContainer::Clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
          "lines": "35-46",
          "snippet": "void WaitObjectContainer::Clear()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tm_handles.clear();\n#else\n\tm_maxFd = 0;\n\tFD_ZERO(&m_readfds);\n\tFD_ZERO(&m_writefds);\n#endif\n\tm_noWait = false;\n\tm_firstEventTime = 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include <errno.h>",
            "#include \"misc.h\"",
            "#include \"wait.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nvoid WaitObjectContainer::Clear()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\tm_handles.clear();\n#else\n\tm_maxFd = 0;\n\tFD_ZERO(&m_readfds);\n\tFD_ZERO(&m_writefds);\n#endif\n\tm_noWait = false;\n\tm_firstEventTime = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nWaitObjectContainer::WaitObjectContainer(WaitObjectsTracer* tracer)\n\t: m_tracer(tracer), m_eventTimer(Timer::MILLISECONDS)\n\t, m_sameResultCount(0), m_noWaitTimer(Timer::MILLISECONDS)\n{\n\tClear();\n\tm_eventTimer.StartTimer();\n}"
  },
  {
    "function_name": "WaitObjectContainer::MaxWaitObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wait.cpp",
    "lines": "18-25",
    "snippet": "unsigned int WaitObjectContainer::MaxWaitObjects()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn MAXIMUM_WAIT_OBJECTS * (MAXIMUM_WAIT_OBJECTS-1);\n#else\n\treturn FD_SETSIZE;\n#endif\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/time.h>",
      "#include <sys/types.h>",
      "#include <errno.h>",
      "#include \"misc.h\"",
      "#include \"wait.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <errno.h>\n#include \"misc.h\"\n#include \"wait.h\"\n#include \"pch.h\"\n\nunsigned int WaitObjectContainer::MaxWaitObjects()\n{\n#ifdef USE_WINDOWS_STYLE_SOCKETS\n\treturn MAXIMUM_WAIT_OBJECTS * (MAXIMUM_WAIT_OBJECTS-1);\n#else\n\treturn FD_SETSIZE;\n#endif\n}"
  }
]