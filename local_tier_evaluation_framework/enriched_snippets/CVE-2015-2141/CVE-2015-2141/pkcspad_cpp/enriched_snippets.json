[
  {
    "function_name": "ComputeMessageRepresentative",
    "container": "PKCS1v15_SignatureMessageEncodingMethod",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pkcspad.cpp",
    "lines": "89-118",
    "snippet": "void PKCS1v15_SignatureMessageEncodingMethod::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n\tconst byte *recoverableMessage, size_t recoverableMessageLength,\n\tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n\tbyte *representative, size_t representativeBitLength) const\n{\n\tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n\n\tsize_t pkcsBlockLen = representativeBitLength;\n\t// convert from bit length to byte length\n\tif (pkcsBlockLen % 8 != 0)\n\t{\n\t\trepresentative[0] = 0;\n\t\trepresentative++;\n\t}\n\tpkcsBlockLen /= 8;\n\n\trepresentative[0] = 1;   // block type 1\n\n\tunsigned int digestSize = hash.DigestSize();\n\tbyte *pPadding = representative + 1;\n\tbyte *pDigest = representative + pkcsBlockLen - digestSize;\n\tbyte *pHashId = pDigest - hashIdentifier.second;\n\tbyte *pSeparator = pHashId - 1;\n\n\t// pad with 0xff\n\tmemset(pPadding, 0xff, pSeparator-pPadding);\n\t*pSeparator = 0;\n\tmemcpy(pHashId, hashIdentifier.first, hashIdentifier.second);\n\thash.Final(pDigest);\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"pkcspad.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash.Final",
          "args": [
            "pDigest"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pHashId",
            "hashIdentifier.first",
            "hashIdentifier.second"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pPadding",
            "0xff",
            "pSeparator-pPadding"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.DigestSize",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize())"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MinRepresentativeBitLength",
          "args": [
            "hashIdentifier.second",
            "hash.DigestSize()"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "MinRepresentativeBitLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pkcspad.h",
          "lines": "60-61",
          "snippet": "size_t MinRepresentativeBitLength(size_t hashIdentifierSize, size_t digestSize) const\n\t\t{return 8 * (digestSize + hashIdentifierSize + 10);}",
          "includes": [
            "#include \"sha.h\"",
            "#include \"pubkey.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sha.h\"\n#include \"pubkey.h\"\n#include \"cryptlib.h\"\n\nsize_t MinRepresentativeBitLength(size_t hashIdentifierSize, size_t digestSize) const\n\t\t{return 8 * (digestSize + hashIdentifierSize + 10);}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"pkcspad.h\"\n#include \"pch.h\"\n\nPKCS1v15_SignatureMessageEncodingMethod {\n  void PKCS1v15_SignatureMessageEncodingMethod::ComputeMessageRepresentative(RandomNumberGenerator &rng, \n  \tconst byte *recoverableMessage, size_t recoverableMessageLength,\n  \tHashTransformation &hash, HashIdentifier hashIdentifier, bool messageEmpty,\n  \tbyte *representative, size_t representativeBitLength) const\n  {\n  \tassert(representativeBitLength >= MinRepresentativeBitLength(hashIdentifier.second, hash.DigestSize()));\n  \n  \tsize_t pkcsBlockLen = representativeBitLength;\n  \t// convert from bit length to byte length\n  \tif (pkcsBlockLen % 8 != 0)\n  \t{\n  \t\trepresentative[0] = 0;\n  \t\trepresentative++;\n  \t}\n  \tpkcsBlockLen /= 8;\n  \n  \trepresentative[0] = 1;   // block type 1\n  \n  \tunsigned int digestSize = hash.DigestSize();\n  \tbyte *pPadding = representative + 1;\n  \tbyte *pDigest = representative + pkcsBlockLen - digestSize;\n  \tbyte *pHashId = pDigest - hashIdentifier.second;\n  \tbyte *pSeparator = pHashId - 1;\n  \n  \t// pad with 0xff\n  \tmemset(pPadding, 0xff, pSeparator-pPadding);\n  \t*pSeparator = 0;\n  \tmemcpy(pHashId, hashIdentifier.first, hashIdentifier.second);\n  \thash.Final(pDigest);\n  }\n}"
  },
  {
    "function_name": "Unpad",
    "container": "PKCS_EncryptionPaddingScheme",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pkcspad.cpp",
    "lines": "53-83",
    "snippet": "DecodingResult PKCS_EncryptionPaddingScheme::Unpad(const byte *pkcsBlock, size_t pkcsBlockLen, byte *output, const NameValuePairs &parameters) const\n{\n\tbool invalid = false;\n\tsize_t maxOutputLen = MaxUnpaddedLength(pkcsBlockLen);\n\n\t// convert from bit length to byte length\n\tif (pkcsBlockLen % 8 != 0)\n\t{\n\t\tinvalid = (pkcsBlock[0] != 0) || invalid;\n\t\tpkcsBlock++;\n\t}\n\tpkcsBlockLen /= 8;\n\n\t// Require block type 2.\n\tinvalid = (pkcsBlock[0] != 2) || invalid;\n\n\t// skip past the padding until we find the separator\n\tsize_t i=1;\n\twhile (i<pkcsBlockLen && pkcsBlock[i++]) { // null body\n\t\t}\n\tassert(i==pkcsBlockLen || pkcsBlock[i-1]==0);\n\n\tsize_t outputLen = pkcsBlockLen - i;\n\tinvalid = (outputLen > maxOutputLen) || invalid;\n\n\tif (invalid)\n\t\treturn DecodingResult();\n\n\tmemcpy (output, pkcsBlock+i, outputLen);\n\treturn DecodingResult(outputLen);\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"pkcspad.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DecodingResult",
          "args": [
            "outputLen"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "output",
            "pkcsBlock+i",
            "outputLen"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodingResult",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "i==pkcsBlockLen || pkcsBlock[i-1]==0"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxUnpaddedLength",
          "args": [
            "pkcsBlockLen"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "MaxUnpaddedLength",
          "container": "PKCS_EncryptionPaddingScheme",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pkcspad.cpp",
          "lines": "26-29",
          "snippet": "size_t PKCS_EncryptionPaddingScheme::MaxUnpaddedLength(size_t paddedLength) const\n{\n\treturn SaturatingSubtract(paddedLength/8, 10U);\n}",
          "includes": [
            "#include <assert.h>",
            "#include \"pkcspad.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"pkcspad.h\"\n#include \"pch.h\"\n\nPKCS_EncryptionPaddingScheme {\n  size_t PKCS_EncryptionPaddingScheme::MaxUnpaddedLength(size_t paddedLength) const\n  {\n  \treturn SaturatingSubtract(paddedLength/8, 10U);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"pkcspad.h\"\n#include \"pch.h\"\n\nPKCS_EncryptionPaddingScheme {\n  DecodingResult PKCS_EncryptionPaddingScheme::Unpad(const byte *pkcsBlock, size_t pkcsBlockLen, byte *output, const NameValuePairs &parameters) const\n  {\n  \tbool invalid = false;\n  \tsize_t maxOutputLen = MaxUnpaddedLength(pkcsBlockLen);\n  \n  \t// convert from bit length to byte length\n  \tif (pkcsBlockLen % 8 != 0)\n  \t{\n  \t\tinvalid = (pkcsBlock[0] != 0) || invalid;\n  \t\tpkcsBlock++;\n  \t}\n  \tpkcsBlockLen /= 8;\n  \n  \t// Require block type 2.\n  \tinvalid = (pkcsBlock[0] != 2) || invalid;\n  \n  \t// skip past the padding until we find the separator\n  \tsize_t i=1;\n  \twhile (i<pkcsBlockLen && pkcsBlock[i++]) { // null body\n  \t\t}\n  \tassert(i==pkcsBlockLen || pkcsBlock[i-1]==0);\n  \n  \tsize_t outputLen = pkcsBlockLen - i;\n  \tinvalid = (outputLen > maxOutputLen) || invalid;\n  \n  \tif (invalid)\n  \t\treturn DecodingResult();\n  \n  \tmemcpy (output, pkcsBlock+i, outputLen);\n  \treturn DecodingResult(outputLen);\n  }\n}"
  },
  {
    "function_name": "Pad",
    "container": "PKCS_EncryptionPaddingScheme",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pkcspad.cpp",
    "lines": "31-51",
    "snippet": "void PKCS_EncryptionPaddingScheme::Pad(RandomNumberGenerator &rng, const byte *input, size_t inputLen, byte *pkcsBlock, size_t pkcsBlockLen, const NameValuePairs &parameters) const\n{\n\tassert (inputLen <= MaxUnpaddedLength(pkcsBlockLen));\t// this should be checked by caller\n\n\t// convert from bit length to byte length\n\tif (pkcsBlockLen % 8 != 0)\n\t{\n\t\tpkcsBlock[0] = 0;\n\t\tpkcsBlock++;\n\t}\n\tpkcsBlockLen /= 8;\n\n\tpkcsBlock[0] = 2;  // block type 2\n\n\t// pad with non-zero random bytes\n\tfor (unsigned i = 1; i < pkcsBlockLen-inputLen-1; i++)\n\t\tpkcsBlock[i] = (byte)rng.GenerateWord32(1, 0xff);\n\n\tpkcsBlock[pkcsBlockLen-inputLen-1] = 0;     // separator\n\tmemcpy(pkcsBlock+pkcsBlockLen-inputLen, input, inputLen);\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"pkcspad.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pkcsBlock+pkcsBlockLen-inputLen",
            "input",
            "inputLen"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rng.GenerateWord32",
          "args": [
            "1",
            "0xff"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateWord32",
          "container": "RandomNumberGenerator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "248-262",
          "snippet": "word32 RandomNumberGenerator::GenerateWord32(word32 min, word32 max)\n{\n\tword32 range = max-min;\n\tconst int maxBits = BitPrecision(range);\n\n\tword32 value;\n\n\tdo\n\t{\n\t\tGenerateBlock((byte *)&value, sizeof(value));\n\t\tvalue = Crop(value, maxBits);\n\t} while (value > range);\n\n\treturn value+min;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nRandomNumberGenerator {\n  word32 RandomNumberGenerator::GenerateWord32(word32 min, word32 max)\n  {\n  \tword32 range = max-min;\n  \tconst int maxBits = BitPrecision(range);\n  \n  \tword32 value;\n  \n  \tdo\n  \t{\n  \t\tGenerateBlock((byte *)&value, sizeof(value));\n  \t\tvalue = Crop(value, maxBits);\n  \t} while (value > range);\n  \n  \treturn value+min;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "inputLen <= MaxUnpaddedLength(pkcsBlockLen)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MaxUnpaddedLength",
          "args": [
            "pkcsBlockLen"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "MaxUnpaddedLength",
          "container": "PKCS_EncryptionPaddingScheme",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pkcspad.cpp",
          "lines": "26-29",
          "snippet": "size_t PKCS_EncryptionPaddingScheme::MaxUnpaddedLength(size_t paddedLength) const\n{\n\treturn SaturatingSubtract(paddedLength/8, 10U);\n}",
          "includes": [
            "#include <assert.h>",
            "#include \"pkcspad.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"pkcspad.h\"\n#include \"pch.h\"\n\nPKCS_EncryptionPaddingScheme {\n  size_t PKCS_EncryptionPaddingScheme::MaxUnpaddedLength(size_t paddedLength) const\n  {\n  \treturn SaturatingSubtract(paddedLength/8, 10U);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"pkcspad.h\"\n#include \"pch.h\"\n\nPKCS_EncryptionPaddingScheme {\n  void PKCS_EncryptionPaddingScheme::Pad(RandomNumberGenerator &rng, const byte *input, size_t inputLen, byte *pkcsBlock, size_t pkcsBlockLen, const NameValuePairs &parameters) const\n  {\n  \tassert (inputLen <= MaxUnpaddedLength(pkcsBlockLen));\t// this should be checked by caller\n  \n  \t// convert from bit length to byte length\n  \tif (pkcsBlockLen % 8 != 0)\n  \t{\n  \t\tpkcsBlock[0] = 0;\n  \t\tpkcsBlock++;\n  \t}\n  \tpkcsBlockLen /= 8;\n  \n  \tpkcsBlock[0] = 2;  // block type 2\n  \n  \t// pad with non-zero random bytes\n  \tfor (unsigned i = 1; i < pkcsBlockLen-inputLen-1; i++)\n  \t\tpkcsBlock[i] = (byte)rng.GenerateWord32(1, 0xff);\n  \n  \tpkcsBlock[pkcsBlockLen-inputLen-1] = 0;     // separator\n  \tmemcpy(pkcsBlock+pkcsBlockLen-inputLen, input, inputLen);\n  }\n}"
  },
  {
    "function_name": "MaxUnpaddedLength",
    "container": "PKCS_EncryptionPaddingScheme",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pkcspad.cpp",
    "lines": "26-29",
    "snippet": "size_t PKCS_EncryptionPaddingScheme::MaxUnpaddedLength(size_t paddedLength) const\n{\n\treturn SaturatingSubtract(paddedLength/8, 10U);\n}",
    "includes": [
      "#include <assert.h>",
      "#include \"pkcspad.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SaturatingSubtract",
          "args": [
            "paddedLength/8",
            "10U"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "SaturatingSubtract",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "432-435",
          "snippet": "inline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 SaturatingSubtract(const T1 &a, const T2 &b)\n{\n\treturn T1((a > b) ? (a - b) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <assert.h>\n#include \"pkcspad.h\"\n#include \"pch.h\"\n\nPKCS_EncryptionPaddingScheme {\n  size_t PKCS_EncryptionPaddingScheme::MaxUnpaddedLength(size_t paddedLength) const\n  {\n  \treturn SaturatingSubtract(paddedLength/8, 10U);\n  }\n}"
  }
]