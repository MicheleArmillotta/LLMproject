[
  {
    "function_name": "AbstractRing<T>::SimultaneousExponentiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "333-336",
    "snippet": "void AbstractRing<T>::SimultaneousExponentiate(T *results, const T &base, const Integer *exponents, unsigned int expCount) const\n{\n\tMultiplicativeGroup().AbstractGroup<T>::SimultaneousMultiply(results, base, exponents, expCount);\n}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MultiplicativeGroup",
          "args": [
            "results",
            "base",
            "exponents",
            "expCount"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiplicativeGroup",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nvoid AbstractRing<T>::SimultaneousExponentiate(T *results, const T &base, const Integer *exponents, unsigned int expCount) const\n{\n\tMultiplicativeGroup().AbstractGroup<T>::SimultaneousMultiply(results, base, exponents, expCount);\n}"
  },
  {
    "function_name": "GeneralCascadeExponentiation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "327-330",
    "snippet": "Element GeneralCascadeExponentiation(const AbstractRing<Element> &ring, Iterator begin, Iterator end)\n{\n\treturn GeneralCascadeMultiplication<Element>(ring.MultiplicativeGroup(), begin, end);\n}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GeneralCascadeMultiplication<Element>",
          "args": [
            "ring.MultiplicativeGroup()",
            "begin",
            "end"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "GeneralCascadeMultiplication",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
          "lines": "172-204",
          "snippet": "Element GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end)\n{\n\tif (end-begin == 1)\n\t\treturn group.ScalarMultiply(begin->base, begin->exponent);\n\telse if (end-begin == 2)\n\t\treturn group.CascadeScalarMultiply(begin->base, begin->exponent, (begin+1)->base, (begin+1)->exponent);\n\telse\n\t{\n\t\tInteger q, t;\n\t\tIterator last = end;\n\t\t--last;\n\n\t\tstd::make_heap(begin, end);\n\t\tstd::pop_heap(begin, end);\n\n\t\twhile (!!begin->exponent)\n\t\t{\n\t\t\t// last->exponent is largest exponent, begin->exponent is next largest\n\t\t\tt = last->exponent;\n\t\t\tInteger::Divide(last->exponent, q, t, begin->exponent);\n\n\t\t\tif (q == Integer::One())\n\t\t\t\tgroup.Accumulate(begin->base, last->base);\t// avoid overhead of ScalarMultiply()\n\t\t\telse\n\t\t\t\tgroup.Accumulate(begin->base, group.ScalarMultiply(last->base, q));\n\n\t\t\tstd::push_heap(begin, end);\n\t\t\tstd::pop_heap(begin, end);\n\t\t}\n\n\t\treturn group.ScalarMultiply(last->base, last->exponent);\n\t}\n}",
          "includes": [
            "#include <vector>",
            "#include \"integer.h\"",
            "#include \"algebra.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nElement GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end)\n{\n\tif (end-begin == 1)\n\t\treturn group.ScalarMultiply(begin->base, begin->exponent);\n\telse if (end-begin == 2)\n\t\treturn group.CascadeScalarMultiply(begin->base, begin->exponent, (begin+1)->base, (begin+1)->exponent);\n\telse\n\t{\n\t\tInteger q, t;\n\t\tIterator last = end;\n\t\t--last;\n\n\t\tstd::make_heap(begin, end);\n\t\tstd::pop_heap(begin, end);\n\n\t\twhile (!!begin->exponent)\n\t\t{\n\t\t\t// last->exponent is largest exponent, begin->exponent is next largest\n\t\t\tt = last->exponent;\n\t\t\tInteger::Divide(last->exponent, q, t, begin->exponent);\n\n\t\t\tif (q == Integer::One())\n\t\t\t\tgroup.Accumulate(begin->base, last->base);\t// avoid overhead of ScalarMultiply()\n\t\t\telse\n\t\t\t\tgroup.Accumulate(begin->base, group.ScalarMultiply(last->base, q));\n\n\t\t\tstd::push_heap(begin, end);\n\t\t\tstd::pop_heap(begin, end);\n\t\t}\n\n\t\treturn group.ScalarMultiply(last->base, last->exponent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring.MultiplicativeGroup",
          "args": [],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nElement GeneralCascadeExponentiation(const AbstractRing<Element> &ring, Iterator begin, Iterator end)\n{\n\treturn GeneralCascadeMultiplication<Element>(ring.MultiplicativeGroup(), begin, end);\n}"
  },
  {
    "function_name": "AbstractRing<T>::CascadeExponentiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "322-325",
    "snippet": "T AbstractRing<T>::CascadeExponentiate(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const\n{\n\treturn MultiplicativeGroup().AbstractGroup<T>::CascadeScalarMultiply(x, e1, y, e2);\n}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MultiplicativeGroup",
          "args": [
            "x",
            "e1",
            "y",
            "e2"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiplicativeGroup",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nT AbstractRing<T>::CascadeExponentiate(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const\n{\n\treturn MultiplicativeGroup().AbstractGroup<T>::CascadeScalarMultiply(x, e1, y, e2);\n}"
  },
  {
    "function_name": "AbstractRing<T>::Exponentiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "315-320",
    "snippet": "T AbstractRing<T>::Exponentiate(const Element &base, const Integer &exponent) const\n{\n\tElement result;\n\tSimultaneousExponentiate(&result, base, &exponent, 1);\n\treturn result;\n}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SimultaneousExponentiate",
          "args": [
            "&result",
            "base",
            "&exponent",
            "1"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "AbstractRing<T>::SimultaneousExponentiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
          "lines": "333-336",
          "snippet": "void AbstractRing<T>::SimultaneousExponentiate(T *results, const T &base, const Integer *exponents, unsigned int expCount) const\n{\n\tMultiplicativeGroup().AbstractGroup<T>::SimultaneousMultiply(results, base, exponents, expCount);\n}",
          "includes": [
            "#include <vector>",
            "#include \"integer.h\"",
            "#include \"algebra.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nvoid AbstractRing<T>::SimultaneousExponentiate(T *results, const T &base, const Integer *exponents, unsigned int expCount) const\n{\n\tMultiplicativeGroup().AbstractGroup<T>::SimultaneousMultiply(results, base, exponents, expCount);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nT AbstractRing<T>::Exponentiate(const Element &base, const Integer &exponent) const\n{\n\tElement result;\n\tSimultaneousExponentiate(&result, base, &exponent, 1);\n\treturn result;\n}"
  },
  {
    "function_name": "AbstractGroup<T>::SimultaneousMultiply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "255-313",
    "snippet": "void AbstractGroup<T>::SimultaneousMultiply(T *results, const T &base, const Integer *expBegin, unsigned int expCount) const\n{\n\tstd::vector<std::vector<Element> > buckets(expCount);\n\tstd::vector<WindowSlider> exponents;\n\texponents.reserve(expCount);\n\tunsigned int i;\n\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tassert(expBegin->NotNegative());\n\t\texponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 0));\n\t\texponents[i].FindNextWindow();\n\t\tbuckets[i].resize(1<<(exponents[i].windowSize-1), Identity());\n\t}\n\n\tunsigned int expBitPosition = 0;\n\tElement g = base;\n\tbool notDone = true;\n\n\twhile (notDone)\n\t{\n\t\tnotDone = false;\n\t\tfor (i=0; i<expCount; i++)\n\t\t{\n\t\t\tif (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)\n\t\t\t{\n\t\t\t\tElement &bucket = buckets[i][exponents[i].expWindow/2];\n\t\t\t\tif (exponents[i].negateNext)\n\t\t\t\t\tAccumulate(bucket, Inverse(g));\n\t\t\t\telse\n\t\t\t\t\tAccumulate(bucket, g);\n\t\t\t\texponents[i].FindNextWindow();\n\t\t\t}\n\t\t\tnotDone = notDone || !exponents[i].finished;\n\t\t}\n\n\t\tif (notDone)\n\t\t{\n\t\t\tg = Double(g);\n\t\t\texpBitPosition++;\n\t\t}\n\t}\n\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tElement &r = *results++;\n\t\tr = buckets[i][buckets[i].size()-1];\n\t\tif (buckets[i].size() > 1)\n\t\t{\n\t\t\tfor (int j = (int)buckets[i].size()-2; j >= 1; j--)\n\t\t\t{\n\t\t\t\tAccumulate(buckets[i][j], buckets[i][j+1]);\n\t\t\t\tAccumulate(r, buckets[i][j]);\n\t\t\t}\n\t\t\tAccumulate(buckets[i][0], buckets[i][1]);\n\t\t\tr = Add(Double(r), buckets[i][0]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Add",
          "args": [
            "Double(r)",
            "buckets[i][0]"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "26-27",
          "snippet": "Element Add(Element a, Element b) const\n\t\t{return a^b;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Add(Element a, Element b) const\n  \t\t{return a^b;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Double",
          "args": [
            "r"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "Doubled",
          "container": "PolynomialOver",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "132-132",
          "snippet": "PolynomialOver<Ring> Doubled(const Ring &ring) const {return Plus(*this, ring);}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOver {\n  PolynomialOver<Ring> Doubled(const Ring &ring) const {return Plus(*this, ring);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Accumulate",
          "args": [
            "buckets[i][0]",
            "buckets[i][1]"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Accumulate",
          "args": [
            "r",
            "buckets[i][j]"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Accumulate",
          "args": [
            "buckets[i][j]",
            "buckets[i][j+1]"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buckets[i].size",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exponents[i].FindNextWindow",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "FindNextWindow",
          "container": "WindowSlider",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
          "lines": "219-246",
          "snippet": "void FindNextWindow()\n\t{\n\t\tunsigned int expLen = exp.WordCount() * WORD_BITS;\n\t\tunsigned int skipCount = firstTime ? 0 : windowSize;\n\t\tfirstTime = false;\n\t\twhile (!exp.GetBit(skipCount))\n\t\t{\n\t\t\tif (skipCount >= expLen)\n\t\t\t{\n\t\t\t\tfinished = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tskipCount++;\n\t\t}\n\n\t\texp >>= skipCount;\n\t\twindowBegin += skipCount;\n\t\texpWindow = word32(exp % (word(1) << windowSize));\n\n\t\tif (fastNegate && exp.GetBit(windowSize))\n\t\t{\n\t\t\tnegateNext = true;\n\t\t\texpWindow = (word32(1) << windowSize) - expWindow;\n\t\t\texp += windowModulus;\n\t\t}\n\t\telse\n\t\t\tnegateNext = false;\n\t}",
          "includes": [
            "#include <vector>",
            "#include \"integer.h\"",
            "#include \"algebra.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nWindowSlider {\n  void FindNextWindow()\n  \t{\n  \t\tunsigned int expLen = exp.WordCount() * WORD_BITS;\n  \t\tunsigned int skipCount = firstTime ? 0 : windowSize;\n  \t\tfirstTime = false;\n  \t\twhile (!exp.GetBit(skipCount))\n  \t\t{\n  \t\t\tif (skipCount >= expLen)\n  \t\t\t{\n  \t\t\t\tfinished = true;\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t\tskipCount++;\n  \t\t}\n  \n  \t\texp >>= skipCount;\n  \t\twindowBegin += skipCount;\n  \t\texpWindow = word32(exp % (word(1) << windowSize));\n  \n  \t\tif (fastNegate && exp.GetBit(windowSize))\n  \t\t{\n  \t\t\tnegateNext = true;\n  \t\t\texpWindow = (word32(1) << windowSize) - expWindow;\n  \t\t\texp += windowModulus;\n  \t\t}\n  \t\telse\n  \t\t\tnegateNext = false;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Accumulate",
          "args": [
            "bucket",
            "g"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Accumulate",
          "args": [
            "bucket",
            "Inverse(g)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Inverse",
          "args": [
            "g"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "SetMultiplicativeInverseOfPrime2ModPrime1",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.h",
          "lines": "74-74",
          "snippet": "void SetMultiplicativeInverseOfPrime2ModPrime1(const Integer &u) {m_u = u;}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"pssr.h\"",
            "#include \"oaep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"pssr.h\"\n#include \"oaep.h\"\n\nInvertibleRabinFunction {\n  void SetMultiplicativeInverseOfPrime2ModPrime1(const Integer &u) {m_u = u;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buckets[i].resize",
          "args": [
            "1<<(exponents[i].windowSize-1)",
            "Identity()"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Identity",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "MultiplicativeIdentity",
          "container": "GF2_32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2_32.h",
          "lines": "44-45",
          "snippet": "Element MultiplicativeIdentity() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF2_32 {\n  Element MultiplicativeIdentity() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exponents.push_back",
          "args": [
            "WindowSlider(*expBegin++, InversionIsFast(), 0)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WindowSlider",
          "args": [
            "*expBegin++",
            "InversionIsFast()",
            "0"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InversionIsFast",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "expBegin->NotNegative()"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expBegin->NotNegative",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "NotNegative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "203-203",
          "snippet": "bool NotNegative() const {return !IsNegative();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool NotNegative() const {return !IsNegative();}"
        }
      },
      {
        "call_info": {
          "callee": "exponents.reserve",
          "args": [
            "expCount"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nvoid AbstractGroup<T>::SimultaneousMultiply(T *results, const T &base, const Integer *expBegin, unsigned int expCount) const\n{\n\tstd::vector<std::vector<Element> > buckets(expCount);\n\tstd::vector<WindowSlider> exponents;\n\texponents.reserve(expCount);\n\tunsigned int i;\n\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tassert(expBegin->NotNegative());\n\t\texponents.push_back(WindowSlider(*expBegin++, InversionIsFast(), 0));\n\t\texponents[i].FindNextWindow();\n\t\tbuckets[i].resize(1<<(exponents[i].windowSize-1), Identity());\n\t}\n\n\tunsigned int expBitPosition = 0;\n\tElement g = base;\n\tbool notDone = true;\n\n\twhile (notDone)\n\t{\n\t\tnotDone = false;\n\t\tfor (i=0; i<expCount; i++)\n\t\t{\n\t\t\tif (!exponents[i].finished && expBitPosition == exponents[i].windowBegin)\n\t\t\t{\n\t\t\t\tElement &bucket = buckets[i][exponents[i].expWindow/2];\n\t\t\t\tif (exponents[i].negateNext)\n\t\t\t\t\tAccumulate(bucket, Inverse(g));\n\t\t\t\telse\n\t\t\t\t\tAccumulate(bucket, g);\n\t\t\t\texponents[i].FindNextWindow();\n\t\t\t}\n\t\t\tnotDone = notDone || !exponents[i].finished;\n\t\t}\n\n\t\tif (notDone)\n\t\t{\n\t\t\tg = Double(g);\n\t\t\texpBitPosition++;\n\t\t}\n\t}\n\n\tfor (i=0; i<expCount; i++)\n\t{\n\t\tElement &r = *results++;\n\t\tr = buckets[i][buckets[i].size()-1];\n\t\tif (buckets[i].size() > 1)\n\t\t{\n\t\t\tfor (int j = (int)buckets[i].size()-2; j >= 1; j--)\n\t\t\t{\n\t\t\t\tAccumulate(buckets[i][j], buckets[i][j+1]);\n\t\t\t\tAccumulate(r, buckets[i][j]);\n\t\t\t}\n\t\t\tAccumulate(buckets[i][0], buckets[i][1]);\n\t\t\tr = Add(Double(r), buckets[i][0]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "FindNextWindow",
    "container": "WindowSlider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "219-246",
    "snippet": "void FindNextWindow()\n\t{\n\t\tunsigned int expLen = exp.WordCount() * WORD_BITS;\n\t\tunsigned int skipCount = firstTime ? 0 : windowSize;\n\t\tfirstTime = false;\n\t\twhile (!exp.GetBit(skipCount))\n\t\t{\n\t\t\tif (skipCount >= expLen)\n\t\t\t{\n\t\t\t\tfinished = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tskipCount++;\n\t\t}\n\n\t\texp >>= skipCount;\n\t\twindowBegin += skipCount;\n\t\texpWindow = word32(exp % (word(1) << windowSize));\n\n\t\tif (fastNegate && exp.GetBit(windowSize))\n\t\t{\n\t\t\tnegateNext = true;\n\t\t\texpWindow = (word32(1) << windowSize) - expWindow;\n\t\t\texp += windowModulus;\n\t\t}\n\t\telse\n\t\t\tnegateNext = false;\n\t}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "1"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.GetBit",
          "args": [
            "windowSize"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word32",
          "args": [
            "exp % (word(1) << windowSize)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "word",
          "args": [
            "1"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ValidateDomainParameters",
          "container": "PasswordAuthenticatedKeyAgreementDomain",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "1612-1613",
          "snippet": "virtual bool ValidateDomainParameters(RandomNumberGenerator &rng) const\n\t\t{return GetCryptoParameters().Validate(rng, 2);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nPasswordAuthenticatedKeyAgreementDomain {\n  virtual bool ValidateDomainParameters(RandomNumberGenerator &rng) const\n  \t\t{return GetCryptoParameters().Validate(rng, 2);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp.GetBit",
          "args": [
            "skipCount"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp.WordCount",
          "args": [],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nWindowSlider {\n  void FindNextWindow()\n  \t{\n  \t\tunsigned int expLen = exp.WordCount() * WORD_BITS;\n  \t\tunsigned int skipCount = firstTime ? 0 : windowSize;\n  \t\tfirstTime = false;\n  \t\twhile (!exp.GetBit(skipCount))\n  \t\t{\n  \t\t\tif (skipCount >= expLen)\n  \t\t\t{\n  \t\t\t\tfinished = true;\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t\tskipCount++;\n  \t\t}\n  \n  \t\texp >>= skipCount;\n  \t\twindowBegin += skipCount;\n  \t\texpWindow = word32(exp % (word(1) << windowSize));\n  \n  \t\tif (fastNegate && exp.GetBit(windowSize))\n  \t\t{\n  \t\t\tnegateNext = true;\n  \t\t\texpWindow = (word32(1) << windowSize) - expWindow;\n  \t\t\texp += windowModulus;\n  \t\t}\n  \t\telse\n  \t\t\tnegateNext = false;\n  \t}\n}"
  },
  {
    "function_name": "WindowSlider",
    "container": "WindowSlider",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "208-217",
    "snippet": "WindowSlider(const Integer &expIn, bool fastNegate, unsigned int windowSizeIn=0)\n\t\t: exp(expIn), windowModulus(Integer::One()), windowSize(windowSizeIn), windowBegin(0), fastNegate(fastNegate), firstTime(true), finished(false)\n\t{\n\t\tif (windowSize == 0)\n\t\t{\n\t\t\tunsigned int expLen = exp.BitCount();\n\t\t\twindowSize = expLen <= 17 ? 1 : (expLen <= 24 ? 2 : (expLen <= 70 ? 3 : (expLen <= 197 ? 4 : (expLen <= 539 ? 5 : (expLen <= 1434 ? 6 : 7)))));\n\t\t}\n\t\twindowModulus <<= windowSize;\n\t}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp.BitCount",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nWindowSlider {\n  WindowSlider(const Integer &expIn, bool fastNegate, unsigned int windowSizeIn=0)\n  \t\t: exp(expIn), windowModulus(Integer::One()), windowSize(windowSizeIn), windowBegin(0), fastNegate(fastNegate), firstTime(true), finished(false)\n  \t{\n  \t\tif (windowSize == 0)\n  \t\t{\n  \t\t\tunsigned int expLen = exp.BitCount();\n  \t\t\twindowSize = expLen <= 17 ? 1 : (expLen <= 24 ? 2 : (expLen <= 70 ? 3 : (expLen <= 197 ? 4 : (expLen <= 539 ? 5 : (expLen <= 1434 ? 6 : 7)))));\n  \t\t}\n  \t\twindowModulus <<= windowSize;\n  \t}\n}"
  },
  {
    "function_name": "GeneralCascadeMultiplication",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "172-204",
    "snippet": "Element GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end)\n{\n\tif (end-begin == 1)\n\t\treturn group.ScalarMultiply(begin->base, begin->exponent);\n\telse if (end-begin == 2)\n\t\treturn group.CascadeScalarMultiply(begin->base, begin->exponent, (begin+1)->base, (begin+1)->exponent);\n\telse\n\t{\n\t\tInteger q, t;\n\t\tIterator last = end;\n\t\t--last;\n\n\t\tstd::make_heap(begin, end);\n\t\tstd::pop_heap(begin, end);\n\n\t\twhile (!!begin->exponent)\n\t\t{\n\t\t\t// last->exponent is largest exponent, begin->exponent is next largest\n\t\t\tt = last->exponent;\n\t\t\tInteger::Divide(last->exponent, q, t, begin->exponent);\n\n\t\t\tif (q == Integer::One())\n\t\t\t\tgroup.Accumulate(begin->base, last->base);\t// avoid overhead of ScalarMultiply()\n\t\t\telse\n\t\t\t\tgroup.Accumulate(begin->base, group.ScalarMultiply(last->base, q));\n\n\t\t\tstd::push_heap(begin, end);\n\t\t\tstd::pop_heap(begin, end);\n\t\t}\n\n\t\treturn group.ScalarMultiply(last->base, last->exponent);\n\t}\n}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "group.ScalarMultiply",
          "args": [
            "last->base",
            "last->exponent"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::pop_heap",
          "args": [
            "begin",
            "end"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::push_heap",
          "args": [
            "begin",
            "end"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group.Accumulate",
          "args": [
            "begin->base",
            "group.ScalarMultiply(last->base, q)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group.ScalarMultiply",
          "args": [
            "last->base",
            "q"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group.Accumulate",
          "args": [
            "begin->base",
            "last->base"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Divide",
          "args": [
            "last->exponent",
            "q",
            "t",
            "begin->exponent"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Divide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3794-3828",
          "snippet": "void Integer::Divide(word &remainder, Integer &quotient, const Integer &dividend, word divisor)\n{\n\tif (!divisor)\n\t\tthrow Integer::DivideByZero();\n\n\tassert(divisor);\n\n\tif ((divisor & (divisor-1)) == 0)\t// divisor is a power of 2\n\t{\n\t\tquotient = dividend >> (BitPrecision(divisor)-1);\n\t\tremainder = dividend.reg[0] & (divisor-1);\n\t\treturn;\n\t}\n\n\tunsigned int i = dividend.WordCount();\n\tquotient.reg.CleanNew(RoundupSize(i));\n\tremainder = 0;\n\twhile (i--)\n\t{\n\t\tquotient.reg[i] = DWord(dividend.reg[i], remainder) / divisor;\n\t\tremainder = DWord(dividend.reg[i], remainder) % divisor;\n\t}\n\n\tif (dividend.NotNegative())\n\t\tquotient.sign = POSITIVE;\n\telse\n\t{\n\t\tquotient.sign = NEGATIVE;\n\t\tif (remainder)\n\t\t{\n\t\t\t--quotient;\n\t\t\tremainder = divisor - remainder;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nvoid Integer::Divide(word &remainder, Integer &quotient, const Integer &dividend, word divisor)\n{\n\tif (!divisor)\n\t\tthrow Integer::DivideByZero();\n\n\tassert(divisor);\n\n\tif ((divisor & (divisor-1)) == 0)\t// divisor is a power of 2\n\t{\n\t\tquotient = dividend >> (BitPrecision(divisor)-1);\n\t\tremainder = dividend.reg[0] & (divisor-1);\n\t\treturn;\n\t}\n\n\tunsigned int i = dividend.WordCount();\n\tquotient.reg.CleanNew(RoundupSize(i));\n\tremainder = 0;\n\twhile (i--)\n\t{\n\t\tquotient.reg[i] = DWord(dividend.reg[i], remainder) / divisor;\n\t\tremainder = DWord(dividend.reg[i], remainder) % divisor;\n\t}\n\n\tif (dividend.NotNegative())\n\t\tquotient.sign = POSITIVE;\n\telse\n\t{\n\t\tquotient.sign = NEGATIVE;\n\t\tif (remainder)\n\t\t{\n\t\t\t--quotient;\n\t\t\tremainder = divisor - remainder;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::pop_heap",
          "args": [
            "begin",
            "end"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_heap",
          "args": [
            "begin",
            "end"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group.CascadeScalarMultiply",
          "args": [
            "begin->base",
            "begin->exponent",
            "(begin+1)->base",
            "(begin+1)->exponent"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group.ScalarMultiply",
          "args": [
            "begin->base",
            "begin->exponent"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nElement GeneralCascadeMultiplication(const AbstractGroup<Element> &group, Iterator begin, Iterator end)\n{\n\tif (end-begin == 1)\n\t\treturn group.ScalarMultiply(begin->base, begin->exponent);\n\telse if (end-begin == 2)\n\t\treturn group.CascadeScalarMultiply(begin->base, begin->exponent, (begin+1)->base, (begin+1)->exponent);\n\telse\n\t{\n\t\tInteger q, t;\n\t\tIterator last = end;\n\t\t--last;\n\n\t\tstd::make_heap(begin, end);\n\t\tstd::pop_heap(begin, end);\n\n\t\twhile (!!begin->exponent)\n\t\t{\n\t\t\t// last->exponent is largest exponent, begin->exponent is next largest\n\t\t\tt = last->exponent;\n\t\t\tInteger::Divide(last->exponent, q, t, begin->exponent);\n\n\t\t\tif (q == Integer::One())\n\t\t\t\tgroup.Accumulate(begin->base, last->base);\t// avoid overhead of ScalarMultiply()\n\t\t\telse\n\t\t\t\tgroup.Accumulate(begin->base, group.ScalarMultiply(last->base, q));\n\n\t\t\tstd::push_heap(begin, end);\n\t\t\tstd::pop_heap(begin, end);\n\t\t}\n\n\t\treturn group.ScalarMultiply(last->base, last->exponent);\n\t}\n}"
  },
  {
    "function_name": "AbstractGroup<T>::CascadeScalarMultiply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "97-170",
    "snippet": "T AbstractGroup<T>::CascadeScalarMultiply(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const\n{\n\tconst unsigned expLen = STDMAX(e1.BitCount(), e2.BitCount());\n\tif (expLen==0)\n\t\treturn this->Identity();\n\n\tconst unsigned w = (expLen <= 46 ? 1 : (expLen <= 260 ? 2 : 3));\n\tconst unsigned tableSize = 1<<w;\n\tstd::vector<Element> powerTable(tableSize << w);\n\n\tpowerTable[1] = x;\n\tpowerTable[tableSize] = y;\n\tif (w==1)\n\t\tpowerTable[3] = this->Add(x,y);\n\telse\n\t{\n\t\tpowerTable[2] = this->Double(x);\n\t\tpowerTable[2*tableSize] = this->Double(y);\n\n\t\tunsigned i, j;\n\n\t\tfor (i=3; i<tableSize; i+=2)\n\t\t\tpowerTable[i] = Add(powerTable[i-2], powerTable[2]);\n\t\tfor (i=1; i<tableSize; i+=2)\n\t\t\tfor (j=i+tableSize; j<(tableSize<<w); j+=tableSize)\n\t\t\t\tpowerTable[j] = Add(powerTable[j-tableSize], y);\n\n\t\tfor (i=3*tableSize; i<(tableSize<<w); i+=2*tableSize)\n\t\t\tpowerTable[i] = Add(powerTable[i-2*tableSize], powerTable[2*tableSize]);\n\t\tfor (i=tableSize; i<(tableSize<<w); i+=2*tableSize)\n\t\t\tfor (j=i+2; j<i+tableSize; j+=2)\n\t\t\t\tpowerTable[j] = Add(powerTable[j-1], x);\n\t}\n\n\tElement result;\n\tunsigned power1 = 0, power2 = 0, prevPosition = expLen-1;\n\tbool firstTime = true;\n\n\tfor (int i = expLen-1; i>=0; i--)\n\t{\n\t\tpower1 = 2*power1 + e1.GetBit(i);\n\t\tpower2 = 2*power2 + e2.GetBit(i);\n\n\t\tif (i==0 || 2*power1 >= tableSize || 2*power2 >= tableSize)\n\t\t{\n\t\t\tunsigned squaresBefore = prevPosition-i;\n\t\t\tunsigned squaresAfter = 0;\n\t\t\tprevPosition = i;\n\t\t\twhile ((power1 || power2) && power1%2 == 0 && power2%2==0)\n\t\t\t{\n\t\t\t\tpower1 /= 2;\n\t\t\t\tpower2 /= 2;\n\t\t\t\tsquaresBefore--;\n\t\t\t\tsquaresAfter++;\n\t\t\t}\n\t\t\tif (firstTime)\n\t\t\t{\n\t\t\t\tresult = powerTable[(power2<<w) + power1];\n\t\t\t\tfirstTime = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (squaresBefore--)\n\t\t\t\t\tresult = this->Double(result);\n\t\t\t\tif (power1 || power2)\n\t\t\t\t\tAccumulate(result, powerTable[(power2<<w) + power1]);\n\t\t\t}\n\t\t\twhile (squaresAfter--)\n\t\t\t\tresult = this->Double(result);\n\t\t\tpower1 = power2 = 0;\n\t\t}\n\t}\n\treturn result;\n}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->Double",
          "args": [
            "result"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "Double",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "41-42",
          "snippet": "Element Double(Element a) const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Double(Element a) const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Accumulate",
          "args": [
            "result",
            "powerTable[(power2<<w) + power1]"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e2.GetBit",
          "args": [
            "i"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e1.GetBit",
          "args": [
            "i"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Add",
          "args": [
            "powerTable[j-1]",
            "x"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "26-27",
          "snippet": "Element Add(Element a, Element b) const\n\t\t{return a^b;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Add(Element a, Element b) const\n  \t\t{return a^b;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->Identity",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "Identity",
          "container": "GF2_32",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2_32.h",
          "lines": "23-24",
          "snippet": "Element Identity() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF2_32 {\n  Element Identity() const\n  \t\t{return 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "STDMAX",
          "args": [
            "e1.BitCount()",
            "e2.BitCount()"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e2.BitCount",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e1.BitCount",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nT AbstractGroup<T>::CascadeScalarMultiply(const Element &x, const Integer &e1, const Element &y, const Integer &e2) const\n{\n\tconst unsigned expLen = STDMAX(e1.BitCount(), e2.BitCount());\n\tif (expLen==0)\n\t\treturn this->Identity();\n\n\tconst unsigned w = (expLen <= 46 ? 1 : (expLen <= 260 ? 2 : 3));\n\tconst unsigned tableSize = 1<<w;\n\tstd::vector<Element> powerTable(tableSize << w);\n\n\tpowerTable[1] = x;\n\tpowerTable[tableSize] = y;\n\tif (w==1)\n\t\tpowerTable[3] = this->Add(x,y);\n\telse\n\t{\n\t\tpowerTable[2] = this->Double(x);\n\t\tpowerTable[2*tableSize] = this->Double(y);\n\n\t\tunsigned i, j;\n\n\t\tfor (i=3; i<tableSize; i+=2)\n\t\t\tpowerTable[i] = Add(powerTable[i-2], powerTable[2]);\n\t\tfor (i=1; i<tableSize; i+=2)\n\t\t\tfor (j=i+tableSize; j<(tableSize<<w); j+=tableSize)\n\t\t\t\tpowerTable[j] = Add(powerTable[j-tableSize], y);\n\n\t\tfor (i=3*tableSize; i<(tableSize<<w); i+=2*tableSize)\n\t\t\tpowerTable[i] = Add(powerTable[i-2*tableSize], powerTable[2*tableSize]);\n\t\tfor (i=tableSize; i<(tableSize<<w); i+=2*tableSize)\n\t\t\tfor (j=i+2; j<i+tableSize; j+=2)\n\t\t\t\tpowerTable[j] = Add(powerTable[j-1], x);\n\t}\n\n\tElement result;\n\tunsigned power1 = 0, power2 = 0, prevPosition = expLen-1;\n\tbool firstTime = true;\n\n\tfor (int i = expLen-1; i>=0; i--)\n\t{\n\t\tpower1 = 2*power1 + e1.GetBit(i);\n\t\tpower2 = 2*power2 + e2.GetBit(i);\n\n\t\tif (i==0 || 2*power1 >= tableSize || 2*power2 >= tableSize)\n\t\t{\n\t\t\tunsigned squaresBefore = prevPosition-i;\n\t\t\tunsigned squaresAfter = 0;\n\t\t\tprevPosition = i;\n\t\t\twhile ((power1 || power2) && power1%2 == 0 && power2%2==0)\n\t\t\t{\n\t\t\t\tpower1 /= 2;\n\t\t\t\tpower2 /= 2;\n\t\t\t\tsquaresBefore--;\n\t\t\t\tsquaresAfter++;\n\t\t\t}\n\t\t\tif (firstTime)\n\t\t\t{\n\t\t\t\tresult = powerTable[(power2<<w) + power1];\n\t\t\t\tfirstTime = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (squaresBefore--)\n\t\t\t\t\tresult = this->Double(result);\n\t\t\t\tif (power1 || power2)\n\t\t\t\t\tAccumulate(result, powerTable[(power2<<w) + power1]);\n\t\t\t}\n\t\t\twhile (squaresAfter--)\n\t\t\t\tresult = this->Double(result);\n\t\t\tpower1 = power2 = 0;\n\t\t}\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "AbstractGroup<T>::ScalarMultiply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algebra.cpp",
    "lines": "90-95",
    "snippet": "T AbstractGroup<T>::ScalarMultiply(const Element &base, const Integer &exponent) const\n{\n\tElement result;\n\tthis->SimultaneousMultiply(&result, base, &exponent, 1);\n\treturn result;\n}",
    "includes": [
      "#include <vector>",
      "#include \"integer.h\"",
      "#include \"algebra.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->SimultaneousMultiply",
          "args": [
            "&result",
            "base",
            "&exponent",
            "1"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include \"integer.h\"\n#include \"algebra.h\"\n#include \"pch.h\"\n\nT AbstractGroup<T>::ScalarMultiply(const Element &base, const Integer &exponent) const\n{\n\tElement result;\n\tthis->SimultaneousMultiply(&result, base, &exponent, 1);\n\treturn result;\n}"
  }
]