[
  {
    "function_name": "InvertibleLUCFunction::AssignFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "201-208",
    "snippet": "void InvertibleLUCFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper<LUCFunction>(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "MultiplicativeInverseOfPrime2ModPrime1"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Prime2"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Prime1"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper<LUCFunction>",
          "args": [
            "this",
            "source"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid InvertibleLUCFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper<LUCFunction>(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}"
  },
  {
    "function_name": "InvertibleLUCFunction::GetVoidValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "192-199",
    "snippet": "bool InvertibleLUCFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper<LUCFunction>(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "MultiplicativeInverseOfPrime2ModPrime1"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Prime2"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Prime1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper<LUCFunction>",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper<LUCFunction>",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nbool InvertibleLUCFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper<LUCFunction>(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}"
  },
  {
    "function_name": "InvertibleLUCFunction::Validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "172-190",
    "snippet": "bool InvertibleLUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = LUCFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p.IsOdd() && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q.IsOdd() && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && RelativelyPrime(m_e, m_p+1);\n\t\tpass = pass && RelativelyPrime(m_e, m_p-1);\n\t\tpass = pass && RelativelyPrime(m_e, m_q+1);\n\t\tpass = pass && RelativelyPrime(m_e, m_q-1);\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyPrime",
          "args": [
            "rng",
            "m_q",
            "level-2"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "247-253",
          "snippet": "bool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelativelyPrime",
          "args": [
            "m_e",
            "m_q-1"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "RelativelyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "65-66",
          "snippet": "inline bool RelativelyPrime(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b) == Integer::One();}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline bool RelativelyPrime(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b) == Integer::One();}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.IsPositive",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "IsPositive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "205-205",
          "snippet": "bool IsPositive() const {return NotNegative() && NotZero();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsPositive() const {return NotNegative() && NotZero();}"
        }
      },
      {
        "call_info": {
          "callee": "m_q.IsOdd",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nbool InvertibleLUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = LUCFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p.IsOdd() && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q.IsOdd() && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && RelativelyPrime(m_e, m_p+1);\n\t\tpass = pass && RelativelyPrime(m_e, m_p-1);\n\t\tpass = pass && RelativelyPrime(m_e, m_q+1);\n\t\tpass = pass && RelativelyPrime(m_e, m_q-1);\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}"
  },
  {
    "function_name": "InvertibleLUCFunction::CalculateInverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "165-170",
    "snippet": "Integer InvertibleLUCFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\t// not clear how to do blinding with LUC\n\tDoQuickSanityCheck();\n\treturn InverseLucas(m_e, x, m_q, m_p, m_u);\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InverseLucas",
          "args": [
            "m_e",
            "x",
            "m_q",
            "m_p",
            "m_u"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "InverseLucas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "998-1017",
          "snippet": "Integer InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q, const Integer &u)\n{\n\tInteger d = (m*m-4);\n\tInteger p2, q2;\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tp2 = p-Jacobi(d,p);\n\t\t\t\tp2 = Lucas(EuclideanMultiplicativeInverse(e,p2), m, p);\n\t\t\t}\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tq2 = q-Jacobi(d,q);\n\t\t\t\tq2 = Lucas(EuclideanMultiplicativeInverse(e,q2), m, q);\n\t\t\t}\n\t\t}\n\treturn CRT(p2, p, q2, q, u);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q, const Integer &u)\n{\n\tInteger d = (m*m-4);\n\tInteger p2, q2;\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tp2 = p-Jacobi(d,p);\n\t\t\t\tp2 = Lucas(EuclideanMultiplicativeInverse(e,p2), m, p);\n\t\t\t}\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tq2 = q-Jacobi(d,q);\n\t\t\t\tq2 = Lucas(EuclideanMultiplicativeInverse(e,q2), m, q);\n\t\t\t}\n\t\t}\n\treturn CRT(p2, p, q2, q, u);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoQuickSanityCheck",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInteger InvertibleLUCFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\t// not clear how to do blinding with LUC\n\tDoQuickSanityCheck();\n\treturn InverseLucas(m_e, x, m_q, m_p, m_u);\n}"
  },
  {
    "function_name": "InvertibleLUCFunction::DEREncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "151-163",
    "snippet": "void InvertibleLUCFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\n\tconst byte version[] = {INTEGER, 1, 0};\n\tseq.Put(version, sizeof(version));\n\tm_n.DEREncode(seq);\n\tm_e.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "807-808",
          "snippet": "bool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nbool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.DEREncode",
          "args": [
            "seq"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rsa.h",
          "lines": "67-68",
          "snippet": "void DEREncode(BufferedTransformation &bt) const\n\t\t{PKCS8PrivateKey::DEREncode(bt);}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\"",
            "#include \"asn.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n#include \"asn.h\"\n#include \"pubkey.h\"\n\nvoid DEREncode(BufferedTransformation &bt) const\n\t\t{PKCS8PrivateKey::DEREncode(bt);}"
        }
      },
      {
        "call_info": {
          "callee": "seq.Put",
          "args": [
            "version",
            "sizeof(version)"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "ByteQueueNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "42-49",
          "snippet": "inline size_t Put(const byte *begin, size_t length)\n\t{\n\t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n\t\tif (buf+m_tail != begin)\n\t\t\tmemcpy(buf+m_tail, begin, l);\n\t\tm_tail += l;\n\t\treturn l;\n\t}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueueNode {\n  inline size_t Put(const byte *begin, size_t length)\n  \t{\n  \t\tsize_t l = STDMIN(length, MaxSize()-m_tail);\n  \t\tif (buf+m_tail != begin)\n  \t\t\tmemcpy(buf+m_tail, begin, l);\n  \t\tm_tail += l;\n  \t\treturn l;\n  \t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid InvertibleLUCFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\n\tconst byte version[] = {INTEGER, 1, 0};\n\tseq.Put(version, sizeof(version));\n\tm_n.DEREncode(seq);\n\tm_e.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}"
  },
  {
    "function_name": "InvertibleLUCFunction::BERDecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "135-149",
    "snippet": "void InvertibleLUCFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\n\tInteger version(seq);\n\tif (!!version)  // make sure version is 0\n\t\tBERDecodeError();\n\n\tm_n.BERDecode(seq);\n\tm_e.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "807-808",
          "snippet": "bool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nbool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.BERDecode",
          "args": [
            "seq"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rsa.h",
          "lines": "65-66",
          "snippet": "void BERDecode(BufferedTransformation &bt)\n\t\t{PKCS8PrivateKey::BERDecode(bt);}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\"",
            "#include \"asn.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n#include \"asn.h\"\n#include \"pubkey.h\"\n\nvoid BERDecode(BufferedTransformation &bt)\n\t\t{PKCS8PrivateKey::BERDecode(bt);}"
        }
      },
      {
        "call_info": {
          "callee": "BERDecodeError",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.h",
          "lines": "49-49",
          "snippet": "inline void BERDecodeError() {throw BERDecodeErr();}",
          "includes": [
            "#include <vector>",
            "#include \"queue.h\"",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"queue.h\"\n#include \"filters.h\"\n\ninline void BERDecodeError() {throw BERDecodeErr();}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid InvertibleLUCFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\n\tInteger version(seq);\n\tif (!!version)  // make sure version is 0\n\t\tBERDecodeError();\n\n\tm_n.BERDecode(seq);\n\tm_e.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}"
  },
  {
    "function_name": "InvertibleLUCFunction::Initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "130-133",
    "snippet": "void InvertibleLUCFunction::Initialize(RandomNumberGenerator &rng, unsigned int keybits, const Integer &e)\n{\n\tGenerateRandom(rng, MakeParameters(\"ModulusSize\", (int)keybits)(\"PublicExponent\", e));\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenerateRandom",
          "args": [
            "rng",
            "MakeParameters(\"ModulusSize\", (int)keybits)(\"PublicExponent\", e)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "InvertibleRabinFunction::GenerateRandom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "75-114",
          "snippet": "void InvertibleRabinFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleRabinFunction: specified modulus size is too small\");\n\n\t// VC70 workaround: putting these after primeParam causes overlapped stack allocation\n\tbool rFound=false, sFound=false;\n\tInteger t=2;\n\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"EquivalentTo\", 3)(\"Mod\", 4);\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\twhile (!(rFound && sFound))\n\t{\n\t\tint jp = Jacobi(t, m_p);\n\t\tint jq = Jacobi(t, m_q);\n\n\t\tif (!rFound && jp==1 && jq==-1)\n\t\t{\n\t\t\tm_r = t;\n\t\t\trFound = true;\n\t\t}\n\n\t\tif (!sFound && jp==-1 && jq==1)\n\t\t{\n\t\t\tm_s = t;\n\t\t\tsFound = true;\n\t\t}\n\n\t\t++t;\n\t}\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
          "includes": [
            "#include \"modarith.h\"",
            "#include \"sha.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rabin.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nvoid InvertibleRabinFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleRabinFunction: specified modulus size is too small\");\n\n\t// VC70 workaround: putting these after primeParam causes overlapped stack allocation\n\tbool rFound=false, sFound=false;\n\tInteger t=2;\n\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"EquivalentTo\", 3)(\"Mod\", 4);\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\twhile (!(rFound && sFound))\n\t{\n\t\tint jp = Jacobi(t, m_p);\n\t\tint jq = Jacobi(t, m_q);\n\n\t\tif (!rFound && jp==1 && jq==-1)\n\t\t{\n\t\t\tm_r = t;\n\t\t\trFound = true;\n\t\t}\n\n\t\tif (!sFound && jp==-1 && jq==1)\n\t\t{\n\t\t\tm_s = t;\n\t\t\tsFound = true;\n\t\t}\n\n\t\t++t;\n\t}\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"PublicExponent\"",
            "e"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid InvertibleLUCFunction::Initialize(RandomNumberGenerator &rng, unsigned int keybits, const Integer &e)\n{\n\tGenerateRandom(rng, MakeParameters(\"ModulusSize\", (int)keybits)(\"PublicExponent\", e));\n}"
  },
  {
    "function_name": "InvertibleLUCFunction::GenerateRandom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "107-128",
    "snippet": "void InvertibleLUCFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: specified modulus size is too small\");\n\n\tm_e = alg.GetValueWithDefault(\"PublicExponent\", Integer(17));\n\n\tif (m_e < 5 || m_e.IsEven())\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: invalid public exponent\");\n\n\tLUCPrimeSelector selector(m_e);\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"PointerToPrimeSelector\", selector.GetSelectorPointer());\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_q.InverseMod",
          "args": [
            "m_p"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_q.GenerateRandom",
          "args": [
            "rng",
            "primeParam"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateRandom",
          "container": "DL_PrivateKeyImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/pubkey.h",
          "lines": "779-788",
          "snippet": "void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params)\n\t{\n\t\tif (!params.GetThisObject(this->AccessGroupParameters()))\n\t\t\tthis->AccessGroupParameters().GenerateRandom(rng, params);\n//\t\tstd::pair<const byte *, int> seed;\n\t\tInteger x(rng, Integer::One(), GetAbstractGroupParameters().GetMaxExponent());\n//\t\t\tInteger::ANY, Integer::Zero(), Integer::One(),\n//\t\t\tparams.GetValue(\"DeterministicKeyGenerationSeed\", seed) ? &seed : NULL);\n\t\tSetPrivateExponent(x);\n\t}",
          "includes": [
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"eprecomp.h\"",
            "#include \"filters.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"eprecomp.h\"\n#include \"filters.h\"\n#include \"modarith.h\"\n\nDL_PrivateKeyImpl {\n  void GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &params)\n  \t{\n  \t\tif (!params.GetThisObject(this->AccessGroupParameters()))\n  \t\t\tthis->AccessGroupParameters().GenerateRandom(rng, params);\n  //\t\tstd::pair<const byte *, int> seed;\n  \t\tInteger x(rng, Integer::One(), GetAbstractGroupParameters().GetMaxExponent());\n  //\t\t\tInteger::ANY, Integer::Zero(), Integer::One(),\n  //\t\t\tparams.GetValue(\"DeterministicKeyGenerationSeed\", seed) ? &seed : NULL);\n  \t\tSetPrivateExponent(x);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeParametersForTwoPrimesOfEqualSize",
          "args": [
            "\"PointerToPrimeSelector\"",
            "selector.GetSelectorPointer()"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selector.GetSelectorPointer",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParametersForTwoPrimesOfEqualSize",
          "args": [
            "modulusSize"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParametersForTwoPrimesOfEqualSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "265-284",
          "snippet": "AlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nAlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"InvertibleLUCFunction: invalid public exponent\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_e.IsEven",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "IsEven",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "209-209",
          "snippet": "bool IsEven() const {return GetBit(0) == 0;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsEven() const {return GetBit(0) == 0;}"
        }
      },
      {
        "call_info": {
          "callee": "alg.GetValueWithDefault",
          "args": [
            "\"PublicExponent\"",
            "Integer(17)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "17"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "Integer::Integer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3034-3038",
          "snippet": "Integer::Integer(const wchar_t *str)\n\t: reg(2), sign(POSITIVE)\n{\n\t*this = StringToInteger(str);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger::Integer(const wchar_t *str)\n\t: reg(2), sign(POSITIVE)\n{\n\t*this = StringToInteger(str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"InvertibleLUCFunction: specified modulus size is too small\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alg.GetIntValue",
          "args": [
            "\"KeySize\"",
            "modulusSize"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alg.GetIntValue",
          "args": [
            "\"ModulusSize\"",
            "modulusSize"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid InvertibleLUCFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: specified modulus size is too small\");\n\n\tm_e = alg.GetValueWithDefault(\"PublicExponent\", Integer(17));\n\n\tif (m_e < 5 || m_e.IsEven())\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: invalid public exponent\");\n\n\tLUCPrimeSelector selector(m_e);\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"PointerToPrimeSelector\", selector.GetSelectorPointer());\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}"
  },
  {
    "function_name": "IsAcceptable",
    "container": "LUCPrimeSelector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "100-103",
    "snippet": "bool IsAcceptable(const Integer &candidate) const\n\t{\n\t\treturn RelativelyPrime(m_e, candidate+1) && RelativelyPrime(m_e, candidate-1);\n\t}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelativelyPrime",
          "args": [
            "m_e",
            "candidate-1"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "RelativelyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "65-66",
          "snippet": "inline bool RelativelyPrime(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b) == Integer::One();}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline bool RelativelyPrime(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b) == Integer::One();}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCPrimeSelector {\n  bool IsAcceptable(const Integer &candidate) const\n  \t{\n  \t\treturn RelativelyPrime(m_e, candidate+1) && RelativelyPrime(m_e, candidate-1);\n  \t}\n}"
  },
  {
    "function_name": "LUCPrimeSelector",
    "container": "LUCPrimeSelector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "99-99",
    "snippet": "LUCPrimeSelector(const Integer &e) : m_e(e) {}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCPrimeSelector {\n  LUCPrimeSelector(const Integer &e) : m_e(e) {}\n}"
  },
  {
    "function_name": "LUCFunction::AssignFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "85-91",
    "snippet": "void LUCFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(PublicExponent)\n\t\t;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "PublicExponent"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper",
          "args": [
            "this",
            "source"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid LUCFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(PublicExponent)\n\t\t;\n}"
  },
  {
    "function_name": "LUCFunction::GetVoidValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "77-83",
    "snippet": "bool LUCFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(PublicExponent)\n\t\t;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "PublicExponent"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nbool LUCFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(PublicExponent)\n\t\t;\n}"
  },
  {
    "function_name": "LUCFunction::Validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "69-75",
    "snippet": "bool LUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = true;\n\tpass = pass && m_n > Integer::One() && m_n.IsOdd();\n\tpass = pass && m_e > Integer::One() && m_e.IsOdd() && m_e < m_n;\n\treturn pass;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_e.IsOdd",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nbool LUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = true;\n\tpass = pass && m_n > Integer::One() && m_n.IsOdd();\n\tpass = pass && m_e > Integer::One() && m_e.IsOdd() && m_e < m_n;\n\treturn pass;\n}"
  },
  {
    "function_name": "LUCFunction::ApplyFunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "63-67",
    "snippet": "Integer LUCFunction::ApplyFunction(const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\treturn Lucas(m_e, x, m_n);\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "m_e",
            "x",
            "m_n"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DoQuickSanityCheck",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInteger LUCFunction::ApplyFunction(const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\treturn Lucas(m_e, x, m_n);\n}"
  },
  {
    "function_name": "LUCFunction::DEREncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "55-61",
    "snippet": "void LUCFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_e.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "807-808",
          "snippet": "bool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nbool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "m_e.DEREncode",
          "args": [
            "seq"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rsa.h",
          "lines": "67-68",
          "snippet": "void DEREncode(BufferedTransformation &bt) const\n\t\t{PKCS8PrivateKey::DEREncode(bt);}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\"",
            "#include \"asn.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n#include \"asn.h\"\n#include \"pubkey.h\"\n\nvoid DEREncode(BufferedTransformation &bt) const\n\t\t{PKCS8PrivateKey::DEREncode(bt);}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid LUCFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_e.DEREncode(seq);\n\tseq.MessageEnd();\n}"
  },
  {
    "function_name": "LUCFunction::BERDecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "47-53",
    "snippet": "void LUCFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_e.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "807-808",
          "snippet": "bool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nbool MessageEnd(int propagation=-1, bool blocking=true)\n\t\t\t{return !!Put2(NULL, 0, propagation < 0 ? -1 : propagation+1, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "m_e.BERDecode",
          "args": [
            "seq"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rsa.h",
          "lines": "65-66",
          "snippet": "void BERDecode(BufferedTransformation &bt)\n\t\t{PKCS8PrivateKey::BERDecode(bt);}",
          "includes": [
            "#include \"emsa2.h\"",
            "#include \"oaep.h\"",
            "#include \"pkcspad.h\"",
            "#include \"asn.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"emsa2.h\"\n#include \"oaep.h\"\n#include \"pkcspad.h\"\n#include \"asn.h\"\n#include \"pubkey.h\"\n\nvoid BERDecode(BufferedTransformation &bt)\n\t\t{PKCS8PrivateKey::BERDecode(bt);}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid LUCFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_e.BERDecode(seq);\n\tseq.MessageEnd();\n}"
  },
  {
    "function_name": "DL_GroupParameters_LUC::SimultaneousExponentiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "41-45",
    "snippet": "void DL_GroupParameters_LUC::SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const\n{\n\tfor (unsigned int i=0; i<exponentsCount; i++)\n\t\tresults[i] = Lucas(exponents[i], base, GetModulus());\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "exponents[i]",
            "base",
            "GetModulus()"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetModulus",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid DL_GroupParameters_LUC::SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const\n{\n\tfor (unsigned int i=0; i<exponentsCount; i++)\n\t\tresults[i] = Lucas(exponents[i], base, GetModulus());\n}"
  },
  {
    "function_name": "DL_BasePrecomputation_LUC::Exponentiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "36-39",
    "snippet": "Integer DL_BasePrecomputation_LUC::Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const\n{\n\treturn Lucas(exponent, m_g, static_cast<const DL_GroupPrecomputation_LUC &>(group).GetModulus());\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "exponent",
            "m_g",
            "static_cast<const DL_GroupPrecomputation_LUC &>(group).GetModulus()"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const DL_GroupPrecomputation_LUC &>",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const DL_GroupPrecomputation_LUC &>",
          "args": [
            "group"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInteger DL_BasePrecomputation_LUC::Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const\n{\n\treturn Lucas(exponent, m_g, static_cast<const DL_GroupPrecomputation_LUC &>(group).GetModulus());\n}"
  },
  {
    "function_name": "DL_Algorithm_LUC_HMP::Verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "26-34",
    "snippet": "bool DL_Algorithm_LUC_HMP::Verify(const DL_GroupParameters<Integer> &params, const DL_PublicKey<Integer> &publicKey, const Integer &e, const Integer &r, const Integer &s) const\n{\n\tInteger p = params.GetGroupOrder()-1;\n\tconst Integer &q = params.GetSubgroupOrder();\n\n\tInteger Vsg = params.ExponentiateBase(s);\n\tInteger Vry = publicKey.ExponentiatePublicElement((r+e)%q);\n\treturn (Vsg*Vsg + Vry*Vry + r*r) % p == (Vsg * Vry * r + 4) % p;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "publicKey.ExponentiatePublicElement",
          "args": [
            "(r+e)%q"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.ExponentiateBase",
          "args": [
            "s"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetSubgroupOrder",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetGroupOrder",
          "args": [],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "GetGroupOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gfpcrypt.h",
          "lines": "49-49",
          "snippet": "Integer GetGroupOrder() const {return GetFieldType() == 1 ? GetModulus()-Integer::One() : GetModulus()+Integer::One();}",
          "includes": [
            "#include <limits.h>",
            "#include \"hmac.h\"",
            "#include \"smartptr.h\"",
            "#include \"asn.h\"",
            "#include \"algparam.h\"",
            "#include \"sha.h\"",
            "#include \"modexppc.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"hmac.h\"\n#include \"smartptr.h\"\n#include \"asn.h\"\n#include \"algparam.h\"\n#include \"sha.h\"\n#include \"modexppc.h\"\n#include \"pubkey.h\"\n\nInteger GetGroupOrder() const {return GetFieldType() == 1 ? GetModulus()-Integer::One() : GetModulus()+Integer::One();}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nbool DL_Algorithm_LUC_HMP::Verify(const DL_GroupParameters<Integer> &params, const DL_PublicKey<Integer> &publicKey, const Integer &e, const Integer &r, const Integer &s) const\n{\n\tInteger p = params.GetGroupOrder()-1;\n\tconst Integer &q = params.GetSubgroupOrder();\n\n\tInteger Vsg = params.ExponentiateBase(s);\n\tInteger Vry = publicKey.ExponentiatePublicElement((r+e)%q);\n\treturn (Vsg*Vsg + Vry*Vry + r*r) % p == (Vsg * Vry * r + 4) % p;\n}"
  },
  {
    "function_name": "DL_Algorithm_LUC_HMP::Sign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "19-24",
    "snippet": "void DL_Algorithm_LUC_HMP::Sign(const DL_GroupParameters<Integer> &params, const Integer &x, const Integer &k, const Integer &e, Integer &r, Integer &s) const\n{\n\tconst Integer &q = params.GetSubgroupOrder();\n\tr = params.ExponentiateBase(k);\n\ts = (k + x*(r+e)) % q;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "params.ExponentiateBase",
          "args": [
            "k"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetSubgroupOrder",
          "args": [],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid DL_Algorithm_LUC_HMP::Sign(const DL_GroupParameters<Integer> &params, const Integer &x, const Integer &k, const Integer &e, Integer &r, Integer &s) const\n{\n\tconst Integer &q = params.GetSubgroupOrder();\n\tr = params.ExponentiateBase(k);\n\ts = (k + x*(r+e)) % q;\n}"
  },
  {
    "function_name": "LUC_TestInstantiations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "12-17",
    "snippet": "void LUC_TestInstantiations()\n{\n\tLUC_HMP<SHA>::Signer t1;\n\tLUCFunction t2;\n\tInvertibleLUCFunction t3;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid LUC_TestInstantiations()\n{\n\tLUC_HMP<SHA>::Signer t1;\n\tLUCFunction t2;\n\tInvertibleLUCFunction t3;\n}"
  }
]