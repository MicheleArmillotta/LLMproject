[
  {
    "function_name": "AssignFrom",
    "container": "InvertibleLUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "201-208",
    "snippet": "void InvertibleLUCFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper<LUCFunction>(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "MultiplicativeInverseOfPrime2ModPrime1"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Prime2"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Prime1"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper<LUCFunction>",
          "args": [
            "this",
            "source"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  void InvertibleLUCFunction::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper<LUCFunction>(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "GetVoidValue",
    "container": "InvertibleLUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "192-199",
    "snippet": "bool InvertibleLUCFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper<LUCFunction>(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "MultiplicativeInverseOfPrime2ModPrime1"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Prime2"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Prime1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper<LUCFunction>",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper<LUCFunction>",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  bool InvertibleLUCFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n  {\n  \treturn GetValueHelper<LUCFunction>(this, name, valueType, pValue).Assignable()\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime1)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Prime2)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "Validate",
    "container": "InvertibleLUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "172-190",
    "snippet": "bool InvertibleLUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = LUCFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p.IsOdd() && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q.IsOdd() && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && RelativelyPrime(m_e, m_p+1);\n\t\tpass = pass && RelativelyPrime(m_e, m_p-1);\n\t\tpass = pass && RelativelyPrime(m_e, m_q+1);\n\t\tpass = pass && RelativelyPrime(m_e, m_q-1);\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyPrime",
          "args": [
            "rng",
            "m_q",
            "level-2"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "247-253",
          "snippet": "bool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelativelyPrime",
          "args": [
            "m_e",
            "m_q-1"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "RelativelyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "65-66",
          "snippet": "inline bool RelativelyPrime(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b) == Integer::One();}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline bool RelativelyPrime(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b) == Integer::One();}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.IsPositive",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "IsPositive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "205-205",
          "snippet": "bool IsPositive() const {return NotNegative() && NotZero();}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsPositive() const {return NotNegative() && NotZero();}"
        }
      },
      {
        "call_info": {
          "callee": "m_q.IsOdd",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LUCFunction::Validate",
          "args": [
            "rng",
            "level"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "Validate",
          "container": "InvertibleLUCFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
          "lines": "172-190",
          "snippet": "bool InvertibleLUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = LUCFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p.IsOdd() && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q.IsOdd() && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && RelativelyPrime(m_e, m_p+1);\n\t\tpass = pass && RelativelyPrime(m_e, m_p-1);\n\t\tpass = pass && RelativelyPrime(m_e, m_q+1);\n\t\tpass = pass && RelativelyPrime(m_e, m_q-1);\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  bool InvertibleLUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = LUCFunction::Validate(rng, level);\n  \tpass = pass && m_p > Integer::One() && m_p.IsOdd() && m_p < m_n;\n  \tpass = pass && m_q > Integer::One() && m_q.IsOdd() && m_q < m_n;\n  \tpass = pass && m_u.IsPositive() && m_u < m_p;\n  \tif (level >= 1)\n  \t{\n  \t\tpass = pass && m_p * m_q == m_n;\n  \t\tpass = pass && RelativelyPrime(m_e, m_p+1);\n  \t\tpass = pass && RelativelyPrime(m_e, m_p-1);\n  \t\tpass = pass && RelativelyPrime(m_e, m_q+1);\n  \t\tpass = pass && RelativelyPrime(m_e, m_q-1);\n  \t\tpass = pass && m_u * m_q % m_p == 1;\n  \t}\n  \tif (level >= 2)\n  \t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "CalculateInverse",
    "container": "InvertibleLUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "165-170",
    "snippet": "Integer InvertibleLUCFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\t// not clear how to do blinding with LUC\n\tDoQuickSanityCheck();\n\treturn InverseLucas(m_e, x, m_q, m_p, m_u);\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InverseLucas",
          "args": [
            "m_e",
            "x",
            "m_q",
            "m_p",
            "m_u"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "InverseLucas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "998-1017",
          "snippet": "Integer InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q, const Integer &u)\n{\n\tInteger d = (m*m-4);\n\tInteger p2, q2;\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tp2 = p-Jacobi(d,p);\n\t\t\t\tp2 = Lucas(EuclideanMultiplicativeInverse(e,p2), m, p);\n\t\t\t}\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tq2 = q-Jacobi(d,q);\n\t\t\t\tq2 = Lucas(EuclideanMultiplicativeInverse(e,q2), m, q);\n\t\t\t}\n\t\t}\n\treturn CRT(p2, p, q2, q, u);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger InverseLucas(const Integer &e, const Integer &m, const Integer &p, const Integer &q, const Integer &u)\n{\n\tInteger d = (m*m-4);\n\tInteger p2, q2;\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tp2 = p-Jacobi(d,p);\n\t\t\t\tp2 = Lucas(EuclideanMultiplicativeInverse(e,p2), m, p);\n\t\t\t}\n\t\t\t#pragma omp section\n\t\t\t{\n\t\t\t\tq2 = q-Jacobi(d,q);\n\t\t\t\tq2 = Lucas(EuclideanMultiplicativeInverse(e,q2), m, q);\n\t\t\t}\n\t\t}\n\treturn CRT(p2, p, q2, q, u);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoQuickSanityCheck",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  Integer InvertibleLUCFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n  {\n  \t// not clear how to do blinding with LUC\n  \tDoQuickSanityCheck();\n  \treturn InverseLucas(m_e, x, m_q, m_p, m_u);\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "InvertibleLUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "151-163",
    "snippet": "void InvertibleLUCFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\n\tconst byte version[] = {INTEGER, 1, 0};\n\tseq.Put(version, sizeof(version));\n\tm_n.DEREncode(seq);\n\tm_e.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.DEREncode",
          "args": [
            "seq"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "InvertibleLUCFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
          "lines": "151-163",
          "snippet": "void InvertibleLUCFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\n\tconst byte version[] = {INTEGER, 1, 0};\n\tseq.Put(version, sizeof(version));\n\tm_n.DEREncode(seq);\n\tm_e.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "seq.Put",
          "args": [
            "version",
            "sizeof(version)"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  void InvertibleLUCFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \n  \tconst byte version[] = {INTEGER, 1, 0};\n  \tseq.Put(version, sizeof(version));\n  \tm_n.DEREncode(seq);\n  \tm_e.DEREncode(seq);\n  \tm_p.DEREncode(seq);\n  \tm_q.DEREncode(seq);\n  \tm_u.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "BERDecode",
    "container": "InvertibleLUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "135-149",
    "snippet": "void InvertibleLUCFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\n\tInteger version(seq);\n\tif (!!version)  // make sure version is 0\n\t\tBERDecodeError();\n\n\tm_n.BERDecode(seq);\n\tm_e.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_u.BERDecode",
          "args": [
            "seq"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "InvertibleLUCFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
          "lines": "135-149",
          "snippet": "void InvertibleLUCFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\n\tInteger version(seq);\n\tif (!!version)  // make sure version is 0\n\t\tBERDecodeError();\n\n\tm_n.BERDecode(seq);\n\tm_e.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BERDecodeError",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecodeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.h",
          "lines": "49-49",
          "snippet": "inline void BERDecodeError() {throw BERDecodeErr();}",
          "includes": [
            "#include <vector>",
            "#include \"queue.h\"",
            "#include \"filters.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include \"queue.h\"\n#include \"filters.h\"\n\ninline void BERDecodeError() {throw BERDecodeErr();}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  void InvertibleLUCFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \n  \tInteger version(seq);\n  \tif (!!version)  // make sure version is 0\n  \t\tBERDecodeError();\n  \n  \tm_n.BERDecode(seq);\n  \tm_e.BERDecode(seq);\n  \tm_p.BERDecode(seq);\n  \tm_q.BERDecode(seq);\n  \tm_u.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "Initialize",
    "container": "InvertibleLUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "130-133",
    "snippet": "void InvertibleLUCFunction::Initialize(RandomNumberGenerator &rng, unsigned int keybits, const Integer &e)\n{\n\tGenerateRandom(rng, MakeParameters(\"ModulusSize\", (int)keybits)(\"PublicExponent\", e));\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenerateRandom",
          "args": [
            "rng",
            "MakeParameters(\"ModulusSize\", (int)keybits)(\"PublicExponent\", e)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateRandom",
          "container": "InvertibleLUCFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
          "lines": "107-128",
          "snippet": "void InvertibleLUCFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: specified modulus size is too small\");\n\n\tm_e = alg.GetValueWithDefault(\"PublicExponent\", Integer(17));\n\n\tif (m_e < 5 || m_e.IsEven())\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: invalid public exponent\");\n\n\tLUCPrimeSelector selector(m_e);\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"PointerToPrimeSelector\", selector.GetSelectorPointer());\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"sha.h\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"luc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  void InvertibleLUCFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n  {\n  \tint modulusSize = 2048;\n  \talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n  \n  \tif (modulusSize < 16)\n  \t\tthrow InvalidArgument(\"InvertibleLUCFunction: specified modulus size is too small\");\n  \n  \tm_e = alg.GetValueWithDefault(\"PublicExponent\", Integer(17));\n  \n  \tif (m_e < 5 || m_e.IsEven())\n  \t\tthrow InvalidArgument(\"InvertibleLUCFunction: invalid public exponent\");\n  \n  \tLUCPrimeSelector selector(m_e);\n  \tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n  \t\t(\"PointerToPrimeSelector\", selector.GetSelectorPointer());\n  \tm_p.GenerateRandom(rng, primeParam);\n  \tm_q.GenerateRandom(rng, primeParam);\n  \n  \tm_n = m_p * m_q;\n  \tm_u = m_q.InverseMod(m_p);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"PublicExponent\"",
            "e"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  void InvertibleLUCFunction::Initialize(RandomNumberGenerator &rng, unsigned int keybits, const Integer &e)\n  {\n  \tGenerateRandom(rng, MakeParameters(\"ModulusSize\", (int)keybits)(\"PublicExponent\", e));\n  }\n}"
  },
  {
    "function_name": "GenerateRandom",
    "container": "InvertibleLUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "107-128",
    "snippet": "void InvertibleLUCFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: specified modulus size is too small\");\n\n\tm_e = alg.GetValueWithDefault(\"PublicExponent\", Integer(17));\n\n\tif (m_e < 5 || m_e.IsEven())\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: invalid public exponent\");\n\n\tLUCPrimeSelector selector(m_e);\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"PointerToPrimeSelector\", selector.GetSelectorPointer());\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_q.InverseMod",
          "args": [
            "m_p"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "InverseMod",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3983-4006",
          "snippet": "word Integer::InverseMod(word mod) const\n{\n\tword g0 = mod, g1 = *this % mod;\n\tword v0 = 0, v1 = 1;\n\tword y;\n\n\twhile (g1)\n\t{\n\t\tif (g1 == 1)\n\t\t\treturn v1;\n\t\ty = g0 / g1;\n\t\tg0 = g0 % g1;\n\t\tv0 += y * v1;\n\n\t\tif (!g0)\n\t\t\tbreak;\n\t\tif (g0 == 1)\n\t\t\treturn mod-v0;\n\t\ty = g1 / g0;\n\t\tg1 = g1 % g0;\n\t\tv1 += y * v0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  word Integer::InverseMod(word mod) const\n  {\n  \tword g0 = mod, g1 = *this % mod;\n  \tword v0 = 0, v1 = 1;\n  \tword y;\n  \n  \twhile (g1)\n  \t{\n  \t\tif (g1 == 1)\n  \t\t\treturn v1;\n  \t\ty = g0 / g1;\n  \t\tg0 = g0 % g1;\n  \t\tv0 += y * v1;\n  \n  \t\tif (!g0)\n  \t\t\tbreak;\n  \t\tif (g0 == 1)\n  \t\t\treturn mod-v0;\n  \t\ty = g1 / g0;\n  \t\tg1 = g1 % g0;\n  \t\tv1 += y * v0;\n  \t}\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_q.GenerateRandom",
          "args": [
            "rng",
            "primeParam"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateRandom",
          "container": "InvertibleLUCFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
          "lines": "107-128",
          "snippet": "void InvertibleLUCFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n{\n\tint modulusSize = 2048;\n\talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n\n\tif (modulusSize < 16)\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: specified modulus size is too small\");\n\n\tm_e = alg.GetValueWithDefault(\"PublicExponent\", Integer(17));\n\n\tif (m_e < 5 || m_e.IsEven())\n\t\tthrow InvalidArgument(\"InvertibleLUCFunction: invalid public exponent\");\n\n\tLUCPrimeSelector selector(m_e);\n\tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n\t\t(\"PointerToPrimeSelector\", selector.GetSelectorPointer());\n\tm_p.GenerateRandom(rng, primeParam);\n\tm_q.GenerateRandom(rng, primeParam);\n\n\tm_n = m_p * m_q;\n\tm_u = m_q.InverseMod(m_p);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "MakeParametersForTwoPrimesOfEqualSize",
          "args": [
            "\"PointerToPrimeSelector\"",
            "selector.GetSelectorPointer()"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selector.GetSelectorPointer",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeParametersForTwoPrimesOfEqualSize",
          "args": [
            "modulusSize"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParametersForTwoPrimesOfEqualSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "265-284",
          "snippet": "AlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nAlgorithmParameters MakeParametersForTwoPrimesOfEqualSize(unsigned int productBitLength)\n{\n\tif (productBitLength < 16)\n\t\tthrow InvalidArgument(\"invalid bit length\");\n\n\tInteger minP, maxP;\n\n\tif (productBitLength%2==0)\n\t{\n\t\tminP = Integer(182) << (productBitLength/2-8);\n\t\tmaxP = Integer::Power2(productBitLength/2)-1;\n\t}\n\telse\n\t{\n\t\tminP = Integer::Power2((productBitLength-1)/2);\n\t\tmaxP = Integer(181) << ((productBitLength+1)/2-8);\n\t}\n\n\treturn MakeParameters(\"RandomNumberType\", Integer::PRIME)(\"Min\", minP)(\"Max\", maxP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"InvertibleLUCFunction: invalid public exponent\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_e.IsEven",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "IsEven",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "209-209",
          "snippet": "bool IsEven() const {return GetBit(0) == 0;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsEven() const {return GetBit(0) == 0;}"
        }
      },
      {
        "call_info": {
          "callee": "alg.GetValueWithDefault",
          "args": [
            "\"PublicExponent\"",
            "Integer(17)"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"InvertibleLUCFunction: specified modulus size is too small\""
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alg.GetIntValue",
          "args": [
            "\"KeySize\"",
            "modulusSize"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alg.GetIntValue",
          "args": [
            "\"ModulusSize\"",
            "modulusSize"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  void InvertibleLUCFunction::GenerateRandom(RandomNumberGenerator &rng, const NameValuePairs &alg)\n  {\n  \tint modulusSize = 2048;\n  \talg.GetIntValue(\"ModulusSize\", modulusSize) || alg.GetIntValue(\"KeySize\", modulusSize);\n  \n  \tif (modulusSize < 16)\n  \t\tthrow InvalidArgument(\"InvertibleLUCFunction: specified modulus size is too small\");\n  \n  \tm_e = alg.GetValueWithDefault(\"PublicExponent\", Integer(17));\n  \n  \tif (m_e < 5 || m_e.IsEven())\n  \t\tthrow InvalidArgument(\"InvertibleLUCFunction: invalid public exponent\");\n  \n  \tLUCPrimeSelector selector(m_e);\n  \tAlgorithmParameters primeParam = MakeParametersForTwoPrimesOfEqualSize(modulusSize)\n  \t\t(\"PointerToPrimeSelector\", selector.GetSelectorPointer());\n  \tm_p.GenerateRandom(rng, primeParam);\n  \tm_q.GenerateRandom(rng, primeParam);\n  \n  \tm_n = m_p * m_q;\n  \tm_u = m_q.InverseMod(m_p);\n  }\n}"
  },
  {
    "function_name": "IsAcceptable",
    "container": "LUCPrimeSelector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "100-103",
    "snippet": "bool IsAcceptable(const Integer &candidate) const\n\t{\n\t\treturn RelativelyPrime(m_e, candidate+1) && RelativelyPrime(m_e, candidate-1);\n\t}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelativelyPrime",
          "args": [
            "m_e",
            "candidate-1"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "RelativelyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.h",
          "lines": "65-66",
          "snippet": "inline bool RelativelyPrime(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b) == Integer::One();}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"integer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"integer.h\"\n\ninline bool RelativelyPrime(const Integer &a, const Integer &b)\n\t{return Integer::Gcd(a,b) == Integer::One();}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCPrimeSelector {\n  bool IsAcceptable(const Integer &candidate) const\n  \t{\n  \t\treturn RelativelyPrime(m_e, candidate+1) && RelativelyPrime(m_e, candidate-1);\n  \t}\n}"
  },
  {
    "function_name": "LUCPrimeSelector",
    "container": "LUCPrimeSelector",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "99-99",
    "snippet": "LUCPrimeSelector(const Integer &e) : m_e(e) {}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCPrimeSelector {\n  LUCPrimeSelector(const Integer &e) : m_e(e) {}\n}"
  },
  {
    "function_name": "AssignFrom",
    "container": "LUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "85-91",
    "snippet": "void LUCFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(PublicExponent)\n\t\t;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "PublicExponent"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper",
          "args": [
            "this",
            "source"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCFunction {\n  void LUCFunction::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(PublicExponent)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "GetVoidValue",
    "container": "LUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "77-83",
    "snippet": "bool LUCFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(PublicExponent)\n\t\t;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "PublicExponent"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCFunction {\n  bool LUCFunction::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n  {\n  \treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(PublicExponent)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "Validate",
    "container": "LUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "69-75",
    "snippet": "bool LUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = true;\n\tpass = pass && m_n > Integer::One() && m_n.IsOdd();\n\tpass = pass && m_e > Integer::One() && m_e.IsOdd() && m_e < m_n;\n\treturn pass;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_e.IsOdd",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCFunction {\n  bool LUCFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = true;\n  \tpass = pass && m_n > Integer::One() && m_n.IsOdd();\n  \tpass = pass && m_e > Integer::One() && m_e.IsOdd() && m_e < m_n;\n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "ApplyFunction",
    "container": "LUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "63-67",
    "snippet": "Integer LUCFunction::ApplyFunction(const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\treturn Lucas(m_e, x, m_n);\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "m_e",
            "x",
            "m_n"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "Lucas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "812-841",
          "snippet": "Integer Lucas(const Integer &e, const Integer &pIn, const Integer &n)\n{\n\tunsigned i = e.BitCount();\n\tif (i==0)\n\t\treturn Integer::Two();\n\n\tMontgomeryRepresentation m(n);\n\tInteger p=m.ConvertIn(pIn%n), two=m.ConvertIn(Integer::Two());\n\tInteger v=p, v1=m.Subtract(m.Square(p), two);\n\n\ti--;\n\twhile (i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\t// v = (v*v1 - p) % m;\n\t\t\tv = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v1 = (v1*v1 - 2) % m;\n\t\t\tv1 = m.Subtract(m.Square(v1), two);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// v1 = (v*v1 - p) % m;\n\t\t\tv1 = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v = (v*v - 2) % m;\n\t\t\tv = m.Subtract(m.Square(v), two);\n\t\t}\n\t}\n\treturn m.ConvertOut(v);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger Lucas(const Integer &e, const Integer &pIn, const Integer &n)\n{\n\tunsigned i = e.BitCount();\n\tif (i==0)\n\t\treturn Integer::Two();\n\n\tMontgomeryRepresentation m(n);\n\tInteger p=m.ConvertIn(pIn%n), two=m.ConvertIn(Integer::Two());\n\tInteger v=p, v1=m.Subtract(m.Square(p), two);\n\n\ti--;\n\twhile (i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\t// v = (v*v1 - p) % m;\n\t\t\tv = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v1 = (v1*v1 - 2) % m;\n\t\t\tv1 = m.Subtract(m.Square(v1), two);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// v1 = (v*v1 - p) % m;\n\t\t\tv1 = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v = (v*v - 2) % m;\n\t\t\tv = m.Subtract(m.Square(v), two);\n\t\t}\n\t}\n\treturn m.ConvertOut(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoQuickSanityCheck",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCFunction {\n  Integer LUCFunction::ApplyFunction(const Integer &x) const\n  {\n  \tDoQuickSanityCheck();\n  \treturn Lucas(m_e, x, m_n);\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "LUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "55-61",
    "snippet": "void LUCFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_n.DEREncode(seq);\n\tm_e.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_e.DEREncode",
          "args": [
            "seq"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "InvertibleLUCFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
          "lines": "151-163",
          "snippet": "void InvertibleLUCFunction::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\n\tconst byte version[] = {INTEGER, 1, 0};\n\tseq.Put(version, sizeof(version));\n\tm_n.DEREncode(seq);\n\tm_e.DEREncode(seq);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_u.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"sha.h\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"luc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  void InvertibleLUCFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \n  \tconst byte version[] = {INTEGER, 1, 0};\n  \tseq.Put(version, sizeof(version));\n  \tm_n.DEREncode(seq);\n  \tm_e.DEREncode(seq);\n  \tm_p.DEREncode(seq);\n  \tm_q.DEREncode(seq);\n  \tm_u.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCFunction {\n  void LUCFunction::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tm_n.DEREncode(seq);\n  \tm_e.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "BERDecode",
    "container": "LUCFunction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "47-53",
    "snippet": "void LUCFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_n.BERDecode(seq);\n\tm_e.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_e.BERDecode",
          "args": [
            "seq"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "InvertibleLUCFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
          "lines": "135-149",
          "snippet": "void InvertibleLUCFunction::BERDecode(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\n\tInteger version(seq);\n\tif (!!version)  // make sure version is 0\n\t\tBERDecodeError();\n\n\tm_n.BERDecode(seq);\n\tm_e.BERDecode(seq);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_u.BERDecode(seq);\n\tseq.MessageEnd();\n}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"sha.h\"",
            "#include \"nbtheory.h\"",
            "#include \"asn.h\"",
            "#include \"luc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nInvertibleLUCFunction {\n  void InvertibleLUCFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \n  \tInteger version(seq);\n  \tif (!!version)  // make sure version is 0\n  \t\tBERDecodeError();\n  \n  \tm_n.BERDecode(seq);\n  \tm_e.BERDecode(seq);\n  \tm_p.BERDecode(seq);\n  \tm_q.BERDecode(seq);\n  \tm_u.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nLUCFunction {\n  void LUCFunction::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_n.BERDecode(seq);\n  \tm_e.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "SimultaneousExponentiate",
    "container": "DL_GroupParameters_LUC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "41-45",
    "snippet": "void DL_GroupParameters_LUC::SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const\n{\n\tfor (unsigned int i=0; i<exponentsCount; i++)\n\t\tresults[i] = Lucas(exponents[i], base, GetModulus());\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "exponents[i]",
            "base",
            "GetModulus()"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "Lucas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "812-841",
          "snippet": "Integer Lucas(const Integer &e, const Integer &pIn, const Integer &n)\n{\n\tunsigned i = e.BitCount();\n\tif (i==0)\n\t\treturn Integer::Two();\n\n\tMontgomeryRepresentation m(n);\n\tInteger p=m.ConvertIn(pIn%n), two=m.ConvertIn(Integer::Two());\n\tInteger v=p, v1=m.Subtract(m.Square(p), two);\n\n\ti--;\n\twhile (i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\t// v = (v*v1 - p) % m;\n\t\t\tv = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v1 = (v1*v1 - 2) % m;\n\t\t\tv1 = m.Subtract(m.Square(v1), two);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// v1 = (v*v1 - p) % m;\n\t\t\tv1 = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v = (v*v - 2) % m;\n\t\t\tv = m.Subtract(m.Square(v), two);\n\t\t}\n\t}\n\treturn m.ConvertOut(v);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger Lucas(const Integer &e, const Integer &pIn, const Integer &n)\n{\n\tunsigned i = e.BitCount();\n\tif (i==0)\n\t\treturn Integer::Two();\n\n\tMontgomeryRepresentation m(n);\n\tInteger p=m.ConvertIn(pIn%n), two=m.ConvertIn(Integer::Two());\n\tInteger v=p, v1=m.Subtract(m.Square(p), two);\n\n\ti--;\n\twhile (i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\t// v = (v*v1 - p) % m;\n\t\t\tv = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v1 = (v1*v1 - 2) % m;\n\t\t\tv1 = m.Subtract(m.Square(v1), two);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// v1 = (v*v1 - p) % m;\n\t\t\tv1 = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v = (v*v - 2) % m;\n\t\t\tv = m.Subtract(m.Square(v), two);\n\t\t}\n\t}\n\treturn m.ConvertOut(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetModulus",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nDL_GroupParameters_LUC {\n  void DL_GroupParameters_LUC::SimultaneousExponentiate(Element *results, const Element &base, const Integer *exponents, unsigned int exponentsCount) const\n  {\n  \tfor (unsigned int i=0; i<exponentsCount; i++)\n  \t\tresults[i] = Lucas(exponents[i], base, GetModulus());\n  }\n}"
  },
  {
    "function_name": "Exponentiate",
    "container": "DL_BasePrecomputation_LUC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "36-39",
    "snippet": "Integer DL_BasePrecomputation_LUC::Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const\n{\n\treturn Lucas(exponent, m_g, static_cast<const DL_GroupPrecomputation_LUC &>(group).GetModulus());\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lucas",
          "args": [
            "exponent",
            "m_g",
            "static_cast<const DL_GroupPrecomputation_LUC &>(group).GetModulus()"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "Lucas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "812-841",
          "snippet": "Integer Lucas(const Integer &e, const Integer &pIn, const Integer &n)\n{\n\tunsigned i = e.BitCount();\n\tif (i==0)\n\t\treturn Integer::Two();\n\n\tMontgomeryRepresentation m(n);\n\tInteger p=m.ConvertIn(pIn%n), two=m.ConvertIn(Integer::Two());\n\tInteger v=p, v1=m.Subtract(m.Square(p), two);\n\n\ti--;\n\twhile (i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\t// v = (v*v1 - p) % m;\n\t\t\tv = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v1 = (v1*v1 - 2) % m;\n\t\t\tv1 = m.Subtract(m.Square(v1), two);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// v1 = (v*v1 - p) % m;\n\t\t\tv1 = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v = (v*v - 2) % m;\n\t\t\tv = m.Subtract(m.Square(v), two);\n\t\t}\n\t}\n\treturn m.ConvertOut(v);\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nInteger Lucas(const Integer &e, const Integer &pIn, const Integer &n)\n{\n\tunsigned i = e.BitCount();\n\tif (i==0)\n\t\treturn Integer::Two();\n\n\tMontgomeryRepresentation m(n);\n\tInteger p=m.ConvertIn(pIn%n), two=m.ConvertIn(Integer::Two());\n\tInteger v=p, v1=m.Subtract(m.Square(p), two);\n\n\ti--;\n\twhile (i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\t// v = (v*v1 - p) % m;\n\t\t\tv = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v1 = (v1*v1 - 2) % m;\n\t\t\tv1 = m.Subtract(m.Square(v1), two);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// v1 = (v*v1 - p) % m;\n\t\t\tv1 = m.Subtract(m.Multiply(v,v1), p);\n\t\t\t// v = (v*v - 2) % m;\n\t\t\tv = m.Subtract(m.Square(v), two);\n\t\t}\n\t}\n\treturn m.ConvertOut(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<const DL_GroupPrecomputation_LUC &>",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<const DL_GroupPrecomputation_LUC &>",
          "args": [
            "group"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nDL_BasePrecomputation_LUC {\n  Integer DL_BasePrecomputation_LUC::Exponentiate(const DL_GroupPrecomputation<Element> &group, const Integer &exponent) const\n  {\n  \treturn Lucas(exponent, m_g, static_cast<const DL_GroupPrecomputation_LUC &>(group).GetModulus());\n  }\n}"
  },
  {
    "function_name": "Verify",
    "container": "DL_Algorithm_LUC_HMP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "26-34",
    "snippet": "bool DL_Algorithm_LUC_HMP::Verify(const DL_GroupParameters<Integer> &params, const DL_PublicKey<Integer> &publicKey, const Integer &e, const Integer &r, const Integer &s) const\n{\n\tInteger p = params.GetGroupOrder()-1;\n\tconst Integer &q = params.GetSubgroupOrder();\n\n\tInteger Vsg = params.ExponentiateBase(s);\n\tInteger Vry = publicKey.ExponentiatePublicElement((r+e)%q);\n\treturn (Vsg*Vsg + Vry*Vry + r*r) % p == (Vsg * Vry * r + 4) % p;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "publicKey.ExponentiatePublicElement",
          "args": [
            "(r+e)%q"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.ExponentiateBase",
          "args": [
            "s"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetSubgroupOrder",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetGroupOrder",
          "args": [],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "GetGroupOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gfpcrypt.h",
          "lines": "49-49",
          "snippet": "Integer GetGroupOrder() const {return GetFieldType() == 1 ? GetModulus()-Integer::One() : GetModulus()+Integer::One();}",
          "includes": [
            "#include <limits.h>",
            "#include \"hmac.h\"",
            "#include \"smartptr.h\"",
            "#include \"asn.h\"",
            "#include \"algparam.h\"",
            "#include \"sha.h\"",
            "#include \"modexppc.h\"",
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"hmac.h\"\n#include \"smartptr.h\"\n#include \"asn.h\"\n#include \"algparam.h\"\n#include \"sha.h\"\n#include \"modexppc.h\"\n#include \"pubkey.h\"\n\nInteger GetGroupOrder() const {return GetFieldType() == 1 ? GetModulus()-Integer::One() : GetModulus()+Integer::One();}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nDL_Algorithm_LUC_HMP {\n  bool DL_Algorithm_LUC_HMP::Verify(const DL_GroupParameters<Integer> &params, const DL_PublicKey<Integer> &publicKey, const Integer &e, const Integer &r, const Integer &s) const\n  {\n  \tInteger p = params.GetGroupOrder()-1;\n  \tconst Integer &q = params.GetSubgroupOrder();\n  \n  \tInteger Vsg = params.ExponentiateBase(s);\n  \tInteger Vry = publicKey.ExponentiatePublicElement((r+e)%q);\n  \treturn (Vsg*Vsg + Vry*Vry + r*r) % p == (Vsg * Vry * r + 4) % p;\n  }\n}"
  },
  {
    "function_name": "Sign",
    "container": "DL_Algorithm_LUC_HMP",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "19-24",
    "snippet": "void DL_Algorithm_LUC_HMP::Sign(const DL_GroupParameters<Integer> &params, const Integer &x, const Integer &k, const Integer &e, Integer &r, Integer &s) const\n{\n\tconst Integer &q = params.GetSubgroupOrder();\n\tr = params.ExponentiateBase(k);\n\ts = (k + x*(r+e)) % q;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "params.ExponentiateBase",
          "args": [
            "k"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.GetSubgroupOrder",
          "args": [],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nDL_Algorithm_LUC_HMP {\n  void DL_Algorithm_LUC_HMP::Sign(const DL_GroupParameters<Integer> &params, const Integer &x, const Integer &k, const Integer &e, Integer &r, Integer &s) const\n  {\n  \tconst Integer &q = params.GetSubgroupOrder();\n  \tr = params.ExponentiateBase(k);\n  \ts = (k + x*(r+e)) % q;\n  }\n}"
  },
  {
    "function_name": "LUC_TestInstantiations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/luc.cpp",
    "lines": "12-17",
    "snippet": "void LUC_TestInstantiations()\n{\n\tLUC_HMP<SHA>::Signer t1;\n\tLUCFunction t2;\n\tInvertibleLUCFunction t3;\n}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"sha.h\"",
      "#include \"nbtheory.h\"",
      "#include \"asn.h\"",
      "#include \"luc.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"sha.h\"\n#include \"nbtheory.h\"\n#include \"asn.h\"\n#include \"luc.h\"\n#include \"pch.h\"\n\nvoid LUC_TestInstantiations()\n{\n\tLUC_HMP<SHA>::Signer t1;\n\tLUCFunction t2;\n\tInvertibleLUCFunction t3;\n}"
  }
]