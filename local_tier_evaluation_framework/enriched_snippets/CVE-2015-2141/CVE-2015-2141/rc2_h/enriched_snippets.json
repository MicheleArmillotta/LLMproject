[
  {
    "function_name": "Decryption",
    "container": "Decryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.h",
    "lines": "63-64",
    "snippet": "Decryption(const byte *key, size_t keyLen, int effectiveKeyLen)\n\t\t\t{SetKey(key, keyLen, MakeParameters(\"EffectiveKeyLength\", effectiveKeyLen));}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"secblock.h\"",
      "#include \"seckey.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetKey",
          "args": [
            "key",
            "keyLen",
            "MakeParameters(\"EffectiveKeyLength\", effectiveKeyLen)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "RC2::Base::UncheckedSetKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.cpp",
          "lines": "10-52",
          "snippet": "void RC2::Base::UncheckedSetKey(const byte *key, unsigned int keyLen, const NameValuePairs &params)\n{\n\tAssertValidKeyLength(keyLen);\n\n\tint effectiveLen = params.GetIntValueWithDefault(Name::EffectiveKeyLength(), DEFAULT_EFFECTIVE_KEYLENGTH);\n\tif (effectiveLen > MAX_EFFECTIVE_KEYLENGTH)\n\t\tthrow InvalidArgument(\"RC2: effective key length parameter exceeds maximum\");\n\n\tstatic const unsigned char PITABLE[256] = {\n\t\t217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,\n\t\t198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,\n\t\t 23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,\n\t\t189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,\n\t\t 84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,\n\t\t 18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,\n\t\t111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,\n\t\t248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,\n\t\t  8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,\n\t\t150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,\n\t\t194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,\n\t\t153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,\n\t\t 45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,\n\t\t211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,\n\t\t 13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,\n\t\t197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173};\n\n\tSecByteBlock L(128);\n\tmemcpy(L, key, keyLen);\n\n\tint i;\n\tfor (i=keyLen; i<128; i++)\n\t\tL[i] = PITABLE[(L[i-1] + L[i-keyLen]) & 255];\n\n\tunsigned int T8 = (effectiveLen+7) / 8;\n\tbyte TM = 255 >> ((8-(effectiveLen%8))%8);\n\tL[128-T8] = PITABLE[L[128-T8] & TM];\n\n\tfor (i=127-T8; i>=0; i--)\n\t\tL[i] = PITABLE[L[i+1] ^ L[i+T8]];\n\n\tfor (i=0; i<64; i++)\n\t\tK[i] = L[2*i] + (L[2*i+1] << 8);\n}",
          "includes": [
            "#include \"argnames.h\"",
            "#include \"misc.h\"",
            "#include \"rc2.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argnames.h\"\n#include \"misc.h\"\n#include \"rc2.h\"\n#include \"pch.h\"\n\nvoid RC2::Base::UncheckedSetKey(const byte *key, unsigned int keyLen, const NameValuePairs &params)\n{\n\tAssertValidKeyLength(keyLen);\n\n\tint effectiveLen = params.GetIntValueWithDefault(Name::EffectiveKeyLength(), DEFAULT_EFFECTIVE_KEYLENGTH);\n\tif (effectiveLen > MAX_EFFECTIVE_KEYLENGTH)\n\t\tthrow InvalidArgument(\"RC2: effective key length parameter exceeds maximum\");\n\n\tstatic const unsigned char PITABLE[256] = {\n\t\t217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,\n\t\t198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,\n\t\t 23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,\n\t\t189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,\n\t\t 84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,\n\t\t 18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,\n\t\t111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,\n\t\t248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,\n\t\t  8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,\n\t\t150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,\n\t\t194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,\n\t\t153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,\n\t\t 45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,\n\t\t211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,\n\t\t 13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,\n\t\t197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173};\n\n\tSecByteBlock L(128);\n\tmemcpy(L, key, keyLen);\n\n\tint i;\n\tfor (i=keyLen; i<128; i++)\n\t\tL[i] = PITABLE[(L[i-1] + L[i-keyLen]) & 255];\n\n\tunsigned int T8 = (effectiveLen+7) / 8;\n\tbyte TM = 255 >> ((8-(effectiveLen%8))%8);\n\tL[128-T8] = PITABLE[L[128-T8] & TM];\n\n\tfor (i=127-T8; i>=0; i--)\n\t\tL[i] = PITABLE[L[i+1] ^ L[i+T8]];\n\n\tfor (i=0; i<64; i++)\n\t\tK[i] = L[2*i] + (L[2*i+1] << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"EffectiveKeyLength\"",
            "effectiveKeyLen"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nDecryption {\n  Decryption(const byte *key, size_t keyLen, int effectiveKeyLen)\n  \t\t\t{SetKey(key, keyLen, MakeParameters(\"EffectiveKeyLength\", effectiveKeyLen));}\n}"
  },
  {
    "function_name": "Decryption",
    "container": "Decryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.h",
    "lines": "61-62",
    "snippet": "Decryption(const byte *key, size_t keyLen=DEFAULT_KEYLENGTH)\n\t\t\t{SetKey(key, keyLen);}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"secblock.h\"",
      "#include \"seckey.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetKey",
          "args": [
            "key",
            "keyLen"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "RawDES::RawSetKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/des.cpp",
          "lines": "274-320",
          "snippet": "void RawDES::RawSetKey(CipherDir dir, const byte *key)\n{\n\tSecByteBlock buffer(56+56+8);\n\tbyte *const pc1m=buffer;                 /* place to modify pc1 into */\n\tbyte *const pcr=pc1m+56;                 /* place to rotate pc1 into */\n\tbyte *const ks=pcr+56;\n\tregister int i,j,l;\n\tint m;\n\t\n\tfor (j=0; j<56; j++) {          /* convert pc1 to bits of key */\n\t\tl=pc1[j]-1;             /* integer bit location  */\n\t\tm = l & 07;             /* find bit              */\n\t\tpc1m[j]=(key[l>>3] &    /* find which key byte l is in */\n\t\t\tbytebit[m])     /* and which bit of that byte */\n\t\t\t? 1 : 0;        /* and store 1-bit result */\n\t}\n\tfor (i=0; i<16; i++) {          /* key chunk for each iteration */\n\t\tmemset(ks,0,8);         /* Clear key schedule */\n\t\tfor (j=0; j<56; j++)    /* rotate pc1 the right amount */\n\t\t\tpcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];\n\t\t/* rotate left and right halves independently */\n\t\tfor (j=0; j<48; j++){   /* select bits individually */\n\t\t\t/* check bit that goes to ks[j] */\n\t\t\tif (pcr[pc2[j]-1]){\n\t\t\t\t/* mask it in if it's there */\n\t\t\t\tl= j % 6;\n\t\t\t\tks[j/6] |= bytebit[l] >> 2;\n\t\t\t}\n\t\t}\n\t\t/* Now convert to odd/even interleaved form for use in F */\n\t\tk[2*i] = ((word32)ks[0] << 24)\n\t\t\t| ((word32)ks[2] << 16)\n\t\t\t| ((word32)ks[4] << 8)\n\t\t\t| ((word32)ks[6]);\n\t\tk[2*i+1] = ((word32)ks[1] << 24)\n\t\t\t| ((word32)ks[3] << 16)\n\t\t\t| ((word32)ks[5] << 8)\n\t\t\t| ((word32)ks[7]);\n\t}\n\t\n\tif (dir==DECRYPTION)     // reverse key schedule order\n\t\tfor (i=0; i<16; i+=2)\n\t\t{\n\t\t\tstd::swap(k[i], k[32-2-i]);\n\t\t\tstd::swap(k[i+1], k[32-1-i]);\n\t\t}\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid RawDES::RawSetKey(CipherDir dir, const byte *key)\n{\n\tSecByteBlock buffer(56+56+8);\n\tbyte *const pc1m=buffer;                 /* place to modify pc1 into */\n\tbyte *const pcr=pc1m+56;                 /* place to rotate pc1 into */\n\tbyte *const ks=pcr+56;\n\tregister int i,j,l;\n\tint m;\n\t\n\tfor (j=0; j<56; j++) {          /* convert pc1 to bits of key */\n\t\tl=pc1[j]-1;             /* integer bit location  */\n\t\tm = l & 07;             /* find bit              */\n\t\tpc1m[j]=(key[l>>3] &    /* find which key byte l is in */\n\t\t\tbytebit[m])     /* and which bit of that byte */\n\t\t\t? 1 : 0;        /* and store 1-bit result */\n\t}\n\tfor (i=0; i<16; i++) {          /* key chunk for each iteration */\n\t\tmemset(ks,0,8);         /* Clear key schedule */\n\t\tfor (j=0; j<56; j++)    /* rotate pc1 the right amount */\n\t\t\tpcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];\n\t\t/* rotate left and right halves independently */\n\t\tfor (j=0; j<48; j++){   /* select bits individually */\n\t\t\t/* check bit that goes to ks[j] */\n\t\t\tif (pcr[pc2[j]-1]){\n\t\t\t\t/* mask it in if it's there */\n\t\t\t\tl= j % 6;\n\t\t\t\tks[j/6] |= bytebit[l] >> 2;\n\t\t\t}\n\t\t}\n\t\t/* Now convert to odd/even interleaved form for use in F */\n\t\tk[2*i] = ((word32)ks[0] << 24)\n\t\t\t| ((word32)ks[2] << 16)\n\t\t\t| ((word32)ks[4] << 8)\n\t\t\t| ((word32)ks[6]);\n\t\tk[2*i+1] = ((word32)ks[1] << 24)\n\t\t\t| ((word32)ks[3] << 16)\n\t\t\t| ((word32)ks[5] << 8)\n\t\t\t| ((word32)ks[7]);\n\t}\n\t\n\tif (dir==DECRYPTION)     // reverse key schedule order\n\t\tfor (i=0; i<16; i+=2)\n\t\t{\n\t\t\tstd::swap(k[i], k[32-2-i]);\n\t\t\tstd::swap(k[i+1], k[32-1-i]);\n\t\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nDecryption {\n  Decryption(const byte *key, size_t keyLen=DEFAULT_KEYLENGTH)\n  \t\t\t{SetKey(key, keyLen);}\n}"
  },
  {
    "function_name": "Decryption",
    "container": "Decryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.h",
    "lines": "60-60",
    "snippet": "Decryption() {}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"secblock.h\"",
      "#include \"seckey.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nDecryption {\n  Decryption() {}\n}"
  },
  {
    "function_name": "Encryption",
    "container": "Encryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.h",
    "lines": "53-54",
    "snippet": "Encryption(const byte *key, size_t keyLen, int effectiveKeyLen)\n\t\t\t{SetKey(key, keyLen, MakeParameters(\"EffectiveKeyLength\", effectiveKeyLen));}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"secblock.h\"",
      "#include \"seckey.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetKey",
          "args": [
            "key",
            "keyLen",
            "MakeParameters(\"EffectiveKeyLength\", effectiveKeyLen)"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "RC2::Base::UncheckedSetKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.cpp",
          "lines": "10-52",
          "snippet": "void RC2::Base::UncheckedSetKey(const byte *key, unsigned int keyLen, const NameValuePairs &params)\n{\n\tAssertValidKeyLength(keyLen);\n\n\tint effectiveLen = params.GetIntValueWithDefault(Name::EffectiveKeyLength(), DEFAULT_EFFECTIVE_KEYLENGTH);\n\tif (effectiveLen > MAX_EFFECTIVE_KEYLENGTH)\n\t\tthrow InvalidArgument(\"RC2: effective key length parameter exceeds maximum\");\n\n\tstatic const unsigned char PITABLE[256] = {\n\t\t217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,\n\t\t198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,\n\t\t 23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,\n\t\t189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,\n\t\t 84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,\n\t\t 18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,\n\t\t111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,\n\t\t248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,\n\t\t  8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,\n\t\t150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,\n\t\t194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,\n\t\t153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,\n\t\t 45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,\n\t\t211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,\n\t\t 13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,\n\t\t197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173};\n\n\tSecByteBlock L(128);\n\tmemcpy(L, key, keyLen);\n\n\tint i;\n\tfor (i=keyLen; i<128; i++)\n\t\tL[i] = PITABLE[(L[i-1] + L[i-keyLen]) & 255];\n\n\tunsigned int T8 = (effectiveLen+7) / 8;\n\tbyte TM = 255 >> ((8-(effectiveLen%8))%8);\n\tL[128-T8] = PITABLE[L[128-T8] & TM];\n\n\tfor (i=127-T8; i>=0; i--)\n\t\tL[i] = PITABLE[L[i+1] ^ L[i+T8]];\n\n\tfor (i=0; i<64; i++)\n\t\tK[i] = L[2*i] + (L[2*i+1] << 8);\n}",
          "includes": [
            "#include \"argnames.h\"",
            "#include \"misc.h\"",
            "#include \"rc2.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"argnames.h\"\n#include \"misc.h\"\n#include \"rc2.h\"\n#include \"pch.h\"\n\nvoid RC2::Base::UncheckedSetKey(const byte *key, unsigned int keyLen, const NameValuePairs &params)\n{\n\tAssertValidKeyLength(keyLen);\n\n\tint effectiveLen = params.GetIntValueWithDefault(Name::EffectiveKeyLength(), DEFAULT_EFFECTIVE_KEYLENGTH);\n\tif (effectiveLen > MAX_EFFECTIVE_KEYLENGTH)\n\t\tthrow InvalidArgument(\"RC2: effective key length parameter exceeds maximum\");\n\n\tstatic const unsigned char PITABLE[256] = {\n\t\t217,120,249,196, 25,221,181,237, 40,233,253,121, 74,160,216,157,\n\t\t198,126, 55,131, 43,118, 83,142, 98, 76,100,136, 68,139,251,162,\n\t\t 23,154, 89,245,135,179, 79, 19, 97, 69,109,141,  9,129,125, 50,\n\t\t189,143, 64,235,134,183,123, 11,240,149, 33, 34, 92,107, 78,130,\n\t\t 84,214,101,147,206, 96,178, 28,115, 86,192, 20,167,140,241,220,\n\t\t 18,117,202, 31, 59,190,228,209, 66, 61,212, 48,163, 60,182, 38,\n\t\t111,191, 14,218, 70,105,  7, 87, 39,242, 29,155,188,148, 67,  3,\n\t\t248, 17,199,246,144,239, 62,231,  6,195,213, 47,200,102, 30,215,\n\t\t  8,232,234,222,128, 82,238,247,132,170,114,172, 53, 77,106, 42,\n\t\t150, 26,210,113, 90, 21, 73,116, 75,159,208, 94,  4, 24,164,236,\n\t\t194,224, 65,110, 15, 81,203,204, 36,145,175, 80,161,244,112, 57,\n\t\t153,124, 58,133, 35,184,180,122,252,  2, 54, 91, 37, 85,151, 49,\n\t\t 45, 93,250,152,227,138,146,174,  5,223, 41, 16,103,108,186,201,\n\t\t211,  0,230,207,225,158,168, 44, 99, 22,  1, 63, 88,226,137,169,\n\t\t 13, 56, 52, 27,171, 51,255,176,187, 72, 12, 95,185,177,205, 46,\n\t\t197,243,219, 71,229,165,156,119, 10,166, 32,104,254,127,193,173};\n\n\tSecByteBlock L(128);\n\tmemcpy(L, key, keyLen);\n\n\tint i;\n\tfor (i=keyLen; i<128; i++)\n\t\tL[i] = PITABLE[(L[i-1] + L[i-keyLen]) & 255];\n\n\tunsigned int T8 = (effectiveLen+7) / 8;\n\tbyte TM = 255 >> ((8-(effectiveLen%8))%8);\n\tL[128-T8] = PITABLE[L[128-T8] & TM];\n\n\tfor (i=127-T8; i>=0; i--)\n\t\tL[i] = PITABLE[L[i+1] ^ L[i+T8]];\n\n\tfor (i=0; i<64; i++)\n\t\tK[i] = L[2*i] + (L[2*i+1] << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MakeParameters",
          "args": [
            "\"EffectiveKeyLength\"",
            "effectiveKeyLen"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "MakeParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "387-390",
          "snippet": "AlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAlgorithmParameters MakeParameters(const char *name, const T &value, bool throwIfNotUsed = true)\n{\n\treturn AlgorithmParameters()(name, value, throwIfNotUsed);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nEncryption {\n  Encryption(const byte *key, size_t keyLen, int effectiveKeyLen)\n  \t\t\t{SetKey(key, keyLen, MakeParameters(\"EffectiveKeyLength\", effectiveKeyLen));}\n}"
  },
  {
    "function_name": "Encryption",
    "container": "Encryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.h",
    "lines": "51-52",
    "snippet": "Encryption(const byte *key, size_t keyLen=DEFAULT_KEYLENGTH)\n\t\t\t{SetKey(key, keyLen);}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"secblock.h\"",
      "#include \"seckey.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetKey",
          "args": [
            "key",
            "keyLen"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "RawDES::RawSetKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/des.cpp",
          "lines": "274-320",
          "snippet": "void RawDES::RawSetKey(CipherDir dir, const byte *key)\n{\n\tSecByteBlock buffer(56+56+8);\n\tbyte *const pc1m=buffer;                 /* place to modify pc1 into */\n\tbyte *const pcr=pc1m+56;                 /* place to rotate pc1 into */\n\tbyte *const ks=pcr+56;\n\tregister int i,j,l;\n\tint m;\n\t\n\tfor (j=0; j<56; j++) {          /* convert pc1 to bits of key */\n\t\tl=pc1[j]-1;             /* integer bit location  */\n\t\tm = l & 07;             /* find bit              */\n\t\tpc1m[j]=(key[l>>3] &    /* find which key byte l is in */\n\t\t\tbytebit[m])     /* and which bit of that byte */\n\t\t\t? 1 : 0;        /* and store 1-bit result */\n\t}\n\tfor (i=0; i<16; i++) {          /* key chunk for each iteration */\n\t\tmemset(ks,0,8);         /* Clear key schedule */\n\t\tfor (j=0; j<56; j++)    /* rotate pc1 the right amount */\n\t\t\tpcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];\n\t\t/* rotate left and right halves independently */\n\t\tfor (j=0; j<48; j++){   /* select bits individually */\n\t\t\t/* check bit that goes to ks[j] */\n\t\t\tif (pcr[pc2[j]-1]){\n\t\t\t\t/* mask it in if it's there */\n\t\t\t\tl= j % 6;\n\t\t\t\tks[j/6] |= bytebit[l] >> 2;\n\t\t\t}\n\t\t}\n\t\t/* Now convert to odd/even interleaved form for use in F */\n\t\tk[2*i] = ((word32)ks[0] << 24)\n\t\t\t| ((word32)ks[2] << 16)\n\t\t\t| ((word32)ks[4] << 8)\n\t\t\t| ((word32)ks[6]);\n\t\tk[2*i+1] = ((word32)ks[1] << 24)\n\t\t\t| ((word32)ks[3] << 16)\n\t\t\t| ((word32)ks[5] << 8)\n\t\t\t| ((word32)ks[7]);\n\t}\n\t\n\tif (dir==DECRYPTION)     // reverse key schedule order\n\t\tfor (i=0; i<16; i+=2)\n\t\t{\n\t\t\tstd::swap(k[i], k[32-2-i]);\n\t\t\tstd::swap(k[i+1], k[32-1-i]);\n\t\t}\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid RawDES::RawSetKey(CipherDir dir, const byte *key)\n{\n\tSecByteBlock buffer(56+56+8);\n\tbyte *const pc1m=buffer;                 /* place to modify pc1 into */\n\tbyte *const pcr=pc1m+56;                 /* place to rotate pc1 into */\n\tbyte *const ks=pcr+56;\n\tregister int i,j,l;\n\tint m;\n\t\n\tfor (j=0; j<56; j++) {          /* convert pc1 to bits of key */\n\t\tl=pc1[j]-1;             /* integer bit location  */\n\t\tm = l & 07;             /* find bit              */\n\t\tpc1m[j]=(key[l>>3] &    /* find which key byte l is in */\n\t\t\tbytebit[m])     /* and which bit of that byte */\n\t\t\t? 1 : 0;        /* and store 1-bit result */\n\t}\n\tfor (i=0; i<16; i++) {          /* key chunk for each iteration */\n\t\tmemset(ks,0,8);         /* Clear key schedule */\n\t\tfor (j=0; j<56; j++)    /* rotate pc1 the right amount */\n\t\t\tpcr[j] = pc1m[(l=j+totrot[i])<(j<28? 28 : 56) ? l: l-28];\n\t\t/* rotate left and right halves independently */\n\t\tfor (j=0; j<48; j++){   /* select bits individually */\n\t\t\t/* check bit that goes to ks[j] */\n\t\t\tif (pcr[pc2[j]-1]){\n\t\t\t\t/* mask it in if it's there */\n\t\t\t\tl= j % 6;\n\t\t\t\tks[j/6] |= bytebit[l] >> 2;\n\t\t\t}\n\t\t}\n\t\t/* Now convert to odd/even interleaved form for use in F */\n\t\tk[2*i] = ((word32)ks[0] << 24)\n\t\t\t| ((word32)ks[2] << 16)\n\t\t\t| ((word32)ks[4] << 8)\n\t\t\t| ((word32)ks[6]);\n\t\tk[2*i+1] = ((word32)ks[1] << 24)\n\t\t\t| ((word32)ks[3] << 16)\n\t\t\t| ((word32)ks[5] << 8)\n\t\t\t| ((word32)ks[7]);\n\t}\n\t\n\tif (dir==DECRYPTION)     // reverse key schedule order\n\t\tfor (i=0; i<16; i+=2)\n\t\t{\n\t\t\tstd::swap(k[i], k[32-2-i]);\n\t\t\tstd::swap(k[i+1], k[32-1-i]);\n\t\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nEncryption {\n  Encryption(const byte *key, size_t keyLen=DEFAULT_KEYLENGTH)\n  \t\t\t{SetKey(key, keyLen);}\n}"
  },
  {
    "function_name": "Encryption",
    "container": "Encryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.h",
    "lines": "50-50",
    "snippet": "Encryption() {}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"secblock.h\"",
      "#include \"seckey.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nEncryption {\n  Encryption() {}\n}"
  },
  {
    "function_name": "OptimalDataAlignment",
    "container": "RC2",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rc2.h",
    "lines": "28-28",
    "snippet": "unsigned int OptimalDataAlignment() const {return GetAlignmentOf<word16>();}",
    "includes": [
      "#include \"algparam.h\"",
      "#include \"secblock.h\"",
      "#include \"seckey.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetAlignmentOf<word16>",
          "args": [],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "GetAlignmentOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "363-379",
          "snippet": "inline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n{\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (sizeof(T) < 16)\n\t\treturn 1;\n#endif\n\n#if (_MSC_VER >= 1300)\n\treturn __alignof(T);\n#elif defined(__GNUC__)\n\treturn __alignof__(T);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn UnsignedMin(4U, sizeof(T));\n#else\n\treturn sizeof(T);\n#endif\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline unsigned int GetAlignmentOf(T *dummy=NULL)\t// VC60 workaround\n{\n#ifdef CRYPTOPP_ALLOW_UNALIGNED_DATA_ACCESS\n\tif (sizeof(T) < 16)\n\t\treturn 1;\n#endif\n\n#if (_MSC_VER >= 1300)\n\treturn __alignof(T);\n#elif defined(__GNUC__)\n\treturn __alignof__(T);\n#elif CRYPTOPP_BOOL_SLOW_WORD64\n\treturn UnsignedMin(4U, sizeof(T));\n#else\n\treturn sizeof(T);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"algparam.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nRC2 {\n  unsigned int OptimalDataAlignment() const {return GetAlignmentOf<word16>();}\n}"
  }
]