[
  {
    "function_name": "WAKE_Policy<B>::OperateKeystream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wake.cpp",
    "lines": "70-87",
    "snippet": "void WAKE_Policy<B>::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)\n{\n#define WAKE_OUTPUT(x)\\\n\twhile (iterationCount--)\\\n\t{\\\n\t\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 0, r6);\\\n\t\tr3 = M(r3, r6);\\\n\t\tr4 = M(r4, r3);\\\n\t\tr5 = M(r5, r4);\\\n\t\tr6 = M(r6, r5);\\\n\t\toutput += 4;\\\n\t\tif (!(x & INPUT_NULL))\\\n\t\t\tinput += 4;\\\n\t}\n\n\ttypedef word32 WordType;\n\tCRYPTOPP_KEYSTREAM_OUTPUT_SWITCH(WAKE_OUTPUT, 0);\n}",
    "includes": [
      "#include \"wake.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_KEYSTREAM_OUTPUT_SWITCH",
          "args": [
            "WAKE_OUTPUT",
            "0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wake.h\"\n#include \"pch.h\"\n\nvoid WAKE_Policy<B>::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)\n{\n#define WAKE_OUTPUT(x)\\\n\twhile (iterationCount--)\\\n\t{\\\n\t\tCRYPTOPP_KEYSTREAM_OUTPUT_WORD(x, B::ToEnum(), 0, r6);\\\n\t\tr3 = M(r3, r6);\\\n\t\tr4 = M(r4, r3);\\\n\t\tr5 = M(r5, r4);\\\n\t\tr6 = M(r6, r5);\\\n\t\toutput += 4;\\\n\t\tif (!(x & INPUT_NULL))\\\n\t\t\tinput += 4;\\\n\t}\n\n\ttypedef word32 WordType;\n\tCRYPTOPP_KEYSTREAM_OUTPUT_SWITCH(WAKE_OUTPUT, 0);\n}"
  },
  {
    "function_name": "WAKE_Policy<B>::CipherSetKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wake.cpp",
    "lines": "61-66",
    "snippet": "void WAKE_Policy<B>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)\n{\n\tword32 k0, k1, k2, k3;\n\tBlockGetAndPut<word32, BigEndian>::Get(key)(r3)(r4)(r5)(r6)(k0)(k1)(k2)(k3);\n\tGenKey(k0, k1, k2, k3);\n}",
    "includes": [
      "#include \"wake.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenKey",
          "args": [
            "k0",
            "k1",
            "k2",
            "k3"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "WAKE_Base::GenKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wake.cpp",
          "lines": "20-58",
          "snippet": "void WAKE_Base::GenKey(word32 k0, word32 k1, word32 k2, word32 k3)\n{\n\t// this code is mostly copied from David Wheeler's paper \"A Bulk Data Encryption Algorithm\"\n\tsigned int x, z, p;\t\n\t// x and z were declared as \"long\" in Wheeler's paper, which is a signed type. I don't know if that was intentional, but it's too late to change it now. -- Wei 7/4/2010\n\tCRYPTOPP_COMPILE_ASSERT(sizeof(x) == 4);\n\tstatic unsigned int tt[10]= {\n\t\t0x726a8f3b,\t\t\t\t\t\t\t\t // table\n\t\t0xe69a3b5c,\n\t\t0xd3c71fe5,\n\t\t0xab3c73d2,\n\t\t0x4d3a8eb3,\n\t\t0x0396d6e8,\n\t\t0x3d4c2f7a,\n\t\t0x9ee27cf3, } ;\n\tt[0] = k0;\n\tt[1] = k1;\n\tt[2] = k2;\n\tt[3] = k3;\n\tfor (p=4 ; p<256 ; p++)\n\t{\n\t  x=t[p-4]+t[p-1] ; \t\t\t\t\t   // fill t\n\t  t[p]= (x>>3) ^ tt[x&7] ;\n\t}\n\n\tfor (p=0 ; p<23 ; p++)\n\t\tt[p]+=t[p+89] ; \t\t  // mix first entries\n\tx=t[33] ; z=t[59] | 0x01000001 ;\n\tz=z&0xff7fffff ;\n\tfor (p=0 ; p<256 ; p++) {\t\t//change top byte to\n\t  x=(x&0xff7fffff)+z ; \t\t // a permutation etc\n\t  t[p]=(t[p] & 0x00ffffff) ^ x ; }\n\n\tt[256]=t[0] ;\n\tbyte y=byte(x);\n\tfor (p=0 ; p<256 ; p++) {\t  // further change perm.\n\t  t[p]=t[y=byte(t[p^y]^y)] ;  // and other digits\n\t  t[y]=t[p+1] ;  }\n}",
          "includes": [
            "#include \"wake.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"wake.h\"\n#include \"pch.h\"\n\nvoid WAKE_Base::GenKey(word32 k0, word32 k1, word32 k2, word32 k3)\n{\n\t// this code is mostly copied from David Wheeler's paper \"A Bulk Data Encryption Algorithm\"\n\tsigned int x, z, p;\t\n\t// x and z were declared as \"long\" in Wheeler's paper, which is a signed type. I don't know if that was intentional, but it's too late to change it now. -- Wei 7/4/2010\n\tCRYPTOPP_COMPILE_ASSERT(sizeof(x) == 4);\n\tstatic unsigned int tt[10]= {\n\t\t0x726a8f3b,\t\t\t\t\t\t\t\t // table\n\t\t0xe69a3b5c,\n\t\t0xd3c71fe5,\n\t\t0xab3c73d2,\n\t\t0x4d3a8eb3,\n\t\t0x0396d6e8,\n\t\t0x3d4c2f7a,\n\t\t0x9ee27cf3, } ;\n\tt[0] = k0;\n\tt[1] = k1;\n\tt[2] = k2;\n\tt[3] = k3;\n\tfor (p=4 ; p<256 ; p++)\n\t{\n\t  x=t[p-4]+t[p-1] ; \t\t\t\t\t   // fill t\n\t  t[p]= (x>>3) ^ tt[x&7] ;\n\t}\n\n\tfor (p=0 ; p<23 ; p++)\n\t\tt[p]+=t[p+89] ; \t\t  // mix first entries\n\tx=t[33] ; z=t[59] | 0x01000001 ;\n\tz=z&0xff7fffff ;\n\tfor (p=0 ; p<256 ; p++) {\t\t//change top byte to\n\t  x=(x&0xff7fffff)+z ; \t\t // a permutation etc\n\t  t[p]=(t[p] & 0x00ffffff) ^ x ; }\n\n\tt[256]=t[0] ;\n\tbyte y=byte(x);\n\tfor (p=0 ; p<256 ; p++) {\t  // further change perm.\n\t  t[p]=t[y=byte(t[p^y]^y)] ;  // and other digits\n\t  t[y]=t[p+1] ;  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockGetAndPut<word32, BigEndian>::Get",
          "args": [
            "k3"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "BlockGetAndPut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "1201-1201",
          "snippet": "static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nBlockGetAndPut {\n  static inline GetBlock<T, B, GA> Get(const void *block) {return GetBlock<T, B, GA>(block);}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"wake.h\"\n#include \"pch.h\"\n\nvoid WAKE_Policy<B>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)\n{\n\tword32 k0, k1, k2, k3;\n\tBlockGetAndPut<word32, BigEndian>::Get(key)(r3)(r4)(r5)(r6)(k0)(k1)(k2)(k3);\n\tGenKey(k0, k1, k2, k3);\n}"
  },
  {
    "function_name": "WAKE_Base::GenKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wake.cpp",
    "lines": "20-58",
    "snippet": "void WAKE_Base::GenKey(word32 k0, word32 k1, word32 k2, word32 k3)\n{\n\t// this code is mostly copied from David Wheeler's paper \"A Bulk Data Encryption Algorithm\"\n\tsigned int x, z, p;\t\n\t// x and z were declared as \"long\" in Wheeler's paper, which is a signed type. I don't know if that was intentional, but it's too late to change it now. -- Wei 7/4/2010\n\tCRYPTOPP_COMPILE_ASSERT(sizeof(x) == 4);\n\tstatic unsigned int tt[10]= {\n\t\t0x726a8f3b,\t\t\t\t\t\t\t\t // table\n\t\t0xe69a3b5c,\n\t\t0xd3c71fe5,\n\t\t0xab3c73d2,\n\t\t0x4d3a8eb3,\n\t\t0x0396d6e8,\n\t\t0x3d4c2f7a,\n\t\t0x9ee27cf3, } ;\n\tt[0] = k0;\n\tt[1] = k1;\n\tt[2] = k2;\n\tt[3] = k3;\n\tfor (p=4 ; p<256 ; p++)\n\t{\n\t  x=t[p-4]+t[p-1] ; \t\t\t\t\t   // fill t\n\t  t[p]= (x>>3) ^ tt[x&7] ;\n\t}\n\n\tfor (p=0 ; p<23 ; p++)\n\t\tt[p]+=t[p+89] ; \t\t  // mix first entries\n\tx=t[33] ; z=t[59] | 0x01000001 ;\n\tz=z&0xff7fffff ;\n\tfor (p=0 ; p<256 ; p++) {\t\t//change top byte to\n\t  x=(x&0xff7fffff)+z ; \t\t // a permutation etc\n\t  t[p]=(t[p] & 0x00ffffff) ^ x ; }\n\n\tt[256]=t[0] ;\n\tbyte y=byte(x);\n\tfor (p=0 ; p<256 ; p++) {\t  // further change perm.\n\t  t[p]=t[y=byte(t[p^y]^y)] ;  // and other digits\n\t  t[y]=t[p+1] ;  }\n}",
    "includes": [
      "#include \"wake.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "t[p^y]^y"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "x"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_COMPILE_ASSERT",
          "args": [
            "sizeof(x) == 4"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"wake.h\"\n#include \"pch.h\"\n\nvoid WAKE_Base::GenKey(word32 k0, word32 k1, word32 k2, word32 k3)\n{\n\t// this code is mostly copied from David Wheeler's paper \"A Bulk Data Encryption Algorithm\"\n\tsigned int x, z, p;\t\n\t// x and z were declared as \"long\" in Wheeler's paper, which is a signed type. I don't know if that was intentional, but it's too late to change it now. -- Wei 7/4/2010\n\tCRYPTOPP_COMPILE_ASSERT(sizeof(x) == 4);\n\tstatic unsigned int tt[10]= {\n\t\t0x726a8f3b,\t\t\t\t\t\t\t\t // table\n\t\t0xe69a3b5c,\n\t\t0xd3c71fe5,\n\t\t0xab3c73d2,\n\t\t0x4d3a8eb3,\n\t\t0x0396d6e8,\n\t\t0x3d4c2f7a,\n\t\t0x9ee27cf3, } ;\n\tt[0] = k0;\n\tt[1] = k1;\n\tt[2] = k2;\n\tt[3] = k3;\n\tfor (p=4 ; p<256 ; p++)\n\t{\n\t  x=t[p-4]+t[p-1] ; \t\t\t\t\t   // fill t\n\t  t[p]= (x>>3) ^ tt[x&7] ;\n\t}\n\n\tfor (p=0 ; p<23 ; p++)\n\t\tt[p]+=t[p+89] ; \t\t  // mix first entries\n\tx=t[33] ; z=t[59] | 0x01000001 ;\n\tz=z&0xff7fffff ;\n\tfor (p=0 ; p<256 ; p++) {\t\t//change top byte to\n\t  x=(x&0xff7fffff)+z ; \t\t // a permutation etc\n\t  t[p]=(t[p] & 0x00ffffff) ^ x ; }\n\n\tt[256]=t[0] ;\n\tbyte y=byte(x);\n\tfor (p=0 ; p<256 ; p++) {\t  // further change perm.\n\t  t[p]=t[y=byte(t[p^y]^y)] ;  // and other digits\n\t  t[y]=t[p+1] ;  }\n}"
  },
  {
    "function_name": "WAKE_Base::M",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wake.cpp",
    "lines": "14-18",
    "snippet": "inline word32 WAKE_Base::M(word32 x, word32 y)\n{\n\tword32 w = x+y;\n\treturn (w>>8) ^ t[w & 0xff];\n}",
    "includes": [
      "#include \"wake.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"wake.h\"\n#include \"pch.h\"\n\ninline word32 WAKE_Base::M(word32 x, word32 y)\n{\n\tword32 w = x+y;\n\treturn (w>>8) ^ t[w & 0xff];\n}"
  },
  {
    "function_name": "WAKE_TestInstantiations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/wake.cpp",
    "lines": "8-12",
    "snippet": "void WAKE_TestInstantiations()\n{\n\tWAKE_OFB<>::Encryption x2;\n\tWAKE_OFB<>::Decryption x4;\n}",
    "includes": [
      "#include \"wake.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"wake.h\"\n#include \"pch.h\"\n\nvoid WAKE_TestInstantiations()\n{\n\tWAKE_OFB<>::Encryption x2;\n\tWAKE_OFB<>::Decryption x4;\n}"
  }
]