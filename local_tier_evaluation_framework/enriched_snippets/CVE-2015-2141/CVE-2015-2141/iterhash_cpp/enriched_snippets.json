[
  {
    "function_name": "IteratedHashBase<T, BASE>::TruncatedFinal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "126-150",
    "snippet": "void IteratedHashBase<T, BASE>::TruncatedFinal(byte *digest, size_t size)\n{\n\tthis->ThrowIfInvalidTruncatedSize(size);\n\n\tT* dataBuf = this->DataBuf();\n\tT* stateBuf = this->StateBuf();\n\tunsigned int blockSize = this->BlockSize();\n\tByteOrder order = this->GetByteOrder();\n\n\tPadLastBlock(blockSize - 2*sizeof(HashWordType));\n\tdataBuf[blockSize/sizeof(T)-2+order] = ConditionalByteReverse(order, this->GetBitCountLo());\n\tdataBuf[blockSize/sizeof(T)-1-order] = ConditionalByteReverse(order, this->GetBitCountHi());\n\n\tHashBlock(dataBuf);\n\n\tif (IsAligned<HashWordType>(digest) && size%sizeof(HashWordType)==0)\n\t\tConditionalByteReverse<HashWordType>(order, (HashWordType *)digest, stateBuf, size);\n\telse\n\t{\n\t\tConditionalByteReverse<HashWordType>(order, stateBuf, stateBuf, this->DigestSize());\n\t\tmemcpy(digest, stateBuf, size);\n\t}\n\n\tthis->Restart();\t\t// reinit for next use\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->Restart",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "Restart",
          "container": "HermeticHashFunctionMAC",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.h",
          "lines": "55-59",
          "snippet": "void Restart()\n\t{\n\t\tm_hash.Restart();\n\t\tm_keyed = false;\n\t}",
          "includes": [
            "#include \"iterhash.h\"",
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"iterhash.h\"\n#include \"strciphr.h\"\n\nHermeticHashFunctionMAC {\n  void Restart()\n  \t{\n  \t\tm_hash.Restart();\n  \t\tm_keyed = false;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "digest",
            "stateBuf",
            "size"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConditionalByteReverse<HashWordType>",
          "args": [
            "order",
            "stateBuf",
            "stateBuf",
            "this->DigestSize()"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "937-943",
          "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->DigestSize",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAligned<HashWordType>",
          "args": [
            "digest"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashBlock",
          "args": [
            "dataBuf"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "HashBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "44-44",
          "snippet": "void HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}"
        }
      },
      {
        "call_info": {
          "callee": "this->GetBitCountHi",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->GetBitCountLo",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "GetBitCountLo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "36-36",
          "snippet": "inline T GetBitCountLo() const {return m_countLo << 3;}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\ninline T GetBitCountLo() const {return m_countLo << 3;}"
        }
      },
      {
        "call_info": {
          "callee": "PadLastBlock",
          "args": [
            "blockSize - 2*sizeof(HashWordType)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->GetByteOrder",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "GetByteOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "22-22",
          "snippet": "ByteOrder GetByteOrder() const {return LITTLE_ENDIAN_ORDER;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nByteOrder GetByteOrder() const {return LITTLE_ENDIAN_ORDER;}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "this->StateBuf",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->DataBuf",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->ThrowIfInvalidTruncatedSize",
          "args": [
            "size"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nvoid IteratedHashBase<T, BASE>::TruncatedFinal(byte *digest, size_t size)\n{\n\tthis->ThrowIfInvalidTruncatedSize(size);\n\n\tT* dataBuf = this->DataBuf();\n\tT* stateBuf = this->StateBuf();\n\tunsigned int blockSize = this->BlockSize();\n\tByteOrder order = this->GetByteOrder();\n\n\tPadLastBlock(blockSize - 2*sizeof(HashWordType));\n\tdataBuf[blockSize/sizeof(T)-2+order] = ConditionalByteReverse(order, this->GetBitCountLo());\n\tdataBuf[blockSize/sizeof(T)-1-order] = ConditionalByteReverse(order, this->GetBitCountHi());\n\n\tHashBlock(dataBuf);\n\n\tif (IsAligned<HashWordType>(digest) && size%sizeof(HashWordType)==0)\n\t\tConditionalByteReverse<HashWordType>(order, (HashWordType *)digest, stateBuf, size);\n\telse\n\t{\n\t\tConditionalByteReverse<HashWordType>(order, stateBuf, stateBuf, this->DigestSize());\n\t\tmemcpy(digest, stateBuf, size);\n\t}\n\n\tthis->Restart();\t\t// reinit for next use\n}"
  },
  {
    "function_name": "IteratedHashBase<T, BASE>::Restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "120-124",
    "snippet": "void IteratedHashBase<T, BASE>::Restart()\n{\n\tm_countLo = m_countHi = 0;\n\tInit();\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "30-30",
          "snippet": "void Init() {}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nvoid Init() {}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nvoid IteratedHashBase<T, BASE>::Restart()\n{\n\tm_countLo = m_countHi = 0;\n\tInit();\n}"
  },
  {
    "function_name": "IteratedHashBase<T, BASE>::PadLastBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "103-118",
    "snippet": "void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tunsigned int num = ModPowerOf2(m_countLo, blockSize);\n\tT* dataBuf = this->DataBuf();\n\tbyte* data = (byte *)dataBuf;\n\tdata[num++] = padFirst;\n\tif (num <= lastBlockSize)\n\t\tmemset(data+num, 0, lastBlockSize-num);\n\telse\n\t{\n\t\tmemset(data+num, 0, blockSize-num);\n\t\tHashBlock(dataBuf);\n\t\tmemset(data, 0, lastBlockSize);\n\t}\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "lastBlockSize"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashBlock",
          "args": [
            "dataBuf"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "HashBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "44-44",
          "snippet": "void HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data+num",
            "0",
            "blockSize-num"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data+num",
            "0",
            "lastBlockSize-num"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->DataBuf",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModPowerOf2",
          "args": [
            "m_countLo",
            "blockSize"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ModPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "339-343",
          "snippet": "inline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nvoid IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tunsigned int num = ModPowerOf2(m_countLo, blockSize);\n\tT* dataBuf = this->DataBuf();\n\tbyte* data = (byte *)dataBuf;\n\tdata[num++] = padFirst;\n\tif (num <= lastBlockSize)\n\t\tmemset(data+num, 0, lastBlockSize-num);\n\telse\n\t{\n\t\tmemset(data+num, 0, blockSize-num);\n\t\tHashBlock(dataBuf);\n\t\tmemset(data, 0, lastBlockSize);\n\t}\n}"
  },
  {
    "function_name": "IteratedHashBase<T, BASE>::HashMultipleBlocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "81-101",
    "snippet": "size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n\tT* dataBuf = this->DataBuf();\n\tdo\n\t{\n\t\tif (noReverse)\n\t\t\tthis->HashEndianCorrectedBlock(input);\n\t\telse\n\t\t{\n\t\t\tByteReverse(dataBuf, input, this->BlockSize());\n\t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n\t\t}\n\n\t\tinput += blockSize/sizeof(T);\n\t\tlength -= blockSize;\n\t}\n\twhile (length >= blockSize);\n\treturn length;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->HashEndianCorrectedBlock",
          "args": [
            "dataBuf"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "HashEndianCorrectedBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ttmac.h",
          "lines": "24-24",
          "snippet": "void HashEndianCorrectedBlock(const word32 *data) {Transform(m_digest, data, false);}",
          "includes": [
            "#include \"iterhash.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"iterhash.h\"\n#include \"seckey.h\"\n\nvoid HashEndianCorrectedBlock(const word32 *data) {Transform(m_digest, data, false);}"
        }
      },
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "dataBuf",
            "input",
            "this->BlockSize()"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "928-934",
          "snippet": "void ByteReverse(T *out, const T *in, size_t byteCount)\n{\n\tassert(byteCount % sizeof(T) == 0);\n\tsize_t count = byteCount/sizeof(T);\n\tfor (size_t i=0; i<count; i++)\n\t\tout[i] = ByteReverse(in[i]);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nvoid ByteReverse(T *out, const T *in, size_t byteCount)\n{\n\tassert(byteCount % sizeof(T) == 0);\n\tsize_t count = byteCount/sizeof(T);\n\tfor (size_t i=0; i<count; i++)\n\t\tout[i] = ByteReverse(in[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "this->DataBuf",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NativeByteOrderIs",
          "args": [
            "this->GetByteOrder()"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "NativeByteOrderIs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "403-406",
          "snippet": "inline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->GetByteOrder",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "GetByteOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "22-22",
          "snippet": "ByteOrder GetByteOrder() const {return LITTLE_ENDIAN_ORDER;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nByteOrder GetByteOrder() const {return LITTLE_ENDIAN_ORDER;}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nsize_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n\tT* dataBuf = this->DataBuf();\n\tdo\n\t{\n\t\tif (noReverse)\n\t\t\tthis->HashEndianCorrectedBlock(input);\n\t\telse\n\t\t{\n\t\t\tByteReverse(dataBuf, input, this->BlockSize());\n\t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n\t\t}\n\n\t\tinput += blockSize/sizeof(T);\n\t\tlength -= blockSize;\n\t}\n\twhile (length >= blockSize);\n\treturn length;\n}"
  },
  {
    "function_name": "IteratedHashBase<T, BASE>::Update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "12-71",
    "snippet": "void IteratedHashBase<T, BASE>::Update(const byte *input, size_t len)\n{\n\tHashWordType oldCountLo = m_countLo, oldCountHi = m_countHi;\n\tif ((m_countLo = oldCountLo + HashWordType(len)) < oldCountLo)\n\t\tm_countHi++;             // carry from low to high\n\tm_countHi += (HashWordType)SafeRightShift<8*sizeof(HashWordType)>(len);\n\tif (m_countHi < oldCountHi || SafeRightShift<2*8*sizeof(HashWordType)>(len) != 0)\n\t\tthrow HashInputTooLong(this->AlgorithmName());\n\n\tunsigned int blockSize = this->BlockSize();\n\tunsigned int num = ModPowerOf2(oldCountLo, blockSize);\n\tT* dataBuf = this->DataBuf();\n\tbyte* data = (byte *)dataBuf;\n\n\tif (num != 0)\t// process left over data\n\t{\n\t\tif (num+len >= blockSize)\n\t\t{\n\t\t\tmemcpy(data+num, input, blockSize-num);\n\t\t\tHashBlock(dataBuf);\n\t\t\tinput += (blockSize-num);\n\t\t\tlen -= (blockSize-num);\n\t\t\tnum = 0;\n\t\t\t// drop through and do the rest\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(data+num, input, len);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\n\tif (len >= blockSize)\n\t{\n\t\tif (input == data)\n\t\t{\n\t\t\tassert(len == blockSize);\n\t\t\tHashBlock(dataBuf);\n\t\t\treturn;\n\t\t}\n\t\telse if (IsAligned<T>(input))\n\t\t{\n\t\t\tsize_t leftOver = HashMultipleBlocks((T *)input, len);\n\t\t\tinput += (len - leftOver);\n\t\t\tlen = leftOver;\n\t\t}\n\t\telse\n\t\t\tdo\n\t\t\t{   // copy input first if it's not aligned correctly\n\t\t\t\tmemcpy(data, input, blockSize);\n\t\t\t\tHashBlock(dataBuf);\n\t\t\t\tinput+=blockSize;\n\t\t\t\tlen-=blockSize;\n\t\t\t} while (len >= blockSize);\n\t}\n\n\tif (len && data != input)\n\t\tmemcpy(data, input, len);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "input",
            "len"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashBlock",
          "args": [
            "dataBuf"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "HashBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "44-44",
          "snippet": "void HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "input",
            "blockSize"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashMultipleBlocks",
          "args": [
            "(T *)input",
            "len"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "IteratedHashBase<T, BASE>::HashMultipleBlocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
          "lines": "81-101",
          "snippet": "size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n\tT* dataBuf = this->DataBuf();\n\tdo\n\t{\n\t\tif (noReverse)\n\t\t\tthis->HashEndianCorrectedBlock(input);\n\t\telse\n\t\t{\n\t\t\tByteReverse(dataBuf, input, this->BlockSize());\n\t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n\t\t}\n\n\t\tinput += blockSize/sizeof(T);\n\t\tlength -= blockSize;\n\t}\n\twhile (length >= blockSize);\n\treturn length;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nsize_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n\tT* dataBuf = this->DataBuf();\n\tdo\n\t{\n\t\tif (noReverse)\n\t\t\tthis->HashEndianCorrectedBlock(input);\n\t\telse\n\t\t{\n\t\t\tByteReverse(dataBuf, input, this->BlockSize());\n\t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n\t\t}\n\n\t\tinput += blockSize/sizeof(T);\n\t\tlength -= blockSize;\n\t}\n\twhile (length >= blockSize);\n\treturn length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAligned<T>",
          "args": [
            "input"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len == blockSize"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data+num",
            "input",
            "len"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data+num",
            "input",
            "blockSize-num"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->DataBuf",
          "args": [],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModPowerOf2",
          "args": [
            "oldCountLo",
            "blockSize"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "ModPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "339-343",
          "snippet": "inline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "HashInputTooLong",
          "args": [
            "this->AlgorithmName()"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AlgorithmName",
          "args": [],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "AlgorithmName",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "17-17",
          "snippet": "std::string AlgorithmName() const {return \"SHA-3-\" + IntToString(m_digestSize*8);}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  std::string AlgorithmName() const {return \"SHA-3-\" + IntToString(m_digestSize*8);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_countHi < oldCountHi || SafeRightShift<2*8*sizeof",
          "args": [
            "len"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SafeRightShift<8*sizeof",
          "args": [
            "len"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashWordType",
          "args": [
            "len"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nvoid IteratedHashBase<T, BASE>::Update(const byte *input, size_t len)\n{\n\tHashWordType oldCountLo = m_countLo, oldCountHi = m_countHi;\n\tif ((m_countLo = oldCountLo + HashWordType(len)) < oldCountLo)\n\t\tm_countHi++;             // carry from low to high\n\tm_countHi += (HashWordType)SafeRightShift<8*sizeof(HashWordType)>(len);\n\tif (m_countHi < oldCountHi || SafeRightShift<2*8*sizeof(HashWordType)>(len) != 0)\n\t\tthrow HashInputTooLong(this->AlgorithmName());\n\n\tunsigned int blockSize = this->BlockSize();\n\tunsigned int num = ModPowerOf2(oldCountLo, blockSize);\n\tT* dataBuf = this->DataBuf();\n\tbyte* data = (byte *)dataBuf;\n\n\tif (num != 0)\t// process left over data\n\t{\n\t\tif (num+len >= blockSize)\n\t\t{\n\t\t\tmemcpy(data+num, input, blockSize-num);\n\t\t\tHashBlock(dataBuf);\n\t\t\tinput += (blockSize-num);\n\t\t\tlen -= (blockSize-num);\n\t\t\tnum = 0;\n\t\t\t// drop through and do the rest\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(data+num, input, len);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\n\tif (len >= blockSize)\n\t{\n\t\tif (input == data)\n\t\t{\n\t\t\tassert(len == blockSize);\n\t\t\tHashBlock(dataBuf);\n\t\t\treturn;\n\t\t}\n\t\telse if (IsAligned<T>(input))\n\t\t{\n\t\t\tsize_t leftOver = HashMultipleBlocks((T *)input, len);\n\t\t\tinput += (len - leftOver);\n\t\t\tlen = leftOver;\n\t\t}\n\t\telse\n\t\t\tdo\n\t\t\t{   // copy input first if it's not aligned correctly\n\t\t\t\tmemcpy(data, input, blockSize);\n\t\t\t\tHashBlock(dataBuf);\n\t\t\t\tinput+=blockSize;\n\t\t\t\tlen-=blockSize;\n\t\t\t} while (len >= blockSize);\n\t}\n\n\tif (len && data != input)\n\t\tmemcpy(data, input, len);\n}"
  }
]