[
  {
    "function_name": "TruncatedFinal",
    "container": "IteratedHashBase<T, BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "126-150",
    "snippet": "void IteratedHashBase<T, BASE>::TruncatedFinal(byte *digest, size_t size)\n{\n\tthis->ThrowIfInvalidTruncatedSize(size);\n\n\tT* dataBuf = this->DataBuf();\n\tT* stateBuf = this->StateBuf();\n\tunsigned int blockSize = this->BlockSize();\n\tByteOrder order = this->GetByteOrder();\n\n\tPadLastBlock(blockSize - 2*sizeof(HashWordType));\n\tdataBuf[blockSize/sizeof(T)-2+order] = ConditionalByteReverse(order, this->GetBitCountLo());\n\tdataBuf[blockSize/sizeof(T)-1-order] = ConditionalByteReverse(order, this->GetBitCountHi());\n\n\tHashBlock(dataBuf);\n\n\tif (IsAligned<HashWordType>(digest) && size%sizeof(HashWordType)==0)\n\t\tConditionalByteReverse<HashWordType>(order, (HashWordType *)digest, stateBuf, size);\n\telse\n\t{\n\t\tConditionalByteReverse<HashWordType>(order, stateBuf, stateBuf, this->DigestSize());\n\t\tmemcpy(digest, stateBuf, size);\n\t}\n\n\tthis->Restart();\t\t// reinit for next use\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->Restart",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "Restart",
          "container": "IteratedHashBase<T, BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
          "lines": "120-124",
          "snippet": "void IteratedHashBase<T, BASE>::Restart()\n{\n\tm_countLo = m_countHi = 0;\n\tInit();\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  void IteratedHashBase<T, BASE>::Restart()\n  {\n  \tm_countLo = m_countHi = 0;\n  \tInit();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "digest",
            "stateBuf",
            "size"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConditionalByteReverse<HashWordType>",
          "args": [
            "order",
            "stateBuf",
            "stateBuf",
            "this->DigestSize()"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "ConditionalByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "937-943",
          "snippet": "inline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void ConditionalByteReverse(ByteOrder order, T *out, const T *in, size_t byteCount)\n{\n\tif (!NativeByteOrderIs(order))\n\t\tByteReverse(out, in, byteCount);\n\telse if (in != out)\n\t\tmemcpy_s(out, byteCount, in, byteCount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->DigestSize",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAligned<HashWordType>",
          "args": [
            "digest"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "HashBlock",
          "args": [
            "dataBuf"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "HashBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "44-44",
          "snippet": "void HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}"
        }
      },
      {
        "call_info": {
          "callee": "this->GetBitCountHi",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->GetBitCountLo",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "GetBitCountLo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "36-36",
          "snippet": "inline T GetBitCountLo() const {return m_countLo << 3;}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\ninline T GetBitCountLo() const {return m_countLo << 3;}"
        }
      },
      {
        "call_info": {
          "callee": "PadLastBlock",
          "args": [
            "blockSize - 2*sizeof(HashWordType)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->GetByteOrder",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "GetByteOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "22-22",
          "snippet": "ByteOrder GetByteOrder() const {return LITTLE_ENDIAN_ORDER;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nByteOrder GetByteOrder() const {return LITTLE_ENDIAN_ORDER;}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "this->StateBuf",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->DataBuf",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->ThrowIfInvalidTruncatedSize",
          "args": [
            "size"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ThrowIfInvalidTruncatedSize",
          "container": "HashTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "309-313",
          "snippet": "void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n{\n\tif (size > DigestSize())\n\t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nHashTransformation {\n  void HashTransformation::ThrowIfInvalidTruncatedSize(size_t size) const\n  {\n  \tif (size > DigestSize())\n  \t\tthrow InvalidArgument(\"HashTransformation: can't truncate a \" + IntToString(DigestSize()) + \" byte digest to \" + IntToString(size) + \" bytes\");\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  void IteratedHashBase<T, BASE>::TruncatedFinal(byte *digest, size_t size)\n  {\n  \tthis->ThrowIfInvalidTruncatedSize(size);\n  \n  \tT* dataBuf = this->DataBuf();\n  \tT* stateBuf = this->StateBuf();\n  \tunsigned int blockSize = this->BlockSize();\n  \tByteOrder order = this->GetByteOrder();\n  \n  \tPadLastBlock(blockSize - 2*sizeof(HashWordType));\n  \tdataBuf[blockSize/sizeof(T)-2+order] = ConditionalByteReverse(order, this->GetBitCountLo());\n  \tdataBuf[blockSize/sizeof(T)-1-order] = ConditionalByteReverse(order, this->GetBitCountHi());\n  \n  \tHashBlock(dataBuf);\n  \n  \tif (IsAligned<HashWordType>(digest) && size%sizeof(HashWordType)==0)\n  \t\tConditionalByteReverse<HashWordType>(order, (HashWordType *)digest, stateBuf, size);\n  \telse\n  \t{\n  \t\tConditionalByteReverse<HashWordType>(order, stateBuf, stateBuf, this->DigestSize());\n  \t\tmemcpy(digest, stateBuf, size);\n  \t}\n  \n  \tthis->Restart();\t\t// reinit for next use\n  }\n}"
  },
  {
    "function_name": "Restart",
    "container": "IteratedHashBase<T, BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "120-124",
    "snippet": "void IteratedHashBase<T, BASE>::Restart()\n{\n\tm_countLo = m_countHi = 0;\n\tInit();\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "InitializeInteger",
          "container": "InitializeInteger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2733-2740",
          "snippet": "InitializeInteger::InitializeInteger()\n{\n\tif (!g_pAssignIntToInteger)\n\t{\n\t\tSetFunctionPointers();\n\t\tg_pAssignIntToInteger = AssignIntToInteger;\n\t}\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInitializeInteger {\n  InitializeInteger::InitializeInteger()\n  {\n  \tif (!g_pAssignIntToInteger)\n  \t{\n  \t\tSetFunctionPointers();\n  \t\tg_pAssignIntToInteger = AssignIntToInteger;\n  \t}\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  void IteratedHashBase<T, BASE>::Restart()\n  {\n  \tm_countLo = m_countHi = 0;\n  \tInit();\n  }\n}"
  },
  {
    "function_name": "PadLastBlock",
    "container": "IteratedHashBase<T, BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "103-118",
    "snippet": "void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tunsigned int num = ModPowerOf2(m_countLo, blockSize);\n\tT* dataBuf = this->DataBuf();\n\tbyte* data = (byte *)dataBuf;\n\tdata[num++] = padFirst;\n\tif (num <= lastBlockSize)\n\t\tmemset(data+num, 0, lastBlockSize-num);\n\telse\n\t{\n\t\tmemset(data+num, 0, blockSize-num);\n\t\tHashBlock(dataBuf);\n\t\tmemset(data, 0, lastBlockSize);\n\t}\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "lastBlockSize"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashBlock",
          "args": [
            "dataBuf"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "HashBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "44-44",
          "snippet": "void HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data+num",
            "0",
            "blockSize-num"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data+num",
            "0",
            "lastBlockSize-num"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->DataBuf",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModPowerOf2",
          "args": [
            "m_countLo",
            "blockSize"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ModPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "339-343",
          "snippet": "inline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  void IteratedHashBase<T, BASE>::PadLastBlock(unsigned int lastBlockSize, byte padFirst)\n  {\n  \tunsigned int blockSize = this->BlockSize();\n  \tunsigned int num = ModPowerOf2(m_countLo, blockSize);\n  \tT* dataBuf = this->DataBuf();\n  \tbyte* data = (byte *)dataBuf;\n  \tdata[num++] = padFirst;\n  \tif (num <= lastBlockSize)\n  \t\tmemset(data+num, 0, lastBlockSize-num);\n  \telse\n  \t{\n  \t\tmemset(data+num, 0, blockSize-num);\n  \t\tHashBlock(dataBuf);\n  \t\tmemset(data, 0, lastBlockSize);\n  \t}\n  }\n}"
  },
  {
    "function_name": "HashMultipleBlocks",
    "container": "IteratedHashBase<T, BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "81-101",
    "snippet": "size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n\tT* dataBuf = this->DataBuf();\n\tdo\n\t{\n\t\tif (noReverse)\n\t\t\tthis->HashEndianCorrectedBlock(input);\n\t\telse\n\t\t{\n\t\t\tByteReverse(dataBuf, input, this->BlockSize());\n\t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n\t\t}\n\n\t\tinput += blockSize/sizeof(T);\n\t\tlength -= blockSize;\n\t}\n\twhile (length >= blockSize);\n\treturn length;\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->HashEndianCorrectedBlock",
          "args": [
            "dataBuf"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "HashEndianCorrectedBlock",
          "container": "VMAC_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.cpp",
          "lines": "133-137",
          "snippet": "void VMAC_Base::HashEndianCorrectedBlock(const word64 *data)\n{\n\tassert(false);\n\tthrow 0;\n}",
          "includes": [
            "#include <intrin.h>",
            "#include \"cpu.h\"",
            "#include \"argnames.h\"",
            "#include \"vmac.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [
            "#define const\t// Turbo C++ 2006 workaround"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <intrin.h>\n#include \"cpu.h\"\n#include \"argnames.h\"\n#include \"vmac.h\"\n#include \"pch.h\"\n\n#define const\t// Turbo C++ 2006 workaround\n\nVMAC_Base {\n  void VMAC_Base::HashEndianCorrectedBlock(const word64 *data)\n  {\n  \tassert(false);\n  \tthrow 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ByteReverse",
          "args": [
            "dataBuf",
            "input",
            "this->BlockSize()"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ByteReverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "928-934",
          "snippet": "void ByteReverse(T *out, const T *in, size_t byteCount)\n{\n\tassert(byteCount % sizeof(T) == 0);\n\tsize_t count = byteCount/sizeof(T);\n\tfor (size_t i=0; i<count; i++)\n\t\tout[i] = ByteReverse(in[i]);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nvoid ByteReverse(T *out, const T *in, size_t byteCount)\n{\n\tassert(byteCount % sizeof(T) == 0);\n\tsize_t count = byteCount/sizeof(T);\n\tfor (size_t i=0; i<count; i++)\n\t\tout[i] = ByteReverse(in[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "this->DataBuf",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NativeByteOrderIs",
          "args": [
            "this->GetByteOrder()"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "NativeByteOrderIs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "403-406",
          "snippet": "inline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool NativeByteOrderIs(ByteOrder order)\n{\n\treturn order == GetNativeByteOrder();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->GetByteOrder",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "GetByteOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "22-22",
          "snippet": "ByteOrder GetByteOrder() const {return LITTLE_ENDIAN_ORDER;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nByteOrder GetByteOrder() const {return LITTLE_ENDIAN_ORDER;}"
        }
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n  {\n  \tunsigned int blockSize = this->BlockSize();\n  \tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n  \tT* dataBuf = this->DataBuf();\n  \tdo\n  \t{\n  \t\tif (noReverse)\n  \t\t\tthis->HashEndianCorrectedBlock(input);\n  \t\telse\n  \t\t{\n  \t\t\tByteReverse(dataBuf, input, this->BlockSize());\n  \t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n  \t\t}\n  \n  \t\tinput += blockSize/sizeof(T);\n  \t\tlength -= blockSize;\n  \t}\n  \twhile (length >= blockSize);\n  \treturn length;\n  }\n}"
  },
  {
    "function_name": "Update",
    "container": "IteratedHashBase<T, BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
    "lines": "12-71",
    "snippet": "void IteratedHashBase<T, BASE>::Update(const byte *input, size_t len)\n{\n\tHashWordType oldCountLo = m_countLo, oldCountHi = m_countHi;\n\tif ((m_countLo = oldCountLo + HashWordType(len)) < oldCountLo)\n\t\tm_countHi++;             // carry from low to high\n\tm_countHi += (HashWordType)SafeRightShift<8*sizeof(HashWordType)>(len);\n\tif (m_countHi < oldCountHi || SafeRightShift<2*8*sizeof(HashWordType)>(len) != 0)\n\t\tthrow HashInputTooLong(this->AlgorithmName());\n\n\tunsigned int blockSize = this->BlockSize();\n\tunsigned int num = ModPowerOf2(oldCountLo, blockSize);\n\tT* dataBuf = this->DataBuf();\n\tbyte* data = (byte *)dataBuf;\n\n\tif (num != 0)\t// process left over data\n\t{\n\t\tif (num+len >= blockSize)\n\t\t{\n\t\t\tmemcpy(data+num, input, blockSize-num);\n\t\t\tHashBlock(dataBuf);\n\t\t\tinput += (blockSize-num);\n\t\t\tlen -= (blockSize-num);\n\t\t\tnum = 0;\n\t\t\t// drop through and do the rest\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(data+num, input, len);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\n\tif (len >= blockSize)\n\t{\n\t\tif (input == data)\n\t\t{\n\t\t\tassert(len == blockSize);\n\t\t\tHashBlock(dataBuf);\n\t\t\treturn;\n\t\t}\n\t\telse if (IsAligned<T>(input))\n\t\t{\n\t\t\tsize_t leftOver = HashMultipleBlocks((T *)input, len);\n\t\t\tinput += (len - leftOver);\n\t\t\tlen = leftOver;\n\t\t}\n\t\telse\n\t\t\tdo\n\t\t\t{   // copy input first if it's not aligned correctly\n\t\t\t\tmemcpy(data, input, blockSize);\n\t\t\t\tHashBlock(dataBuf);\n\t\t\t\tinput+=blockSize;\n\t\t\t\tlen-=blockSize;\n\t\t\t} while (len >= blockSize);\n\t}\n\n\tif (len && data != input)\n\t\tmemcpy(data, input, len);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include \"iterhash.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "input",
            "len"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashBlock",
          "args": [
            "dataBuf"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "HashBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.h",
          "lines": "44-44",
          "snippet": "void HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nvoid HashBlock(const HashWordType *input) {HashMultipleBlocks(input, this->BlockSize());}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "input",
            "blockSize"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashMultipleBlocks",
          "args": [
            "(T *)input",
            "len"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "HashMultipleBlocks",
          "container": "IteratedHashBase<T, BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/iterhash.cpp",
          "lines": "81-101",
          "snippet": "size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n{\n\tunsigned int blockSize = this->BlockSize();\n\tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n\tT* dataBuf = this->DataBuf();\n\tdo\n\t{\n\t\tif (noReverse)\n\t\t\tthis->HashEndianCorrectedBlock(input);\n\t\telse\n\t\t{\n\t\t\tByteReverse(dataBuf, input, this->BlockSize());\n\t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n\t\t}\n\n\t\tinput += blockSize/sizeof(T);\n\t\tlength -= blockSize;\n\t}\n\twhile (length >= blockSize);\n\treturn length;\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  size_t IteratedHashBase<T, BASE>::HashMultipleBlocks(const T *input, size_t length)\n  {\n  \tunsigned int blockSize = this->BlockSize();\n  \tbool noReverse = NativeByteOrderIs(this->GetByteOrder());\n  \tT* dataBuf = this->DataBuf();\n  \tdo\n  \t{\n  \t\tif (noReverse)\n  \t\t\tthis->HashEndianCorrectedBlock(input);\n  \t\telse\n  \t\t{\n  \t\t\tByteReverse(dataBuf, input, this->BlockSize());\n  \t\t\tthis->HashEndianCorrectedBlock(dataBuf);\n  \t\t}\n  \n  \t\tinput += blockSize/sizeof(T);\n  \t\tlength -= blockSize;\n  \t}\n  \twhile (length >= blockSize);\n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsAligned<T>",
          "args": [
            "input"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "IsAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "387-390",
          "snippet": "inline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAligned(const void *p, T *dummy=NULL)\t// VC60 workaround\n{\n\treturn IsAlignedOn(p, GetAlignmentOf<T>());\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len == blockSize"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data+num",
            "input",
            "len"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data+num",
            "input",
            "blockSize-num"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->DataBuf",
          "args": [],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ModPowerOf2",
          "args": [
            "oldCountLo",
            "blockSize"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "ModPowerOf2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "339-343",
          "snippet": "inline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T2 ModPowerOf2(const T1 &a, const T2 &b)\n{\n\tassert(IsPowerOf2(b));\n\treturn T2(a) & (b-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->BlockSize",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "BlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.h",
          "lines": "21-21",
          "snippet": "unsigned int BlockSize() const {return m_L1KeyLength;}",
          "includes": [
            "#include \"seckey.h\"",
            "#include \"iterhash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"seckey.h\"\n#include \"iterhash.h\"\n\nunsigned int BlockSize() const {return m_L1KeyLength;}"
        }
      },
      {
        "call_info": {
          "callee": "HashInputTooLong",
          "args": [
            "this->AlgorithmName()"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AlgorithmName",
          "args": [],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "AlgorithmName",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "17-17",
          "snippet": "std::string AlgorithmName() const {return \"SHA-3-\" + IntToString(m_digestSize*8);}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  std::string AlgorithmName() const {return \"SHA-3-\" + IntToString(m_digestSize*8);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_countHi < oldCountHi || SafeRightShift<2*8*sizeof",
          "args": [
            "len"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SafeRightShift<8*sizeof",
          "args": [
            "len"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HashWordType",
          "args": [
            "len"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include \"iterhash.h\"\n\nIteratedHashBase<T, BASE> {\n  void IteratedHashBase<T, BASE>::Update(const byte *input, size_t len)\n  {\n  \tHashWordType oldCountLo = m_countLo, oldCountHi = m_countHi;\n  \tif ((m_countLo = oldCountLo + HashWordType(len)) < oldCountLo)\n  \t\tm_countHi++;             // carry from low to high\n  \tm_countHi += (HashWordType)SafeRightShift<8*sizeof(HashWordType)>(len);\n  \tif (m_countHi < oldCountHi || SafeRightShift<2*8*sizeof(HashWordType)>(len) != 0)\n  \t\tthrow HashInputTooLong(this->AlgorithmName());\n  \n  \tunsigned int blockSize = this->BlockSize();\n  \tunsigned int num = ModPowerOf2(oldCountLo, blockSize);\n  \tT* dataBuf = this->DataBuf();\n  \tbyte* data = (byte *)dataBuf;\n  \n  \tif (num != 0)\t// process left over data\n  \t{\n  \t\tif (num+len >= blockSize)\n  \t\t{\n  \t\t\tmemcpy(data+num, input, blockSize-num);\n  \t\t\tHashBlock(dataBuf);\n  \t\t\tinput += (blockSize-num);\n  \t\t\tlen -= (blockSize-num);\n  \t\t\tnum = 0;\n  \t\t\t// drop through and do the rest\n  \t\t}\n  \t\telse\n  \t\t{\n  \t\t\tmemcpy(data+num, input, len);\n  \t\t\treturn;\n  \t\t}\n  \t}\n  \n  \t// now process the input data in blocks of blockSize bytes and save the leftovers to m_data\n  \tif (len >= blockSize)\n  \t{\n  \t\tif (input == data)\n  \t\t{\n  \t\t\tassert(len == blockSize);\n  \t\t\tHashBlock(dataBuf);\n  \t\t\treturn;\n  \t\t}\n  \t\telse if (IsAligned<T>(input))\n  \t\t{\n  \t\t\tsize_t leftOver = HashMultipleBlocks((T *)input, len);\n  \t\t\tinput += (len - leftOver);\n  \t\t\tlen = leftOver;\n  \t\t}\n  \t\telse\n  \t\t\tdo\n  \t\t\t{   // copy input first if it's not aligned correctly\n  \t\t\t\tmemcpy(data, input, blockSize);\n  \t\t\t\tHashBlock(dataBuf);\n  \t\t\t\tinput+=blockSize;\n  \t\t\t\tlen-=blockSize;\n  \t\t\t} while (len >= blockSize);\n  \t}\n  \n  \tif (len && data != input)\n  \t\tmemcpy(data, input, len);\n  }\n}"
  }
]