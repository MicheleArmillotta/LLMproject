[
  {
    "function_name": "ProcessLastBlock",
    "container": "CBC_CTS_Decryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "209-241",
    "snippet": "void CBC_CTS_Decryption::ProcessLastBlock(byte *outString, const byte *inString, size_t length)\n{\n\tconst byte *pn, *pn1;\n\tbool stealIV = length <= BlockSize();\n\n\tif (stealIV)\n\t{\n\t\tpn = inString;\n\t\tpn1 = m_register;\n\t}\n\telse\n\t{\n\t\tpn = inString + BlockSize();\n\t\tpn1 = inString;\n\t\tlength -= BlockSize();\n\t}\n\n\t// decrypt last partial plaintext block\n\tmemcpy(m_temp, pn1, BlockSize());\n\tm_cipher->ProcessBlock(m_temp);\n\txorbuf(m_temp, pn, length);\n\n\tif (stealIV)\n\t\tmemcpy(outString, m_temp, length);\n\telse\n\t{\n\t\tmemcpy(outString+BlockSize(), m_temp, length);\n\t\t// decrypt next to last plaintext block\n\t\tmemcpy(m_temp, pn, length);\n\t\tm_cipher->ProcessBlock(m_temp);\n\t\txorbuf(outString, m_temp, m_register, BlockSize());\n\t}\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "outString",
            "m_temp",
            "m_register",
            "BlockSize()"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "47-77",
          "snippet": "void xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->ProcessBlock",
          "args": [
            "m_temp"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_temp",
            "pn",
            "length"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString+BlockSize()",
            "m_temp",
            "length"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "m_temp",
            "length"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->ProcessBlock",
          "args": [
            "m_temp"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_temp",
            "pn1",
            "BlockSize()"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCBC_CTS_Decryption {\n  void CBC_CTS_Decryption::ProcessLastBlock(byte *outString, const byte *inString, size_t length)\n  {\n  \tconst byte *pn, *pn1;\n  \tbool stealIV = length <= BlockSize();\n  \n  \tif (stealIV)\n  \t{\n  \t\tpn = inString;\n  \t\tpn1 = m_register;\n  \t}\n  \telse\n  \t{\n  \t\tpn = inString + BlockSize();\n  \t\tpn1 = inString;\n  \t\tlength -= BlockSize();\n  \t}\n  \n  \t// decrypt last partial plaintext block\n  \tmemcpy(m_temp, pn1, BlockSize());\n  \tm_cipher->ProcessBlock(m_temp);\n  \txorbuf(m_temp, pn, length);\n  \n  \tif (stealIV)\n  \t\tmemcpy(outString, m_temp, length);\n  \telse\n  \t{\n  \t\tmemcpy(outString+BlockSize(), m_temp, length);\n  \t\t// decrypt next to last plaintext block\n  \t\tmemcpy(m_temp, pn, length);\n  \t\tm_cipher->ProcessBlock(m_temp);\n  \t\txorbuf(outString, m_temp, m_register, BlockSize());\n  \t}\n  }\n}"
  },
  {
    "function_name": "ProcessData",
    "container": "CBC_Decryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "195-207",
    "snippet": "void CBC_Decryption::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tif (!length)\n\t\treturn;\n\tassert(length%BlockSize()==0);\n\n\tunsigned int blockSize = BlockSize();\n\tmemcpy(m_temp, inString+length-blockSize, blockSize);\t// save copy now in case of in-place decryption\n\tif (length > blockSize)\n\t\tm_cipher->AdvancedProcessBlocks(inString+blockSize, inString, outString+blockSize, length-blockSize, BlockTransformation::BT_ReverseDirection|BlockTransformation::BT_AllowParallel);\n\tm_cipher->ProcessAndXorBlock(inString, m_register, outString);\n\tm_register.swap(m_temp);\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_register.swap",
          "args": [
            "m_temp"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "swap",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "2954-2958",
          "snippet": "void Integer::swap(Integer &a)\n{\n\treg.swap(a.reg);\n\tstd::swap(sign, a.sign);\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::swap(Integer &a)\n  {\n  \treg.swap(a.reg);\n  \tstd::swap(sign, a.sign);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->ProcessAndXorBlock",
          "args": [
            "inString",
            "m_register",
            "outString"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessAndXorBlock",
          "container": "SKIPJACK::Dec",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/skipjack.cpp",
          "lines": "152-198",
          "snippet": "void SKIPJACK::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tword16 w1, w2, w3, w4;\n\tBlock::Get(inBlock)(w4)(w3)(w2)(w1);\n\n\t/* stepping rule A: */\n\th1(tab, w2); w3 ^= w2 ^ 32;\n\th0(tab, w3); w4 ^= w3 ^ 31;\n\th4(tab, w4); w1 ^= w4 ^ 30;\n\th3(tab, w1); w2 ^= w1 ^ 29;\n\th2(tab, w2); w3 ^= w2 ^ 28;\n\th1(tab, w3); w4 ^= w3 ^ 27;\n\th0(tab, w4); w1 ^= w4 ^ 26;\n\th4(tab, w1); w2 ^= w1 ^ 25;\n\n\t/* stepping rule B: */\n\tw1 ^= w2 ^ 24; h3(tab, w2);\n\tw2 ^= w3 ^ 23; h2(tab, w3);\n\tw3 ^= w4 ^ 22; h1(tab, w4);\n\tw4 ^= w1 ^ 21; h0(tab, w1);\n\tw1 ^= w2 ^ 20; h4(tab, w2);\n\tw2 ^= w3 ^ 19; h3(tab, w3);\n\tw3 ^= w4 ^ 18; h2(tab, w4);\n\tw4 ^= w1 ^ 17; h1(tab, w1);\n\n\t/* stepping rule A: */\n\th0(tab, w2); w3 ^= w2 ^ 16;\n\th4(tab, w3); w4 ^= w3 ^ 15;\n\th3(tab, w4); w1 ^= w4 ^ 14;\n\th2(tab, w1); w2 ^= w1 ^ 13;\n\th1(tab, w2); w3 ^= w2 ^ 12;\n\th0(tab, w3); w4 ^= w3 ^ 11;\n\th4(tab, w4); w1 ^= w4 ^ 10;\n\th3(tab, w1); w2 ^= w1 ^  9;\n\n\t/* stepping rule B: */\n\tw1 ^= w2 ^ 8; h2(tab, w2);\n\tw2 ^= w3 ^ 7; h1(tab, w3);\n\tw3 ^= w4 ^ 6; h0(tab, w4);\n\tw4 ^= w1 ^ 5; h4(tab, w1);\n\tw1 ^= w2 ^ 4; h3(tab, w2);\n\tw2 ^= w3 ^ 3; h2(tab, w3);\n\tw3 ^= w4 ^ 2; h1(tab, w4);\n\tw4 ^= w1 ^ 1; h0(tab, w1);\n\n\tBlock::Put(xorBlock, outBlock)(w4)(w3)(w2)(w1);\n}",
          "includes": [
            "#include \"skipjack.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"skipjack.h\"\n#include \"pch.h\"\n\nSKIPJACK {\n  Dec {\n    void SKIPJACK::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tword16 w1, w2, w3, w4;\n    \tBlock::Get(inBlock)(w4)(w3)(w2)(w1);\n    \n    \t/* stepping rule A: */\n    \th1(tab, w2); w3 ^= w2 ^ 32;\n    \th0(tab, w3); w4 ^= w3 ^ 31;\n    \th4(tab, w4); w1 ^= w4 ^ 30;\n    \th3(tab, w1); w2 ^= w1 ^ 29;\n    \th2(tab, w2); w3 ^= w2 ^ 28;\n    \th1(tab, w3); w4 ^= w3 ^ 27;\n    \th0(tab, w4); w1 ^= w4 ^ 26;\n    \th4(tab, w1); w2 ^= w1 ^ 25;\n    \n    \t/* stepping rule B: */\n    \tw1 ^= w2 ^ 24; h3(tab, w2);\n    \tw2 ^= w3 ^ 23; h2(tab, w3);\n    \tw3 ^= w4 ^ 22; h1(tab, w4);\n    \tw4 ^= w1 ^ 21; h0(tab, w1);\n    \tw1 ^= w2 ^ 20; h4(tab, w2);\n    \tw2 ^= w3 ^ 19; h3(tab, w3);\n    \tw3 ^= w4 ^ 18; h2(tab, w4);\n    \tw4 ^= w1 ^ 17; h1(tab, w1);\n    \n    \t/* stepping rule A: */\n    \th0(tab, w2); w3 ^= w2 ^ 16;\n    \th4(tab, w3); w4 ^= w3 ^ 15;\n    \th3(tab, w4); w1 ^= w4 ^ 14;\n    \th2(tab, w1); w2 ^= w1 ^ 13;\n    \th1(tab, w2); w3 ^= w2 ^ 12;\n    \th0(tab, w3); w4 ^= w3 ^ 11;\n    \th4(tab, w4); w1 ^= w4 ^ 10;\n    \th3(tab, w1); w2 ^= w1 ^  9;\n    \n    \t/* stepping rule B: */\n    \tw1 ^= w2 ^ 8; h2(tab, w2);\n    \tw2 ^= w3 ^ 7; h1(tab, w3);\n    \tw3 ^= w4 ^ 6; h0(tab, w4);\n    \tw4 ^= w1 ^ 5; h4(tab, w1);\n    \tw1 ^= w2 ^ 4; h3(tab, w2);\n    \tw2 ^= w3 ^ 3; h2(tab, w3);\n    \tw3 ^= w4 ^ 2; h1(tab, w4);\n    \tw4 ^= w1 ^ 1; h0(tab, w1);\n    \n    \tBlock::Put(xorBlock, outBlock)(w4)(w3)(w2)(w1);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->AdvancedProcessBlocks",
          "args": [
            "inString+blockSize",
            "inString",
            "outString+blockSize",
            "length-blockSize",
            "BlockTransformation::BT_ReverseDirection|BlockTransformation::BT_AllowParallel"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "AdvancedProcessBlocks",
          "container": "BlockTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "141-177",
          "snippet": "size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n{\n\tsize_t blockSize = BlockSize();\n\tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n\tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n\tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n\n\tif (flags & BT_ReverseDirection)\n\t{\n\t\tassert(length % blockSize == 0);\n\t\tinBlocks += length - blockSize;\n\t\txorBlocks += length - blockSize;\n\t\toutBlocks += length - blockSize;\n\t\tinIncrement = 0-inIncrement;\n\t\txorIncrement = 0-xorIncrement;\n\t\toutIncrement = 0-outIncrement;\n\t}\n\n\twhile (length >= blockSize)\n\t{\n\t\tif (flags & BT_XorInput)\n\t\t{\n\t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n\t\t\tProcessBlock(outBlocks);\n\t\t}\n\t\telse\n\t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n\t\tif (flags & BT_InBlockIsCounter)\n\t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n\t\tinBlocks += inIncrement;\n\t\toutBlocks += outIncrement;\n\t\txorBlocks += xorIncrement;\n\t\tlength -= blockSize;\n\t}\n\n\treturn length;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBlockTransformation {\n  size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n  {\n  \tsize_t blockSize = BlockSize();\n  \tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n  \tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n  \tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n  \n  \tif (flags & BT_ReverseDirection)\n  \t{\n  \t\tassert(length % blockSize == 0);\n  \t\tinBlocks += length - blockSize;\n  \t\txorBlocks += length - blockSize;\n  \t\toutBlocks += length - blockSize;\n  \t\tinIncrement = 0-inIncrement;\n  \t\txorIncrement = 0-xorIncrement;\n  \t\toutIncrement = 0-outIncrement;\n  \t}\n  \n  \twhile (length >= blockSize)\n  \t{\n  \t\tif (flags & BT_XorInput)\n  \t\t{\n  \t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n  \t\t\tProcessBlock(outBlocks);\n  \t\t}\n  \t\telse\n  \t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n  \t\tif (flags & BT_InBlockIsCounter)\n  \t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n  \t\tinBlocks += inIncrement;\n  \t\toutBlocks += outIncrement;\n  \t\txorBlocks += xorIncrement;\n  \t\tlength -= blockSize;\n  \t}\n  \n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_temp",
            "inString+length-blockSize",
            "blockSize"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length%BlockSize()==0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCBC_Decryption {\n  void CBC_Decryption::ProcessData(byte *outString, const byte *inString, size_t length)\n  {\n  \tif (!length)\n  \t\treturn;\n  \tassert(length%BlockSize()==0);\n  \n  \tunsigned int blockSize = BlockSize();\n  \tmemcpy(m_temp, inString+length-blockSize, blockSize);\t// save copy now in case of in-place decryption\n  \tif (length > blockSize)\n  \t\tm_cipher->AdvancedProcessBlocks(inString+blockSize, inString, outString+blockSize, length-blockSize, BlockTransformation::BT_ReverseDirection|BlockTransformation::BT_AllowParallel);\n  \tm_cipher->ProcessAndXorBlock(inString, m_register, outString);\n  \tm_register.swap(m_temp);\n  }\n}"
  },
  {
    "function_name": "ProcessLastBlock",
    "container": "CBC_CTS_Encryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "168-193",
    "snippet": "void CBC_CTS_Encryption::ProcessLastBlock(byte *outString, const byte *inString, size_t length)\n{\n\tif (length <= BlockSize())\n\t{\n\t\tif (!m_stolenIV)\n\t\t\tthrow InvalidArgument(\"CBC_Encryption: message is too short for ciphertext stealing\");\n\n\t\t// steal from IV\n\t\tmemcpy(outString, m_register, length);\n\t\toutString = m_stolenIV;\n\t}\n\telse\n\t{\n\t\t// steal from next to last block\n\t\txorbuf(m_register, inString, BlockSize());\n\t\tm_cipher->ProcessBlock(m_register);\n\t\tinString += BlockSize();\n\t\tlength -= BlockSize();\n\t\tmemcpy(outString+BlockSize(), m_register, length);\n\t}\n\n\t// output last full ciphertext block\n\txorbuf(m_register, inString, length);\n\tm_cipher->ProcessBlock(m_register);\n\tmemcpy(outString, m_register, BlockSize());\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "m_register",
            "BlockSize()"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->ProcessBlock",
          "args": [
            "m_register"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "m_register",
            "inString",
            "length"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString+BlockSize()",
            "m_register",
            "length"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->ProcessBlock",
          "args": [
            "m_register"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "m_register",
            "length"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"CBC_Encryption: message is too short for ciphertext stealing\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCBC_CTS_Encryption {\n  void CBC_CTS_Encryption::ProcessLastBlock(byte *outString, const byte *inString, size_t length)\n  {\n  \tif (length <= BlockSize())\n  \t{\n  \t\tif (!m_stolenIV)\n  \t\t\tthrow InvalidArgument(\"CBC_Encryption: message is too short for ciphertext stealing\");\n  \n  \t\t// steal from IV\n  \t\tmemcpy(outString, m_register, length);\n  \t\toutString = m_stolenIV;\n  \t}\n  \telse\n  \t{\n  \t\t// steal from next to last block\n  \t\txorbuf(m_register, inString, BlockSize());\n  \t\tm_cipher->ProcessBlock(m_register);\n  \t\tinString += BlockSize();\n  \t\tlength -= BlockSize();\n  \t\tmemcpy(outString+BlockSize(), m_register, length);\n  \t}\n  \n  \t// output last full ciphertext block\n  \txorbuf(m_register, inString, length);\n  \tm_cipher->ProcessBlock(m_register);\n  \tmemcpy(outString, m_register, BlockSize());\n  }\n}"
  },
  {
    "function_name": "ProcessData",
    "container": "CBC_Encryption",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "155-166",
    "snippet": "void CBC_Encryption::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tif (!length)\n\t\treturn;\n\tassert(length%BlockSize()==0);\n\n\tunsigned int blockSize = BlockSize();\n\tm_cipher->AdvancedProcessBlocks(inString, m_register, outString, blockSize, BlockTransformation::BT_XorInput);\n\tif (length > blockSize)\n\t\tm_cipher->AdvancedProcessBlocks(inString+blockSize, outString, outString+blockSize, length-blockSize, BlockTransformation::BT_XorInput);\n\tmemcpy(m_register, outString + length - blockSize, blockSize);\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_register",
            "outString + length - blockSize",
            "blockSize"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->AdvancedProcessBlocks",
          "args": [
            "inString+blockSize",
            "outString",
            "outString+blockSize",
            "length-blockSize",
            "BlockTransformation::BT_XorInput"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "AdvancedProcessBlocks",
          "container": "BlockTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "141-177",
          "snippet": "size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n{\n\tsize_t blockSize = BlockSize();\n\tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n\tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n\tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n\n\tif (flags & BT_ReverseDirection)\n\t{\n\t\tassert(length % blockSize == 0);\n\t\tinBlocks += length - blockSize;\n\t\txorBlocks += length - blockSize;\n\t\toutBlocks += length - blockSize;\n\t\tinIncrement = 0-inIncrement;\n\t\txorIncrement = 0-xorIncrement;\n\t\toutIncrement = 0-outIncrement;\n\t}\n\n\twhile (length >= blockSize)\n\t{\n\t\tif (flags & BT_XorInput)\n\t\t{\n\t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n\t\t\tProcessBlock(outBlocks);\n\t\t}\n\t\telse\n\t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n\t\tif (flags & BT_InBlockIsCounter)\n\t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n\t\tinBlocks += inIncrement;\n\t\toutBlocks += outIncrement;\n\t\txorBlocks += xorIncrement;\n\t\tlength -= blockSize;\n\t}\n\n\treturn length;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBlockTransformation {\n  size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n  {\n  \tsize_t blockSize = BlockSize();\n  \tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n  \tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n  \tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n  \n  \tif (flags & BT_ReverseDirection)\n  \t{\n  \t\tassert(length % blockSize == 0);\n  \t\tinBlocks += length - blockSize;\n  \t\txorBlocks += length - blockSize;\n  \t\toutBlocks += length - blockSize;\n  \t\tinIncrement = 0-inIncrement;\n  \t\txorIncrement = 0-xorIncrement;\n  \t\toutIncrement = 0-outIncrement;\n  \t}\n  \n  \twhile (length >= blockSize)\n  \t{\n  \t\tif (flags & BT_XorInput)\n  \t\t{\n  \t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n  \t\t\tProcessBlock(outBlocks);\n  \t\t}\n  \t\telse\n  \t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n  \t\tif (flags & BT_InBlockIsCounter)\n  \t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n  \t\tinBlocks += inIncrement;\n  \t\toutBlocks += outIncrement;\n  \t\txorBlocks += xorIncrement;\n  \t\tlength -= blockSize;\n  \t}\n  \n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length%BlockSize()==0"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCBC_Encryption {\n  void CBC_Encryption::ProcessData(byte *outString, const byte *inString, size_t length)\n  {\n  \tif (!length)\n  \t\treturn;\n  \tassert(length%BlockSize()==0);\n  \n  \tunsigned int blockSize = BlockSize();\n  \tm_cipher->AdvancedProcessBlocks(inString, m_register, outString, blockSize, BlockTransformation::BT_XorInput);\n  \tif (length > blockSize)\n  \t\tm_cipher->AdvancedProcessBlocks(inString+blockSize, outString, outString+blockSize, length-blockSize, BlockTransformation::BT_XorInput);\n  \tmemcpy(m_register, outString + length - blockSize, blockSize);\n  }\n}"
  },
  {
    "function_name": "ProcessData",
    "container": "ECB_OneWay",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "149-153",
    "snippet": "void ECB_OneWay::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tassert(length%BlockSize()==0);\n\tm_cipher->AdvancedProcessBlocks(inString, NULL, outString, length, BlockTransformation::BT_AllowParallel);\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_cipher->AdvancedProcessBlocks",
          "args": [
            "inString",
            "NULL",
            "outString",
            "length",
            "BlockTransformation::BT_AllowParallel"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "AdvancedProcessBlocks",
          "container": "BlockTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "141-177",
          "snippet": "size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n{\n\tsize_t blockSize = BlockSize();\n\tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n\tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n\tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n\n\tif (flags & BT_ReverseDirection)\n\t{\n\t\tassert(length % blockSize == 0);\n\t\tinBlocks += length - blockSize;\n\t\txorBlocks += length - blockSize;\n\t\toutBlocks += length - blockSize;\n\t\tinIncrement = 0-inIncrement;\n\t\txorIncrement = 0-xorIncrement;\n\t\toutIncrement = 0-outIncrement;\n\t}\n\n\twhile (length >= blockSize)\n\t{\n\t\tif (flags & BT_XorInput)\n\t\t{\n\t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n\t\t\tProcessBlock(outBlocks);\n\t\t}\n\t\telse\n\t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n\t\tif (flags & BT_InBlockIsCounter)\n\t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n\t\tinBlocks += inIncrement;\n\t\toutBlocks += outIncrement;\n\t\txorBlocks += xorIncrement;\n\t\tlength -= blockSize;\n\t}\n\n\treturn length;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBlockTransformation {\n  size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n  {\n  \tsize_t blockSize = BlockSize();\n  \tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n  \tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n  \tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n  \n  \tif (flags & BT_ReverseDirection)\n  \t{\n  \t\tassert(length % blockSize == 0);\n  \t\tinBlocks += length - blockSize;\n  \t\txorBlocks += length - blockSize;\n  \t\toutBlocks += length - blockSize;\n  \t\tinIncrement = 0-inIncrement;\n  \t\txorIncrement = 0-xorIncrement;\n  \t\toutIncrement = 0-outIncrement;\n  \t}\n  \n  \twhile (length >= blockSize)\n  \t{\n  \t\tif (flags & BT_XorInput)\n  \t\t{\n  \t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n  \t\t\tProcessBlock(outBlocks);\n  \t\t}\n  \t\telse\n  \t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n  \t\tif (flags & BT_InBlockIsCounter)\n  \t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n  \t\tinBlocks += inIncrement;\n  \t\toutBlocks += outIncrement;\n  \t\txorBlocks += xorIncrement;\n  \t\tlength -= blockSize;\n  \t}\n  \n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length%BlockSize()==0"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nECB_OneWay {\n  void ECB_OneWay::ProcessData(byte *outString, const byte *inString, size_t length)\n  {\n  \tassert(length%BlockSize()==0);\n  \tm_cipher->AdvancedProcessBlocks(inString, NULL, outString, length, BlockTransformation::BT_AllowParallel);\n  }\n}"
  },
  {
    "function_name": "UncheckedSetKey",
    "container": "BlockOrientedCipherModeBase",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "137-147",
    "snippet": "void BlockOrientedCipherModeBase::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n{\n\tm_cipher->SetKey(key, length, params);\n\tResizeBuffers();\n\tif (IsResynchronizable())\n\t{\n\t\tsize_t ivLength;\n\t\tconst byte *iv = GetIVAndThrowIfInvalid(params, ivLength);\n\t\tResynchronize(iv, (int)ivLength);\n\t}\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Resynchronize",
          "args": [
            "iv",
            "(int)ivLength"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "CipherResynchronize",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "57-62",
          "snippet": "void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)\n{\n\tassert(length == BlockSize());\n\tCopyOrZero(m_register, iv, length);\n\tTransformRegister();\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)\n  {\n  \tassert(length == BlockSize());\n  \tCopyOrZero(m_register, iv, length);\n  \tTransformRegister();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetIVAndThrowIfInvalid",
          "args": [
            "params",
            "ivLength"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsResynchronizable",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResizeBuffers",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ResizeBuffers",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "71-75",
          "snippet": "void CFB_ModePolicy::ResizeBuffers()\n{\n\tCipherModeBase::ResizeBuffers();\n\tm_temp.New(BlockSize());\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::ResizeBuffers()\n  {\n  \tCipherModeBase::ResizeBuffers();\n  \tm_temp.New(BlockSize());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->SetKey",
          "args": [
            "key",
            "length",
            "params"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "SetKey",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "48-60",
          "snippet": "void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tm_bufferedDataLength = 0;\r\n\tm_state = State_Start;\r\n\r\n\tSetKeyWithoutResync(userKey, keylength, params);\r\n\tm_state = State_KeySet;\r\n\r\n\tsize_t length;\r\n\tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n\tif (iv)\r\n\t\tResynchronize(iv, (int)length);\r\n}",
          "includes": [
            "#include \"authenc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n  {\r\n  \tm_bufferedDataLength = 0;\r\n  \tm_state = State_Start;\r\n  \r\n  \tSetKeyWithoutResync(userKey, keylength, params);\r\n  \tm_state = State_KeySet;\r\n  \r\n  \tsize_t length;\r\n  \tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n  \tif (iv)\r\n  \t\tResynchronize(iv, (int)length);\r\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nBlockOrientedCipherModeBase {\n  void BlockOrientedCipherModeBase::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n  {\n  \tm_cipher->SetKey(key, length, params);\n  \tResizeBuffers();\n  \tif (IsResynchronizable())\n  \t{\n  \t\tsize_t ivLength;\n  \t\tconst byte *iv = GetIVAndThrowIfInvalid(params, ivLength);\n  \t\tResynchronize(iv, (int)ivLength);\n  \t}\n  }\n}"
  },
  {
    "function_name": "CipherResynchronize",
    "container": "CTR_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "130-135",
    "snippet": "void CTR_ModePolicy::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n{\n\tassert(length == BlockSize());\n\tCopyOrZero(m_register, iv, length);\n\tm_counterArray = m_register;\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CopyOrZero",
          "args": [
            "m_register",
            "iv",
            "length"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "CopyOrZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "115-121",
          "snippet": "inline void CopyOrZero(void *dest, const void *src, size_t s)\n{\n\tif (src)\n\t\tmemcpy_s(dest, s, src, s);\n\telse\n\t\tmemset(dest, 0, s);\n}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\ninline void CopyOrZero(void *dest, const void *src, size_t s)\n{\n\tif (src)\n\t\tmemcpy_s(dest, s, src, s);\n\telse\n\t\tmemset(dest, 0, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length == BlockSize()"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCTR_ModePolicy {\n  void CTR_ModePolicy::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n  {\n  \tassert(length == BlockSize());\n  \tCopyOrZero(m_register, iv, length);\n  \tm_counterArray = m_register;\n  }\n}"
  },
  {
    "function_name": "OperateKeystream",
    "container": "CTR_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "110-128",
    "snippet": "void CTR_ModePolicy::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)\n{\n\tassert(m_cipher->IsForwardTransformation());\t// CTR mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tunsigned int s = BlockSize();\n\tunsigned int inputIncrement = input ? s : 0;\n\n\twhile (iterationCount)\n\t{\n\t\tbyte lsb = m_counterArray[s-1];\n\t\tsize_t blocks = UnsignedMin(iterationCount, 256U-lsb);\n\t\tm_cipher->AdvancedProcessBlocks(m_counterArray, input, output, blocks*s, BlockTransformation::BT_InBlockIsCounter|BlockTransformation::BT_AllowParallel);\n\t\tif ((m_counterArray[s-1] = lsb + (byte)blocks) == 0)\n\t\t\tIncrementCounterBy256();\n\n\t\toutput += blocks*s;\n\t\tinput += blocks*inputIncrement;\n\t\titerationCount -= blocks;\n\t}\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IncrementCounterBy256",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "IncrementCounterBy256",
          "container": "CTR_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "105-108",
          "snippet": "void CTR_ModePolicy::IncrementCounterBy256()\n{\n\tIncrementCounterByOne(m_counterArray, BlockSize()-1);\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCTR_ModePolicy {\n  void CTR_ModePolicy::IncrementCounterBy256()\n  {\n  \tIncrementCounterByOne(m_counterArray, BlockSize()-1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->AdvancedProcessBlocks",
          "args": [
            "m_counterArray",
            "input",
            "output",
            "blocks*s",
            "BlockTransformation::BT_InBlockIsCounter|BlockTransformation::BT_AllowParallel"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "AdvancedProcessBlocks",
          "container": "BlockTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "141-177",
          "snippet": "size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n{\n\tsize_t blockSize = BlockSize();\n\tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n\tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n\tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n\n\tif (flags & BT_ReverseDirection)\n\t{\n\t\tassert(length % blockSize == 0);\n\t\tinBlocks += length - blockSize;\n\t\txorBlocks += length - blockSize;\n\t\toutBlocks += length - blockSize;\n\t\tinIncrement = 0-inIncrement;\n\t\txorIncrement = 0-xorIncrement;\n\t\toutIncrement = 0-outIncrement;\n\t}\n\n\twhile (length >= blockSize)\n\t{\n\t\tif (flags & BT_XorInput)\n\t\t{\n\t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n\t\t\tProcessBlock(outBlocks);\n\t\t}\n\t\telse\n\t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n\t\tif (flags & BT_InBlockIsCounter)\n\t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n\t\tinBlocks += inIncrement;\n\t\toutBlocks += outIncrement;\n\t\txorBlocks += xorIncrement;\n\t\tlength -= blockSize;\n\t}\n\n\treturn length;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBlockTransformation {\n  size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n  {\n  \tsize_t blockSize = BlockSize();\n  \tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n  \tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n  \tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n  \n  \tif (flags & BT_ReverseDirection)\n  \t{\n  \t\tassert(length % blockSize == 0);\n  \t\tinBlocks += length - blockSize;\n  \t\txorBlocks += length - blockSize;\n  \t\toutBlocks += length - blockSize;\n  \t\tinIncrement = 0-inIncrement;\n  \t\txorIncrement = 0-xorIncrement;\n  \t\toutIncrement = 0-outIncrement;\n  \t}\n  \n  \twhile (length >= blockSize)\n  \t{\n  \t\tif (flags & BT_XorInput)\n  \t\t{\n  \t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n  \t\t\tProcessBlock(outBlocks);\n  \t\t}\n  \t\telse\n  \t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n  \t\tif (flags & BT_InBlockIsCounter)\n  \t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n  \t\tinBlocks += inIncrement;\n  \t\toutBlocks += outIncrement;\n  \t\txorBlocks += xorIncrement;\n  \t\tlength -= blockSize;\n  \t}\n  \n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "iterationCount",
            "256U-lsb"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_cipher->IsForwardTransformation()"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->IsForwardTransformation",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "IsForwardTransformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/arc4.h",
          "lines": "25-25",
          "snippet": "bool IsForwardTransformation() const {return true;}",
          "includes": [
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n\nbool IsForwardTransformation() const {return true;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCTR_ModePolicy {\n  void CTR_ModePolicy::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// CTR mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tunsigned int s = BlockSize();\n  \tunsigned int inputIncrement = input ? s : 0;\n  \n  \twhile (iterationCount)\n  \t{\n  \t\tbyte lsb = m_counterArray[s-1];\n  \t\tsize_t blocks = UnsignedMin(iterationCount, 256U-lsb);\n  \t\tm_cipher->AdvancedProcessBlocks(m_counterArray, input, output, blocks*s, BlockTransformation::BT_InBlockIsCounter|BlockTransformation::BT_AllowParallel);\n  \t\tif ((m_counterArray[s-1] = lsb + (byte)blocks) == 0)\n  \t\t\tIncrementCounterBy256();\n  \n  \t\toutput += blocks*s;\n  \t\tinput += blocks*inputIncrement;\n  \t\titerationCount -= blocks;\n  \t}\n  }\n}"
  },
  {
    "function_name": "IncrementCounterBy256",
    "container": "CTR_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "105-108",
    "snippet": "void CTR_ModePolicy::IncrementCounterBy256()\n{\n\tIncrementCounterByOne(m_counterArray, BlockSize()-1);\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IncrementCounterByOne",
          "args": [
            "m_counterArray",
            "BlockSize()-1"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "IncrementCounterByOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "445-449",
          "snippet": "inline void IncrementCounterByOne(byte *inout, unsigned int s)\n{\n\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = !++inout[i];\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline void IncrementCounterByOne(byte *inout, unsigned int s)\n{\n\tfor (int i=s-1, carry=1; i>=0 && carry; i--)\n\t\tcarry = !++inout[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCTR_ModePolicy {\n  void CTR_ModePolicy::IncrementCounterBy256()\n  {\n  \tIncrementCounterByOne(m_counterArray, BlockSize()-1);\n  }\n}"
  },
  {
    "function_name": "SeekToIteration",
    "container": "CTR_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "93-103",
    "snippet": "void CTR_ModePolicy::SeekToIteration(lword iterationCount)\n{\n\tint carry=0;\n\tfor (int i=BlockSize()-1; i>=0; i--)\n\t{\n\t\tunsigned int sum = m_register[i] + byte(iterationCount) + carry;\n\t\tm_counterArray[i] = (byte) sum;\n\t\tcarry = sum >> 8;\n\t\titerationCount >>= 8;\n\t}\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "byte",
          "args": [
            "iterationCount"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCTR_ModePolicy {\n  void CTR_ModePolicy::SeekToIteration(lword iterationCount)\n  {\n  \tint carry=0;\n  \tfor (int i=BlockSize()-1; i>=0; i--)\n  \t{\n  \t\tunsigned int sum = m_register[i] + byte(iterationCount) + carry;\n  \t\tm_counterArray[i] = (byte) sum;\n  \t\tcarry = sum >> 8;\n  \t\titerationCount >>= 8;\n  \t}\n  }\n}"
  },
  {
    "function_name": "CipherResynchronize",
    "container": "OFB_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "87-91",
    "snippet": "void OFB_ModePolicy::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n{\n\tassert(length == BlockSize());\n\tCopyOrZero(m_register, iv, length);\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CopyOrZero",
          "args": [
            "m_register",
            "iv",
            "length"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "CopyOrZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "115-121",
          "snippet": "inline void CopyOrZero(void *dest, const void *src, size_t s)\n{\n\tif (src)\n\t\tmemcpy_s(dest, s, src, s);\n\telse\n\t\tmemset(dest, 0, s);\n}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\ninline void CopyOrZero(void *dest, const void *src, size_t s)\n{\n\tif (src)\n\t\tmemcpy_s(dest, s, src, s);\n\telse\n\t\tmemset(dest, 0, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length == BlockSize()"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nOFB_ModePolicy {\n  void OFB_ModePolicy::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n  {\n  \tassert(length == BlockSize());\n  \tCopyOrZero(m_register, iv, length);\n  }\n}"
  },
  {
    "function_name": "WriteKeystream",
    "container": "OFB_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "77-85",
    "snippet": "void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)\n{\n\tassert(m_cipher->IsForwardTransformation());\t// OFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tunsigned int s = BlockSize();\n\tm_cipher->ProcessBlock(m_register, keystreamBuffer);\n\tif (iterationCount > 1)\n\t\tm_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);\n\tmemcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_register",
            "keystreamBuffer+s*(iterationCount-1)",
            "s"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->AdvancedProcessBlocks",
          "args": [
            "keystreamBuffer",
            "NULL",
            "keystreamBuffer+s",
            "s*(iterationCount-1)",
            "0"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "AdvancedProcessBlocks",
          "container": "BlockTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "141-177",
          "snippet": "size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n{\n\tsize_t blockSize = BlockSize();\n\tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n\tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n\tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n\n\tif (flags & BT_ReverseDirection)\n\t{\n\t\tassert(length % blockSize == 0);\n\t\tinBlocks += length - blockSize;\n\t\txorBlocks += length - blockSize;\n\t\toutBlocks += length - blockSize;\n\t\tinIncrement = 0-inIncrement;\n\t\txorIncrement = 0-xorIncrement;\n\t\toutIncrement = 0-outIncrement;\n\t}\n\n\twhile (length >= blockSize)\n\t{\n\t\tif (flags & BT_XorInput)\n\t\t{\n\t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n\t\t\tProcessBlock(outBlocks);\n\t\t}\n\t\telse\n\t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n\t\tif (flags & BT_InBlockIsCounter)\n\t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n\t\tinBlocks += inIncrement;\n\t\toutBlocks += outIncrement;\n\t\txorBlocks += xorIncrement;\n\t\tlength -= blockSize;\n\t}\n\n\treturn length;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBlockTransformation {\n  size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n  {\n  \tsize_t blockSize = BlockSize();\n  \tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n  \tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n  \tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n  \n  \tif (flags & BT_ReverseDirection)\n  \t{\n  \t\tassert(length % blockSize == 0);\n  \t\tinBlocks += length - blockSize;\n  \t\txorBlocks += length - blockSize;\n  \t\toutBlocks += length - blockSize;\n  \t\tinIncrement = 0-inIncrement;\n  \t\txorIncrement = 0-xorIncrement;\n  \t\toutIncrement = 0-outIncrement;\n  \t}\n  \n  \twhile (length >= blockSize)\n  \t{\n  \t\tif (flags & BT_XorInput)\n  \t\t{\n  \t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n  \t\t\tProcessBlock(outBlocks);\n  \t\t}\n  \t\telse\n  \t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n  \t\tif (flags & BT_InBlockIsCounter)\n  \t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n  \t\tinBlocks += inIncrement;\n  \t\toutBlocks += outIncrement;\n  \t\txorBlocks += xorIncrement;\n  \t\tlength -= blockSize;\n  \t}\n  \n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->ProcessBlock",
          "args": [
            "m_register",
            "keystreamBuffer"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_cipher->IsForwardTransformation()"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->IsForwardTransformation",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "IsForwardTransformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/arc4.h",
          "lines": "25-25",
          "snippet": "bool IsForwardTransformation() const {return true;}",
          "includes": [
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n\nbool IsForwardTransformation() const {return true;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nOFB_ModePolicy {\n  void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// OFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tunsigned int s = BlockSize();\n  \tm_cipher->ProcessBlock(m_register, keystreamBuffer);\n  \tif (iterationCount > 1)\n  \t\tm_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);\n  \tmemcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);\n  }\n}"
  },
  {
    "function_name": "ResizeBuffers",
    "container": "CFB_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "71-75",
    "snippet": "void CFB_ModePolicy::ResizeBuffers()\n{\n\tCipherModeBase::ResizeBuffers();\n\tm_temp.New(BlockSize());\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_temp.New",
          "args": [
            "BlockSize()"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "CipherModeBase::ResizeBuffers",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ResizeBuffers",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "71-75",
          "snippet": "void CFB_ModePolicy::ResizeBuffers()\n{\n\tCipherModeBase::ResizeBuffers();\n\tm_temp.New(BlockSize());\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::ResizeBuffers()\n  {\n  \tCipherModeBase::ResizeBuffers();\n  \tm_temp.New(BlockSize());\n  }\n}"
  },
  {
    "function_name": "SetFeedbackSize",
    "container": "CFB_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "64-69",
    "snippet": "void CFB_ModePolicy::SetFeedbackSize(unsigned int feedbackSize)\n{\n\tif (feedbackSize > BlockSize())\n\t\tthrow InvalidArgument(\"CFB_Mode: invalid feedback size\");\n\tm_feedbackSize = feedbackSize ? feedbackSize : BlockSize();\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidArgument",
          "args": [
            "\"CFB_Mode: invalid feedback size\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::SetFeedbackSize(unsigned int feedbackSize)\n  {\n  \tif (feedbackSize > BlockSize())\n  \t\tthrow InvalidArgument(\"CFB_Mode: invalid feedback size\");\n  \tm_feedbackSize = feedbackSize ? feedbackSize : BlockSize();\n  }\n}"
  },
  {
    "function_name": "CipherResynchronize",
    "container": "CFB_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "57-62",
    "snippet": "void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)\n{\n\tassert(length == BlockSize());\n\tCopyOrZero(m_register, iv, length);\n\tTransformRegister();\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TransformRegister",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "TransformRegister",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "48-55",
          "snippet": "void CFB_ModePolicy::TransformRegister()\n{\n\tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tm_cipher->ProcessBlock(m_register, m_temp);\n\tunsigned int updateSize = BlockSize()-m_feedbackSize;\n\tmemmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);\n\tmemcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::TransformRegister()\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tm_cipher->ProcessBlock(m_register, m_temp);\n  \tunsigned int updateSize = BlockSize()-m_feedbackSize;\n  \tmemmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);\n  \tmemcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CopyOrZero",
          "args": [
            "m_register",
            "iv",
            "length"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "CopyOrZero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "115-121",
          "snippet": "inline void CopyOrZero(void *dest, const void *src, size_t s)\n{\n\tif (src)\n\t\tmemcpy_s(dest, s, src, s);\n\telse\n\t\tmemset(dest, 0, s);\n}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\ninline void CopyOrZero(void *dest, const void *src, size_t s)\n{\n\tif (src)\n\t\tmemcpy_s(dest, s, src, s);\n\telse\n\t\tmemset(dest, 0, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length == BlockSize()"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)\n  {\n  \tassert(length == BlockSize());\n  \tCopyOrZero(m_register, iv, length);\n  \tTransformRegister();\n  }\n}"
  },
  {
    "function_name": "TransformRegister",
    "container": "CFB_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "48-55",
    "snippet": "void CFB_ModePolicy::TransformRegister()\n{\n\tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tm_cipher->ProcessBlock(m_register, m_temp);\n\tunsigned int updateSize = BlockSize()-m_feedbackSize;\n\tmemmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);\n\tmemcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy_s",
          "args": [
            "m_register+updateSize",
            "m_register.size()-updateSize",
            "m_temp",
            "m_feedbackSize"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "145-150",
          "snippet": "inline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memcpy_s CryptoPP::memcpy_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memcpy_s CryptoPP::memcpy_s\n\ninline void memcpy_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memcpy_s: buffer overflow\");\n\tmemcpy(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_register.size",
          "args": [],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_s",
          "args": [
            "m_register",
            "m_register.size()",
            "m_register+m_feedbackSize",
            "updateSize"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "152-157",
          "snippet": "inline void memmove_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memmove_s: buffer overflow\");\n\tmemmove(dest, src, count);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [
            "#define memmove_s CryptoPP::memmove_s"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\n#define memmove_s CryptoPP::memmove_s\n\ninline void memmove_s(void *dest, size_t sizeInBytes, const void *src, size_t count)\n{\n\tif (count > sizeInBytes)\n\t\tthrow InvalidArgument(\"memmove_s: buffer overflow\");\n\tmemmove(dest, src, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->ProcessBlock",
          "args": [
            "m_register",
            "m_temp"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_cipher->IsForwardTransformation()"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->IsForwardTransformation",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "IsForwardTransformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/arc4.h",
          "lines": "25-25",
          "snippet": "bool IsForwardTransformation() const {return true;}",
          "includes": [
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n\nbool IsForwardTransformation() const {return true;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::TransformRegister()\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tm_cipher->ProcessBlock(m_register, m_temp);\n  \tunsigned int updateSize = BlockSize()-m_feedbackSize;\n  \tmemmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);\n  \tmemcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);\n  }\n}"
  },
  {
    "function_name": "Iterate",
    "container": "CFB_ModePolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "27-46",
    "snippet": "void CFB_ModePolicy::Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount)\n{\n\tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tassert(m_feedbackSize == BlockSize());\n\n\tunsigned int s = BlockSize();\n\tif (dir == ENCRYPTION)\n\t{\n\t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n\t\tm_cipher->AdvancedProcessBlocks(output, input+s, output+s, (iterationCount-1)*s, 0);\n\t\tmemcpy(m_register, output+(iterationCount-1)*s, s);\n\t}\n\telse\n\t{\n\t\tmemcpy(m_temp, input+(iterationCount-1)*s, s);\t// make copy first in case of in-place decryption\n\t\tm_cipher->AdvancedProcessBlocks(input, input+s, output+s, (iterationCount-1)*s, BlockTransformation::BT_ReverseDirection);\n\t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n\t\tmemcpy(m_register, m_temp, s);\n\t}\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_register",
            "m_temp",
            "s"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->ProcessAndXorBlock",
          "args": [
            "m_register",
            "input",
            "output"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessAndXorBlock",
          "container": "SKIPJACK::Dec",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/skipjack.cpp",
          "lines": "152-198",
          "snippet": "void SKIPJACK::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n{\n\tword16 w1, w2, w3, w4;\n\tBlock::Get(inBlock)(w4)(w3)(w2)(w1);\n\n\t/* stepping rule A: */\n\th1(tab, w2); w3 ^= w2 ^ 32;\n\th0(tab, w3); w4 ^= w3 ^ 31;\n\th4(tab, w4); w1 ^= w4 ^ 30;\n\th3(tab, w1); w2 ^= w1 ^ 29;\n\th2(tab, w2); w3 ^= w2 ^ 28;\n\th1(tab, w3); w4 ^= w3 ^ 27;\n\th0(tab, w4); w1 ^= w4 ^ 26;\n\th4(tab, w1); w2 ^= w1 ^ 25;\n\n\t/* stepping rule B: */\n\tw1 ^= w2 ^ 24; h3(tab, w2);\n\tw2 ^= w3 ^ 23; h2(tab, w3);\n\tw3 ^= w4 ^ 22; h1(tab, w4);\n\tw4 ^= w1 ^ 21; h0(tab, w1);\n\tw1 ^= w2 ^ 20; h4(tab, w2);\n\tw2 ^= w3 ^ 19; h3(tab, w3);\n\tw3 ^= w4 ^ 18; h2(tab, w4);\n\tw4 ^= w1 ^ 17; h1(tab, w1);\n\n\t/* stepping rule A: */\n\th0(tab, w2); w3 ^= w2 ^ 16;\n\th4(tab, w3); w4 ^= w3 ^ 15;\n\th3(tab, w4); w1 ^= w4 ^ 14;\n\th2(tab, w1); w2 ^= w1 ^ 13;\n\th1(tab, w2); w3 ^= w2 ^ 12;\n\th0(tab, w3); w4 ^= w3 ^ 11;\n\th4(tab, w4); w1 ^= w4 ^ 10;\n\th3(tab, w1); w2 ^= w1 ^  9;\n\n\t/* stepping rule B: */\n\tw1 ^= w2 ^ 8; h2(tab, w2);\n\tw2 ^= w3 ^ 7; h1(tab, w3);\n\tw3 ^= w4 ^ 6; h0(tab, w4);\n\tw4 ^= w1 ^ 5; h4(tab, w1);\n\tw1 ^= w2 ^ 4; h3(tab, w2);\n\tw2 ^= w3 ^ 3; h2(tab, w3);\n\tw3 ^= w4 ^ 2; h1(tab, w4);\n\tw4 ^= w1 ^ 1; h0(tab, w1);\n\n\tBlock::Put(xorBlock, outBlock)(w4)(w3)(w2)(w1);\n}",
          "includes": [
            "#include \"skipjack.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"skipjack.h\"\n#include \"pch.h\"\n\nSKIPJACK {\n  Dec {\n    void SKIPJACK::Dec::ProcessAndXorBlock(const byte *inBlock, const byte *xorBlock, byte *outBlock) const\n    {\n    \tword16 w1, w2, w3, w4;\n    \tBlock::Get(inBlock)(w4)(w3)(w2)(w1);\n    \n    \t/* stepping rule A: */\n    \th1(tab, w2); w3 ^= w2 ^ 32;\n    \th0(tab, w3); w4 ^= w3 ^ 31;\n    \th4(tab, w4); w1 ^= w4 ^ 30;\n    \th3(tab, w1); w2 ^= w1 ^ 29;\n    \th2(tab, w2); w3 ^= w2 ^ 28;\n    \th1(tab, w3); w4 ^= w3 ^ 27;\n    \th0(tab, w4); w1 ^= w4 ^ 26;\n    \th4(tab, w1); w2 ^= w1 ^ 25;\n    \n    \t/* stepping rule B: */\n    \tw1 ^= w2 ^ 24; h3(tab, w2);\n    \tw2 ^= w3 ^ 23; h2(tab, w3);\n    \tw3 ^= w4 ^ 22; h1(tab, w4);\n    \tw4 ^= w1 ^ 21; h0(tab, w1);\n    \tw1 ^= w2 ^ 20; h4(tab, w2);\n    \tw2 ^= w3 ^ 19; h3(tab, w3);\n    \tw3 ^= w4 ^ 18; h2(tab, w4);\n    \tw4 ^= w1 ^ 17; h1(tab, w1);\n    \n    \t/* stepping rule A: */\n    \th0(tab, w2); w3 ^= w2 ^ 16;\n    \th4(tab, w3); w4 ^= w3 ^ 15;\n    \th3(tab, w4); w1 ^= w4 ^ 14;\n    \th2(tab, w1); w2 ^= w1 ^ 13;\n    \th1(tab, w2); w3 ^= w2 ^ 12;\n    \th0(tab, w3); w4 ^= w3 ^ 11;\n    \th4(tab, w4); w1 ^= w4 ^ 10;\n    \th3(tab, w1); w2 ^= w1 ^  9;\n    \n    \t/* stepping rule B: */\n    \tw1 ^= w2 ^ 8; h2(tab, w2);\n    \tw2 ^= w3 ^ 7; h1(tab, w3);\n    \tw3 ^= w4 ^ 6; h0(tab, w4);\n    \tw4 ^= w1 ^ 5; h4(tab, w1);\n    \tw1 ^= w2 ^ 4; h3(tab, w2);\n    \tw2 ^= w3 ^ 3; h2(tab, w3);\n    \tw3 ^= w4 ^ 2; h1(tab, w4);\n    \tw4 ^= w1 ^ 1; h0(tab, w1);\n    \n    \tBlock::Put(xorBlock, outBlock)(w4)(w3)(w2)(w1);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_cipher->AdvancedProcessBlocks",
          "args": [
            "input",
            "input+s",
            "output+s",
            "(iterationCount-1)*s",
            "BlockTransformation::BT_ReverseDirection"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "AdvancedProcessBlocks",
          "container": "BlockTransformation",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "141-177",
          "snippet": "size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n{\n\tsize_t blockSize = BlockSize();\n\tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n\tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n\tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n\n\tif (flags & BT_ReverseDirection)\n\t{\n\t\tassert(length % blockSize == 0);\n\t\tinBlocks += length - blockSize;\n\t\txorBlocks += length - blockSize;\n\t\toutBlocks += length - blockSize;\n\t\tinIncrement = 0-inIncrement;\n\t\txorIncrement = 0-xorIncrement;\n\t\toutIncrement = 0-outIncrement;\n\t}\n\n\twhile (length >= blockSize)\n\t{\n\t\tif (flags & BT_XorInput)\n\t\t{\n\t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n\t\t\tProcessBlock(outBlocks);\n\t\t}\n\t\telse\n\t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n\t\tif (flags & BT_InBlockIsCounter)\n\t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n\t\tinBlocks += inIncrement;\n\t\toutBlocks += outIncrement;\n\t\txorBlocks += xorIncrement;\n\t\tlength -= blockSize;\n\t}\n\n\treturn length;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nBlockTransformation {\n  size_t BlockTransformation::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const\n  {\n  \tsize_t blockSize = BlockSize();\n  \tsize_t inIncrement = (flags & (BT_InBlockIsCounter|BT_DontIncrementInOutPointers)) ? 0 : blockSize;\n  \tsize_t xorIncrement = xorBlocks ? blockSize : 0;\n  \tsize_t outIncrement = (flags & BT_DontIncrementInOutPointers) ? 0 : blockSize;\n  \n  \tif (flags & BT_ReverseDirection)\n  \t{\n  \t\tassert(length % blockSize == 0);\n  \t\tinBlocks += length - blockSize;\n  \t\txorBlocks += length - blockSize;\n  \t\toutBlocks += length - blockSize;\n  \t\tinIncrement = 0-inIncrement;\n  \t\txorIncrement = 0-xorIncrement;\n  \t\toutIncrement = 0-outIncrement;\n  \t}\n  \n  \twhile (length >= blockSize)\n  \t{\n  \t\tif (flags & BT_XorInput)\n  \t\t{\n  \t\t\txorbuf(outBlocks, xorBlocks, inBlocks, blockSize);\n  \t\t\tProcessBlock(outBlocks);\n  \t\t}\n  \t\telse\n  \t\t\tProcessAndXorBlock(inBlocks, xorBlocks, outBlocks);\n  \t\tif (flags & BT_InBlockIsCounter)\n  \t\t\tconst_cast<byte *>(inBlocks)[blockSize-1]++;\n  \t\tinBlocks += inIncrement;\n  \t\toutBlocks += outIncrement;\n  \t\txorBlocks += xorIncrement;\n  \t\tlength -= blockSize;\n  \t}\n  \n  \treturn length;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_temp",
            "input+(iterationCount-1)*s",
            "s"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "m_register",
            "output+(iterationCount-1)*s",
            "s"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlockSize",
          "args": [],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "MinLastBlockSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.h",
          "lines": "211-211",
          "snippet": "unsigned int MinLastBlockSize() const {return BlockSize()+1;}",
          "includes": [
            "#include \"algparam.h\"",
            "#include \"argnames.h\"",
            "#include \"strciphr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algparam.h\"\n#include \"argnames.h\"\n#include \"strciphr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nunsigned int MinLastBlockSize() const {return BlockSize()+1;}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_feedbackSize == BlockSize()"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_cipher->IsForwardTransformation()"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_cipher->IsForwardTransformation",
          "args": [],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "IsForwardTransformation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/arc4.h",
          "lines": "25-25",
          "snippet": "bool IsForwardTransformation() const {return true;}",
          "includes": [
            "#include \"strciphr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n\nbool IsForwardTransformation() const {return true;}"
        }
      }
    ],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount)\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tassert(m_feedbackSize == BlockSize());\n  \n  \tunsigned int s = BlockSize();\n  \tif (dir == ENCRYPTION)\n  \t{\n  \t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n  \t\tm_cipher->AdvancedProcessBlocks(output, input+s, output+s, (iterationCount-1)*s, 0);\n  \t\tmemcpy(m_register, output+(iterationCount-1)*s, s);\n  \t}\n  \telse\n  \t{\n  \t\tmemcpy(m_temp, input+(iterationCount-1)*s, s);\t// make copy first in case of in-place decryption\n  \t\tm_cipher->AdvancedProcessBlocks(input, input+s, output+s, (iterationCount-1)*s, BlockTransformation::BT_ReverseDirection);\n  \t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n  \t\tmemcpy(m_register, m_temp, s);\n  \t}\n  }\n}"
  },
  {
    "function_name": "Modes_TestInstantiations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
    "lines": "16-24",
    "snippet": "void Modes_TestInstantiations()\n{\n\tCFB_Mode<DES>::Encryption m0;\n\tCFB_Mode<DES>::Decryption m1;\n\tOFB_Mode<DES>::Encryption m2;\n\tCTR_Mode<DES>::Encryption m3;\n\tECB_Mode<DES>::Encryption m4;\n\tCBC_Mode<DES>::Encryption m5;\n}",
    "includes": [
      "#include \"des.h\"",
      "#include \"modes.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nvoid Modes_TestInstantiations()\n{\n\tCFB_Mode<DES>::Encryption m0;\n\tCFB_Mode<DES>::Decryption m1;\n\tOFB_Mode<DES>::Encryption m2;\n\tCTR_Mode<DES>::Encryption m3;\n\tECB_Mode<DES>::Encryption m4;\n\tCBC_Mode<DES>::Encryption m5;\n}"
  }
]