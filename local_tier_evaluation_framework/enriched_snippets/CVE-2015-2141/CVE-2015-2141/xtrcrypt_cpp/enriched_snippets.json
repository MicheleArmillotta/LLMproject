[
  {
    "function_name": "Agree",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "90-106",
    "snippet": "bool XTR_DH::Agree(byte *agreedValue, const byte *privateKey, const byte *otherPublicKey, bool validateOtherPublicKey) const\n{\n\tGFP2Element w(otherPublicKey, PublicKeyLength());\n\tif (validateOtherPublicKey)\n\t{\n\t\tGFP2_ONB<ModularArithmetic> gfp2(m_p);\n\t\tGFP2Element three = gfp2.ConvertIn(3);\n\t\tif (w.c1.IsNegative() || w.c2.IsNegative() || w.c1 >= m_p || w.c2 >= m_p || w == three)\n\t\t\treturn false;\n\t\tif (XTR_Exponentiate(w, m_q, m_p) != three)\n\t\t\treturn false;\n\t}\n\tInteger s(privateKey, PrivateKeyLength());\n\tGFP2Element z = XTR_Exponentiate(w, s, m_p);\n\tz.Encode(agreedValue, AgreedValueLength());\n\treturn true;\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "z.Encode",
          "args": [
            "agreedValue",
            "AgreedValueLength()"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AgreedValueLength",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "AgreedValueLength",
          "container": "XTR_DH",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.h",
          "lines": "29-29",
          "snippet": "unsigned int AgreedValueLength() const {return 2*m_p.ByteCount();}",
          "includes": [
            "#include \"xtr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xtr.h\"\n\nXTR_DH {\n  unsigned int AgreedValueLength() const {return 2*m_p.ByteCount();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XTR_Exponentiate",
          "args": [
            "w",
            "s",
            "m_p"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "XTR_Exponentiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.cpp",
          "lines": "53-95",
          "snippet": "GFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"xtr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"xtr.h\"\n#include \"pch.h\"\n\nGFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "w.c2.IsNegative",
          "args": [],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "IsNegative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "201-201",
          "snippet": "bool IsNegative() const {return sign == NEGATIVE;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsNegative() const {return sign == NEGATIVE;}"
        }
      },
      {
        "call_info": {
          "callee": "gfp2.ConvertIn",
          "args": [
            "3"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ConvertIn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ecp.h",
          "lines": "104-105",
          "snippet": "Element ConvertIn(const Element &P) const\n\t\t{return P.identity ? P : ECP::Point(m_ec->GetField().ConvertIn(P.x), m_ec->GetField().ConvertIn(P.y));}",
          "includes": [
            "#include \"pubkey.h\"",
            "#include \"smartptr.h\"",
            "#include \"eprecomp.h\"",
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n#include \"smartptr.h\"\n#include \"eprecomp.h\"\n#include \"modarith.h\"\n\nElement ConvertIn(const Element &P) const\n\t\t{return P.identity ? P : ECP::Point(m_ec->GetField().ConvertIn(P.x), m_ec->GetField().ConvertIn(P.y));}"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  bool XTR_DH::Agree(byte *agreedValue, const byte *privateKey, const byte *otherPublicKey, bool validateOtherPublicKey) const\n  {\n  \tGFP2Element w(otherPublicKey, PublicKeyLength());\n  \tif (validateOtherPublicKey)\n  \t{\n  \t\tGFP2_ONB<ModularArithmetic> gfp2(m_p);\n  \t\tGFP2Element three = gfp2.ConvertIn(3);\n  \t\tif (w.c1.IsNegative() || w.c2.IsNegative() || w.c1 >= m_p || w.c2 >= m_p || w == three)\n  \t\t\treturn false;\n  \t\tif (XTR_Exponentiate(w, m_q, m_p) != three)\n  \t\t\treturn false;\n  \t}\n  \tInteger s(privateKey, PrivateKeyLength());\n  \tGFP2Element z = XTR_Exponentiate(w, s, m_p);\n  \tz.Encode(agreedValue, AgreedValueLength());\n  \treturn true;\n  }\n}"
  },
  {
    "function_name": "GeneratePublicKey",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "83-88",
    "snippet": "void XTR_DH::GeneratePublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const\n{\n\tInteger x(privateKey, PrivateKeyLength());\n\tGFP2Element y = XTR_Exponentiate(m_g, x, m_p);\n\ty.Encode(publicKey, PublicKeyLength());\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "y.Encode",
          "args": [
            "publicKey",
            "PublicKeyLength()"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "PolynomialMod2",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf2n.cpp",
          "lines": "157-161",
          "snippet": "void PolynomialMod2::Encode(BufferedTransformation &bt, size_t outputLen) const\n{\n\tfor (size_t i=outputLen; i > 0; i--)\n\t\tbt.Put(GetByte(i-1));\n}",
          "includes": [
            "#include <iostream>",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"randpool.h\"",
            "#include \"words.h\"",
            "#include \"algebra.h\"",
            "#include \"gf2n.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"randpool.h\"\n#include \"words.h\"\n#include \"algebra.h\"\n#include \"gf2n.h\"\n#include \"pch.h\"\n\nPolynomialMod2 {\n  void PolynomialMod2::Encode(BufferedTransformation &bt, size_t outputLen) const\n  {\n  \tfor (size_t i=outputLen; i > 0; i--)\n  \t\tbt.Put(GetByte(i-1));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PublicKeyLength",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "PublicKeyLength",
          "container": "XTR_DH",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.h",
          "lines": "31-31",
          "snippet": "unsigned int PublicKeyLength() const {return 2*m_p.ByteCount();}",
          "includes": [
            "#include \"xtr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xtr.h\"\n\nXTR_DH {\n  unsigned int PublicKeyLength() const {return 2*m_p.ByteCount();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XTR_Exponentiate",
          "args": [
            "m_g",
            "x",
            "m_p"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "XTR_Exponentiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.cpp",
          "lines": "53-95",
          "snippet": "GFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"xtr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"xtr.h\"\n#include \"pch.h\"\n\nGFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  void XTR_DH::GeneratePublicKey(RandomNumberGenerator &rng, const byte *privateKey, byte *publicKey) const\n  {\n  \tInteger x(privateKey, PrivateKeyLength());\n  \tGFP2Element y = XTR_Exponentiate(m_g, x, m_p);\n  \ty.Encode(publicKey, PublicKeyLength());\n  }\n}"
  },
  {
    "function_name": "GeneratePrivateKey",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "77-81",
    "snippet": "void XTR_DH::GeneratePrivateKey(RandomNumberGenerator &rng, byte *privateKey) const\n{\n\tInteger x(rng, Integer::Zero(), m_q-1);\n\tx.Encode(privateKey, PrivateKeyLength());\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x.Encode",
          "args": [
            "privateKey",
            "PrivateKeyLength()"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrivateKeyLength",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "PrivateKeyLength",
          "container": "XTR_DH",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.h",
          "lines": "30-30",
          "snippet": "unsigned int PrivateKeyLength() const {return m_q.ByteCount();}",
          "includes": [
            "#include \"xtr.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xtr.h\"\n\nXTR_DH {\n  unsigned int PrivateKeyLength() const {return m_q.ByteCount();}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::Zero",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "Zero",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "23-24",
          "snippet": "Element Zero() const\n\t\t{return 0;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element Zero() const\n  \t\t{return 0;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  void XTR_DH::GeneratePrivateKey(RandomNumberGenerator &rng, byte *privateKey) const\n  {\n  \tInteger x(rng, Integer::Zero(), m_q-1);\n  \tx.Encode(privateKey, PrivateKeyLength());\n  }\n}"
  },
  {
    "function_name": "AssignFrom",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "68-75",
    "snippet": "void XTR_DH::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(SubgroupOrder)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(SubgroupGenerator)\n\t\t;\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "SubgroupGenerator"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "SubgroupOrder"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_SET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssignFromHelper",
          "args": [
            "this",
            "source"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFromHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "235-238",
          "snippet": "AssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nAssignFromHelperClass<T, T> AssignFromHelper(T *pObject, const NameValuePairs &source)\n{\n\treturn AssignFromHelperClass<T, T>(pObject, source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  void XTR_DH::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Modulus)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(SubgroupOrder)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(SubgroupGenerator)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "GetVoidValue",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "59-66",
    "snippet": "bool XTR_DH::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n{\n\treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(SubgroupOrder)\n\t\tCRYPTOPP_GET_FUNCTION_ENTRY(SubgroupGenerator)\n\t\t;\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "SubgroupGenerator"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "SubgroupOrder"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CRYPTOPP_GET_FUNCTION_ENTRY",
          "args": [
            "Modulus"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueHelper",
          "args": [
            "this",
            "name",
            "valueType",
            "pValue"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/algparam.h",
          "lines": "161-164",
          "snippet": "GetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\nGetValueHelperClass<T, T> GetValueHelper(const T *pObject, const char *name, const std::type_info &valueType, void *pValue, const NameValuePairs *searchFirst=NULL)\n{\n\treturn GetValueHelperClass<T, T>(pObject, name, valueType, pValue, searchFirst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  bool XTR_DH::GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n  {\n  \treturn GetValueHelper(this, name, valueType, pValue).Assignable()\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(Modulus)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(SubgroupOrder)\n  \t\tCRYPTOPP_GET_FUNCTION_ENTRY(SubgroupGenerator)\n  \t\t;\n  }\n}"
  },
  {
    "function_name": "Validate",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "41-57",
    "snippet": "bool XTR_DH::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = true;\n\tpass = pass && m_p > Integer::One() && m_p.IsOdd();\n\tpass = pass && m_q > Integer::One() && m_q.IsOdd();\n\tGFP2Element three = GFP2_ONB<ModularArithmetic>(m_p).ConvertIn(3);\n\tpass = pass && !(m_g.c1.IsNegative() || m_g.c2.IsNegative() || m_g.c1 >= m_p || m_g.c2 >= m_p || m_g == three);\n\tif (level >= 1)\n\t\tpass = pass && ((m_p.Squared()-m_p+1)%m_q).IsZero();\n\tif (level >= 2)\n\t{\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\t\tpass = pass && XTR_Exponentiate(m_g, (m_p.Squared()-m_p+1)/m_q, m_p) != three;\n\t\tpass = pass && XTR_Exponentiate(m_g, m_q, m_p) == three;\n\t}\n\treturn pass;\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XTR_Exponentiate",
          "args": [
            "m_g",
            "m_q",
            "m_p"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "XTR_Exponentiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.cpp",
          "lines": "53-95",
          "snippet": "GFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"xtr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"xtr.h\"\n#include \"pch.h\"\n\nGFP2Element XTR_Exponentiate(const GFP2Element &b, const Integer &e, const Integer &p)\n{\n\tunsigned int bitCount = e.BitCount();\n\tif (bitCount == 0)\n\t\treturn GFP2Element(-3, -3);\n\n\t// find the lowest bit of e that is 1\n\tunsigned int lowest1bit;\n\tfor (lowest1bit=0; e.GetBit(lowest1bit) == 0; lowest1bit++) {}\n\n\tGFP2_ONB<MontgomeryRepresentation> gfp2(p);\n\tGFP2Element c = gfp2.ConvertIn(b);\n\tGFP2Element cp = gfp2.PthPower(c);\n\tGFP2Element S[5] = {gfp2.ConvertIn(3), c, gfp2.SpecialOperation1(c)};\n\n\t// do all exponents bits except the lowest zeros starting from the top\n\tunsigned int i;\n\tfor (i = e.BitCount() - 1; i>lowest1bit; i--)\n\t{\n\t\tif (e.GetBit(i))\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[0]);\n\t\t\tgfp2.Accumulate(S[0], gfp2.SpecialOperation2(S[2], c, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[2] = gfp2.SpecialOperation1(S[2]);\n\t\t\tS[0].swap(S[1]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgfp2.RaiseToPthPower(S[2]);\n\t\t\tgfp2.Accumulate(S[2], gfp2.SpecialOperation2(S[0], cp, S[1]));\n\t\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\t\t\tS[0] = gfp2.SpecialOperation1(S[0]);\n\t\t\tS[2].swap(S[1]);\n\t\t}\n\t}\n\n\t// now do the lowest zeros\n\twhile (i--)\n\t\tS[1] = gfp2.SpecialOperation1(S[1]);\n\n\treturn gfp2.ConvertOut(S[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_p.Squared",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "Squared",
          "container": "PolynomialOverFixedRing",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/polynomi.h",
          "lines": "278-278",
          "snippet": "ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}",
          "includes": [
            "#include <vector>",
            "#include <iosfwd>",
            "#include \"algebra.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <iosfwd>\n#include \"algebra.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nPolynomialOverFixedRing {\n  ThisType Squared() const {return ThisType(B::Squared(ms_fixedRing));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VerifyPrime",
          "args": [
            "rng",
            "m_q",
            "level-2"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyPrime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/nbtheory.cpp",
          "lines": "247-253",
          "snippet": "bool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}",
          "includes": [
            "#include <omp.h>",
            "#include <vector>",
            "#include <math.h>",
            "#include \"algparam.h\"",
            "#include \"modarith.h\"",
            "#include \"nbtheory.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <omp.h>\n#include <vector>\n#include <math.h>\n#include \"algparam.h\"\n#include \"modarith.h\"\n#include \"nbtheory.h\"\n#include \"pch.h\"\n\nbool VerifyPrime(RandomNumberGenerator &rng, const Integer &p, unsigned int level)\n{\n\tbool pass = IsPrime(p) && RabinMillerTest(rng, p, 1);\n\tif (level >= 1)\n\t\tpass = pass && RabinMillerTest(rng, p, 10);\n\treturn pass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_g.c2.IsNegative",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "IsNegative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "201-201",
          "snippet": "bool IsNegative() const {return sign == NEGATIVE;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsNegative() const {return sign == NEGATIVE;}"
        }
      },
      {
        "call_info": {
          "callee": "GFP2_ONB<ModularArithmetic>",
          "args": [
            "3"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "RaiseToPthPower",
          "container": "GFP2_ONB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "173-176",
          "snippet": "void RaiseToPthPower(Element &a) const\n\t{\n\t\ta.c1.swap(a.c2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2_ONB {\n  void RaiseToPthPower(Element &a) const\n  \t{\n  \t\ta.c1.swap(a.c2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_q.IsOdd",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "IsOdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.h",
          "lines": "211-211",
          "snippet": "bool IsOdd() const\t{return GetBit(0) == 1;}",
          "includes": [
            "#include <algorithm>",
            "#include <iosfwd>",
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <iosfwd>\n#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nbool IsOdd() const\t{return GetBit(0) == 1;}"
        }
      },
      {
        "call_info": {
          "callee": "Integer::One",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "One",
          "container": "GF256",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/gf256.h",
          "lines": "44-45",
          "snippet": "Element One() const\n\t\t{return 1;}",
          "includes": [
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cryptlib.h\"\n\nGF256 {\n  Element One() const\n  \t\t{return 1;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  bool XTR_DH::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = true;\n  \tpass = pass && m_p > Integer::One() && m_p.IsOdd();\n  \tpass = pass && m_q > Integer::One() && m_q.IsOdd();\n  \tGFP2Element three = GFP2_ONB<ModularArithmetic>(m_p).ConvertIn(3);\n  \tpass = pass && !(m_g.c1.IsNegative() || m_g.c2.IsNegative() || m_g.c1 >= m_p || m_g.c2 >= m_p || m_g == three);\n  \tif (level >= 1)\n  \t\tpass = pass && ((m_p.Squared()-m_p+1)%m_q).IsZero();\n  \tif (level >= 2)\n  \t{\n  \t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n  \t\tpass = pass && XTR_Exponentiate(m_g, (m_p.Squared()-m_p+1)/m_q, m_p) != three;\n  \t\tpass = pass && XTR_Exponentiate(m_g, m_q, m_p) == three;\n  \t}\n  \treturn pass;\n  }\n}"
  },
  {
    "function_name": "DEREncode",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "31-39",
    "snippet": "void XTR_DH::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_g.c1.DEREncode(seq);\n\tm_g.c2.DEREncode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_g.c2.DEREncode",
          "args": [
            "seq"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "DEREncode",
          "container": "XTR_DH",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
          "lines": "31-39",
          "snippet": "void XTR_DH::DEREncode(BufferedTransformation &bt) const\n{\n\tDERSequenceEncoder seq(bt);\n\tm_p.DEREncode(seq);\n\tm_q.DEREncode(seq);\n\tm_g.c1.DEREncode(seq);\n\tm_g.c2.DEREncode(seq);\n\tseq.MessageEnd();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  void XTR_DH::DEREncode(BufferedTransformation &bt) const\n  {\n  \tDERSequenceEncoder seq(bt);\n  \tm_p.DEREncode(seq);\n  \tm_q.DEREncode(seq);\n  \tm_g.c1.DEREncode(seq);\n  \tm_g.c2.DEREncode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "XTR_DH",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "21-29",
    "snippet": "XTR_DH::XTR_DH(BufferedTransformation &bt)\n{\n\tBERSequenceDecoder seq(bt);\n\tm_p.BERDecode(seq);\n\tm_q.BERDecode(seq);\n\tm_g.c1.BERDecode(seq);\n\tm_g.c2.BERDecode(seq);\n\tseq.MessageEnd();\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq.MessageEnd",
          "args": [],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_g.c2.BERDecode",
          "args": [
            "seq"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "BERDecode",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3146-3153",
          "snippet": "void Integer::BERDecode(BufferedTransformation &bt)\n{\n\tBERGeneralDecoder dec(bt, INTEGER);\n\tif (!dec.IsDefiniteLength() || dec.MaxRetrievable() < dec.RemainingLength())\n\t\tBERDecodeError();\n\tDecode(dec, (size_t)dec.RemainingLength(), SIGNED);\n\tdec.MessageEnd();\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  void Integer::BERDecode(BufferedTransformation &bt)\n  {\n  \tBERGeneralDecoder dec(bt, INTEGER);\n  \tif (!dec.IsDefiniteLength() || dec.MaxRetrievable() < dec.RemainingLength())\n  \t\tBERDecodeError();\n  \tDecode(dec, (size_t)dec.RemainingLength(), SIGNED);\n  \tdec.MessageEnd();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  XTR_DH::XTR_DH(BufferedTransformation &bt)\n  {\n  \tBERSequenceDecoder seq(bt);\n  \tm_p.BERDecode(seq);\n  \tm_q.BERDecode(seq);\n  \tm_g.c1.BERDecode(seq);\n  \tm_g.c2.BERDecode(seq);\n  \tseq.MessageEnd();\n  }\n}"
  },
  {
    "function_name": "XTR_DH",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "16-19",
    "snippet": "XTR_DH::XTR_DH(RandomNumberGenerator &rng, unsigned int pbits, unsigned int qbits)\n{\n\tXTR_FindPrimesAndGenerator(rng, m_p, m_q, m_g, pbits, qbits);\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XTR_FindPrimesAndGenerator",
          "args": [
            "rng",
            "m_p",
            "m_q",
            "m_g",
            "pbits",
            "qbits"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "XTR_FindPrimesAndGenerator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.cpp",
          "lines": "16-51",
          "snippet": "void XTR_FindPrimesAndGenerator(RandomNumberGenerator &rng, Integer &p, Integer &q, GFP2Element &g, unsigned int pbits, unsigned int qbits)\n{\n\tassert(qbits > 9);\t// no primes exist for pbits = 10, qbits = 9\n\tassert(pbits > qbits);\n\n\tconst Integer minQ = Integer::Power2(qbits - 1);\n\tconst Integer maxQ = Integer::Power2(qbits) - 1;\n\tconst Integer minP = Integer::Power2(pbits - 1);\n\tconst Integer maxP = Integer::Power2(pbits) - 1;\n\n\tInteger r1, r2;\n\tdo\n\t{\n\t\tbool qFound = q.Randomize(rng, minQ, maxQ, Integer::PRIME, 7, 12);\n\t\tassert(qFound);\n\t\tbool solutionsExist = SolveModularQuadraticEquation(r1, r2, 1, -1, 1, q);\n\t\tassert(solutionsExist);\n\t} while (!p.Randomize(rng, minP, maxP, Integer::PRIME, CRT(rng.GenerateBit()?r1:r2, q, 2, 3, EuclideanMultiplicativeInverse(p, 3)), 3*q));\n\tassert(((p.Squared() - p + 1) % q).IsZero());\n\n\tGFP2_ONB<ModularArithmetic> gfp2(p);\n\tGFP2Element three = gfp2.ConvertIn(3), t;\n\n\twhile (true)\n\t{\n\t\tg.c1.Randomize(rng, Integer::Zero(), p-1);\n\t\tg.c2.Randomize(rng, Integer::Zero(), p-1);\n\t\tt = XTR_Exponentiate(g, p+1, p);\n\t\tif (t.c1 == t.c2)\n\t\t\tcontinue;\n\t\tg = XTR_Exponentiate(g, (p.Squared()-p+1)/q, p);\n\t\tif (g != three)\n\t\t\tbreak;\n\t}\n\tassert(XTR_Exponentiate(g, q, p) == three);\n}",
          "includes": [
            "#include \"algebra.cpp\"",
            "#include \"nbtheory.h\"",
            "#include \"xtr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"algebra.cpp\"\n#include \"nbtheory.h\"\n#include \"xtr.h\"\n#include \"pch.h\"\n\nvoid XTR_FindPrimesAndGenerator(RandomNumberGenerator &rng, Integer &p, Integer &q, GFP2Element &g, unsigned int pbits, unsigned int qbits)\n{\n\tassert(qbits > 9);\t// no primes exist for pbits = 10, qbits = 9\n\tassert(pbits > qbits);\n\n\tconst Integer minQ = Integer::Power2(qbits - 1);\n\tconst Integer maxQ = Integer::Power2(qbits) - 1;\n\tconst Integer minP = Integer::Power2(pbits - 1);\n\tconst Integer maxP = Integer::Power2(pbits) - 1;\n\n\tInteger r1, r2;\n\tdo\n\t{\n\t\tbool qFound = q.Randomize(rng, minQ, maxQ, Integer::PRIME, 7, 12);\n\t\tassert(qFound);\n\t\tbool solutionsExist = SolveModularQuadraticEquation(r1, r2, 1, -1, 1, q);\n\t\tassert(solutionsExist);\n\t} while (!p.Randomize(rng, minP, maxP, Integer::PRIME, CRT(rng.GenerateBit()?r1:r2, q, 2, 3, EuclideanMultiplicativeInverse(p, 3)), 3*q));\n\tassert(((p.Squared() - p + 1) % q).IsZero());\n\n\tGFP2_ONB<ModularArithmetic> gfp2(p);\n\tGFP2Element three = gfp2.ConvertIn(3), t;\n\n\twhile (true)\n\t{\n\t\tg.c1.Randomize(rng, Integer::Zero(), p-1);\n\t\tg.c2.Randomize(rng, Integer::Zero(), p-1);\n\t\tt = XTR_Exponentiate(g, p+1, p);\n\t\tif (t.c1 == t.c2)\n\t\t\tcontinue;\n\t\tg = XTR_Exponentiate(g, (p.Squared()-p+1)/q, p);\n\t\tif (g != three)\n\t\t\tbreak;\n\t}\n\tassert(XTR_Exponentiate(g, q, p) == three);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  XTR_DH::XTR_DH(RandomNumberGenerator &rng, unsigned int pbits, unsigned int qbits)\n  {\n  \tXTR_FindPrimesAndGenerator(rng, m_p, m_q, m_g, pbits, qbits);\n  }\n}"
  },
  {
    "function_name": "XTR_DH",
    "container": "XTR_DH",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtrcrypt.cpp",
    "lines": "11-14",
    "snippet": "XTR_DH::XTR_DH(const Integer &p, const Integer &q, const GFP2Element &g)\n\t: m_p(p), m_q(q), m_g(g)\n{\n}",
    "includes": [
      "#include \"argnames.h\"",
      "#include \"asn.h\"",
      "#include \"nbtheory.h\"",
      "#include \"xtrcrypt.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"argnames.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"xtrcrypt.h\"\n#include \"pch.h\"\n\nXTR_DH {\n  XTR_DH::XTR_DH(const Integer &p, const Integer &q, const GFP2Element &g)\n  \t: m_p(p), m_q(q), m_g(g)\n  {\n  }\n}"
  }
]