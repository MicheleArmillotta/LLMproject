[
  {
    "function_name": "RunTestDataFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "748-757",
    "snippet": "bool RunTestDataFile(const char *filename, const NameValuePairs &overrideParameters, bool thorough)\n{\n\ts_thorough = thorough;\n\tunsigned int totalTests = 0, failedTests = 0;\n\tTestDataFile(filename, overrideParameters, totalTests, failedTests);\n\tcout << dec << \"\\nTests complete. Total tests = \" << totalTests << \". Failed tests = \" << failedTests << \".\\n\";\n\tif (failedTests != 0)\n\t\tcout << \"SOME TESTS FAILED!\\n\";\n\treturn failedTests == 0;\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool s_thorough;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TestDataFile",
          "args": [
            "filename",
            "overrideParameters",
            "totalTests",
            "failedTests"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "TestDataFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "670-746",
          "snippet": "void TestDataFile(const std::string &filename, const NameValuePairs &overrideParameters, unsigned int &totalTests, unsigned int &failedTests)\n{\n\tstd::ifstream file(filename.c_str());\n\tif (!file.good())\n\t\tthrow Exception(Exception::OTHER_ERROR, \"Can not open file \" + filename + \" for reading\");\n\tTestData v;\n\ts_currentTestData = &v;\n\tstd::string name, value, lastAlgName;\n\n\twhile (file)\n\t{\n\t\twhile (file.peek() == '#')\n\t\t\tfile.ignore(INT_MAX, '\\n');\n\n\t\tif (file.peek() == '\\n' || file.peek() == '\\r')\n\t\t\tv.clear();\n\n\t\tif (!GetField(file, name, value))\n\t\t\tbreak;\n\t\tv[name] = value;\n\n\t\tif (name == \"Test\" && (s_thorough || v[\"SlowTest\"] != \"1\"))\n\t\t{\n\t\t\tbool failed = true;\n\t\t\tstd::string algType = GetRequiredDatum(v, \"AlgorithmType\");\n\n\t\t\tif (lastAlgName != GetRequiredDatum(v, \"Name\"))\n\t\t\t{\n\t\t\t\tlastAlgName = GetRequiredDatum(v, \"Name\");\n\t\t\t\tcout << \"\\nTesting \" << algType.c_str() << \" algorithm \" << lastAlgName.c_str() << \".\\n\";\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (algType == \"Signature\")\n\t\t\t\t\tTestSignatureScheme(v);\n\t\t\t\telse if (algType == \"SymmetricCipher\")\n\t\t\t\t\tTestSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AuthenticatedSymmetricCipher\")\n\t\t\t\t\tTestAuthenticatedSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AsymmetricCipher\")\n\t\t\t\t\tTestAsymmetricCipher(v);\n\t\t\t\telse if (algType == \"MessageDigest\")\n\t\t\t\t\tTestDigestOrMAC(v, true);\n\t\t\t\telse if (algType == \"MAC\")\n\t\t\t\t\tTestDigestOrMAC(v, false);\n\t\t\t\telse if (algType == \"FileList\")\n\t\t\t\t\tTestDataFile(GetRequiredDatum(v, \"Test\"), g_nullNameValuePairs, totalTests, failedTests);\n\t\t\t\telse\n\t\t\t\t\tSignalTestError();\n\t\t\t\tfailed = false;\n\t\t\t}\n\t\t\tcatch (TestFailure &)\n\t\t\t{\n\t\t\t\tcout << \"\\nTest failed.\\n\";\n\t\t\t}\n\t\t\tcatch (CryptoPP::Exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nCryptoPP::Exception caught: \" << e.what() << endl;\n\t\t\t}\n\t\t\tcatch (std::exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nstd::exception caught: \" << e.what() << endl;\n\t\t\t}\n\n\t\t\tif (failed)\n\t\t\t{\n\t\t\t\tcout << \"Skipping to next test.\\n\";\n\t\t\t\tfailedTests++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout << \".\" << flush;\n\n\t\t\ttotalTests++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool s_thorough;",
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic bool s_thorough;\nstatic const TestData *s_currentTestData = NULL;\n\nvoid TestDataFile(const std::string &filename, const NameValuePairs &overrideParameters, unsigned int &totalTests, unsigned int &failedTests)\n{\n\tstd::ifstream file(filename.c_str());\n\tif (!file.good())\n\t\tthrow Exception(Exception::OTHER_ERROR, \"Can not open file \" + filename + \" for reading\");\n\tTestData v;\n\ts_currentTestData = &v;\n\tstd::string name, value, lastAlgName;\n\n\twhile (file)\n\t{\n\t\twhile (file.peek() == '#')\n\t\t\tfile.ignore(INT_MAX, '\\n');\n\n\t\tif (file.peek() == '\\n' || file.peek() == '\\r')\n\t\t\tv.clear();\n\n\t\tif (!GetField(file, name, value))\n\t\t\tbreak;\n\t\tv[name] = value;\n\n\t\tif (name == \"Test\" && (s_thorough || v[\"SlowTest\"] != \"1\"))\n\t\t{\n\t\t\tbool failed = true;\n\t\t\tstd::string algType = GetRequiredDatum(v, \"AlgorithmType\");\n\n\t\t\tif (lastAlgName != GetRequiredDatum(v, \"Name\"))\n\t\t\t{\n\t\t\t\tlastAlgName = GetRequiredDatum(v, \"Name\");\n\t\t\t\tcout << \"\\nTesting \" << algType.c_str() << \" algorithm \" << lastAlgName.c_str() << \".\\n\";\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (algType == \"Signature\")\n\t\t\t\t\tTestSignatureScheme(v);\n\t\t\t\telse if (algType == \"SymmetricCipher\")\n\t\t\t\t\tTestSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AuthenticatedSymmetricCipher\")\n\t\t\t\t\tTestAuthenticatedSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AsymmetricCipher\")\n\t\t\t\t\tTestAsymmetricCipher(v);\n\t\t\t\telse if (algType == \"MessageDigest\")\n\t\t\t\t\tTestDigestOrMAC(v, true);\n\t\t\t\telse if (algType == \"MAC\")\n\t\t\t\t\tTestDigestOrMAC(v, false);\n\t\t\t\telse if (algType == \"FileList\")\n\t\t\t\t\tTestDataFile(GetRequiredDatum(v, \"Test\"), g_nullNameValuePairs, totalTests, failedTests);\n\t\t\t\telse\n\t\t\t\t\tSignalTestError();\n\t\t\t\tfailed = false;\n\t\t\t}\n\t\t\tcatch (TestFailure &)\n\t\t\t{\n\t\t\t\tcout << \"\\nTest failed.\\n\";\n\t\t\t}\n\t\t\tcatch (CryptoPP::Exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nCryptoPP::Exception caught: \" << e.what() << endl;\n\t\t\t}\n\t\t\tcatch (std::exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nstd::exception caught: \" << e.what() << endl;\n\t\t\t}\n\n\t\t\tif (failed)\n\t\t\t{\n\t\t\t\tcout << \"Skipping to next test.\\n\";\n\t\t\t\tfailedTests++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout << \".\" << flush;\n\n\t\t\ttotalTests++;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic bool s_thorough;\n\nbool RunTestDataFile(const char *filename, const NameValuePairs &overrideParameters, bool thorough)\n{\n\ts_thorough = thorough;\n\tunsigned int totalTests = 0, failedTests = 0;\n\tTestDataFile(filename, overrideParameters, totalTests, failedTests);\n\tcout << dec << \"\\nTests complete. Total tests = \" << totalTests << \". Failed tests = \" << failedTests << \".\\n\";\n\tif (failedTests != 0)\n\t\tcout << \"SOME TESTS FAILED!\\n\";\n\treturn failedTests == 0;\n}"
  },
  {
    "function_name": "TestDataFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "670-746",
    "snippet": "void TestDataFile(const std::string &filename, const NameValuePairs &overrideParameters, unsigned int &totalTests, unsigned int &failedTests)\n{\n\tstd::ifstream file(filename.c_str());\n\tif (!file.good())\n\t\tthrow Exception(Exception::OTHER_ERROR, \"Can not open file \" + filename + \" for reading\");\n\tTestData v;\n\ts_currentTestData = &v;\n\tstd::string name, value, lastAlgName;\n\n\twhile (file)\n\t{\n\t\twhile (file.peek() == '#')\n\t\t\tfile.ignore(INT_MAX, '\\n');\n\n\t\tif (file.peek() == '\\n' || file.peek() == '\\r')\n\t\t\tv.clear();\n\n\t\tif (!GetField(file, name, value))\n\t\t\tbreak;\n\t\tv[name] = value;\n\n\t\tif (name == \"Test\" && (s_thorough || v[\"SlowTest\"] != \"1\"))\n\t\t{\n\t\t\tbool failed = true;\n\t\t\tstd::string algType = GetRequiredDatum(v, \"AlgorithmType\");\n\n\t\t\tif (lastAlgName != GetRequiredDatum(v, \"Name\"))\n\t\t\t{\n\t\t\t\tlastAlgName = GetRequiredDatum(v, \"Name\");\n\t\t\t\tcout << \"\\nTesting \" << algType.c_str() << \" algorithm \" << lastAlgName.c_str() << \".\\n\";\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (algType == \"Signature\")\n\t\t\t\t\tTestSignatureScheme(v);\n\t\t\t\telse if (algType == \"SymmetricCipher\")\n\t\t\t\t\tTestSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AuthenticatedSymmetricCipher\")\n\t\t\t\t\tTestAuthenticatedSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AsymmetricCipher\")\n\t\t\t\t\tTestAsymmetricCipher(v);\n\t\t\t\telse if (algType == \"MessageDigest\")\n\t\t\t\t\tTestDigestOrMAC(v, true);\n\t\t\t\telse if (algType == \"MAC\")\n\t\t\t\t\tTestDigestOrMAC(v, false);\n\t\t\t\telse if (algType == \"FileList\")\n\t\t\t\t\tTestDataFile(GetRequiredDatum(v, \"Test\"), g_nullNameValuePairs, totalTests, failedTests);\n\t\t\t\telse\n\t\t\t\t\tSignalTestError();\n\t\t\t\tfailed = false;\n\t\t\t}\n\t\t\tcatch (TestFailure &)\n\t\t\t{\n\t\t\t\tcout << \"\\nTest failed.\\n\";\n\t\t\t}\n\t\t\tcatch (CryptoPP::Exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nCryptoPP::Exception caught: \" << e.what() << endl;\n\t\t\t}\n\t\t\tcatch (std::exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nstd::exception caught: \" << e.what() << endl;\n\t\t\t}\n\n\t\t\tif (failed)\n\t\t\t{\n\t\t\t\tcout << \"Skipping to next test.\\n\";\n\t\t\t\tfailedTests++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout << \".\" << flush;\n\n\t\t\ttotalTests++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool s_thorough;",
      "static const TestData *s_currentTestData = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignalTestError",
          "args": [],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "41-45",
          "snippet": "static void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestDataFile",
          "args": [
            "GetRequiredDatum(v, \"Test\")",
            "g_nullNameValuePairs",
            "totalTests",
            "failedTests"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "TestDataFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "670-746",
          "snippet": "void TestDataFile(const std::string &filename, const NameValuePairs &overrideParameters, unsigned int &totalTests, unsigned int &failedTests)\n{\n\tstd::ifstream file(filename.c_str());\n\tif (!file.good())\n\t\tthrow Exception(Exception::OTHER_ERROR, \"Can not open file \" + filename + \" for reading\");\n\tTestData v;\n\ts_currentTestData = &v;\n\tstd::string name, value, lastAlgName;\n\n\twhile (file)\n\t{\n\t\twhile (file.peek() == '#')\n\t\t\tfile.ignore(INT_MAX, '\\n');\n\n\t\tif (file.peek() == '\\n' || file.peek() == '\\r')\n\t\t\tv.clear();\n\n\t\tif (!GetField(file, name, value))\n\t\t\tbreak;\n\t\tv[name] = value;\n\n\t\tif (name == \"Test\" && (s_thorough || v[\"SlowTest\"] != \"1\"))\n\t\t{\n\t\t\tbool failed = true;\n\t\t\tstd::string algType = GetRequiredDatum(v, \"AlgorithmType\");\n\n\t\t\tif (lastAlgName != GetRequiredDatum(v, \"Name\"))\n\t\t\t{\n\t\t\t\tlastAlgName = GetRequiredDatum(v, \"Name\");\n\t\t\t\tcout << \"\\nTesting \" << algType.c_str() << \" algorithm \" << lastAlgName.c_str() << \".\\n\";\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (algType == \"Signature\")\n\t\t\t\t\tTestSignatureScheme(v);\n\t\t\t\telse if (algType == \"SymmetricCipher\")\n\t\t\t\t\tTestSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AuthenticatedSymmetricCipher\")\n\t\t\t\t\tTestAuthenticatedSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AsymmetricCipher\")\n\t\t\t\t\tTestAsymmetricCipher(v);\n\t\t\t\telse if (algType == \"MessageDigest\")\n\t\t\t\t\tTestDigestOrMAC(v, true);\n\t\t\t\telse if (algType == \"MAC\")\n\t\t\t\t\tTestDigestOrMAC(v, false);\n\t\t\t\telse if (algType == \"FileList\")\n\t\t\t\t\tTestDataFile(GetRequiredDatum(v, \"Test\"), g_nullNameValuePairs, totalTests, failedTests);\n\t\t\t\telse\n\t\t\t\t\tSignalTestError();\n\t\t\t\tfailed = false;\n\t\t\t}\n\t\t\tcatch (TestFailure &)\n\t\t\t{\n\t\t\t\tcout << \"\\nTest failed.\\n\";\n\t\t\t}\n\t\t\tcatch (CryptoPP::Exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nCryptoPP::Exception caught: \" << e.what() << endl;\n\t\t\t}\n\t\t\tcatch (std::exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nstd::exception caught: \" << e.what() << endl;\n\t\t\t}\n\n\t\t\tif (failed)\n\t\t\t{\n\t\t\t\tcout << \"Skipping to next test.\\n\";\n\t\t\t\tfailedTests++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout << \".\" << flush;\n\n\t\t\ttotalTests++;\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Test\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TestDigestOrMAC",
          "args": [
            "v",
            "false"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "TestDigestOrMAC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "539-581",
          "snippet": "void TestDigestOrMAC(TestData &v, bool testDigest)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\tconst char *digestName = testDigest ? \"Digest\" : \"MAC\";\n\n\tmember_ptr<MessageAuthenticationCode> mac;\n\tmember_ptr<HashTransformation> hash;\n\tHashTransformation *pHash = NULL;\n\n\tTestDataNameValuePairs pairs(v);\n\n\tif (testDigest)\n\t{\n\t\thash.reset(ObjectFactoryRegistry<HashTransformation>::Registry().CreateObject(name.c_str()));\n\t\tpHash = hash.get();\n\t}\n\telse\n\t{\n\t\tmac.reset(ObjectFactoryRegistry<MessageAuthenticationCode>::Registry().CreateObject(name.c_str()));\n\t\tpHash = mac.get();\n\t\tstd::string key = GetDecodedDatum(v, \"Key\");\n\t\tmac->SetKey((const byte *)key.c_str(), key.size(), pairs);\n\t}\n\n\tif (test == \"Verify\" || test == \"VerifyTruncated\" || test == \"NotVerify\")\n\t{\n\t\tint digestSize = -1;\n\t\tif (test == \"VerifyTruncated\")\n\t\t\tpairs.GetIntValue(Name::DigestSize(), digestSize);\n\t\tHashVerificationFilter verifierFilter(*pHash, NULL, HashVerificationFilter::HASH_AT_BEGIN, digestSize);\n\t\tPutDecodedDatumInto(v, digestName, verifierFilter);\n\t\tPutDecodedDatumInto(v, \"Message\", verifierFilter);\n\t\tverifierFilter.MessageEnd();\n\t\tif (verifierFilter.GetLastResult() == (test == \"NotVerify\"))\n\t\t\tSignalTestFailure();\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestDigestOrMAC(TestData &v, bool testDigest)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\tconst char *digestName = testDigest ? \"Digest\" : \"MAC\";\n\n\tmember_ptr<MessageAuthenticationCode> mac;\n\tmember_ptr<HashTransformation> hash;\n\tHashTransformation *pHash = NULL;\n\n\tTestDataNameValuePairs pairs(v);\n\n\tif (testDigest)\n\t{\n\t\thash.reset(ObjectFactoryRegistry<HashTransformation>::Registry().CreateObject(name.c_str()));\n\t\tpHash = hash.get();\n\t}\n\telse\n\t{\n\t\tmac.reset(ObjectFactoryRegistry<MessageAuthenticationCode>::Registry().CreateObject(name.c_str()));\n\t\tpHash = mac.get();\n\t\tstd::string key = GetDecodedDatum(v, \"Key\");\n\t\tmac->SetKey((const byte *)key.c_str(), key.size(), pairs);\n\t}\n\n\tif (test == \"Verify\" || test == \"VerifyTruncated\" || test == \"NotVerify\")\n\t{\n\t\tint digestSize = -1;\n\t\tif (test == \"VerifyTruncated\")\n\t\t\tpairs.GetIntValue(Name::DigestSize(), digestSize);\n\t\tHashVerificationFilter verifierFilter(*pHash, NULL, HashVerificationFilter::HASH_AT_BEGIN, digestSize);\n\t\tPutDecodedDatumInto(v, digestName, verifierFilter);\n\t\tPutDecodedDatumInto(v, \"Message\", verifierFilter);\n\t\tverifierFilter.MessageEnd();\n\t\tif (verifierFilter.GetLastResult() == (test == \"NotVerify\"))\n\t\t\tSignalTestFailure();\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestAsymmetricCipher",
          "args": [
            "v"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "TestAsymmetricCipher",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "280-318",
          "snippet": "void TestAsymmetricCipher(TestData &v)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::auto_ptr<PK_Encryptor> encryptor(ObjectFactoryRegistry<PK_Encryptor>::Registry().CreateObject(name.c_str()));\n\tstd::auto_ptr<PK_Decryptor> decryptor(ObjectFactoryRegistry<PK_Decryptor>::Registry().CreateObject(name.c_str()));\n\n\tstd::string keyFormat = GetRequiredDatum(v, \"KeyFormat\");\n\n\tif (keyFormat == \"DER\")\n\t{\n\t\tdecryptor->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref());\n\t\tencryptor->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref());\n\t}\n\telse if (keyFormat == \"Component\")\n\t{\n\t\tTestDataNameValuePairs pairs(v);\n\t\tdecryptor->AccessMaterial().AssignFrom(pairs);\n\t\tencryptor->AccessMaterial().AssignFrom(pairs);\n\t}\n\n\tif (test == \"DecryptMatch\")\n\t{\n\t\tstd::string decrypted, expected = GetDecodedDatum(v, \"Plaintext\");\n\t\tStringSource ss(GetDecodedDatum(v, \"Ciphertext\"), true, new PK_DecryptorFilter(GlobalRNG(), *decryptor, new StringSink(decrypted)));\n\t\tif (decrypted != expected)\n\t\t\tSignalTestFailure();\n\t}\n\telse if (test == \"KeyPairValidAndConsistent\")\n\t{\n\t\tTestKeyPairValidAndConsistent(encryptor->AccessMaterial(), decryptor->GetMaterial());\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestAsymmetricCipher(TestData &v)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::auto_ptr<PK_Encryptor> encryptor(ObjectFactoryRegistry<PK_Encryptor>::Registry().CreateObject(name.c_str()));\n\tstd::auto_ptr<PK_Decryptor> decryptor(ObjectFactoryRegistry<PK_Decryptor>::Registry().CreateObject(name.c_str()));\n\n\tstd::string keyFormat = GetRequiredDatum(v, \"KeyFormat\");\n\n\tif (keyFormat == \"DER\")\n\t{\n\t\tdecryptor->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref());\n\t\tencryptor->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref());\n\t}\n\telse if (keyFormat == \"Component\")\n\t{\n\t\tTestDataNameValuePairs pairs(v);\n\t\tdecryptor->AccessMaterial().AssignFrom(pairs);\n\t\tencryptor->AccessMaterial().AssignFrom(pairs);\n\t}\n\n\tif (test == \"DecryptMatch\")\n\t{\n\t\tstd::string decrypted, expected = GetDecodedDatum(v, \"Plaintext\");\n\t\tStringSource ss(GetDecodedDatum(v, \"Ciphertext\"), true, new PK_DecryptorFilter(GlobalRNG(), *decryptor, new StringSink(decrypted)));\n\t\tif (decrypted != expected)\n\t\t\tSignalTestFailure();\n\t}\n\telse if (test == \"KeyPairValidAndConsistent\")\n\t{\n\t\tTestKeyPairValidAndConsistent(encryptor->AccessMaterial(), decryptor->GetMaterial());\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestAuthenticatedSymmetricCipher",
          "args": [
            "v",
            "overrideParameters"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "TestAuthenticatedSymmetricCipher",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "453-537",
          "snippet": "void TestAuthenticatedSymmetricCipher(TestData &v, const NameValuePairs &overrideParameters)\n{\n\tstd::string type = GetRequiredDatum(v, \"AlgorithmType\");\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\tstd::string key = GetDecodedDatum(v, \"Key\");\n\n\tstd::string plaintext = GetOptionalDecodedDatum(v, \"Plaintext\");\n\tstd::string ciphertext = GetOptionalDecodedDatum(v, \"Ciphertext\");\n\tstd::string header = GetOptionalDecodedDatum(v, \"Header\");\n\tstd::string footer = GetOptionalDecodedDatum(v, \"Footer\");\n\tstd::string mac = GetOptionalDecodedDatum(v, \"MAC\");\n\n\tTestDataNameValuePairs testDataPairs(v);\n\tCombinedNameValuePairs pairs(overrideParameters, testDataPairs);\n\n\tif (test == \"Encrypt\" || test == \"EncryptXorDigest\" || test == \"NotVerify\")\n\t{\n\t\tmember_ptr<AuthenticatedSymmetricCipher> asc1, asc2;\n\t\tasc1.reset(ObjectFactoryRegistry<AuthenticatedSymmetricCipher, ENCRYPTION>::Registry().CreateObject(name.c_str()));\n\t\tasc2.reset(ObjectFactoryRegistry<AuthenticatedSymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str()));\n\t\tasc1->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\tasc2->SetKey((const byte *)key.data(), key.size(), pairs);\n\n\t\tstd::string encrypted, decrypted;\n\t\tAuthenticatedEncryptionFilter ef(*asc1, new StringSink(encrypted));\n\t\tbool macAtBegin = !mac.empty() && !GlobalRNG().GenerateBit();\t// test both ways randomly\n\t\tAuthenticatedDecryptionFilter df(*asc2, new StringSink(decrypted), macAtBegin ? AuthenticatedDecryptionFilter::MAC_AT_BEGIN : 0);\n\n\t\tif (asc1->NeedsPrespecifiedDataLengths())\n\t\t{\n\t\t\tasc1->SpecifyDataLengths(header.size(), plaintext.size(), footer.size());\n\t\t\tasc2->SpecifyDataLengths(header.size(), plaintext.size(), footer.size());\n\t\t}\n\n\t\tStringStore sh(header), sp(plaintext), sc(ciphertext), sf(footer), sm(mac);\n\n\t\tif (macAtBegin)\n\t\t\tRandomizedTransfer(sm, df, true);\n\t\tsh.CopyTo(df, LWORD_MAX, AAD_CHANNEL);\n\t\tRandomizedTransfer(sc, df, true);\n\t\tsf.CopyTo(df, LWORD_MAX, AAD_CHANNEL);\n\t\tif (!macAtBegin)\n\t\t\tRandomizedTransfer(sm, df, true);\n\t\tdf.MessageEnd();\n\n\t\tRandomizedTransfer(sh, ef, true, AAD_CHANNEL);\n\t\tRandomizedTransfer(sp, ef, true);\n\t\tRandomizedTransfer(sf, ef, true, AAD_CHANNEL);\n\t\tef.MessageEnd();\n\n\t\tif (test == \"Encrypt\" && encrypted != ciphertext+mac)\n\t\t{\n\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(2048); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tif (test == \"Encrypt\" && decrypted != plaintext)\n\t\t{\n\t\t\tstd::cout << \"incorrectly decrypted: \";\n\t\t\tStringSource xx(decrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\n\t\tif (ciphertext.size()+mac.size()-plaintext.size() != asc1->DigestSize())\n\t\t{\n\t\t\tstd::cout << \"bad MAC size\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tif (df.GetLastResult() != (test == \"Encrypt\"))\n\t\t{\n\t\t\tstd::cout << \"MAC incorrectly verified\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"unexpected test name\\n\";\n\t\tSignalTestError();\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestAuthenticatedSymmetricCipher(TestData &v, const NameValuePairs &overrideParameters)\n{\n\tstd::string type = GetRequiredDatum(v, \"AlgorithmType\");\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\tstd::string key = GetDecodedDatum(v, \"Key\");\n\n\tstd::string plaintext = GetOptionalDecodedDatum(v, \"Plaintext\");\n\tstd::string ciphertext = GetOptionalDecodedDatum(v, \"Ciphertext\");\n\tstd::string header = GetOptionalDecodedDatum(v, \"Header\");\n\tstd::string footer = GetOptionalDecodedDatum(v, \"Footer\");\n\tstd::string mac = GetOptionalDecodedDatum(v, \"MAC\");\n\n\tTestDataNameValuePairs testDataPairs(v);\n\tCombinedNameValuePairs pairs(overrideParameters, testDataPairs);\n\n\tif (test == \"Encrypt\" || test == \"EncryptXorDigest\" || test == \"NotVerify\")\n\t{\n\t\tmember_ptr<AuthenticatedSymmetricCipher> asc1, asc2;\n\t\tasc1.reset(ObjectFactoryRegistry<AuthenticatedSymmetricCipher, ENCRYPTION>::Registry().CreateObject(name.c_str()));\n\t\tasc2.reset(ObjectFactoryRegistry<AuthenticatedSymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str()));\n\t\tasc1->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\tasc2->SetKey((const byte *)key.data(), key.size(), pairs);\n\n\t\tstd::string encrypted, decrypted;\n\t\tAuthenticatedEncryptionFilter ef(*asc1, new StringSink(encrypted));\n\t\tbool macAtBegin = !mac.empty() && !GlobalRNG().GenerateBit();\t// test both ways randomly\n\t\tAuthenticatedDecryptionFilter df(*asc2, new StringSink(decrypted), macAtBegin ? AuthenticatedDecryptionFilter::MAC_AT_BEGIN : 0);\n\n\t\tif (asc1->NeedsPrespecifiedDataLengths())\n\t\t{\n\t\t\tasc1->SpecifyDataLengths(header.size(), plaintext.size(), footer.size());\n\t\t\tasc2->SpecifyDataLengths(header.size(), plaintext.size(), footer.size());\n\t\t}\n\n\t\tStringStore sh(header), sp(plaintext), sc(ciphertext), sf(footer), sm(mac);\n\n\t\tif (macAtBegin)\n\t\t\tRandomizedTransfer(sm, df, true);\n\t\tsh.CopyTo(df, LWORD_MAX, AAD_CHANNEL);\n\t\tRandomizedTransfer(sc, df, true);\n\t\tsf.CopyTo(df, LWORD_MAX, AAD_CHANNEL);\n\t\tif (!macAtBegin)\n\t\t\tRandomizedTransfer(sm, df, true);\n\t\tdf.MessageEnd();\n\n\t\tRandomizedTransfer(sh, ef, true, AAD_CHANNEL);\n\t\tRandomizedTransfer(sp, ef, true);\n\t\tRandomizedTransfer(sf, ef, true, AAD_CHANNEL);\n\t\tef.MessageEnd();\n\n\t\tif (test == \"Encrypt\" && encrypted != ciphertext+mac)\n\t\t{\n\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(2048); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tif (test == \"Encrypt\" && decrypted != plaintext)\n\t\t{\n\t\t\tstd::cout << \"incorrectly decrypted: \";\n\t\t\tStringSource xx(decrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\n\t\tif (ciphertext.size()+mac.size()-plaintext.size() != asc1->DigestSize())\n\t\t{\n\t\t\tstd::cout << \"bad MAC size\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tif (df.GetLastResult() != (test == \"Encrypt\"))\n\t\t{\n\t\t\tstd::cout << \"MAC incorrectly verified\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"unexpected test name\\n\";\n\t\tSignalTestError();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestSymmetricCipher",
          "args": [
            "v",
            "overrideParameters"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "TestSymmetricCipher",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "320-451",
          "snippet": "void TestSymmetricCipher(TestData &v, const NameValuePairs &overrideParameters)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::string key = GetDecodedDatum(v, \"Key\");\n\tstd::string plaintext = GetDecodedDatum(v, \"Plaintext\");\n\n\tTestDataNameValuePairs testDataPairs(v);\n\tCombinedNameValuePairs pairs(overrideParameters, testDataPairs);\n\n\tif (test == \"Encrypt\" || test == \"EncryptXorDigest\" || test == \"Resync\" || test == \"EncryptionMCT\" || test == \"DecryptionMCT\")\n\t{\n\t\tstatic member_ptr<SymmetricCipher> encryptor, decryptor;\n\t\tstatic std::string lastName;\n\n\t\tif (name != lastName)\n\t\t{\n\t\t\tencryptor.reset(ObjectFactoryRegistry<SymmetricCipher, ENCRYPTION>::Registry().CreateObject(name.c_str()));\n\t\t\tdecryptor.reset(ObjectFactoryRegistry<SymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str()));\n\t\t\tlastName = name;\n\t\t}\n\n\t\tConstByteArrayParameter iv;\n\t\tif (pairs.GetValue(Name::IV(), iv) && iv.size() != encryptor->IVSize())\n\t\t\tSignalTestFailure();\n\n\t\tif (test == \"Resync\")\n\t\t{\n\t\t\tencryptor->Resynchronize(iv.begin(), (int)iv.size());\n\t\t\tdecryptor->Resynchronize(iv.begin(), (int)iv.size());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tencryptor->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\t\tdecryptor->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\t}\n\n\t\tint seek = pairs.GetIntValueWithDefault(\"Seek\", 0);\n\t\tif (seek)\n\t\t{\n\t\t\tencryptor->Seek(seek);\n\t\t\tdecryptor->Seek(seek);\n\t\t}\n\n\t\tstd::string encrypted, xorDigest, ciphertext, ciphertextXorDigest;\n\t\tif (test == \"EncryptionMCT\" || test == \"DecryptionMCT\")\n\t\t{\n\t\t\tSymmetricCipher *cipher = encryptor.get();\n\t\t\tSecByteBlock buf((byte *)plaintext.data(), plaintext.size()), keybuf((byte *)key.data(), key.size());\n\n\t\t\tif (test == \"DecryptionMCT\")\n\t\t\t{\n\t\t\t\tcipher = decryptor.get();\n\t\t\t\tciphertext = GetDecodedDatum(v, \"Ciphertext\");\n\t\t\t\tbuf.Assign((byte *)ciphertext.data(), ciphertext.size());\n\t\t\t}\n\n\t\t\tfor (int i=0; i<400; i++)\n\t\t\t{\n\t\t\t\tencrypted.reserve(10000 * plaintext.size());\n\t\t\t\tfor (int j=0; j<10000; j++)\n\t\t\t\t{\n\t\t\t\t\tcipher->ProcessString(buf.begin(), buf.size());\n\t\t\t\t\tencrypted.append((char *)buf.begin(), buf.size());\n\t\t\t\t}\n\n\t\t\t\tencrypted.erase(0, encrypted.size() - keybuf.size());\n\t\t\t\txorbuf(keybuf.begin(), (const byte *)encrypted.data(), keybuf.size());\n\t\t\t\tcipher->SetKey(keybuf, keybuf.size());\n\t\t\t}\n\t\t\tencrypted.assign((char *)buf.begin(), buf.size());\n\t\t\tciphertext = GetDecodedDatum(v, test == \"EncryptionMCT\" ? \"Ciphertext\" : \"Plaintext\");\n\t\t\tif (encrypted != ciphertext)\n\t\t\t{\n\t\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\t\tstd::cout << \"\\n\";\n\t\t\t\tSignalTestFailure();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStreamTransformationFilter encFilter(*encryptor, new StringSink(encrypted), StreamTransformationFilter::NO_PADDING);\n\t\tRandomizedTransfer(StringStore(plaintext).Ref(), encFilter, true);\n\t\tencFilter.MessageEnd();\n\t\t/*{\n\t\t\tstd::string z;\n\t\t\tencryptor->Seek(seek);\n\t\t\tStringSource ss(plaintext, false, new StreamTransformationFilter(*encryptor, new StringSink(z), StreamTransformationFilter::NO_PADDING));\n\t\t\twhile (ss.Pump(64)) {}\n\t\t\tss.PumpAll();\n\t\t\tfor (int i=0; i<z.length(); i++)\n\t\t\t\tassert(encrypted[i] == z[i]);\n\t\t}*/\n\t\tif (test != \"EncryptXorDigest\")\n\t\t\tciphertext = GetDecodedDatum(v, \"Ciphertext\");\n\t\telse\n\t\t{\n\t\t\tciphertextXorDigest = GetDecodedDatum(v, \"CiphertextXorDigest\");\n\t\t\txorDigest.append(encrypted, 0, 64);\n\t\t\tfor (size_t i=64; i<encrypted.size(); i++)\n\t\t\t\txorDigest[i%64] ^= encrypted[i];\n\t\t}\n\t\tif (test != \"EncryptXorDigest\" ? encrypted != ciphertext : xorDigest != ciphertextXorDigest)\n\t\t{\n\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(2048); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tstd::string decrypted;\n\t\tStreamTransformationFilter decFilter(*decryptor, new StringSink(decrypted), StreamTransformationFilter::NO_PADDING);\n\t\tRandomizedTransfer(StringStore(encrypted).Ref(), decFilter, true);\n\t\tdecFilter.MessageEnd();\n\t\tif (decrypted != plaintext)\n\t\t{\n\t\t\tstd::cout << \"incorrectly decrypted: \";\n\t\t\tStringSource xx(decrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"unexpected test name\\n\";\n\t\tSignalTestError();\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestSymmetricCipher(TestData &v, const NameValuePairs &overrideParameters)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::string key = GetDecodedDatum(v, \"Key\");\n\tstd::string plaintext = GetDecodedDatum(v, \"Plaintext\");\n\n\tTestDataNameValuePairs testDataPairs(v);\n\tCombinedNameValuePairs pairs(overrideParameters, testDataPairs);\n\n\tif (test == \"Encrypt\" || test == \"EncryptXorDigest\" || test == \"Resync\" || test == \"EncryptionMCT\" || test == \"DecryptionMCT\")\n\t{\n\t\tstatic member_ptr<SymmetricCipher> encryptor, decryptor;\n\t\tstatic std::string lastName;\n\n\t\tif (name != lastName)\n\t\t{\n\t\t\tencryptor.reset(ObjectFactoryRegistry<SymmetricCipher, ENCRYPTION>::Registry().CreateObject(name.c_str()));\n\t\t\tdecryptor.reset(ObjectFactoryRegistry<SymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str()));\n\t\t\tlastName = name;\n\t\t}\n\n\t\tConstByteArrayParameter iv;\n\t\tif (pairs.GetValue(Name::IV(), iv) && iv.size() != encryptor->IVSize())\n\t\t\tSignalTestFailure();\n\n\t\tif (test == \"Resync\")\n\t\t{\n\t\t\tencryptor->Resynchronize(iv.begin(), (int)iv.size());\n\t\t\tdecryptor->Resynchronize(iv.begin(), (int)iv.size());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tencryptor->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\t\tdecryptor->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\t}\n\n\t\tint seek = pairs.GetIntValueWithDefault(\"Seek\", 0);\n\t\tif (seek)\n\t\t{\n\t\t\tencryptor->Seek(seek);\n\t\t\tdecryptor->Seek(seek);\n\t\t}\n\n\t\tstd::string encrypted, xorDigest, ciphertext, ciphertextXorDigest;\n\t\tif (test == \"EncryptionMCT\" || test == \"DecryptionMCT\")\n\t\t{\n\t\t\tSymmetricCipher *cipher = encryptor.get();\n\t\t\tSecByteBlock buf((byte *)plaintext.data(), plaintext.size()), keybuf((byte *)key.data(), key.size());\n\n\t\t\tif (test == \"DecryptionMCT\")\n\t\t\t{\n\t\t\t\tcipher = decryptor.get();\n\t\t\t\tciphertext = GetDecodedDatum(v, \"Ciphertext\");\n\t\t\t\tbuf.Assign((byte *)ciphertext.data(), ciphertext.size());\n\t\t\t}\n\n\t\t\tfor (int i=0; i<400; i++)\n\t\t\t{\n\t\t\t\tencrypted.reserve(10000 * plaintext.size());\n\t\t\t\tfor (int j=0; j<10000; j++)\n\t\t\t\t{\n\t\t\t\t\tcipher->ProcessString(buf.begin(), buf.size());\n\t\t\t\t\tencrypted.append((char *)buf.begin(), buf.size());\n\t\t\t\t}\n\n\t\t\t\tencrypted.erase(0, encrypted.size() - keybuf.size());\n\t\t\t\txorbuf(keybuf.begin(), (const byte *)encrypted.data(), keybuf.size());\n\t\t\t\tcipher->SetKey(keybuf, keybuf.size());\n\t\t\t}\n\t\t\tencrypted.assign((char *)buf.begin(), buf.size());\n\t\t\tciphertext = GetDecodedDatum(v, test == \"EncryptionMCT\" ? \"Ciphertext\" : \"Plaintext\");\n\t\t\tif (encrypted != ciphertext)\n\t\t\t{\n\t\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\t\tstd::cout << \"\\n\";\n\t\t\t\tSignalTestFailure();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStreamTransformationFilter encFilter(*encryptor, new StringSink(encrypted), StreamTransformationFilter::NO_PADDING);\n\t\tRandomizedTransfer(StringStore(plaintext).Ref(), encFilter, true);\n\t\tencFilter.MessageEnd();\n\t\t/*{\n\t\t\tstd::string z;\n\t\t\tencryptor->Seek(seek);\n\t\t\tStringSource ss(plaintext, false, new StreamTransformationFilter(*encryptor, new StringSink(z), StreamTransformationFilter::NO_PADDING));\n\t\t\twhile (ss.Pump(64)) {}\n\t\t\tss.PumpAll();\n\t\t\tfor (int i=0; i<z.length(); i++)\n\t\t\t\tassert(encrypted[i] == z[i]);\n\t\t}*/\n\t\tif (test != \"EncryptXorDigest\")\n\t\t\tciphertext = GetDecodedDatum(v, \"Ciphertext\");\n\t\telse\n\t\t{\n\t\t\tciphertextXorDigest = GetDecodedDatum(v, \"CiphertextXorDigest\");\n\t\t\txorDigest.append(encrypted, 0, 64);\n\t\t\tfor (size_t i=64; i<encrypted.size(); i++)\n\t\t\t\txorDigest[i%64] ^= encrypted[i];\n\t\t}\n\t\tif (test != \"EncryptXorDigest\" ? encrypted != ciphertext : xorDigest != ciphertextXorDigest)\n\t\t{\n\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(2048); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tstd::string decrypted;\n\t\tStreamTransformationFilter decFilter(*decryptor, new StringSink(decrypted), StreamTransformationFilter::NO_PADDING);\n\t\tRandomizedTransfer(StringStore(encrypted).Ref(), decFilter, true);\n\t\tdecFilter.MessageEnd();\n\t\tif (decrypted != plaintext)\n\t\t{\n\t\t\tstd::cout << \"incorrectly decrypted: \";\n\t\t\tStringSource xx(decrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"unexpected test name\\n\";\n\t\tSignalTestError();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestSignatureScheme",
          "args": [
            "v"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "TestSignatureScheme",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "203-278",
          "snippet": "void TestSignatureScheme(TestData &v)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::auto_ptr<PK_Signer> signer(ObjectFactoryRegistry<PK_Signer>::Registry().CreateObject(name.c_str()));\n\tstd::auto_ptr<PK_Verifier> verifier(ObjectFactoryRegistry<PK_Verifier>::Registry().CreateObject(name.c_str()));\n\n\tTestDataNameValuePairs pairs(v);\n\n\tif (test == \"GenerateKey\")\n\t{\n\t\tsigner->AccessPrivateKey().GenerateRandom(GlobalRNG(), pairs);\n\t\tverifier->AccessPublicKey().AssignFrom(signer->AccessPrivateKey());\n\t}\n\telse\n\t{\n\t\tstd::string keyFormat = GetRequiredDatum(v, \"KeyFormat\");\n\n\t\tif (keyFormat == \"DER\")\n\t\t\tverifier->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref());\n\t\telse if (keyFormat == \"Component\")\n\t\t\tverifier->AccessMaterial().AssignFrom(pairs);\n\n\t\tif (test == \"Verify\" || test == \"NotVerify\")\n\t\t{\n\t\t\tVerifierFilter verifierFilter(*verifier, NULL, VerifierFilter::SIGNATURE_AT_BEGIN);\n\t\t\tPutDecodedDatumInto(v, \"Signature\", verifierFilter);\n\t\t\tPutDecodedDatumInto(v, \"Message\", verifierFilter);\n\t\t\tverifierFilter.MessageEnd();\n\t\t\tif (verifierFilter.GetLastResult() == (test == \"NotVerify\"))\n\t\t\t\tSignalTestFailure();\n\t\t\treturn;\n\t\t}\n\t\telse if (test == \"PublicKeyValid\")\n\t\t{\n\t\t\tif (!verifier->GetMaterial().Validate(GlobalRNG(), 3))\n\t\t\t\tSignalTestFailure();\n\t\t\treturn;\n\t\t}\n\n\t\tif (keyFormat == \"DER\")\n\t\t\tsigner->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref());\n\t\telse if (keyFormat == \"Component\")\n\t\t\tsigner->AccessMaterial().AssignFrom(pairs);\n\t}\n\n\tif (test == \"GenerateKey\" || test == \"KeyPairValidAndConsistent\")\n\t{\n\t\tTestKeyPairValidAndConsistent(verifier->AccessMaterial(), signer->GetMaterial());\n\t\tVerifierFilter verifierFilter(*verifier, NULL, VerifierFilter::THROW_EXCEPTION);\n\t\tverifierFilter.Put((const byte *)\"abc\", 3);\n\t\tStringSource ss(\"abc\", true, new SignerFilter(GlobalRNG(), *signer, new Redirector(verifierFilter)));\n\t}\n\telse if (test == \"Sign\")\n\t{\n\t\tSignerFilter f(GlobalRNG(), *signer, new HexEncoder(new FileSink(cout)));\n\t\tStringSource ss(GetDecodedDatum(v, \"Message\"), true, new Redirector(f));\n\t\tSignalTestFailure();\n\t}\n\telse if (test == \"DeterministicSign\")\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\t// TODO: implement\n\t}\n\telse if (test == \"RandomSign\")\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\t// TODO: implement\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestSignatureScheme(TestData &v)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::auto_ptr<PK_Signer> signer(ObjectFactoryRegistry<PK_Signer>::Registry().CreateObject(name.c_str()));\n\tstd::auto_ptr<PK_Verifier> verifier(ObjectFactoryRegistry<PK_Verifier>::Registry().CreateObject(name.c_str()));\n\n\tTestDataNameValuePairs pairs(v);\n\n\tif (test == \"GenerateKey\")\n\t{\n\t\tsigner->AccessPrivateKey().GenerateRandom(GlobalRNG(), pairs);\n\t\tverifier->AccessPublicKey().AssignFrom(signer->AccessPrivateKey());\n\t}\n\telse\n\t{\n\t\tstd::string keyFormat = GetRequiredDatum(v, \"KeyFormat\");\n\n\t\tif (keyFormat == \"DER\")\n\t\t\tverifier->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref());\n\t\telse if (keyFormat == \"Component\")\n\t\t\tverifier->AccessMaterial().AssignFrom(pairs);\n\n\t\tif (test == \"Verify\" || test == \"NotVerify\")\n\t\t{\n\t\t\tVerifierFilter verifierFilter(*verifier, NULL, VerifierFilter::SIGNATURE_AT_BEGIN);\n\t\t\tPutDecodedDatumInto(v, \"Signature\", verifierFilter);\n\t\t\tPutDecodedDatumInto(v, \"Message\", verifierFilter);\n\t\t\tverifierFilter.MessageEnd();\n\t\t\tif (verifierFilter.GetLastResult() == (test == \"NotVerify\"))\n\t\t\t\tSignalTestFailure();\n\t\t\treturn;\n\t\t}\n\t\telse if (test == \"PublicKeyValid\")\n\t\t{\n\t\t\tif (!verifier->GetMaterial().Validate(GlobalRNG(), 3))\n\t\t\t\tSignalTestFailure();\n\t\t\treturn;\n\t\t}\n\n\t\tif (keyFormat == \"DER\")\n\t\t\tsigner->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref());\n\t\telse if (keyFormat == \"Component\")\n\t\t\tsigner->AccessMaterial().AssignFrom(pairs);\n\t}\n\n\tif (test == \"GenerateKey\" || test == \"KeyPairValidAndConsistent\")\n\t{\n\t\tTestKeyPairValidAndConsistent(verifier->AccessMaterial(), signer->GetMaterial());\n\t\tVerifierFilter verifierFilter(*verifier, NULL, VerifierFilter::THROW_EXCEPTION);\n\t\tverifierFilter.Put((const byte *)\"abc\", 3);\n\t\tStringSource ss(\"abc\", true, new SignerFilter(GlobalRNG(), *signer, new Redirector(verifierFilter)));\n\t}\n\telse if (test == \"Sign\")\n\t{\n\t\tSignerFilter f(GlobalRNG(), *signer, new HexEncoder(new FileSink(cout)));\n\t\tStringSource ss(GetDecodedDatum(v, \"Message\"), true, new Redirector(f));\n\t\tSignalTestFailure();\n\t}\n\telse if (test == \"DeterministicSign\")\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\t// TODO: implement\n\t}\n\telse if (test == \"RandomSign\")\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\t// TODO: implement\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lastAlgName.c_str",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "algType.c_str",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Name\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Name\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"AlgorithmType\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetField",
          "args": [
            "file",
            "name",
            "value"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "GetField",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "583-637",
          "snippet": "bool GetField(std::istream &is, std::string &name, std::string &value)\n{\n\tname.resize(0);\t\t// GCC workaround: 2.95.3 doesn't have clear()\n\tis >> name;\n\tif (name.empty())\n\t\treturn false;\n\n\tif (name[name.size()-1] != ':')\n\t{\n\t\tchar c;\n\t\tis >> skipws >> c;\n\t\tif (c != ':')\n\t\t\tSignalTestError();\n\t}\n\telse\n\t\tname.erase(name.size()-1);\n\n\twhile (is.peek() == ' ')\n\t\tis.ignore(1);\n\n\t// VC60 workaround: getline bug\n\tchar buffer[128];\n\tvalue.resize(0);\t// GCC workaround: 2.95.3 doesn't have clear()\n\tbool continueLine;\n\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\tis.get(buffer, sizeof(buffer));\n\t\t\tvalue += buffer;\n\t\t}\n\t\twhile (buffer[0] != 0);\n\t\tis.clear();\n\t\tis.ignore();\n\n\t\tif (!value.empty() && value[value.size()-1] == '\\r')\n\t\t\tvalue.resize(value.size()-1);\n\n\t\tif (!value.empty() && value[value.size()-1] == '\\\\')\n\t\t{\n\t\t\tvalue.resize(value.size()-1);\n\t\t\tcontinueLine = true;\n\t\t}\n\t\telse\n\t\t\tcontinueLine = false;\n\n\t\tstd::string::size_type i = value.find('#');\n\t\tif (i != std::string::npos)\n\t\t\tvalue.erase(i);\n\t}\n\twhile (continueLine);\n\n\treturn true;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nbool GetField(std::istream &is, std::string &name, std::string &value)\n{\n\tname.resize(0);\t\t// GCC workaround: 2.95.3 doesn't have clear()\n\tis >> name;\n\tif (name.empty())\n\t\treturn false;\n\n\tif (name[name.size()-1] != ':')\n\t{\n\t\tchar c;\n\t\tis >> skipws >> c;\n\t\tif (c != ':')\n\t\t\tSignalTestError();\n\t}\n\telse\n\t\tname.erase(name.size()-1);\n\n\twhile (is.peek() == ' ')\n\t\tis.ignore(1);\n\n\t// VC60 workaround: getline bug\n\tchar buffer[128];\n\tvalue.resize(0);\t// GCC workaround: 2.95.3 doesn't have clear()\n\tbool continueLine;\n\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\tis.get(buffer, sizeof(buffer));\n\t\t\tvalue += buffer;\n\t\t}\n\t\twhile (buffer[0] != 0);\n\t\tis.clear();\n\t\tis.ignore();\n\n\t\tif (!value.empty() && value[value.size()-1] == '\\r')\n\t\t\tvalue.resize(value.size()-1);\n\n\t\tif (!value.empty() && value[value.size()-1] == '\\\\')\n\t\t{\n\t\t\tvalue.resize(value.size()-1);\n\t\t\tcontinueLine = true;\n\t\t}\n\t\telse\n\t\t\tcontinueLine = false;\n\n\t\tstd::string::size_type i = value.find('#');\n\t\tif (i != std::string::npos)\n\t\t\tvalue.erase(i);\n\t}\n\twhile (continueLine);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.clear",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.peek",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.peek",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.ignore",
          "args": [
            "INT_MAX",
            "'\\n'"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.peek",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"Can not open file \" + filename + \" for reading\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.good",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic bool s_thorough;\nstatic const TestData *s_currentTestData = NULL;\n\nvoid TestDataFile(const std::string &filename, const NameValuePairs &overrideParameters, unsigned int &totalTests, unsigned int &failedTests)\n{\n\tstd::ifstream file(filename.c_str());\n\tif (!file.good())\n\t\tthrow Exception(Exception::OTHER_ERROR, \"Can not open file \" + filename + \" for reading\");\n\tTestData v;\n\ts_currentTestData = &v;\n\tstd::string name, value, lastAlgName;\n\n\twhile (file)\n\t{\n\t\twhile (file.peek() == '#')\n\t\t\tfile.ignore(INT_MAX, '\\n');\n\n\t\tif (file.peek() == '\\n' || file.peek() == '\\r')\n\t\t\tv.clear();\n\n\t\tif (!GetField(file, name, value))\n\t\t\tbreak;\n\t\tv[name] = value;\n\n\t\tif (name == \"Test\" && (s_thorough || v[\"SlowTest\"] != \"1\"))\n\t\t{\n\t\t\tbool failed = true;\n\t\t\tstd::string algType = GetRequiredDatum(v, \"AlgorithmType\");\n\n\t\t\tif (lastAlgName != GetRequiredDatum(v, \"Name\"))\n\t\t\t{\n\t\t\t\tlastAlgName = GetRequiredDatum(v, \"Name\");\n\t\t\t\tcout << \"\\nTesting \" << algType.c_str() << \" algorithm \" << lastAlgName.c_str() << \".\\n\";\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (algType == \"Signature\")\n\t\t\t\t\tTestSignatureScheme(v);\n\t\t\t\telse if (algType == \"SymmetricCipher\")\n\t\t\t\t\tTestSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AuthenticatedSymmetricCipher\")\n\t\t\t\t\tTestAuthenticatedSymmetricCipher(v, overrideParameters);\n\t\t\t\telse if (algType == \"AsymmetricCipher\")\n\t\t\t\t\tTestAsymmetricCipher(v);\n\t\t\t\telse if (algType == \"MessageDigest\")\n\t\t\t\t\tTestDigestOrMAC(v, true);\n\t\t\t\telse if (algType == \"MAC\")\n\t\t\t\t\tTestDigestOrMAC(v, false);\n\t\t\t\telse if (algType == \"FileList\")\n\t\t\t\t\tTestDataFile(GetRequiredDatum(v, \"Test\"), g_nullNameValuePairs, totalTests, failedTests);\n\t\t\t\telse\n\t\t\t\t\tSignalTestError();\n\t\t\t\tfailed = false;\n\t\t\t}\n\t\t\tcatch (TestFailure &)\n\t\t\t{\n\t\t\t\tcout << \"\\nTest failed.\\n\";\n\t\t\t}\n\t\t\tcatch (CryptoPP::Exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nCryptoPP::Exception caught: \" << e.what() << endl;\n\t\t\t}\n\t\t\tcatch (std::exception &e)\n\t\t\t{\n\t\t\t\tcout << \"\\nstd::exception caught: \" << e.what() << endl;\n\t\t\t}\n\n\t\t\tif (failed)\n\t\t\t{\n\t\t\t\tcout << \"Skipping to next test.\\n\";\n\t\t\t\tfailedTests++;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout << \".\" << flush;\n\n\t\t\ttotalTests++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "OutputNameValuePairs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "649-668",
    "snippet": "void OutputNameValuePairs(const NameValuePairs &v)\n{\n\tstd::string names = v.GetValueNames();\n\tstring::size_type i = 0;\n\twhile (i < names.size())\n\t{\n\t\tstring::size_type j = names.find_first_of (';', i);\n\n\t\tif (j == string::npos)\n\t\t\treturn;\n\t\telse\n\t\t{\n\t\t\tstd::string name = names.substr(i, j-i);\n\t\t\tif (name.find(':') == string::npos)\n\t\t\t\tOutputPair(v, name.c_str());\n\t\t}\n\n\t\ti = j + 1;\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OutputPair",
          "args": [
            "v",
            "name.c_str()"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "OutputPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "639-647",
          "snippet": "void OutputPair(const NameValuePairs &v, const char *name)\n{\n\tInteger x;\n\tbool b = v.GetValue(name, x);\n\tassert(b);\n\tcout << name << \": \\\\\\n    \";\n\tx.Encode(HexEncoder(new FileSink(cout), false, 64, \"\\\\\\n    \").Ref(), x.MinEncodedSize());\n\tcout << endl;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid OutputPair(const NameValuePairs &v, const char *name)\n{\n\tInteger x;\n\tbool b = v.GetValue(name, x);\n\tassert(b);\n\tcout << name << \": \\\\\\n    \";\n\tx.Encode(HexEncoder(new FileSink(cout), false, 64, \"\\\\\\n    \").Ref(), x.MinEncodedSize());\n\tcout << endl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.find",
          "args": [
            "':'"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "names.substr",
          "args": [
            "i",
            "j-i"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "names.find_first_of",
          "args": [
            "';'",
            "i"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "names.size",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.GetValueNames",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid OutputNameValuePairs(const NameValuePairs &v)\n{\n\tstd::string names = v.GetValueNames();\n\tstring::size_type i = 0;\n\twhile (i < names.size())\n\t{\n\t\tstring::size_type j = names.find_first_of (';', i);\n\n\t\tif (j == string::npos)\n\t\t\treturn;\n\t\telse\n\t\t{\n\t\t\tstd::string name = names.substr(i, j-i);\n\t\t\tif (name.find(':') == string::npos)\n\t\t\t\tOutputPair(v, name.c_str());\n\t\t}\n\n\t\ti = j + 1;\n\t}\n}"
  },
  {
    "function_name": "OutputPair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "639-647",
    "snippet": "void OutputPair(const NameValuePairs &v, const char *name)\n{\n\tInteger x;\n\tbool b = v.GetValue(name, x);\n\tassert(b);\n\tcout << name << \": \\\\\\n    \";\n\tx.Encode(HexEncoder(new FileSink(cout), false, 64, \"\\\\\\n    \").Ref(), x.MinEncodedSize());\n\tcout << endl;\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "x.Encode",
          "args": [
            "HexEncoder(new FileSink(cout), false, 64, \"\\\\\\n    \").Ref()",
            "x.MinEncodedSize()"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "GFP2Element",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/xtr.h",
          "lines": "21-25",
          "snippet": "void Encode(byte *encodedElement, unsigned int size)\n\t{\n\t\tc1.Encode(encodedElement, size/2);\n\t\tc2.Encode(encodedElement+size/2, size/2);\n\t}",
          "includes": [
            "#include \"modarith.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n\nGFP2Element {\n  void Encode(byte *encodedElement, unsigned int size)\n  \t{\n  \t\tc1.Encode(encodedElement, size/2);\n  \t\tc2.Encode(encodedElement+size/2, size/2);\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "x.MinEncodedSize",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexEncoder",
          "args": [],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexEncoder",
          "args": [
            "new FileSink(cout)",
            "false",
            "64",
            "\"\\\\\\n    \""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "b"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.GetValue",
          "args": [
            "name",
            "x"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid OutputPair(const NameValuePairs &v, const char *name)\n{\n\tInteger x;\n\tbool b = v.GetValue(name, x);\n\tassert(b);\n\tcout << name << \": \\\\\\n    \";\n\tx.Encode(HexEncoder(new FileSink(cout), false, 64, \"\\\\\\n    \").Ref(), x.MinEncodedSize());\n\tcout << endl;\n}"
  },
  {
    "function_name": "GetField",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "583-637",
    "snippet": "bool GetField(std::istream &is, std::string &name, std::string &value)\n{\n\tname.resize(0);\t\t// GCC workaround: 2.95.3 doesn't have clear()\n\tis >> name;\n\tif (name.empty())\n\t\treturn false;\n\n\tif (name[name.size()-1] != ':')\n\t{\n\t\tchar c;\n\t\tis >> skipws >> c;\n\t\tif (c != ':')\n\t\t\tSignalTestError();\n\t}\n\telse\n\t\tname.erase(name.size()-1);\n\n\twhile (is.peek() == ' ')\n\t\tis.ignore(1);\n\n\t// VC60 workaround: getline bug\n\tchar buffer[128];\n\tvalue.resize(0);\t// GCC workaround: 2.95.3 doesn't have clear()\n\tbool continueLine;\n\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\tis.get(buffer, sizeof(buffer));\n\t\t\tvalue += buffer;\n\t\t}\n\t\twhile (buffer[0] != 0);\n\t\tis.clear();\n\t\tis.ignore();\n\n\t\tif (!value.empty() && value[value.size()-1] == '\\r')\n\t\t\tvalue.resize(value.size()-1);\n\n\t\tif (!value.empty() && value[value.size()-1] == '\\\\')\n\t\t{\n\t\t\tvalue.resize(value.size()-1);\n\t\t\tcontinueLine = true;\n\t\t}\n\t\telse\n\t\t\tcontinueLine = false;\n\n\t\tstd::string::size_type i = value.find('#');\n\t\tif (i != std::string::npos)\n\t\t\tvalue.erase(i);\n\t}\n\twhile (continueLine);\n\n\treturn true;\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value.erase",
          "args": [
            "i"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.find",
          "args": [
            "'#'"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.resize",
          "args": [
            "value.size()-1"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.empty",
          "args": [],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is.ignore",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is.clear",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is.get",
          "args": [
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is.ignore",
          "args": [
            "1"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is.peek",
          "args": [],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.erase",
          "args": [
            "name.size()-1"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignalTestError",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "41-45",
          "snippet": "static void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nbool GetField(std::istream &is, std::string &name, std::string &value)\n{\n\tname.resize(0);\t\t// GCC workaround: 2.95.3 doesn't have clear()\n\tis >> name;\n\tif (name.empty())\n\t\treturn false;\n\n\tif (name[name.size()-1] != ':')\n\t{\n\t\tchar c;\n\t\tis >> skipws >> c;\n\t\tif (c != ':')\n\t\t\tSignalTestError();\n\t}\n\telse\n\t\tname.erase(name.size()-1);\n\n\twhile (is.peek() == ' ')\n\t\tis.ignore(1);\n\n\t// VC60 workaround: getline bug\n\tchar buffer[128];\n\tvalue.resize(0);\t// GCC workaround: 2.95.3 doesn't have clear()\n\tbool continueLine;\n\n\tdo\n\t{\n\t\tdo\n\t\t{\n\t\t\tis.get(buffer, sizeof(buffer));\n\t\t\tvalue += buffer;\n\t\t}\n\t\twhile (buffer[0] != 0);\n\t\tis.clear();\n\t\tis.ignore();\n\n\t\tif (!value.empty() && value[value.size()-1] == '\\r')\n\t\t\tvalue.resize(value.size()-1);\n\n\t\tif (!value.empty() && value[value.size()-1] == '\\\\')\n\t\t{\n\t\t\tvalue.resize(value.size()-1);\n\t\t\tcontinueLine = true;\n\t\t}\n\t\telse\n\t\t\tcontinueLine = false;\n\n\t\tstd::string::size_type i = value.find('#');\n\t\tif (i != std::string::npos)\n\t\t\tvalue.erase(i);\n\t}\n\twhile (continueLine);\n\n\treturn true;\n}"
  },
  {
    "function_name": "TestDigestOrMAC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "539-581",
    "snippet": "void TestDigestOrMAC(TestData &v, bool testDigest)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\tconst char *digestName = testDigest ? \"Digest\" : \"MAC\";\n\n\tmember_ptr<MessageAuthenticationCode> mac;\n\tmember_ptr<HashTransformation> hash;\n\tHashTransformation *pHash = NULL;\n\n\tTestDataNameValuePairs pairs(v);\n\n\tif (testDigest)\n\t{\n\t\thash.reset(ObjectFactoryRegistry<HashTransformation>::Registry().CreateObject(name.c_str()));\n\t\tpHash = hash.get();\n\t}\n\telse\n\t{\n\t\tmac.reset(ObjectFactoryRegistry<MessageAuthenticationCode>::Registry().CreateObject(name.c_str()));\n\t\tpHash = mac.get();\n\t\tstd::string key = GetDecodedDatum(v, \"Key\");\n\t\tmac->SetKey((const byte *)key.c_str(), key.size(), pairs);\n\t}\n\n\tif (test == \"Verify\" || test == \"VerifyTruncated\" || test == \"NotVerify\")\n\t{\n\t\tint digestSize = -1;\n\t\tif (test == \"VerifyTruncated\")\n\t\t\tpairs.GetIntValue(Name::DigestSize(), digestSize);\n\t\tHashVerificationFilter verifierFilter(*pHash, NULL, HashVerificationFilter::HASH_AT_BEGIN, digestSize);\n\t\tPutDecodedDatumInto(v, digestName, verifierFilter);\n\t\tPutDecodedDatumInto(v, \"Message\", verifierFilter);\n\t\tverifierFilter.MessageEnd();\n\t\tif (verifierFilter.GetLastResult() == (test == \"NotVerify\"))\n\t\t\tSignalTestFailure();\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignalTestError",
          "args": [],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "41-45",
          "snippet": "static void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignalTestFailure",
          "args": [],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "35-39",
          "snippet": "static void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "verifierFilter.GetLastResult",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "374-374",
          "snippet": "bool GetLastResult() const {return m_hashVerifier.GetLastResult();}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nbool GetLastResult() const {return m_hashVerifier.GetLastResult();}"
        }
      },
      {
        "call_info": {
          "callee": "verifierFilter.MessageEnd",
          "args": [],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PutDecodedDatumInto",
          "args": [
            "v",
            "\"Message\"",
            "verifierFilter"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "PutDecodedDatumInto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "73-121",
          "snippet": "void PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pairs.GetIntValue",
          "args": [
            "Name::DigestSize()",
            "digestSize"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::DigestSize",
          "args": [],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac->SetKey",
          "args": [
            "(const byte *)key.c_str()",
            "key.size()",
            "pairs"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "SetKey",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "48-60",
          "snippet": "void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tm_bufferedDataLength = 0;\r\n\tm_state = State_Start;\r\n\r\n\tSetKeyWithoutResync(userKey, keylength, params);\r\n\tm_state = State_KeySet;\r\n\r\n\tsize_t length;\r\n\tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n\tif (iv)\r\n\t\tResynchronize(iv, (int)length);\r\n}",
          "includes": [
            "#include \"authenc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n  {\r\n  \tm_bufferedDataLength = 0;\r\n  \tm_state = State_Start;\r\n  \r\n  \tSetKeyWithoutResync(userKey, keylength, params);\r\n  \tm_state = State_KeySet;\r\n  \r\n  \tsize_t length;\r\n  \tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n  \tif (iv)\r\n  \t\tResynchronize(iv, (int)length);\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.size",
          "args": [],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.c_str",
          "args": [],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDecodedDatum",
          "args": [
            "v",
            "\"Key\""
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "GetDecodedDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "123-128",
          "snippet": "std::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstd::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mac.get",
          "args": [],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.reset",
          "args": [
            "ObjectFactoryRegistry<MessageAuthenticationCode>::Registry().CreateObject(name.c_str())"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "member_ptr<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "50-50",
          "snippet": "void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nmember_ptr<T> {\n  void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<MessageAuthenticationCode>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<MessageAuthenticationCode>::Registry",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.get",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<HashTransformation>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<HashTransformation>::Registry",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Test\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Name\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestDigestOrMAC(TestData &v, bool testDigest)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\tconst char *digestName = testDigest ? \"Digest\" : \"MAC\";\n\n\tmember_ptr<MessageAuthenticationCode> mac;\n\tmember_ptr<HashTransformation> hash;\n\tHashTransformation *pHash = NULL;\n\n\tTestDataNameValuePairs pairs(v);\n\n\tif (testDigest)\n\t{\n\t\thash.reset(ObjectFactoryRegistry<HashTransformation>::Registry().CreateObject(name.c_str()));\n\t\tpHash = hash.get();\n\t}\n\telse\n\t{\n\t\tmac.reset(ObjectFactoryRegistry<MessageAuthenticationCode>::Registry().CreateObject(name.c_str()));\n\t\tpHash = mac.get();\n\t\tstd::string key = GetDecodedDatum(v, \"Key\");\n\t\tmac->SetKey((const byte *)key.c_str(), key.size(), pairs);\n\t}\n\n\tif (test == \"Verify\" || test == \"VerifyTruncated\" || test == \"NotVerify\")\n\t{\n\t\tint digestSize = -1;\n\t\tif (test == \"VerifyTruncated\")\n\t\t\tpairs.GetIntValue(Name::DigestSize(), digestSize);\n\t\tHashVerificationFilter verifierFilter(*pHash, NULL, HashVerificationFilter::HASH_AT_BEGIN, digestSize);\n\t\tPutDecodedDatumInto(v, digestName, verifierFilter);\n\t\tPutDecodedDatumInto(v, \"Message\", verifierFilter);\n\t\tverifierFilter.MessageEnd();\n\t\tif (verifierFilter.GetLastResult() == (test == \"NotVerify\"))\n\t\t\tSignalTestFailure();\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}"
  },
  {
    "function_name": "TestAuthenticatedSymmetricCipher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "453-537",
    "snippet": "void TestAuthenticatedSymmetricCipher(TestData &v, const NameValuePairs &overrideParameters)\n{\n\tstd::string type = GetRequiredDatum(v, \"AlgorithmType\");\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\tstd::string key = GetDecodedDatum(v, \"Key\");\n\n\tstd::string plaintext = GetOptionalDecodedDatum(v, \"Plaintext\");\n\tstd::string ciphertext = GetOptionalDecodedDatum(v, \"Ciphertext\");\n\tstd::string header = GetOptionalDecodedDatum(v, \"Header\");\n\tstd::string footer = GetOptionalDecodedDatum(v, \"Footer\");\n\tstd::string mac = GetOptionalDecodedDatum(v, \"MAC\");\n\n\tTestDataNameValuePairs testDataPairs(v);\n\tCombinedNameValuePairs pairs(overrideParameters, testDataPairs);\n\n\tif (test == \"Encrypt\" || test == \"EncryptXorDigest\" || test == \"NotVerify\")\n\t{\n\t\tmember_ptr<AuthenticatedSymmetricCipher> asc1, asc2;\n\t\tasc1.reset(ObjectFactoryRegistry<AuthenticatedSymmetricCipher, ENCRYPTION>::Registry().CreateObject(name.c_str()));\n\t\tasc2.reset(ObjectFactoryRegistry<AuthenticatedSymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str()));\n\t\tasc1->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\tasc2->SetKey((const byte *)key.data(), key.size(), pairs);\n\n\t\tstd::string encrypted, decrypted;\n\t\tAuthenticatedEncryptionFilter ef(*asc1, new StringSink(encrypted));\n\t\tbool macAtBegin = !mac.empty() && !GlobalRNG().GenerateBit();\t// test both ways randomly\n\t\tAuthenticatedDecryptionFilter df(*asc2, new StringSink(decrypted), macAtBegin ? AuthenticatedDecryptionFilter::MAC_AT_BEGIN : 0);\n\n\t\tif (asc1->NeedsPrespecifiedDataLengths())\n\t\t{\n\t\t\tasc1->SpecifyDataLengths(header.size(), plaintext.size(), footer.size());\n\t\t\tasc2->SpecifyDataLengths(header.size(), plaintext.size(), footer.size());\n\t\t}\n\n\t\tStringStore sh(header), sp(plaintext), sc(ciphertext), sf(footer), sm(mac);\n\n\t\tif (macAtBegin)\n\t\t\tRandomizedTransfer(sm, df, true);\n\t\tsh.CopyTo(df, LWORD_MAX, AAD_CHANNEL);\n\t\tRandomizedTransfer(sc, df, true);\n\t\tsf.CopyTo(df, LWORD_MAX, AAD_CHANNEL);\n\t\tif (!macAtBegin)\n\t\t\tRandomizedTransfer(sm, df, true);\n\t\tdf.MessageEnd();\n\n\t\tRandomizedTransfer(sh, ef, true, AAD_CHANNEL);\n\t\tRandomizedTransfer(sp, ef, true);\n\t\tRandomizedTransfer(sf, ef, true, AAD_CHANNEL);\n\t\tef.MessageEnd();\n\n\t\tif (test == \"Encrypt\" && encrypted != ciphertext+mac)\n\t\t{\n\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(2048); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tif (test == \"Encrypt\" && decrypted != plaintext)\n\t\t{\n\t\t\tstd::cout << \"incorrectly decrypted: \";\n\t\t\tStringSource xx(decrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\n\t\tif (ciphertext.size()+mac.size()-plaintext.size() != asc1->DigestSize())\n\t\t{\n\t\t\tstd::cout << \"bad MAC size\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tif (df.GetLastResult() != (test == \"Encrypt\"))\n\t\t{\n\t\t\tstd::cout << \"MAC incorrectly verified\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"unexpected test name\\n\";\n\t\tSignalTestError();\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignalTestError",
          "args": [],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "41-45",
          "snippet": "static void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignalTestFailure",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "35-39",
          "snippet": "static void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "df.GetLastResult",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "374-374",
          "snippet": "bool GetLastResult() const {return m_hashVerifier.GetLastResult();}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nbool GetLastResult() const {return m_hashVerifier.GetLastResult();}"
        }
      },
      {
        "call_info": {
          "callee": "asc1->DigestSize",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "plaintext.size",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xx.Flush",
          "args": [
            "false"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "Flush",
          "container": "InformationDispersal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.h",
          "lines": "107-107",
          "snippet": "bool Flush(bool hardFlush, int propagation=-1, bool blocking=true) {return m_ida.Flush(hardFlush, propagation, blocking);}",
          "includes": [
            "#include <vector>",
            "#include <map>",
            "#include \"channels.h\"",
            "#include \"filters.h\"",
            "#include \"mqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <map>\n#include \"channels.h\"\n#include \"filters.h\"\n#include \"mqueue.h\"\n\nInformationDispersal {\n  bool Flush(bool hardFlush, int propagation=-1, bool blocking=true) {return m_ida.Flush(hardFlush, propagation, blocking);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xx.Pump",
          "args": [
            "256"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xx.Pump",
          "args": [
            "2048"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef.MessageEnd",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RandomizedTransfer",
          "args": [
            "sf",
            "ef",
            "true",
            "AAD_CHANNEL"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RandomizedTransfer",
          "args": [
            "sp",
            "ef",
            "true"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "RandomizedTransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "61-71",
          "snippet": "void RandomizedTransfer(BufferedTransformation &source, BufferedTransformation &target, bool finish, const std::string &channel=DEFAULT_CHANNEL)\n{\n\twhile (source.MaxRetrievable() > (finish ? 0 : 4096))\n\t{\n\t\tbyte buf[4096+64];\n\t\tsize_t start = GlobalRNG().GenerateWord32(0, 63);\n\t\tsize_t len = GlobalRNG().GenerateWord32(1, UnsignedMin(4096U, 3*source.MaxRetrievable()/2));\n\t\tlen = source.Get(buf+start, len);\n\t\ttarget.ChannelPut(channel, buf+start, len);\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid RandomizedTransfer(BufferedTransformation &source, BufferedTransformation &target, bool finish, const std::string &channel=DEFAULT_CHANNEL)\n{\n\twhile (source.MaxRetrievable() > (finish ? 0 : 4096))\n\t{\n\t\tbyte buf[4096+64];\n\t\tsize_t start = GlobalRNG().GenerateWord32(0, 63);\n\t\tsize_t len = GlobalRNG().GenerateWord32(1, UnsignedMin(4096U, 3*source.MaxRetrievable()/2));\n\t\tlen = source.Get(buf+start, len);\n\t\ttarget.ChannelPut(channel, buf+start, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RandomizedTransfer",
          "args": [
            "sh",
            "ef",
            "true",
            "AAD_CHANNEL"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sf.CopyTo",
          "args": [
            "df",
            "LWORD_MAX",
            "AAD_CHANNEL"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sh.CopyTo",
          "args": [
            "df",
            "LWORD_MAX",
            "AAD_CHANNEL"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asc2->SpecifyDataLengths",
          "args": [
            "header.size()",
            "plaintext.size()",
            "footer.size()"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "SpecifyDataLengths",
          "container": "AuthenticatedSymmetricCipher",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "204-216",
          "snippet": "void AuthenticatedSymmetricCipher::SpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength)\n{\n\tif (headerLength > MaxHeaderLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": header length \" + IntToString(headerLength) + \" exceeds the maximum of \" + IntToString(MaxHeaderLength()));\n\n\tif (messageLength > MaxMessageLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": message length \" + IntToString(messageLength) + \" exceeds the maximum of \" + IntToString(MaxMessageLength()));\n\t\t\n\tif (footerLength > MaxFooterLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": footer length \" + IntToString(footerLength) + \" exceeds the maximum of \" + IntToString(MaxFooterLength()));\n\n\tUncheckedSpecifyDataLengths(headerLength, messageLength, footerLength);\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipher {\n  void AuthenticatedSymmetricCipher::SpecifyDataLengths(lword headerLength, lword messageLength, lword footerLength)\n  {\n  \tif (headerLength > MaxHeaderLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": header length \" + IntToString(headerLength) + \" exceeds the maximum of \" + IntToString(MaxHeaderLength()));\n  \n  \tif (messageLength > MaxMessageLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": message length \" + IntToString(messageLength) + \" exceeds the maximum of \" + IntToString(MaxMessageLength()));\n  \t\t\n  \tif (footerLength > MaxFooterLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": footer length \" + IntToString(footerLength) + \" exceeds the maximum of \" + IntToString(MaxFooterLength()));\n  \n  \tUncheckedSpecifyDataLengths(headerLength, messageLength, footerLength);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "asc1->NeedsPrespecifiedDataLengths",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mac.empty",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "asc2->SetKey",
          "args": [
            "(const byte *)key.data()",
            "key.size()",
            "pairs"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "SetKey",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "48-60",
          "snippet": "void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tm_bufferedDataLength = 0;\r\n\tm_state = State_Start;\r\n\r\n\tSetKeyWithoutResync(userKey, keylength, params);\r\n\tm_state = State_KeySet;\r\n\r\n\tsize_t length;\r\n\tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n\tif (iv)\r\n\t\tResynchronize(iv, (int)length);\r\n}",
          "includes": [
            "#include \"authenc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n  {\r\n  \tm_bufferedDataLength = 0;\r\n  \tm_state = State_Start;\r\n  \r\n  \tSetKeyWithoutResync(userKey, keylength, params);\r\n  \tm_state = State_KeySet;\r\n  \r\n  \tsize_t length;\r\n  \tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n  \tif (iv)\r\n  \t\tResynchronize(iv, (int)length);\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.data",
          "args": [],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "300-300",
          "snippet": "typename A::const_pointer data() const {return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "asc2.reset",
          "args": [
            "ObjectFactoryRegistry<AuthenticatedSymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str())"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "member_ptr<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "50-50",
          "snippet": "void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nmember_ptr<T> {\n  void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<AuthenticatedSymmetricCipher, DECRYPTION>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<AuthenticatedSymmetricCipher, DECRYPTION>::Registry",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<AuthenticatedSymmetricCipher, ENCRYPTION>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<AuthenticatedSymmetricCipher, ENCRYPTION>::Registry",
          "args": [],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetOptionalDecodedDatum",
          "args": [
            "v",
            "\"MAC\""
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "GetOptionalDecodedDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "130-136",
          "snippet": "std::string GetOptionalDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tif (DataExists(data, name))\n\t\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstd::string GetOptionalDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tif (DataExists(data, name))\n\t\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDecodedDatum",
          "args": [
            "v",
            "\"Key\""
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "GetDecodedDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "123-128",
          "snippet": "std::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstd::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Test\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Name\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"AlgorithmType\""
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestAuthenticatedSymmetricCipher(TestData &v, const NameValuePairs &overrideParameters)\n{\n\tstd::string type = GetRequiredDatum(v, \"AlgorithmType\");\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\tstd::string key = GetDecodedDatum(v, \"Key\");\n\n\tstd::string plaintext = GetOptionalDecodedDatum(v, \"Plaintext\");\n\tstd::string ciphertext = GetOptionalDecodedDatum(v, \"Ciphertext\");\n\tstd::string header = GetOptionalDecodedDatum(v, \"Header\");\n\tstd::string footer = GetOptionalDecodedDatum(v, \"Footer\");\n\tstd::string mac = GetOptionalDecodedDatum(v, \"MAC\");\n\n\tTestDataNameValuePairs testDataPairs(v);\n\tCombinedNameValuePairs pairs(overrideParameters, testDataPairs);\n\n\tif (test == \"Encrypt\" || test == \"EncryptXorDigest\" || test == \"NotVerify\")\n\t{\n\t\tmember_ptr<AuthenticatedSymmetricCipher> asc1, asc2;\n\t\tasc1.reset(ObjectFactoryRegistry<AuthenticatedSymmetricCipher, ENCRYPTION>::Registry().CreateObject(name.c_str()));\n\t\tasc2.reset(ObjectFactoryRegistry<AuthenticatedSymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str()));\n\t\tasc1->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\tasc2->SetKey((const byte *)key.data(), key.size(), pairs);\n\n\t\tstd::string encrypted, decrypted;\n\t\tAuthenticatedEncryptionFilter ef(*asc1, new StringSink(encrypted));\n\t\tbool macAtBegin = !mac.empty() && !GlobalRNG().GenerateBit();\t// test both ways randomly\n\t\tAuthenticatedDecryptionFilter df(*asc2, new StringSink(decrypted), macAtBegin ? AuthenticatedDecryptionFilter::MAC_AT_BEGIN : 0);\n\n\t\tif (asc1->NeedsPrespecifiedDataLengths())\n\t\t{\n\t\t\tasc1->SpecifyDataLengths(header.size(), plaintext.size(), footer.size());\n\t\t\tasc2->SpecifyDataLengths(header.size(), plaintext.size(), footer.size());\n\t\t}\n\n\t\tStringStore sh(header), sp(plaintext), sc(ciphertext), sf(footer), sm(mac);\n\n\t\tif (macAtBegin)\n\t\t\tRandomizedTransfer(sm, df, true);\n\t\tsh.CopyTo(df, LWORD_MAX, AAD_CHANNEL);\n\t\tRandomizedTransfer(sc, df, true);\n\t\tsf.CopyTo(df, LWORD_MAX, AAD_CHANNEL);\n\t\tif (!macAtBegin)\n\t\t\tRandomizedTransfer(sm, df, true);\n\t\tdf.MessageEnd();\n\n\t\tRandomizedTransfer(sh, ef, true, AAD_CHANNEL);\n\t\tRandomizedTransfer(sp, ef, true);\n\t\tRandomizedTransfer(sf, ef, true, AAD_CHANNEL);\n\t\tef.MessageEnd();\n\n\t\tif (test == \"Encrypt\" && encrypted != ciphertext+mac)\n\t\t{\n\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(2048); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tif (test == \"Encrypt\" && decrypted != plaintext)\n\t\t{\n\t\t\tstd::cout << \"incorrectly decrypted: \";\n\t\t\tStringSource xx(decrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\n\t\tif (ciphertext.size()+mac.size()-plaintext.size() != asc1->DigestSize())\n\t\t{\n\t\t\tstd::cout << \"bad MAC size\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tif (df.GetLastResult() != (test == \"Encrypt\"))\n\t\t{\n\t\t\tstd::cout << \"MAC incorrectly verified\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"unexpected test name\\n\";\n\t\tSignalTestError();\n\t}\n}"
  },
  {
    "function_name": "TestSymmetricCipher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "320-451",
    "snippet": "void TestSymmetricCipher(TestData &v, const NameValuePairs &overrideParameters)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::string key = GetDecodedDatum(v, \"Key\");\n\tstd::string plaintext = GetDecodedDatum(v, \"Plaintext\");\n\n\tTestDataNameValuePairs testDataPairs(v);\n\tCombinedNameValuePairs pairs(overrideParameters, testDataPairs);\n\n\tif (test == \"Encrypt\" || test == \"EncryptXorDigest\" || test == \"Resync\" || test == \"EncryptionMCT\" || test == \"DecryptionMCT\")\n\t{\n\t\tstatic member_ptr<SymmetricCipher> encryptor, decryptor;\n\t\tstatic std::string lastName;\n\n\t\tif (name != lastName)\n\t\t{\n\t\t\tencryptor.reset(ObjectFactoryRegistry<SymmetricCipher, ENCRYPTION>::Registry().CreateObject(name.c_str()));\n\t\t\tdecryptor.reset(ObjectFactoryRegistry<SymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str()));\n\t\t\tlastName = name;\n\t\t}\n\n\t\tConstByteArrayParameter iv;\n\t\tif (pairs.GetValue(Name::IV(), iv) && iv.size() != encryptor->IVSize())\n\t\t\tSignalTestFailure();\n\n\t\tif (test == \"Resync\")\n\t\t{\n\t\t\tencryptor->Resynchronize(iv.begin(), (int)iv.size());\n\t\t\tdecryptor->Resynchronize(iv.begin(), (int)iv.size());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tencryptor->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\t\tdecryptor->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\t}\n\n\t\tint seek = pairs.GetIntValueWithDefault(\"Seek\", 0);\n\t\tif (seek)\n\t\t{\n\t\t\tencryptor->Seek(seek);\n\t\t\tdecryptor->Seek(seek);\n\t\t}\n\n\t\tstd::string encrypted, xorDigest, ciphertext, ciphertextXorDigest;\n\t\tif (test == \"EncryptionMCT\" || test == \"DecryptionMCT\")\n\t\t{\n\t\t\tSymmetricCipher *cipher = encryptor.get();\n\t\t\tSecByteBlock buf((byte *)plaintext.data(), plaintext.size()), keybuf((byte *)key.data(), key.size());\n\n\t\t\tif (test == \"DecryptionMCT\")\n\t\t\t{\n\t\t\t\tcipher = decryptor.get();\n\t\t\t\tciphertext = GetDecodedDatum(v, \"Ciphertext\");\n\t\t\t\tbuf.Assign((byte *)ciphertext.data(), ciphertext.size());\n\t\t\t}\n\n\t\t\tfor (int i=0; i<400; i++)\n\t\t\t{\n\t\t\t\tencrypted.reserve(10000 * plaintext.size());\n\t\t\t\tfor (int j=0; j<10000; j++)\n\t\t\t\t{\n\t\t\t\t\tcipher->ProcessString(buf.begin(), buf.size());\n\t\t\t\t\tencrypted.append((char *)buf.begin(), buf.size());\n\t\t\t\t}\n\n\t\t\t\tencrypted.erase(0, encrypted.size() - keybuf.size());\n\t\t\t\txorbuf(keybuf.begin(), (const byte *)encrypted.data(), keybuf.size());\n\t\t\t\tcipher->SetKey(keybuf, keybuf.size());\n\t\t\t}\n\t\t\tencrypted.assign((char *)buf.begin(), buf.size());\n\t\t\tciphertext = GetDecodedDatum(v, test == \"EncryptionMCT\" ? \"Ciphertext\" : \"Plaintext\");\n\t\t\tif (encrypted != ciphertext)\n\t\t\t{\n\t\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\t\tstd::cout << \"\\n\";\n\t\t\t\tSignalTestFailure();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStreamTransformationFilter encFilter(*encryptor, new StringSink(encrypted), StreamTransformationFilter::NO_PADDING);\n\t\tRandomizedTransfer(StringStore(plaintext).Ref(), encFilter, true);\n\t\tencFilter.MessageEnd();\n\t\t/*{\n\t\t\tstd::string z;\n\t\t\tencryptor->Seek(seek);\n\t\t\tStringSource ss(plaintext, false, new StreamTransformationFilter(*encryptor, new StringSink(z), StreamTransformationFilter::NO_PADDING));\n\t\t\twhile (ss.Pump(64)) {}\n\t\t\tss.PumpAll();\n\t\t\tfor (int i=0; i<z.length(); i++)\n\t\t\t\tassert(encrypted[i] == z[i]);\n\t\t}*/\n\t\tif (test != \"EncryptXorDigest\")\n\t\t\tciphertext = GetDecodedDatum(v, \"Ciphertext\");\n\t\telse\n\t\t{\n\t\t\tciphertextXorDigest = GetDecodedDatum(v, \"CiphertextXorDigest\");\n\t\t\txorDigest.append(encrypted, 0, 64);\n\t\t\tfor (size_t i=64; i<encrypted.size(); i++)\n\t\t\t\txorDigest[i%64] ^= encrypted[i];\n\t\t}\n\t\tif (test != \"EncryptXorDigest\" ? encrypted != ciphertext : xorDigest != ciphertextXorDigest)\n\t\t{\n\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(2048); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tstd::string decrypted;\n\t\tStreamTransformationFilter decFilter(*decryptor, new StringSink(decrypted), StreamTransformationFilter::NO_PADDING);\n\t\tRandomizedTransfer(StringStore(encrypted).Ref(), decFilter, true);\n\t\tdecFilter.MessageEnd();\n\t\tif (decrypted != plaintext)\n\t\t{\n\t\t\tstd::cout << \"incorrectly decrypted: \";\n\t\t\tStringSource xx(decrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"unexpected test name\\n\";\n\t\tSignalTestError();\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignalTestError",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "41-45",
          "snippet": "static void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignalTestFailure",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "35-39",
          "snippet": "static void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xx.Flush",
          "args": [
            "false"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "Flush",
          "container": "InformationDispersal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/ida.h",
          "lines": "107-107",
          "snippet": "bool Flush(bool hardFlush, int propagation=-1, bool blocking=true) {return m_ida.Flush(hardFlush, propagation, blocking);}",
          "includes": [
            "#include <vector>",
            "#include <map>",
            "#include \"channels.h\"",
            "#include \"filters.h\"",
            "#include \"mqueue.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <map>\n#include \"channels.h\"\n#include \"filters.h\"\n#include \"mqueue.h\"\n\nInformationDispersal {\n  bool Flush(bool hardFlush, int propagation=-1, bool blocking=true) {return m_ida.Flush(hardFlush, propagation, blocking);}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xx.Pump",
          "args": [
            "256"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decFilter.MessageEnd",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RandomizedTransfer",
          "args": [
            "StringStore(encrypted).Ref()",
            "decFilter",
            "true"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "RandomizedTransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "61-71",
          "snippet": "void RandomizedTransfer(BufferedTransformation &source, BufferedTransformation &target, bool finish, const std::string &channel=DEFAULT_CHANNEL)\n{\n\twhile (source.MaxRetrievable() > (finish ? 0 : 4096))\n\t{\n\t\tbyte buf[4096+64];\n\t\tsize_t start = GlobalRNG().GenerateWord32(0, 63);\n\t\tsize_t len = GlobalRNG().GenerateWord32(1, UnsignedMin(4096U, 3*source.MaxRetrievable()/2));\n\t\tlen = source.Get(buf+start, len);\n\t\ttarget.ChannelPut(channel, buf+start, len);\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid RandomizedTransfer(BufferedTransformation &source, BufferedTransformation &target, bool finish, const std::string &channel=DEFAULT_CHANNEL)\n{\n\twhile (source.MaxRetrievable() > (finish ? 0 : 4096))\n\t{\n\t\tbyte buf[4096+64];\n\t\tsize_t start = GlobalRNG().GenerateWord32(0, 63);\n\t\tsize_t len = GlobalRNG().GenerateWord32(1, UnsignedMin(4096U, 3*source.MaxRetrievable()/2));\n\t\tlen = source.Get(buf+start, len);\n\t\ttarget.ChannelPut(channel, buf+start, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringStore",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "StringStore",
          "container": "StringStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "669-670",
          "snippet": "StringStore(const char *string = NULL)\n\t\t{StoreInitialize(MakeParameters(\"InputBuffer\", ConstByteArrayParameter(string)));}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringStore {\n  StringStore(const char *string = NULL)\n  \t\t{StoreInitialize(MakeParameters(\"InputBuffer\", ConstByteArrayParameter(string)));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringStore",
          "args": [
            "encrypted"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "StoreInitialize",
          "container": "StringStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "1046-1054",
          "snippet": "void StringStore::StoreInitialize(const NameValuePairs &parameters)\n{\n\tConstByteArrayParameter array;\n\tif (!parameters.GetValue(Name::InputBuffer(), array))\n\t\tthrow InvalidArgument(\"StringStore: missing InputBuffer argument\");\n\tm_store = array.begin();\n\tm_length = array.size();\n\tm_count = 0;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nStringStore {\n  void StringStore::StoreInitialize(const NameValuePairs &parameters)\n  {\n  \tConstByteArrayParameter array;\n  \tif (!parameters.GetValue(Name::InputBuffer(), array))\n  \t\tthrow InvalidArgument(\"StringStore: missing InputBuffer argument\");\n  \tm_store = array.begin();\n  \tm_length = array.size();\n  \tm_count = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "xx.Pump",
          "args": [
            "2048"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encrypted.size",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xorDigest.append",
          "args": [
            "encrypted",
            "0",
            "64"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDecodedDatum",
          "args": [
            "v",
            "\"CiphertextXorDigest\""
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "GetDecodedDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "123-128",
          "snippet": "std::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstd::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xx.Pump",
          "args": [
            "256"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encrypted.assign",
          "args": [
            "(char *)buf.begin()",
            "buf.size()"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf.begin",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cipher->SetKey",
          "args": [
            "keybuf",
            "keybuf.size()"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "keybuf.begin()",
            "(const byte *)encrypted.data()",
            "keybuf.size()"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "encrypted.data",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "300-300",
          "snippet": "typename A::const_pointer data() const {return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "encrypted.erase",
          "args": [
            "0",
            "encrypted.size() - keybuf.size()"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encrypted.append",
          "args": [
            "(char *)buf.begin()",
            "buf.size()"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cipher->ProcessString",
          "args": [
            "buf.begin()",
            "buf.size()"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encrypted.reserve",
          "args": [
            "10000 * plaintext.size()"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf.Assign",
          "args": [
            "(byte *)ciphertext.data()",
            "ciphertext.size()"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "Assign",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "310-314",
          "snippet": "void Assign(const T *t, size_type len)\n\t{\n\t\tNew(len);\n\t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void Assign(const T *t, size_type len)\n  \t{\n  \t\tNew(len);\n  \t\tmemcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "decryptor.get",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encryptor.get",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor->Seek",
          "args": [
            "seek"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "AdditiveCipherTemplate<BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
          "lines": "135-150",
          "snippet": "void AdditiveCipherTemplate<BASE>::Seek(lword position)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tpolicy.SeekToIteration(position / bytesPerIteration);\n\tposition %= bytesPerIteration;\n\n\tif (position > 0)\n\t{\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n\t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n\t}\n\telse\n\t\tm_leftOver = 0;\n}",
          "includes": [
            "#include \"strciphr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nAdditiveCipherTemplate<BASE> {\n  void AdditiveCipherTemplate<BASE>::Seek(lword position)\n  {\n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n  \n  \tpolicy.SeekToIteration(position / bytesPerIteration);\n  \tposition %= bytesPerIteration;\n  \n  \tif (position > 0)\n  \t{\n  \t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n  \t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n  \t}\n  \telse\n  \t\tm_leftOver = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pairs.GetIntValueWithDefault",
          "args": [
            "\"Seek\"",
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor->SetKey",
          "args": [
            "(const byte *)key.data()",
            "key.size()",
            "pairs"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "SetKey",
          "container": "AuthenticatedSymmetricCipherBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/authenc.cpp",
          "lines": "48-60",
          "snippet": "void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n{\r\n\tm_bufferedDataLength = 0;\r\n\tm_state = State_Start;\r\n\r\n\tSetKeyWithoutResync(userKey, keylength, params);\r\n\tm_state = State_KeySet;\r\n\r\n\tsize_t length;\r\n\tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n\tif (iv)\r\n\t\tResynchronize(iv, (int)length);\r\n}",
          "includes": [
            "#include \"authenc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"authenc.h\"\n#include \"pch.h\"\n\nAuthenticatedSymmetricCipherBase {\n  void AuthenticatedSymmetricCipherBase::SetKey(const byte *userKey, size_t keylength, const NameValuePairs &params)\r\n  {\r\n  \tm_bufferedDataLength = 0;\r\n  \tm_state = State_Start;\r\n  \r\n  \tSetKeyWithoutResync(userKey, keylength, params);\r\n  \tm_state = State_KeySet;\r\n  \r\n  \tsize_t length;\r\n  \tconst byte *iv = GetIVAndThrowIfInvalid(params, length);\r\n  \tif (iv)\r\n  \t\tResynchronize(iv, (int)length);\r\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "decryptor->Resynchronize",
          "args": [
            "iv.begin()",
            "(int)iv.size()"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "Resynchronize",
          "container": "VMAC_Base",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/vmac.cpp",
          "lines": "99-131",
          "snippet": "void VMAC_Base::Resynchronize(const byte *nonce, int len)\n{\n\tsize_t length = ThrowIfInvalidIVLength(len);\n\tsize_t s = IVSize();\n\tbyte *storedNonce = m_nonce();\n\n\tif (m_is128)\n\t{\n\t\tmemset(storedNonce, 0, s-length);\n\t\tmemcpy(storedNonce+s-length, nonce, length);\n\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t}\n\telse\n\t{\n\t\tif (m_padCached && (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n\t\t{\n\t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n\t\t\tfor (size_t i=0; m_padCached && i<s-length; i++)\n\t\t\t\tm_padCached = (storedNonce[i] == 0);\n\t\t}\n\t\tif (!m_padCached)\n\t\t{\n\t\t\tmemset(storedNonce, 0, s-length);\n\t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n\t\t\tstoredNonce[s-1] = nonce[length-1] & 0xfe;\n\t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n\t\t\tm_padCached = true;\n\t\t}\n\t\tstoredNonce[s-1] = nonce[length-1];\n\t}\n\tm_isFirstBlock = true;\n\tRestart();\n}",
          "includes": [
            "#include <intrin.h>",
            "#include \"cpu.h\"",
            "#include \"argnames.h\"",
            "#include \"vmac.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [
            "#define const\t// Turbo C++ 2006 workaround"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <intrin.h>\n#include \"cpu.h\"\n#include \"argnames.h\"\n#include \"vmac.h\"\n#include \"pch.h\"\n\n#define const\t// Turbo C++ 2006 workaround\n\nVMAC_Base {\n  void VMAC_Base::Resynchronize(const byte *nonce, int len)\n  {\n  \tsize_t length = ThrowIfInvalidIVLength(len);\n  \tsize_t s = IVSize();\n  \tbyte *storedNonce = m_nonce();\n  \n  \tif (m_is128)\n  \t{\n  \t\tmemset(storedNonce, 0, s-length);\n  \t\tmemcpy(storedNonce+s-length, nonce, length);\n  \t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n  \t}\n  \telse\n  \t{\n  \t\tif (m_padCached && (storedNonce[s-1] | 1) == (nonce[length-1] | 1))\n  \t\t{\n  \t\t\tm_padCached = VerifyBufsEqual(storedNonce+s-length, nonce, length-1);\n  \t\t\tfor (size_t i=0; m_padCached && i<s-length; i++)\n  \t\t\t\tm_padCached = (storedNonce[i] == 0);\n  \t\t}\n  \t\tif (!m_padCached)\n  \t\t{\n  \t\t\tmemset(storedNonce, 0, s-length);\n  \t\t\tmemcpy(storedNonce+s-length, nonce, length-1);\n  \t\t\tstoredNonce[s-1] = nonce[length-1] & 0xfe;\n  \t\t\tAccessCipher().ProcessBlock(storedNonce, m_pad());\n  \t\t\tm_padCached = true;\n  \t\t}\n  \t\tstoredNonce[s-1] = nonce[length-1];\n  \t}\n  \tm_isFirstBlock = true;\n  \tRestart();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "encryptor->IVSize",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "IVSize",
          "container": "FixedBlockSize::FixedRounds",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/seckey.h",
          "lines": "139-139",
          "snippet": "unsigned int IVSize() const {return INFO::IV_LENGTH;}",
          "includes": [
            "#include \"simple.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"simple.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n\nFixedBlockSize {\n  FixedRounds {\n    unsigned int IVSize() const {return INFO::IV_LENGTH;}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pairs.GetValue",
          "args": [
            "Name::IV()",
            "iv"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::IV",
          "args": [],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor.reset",
          "args": [
            "ObjectFactoryRegistry<SymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str())"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "reset",
          "container": "member_ptr<T>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "50-50",
          "snippet": "void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nmember_ptr<T> {\n  void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<SymmetricCipher, DECRYPTION>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<SymmetricCipher, DECRYPTION>::Registry",
          "args": [],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<SymmetricCipher, ENCRYPTION>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<SymmetricCipher, ENCRYPTION>::Registry",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Test\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Name\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestSymmetricCipher(TestData &v, const NameValuePairs &overrideParameters)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::string key = GetDecodedDatum(v, \"Key\");\n\tstd::string plaintext = GetDecodedDatum(v, \"Plaintext\");\n\n\tTestDataNameValuePairs testDataPairs(v);\n\tCombinedNameValuePairs pairs(overrideParameters, testDataPairs);\n\n\tif (test == \"Encrypt\" || test == \"EncryptXorDigest\" || test == \"Resync\" || test == \"EncryptionMCT\" || test == \"DecryptionMCT\")\n\t{\n\t\tstatic member_ptr<SymmetricCipher> encryptor, decryptor;\n\t\tstatic std::string lastName;\n\n\t\tif (name != lastName)\n\t\t{\n\t\t\tencryptor.reset(ObjectFactoryRegistry<SymmetricCipher, ENCRYPTION>::Registry().CreateObject(name.c_str()));\n\t\t\tdecryptor.reset(ObjectFactoryRegistry<SymmetricCipher, DECRYPTION>::Registry().CreateObject(name.c_str()));\n\t\t\tlastName = name;\n\t\t}\n\n\t\tConstByteArrayParameter iv;\n\t\tif (pairs.GetValue(Name::IV(), iv) && iv.size() != encryptor->IVSize())\n\t\t\tSignalTestFailure();\n\n\t\tif (test == \"Resync\")\n\t\t{\n\t\t\tencryptor->Resynchronize(iv.begin(), (int)iv.size());\n\t\t\tdecryptor->Resynchronize(iv.begin(), (int)iv.size());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tencryptor->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\t\tdecryptor->SetKey((const byte *)key.data(), key.size(), pairs);\n\t\t}\n\n\t\tint seek = pairs.GetIntValueWithDefault(\"Seek\", 0);\n\t\tif (seek)\n\t\t{\n\t\t\tencryptor->Seek(seek);\n\t\t\tdecryptor->Seek(seek);\n\t\t}\n\n\t\tstd::string encrypted, xorDigest, ciphertext, ciphertextXorDigest;\n\t\tif (test == \"EncryptionMCT\" || test == \"DecryptionMCT\")\n\t\t{\n\t\t\tSymmetricCipher *cipher = encryptor.get();\n\t\t\tSecByteBlock buf((byte *)plaintext.data(), plaintext.size()), keybuf((byte *)key.data(), key.size());\n\n\t\t\tif (test == \"DecryptionMCT\")\n\t\t\t{\n\t\t\t\tcipher = decryptor.get();\n\t\t\t\tciphertext = GetDecodedDatum(v, \"Ciphertext\");\n\t\t\t\tbuf.Assign((byte *)ciphertext.data(), ciphertext.size());\n\t\t\t}\n\n\t\t\tfor (int i=0; i<400; i++)\n\t\t\t{\n\t\t\t\tencrypted.reserve(10000 * plaintext.size());\n\t\t\t\tfor (int j=0; j<10000; j++)\n\t\t\t\t{\n\t\t\t\t\tcipher->ProcessString(buf.begin(), buf.size());\n\t\t\t\t\tencrypted.append((char *)buf.begin(), buf.size());\n\t\t\t\t}\n\n\t\t\t\tencrypted.erase(0, encrypted.size() - keybuf.size());\n\t\t\t\txorbuf(keybuf.begin(), (const byte *)encrypted.data(), keybuf.size());\n\t\t\t\tcipher->SetKey(keybuf, keybuf.size());\n\t\t\t}\n\t\t\tencrypted.assign((char *)buf.begin(), buf.size());\n\t\t\tciphertext = GetDecodedDatum(v, test == \"EncryptionMCT\" ? \"Ciphertext\" : \"Plaintext\");\n\t\t\tif (encrypted != ciphertext)\n\t\t\t{\n\t\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\t\tstd::cout << \"\\n\";\n\t\t\t\tSignalTestFailure();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tStreamTransformationFilter encFilter(*encryptor, new StringSink(encrypted), StreamTransformationFilter::NO_PADDING);\n\t\tRandomizedTransfer(StringStore(plaintext).Ref(), encFilter, true);\n\t\tencFilter.MessageEnd();\n\t\t/*{\n\t\t\tstd::string z;\n\t\t\tencryptor->Seek(seek);\n\t\t\tStringSource ss(plaintext, false, new StreamTransformationFilter(*encryptor, new StringSink(z), StreamTransformationFilter::NO_PADDING));\n\t\t\twhile (ss.Pump(64)) {}\n\t\t\tss.PumpAll();\n\t\t\tfor (int i=0; i<z.length(); i++)\n\t\t\t\tassert(encrypted[i] == z[i]);\n\t\t}*/\n\t\tif (test != \"EncryptXorDigest\")\n\t\t\tciphertext = GetDecodedDatum(v, \"Ciphertext\");\n\t\telse\n\t\t{\n\t\t\tciphertextXorDigest = GetDecodedDatum(v, \"CiphertextXorDigest\");\n\t\t\txorDigest.append(encrypted, 0, 64);\n\t\t\tfor (size_t i=64; i<encrypted.size(); i++)\n\t\t\t\txorDigest[i%64] ^= encrypted[i];\n\t\t}\n\t\tif (test != \"EncryptXorDigest\" ? encrypted != ciphertext : xorDigest != ciphertextXorDigest)\n\t\t{\n\t\t\tstd::cout << \"incorrectly encrypted: \";\n\t\t\tStringSource xx(encrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(2048); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t\tstd::string decrypted;\n\t\tStreamTransformationFilter decFilter(*decryptor, new StringSink(decrypted), StreamTransformationFilter::NO_PADDING);\n\t\tRandomizedTransfer(StringStore(encrypted).Ref(), decFilter, true);\n\t\tdecFilter.MessageEnd();\n\t\tif (decrypted != plaintext)\n\t\t{\n\t\t\tstd::cout << \"incorrectly decrypted: \";\n\t\t\tStringSource xx(decrypted, false, new HexEncoder(new FileSink(std::cout)));\n\t\t\txx.Pump(256); xx.Flush(false);\n\t\t\tstd::cout << \"\\n\";\n\t\t\tSignalTestFailure();\n\t\t}\n\t}\n\telse\n\t{\n\t\tstd::cout << \"unexpected test name\\n\";\n\t\tSignalTestError();\n\t}\n}"
  },
  {
    "function_name": "TestAsymmetricCipher",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "280-318",
    "snippet": "void TestAsymmetricCipher(TestData &v)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::auto_ptr<PK_Encryptor> encryptor(ObjectFactoryRegistry<PK_Encryptor>::Registry().CreateObject(name.c_str()));\n\tstd::auto_ptr<PK_Decryptor> decryptor(ObjectFactoryRegistry<PK_Decryptor>::Registry().CreateObject(name.c_str()));\n\n\tstd::string keyFormat = GetRequiredDatum(v, \"KeyFormat\");\n\n\tif (keyFormat == \"DER\")\n\t{\n\t\tdecryptor->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref());\n\t\tencryptor->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref());\n\t}\n\telse if (keyFormat == \"Component\")\n\t{\n\t\tTestDataNameValuePairs pairs(v);\n\t\tdecryptor->AccessMaterial().AssignFrom(pairs);\n\t\tencryptor->AccessMaterial().AssignFrom(pairs);\n\t}\n\n\tif (test == \"DecryptMatch\")\n\t{\n\t\tstd::string decrypted, expected = GetDecodedDatum(v, \"Plaintext\");\n\t\tStringSource ss(GetDecodedDatum(v, \"Ciphertext\"), true, new PK_DecryptorFilter(GlobalRNG(), *decryptor, new StringSink(decrypted)));\n\t\tif (decrypted != expected)\n\t\t\tSignalTestFailure();\n\t}\n\telse if (test == \"KeyPairValidAndConsistent\")\n\t{\n\t\tTestKeyPairValidAndConsistent(encryptor->AccessMaterial(), decryptor->GetMaterial());\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignalTestError",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "41-45",
          "snippet": "static void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestKeyPairValidAndConsistent",
          "args": [
            "encryptor->AccessMaterial()",
            "decryptor->GetMaterial()"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "TestKeyPairValidAndConsistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "188-201",
          "snippet": "void TestKeyPairValidAndConsistent(CryptoMaterial &pub, const CryptoMaterial &priv)\n{\n\tif (!pub.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\tif (!priv.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\n\tByteQueue bq1, bq2;\n\tpub.Save(bq1);\n\tpub.AssignFrom(priv);\n\tpub.Save(bq2);\n\tif (bq1 != bq2)\n\t\tSignalTestFailure();\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool s_thorough;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic bool s_thorough;\n\nvoid TestKeyPairValidAndConsistent(CryptoMaterial &pub, const CryptoMaterial &priv)\n{\n\tif (!pub.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\tif (!priv.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\n\tByteQueue bq1, bq2;\n\tpub.Save(bq1);\n\tpub.AssignFrom(priv);\n\tpub.Save(bq2);\n\tif (bq1 != bq2)\n\t\tSignalTestFailure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "decryptor->GetMaterial",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encryptor->AccessMaterial",
          "args": [],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignalTestFailure",
          "args": [],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "35-39",
          "snippet": "static void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDecodedDatum",
          "args": [
            "v",
            "\"Ciphertext\""
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "GetDecodedDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "123-128",
          "snippet": "std::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstd::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encryptor->AccessMaterial",
          "args": [
            "pairs"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encryptor->AccessMaterial",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor->AccessMaterial",
          "args": [
            "pairs"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor->AccessMaterial",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encryptor->AccessMaterial",
          "args": [
            "StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref()"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringStore",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "StringStore",
          "container": "StringStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "669-670",
          "snippet": "StringStore(const char *string = NULL)\n\t\t{StoreInitialize(MakeParameters(\"InputBuffer\", ConstByteArrayParameter(string)));}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringStore {\n  StringStore(const char *string = NULL)\n  \t\t{StoreInitialize(MakeParameters(\"InputBuffer\", ConstByteArrayParameter(string)));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringStore",
          "args": [
            "GetDecodedDatum(v, \"PublicKey\")"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "StoreInitialize",
          "container": "StringStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "1046-1054",
          "snippet": "void StringStore::StoreInitialize(const NameValuePairs &parameters)\n{\n\tConstByteArrayParameter array;\n\tif (!parameters.GetValue(Name::InputBuffer(), array))\n\t\tthrow InvalidArgument(\"StringStore: missing InputBuffer argument\");\n\tm_store = array.begin();\n\tm_length = array.size();\n\tm_count = 0;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nStringStore {\n  void StringStore::StoreInitialize(const NameValuePairs &parameters)\n  {\n  \tConstByteArrayParameter array;\n  \tif (!parameters.GetValue(Name::InputBuffer(), array))\n  \t\tthrow InvalidArgument(\"StringStore: missing InputBuffer argument\");\n  \tm_store = array.begin();\n  \tm_length = array.size();\n  \tm_count = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "encryptor->AccessMaterial",
          "args": [],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor->AccessMaterial",
          "args": [
            "StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref()"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decryptor->AccessMaterial",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"KeyFormat\""
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<PK_Decryptor>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<PK_Decryptor>::Registry",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<PK_Encryptor>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<PK_Encryptor>::Registry",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Test\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Name\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestAsymmetricCipher(TestData &v)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::auto_ptr<PK_Encryptor> encryptor(ObjectFactoryRegistry<PK_Encryptor>::Registry().CreateObject(name.c_str()));\n\tstd::auto_ptr<PK_Decryptor> decryptor(ObjectFactoryRegistry<PK_Decryptor>::Registry().CreateObject(name.c_str()));\n\n\tstd::string keyFormat = GetRequiredDatum(v, \"KeyFormat\");\n\n\tif (keyFormat == \"DER\")\n\t{\n\t\tdecryptor->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref());\n\t\tencryptor->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref());\n\t}\n\telse if (keyFormat == \"Component\")\n\t{\n\t\tTestDataNameValuePairs pairs(v);\n\t\tdecryptor->AccessMaterial().AssignFrom(pairs);\n\t\tencryptor->AccessMaterial().AssignFrom(pairs);\n\t}\n\n\tif (test == \"DecryptMatch\")\n\t{\n\t\tstd::string decrypted, expected = GetDecodedDatum(v, \"Plaintext\");\n\t\tStringSource ss(GetDecodedDatum(v, \"Ciphertext\"), true, new PK_DecryptorFilter(GlobalRNG(), *decryptor, new StringSink(decrypted)));\n\t\tif (decrypted != expected)\n\t\t\tSignalTestFailure();\n\t}\n\telse if (test == \"KeyPairValidAndConsistent\")\n\t{\n\t\tTestKeyPairValidAndConsistent(encryptor->AccessMaterial(), decryptor->GetMaterial());\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}"
  },
  {
    "function_name": "TestSignatureScheme",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "203-278",
    "snippet": "void TestSignatureScheme(TestData &v)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::auto_ptr<PK_Signer> signer(ObjectFactoryRegistry<PK_Signer>::Registry().CreateObject(name.c_str()));\n\tstd::auto_ptr<PK_Verifier> verifier(ObjectFactoryRegistry<PK_Verifier>::Registry().CreateObject(name.c_str()));\n\n\tTestDataNameValuePairs pairs(v);\n\n\tif (test == \"GenerateKey\")\n\t{\n\t\tsigner->AccessPrivateKey().GenerateRandom(GlobalRNG(), pairs);\n\t\tverifier->AccessPublicKey().AssignFrom(signer->AccessPrivateKey());\n\t}\n\telse\n\t{\n\t\tstd::string keyFormat = GetRequiredDatum(v, \"KeyFormat\");\n\n\t\tif (keyFormat == \"DER\")\n\t\t\tverifier->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref());\n\t\telse if (keyFormat == \"Component\")\n\t\t\tverifier->AccessMaterial().AssignFrom(pairs);\n\n\t\tif (test == \"Verify\" || test == \"NotVerify\")\n\t\t{\n\t\t\tVerifierFilter verifierFilter(*verifier, NULL, VerifierFilter::SIGNATURE_AT_BEGIN);\n\t\t\tPutDecodedDatumInto(v, \"Signature\", verifierFilter);\n\t\t\tPutDecodedDatumInto(v, \"Message\", verifierFilter);\n\t\t\tverifierFilter.MessageEnd();\n\t\t\tif (verifierFilter.GetLastResult() == (test == \"NotVerify\"))\n\t\t\t\tSignalTestFailure();\n\t\t\treturn;\n\t\t}\n\t\telse if (test == \"PublicKeyValid\")\n\t\t{\n\t\t\tif (!verifier->GetMaterial().Validate(GlobalRNG(), 3))\n\t\t\t\tSignalTestFailure();\n\t\t\treturn;\n\t\t}\n\n\t\tif (keyFormat == \"DER\")\n\t\t\tsigner->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref());\n\t\telse if (keyFormat == \"Component\")\n\t\t\tsigner->AccessMaterial().AssignFrom(pairs);\n\t}\n\n\tif (test == \"GenerateKey\" || test == \"KeyPairValidAndConsistent\")\n\t{\n\t\tTestKeyPairValidAndConsistent(verifier->AccessMaterial(), signer->GetMaterial());\n\t\tVerifierFilter verifierFilter(*verifier, NULL, VerifierFilter::THROW_EXCEPTION);\n\t\tverifierFilter.Put((const byte *)\"abc\", 3);\n\t\tStringSource ss(\"abc\", true, new SignerFilter(GlobalRNG(), *signer, new Redirector(verifierFilter)));\n\t}\n\telse if (test == \"Sign\")\n\t{\n\t\tSignerFilter f(GlobalRNG(), *signer, new HexEncoder(new FileSink(cout)));\n\t\tStringSource ss(GetDecodedDatum(v, \"Message\"), true, new Redirector(f));\n\t\tSignalTestFailure();\n\t}\n\telse if (test == \"DeterministicSign\")\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\t// TODO: implement\n\t}\n\telse if (test == \"RandomSign\")\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\t// TODO: implement\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignalTestError",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "41-45",
          "snippet": "static void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "false"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SignalTestFailure",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "35-39",
          "snippet": "static void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDecodedDatum",
          "args": [
            "v",
            "\"Message\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "GetDecodedDatum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "123-128",
          "snippet": "std::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstd::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifierFilter.Put",
          "args": [
            "(const byte *)\"abc\"",
            "3"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TestKeyPairValidAndConsistent",
          "args": [
            "verifier->AccessMaterial()",
            "signer->GetMaterial()"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "TestKeyPairValidAndConsistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "188-201",
          "snippet": "void TestKeyPairValidAndConsistent(CryptoMaterial &pub, const CryptoMaterial &priv)\n{\n\tif (!pub.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\tif (!priv.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\n\tByteQueue bq1, bq2;\n\tpub.Save(bq1);\n\tpub.AssignFrom(priv);\n\tpub.Save(bq2);\n\tif (bq1 != bq2)\n\t\tSignalTestFailure();\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool s_thorough;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic bool s_thorough;\n\nvoid TestKeyPairValidAndConsistent(CryptoMaterial &pub, const CryptoMaterial &priv)\n{\n\tif (!pub.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\tif (!priv.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\n\tByteQueue bq1, bq2;\n\tpub.Save(bq1);\n\tpub.AssignFrom(priv);\n\tpub.Save(bq2);\n\tif (bq1 != bq2)\n\t\tSignalTestFailure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "signer->GetMaterial",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier->AccessMaterial",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer->AccessMaterial",
          "args": [
            "pairs"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer->AccessMaterial",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer->AccessMaterial",
          "args": [
            "StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref()"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringStore",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "StringStore",
          "container": "StringStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "669-670",
          "snippet": "StringStore(const char *string = NULL)\n\t\t{StoreInitialize(MakeParameters(\"InputBuffer\", ConstByteArrayParameter(string)));}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringStore {\n  StringStore(const char *string = NULL)\n  \t\t{StoreInitialize(MakeParameters(\"InputBuffer\", ConstByteArrayParameter(string)));}\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringStore",
          "args": [
            "GetDecodedDatum(v, \"PrivateKey\")"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "StoreInitialize",
          "container": "StringStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.cpp",
          "lines": "1046-1054",
          "snippet": "void StringStore::StoreInitialize(const NameValuePairs &parameters)\n{\n\tConstByteArrayParameter array;\n\tif (!parameters.GetValue(Name::InputBuffer(), array))\n\t\tthrow InvalidArgument(\"StringStore: missing InputBuffer argument\");\n\tm_store = array.begin();\n\tm_length = array.size();\n\tm_count = 0;\n}",
          "includes": [
            "#include <functional>",
            "#include <memory>",
            "#include \"argnames.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"mqueue.h\"",
            "#include \"filters.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <functional>\n#include <memory>\n#include \"argnames.h\"\n#include \"fltrimpl.h\"\n#include \"mqueue.h\"\n#include \"filters.h\"\n#include \"pch.h\"\n\nStringStore {\n  void StringStore::StoreInitialize(const NameValuePairs &parameters)\n  {\n  \tConstByteArrayParameter array;\n  \tif (!parameters.GetValue(Name::InputBuffer(), array))\n  \t\tthrow InvalidArgument(\"StringStore: missing InputBuffer argument\");\n  \tm_store = array.begin();\n  \tm_length = array.size();\n  \tm_count = 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "signer->AccessMaterial",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier->GetMaterial",
          "args": [
            "GlobalRNG()",
            "3"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier->GetMaterial",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifierFilter.GetLastResult",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "374-374",
          "snippet": "bool GetLastResult() const {return m_hashVerifier.GetLastResult();}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nbool GetLastResult() const {return m_hashVerifier.GetLastResult();}"
        }
      },
      {
        "call_info": {
          "callee": "verifierFilter.MessageEnd",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "MessageEnd",
          "container": "DERGeneralEncoder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "504-511",
          "snippet": "void DERGeneralEncoder::MessageEnd()\n{\n\tm_finished = true;\n\tlword length = CurrentSize();\n\tm_outQueue.Put(m_asnTag);\n\tDERLengthEncode(m_outQueue, length);\n\tTransferTo(m_outQueue);\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nDERGeneralEncoder {\n  void DERGeneralEncoder::MessageEnd()\n  {\n  \tm_finished = true;\n  \tlword length = CurrentSize();\n  \tm_outQueue.Put(m_asnTag);\n  \tDERLengthEncode(m_outQueue, length);\n  \tTransferTo(m_outQueue);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PutDecodedDatumInto",
          "args": [
            "v",
            "\"Message\"",
            "verifierFilter"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "PutDecodedDatumInto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "73-121",
          "snippet": "void PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "verifier->AccessMaterial",
          "args": [
            "pairs"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier->AccessMaterial",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier->AccessMaterial",
          "args": [
            "StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref()"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier->AccessMaterial",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"KeyFormat\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier->AccessPublicKey",
          "args": [
            "signer->AccessPrivateKey()"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer->AccessPrivateKey",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verifier->AccessPublicKey",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer->AccessPrivateKey",
          "args": [
            "GlobalRNG()",
            "pairs"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signer->AccessPrivateKey",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<PK_Verifier>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<PK_Verifier>::Registry",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<PK_Signer>::Registry",
          "args": [
            "name.c_str()"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.c_str",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectFactoryRegistry<PK_Signer>::Registry",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Test\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "v",
            "\"Name\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid TestSignatureScheme(TestData &v)\n{\n\tstd::string name = GetRequiredDatum(v, \"Name\");\n\tstd::string test = GetRequiredDatum(v, \"Test\");\n\n\tstd::auto_ptr<PK_Signer> signer(ObjectFactoryRegistry<PK_Signer>::Registry().CreateObject(name.c_str()));\n\tstd::auto_ptr<PK_Verifier> verifier(ObjectFactoryRegistry<PK_Verifier>::Registry().CreateObject(name.c_str()));\n\n\tTestDataNameValuePairs pairs(v);\n\n\tif (test == \"GenerateKey\")\n\t{\n\t\tsigner->AccessPrivateKey().GenerateRandom(GlobalRNG(), pairs);\n\t\tverifier->AccessPublicKey().AssignFrom(signer->AccessPrivateKey());\n\t}\n\telse\n\t{\n\t\tstd::string keyFormat = GetRequiredDatum(v, \"KeyFormat\");\n\n\t\tif (keyFormat == \"DER\")\n\t\t\tverifier->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PublicKey\")).Ref());\n\t\telse if (keyFormat == \"Component\")\n\t\t\tverifier->AccessMaterial().AssignFrom(pairs);\n\n\t\tif (test == \"Verify\" || test == \"NotVerify\")\n\t\t{\n\t\t\tVerifierFilter verifierFilter(*verifier, NULL, VerifierFilter::SIGNATURE_AT_BEGIN);\n\t\t\tPutDecodedDatumInto(v, \"Signature\", verifierFilter);\n\t\t\tPutDecodedDatumInto(v, \"Message\", verifierFilter);\n\t\t\tverifierFilter.MessageEnd();\n\t\t\tif (verifierFilter.GetLastResult() == (test == \"NotVerify\"))\n\t\t\t\tSignalTestFailure();\n\t\t\treturn;\n\t\t}\n\t\telse if (test == \"PublicKeyValid\")\n\t\t{\n\t\t\tif (!verifier->GetMaterial().Validate(GlobalRNG(), 3))\n\t\t\t\tSignalTestFailure();\n\t\t\treturn;\n\t\t}\n\n\t\tif (keyFormat == \"DER\")\n\t\t\tsigner->AccessMaterial().Load(StringStore(GetDecodedDatum(v, \"PrivateKey\")).Ref());\n\t\telse if (keyFormat == \"Component\")\n\t\t\tsigner->AccessMaterial().AssignFrom(pairs);\n\t}\n\n\tif (test == \"GenerateKey\" || test == \"KeyPairValidAndConsistent\")\n\t{\n\t\tTestKeyPairValidAndConsistent(verifier->AccessMaterial(), signer->GetMaterial());\n\t\tVerifierFilter verifierFilter(*verifier, NULL, VerifierFilter::THROW_EXCEPTION);\n\t\tverifierFilter.Put((const byte *)\"abc\", 3);\n\t\tStringSource ss(\"abc\", true, new SignerFilter(GlobalRNG(), *signer, new Redirector(verifierFilter)));\n\t}\n\telse if (test == \"Sign\")\n\t{\n\t\tSignerFilter f(GlobalRNG(), *signer, new HexEncoder(new FileSink(cout)));\n\t\tStringSource ss(GetDecodedDatum(v, \"Message\"), true, new Redirector(f));\n\t\tSignalTestFailure();\n\t}\n\telse if (test == \"DeterministicSign\")\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\t// TODO: implement\n\t}\n\telse if (test == \"RandomSign\")\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\t// TODO: implement\n\t}\n\telse\n\t{\n\t\tSignalTestError();\n\t\tassert(false);\n\t}\n}"
  },
  {
    "function_name": "TestKeyPairValidAndConsistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "188-201",
    "snippet": "void TestKeyPairValidAndConsistent(CryptoMaterial &pub, const CryptoMaterial &priv)\n{\n\tif (!pub.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\tif (!priv.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\n\tByteQueue bq1, bq2;\n\tpub.Save(bq1);\n\tpub.AssignFrom(priv);\n\tpub.Save(bq2);\n\tif (bq1 != bq2)\n\t\tSignalTestFailure();\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool s_thorough;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignalTestFailure",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "35-39",
          "snippet": "static void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const TestData *s_currentTestData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pub.Save",
          "args": [
            "bq2"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "Save",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.h",
          "lines": "60-61",
          "snippet": "void Save(BufferedTransformation &bt) const\n\t\t{DEREncode(bt);}",
          "includes": [
            "#include \"pubkey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pubkey.h\"\n\nvoid Save(BufferedTransformation &bt) const\n\t\t{DEREncode(bt);}"
        }
      },
      {
        "call_info": {
          "callee": "pub.AssignFrom",
          "args": [
            "priv"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "AssignFrom",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "212-219",
          "snippet": "void InvertibleRabinFunction::AssignFrom(const NameValuePairs &source)\n{\n\tAssignFromHelper<RabinFunction>(this, source)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n\t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n\t\t;\n}",
          "includes": [
            "#include \"modarith.h\"",
            "#include \"sha.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rabin.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  void InvertibleRabinFunction::AssignFrom(const NameValuePairs &source)\n  {\n  \tAssignFromHelper<RabinFunction>(this, source)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime1)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(Prime2)\n  \t\tCRYPTOPP_SET_FUNCTION_ENTRY(MultiplicativeInverseOfPrime2ModPrime1)\n  \t\t;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "priv.Validate",
          "args": [
            "GlobalRNG()",
            "2+s_thorough"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "Validate",
          "container": "InvertibleRabinFunction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rabin.cpp",
          "lines": "183-201",
          "snippet": "bool InvertibleRabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n{\n\tbool pass = RabinFunction::Validate(rng, level);\n\tpass = pass && m_p > Integer::One() && m_p%4 == 3 && m_p < m_n;\n\tpass = pass && m_q > Integer::One() && m_q%4 == 3 && m_q < m_n;\n\tpass = pass && m_u.IsPositive() && m_u < m_p;\n\tif (level >= 1)\n\t{\n\t\tpass = pass && m_p * m_q == m_n;\n\t\tpass = pass && m_u * m_q % m_p == 1;\n\t\tpass = pass && Jacobi(m_r, m_p) == 1;\n\t\tpass = pass && Jacobi(m_r, m_q) == -1;\n\t\tpass = pass && Jacobi(m_s, m_p) == -1;\n\t\tpass = pass && Jacobi(m_s, m_q) == 1;\n\t}\n\tif (level >= 2)\n\t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n\treturn pass;\n}",
          "includes": [
            "#include \"modarith.h\"",
            "#include \"sha.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"rabin.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"modarith.h\"\n#include \"sha.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rabin.h\"\n#include \"pch.h\"\n\nInvertibleRabinFunction {\n  bool InvertibleRabinFunction::Validate(RandomNumberGenerator &rng, unsigned int level) const\n  {\n  \tbool pass = RabinFunction::Validate(rng, level);\n  \tpass = pass && m_p > Integer::One() && m_p%4 == 3 && m_p < m_n;\n  \tpass = pass && m_q > Integer::One() && m_q%4 == 3 && m_q < m_n;\n  \tpass = pass && m_u.IsPositive() && m_u < m_p;\n  \tif (level >= 1)\n  \t{\n  \t\tpass = pass && m_p * m_q == m_n;\n  \t\tpass = pass && m_u * m_q % m_p == 1;\n  \t\tpass = pass && Jacobi(m_r, m_p) == 1;\n  \t\tpass = pass && Jacobi(m_r, m_q) == -1;\n  \t\tpass = pass && Jacobi(m_s, m_p) == -1;\n  \t\tpass = pass && Jacobi(m_s, m_q) == 1;\n  \t}\n  \tif (level >= 2)\n  \t\tpass = pass && VerifyPrime(rng, m_p, level-2) && VerifyPrime(rng, m_q, level-2);\n  \treturn pass;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic bool s_thorough;\n\nvoid TestKeyPairValidAndConsistent(CryptoMaterial &pub, const CryptoMaterial &priv)\n{\n\tif (!pub.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\tif (!priv.Validate(GlobalRNG(), 2+s_thorough))\n\t\tSignalTestFailure();\n\n\tByteQueue bq1, bq2;\n\tpub.Save(bq1);\n\tpub.AssignFrom(priv);\n\tpub.Save(bq2);\n\tif (bq1 != bq2)\n\t\tSignalTestFailure();\n}"
  },
  {
    "function_name": "GetVoidValue",
    "container": "TestDataNameValuePairs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "143-181",
    "snippet": "virtual bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n\t{\n\t\tTestData::const_iterator i = m_data.find(name);\n\t\tif (i == m_data.end())\n\t\t{\n\t\t\tif (std::string(name) == Name::DigestSize() && valueType == typeid(int))\n\t\t\t{\n\t\t\t\ti = m_data.find(\"MAC\");\n\t\t\t\tif (i == m_data.end())\n\t\t\t\t\ti = m_data.find(\"Digest\");\n\t\t\t\tif (i == m_data.end())\n\t\t\t\t\treturn false;\n\n\t\t\t\tm_temp.resize(0);\n\t\t\t\tPutDecodedDatumInto(m_data, i->first.c_str(), StringSink(m_temp).Ref());\n\t\t\t\t*reinterpret_cast<int *>(pValue) = (int)m_temp.size();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\tconst std::string &value = i->second;\n\t\t\n\t\tif (valueType == typeid(int))\n\t\t\t*reinterpret_cast<int *>(pValue) = atoi(value.c_str());\n\t\telse if (valueType == typeid(Integer))\n\t\t\t*reinterpret_cast<Integer *>(pValue) = Integer((std::string(value) + \"h\").c_str());\n\t\telse if (valueType == typeid(ConstByteArrayParameter))\n\t\t{\n\t\t\tm_temp.resize(0);\n\t\t\tPutDecodedDatumInto(m_data, name, StringSink(m_temp).Ref());\n\t\t\treinterpret_cast<ConstByteArrayParameter *>(pValue)->Assign((const byte *)m_temp.data(), m_temp.size(), false);\n\t\t}\n\t\telse\n\t\t\tthrow ValueTypeMismatch(name, typeid(std::string), valueType);\n\n\t\treturn true;\n\t}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ValueTypeMismatch",
          "args": [
            "name",
            "typeid(std::string)",
            "valueType"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "std::string"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<ConstByteArrayParameter *>",
          "args": [
            "(const byte *)m_temp.data()",
            "m_temp.size()",
            "false"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_temp.size",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_temp.data",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "300-300",
          "snippet": "typename A::const_pointer data() const {return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<ConstByteArrayParameter *>",
          "args": [
            "pValue"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutDecodedDatumInto",
          "args": [
            "m_data",
            "name",
            "StringSink(m_temp).Ref()"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "PutDecodedDatumInto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "73-121",
          "snippet": "void PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [
            "m_temp"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "StringSinkTemplate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "594-595",
          "snippet": "void IsolatedInitialize(const NameValuePairs &parameters)\n\t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringSinkTemplate {\n  void IsolatedInitialize(const NameValuePairs &parameters)\n  \t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_temp.resize",
          "args": [
            "0"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "203-211",
          "snippet": "void resize(size_t newSize)\n\t{\n\t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n\t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n\t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n\t\tdelete [] this->m_ptr;\n\t\tthis->m_size = newSize;\n\t\tthis->m_ptr = newPtr;\n\t}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  void resize(size_t newSize)\n  \t{\n  \t\tmember_ptr<T> *newPtr = new member_ptr<T>[newSize];\n  \t\tfor (size_t i=0; i<this->m_size && i<newSize; i++)\n  \t\t\tnewPtr[i].reset(this->m_ptr[i].release());\n  \t\tdelete [] this->m_ptr;\n  \t\tthis->m_size = newSize;\n  \t\tthis->m_ptr = newPtr;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "ConstByteArrayParameter"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Integer",
          "args": [
            "(std::string(value) + \"h\").c_str()"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "InverseMod",
          "container": "Integer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/integer.cpp",
          "lines": "3983-4006",
          "snippet": "word Integer::InverseMod(word mod) const\n{\n\tword g0 = mod, g1 = *this % mod;\n\tword v0 = 0, v1 = 1;\n\tword y;\n\n\twhile (g1)\n\t{\n\t\tif (g1 == 1)\n\t\t\treturn v1;\n\t\ty = g0 / g1;\n\t\tg0 = g0 % g1;\n\t\tv0 += y * v1;\n\n\t\tif (!g0)\n\t\t\tbreak;\n\t\tif (g0 == 1)\n\t\t\treturn mod-v0;\n\t\ty = g1 / g0;\n\t\tg1 = g1 % g0;\n\t\tv1 += y * v0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <c_asm.h>",
            "#include <intrin.h>",
            "#include <iostream>",
            "#include \"cpu.h\"",
            "#include \"sha.h\"",
            "#include \"pubkey.h\"\t\t// for P1363_KDF2",
            "#include \"algparam.h\"",
            "#include \"words.h\"",
            "#include \"oids.h\"",
            "#include \"asn.h\"",
            "#include \"nbtheory.h\"",
            "#include \"modarith.h\"",
            "#include \"integer.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <c_asm.h>\n#include <intrin.h>\n#include <iostream>\n#include \"cpu.h\"\n#include \"sha.h\"\n#include \"pubkey.h\"\t\t// for P1363_KDF2\n#include \"algparam.h\"\n#include \"words.h\"\n#include \"oids.h\"\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"modarith.h\"\n#include \"integer.h\"\n#include \"pch.h\"\n\nInteger {\n  word Integer::InverseMod(word mod) const\n  {\n  \tword g0 = mod, g1 = *this % mod;\n  \tword v0 = 0, v1 = 1;\n  \tword y;\n  \n  \twhile (g1)\n  \t{\n  \t\tif (g1 == 1)\n  \t\t\treturn v1;\n  \t\ty = g0 / g1;\n  \t\tg0 = g0 % g1;\n  \t\tv0 += y * v1;\n  \n  \t\tif (!g0)\n  \t\t\tbreak;\n  \t\tif (g0 == 1)\n  \t\t\treturn mod-v0;\n  \t\ty = g1 / g0;\n  \t\tg1 = g1 % g0;\n  \t\tv1 += y * v0;\n  \t}\n  \treturn 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "value"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<Integer *>",
          "args": [
            "pValue"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "Integer"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "value.c_str()"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.c_str",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<int *>",
          "args": [
            "pValue"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "int"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<int *>",
          "args": [
            "pValue"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->first.c_str",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data.end",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_data.find",
          "args": [
            "\"Digest\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data.find",
          "args": [
            "\"MAC\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeid",
          "args": [
            "int"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Name::DigestSize",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "DigestSize",
          "container": "SHA3",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/sha3.h",
          "lines": "16-16",
          "snippet": "unsigned int DigestSize() const {return m_digestSize;}",
          "includes": [
            "#include \"secblock.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"secblock.h\"\n#include \"cryptlib.h\"\n\nSHA3 {\n  unsigned int DigestSize() const {return m_digestSize;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "name"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_data.find",
          "args": [
            "name"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nTestDataNameValuePairs {\n  virtual bool GetVoidValue(const char *name, const std::type_info &valueType, void *pValue) const\n  \t{\n  \t\tTestData::const_iterator i = m_data.find(name);\n  \t\tif (i == m_data.end())\n  \t\t{\n  \t\t\tif (std::string(name) == Name::DigestSize() && valueType == typeid(int))\n  \t\t\t{\n  \t\t\t\ti = m_data.find(\"MAC\");\n  \t\t\t\tif (i == m_data.end())\n  \t\t\t\t\ti = m_data.find(\"Digest\");\n  \t\t\t\tif (i == m_data.end())\n  \t\t\t\t\treturn false;\n  \n  \t\t\t\tm_temp.resize(0);\n  \t\t\t\tPutDecodedDatumInto(m_data, i->first.c_str(), StringSink(m_temp).Ref());\n  \t\t\t\t*reinterpret_cast<int *>(pValue) = (int)m_temp.size();\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t\telse\n  \t\t\t\treturn false;\n  \t\t}\n  \t\t\n  \t\tconst std::string &value = i->second;\n  \t\t\n  \t\tif (valueType == typeid(int))\n  \t\t\t*reinterpret_cast<int *>(pValue) = atoi(value.c_str());\n  \t\telse if (valueType == typeid(Integer))\n  \t\t\t*reinterpret_cast<Integer *>(pValue) = Integer((std::string(value) + \"h\").c_str());\n  \t\telse if (valueType == typeid(ConstByteArrayParameter))\n  \t\t{\n  \t\t\tm_temp.resize(0);\n  \t\t\tPutDecodedDatumInto(m_data, name, StringSink(m_temp).Ref());\n  \t\t\treinterpret_cast<ConstByteArrayParameter *>(pValue)->Assign((const byte *)m_temp.data(), m_temp.size(), false);\n  \t\t}\n  \t\telse\n  \t\t\tthrow ValueTypeMismatch(name, typeid(std::string), valueType);\n  \n  \t\treturn true;\n  \t}\n}"
  },
  {
    "function_name": "TestDataNameValuePairs",
    "container": "TestDataNameValuePairs",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "141-141",
    "snippet": "TestDataNameValuePairs(const TestData &data) : m_data(data) {}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nTestDataNameValuePairs {\n  TestDataNameValuePairs(const TestData &data) : m_data(data) {}\n}"
  },
  {
    "function_name": "GetOptionalDecodedDatum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "130-136",
    "snippet": "std::string GetOptionalDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tif (DataExists(data, name))\n\t\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PutDecodedDatumInto",
          "args": [
            "data",
            "name",
            "StringSink(s).Ref()"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "PutDecodedDatumInto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "73-121",
          "snippet": "void PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [
            "s"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "StringSinkTemplate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "594-595",
          "snippet": "void IsolatedInitialize(const NameValuePairs &parameters)\n\t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringSinkTemplate {\n  void IsolatedInitialize(const NameValuePairs &parameters)\n  \t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DataExists",
          "args": [
            "data",
            "name"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "DataExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "47-51",
          "snippet": "bool DataExists(const TestData &data, const char *name)\n{\n\tTestData::const_iterator i = data.find(name);\n\treturn (i != data.end());\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nbool DataExists(const TestData &data, const char *name)\n{\n\tTestData::const_iterator i = data.find(name);\n\treturn (i != data.end());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstd::string GetOptionalDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tif (DataExists(data, name))\n\t\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}"
  },
  {
    "function_name": "GetDecodedDatum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "123-128",
    "snippet": "std::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PutDecodedDatumInto",
          "args": [
            "data",
            "name",
            "StringSink(s).Ref()"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "PutDecodedDatumInto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "73-121",
          "snippet": "void PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSink",
          "args": [
            "s"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "IsolatedInitialize",
          "container": "StringSinkTemplate",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/filters.h",
          "lines": "594-595",
          "snippet": "void IsolatedInitialize(const NameValuePairs &parameters)\n\t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}",
          "includes": [
            "#include <deque>",
            "#include \"algparam.h\"",
            "#include \"queue.h\"",
            "#include \"smartptr.h\"",
            "#include \"misc.h\"",
            "#include \"secblock.h\"",
            "#include \"simple.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include \"algparam.h\"\n#include \"queue.h\"\n#include \"smartptr.h\"\n#include \"misc.h\"\n#include \"secblock.h\"\n#include \"simple.h\"\n\nStringSinkTemplate {\n  void IsolatedInitialize(const NameValuePairs &parameters)\n  \t\t{if (!parameters.GetValue(\"OutputStringPointer\", m_output)) throw InvalidArgument(\"StringSink: OutputStringPointer not specified\");}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstd::string GetDecodedDatum(const TestData &data, const char *name)\n{\n\tstd::string s;\n\tPutDecodedDatumInto(data, name, StringSink(s).Ref());\n\treturn s;\n}"
  },
  {
    "function_name": "PutDecodedDatumInto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "73-121",
    "snippet": "void PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RandomizedTransfer",
          "args": [
            "q",
            "target",
            "true"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "RandomizedTransfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "61-71",
          "snippet": "void RandomizedTransfer(BufferedTransformation &source, BufferedTransformation &target, bool finish, const std::string &channel=DEFAULT_CHANNEL)\n{\n\twhile (source.MaxRetrievable() > (finish ? 0 : 4096))\n\t{\n\t\tbyte buf[4096+64];\n\t\tsize_t start = GlobalRNG().GenerateWord32(0, 63);\n\t\tsize_t len = GlobalRNG().GenerateWord32(1, UnsignedMin(4096U, 3*source.MaxRetrievable()/2));\n\t\tlen = source.Get(buf+start, len);\n\t\ttarget.ChannelPut(channel, buf+start, len);\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid RandomizedTransfer(BufferedTransformation &source, BufferedTransformation &target, bool finish, const std::string &channel=DEFAULT_CHANNEL)\n{\n\twhile (source.MaxRetrievable() > (finish ? 0 : 4096))\n\t{\n\t\tbyte buf[4096+64];\n\t\tsize_t start = GlobalRNG().GenerateWord32(0, 63);\n\t\tsize_t len = GlobalRNG().GenerateWord32(1, UnsignedMin(4096U, 3*source.MaxRetrievable()/2));\n\t\tlen = source.Get(buf+start, len);\n\t\ttarget.ChannelPut(channel, buf+start, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "q.Put",
          "args": [
            "(const byte *)s2.data()",
            "s2.size()"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "EncodedObjectFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/asn.cpp",
          "lines": "300-374",
          "snippet": "void EncodedObjectFilter::Put(const byte *inString, size_t length)\n{\n\tif (m_nCurrentObject == m_nObjects)\n\t{\n\t\tAttachedTransformation()->Put(inString, length);\n\t\treturn;\n\t}\n\n\tLazyPutter lazyPutter(m_queue, inString, length);\n\n\twhile (m_queue.AnyRetrievable())\n\t{\n\t\tswitch (m_state)\n\t\t{\n\t\tcase IDENTIFIER:\n\t\t\tif (!m_queue.Get(m_id))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\tm_state = LENGTH;\t// fall through\n\t\tcase LENGTH:\n\t\t{\n\t\t\tbyte b;\n\t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n\t\t\t{\n\t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n\t\t\t\tm_level--;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tByteQueue::Walker walker(m_queue);\n\t\t\tbool definiteLength;\n\t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n\t\t\t\treturn;\n\t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n\t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n\t\t\t\tBERDecodeError();\n\t\t\tif (!definiteLength)\n\t\t\t{\n\t\t\t\tif (!(m_id & CONSTRUCTED))\n\t\t\t\t\tBERDecodeError();\n\t\t\t\tm_level++;\n\t\t\t\tm_state = IDENTIFIER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm_state = BODY;\t\t// fall through\n\t\t}\n\t\tcase BODY:\n\t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n\n\t\t\tif (m_lengthRemaining == 0)\n\t\t\t\tm_state = IDENTIFIER;\n\t\t}\n\n\t\tif (m_state == IDENTIFIER && m_level == 0)\n\t\t{\n\t\t\t// just finished processing a level 0 object\n\t\t\t++m_nCurrentObject;\n\n\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\tif (m_nCurrentObject == m_nObjects)\n\t\t\t{\n\t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageEnd();\n\n\t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n\t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n\n\t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include <time.h>",
            "#include <iomanip>",
            "#include \"asn.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <iomanip>\n#include \"asn.h\"\n#include \"pch.h\"\n\nEncodedObjectFilter {\n  void EncodedObjectFilter::Put(const byte *inString, size_t length)\n  {\n  \tif (m_nCurrentObject == m_nObjects)\n  \t{\n  \t\tAttachedTransformation()->Put(inString, length);\n  \t\treturn;\n  \t}\n  \n  \tLazyPutter lazyPutter(m_queue, inString, length);\n  \n  \twhile (m_queue.AnyRetrievable())\n  \t{\n  \t\tswitch (m_state)\n  \t\t{\n  \t\tcase IDENTIFIER:\n  \t\t\tif (!m_queue.Get(m_id))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\tm_state = LENGTH;\t// fall through\n  \t\tcase LENGTH:\n  \t\t{\n  \t\t\tbyte b;\n  \t\t\tif (m_level > 0 && m_id == 0 && m_queue.Peek(b) && b == 0)\n  \t\t\t{\n  \t\t\t\tm_queue.TransferTo(CurrentTarget(), 1);\n  \t\t\t\tm_level--;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tByteQueue::Walker walker(m_queue);\n  \t\t\tbool definiteLength;\n  \t\t\tif (!BERLengthDecode(walker, m_lengthRemaining, definiteLength))\n  \t\t\t\treturn;\n  \t\t\tm_queue.TransferTo(CurrentTarget(), walker.GetCurrentPosition());\n  \t\t\tif (!((m_id & CONSTRUCTED) || definiteLength))\n  \t\t\t\tBERDecodeError();\n  \t\t\tif (!definiteLength)\n  \t\t\t{\n  \t\t\t\tif (!(m_id & CONSTRUCTED))\n  \t\t\t\t\tBERDecodeError();\n  \t\t\t\tm_level++;\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t\t\tbreak;\n  \t\t\t}\n  \t\t\tm_state = BODY;\t\t// fall through\n  \t\t}\n  \t\tcase BODY:\n  \t\t\tm_lengthRemaining -= m_queue.TransferTo(CurrentTarget(), m_lengthRemaining);\n  \n  \t\t\tif (m_lengthRemaining == 0)\n  \t\t\t\tm_state = IDENTIFIER;\n  \t\t}\n  \n  \t\tif (m_state == IDENTIFIER && m_level == 0)\n  \t\t{\n  \t\t\t// just finished processing a level 0 object\n  \t\t\t++m_nCurrentObject;\n  \n  \t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_EACH_OBJECT)\n  \t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\tif (m_nCurrentObject == m_nObjects)\n  \t\t\t{\n  \t\t\t\tif (m_flags & PUT_MESSANGE_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageEnd();\n  \n  \t\t\t\tif (m_flags & PUT_MESSANGE_SERIES_END_AFTER_ALL_OBJECTS)\n  \t\t\t\t\tAttachedTransformation()->MessageSeriesEnd();\n  \n  \t\t\t\tm_queue.TransferAllTo(*AttachedTransformation());\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t}\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s2.size",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "s2.data",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "data",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "300-300",
          "snippet": "typename A::const_pointer data() const {return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  typename A::const_pointer data() const {return m_ptr;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "STDMIN(s1.find(' '), s1.length())"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "s1.find(' ')",
            "s1.length()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.length",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.find",
          "args": [
            "' '"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "s1.substr(0, s1.find(' '))",
            "true",
            "new HexDecoder(new StringSink(s2))"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "0",
            "s1.find(' ')"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.find",
          "args": [
            "' '"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "STDMIN(s1.find(' '), s1.length())"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "s1.find(' ')",
            "s1.length()"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.length",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.find",
          "args": [
            "' '"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StringSource",
          "args": [
            "s1.substr(2, s1.find(' '))",
            "true",
            "new HexDecoder(new StringSink(s2))"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "2",
            "s1.find(' ')"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.find",
          "args": [
            "' '"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "0",
            "2"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "s2.length() + 2"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s2.length",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "1",
            "s1.find('\\\"', 1)-1"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.find",
          "args": [
            "'\\\"'",
            "1"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "s1.find(' ')+1"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.find",
          "args": [
            "' '"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s1.c_str()+1"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.c_str",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s1.empty",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "303-303",
          "snippet": "bool empty() const {return m_size == 0;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  bool empty() const {return m_size == 0;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "s1.substr",
          "args": [
            "1"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRequiredDatum",
          "args": [
            "data",
            "name"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid PutDecodedDatumInto(const TestData &data, const char *name, BufferedTransformation &target)\n{\n\tstd::string s1 = GetRequiredDatum(data, name), s2;\n\tByteQueue q;\n\n\twhile (!s1.empty())\n\t{\n\t\twhile (s1[0] == ' ')\n\t\t{\n\t\t\ts1 = s1.substr(1);\n\t\t\tif (s1.empty())\n\t\t\t\tgoto end;\t// avoid invalid read if s1 is empty\n\t\t}\n\n\t\tint repeat = 1;\n\t\tif (s1[0] == 'r')\n\t\t{\n\t\t\trepeat = atoi(s1.c_str()+1);\n\t\t\ts1 = s1.substr(s1.find(' ')+1);\n\t\t}\n\t\t\n\t\ts2 = \"\"; // MSVC 6 doesn't have clear();\n\n\t\tif (s1[0] == '\\\"')\n\t\t{\n\t\t\ts2 = s1.substr(1, s1.find('\\\"', 1)-1);\n\t\t\ts1 = s1.substr(s2.length() + 2);\n\t\t}\n\t\telse if (s1.substr(0, 2) == \"0x\")\n\t\t{\n\t\t\tStringSource(s1.substr(2, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStringSource(s1.substr(0, s1.find(' ')), true, new HexDecoder(new StringSink(s2)));\n\t\t\ts1 = s1.substr(STDMIN(s1.find(' '), s1.length()));\n\t\t}\n\n\t\twhile (repeat--)\n\t\t{\n\t\t\tq.Put((const byte *)s2.data(), s2.size());\n\t\t\tRandomizedTransfer(q, target, false);\n\t\t}\n\t}\n\nend:\n\tRandomizedTransfer(q, target, true);\n}"
  },
  {
    "function_name": "RandomizedTransfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "61-71",
    "snippet": "void RandomizedTransfer(BufferedTransformation &source, BufferedTransformation &target, bool finish, const std::string &channel=DEFAULT_CHANNEL)\n{\n\twhile (source.MaxRetrievable() > (finish ? 0 : 4096))\n\t{\n\t\tbyte buf[4096+64];\n\t\tsize_t start = GlobalRNG().GenerateWord32(0, 63);\n\t\tsize_t len = GlobalRNG().GenerateWord32(1, UnsignedMin(4096U, 3*source.MaxRetrievable()/2));\n\t\tlen = source.Get(buf+start, len);\n\t\ttarget.ChannelPut(channel, buf+start, len);\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "target.ChannelPut",
          "args": [
            "channel",
            "buf+start",
            "len"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ChannelPut",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.h",
          "lines": "975-976",
          "snippet": "size_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)\n\t\t\t{return ChannelPut2(channel, inString, length, 0, blocking);}",
          "includes": [
            "#include \"stdcpp.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"stdcpp.h\"\n#include \"config.h\"\n\nsize_t ChannelPut(const std::string &channel, const byte *inString, size_t length, bool blocking=true)\n\t\t\t{return ChannelPut2(channel, inString, length, 0, blocking);}"
        }
      },
      {
        "call_info": {
          "callee": "source.Get",
          "args": [
            "buf+start",
            "len"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "ByteQueue::Walker",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/queue.cpp",
          "lines": "492-496",
          "snippet": "size_t ByteQueue::Walker::Get(byte *outString, size_t getMax)\n{\n\tArraySink sink(outString, getMax);\n\treturn (size_t)TransferTo(sink, getMax);\n}",
          "includes": [
            "#include \"filters.h\"",
            "#include \"queue.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filters.h\"\n#include \"queue.h\"\n#include \"pch.h\"\n\nByteQueue {\n  Walker {\n    size_t ByteQueue::Walker::Get(byte *outString, size_t getMax)\n    {\n    \tArraySink sink(outString, getMax);\n    \treturn (size_t)TransferTo(sink, getMax);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [
            "1",
            "UnsignedMin(4096U, 3*source.MaxRetrievable()/2)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnsignedMin",
          "args": [
            "4096U",
            "3*source.MaxRetrievable()/2"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "UnsignedMin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "182-192",
          "snippet": "inline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline const T1 UnsignedMin(const T1& a, const T2& b)\n{\n\tCRYPTOPP_COMPILE_ASSERT((sizeof(T1)<=sizeof(T2) && T2(-1)>0) || (sizeof(T1)>sizeof(T2) && T1(-1)>0));\n\tassert(a==0 || a>0);\t// GCC workaround: get rid of the warning \"comparison is always true due to limited range of data type\"\n\tassert(b>=0);\n\n\tif (sizeof(T1)<=sizeof(T2))\n\t\treturn b < (T2)a ? (T1)b : a;\n\telse\n\t\treturn (T1)b < a ? (T1)b : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "source.MaxRetrievable",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "MaxRetrievable",
          "container": "FileStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/files.cpp",
          "lines": "65-74",
          "snippet": "lword FileStore::MaxRetrievable() const\n{\n\tif (!m_stream)\n\t\treturn 0;\n\n\tstreampos current = m_stream->tellg();\n\tstreampos end = m_stream->seekg(0, ios::end).tellg();\n\tm_stream->seekg(current);\n\treturn end-current;\n}",
          "includes": [
            "#include <limits>",
            "#include \"files.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits>\n#include \"files.h\"\n#include \"pch.h\"\n\nFileStore {\n  lword FileStore::MaxRetrievable() const\n  {\n  \tif (!m_stream)\n  \t\treturn 0;\n  \n  \tstreampos current = m_stream->tellg();\n  \tstreampos end = m_stream->seekg(0, ios::end).tellg();\n  \tm_stream->seekg(current);\n  \treturn end-current;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [
            "0",
            "63"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GlobalRNG",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nvoid RandomizedTransfer(BufferedTransformation &source, BufferedTransformation &target, bool finish, const std::string &channel=DEFAULT_CHANNEL)\n{\n\twhile (source.MaxRetrievable() > (finish ? 0 : 4096))\n\t{\n\t\tbyte buf[4096+64];\n\t\tsize_t start = GlobalRNG().GenerateWord32(0, 63);\n\t\tsize_t len = GlobalRNG().GenerateWord32(1, UnsignedMin(4096U, 3*source.MaxRetrievable()/2));\n\t\tlen = source.Get(buf+start, len);\n\t\ttarget.ChannelPut(channel, buf+start, len);\n\t}\n}"
  },
  {
    "function_name": "DataExists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "47-51",
    "snippet": "bool DataExists(const TestData &data, const char *name)\n{\n\tTestData::const_iterator i = data.find(name);\n\treturn (i != data.end());\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data.end",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.find",
          "args": [
            "name"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nbool DataExists(const TestData &data, const char *name)\n{\n\tTestData::const_iterator i = data.find(name);\n\treturn (i != data.end());\n}"
  },
  {
    "function_name": "SignalTestError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "41-45",
    "snippet": "static void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const TestData *s_currentTestData = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Exception",
          "args": [
            "Exception::OTHER_ERROR",
            "\"Unexpected error during validation test\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OutputTestData",
          "args": [
            "*s_currentTestData"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "OutputTestData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "27-33",
          "snippet": "static void OutputTestData(const TestData &v)\n{\n\tfor (TestData::const_iterator i = v.begin(); i != v.end(); ++i)\n\t{\n\t\tcerr << i->first << \": \" << i->second << endl;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic void OutputTestData(const TestData &v)\n{\n\tfor (TestData::const_iterator i = v.begin(); i != v.end(); ++i)\n\t{\n\t\tcerr << i->first << \": \" << i->second << endl;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestError()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow Exception(Exception::OTHER_ERROR, \"Unexpected error during validation test\");\n}"
  },
  {
    "function_name": "SignalTestFailure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "35-39",
    "snippet": "static void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const TestData *s_currentTestData = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TestFailure",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "SignalTestFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "35-39",
          "snippet": "static void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "OutputTestData",
          "args": [
            "*s_currentTestData"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "OutputTestData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
          "lines": "27-33",
          "snippet": "static void OutputTestData(const TestData &v)\n{\n\tfor (TestData::const_iterator i = v.begin(); i != v.end(); ++i)\n\t{\n\t\tcerr << i->first << \": \" << i->second << endl;\n\t}\n}",
          "includes": [
            "#include <memory>",
            "#include <iostream>",
            "#include \"validate.h\"",
            "#include \"queue.h\"",
            "#include \"trunhash.h\"",
            "#include \"files.h\"",
            "#include \"randpool.h\"",
            "#include \"hex.h\"",
            "#include \"filters.h\"",
            "#include \"integer.h\"",
            "#include \"factory.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic void OutputTestData(const TestData &v)\n{\n\tfor (TestData::const_iterator i = v.begin(); i != v.end(); ++i)\n\t{\n\t\tcerr << i->first << \": \" << i->second << endl;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic const TestData *s_currentTestData = NULL;\n\nstatic void SignalTestFailure()\n{\n\tOutputTestData(*s_currentTestData);\n\tthrow TestFailure();\n}"
  },
  {
    "function_name": "OutputTestData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "27-33",
    "snippet": "static void OutputTestData(const TestData &v)\n{\n\tfor (TestData::const_iterator i = v.begin(); i != v.end(); ++i)\n\t{\n\t\tcerr << i->first << \": \" << i->second << endl;\n\t}\n}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v.end",
          "args": [],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "296-297",
          "snippet": "const_iterator end() const\n\t\t{return m_ptr+m_size;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator end() const\n  \t\t{return m_ptr+m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.begin",
          "args": [],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "292-293",
          "snippet": "const_iterator begin() const\n\t\t{return m_ptr;}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  const_iterator begin() const\n  \t\t{return m_ptr;}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nstatic void OutputTestData(const TestData &v)\n{\n\tfor (TestData::const_iterator i = v.begin(); i != v.end(); ++i)\n\t{\n\t\tcerr << i->first << \": \" << i->second << endl;\n\t}\n}"
  },
  {
    "function_name": "TestFailure",
    "container": "TestFailure",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/datatest.cpp",
    "lines": "22-22",
    "snippet": "TestFailure() : Exception(OTHER_ERROR, \"Validation test failed\") {}",
    "includes": [
      "#include <memory>",
      "#include <iostream>",
      "#include \"validate.h\"",
      "#include \"queue.h\"",
      "#include \"trunhash.h\"",
      "#include \"files.h\"",
      "#include \"randpool.h\"",
      "#include \"hex.h\"",
      "#include \"filters.h\"",
      "#include \"integer.h\"",
      "#include \"factory.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <memory>\n#include <iostream>\n#include \"validate.h\"\n#include \"queue.h\"\n#include \"trunhash.h\"\n#include \"files.h\"\n#include \"randpool.h\"\n#include \"hex.h\"\n#include \"filters.h\"\n#include \"integer.h\"\n#include \"factory.h\"\n\nTestFailure {\n  TestFailure() : Exception(OTHER_ERROR, \"Validation test failed\") {}\n}"
  }
]