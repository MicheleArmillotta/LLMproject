[
  {
    "function_name": "CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "240-248",
    "snippet": "void CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\tfor (unsigned int i=0; i<length; i++)\n\t{\n\t\tbyte b = message[i];\n\t\toutput[i] = reg[i] ^ b;\n\t\treg[i] = b;\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\tfor (unsigned int i=0; i<length; i++)\n\t{\n\t\tbyte b = message[i];\n\t\toutput[i] = reg[i] ^ b;\n\t\treg[i] = b;\n\t}\n}"
  },
  {
    "function_name": "CFB_EncryptionTemplate<BASE>::CombineMessageAndShiftRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "233-237",
    "snippet": "void CFB_EncryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\txorbuf(reg, message, length);\n\tmemcpy(output, reg, length);\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "output",
            "reg",
            "length"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "reg",
            "message",
            "length"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid CFB_EncryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\txorbuf(reg, message, length);\n\tmemcpy(output, reg, length);\n}"
  },
  {
    "function_name": "CFB_CipherTemplate<BASE>::ProcessData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "177-230",
    "snippet": "void CFB_CipherTemplate<BASE>::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tassert(length % this->MandatoryBlockSize() == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\tunsigned int alignment = policy.GetAlignment();\n\tbyte *reg = policy.GetRegisterBegin();\n\n\tif (m_leftOver)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\tCombineMessageAndShiftRegister(outString, reg + bytesPerIteration - m_leftOver, inString, len);\n\t\tm_leftOver -= len;\n\t\tlength -= len;\n\t\tinString += len;\n\t\toutString += len;\n\t}\n\n\tif (!length)\n\t\treturn;\n\n\tassert(m_leftOver == 0);\n\n\tif (policy.CanIterate() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))\n\t{\n\t\tif (IsAlignedOn(inString, alignment))\n\t\t\tpolicy.Iterate(outString, inString, GetCipherDir(*this), length / bytesPerIteration);\n\t\telse\n\t\t{\n\t\t\tmemcpy(outString, inString, length);\n\t\t\tpolicy.Iterate(outString, outString, GetCipherDir(*this), length / bytesPerIteration);\n\t\t}\n\t\tinString += length - length % bytesPerIteration;\n\t\toutString += length - length % bytesPerIteration;\n\t\tlength %= bytesPerIteration;\n\t}\n\n\twhile (length >= bytesPerIteration)\n\t{\n\t\tpolicy.TransformRegister();\n\t\tCombineMessageAndShiftRegister(outString, reg, inString, bytesPerIteration);\n\t\tlength -= bytesPerIteration;\n\t\tinString += bytesPerIteration;\n\t\toutString += bytesPerIteration;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tpolicy.TransformRegister();\n\t\tCombineMessageAndShiftRegister(outString, reg, inString, length);\n\t\tm_leftOver = bytesPerIteration - length;\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CombineMessageAndShiftRegister",
          "args": [
            "outString",
            "reg",
            "inString",
            "length"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
          "lines": "240-248",
          "snippet": "void CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\tfor (unsigned int i=0; i<length; i++)\n\t{\n\t\tbyte b = message[i];\n\t\toutput[i] = reg[i] ^ b;\n\t\treg[i] = b;\n\t}\n}",
          "includes": [
            "#include \"strciphr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\tfor (unsigned int i=0; i<length; i++)\n\t{\n\t\tbyte b = message[i];\n\t\toutput[i] = reg[i] ^ b;\n\t\treg[i] = b;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.TransformRegister",
          "args": [],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.TransformRegister",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.Iterate",
          "args": [
            "outString",
            "outString",
            "GetCipherDir(*this)",
            "length / bytesPerIteration"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCipherDir",
          "args": [
            "*this"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "GetCipherDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "438-441",
          "snippet": "inline CipherDir GetCipherDir(const T &obj)\n{\n\treturn obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline CipherDir GetCipherDir(const T &obj)\n{\n\treturn obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "inString",
            "length"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.Iterate",
          "args": [
            "outString",
            "inString",
            "GetCipherDir(*this)",
            "length / bytesPerIteration"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAlignedOn",
          "args": [
            "inString",
            "alignment"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "IsAlignedOn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "381-384",
          "snippet": "inline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.CanIterate",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_leftOver == 0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "m_leftOver",
            "length"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetRegisterBegin",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetAlignment",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length % this->MandatoryBlockSize() == 0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->MandatoryBlockSize",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "MandatoryBlockSize",
          "container": "CFB_RequireFullDataBlocks",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.h",
          "lines": "273-273",
          "snippet": "unsigned int MandatoryBlockSize() const {return this->OptimalBlockSize();}",
          "includes": [
            "#include \"strciphr.cpp\"",
            "#include \"argnames.h\"",
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.cpp\"\n#include \"argnames.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nCFB_RequireFullDataBlocks {\n  unsigned int MandatoryBlockSize() const {return this->OptimalBlockSize();}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid CFB_CipherTemplate<BASE>::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tassert(length % this->MandatoryBlockSize() == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\tunsigned int alignment = policy.GetAlignment();\n\tbyte *reg = policy.GetRegisterBegin();\n\n\tif (m_leftOver)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\tCombineMessageAndShiftRegister(outString, reg + bytesPerIteration - m_leftOver, inString, len);\n\t\tm_leftOver -= len;\n\t\tlength -= len;\n\t\tinString += len;\n\t\toutString += len;\n\t}\n\n\tif (!length)\n\t\treturn;\n\n\tassert(m_leftOver == 0);\n\n\tif (policy.CanIterate() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))\n\t{\n\t\tif (IsAlignedOn(inString, alignment))\n\t\t\tpolicy.Iterate(outString, inString, GetCipherDir(*this), length / bytesPerIteration);\n\t\telse\n\t\t{\n\t\t\tmemcpy(outString, inString, length);\n\t\t\tpolicy.Iterate(outString, outString, GetCipherDir(*this), length / bytesPerIteration);\n\t\t}\n\t\tinString += length - length % bytesPerIteration;\n\t\toutString += length - length % bytesPerIteration;\n\t\tlength %= bytesPerIteration;\n\t}\n\n\twhile (length >= bytesPerIteration)\n\t{\n\t\tpolicy.TransformRegister();\n\t\tCombineMessageAndShiftRegister(outString, reg, inString, bytesPerIteration);\n\t\tlength -= bytesPerIteration;\n\t\tinString += bytesPerIteration;\n\t\toutString += bytesPerIteration;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tpolicy.TransformRegister();\n\t\tCombineMessageAndShiftRegister(outString, reg, inString, length);\n\t\tm_leftOver = bytesPerIteration - length;\n\t}\n}"
  },
  {
    "function_name": "CFB_CipherTemplate<BASE>::Resynchronize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "169-174",
    "snippet": "void CFB_CipherTemplate<BASE>::Resynchronize(const byte *iv, int length)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherResynchronize(iv, this->ThrowIfInvalidIVLength(length));\n\tm_leftOver = policy.GetBytesPerIteration();\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CipherResynchronize",
          "args": [
            "iv",
            "this->ThrowIfInvalidIVLength(length)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->ThrowIfInvalidIVLength",
          "args": [
            "length"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid CFB_CipherTemplate<BASE>::Resynchronize(const byte *iv, int length)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherResynchronize(iv, this->ThrowIfInvalidIVLength(length));\n\tm_leftOver = policy.GetBytesPerIteration();\n}"
  },
  {
    "function_name": "CFB_CipherTemplate<BASE>::UncheckedSetKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "153-166",
    "snippet": "void CFB_CipherTemplate<BASE>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherSetKey(params, key, length);\n\n\tif (this->IsResynchronizable())\n\t{\n\t\tsize_t ivLength;\n\t\tconst byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);\n\t\tpolicy.CipherResynchronize(iv, ivLength);\n\t}\n\n\tm_leftOver = policy.GetBytesPerIteration();\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CipherResynchronize",
          "args": [
            "iv",
            "ivLength"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->GetIVAndThrowIfInvalid",
          "args": [
            "params",
            "ivLength"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->IsResynchronizable",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CipherSetKey",
          "args": [
            "params",
            "key",
            "length"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid CFB_CipherTemplate<BASE>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherSetKey(params, key, length);\n\n\tif (this->IsResynchronizable())\n\t{\n\t\tsize_t ivLength;\n\t\tconst byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);\n\t\tpolicy.CipherResynchronize(iv, ivLength);\n\t}\n\n\tm_leftOver = policy.GetBytesPerIteration();\n}"
  },
  {
    "function_name": "AdditiveCipherTemplate<BASE>::Seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "135-150",
    "snippet": "void AdditiveCipherTemplate<BASE>::Seek(lword position)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tpolicy.SeekToIteration(position / bytesPerIteration);\n\tposition %= bytesPerIteration;\n\n\tif (position > 0)\n\t{\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n\t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n\t}\n\telse\n\t\tm_leftOver = 0;\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.WriteKeystream",
          "args": [
            "KeystreamBufferEnd()-bytesPerIteration",
            "1"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.SeekToIteration",
          "args": [
            "position / bytesPerIteration"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid AdditiveCipherTemplate<BASE>::Seek(lword position)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tpolicy.SeekToIteration(position / bytesPerIteration);\n\tposition %= bytesPerIteration;\n\n\tif (position > 0)\n\t{\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n\t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n\t}\n\telse\n\t\tm_leftOver = 0;\n}"
  },
  {
    "function_name": "AdditiveCipherTemplate<S>::Resynchronize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "126-132",
    "snippet": "void AdditiveCipherTemplate<S>::Resynchronize(const byte *iv, int length)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tm_leftOver = 0;\n\tm_buffer.New(GetBufferByteSize(policy));\n\tpolicy.CipherResynchronize(m_buffer, iv, this->ThrowIfInvalidIVLength(length));\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.CipherResynchronize",
          "args": [
            "m_buffer",
            "iv",
            "this->ThrowIfInvalidIVLength(length)"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->ThrowIfInvalidIVLength",
          "args": [
            "length"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.New",
          "args": [
            "GetBufferByteSize(policy)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBufferByteSize",
          "args": [
            "policy"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "GetBufferByteSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.h",
          "lines": "153-153",
          "snippet": "unsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}",
          "includes": [
            "#include \"strciphr.cpp\"",
            "#include \"argnames.h\"",
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.cpp\"\n#include \"argnames.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nunsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}"
        }
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid AdditiveCipherTemplate<S>::Resynchronize(const byte *iv, int length)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tm_leftOver = 0;\n\tm_buffer.New(GetBufferByteSize(policy));\n\tpolicy.CipherResynchronize(m_buffer, iv, this->ThrowIfInvalidIVLength(length));\n}"
  },
  {
    "function_name": "AdditiveCipherTemplate<S>::ProcessData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "67-123",
    "snippet": "void AdditiveCipherTemplate<S>::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tif (m_leftOver > 0)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\txorbuf(outString, inString, KeystreamBufferEnd()-m_leftOver, len);\n\t\tlength -= len;\n\t\tm_leftOver -= len;\n\t\tinString += len;\n\t\toutString += len;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\tassert(m_leftOver == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tif (policy.CanOperateKeystream() && length >= bytesPerIteration)\n\t{\n\t\tsize_t iterations = length / bytesPerIteration;\n\t\tunsigned int alignment = policy.GetAlignment();\n\t\tKeystreamOperation operation = KeystreamOperation((IsAlignedOn(inString, alignment) * 2) | (int)IsAlignedOn(outString, alignment));\n\n\t\tpolicy.OperateKeystream(operation, outString, inString, iterations);\n\n\t\tinString += iterations * bytesPerIteration;\n\t\toutString += iterations * bytesPerIteration;\n\t\tlength -= iterations * bytesPerIteration;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\n\tsize_t bufferByteSize = m_buffer.size();\n\tsize_t bufferIterations = bufferByteSize / bytesPerIteration;\n\n\twhile (length >= bufferByteSize)\n\t{\n\t\tpolicy.WriteKeystream(m_buffer, bufferIterations);\n\t\txorbuf(outString, inString, KeystreamBufferBegin(), bufferByteSize);\n\t\tlength -= bufferByteSize;\n\t\tinString += bufferByteSize;\n\t\toutString += bufferByteSize;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tbufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);\n\t\tbufferIterations = bufferByteSize / bytesPerIteration;\n\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);\n\t\txorbuf(outString, inString, KeystreamBufferEnd()-bufferByteSize, length);\n\t\tm_leftOver = bufferByteSize - length;\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "outString",
            "inString",
            "KeystreamBufferEnd()-bufferByteSize",
            "length"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "47-77",
          "snippet": "void xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.WriteKeystream",
          "args": [
            "KeystreamBufferEnd()-bufferByteSize",
            "bufferIterations"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "length",
            "bytesPerIteration"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeystreamBufferBegin",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.WriteKeystream",
          "args": [
            "m_buffer",
            "bufferIterations"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.size",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.OperateKeystream",
          "args": [
            "operation",
            "outString",
            "inString",
            "iterations"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamOperation",
          "args": [
            "(IsAlignedOn(inString, alignment) * 2) | (int)IsAlignedOn(outString, alignment)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAlignedOn",
          "args": [
            "outString",
            "alignment"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "IsAlignedOn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "381-384",
          "snippet": "inline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.GetAlignment",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CanOperateKeystream",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_leftOver == 0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "m_leftOver",
            "length"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid AdditiveCipherTemplate<S>::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tif (m_leftOver > 0)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\txorbuf(outString, inString, KeystreamBufferEnd()-m_leftOver, len);\n\t\tlength -= len;\n\t\tm_leftOver -= len;\n\t\tinString += len;\n\t\toutString += len;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\tassert(m_leftOver == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tif (policy.CanOperateKeystream() && length >= bytesPerIteration)\n\t{\n\t\tsize_t iterations = length / bytesPerIteration;\n\t\tunsigned int alignment = policy.GetAlignment();\n\t\tKeystreamOperation operation = KeystreamOperation((IsAlignedOn(inString, alignment) * 2) | (int)IsAlignedOn(outString, alignment));\n\n\t\tpolicy.OperateKeystream(operation, outString, inString, iterations);\n\n\t\tinString += iterations * bytesPerIteration;\n\t\toutString += iterations * bytesPerIteration;\n\t\tlength -= iterations * bytesPerIteration;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\n\tsize_t bufferByteSize = m_buffer.size();\n\tsize_t bufferIterations = bufferByteSize / bytesPerIteration;\n\n\twhile (length >= bufferByteSize)\n\t{\n\t\tpolicy.WriteKeystream(m_buffer, bufferIterations);\n\t\txorbuf(outString, inString, KeystreamBufferBegin(), bufferByteSize);\n\t\tlength -= bufferByteSize;\n\t\tinString += bufferByteSize;\n\t\toutString += bufferByteSize;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tbufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);\n\t\tbufferIterations = bufferByteSize / bytesPerIteration;\n\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);\n\t\txorbuf(outString, inString, KeystreamBufferEnd()-bufferByteSize, length);\n\t\tm_leftOver = bufferByteSize - length;\n\t}\n}"
  },
  {
    "function_name": "AdditiveCipherTemplate<S>::GenerateBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "29-64",
    "snippet": "void AdditiveCipherTemplate<S>::GenerateBlock(byte *outString, size_t length)\n{\n\tif (m_leftOver > 0)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\tmemcpy(outString, KeystreamBufferEnd()-m_leftOver, len);\n\t\tlength -= len;\n\t\tm_leftOver -= len;\n\t\toutString += len;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\tassert(m_leftOver == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tif (length >= bytesPerIteration)\n\t{\n\t\tsize_t iterations = length / bytesPerIteration;\n\t\tpolicy.WriteKeystream(outString, iterations);\n\t\toutString += iterations * bytesPerIteration;\n\t\tlength -= iterations * bytesPerIteration;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tsize_t bufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);\n\t\tsize_t bufferIterations = bufferByteSize / bytesPerIteration;\n\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);\n\t\tmemcpy(outString, KeystreamBufferEnd()-bufferByteSize, length);\n\t\tm_leftOver = bufferByteSize - length;\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "KeystreamBufferEnd()-bufferByteSize",
            "length"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.WriteKeystream",
          "args": [
            "KeystreamBufferEnd()-bufferByteSize",
            "bufferIterations"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "length",
            "bytesPerIteration"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.WriteKeystream",
          "args": [
            "outString",
            "iterations"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_leftOver == 0"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "KeystreamBufferEnd()-m_leftOver",
            "len"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "m_leftOver",
            "length"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid AdditiveCipherTemplate<S>::GenerateBlock(byte *outString, size_t length)\n{\n\tif (m_leftOver > 0)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\tmemcpy(outString, KeystreamBufferEnd()-m_leftOver, len);\n\t\tlength -= len;\n\t\tm_leftOver -= len;\n\t\toutString += len;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\tassert(m_leftOver == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tif (length >= bytesPerIteration)\n\t{\n\t\tsize_t iterations = length / bytesPerIteration;\n\t\tpolicy.WriteKeystream(outString, iterations);\n\t\toutString += iterations * bytesPerIteration;\n\t\tlength -= iterations * bytesPerIteration;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tsize_t bufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);\n\t\tsize_t bufferIterations = bufferByteSize / bytesPerIteration;\n\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);\n\t\tmemcpy(outString, KeystreamBufferEnd()-bufferByteSize, length);\n\t\tm_leftOver = bufferByteSize - length;\n\t}\n}"
  },
  {
    "function_name": "AdditiveCipherTemplate<S>::UncheckedSetKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "12-26",
    "snippet": "void AdditiveCipherTemplate<S>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherSetKey(params, key, length);\n\tm_leftOver = 0;\n\tunsigned int bufferByteSize = policy.CanOperateKeystream() ? GetBufferByteSize(policy) : RoundUpToMultipleOf(1024U, GetBufferByteSize(policy));\n\tm_buffer.New(bufferByteSize);\n\n\tif (this->IsResynchronizable())\n\t{\n\t\tsize_t ivLength;\n\t\tconst byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);\n\t\tpolicy.CipherResynchronize(m_buffer, iv, ivLength);\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.CipherResynchronize",
          "args": [
            "m_buffer",
            "iv",
            "ivLength"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->GetIVAndThrowIfInvalid",
          "args": [
            "params",
            "ivLength"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->IsResynchronizable",
          "args": [],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.New",
          "args": [
            "bufferByteSize"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "1024U",
            "GetBufferByteSize(policy)"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBufferByteSize",
          "args": [
            "policy"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "GetBufferByteSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.h",
          "lines": "153-153",
          "snippet": "unsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}",
          "includes": [
            "#include \"strciphr.cpp\"",
            "#include \"argnames.h\"",
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.cpp\"\n#include \"argnames.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nunsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}"
        }
      },
      {
        "call_info": {
          "callee": "policy.CanOperateKeystream",
          "args": [],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CipherSetKey",
          "args": [
            "params",
            "key",
            "length"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nvoid AdditiveCipherTemplate<S>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherSetKey(params, key, length);\n\tm_leftOver = 0;\n\tunsigned int bufferByteSize = policy.CanOperateKeystream() ? GetBufferByteSize(policy) : RoundUpToMultipleOf(1024U, GetBufferByteSize(policy));\n\tm_buffer.New(bufferByteSize);\n\n\tif (this->IsResynchronizable())\n\t{\n\t\tsize_t ivLength;\n\t\tconst byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);\n\t\tpolicy.CipherResynchronize(m_buffer, iv, ivLength);\n\t}\n}"
  }
]