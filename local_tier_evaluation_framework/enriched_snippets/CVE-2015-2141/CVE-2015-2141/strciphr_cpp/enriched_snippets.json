[
  {
    "function_name": "CombineMessageAndShiftRegister",
    "container": "CFB_DecryptionTemplate<BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "240-248",
    "snippet": "void CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\tfor (unsigned int i=0; i<length; i++)\n\t{\n\t\tbyte b = message[i];\n\t\toutput[i] = reg[i] ^ b;\n\t\treg[i] = b;\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nCFB_DecryptionTemplate<BASE> {\n  void CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n  {\n  \tfor (unsigned int i=0; i<length; i++)\n  \t{\n  \t\tbyte b = message[i];\n  \t\toutput[i] = reg[i] ^ b;\n  \t\treg[i] = b;\n  \t}\n  }\n}"
  },
  {
    "function_name": "CombineMessageAndShiftRegister",
    "container": "CFB_EncryptionTemplate<BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "233-237",
    "snippet": "void CFB_EncryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\txorbuf(reg, message, length);\n\tmemcpy(output, reg, length);\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "output",
            "reg",
            "length"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "reg",
            "message",
            "length"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "17-45",
          "snippet": "void xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *buf, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(buf) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(buf) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)buf)[i] ^= ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\tbuf += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)buf)[i] ^= ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\tbuf += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\tbuf[i] ^= mask[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nCFB_EncryptionTemplate<BASE> {\n  void CFB_EncryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n  {\n  \txorbuf(reg, message, length);\n  \tmemcpy(output, reg, length);\n  }\n}"
  },
  {
    "function_name": "ProcessData",
    "container": "CFB_CipherTemplate<BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "177-230",
    "snippet": "void CFB_CipherTemplate<BASE>::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tassert(length % this->MandatoryBlockSize() == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\tunsigned int alignment = policy.GetAlignment();\n\tbyte *reg = policy.GetRegisterBegin();\n\n\tif (m_leftOver)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\tCombineMessageAndShiftRegister(outString, reg + bytesPerIteration - m_leftOver, inString, len);\n\t\tm_leftOver -= len;\n\t\tlength -= len;\n\t\tinString += len;\n\t\toutString += len;\n\t}\n\n\tif (!length)\n\t\treturn;\n\n\tassert(m_leftOver == 0);\n\n\tif (policy.CanIterate() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))\n\t{\n\t\tif (IsAlignedOn(inString, alignment))\n\t\t\tpolicy.Iterate(outString, inString, GetCipherDir(*this), length / bytesPerIteration);\n\t\telse\n\t\t{\n\t\t\tmemcpy(outString, inString, length);\n\t\t\tpolicy.Iterate(outString, outString, GetCipherDir(*this), length / bytesPerIteration);\n\t\t}\n\t\tinString += length - length % bytesPerIteration;\n\t\toutString += length - length % bytesPerIteration;\n\t\tlength %= bytesPerIteration;\n\t}\n\n\twhile (length >= bytesPerIteration)\n\t{\n\t\tpolicy.TransformRegister();\n\t\tCombineMessageAndShiftRegister(outString, reg, inString, bytesPerIteration);\n\t\tlength -= bytesPerIteration;\n\t\tinString += bytesPerIteration;\n\t\toutString += bytesPerIteration;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tpolicy.TransformRegister();\n\t\tCombineMessageAndShiftRegister(outString, reg, inString, length);\n\t\tm_leftOver = bytesPerIteration - length;\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CombineMessageAndShiftRegister",
          "args": [
            "outString",
            "reg",
            "inString",
            "length"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "CombineMessageAndShiftRegister",
          "container": "CFB_DecryptionTemplate<BASE>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
          "lines": "240-248",
          "snippet": "void CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n{\n\tfor (unsigned int i=0; i<length; i++)\n\t{\n\t\tbyte b = message[i];\n\t\toutput[i] = reg[i] ^ b;\n\t\treg[i] = b;\n\t}\n}",
          "includes": [
            "#include \"strciphr.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nCFB_DecryptionTemplate<BASE> {\n  void CFB_DecryptionTemplate<BASE>::CombineMessageAndShiftRegister(byte *output, byte *reg, const byte *message, size_t length)\n  {\n  \tfor (unsigned int i=0; i<length; i++)\n  \t{\n  \t\tbyte b = message[i];\n  \t\toutput[i] = reg[i] ^ b;\n  \t\treg[i] = b;\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.TransformRegister",
          "args": [],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "TransformRegister",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "48-55",
          "snippet": "void CFB_ModePolicy::TransformRegister()\n{\n\tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tm_cipher->ProcessBlock(m_register, m_temp);\n\tunsigned int updateSize = BlockSize()-m_feedbackSize;\n\tmemmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);\n\tmemcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::TransformRegister()\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tm_cipher->ProcessBlock(m_register, m_temp);\n  \tunsigned int updateSize = BlockSize()-m_feedbackSize;\n  \tmemmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);\n  \tmemcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.Iterate",
          "args": [
            "outString",
            "outString",
            "GetCipherDir(*this)",
            "length / bytesPerIteration"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "Iterate",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "27-46",
          "snippet": "void CFB_ModePolicy::Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount)\n{\n\tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tassert(m_feedbackSize == BlockSize());\n\n\tunsigned int s = BlockSize();\n\tif (dir == ENCRYPTION)\n\t{\n\t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n\t\tm_cipher->AdvancedProcessBlocks(output, input+s, output+s, (iterationCount-1)*s, 0);\n\t\tmemcpy(m_register, output+(iterationCount-1)*s, s);\n\t}\n\telse\n\t{\n\t\tmemcpy(m_temp, input+(iterationCount-1)*s, s);\t// make copy first in case of in-place decryption\n\t\tm_cipher->AdvancedProcessBlocks(input, input+s, output+s, (iterationCount-1)*s, BlockTransformation::BT_ReverseDirection);\n\t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n\t\tmemcpy(m_register, m_temp, s);\n\t}\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount)\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// CFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tassert(m_feedbackSize == BlockSize());\n  \n  \tunsigned int s = BlockSize();\n  \tif (dir == ENCRYPTION)\n  \t{\n  \t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n  \t\tm_cipher->AdvancedProcessBlocks(output, input+s, output+s, (iterationCount-1)*s, 0);\n  \t\tmemcpy(m_register, output+(iterationCount-1)*s, s);\n  \t}\n  \telse\n  \t{\n  \t\tmemcpy(m_temp, input+(iterationCount-1)*s, s);\t// make copy first in case of in-place decryption\n  \t\tm_cipher->AdvancedProcessBlocks(input, input+s, output+s, (iterationCount-1)*s, BlockTransformation::BT_ReverseDirection);\n  \t\tm_cipher->ProcessAndXorBlock(m_register, input, output);\n  \t\tmemcpy(m_register, m_temp, s);\n  \t}\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCipherDir",
          "args": [
            "*this"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "GetCipherDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "438-441",
          "snippet": "inline CipherDir GetCipherDir(const T &obj)\n{\n\treturn obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline CipherDir GetCipherDir(const T &obj)\n{\n\treturn obj.IsForwardTransformation() ? ENCRYPTION : DECRYPTION;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "inString",
            "length"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAlignedOn",
          "args": [
            "inString",
            "alignment"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "IsAlignedOn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "381-384",
          "snippet": "inline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.CanIterate",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_leftOver == 0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "m_leftOver",
            "length"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetRegisterBegin",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetAlignment",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "GetAlignment",
          "container": "PanamaCipherPolicy<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "476-484",
          "snippet": "unsigned int PanamaCipherPolicy<B>::GetAlignment() const\n{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n\t\treturn 16;\n\telse\n#endif\n\t\treturn 1;\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  unsigned int PanamaCipherPolicy<B>::GetAlignment() const\n  {\n  #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n  \tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n  \t\treturn 16;\n  \telse\n  #endif\n  \t\treturn 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "length % this->MandatoryBlockSize() == 0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->MandatoryBlockSize",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "MandatoryBlockSize",
          "container": "CFB_RequireFullDataBlocks",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.h",
          "lines": "273-273",
          "snippet": "unsigned int MandatoryBlockSize() const {return this->OptimalBlockSize();}",
          "includes": [
            "#include \"strciphr.cpp\"",
            "#include \"argnames.h\"",
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.cpp\"\n#include \"argnames.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nCFB_RequireFullDataBlocks {\n  unsigned int MandatoryBlockSize() const {return this->OptimalBlockSize();}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nCFB_CipherTemplate<BASE> {\n  void CFB_CipherTemplate<BASE>::ProcessData(byte *outString, const byte *inString, size_t length)\n  {\n  \tassert(length % this->MandatoryBlockSize() == 0);\n  \n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n  \tunsigned int alignment = policy.GetAlignment();\n  \tbyte *reg = policy.GetRegisterBegin();\n  \n  \tif (m_leftOver)\n  \t{\n  \t\tsize_t len = STDMIN(m_leftOver, length);\n  \t\tCombineMessageAndShiftRegister(outString, reg + bytesPerIteration - m_leftOver, inString, len);\n  \t\tm_leftOver -= len;\n  \t\tlength -= len;\n  \t\tinString += len;\n  \t\toutString += len;\n  \t}\n  \n  \tif (!length)\n  \t\treturn;\n  \n  \tassert(m_leftOver == 0);\n  \n  \tif (policy.CanIterate() && length >= bytesPerIteration && IsAlignedOn(outString, alignment))\n  \t{\n  \t\tif (IsAlignedOn(inString, alignment))\n  \t\t\tpolicy.Iterate(outString, inString, GetCipherDir(*this), length / bytesPerIteration);\n  \t\telse\n  \t\t{\n  \t\t\tmemcpy(outString, inString, length);\n  \t\t\tpolicy.Iterate(outString, outString, GetCipherDir(*this), length / bytesPerIteration);\n  \t\t}\n  \t\tinString += length - length % bytesPerIteration;\n  \t\toutString += length - length % bytesPerIteration;\n  \t\tlength %= bytesPerIteration;\n  \t}\n  \n  \twhile (length >= bytesPerIteration)\n  \t{\n  \t\tpolicy.TransformRegister();\n  \t\tCombineMessageAndShiftRegister(outString, reg, inString, bytesPerIteration);\n  \t\tlength -= bytesPerIteration;\n  \t\tinString += bytesPerIteration;\n  \t\toutString += bytesPerIteration;\n  \t}\n  \n  \tif (length > 0)\n  \t{\n  \t\tpolicy.TransformRegister();\n  \t\tCombineMessageAndShiftRegister(outString, reg, inString, length);\n  \t\tm_leftOver = bytesPerIteration - length;\n  \t}\n  }\n}"
  },
  {
    "function_name": "Resynchronize",
    "container": "CFB_CipherTemplate<BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "169-174",
    "snippet": "void CFB_CipherTemplate<BASE>::Resynchronize(const byte *iv, int length)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherResynchronize(iv, this->ThrowIfInvalidIVLength(length));\n\tm_leftOver = policy.GetBytesPerIteration();\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CipherResynchronize",
          "args": [
            "iv",
            "this->ThrowIfInvalidIVLength(length)"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "CipherResynchronize",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "57-62",
          "snippet": "void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)\n{\n\tassert(length == BlockSize());\n\tCopyOrZero(m_register, iv, length);\n\tTransformRegister();\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)\n  {\n  \tassert(length == BlockSize());\n  \tCopyOrZero(m_register, iv, length);\n  \tTransformRegister();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->ThrowIfInvalidIVLength",
          "args": [
            "length"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ThrowIfInvalidIVLength",
          "container": "SimpleKeyingInterface",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "94-104",
          "snippet": "size_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)\n{\n\tif (size < 0)\n\t\treturn IVSize();\n\telse if ((size_t)size < MinIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" is less than the minimum of \" + IntToString(MinIVLength()));\n\telse if ((size_t)size > MaxIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" exceeds the maximum of \" + IntToString(MaxIVLength()));\n\telse\n\t\treturn size;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nSimpleKeyingInterface {\n  size_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)\n  {\n  \tif (size < 0)\n  \t\treturn IVSize();\n  \telse if ((size_t)size < MinIVLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" is less than the minimum of \" + IntToString(MinIVLength()));\n  \telse if ((size_t)size > MaxIVLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" exceeds the maximum of \" + IntToString(MaxIVLength()));\n  \telse\n  \t\treturn size;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nCFB_CipherTemplate<BASE> {\n  void CFB_CipherTemplate<BASE>::Resynchronize(const byte *iv, int length)\n  {\n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tpolicy.CipherResynchronize(iv, this->ThrowIfInvalidIVLength(length));\n  \tm_leftOver = policy.GetBytesPerIteration();\n  }\n}"
  },
  {
    "function_name": "UncheckedSetKey",
    "container": "CFB_CipherTemplate<BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "153-166",
    "snippet": "void CFB_CipherTemplate<BASE>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherSetKey(params, key, length);\n\n\tif (this->IsResynchronizable())\n\t{\n\t\tsize_t ivLength;\n\t\tconst byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);\n\t\tpolicy.CipherResynchronize(iv, ivLength);\n\t}\n\n\tm_leftOver = policy.GetBytesPerIteration();\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CipherResynchronize",
          "args": [
            "iv",
            "ivLength"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "CipherResynchronize",
          "container": "CFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "57-62",
          "snippet": "void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)\n{\n\tassert(length == BlockSize());\n\tCopyOrZero(m_register, iv, length);\n\tTransformRegister();\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nCFB_ModePolicy {\n  void CFB_ModePolicy::CipherResynchronize(const byte *iv, size_t length)\n  {\n  \tassert(length == BlockSize());\n  \tCopyOrZero(m_register, iv, length);\n  \tTransformRegister();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->GetIVAndThrowIfInvalid",
          "args": [
            "params",
            "ivLength"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->IsResynchronizable",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CipherSetKey",
          "args": [
            "params",
            "key",
            "length"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "CipherSetKey",
          "container": "PanamaCipherPolicy<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "442-446",
          "snippet": "void PanamaCipherPolicy<B>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)\n{\n\tassert(length==32);\n\tmemcpy(m_key, key, 32);\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  void PanamaCipherPolicy<B>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)\n  {\n  \tassert(length==32);\n  \tmemcpy(m_key, key, 32);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nCFB_CipherTemplate<BASE> {\n  void CFB_CipherTemplate<BASE>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n  {\n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tpolicy.CipherSetKey(params, key, length);\n  \n  \tif (this->IsResynchronizable())\n  \t{\n  \t\tsize_t ivLength;\n  \t\tconst byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);\n  \t\tpolicy.CipherResynchronize(iv, ivLength);\n  \t}\n  \n  \tm_leftOver = policy.GetBytesPerIteration();\n  }\n}"
  },
  {
    "function_name": "Seek",
    "container": "AdditiveCipherTemplate<BASE>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "135-150",
    "snippet": "void AdditiveCipherTemplate<BASE>::Seek(lword position)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tpolicy.SeekToIteration(position / bytesPerIteration);\n\tposition %= bytesPerIteration;\n\n\tif (position > 0)\n\t{\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n\t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n\t}\n\telse\n\t\tm_leftOver = 0;\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.WriteKeystream",
          "args": [
            "KeystreamBufferEnd()-bytesPerIteration",
            "1"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "WriteKeystream",
          "container": "OFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "77-85",
          "snippet": "void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)\n{\n\tassert(m_cipher->IsForwardTransformation());\t// OFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tunsigned int s = BlockSize();\n\tm_cipher->ProcessBlock(m_register, keystreamBuffer);\n\tif (iterationCount > 1)\n\t\tm_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);\n\tmemcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nOFB_ModePolicy {\n  void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// OFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tunsigned int s = BlockSize();\n  \tm_cipher->ProcessBlock(m_register, keystreamBuffer);\n  \tif (iterationCount > 1)\n  \t\tm_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);\n  \tmemcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.SeekToIteration",
          "args": [
            "position / bytesPerIteration"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToIteration",
          "container": "SEAL_Policy<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/seal.cpp",
          "lines": "78-82",
          "snippet": "void SEAL_Policy<B>::SeekToIteration(lword iterationCount)\n{\n\tm_outsideCounter = m_startCount + (unsigned int)(iterationCount / m_iterationsPerCount);\n\tm_insideCounter = (unsigned int)(iterationCount % m_iterationsPerCount);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include \"sha.h\"",
            "#include \"seal.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include \"sha.h\"\n#include \"seal.h\"\n#include \"pch.h\"\n\nSEAL_Policy<B> {\n  void SEAL_Policy<B>::SeekToIteration(lword iterationCount)\n  {\n  \tm_outsideCounter = m_startCount + (unsigned int)(iterationCount / m_iterationsPerCount);\n  \tm_insideCounter = (unsigned int)(iterationCount % m_iterationsPerCount);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nAdditiveCipherTemplate<BASE> {\n  void AdditiveCipherTemplate<BASE>::Seek(lword position)\n  {\n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n  \n  \tpolicy.SeekToIteration(position / bytesPerIteration);\n  \tposition %= bytesPerIteration;\n  \n  \tif (position > 0)\n  \t{\n  \t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bytesPerIteration, 1);\n  \t\tm_leftOver = bytesPerIteration - (unsigned int)position;\n  \t}\n  \telse\n  \t\tm_leftOver = 0;\n  }\n}"
  },
  {
    "function_name": "Resynchronize",
    "container": "AdditiveCipherTemplate<S>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "126-132",
    "snippet": "void AdditiveCipherTemplate<S>::Resynchronize(const byte *iv, int length)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tm_leftOver = 0;\n\tm_buffer.New(GetBufferByteSize(policy));\n\tpolicy.CipherResynchronize(m_buffer, iv, this->ThrowIfInvalidIVLength(length));\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.CipherResynchronize",
          "args": [
            "m_buffer",
            "iv",
            "this->ThrowIfInvalidIVLength(length)"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "CipherResynchronize",
          "container": "PanamaCipherPolicy<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "449-472",
          "snippet": "void PanamaCipherPolicy<B>::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n{\n\tassert(length==32);\n\tthis->Reset();\n\tthis->Iterate(1, m_key);\n\tif (iv && IsAligned<word32>(iv))\n\t\tthis->Iterate(1, (const word32 *)iv);\n\telse\n\t{\n\t\tFixedSizeSecBlock<word32, 8> buf;\n\t\tif (iv)\n\t\t\tmemcpy(buf, iv, 32);\n\t\telse\n\t\t\tmemset(buf, 0, 32);\n\t\tthis->Iterate(1, buf);\n\t}\n\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2() && !IsP4())\t\t// SSE2 code is slower on P4 Prescott\n\t\tPanama_SSE2_Pull(32, this->m_state, NULL, NULL);\n\telse\n#endif\n\t\tthis->Iterate(32);\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  void PanamaCipherPolicy<B>::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n  {\n  \tassert(length==32);\n  \tthis->Reset();\n  \tthis->Iterate(1, m_key);\n  \tif (iv && IsAligned<word32>(iv))\n  \t\tthis->Iterate(1, (const word32 *)iv);\n  \telse\n  \t{\n  \t\tFixedSizeSecBlock<word32, 8> buf;\n  \t\tif (iv)\n  \t\t\tmemcpy(buf, iv, 32);\n  \t\telse\n  \t\t\tmemset(buf, 0, 32);\n  \t\tthis->Iterate(1, buf);\n  \t}\n  \n  #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n  \tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2() && !IsP4())\t\t// SSE2 code is slower on P4 Prescott\n  \t\tPanama_SSE2_Pull(32, this->m_state, NULL, NULL);\n  \telse\n  #endif\n  \t\tthis->Iterate(32);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->ThrowIfInvalidIVLength",
          "args": [
            "length"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ThrowIfInvalidIVLength",
          "container": "SimpleKeyingInterface",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/cryptlib.cpp",
          "lines": "94-104",
          "snippet": "size_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)\n{\n\tif (size < 0)\n\t\treturn IVSize();\n\telse if ((size_t)size < MinIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" is less than the minimum of \" + IntToString(MinIVLength()));\n\telse if ((size_t)size > MaxIVLength())\n\t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" exceeds the maximum of \" + IntToString(MaxIVLength()));\n\telse\n\t\treturn size;\n}",
          "includes": [
            "#include <memory>",
            "#include \"osrng.h\"",
            "#include \"trdlocal.h\"",
            "#include \"fltrimpl.h\"",
            "#include \"argnames.h\"",
            "#include \"fips140.h\"",
            "#include \"algparam.h\"",
            "#include \"filters.h\"",
            "#include \"misc.h\"",
            "#include \"cryptlib.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <memory>\n#include \"osrng.h\"\n#include \"trdlocal.h\"\n#include \"fltrimpl.h\"\n#include \"argnames.h\"\n#include \"fips140.h\"\n#include \"algparam.h\"\n#include \"filters.h\"\n#include \"misc.h\"\n#include \"cryptlib.h\"\n#include \"pch.h\"\n\nSimpleKeyingInterface {\n  size_t SimpleKeyingInterface::ThrowIfInvalidIVLength(int size)\n  {\n  \tif (size < 0)\n  \t\treturn IVSize();\n  \telse if ((size_t)size < MinIVLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" is less than the minimum of \" + IntToString(MinIVLength()));\n  \telse if ((size_t)size > MaxIVLength())\n  \t\tthrow InvalidArgument(GetAlgorithm().AlgorithmName() + \": IV length \" + IntToString(size) + \" exceeds the maximum of \" + IntToString(MaxIVLength()));\n  \telse\n  \t\treturn size;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_buffer.New",
          "args": [
            "GetBufferByteSize(policy)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBufferByteSize",
          "args": [
            "policy"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "GetBufferByteSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.h",
          "lines": "153-153",
          "snippet": "unsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}",
          "includes": [
            "#include \"strciphr.cpp\"",
            "#include \"argnames.h\"",
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.cpp\"\n#include \"argnames.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nunsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}"
        }
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nAdditiveCipherTemplate<S> {\n  void AdditiveCipherTemplate<S>::Resynchronize(const byte *iv, int length)\n  {\n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tm_leftOver = 0;\n  \tm_buffer.New(GetBufferByteSize(policy));\n  \tpolicy.CipherResynchronize(m_buffer, iv, this->ThrowIfInvalidIVLength(length));\n  }\n}"
  },
  {
    "function_name": "ProcessData",
    "container": "AdditiveCipherTemplate<S>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "67-123",
    "snippet": "void AdditiveCipherTemplate<S>::ProcessData(byte *outString, const byte *inString, size_t length)\n{\n\tif (m_leftOver > 0)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\txorbuf(outString, inString, KeystreamBufferEnd()-m_leftOver, len);\n\t\tlength -= len;\n\t\tm_leftOver -= len;\n\t\tinString += len;\n\t\toutString += len;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\tassert(m_leftOver == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tif (policy.CanOperateKeystream() && length >= bytesPerIteration)\n\t{\n\t\tsize_t iterations = length / bytesPerIteration;\n\t\tunsigned int alignment = policy.GetAlignment();\n\t\tKeystreamOperation operation = KeystreamOperation((IsAlignedOn(inString, alignment) * 2) | (int)IsAlignedOn(outString, alignment));\n\n\t\tpolicy.OperateKeystream(operation, outString, inString, iterations);\n\n\t\tinString += iterations * bytesPerIteration;\n\t\toutString += iterations * bytesPerIteration;\n\t\tlength -= iterations * bytesPerIteration;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\n\tsize_t bufferByteSize = m_buffer.size();\n\tsize_t bufferIterations = bufferByteSize / bytesPerIteration;\n\n\twhile (length >= bufferByteSize)\n\t{\n\t\tpolicy.WriteKeystream(m_buffer, bufferIterations);\n\t\txorbuf(outString, inString, KeystreamBufferBegin(), bufferByteSize);\n\t\tlength -= bufferByteSize;\n\t\tinString += bufferByteSize;\n\t\toutString += bufferByteSize;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tbufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);\n\t\tbufferIterations = bufferByteSize / bytesPerIteration;\n\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);\n\t\txorbuf(outString, inString, KeystreamBufferEnd()-bufferByteSize, length);\n\t\tm_leftOver = bufferByteSize - length;\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xorbuf",
          "args": [
            "outString",
            "inString",
            "KeystreamBufferEnd()-bufferByteSize",
            "length"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "xorbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.cpp",
          "lines": "47-77",
          "snippet": "void xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}",
          "includes": [
            "#include <malloc.h>",
            "#include <new>",
            "#include \"words.h\"",
            "#include \"misc.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <malloc.h>\n#include <new>\n#include \"words.h\"\n#include \"misc.h\"\n#include \"pch.h\"\n\nvoid xorbuf(byte *output, const byte *input, const byte *mask, size_t count)\n{\n\tsize_t i;\n\n\tif (IsAligned<word32>(output) && IsAligned<word32>(input) && IsAligned<word32>(mask))\n\t{\n\t\tif (!CRYPTOPP_BOOL_SLOW_WORD64 && IsAligned<word64>(output) && IsAligned<word64>(input) && IsAligned<word64>(mask))\n\t\t{\n\t\t\tfor (i=0; i<count/8; i++)\n\t\t\t\t((word64*)output)[i] = ((word64*)input)[i] ^ ((word64*)mask)[i];\n\t\t\tcount -= 8*i;\n\t\t\tif (!count)\n\t\t\t\treturn;\n\t\t\toutput += 8*i;\n\t\t\tinput += 8*i;\n\t\t\tmask += 8*i;\n\t\t}\n\n\t\tfor (i=0; i<count/4; i++)\n\t\t\t((word32*)output)[i] = ((word32*)input)[i] ^ ((word32*)mask)[i];\n\t\tcount -= 4*i;\n\t\tif (!count)\n\t\t\treturn;\n\t\toutput += 4*i;\n\t\tinput += 4*i;\n\t\tmask += 4*i;\n\t}\n\n\tfor (i=0; i<count; i++)\n\t\toutput[i] = input[i] ^ mask[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.WriteKeystream",
          "args": [
            "KeystreamBufferEnd()-bufferByteSize",
            "bufferIterations"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "WriteKeystream",
          "container": "OFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "77-85",
          "snippet": "void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)\n{\n\tassert(m_cipher->IsForwardTransformation());\t// OFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tunsigned int s = BlockSize();\n\tm_cipher->ProcessBlock(m_register, keystreamBuffer);\n\tif (iterationCount > 1)\n\t\tm_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);\n\tmemcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nOFB_ModePolicy {\n  void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// OFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tunsigned int s = BlockSize();\n  \tm_cipher->ProcessBlock(m_register, keystreamBuffer);\n  \tif (iterationCount > 1)\n  \t\tm_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);\n  \tmemcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "length",
            "bytesPerIteration"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeystreamBufferBegin",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.size",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "vector_member_ptrs",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/smartptr.h",
          "lines": "202-202",
          "snippet": "size_t size() const {return this->m_size;}",
          "includes": [
            "#include <algorithm>",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include \"config.h\"\n\nvector_member_ptrs {\n  size_t size() const {return this->m_size;}\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.OperateKeystream",
          "args": [
            "operation",
            "outString",
            "inString",
            "iterations"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "OperateKeystream",
          "container": "PanamaCipherPolicy<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "488-496",
          "snippet": "void PanamaCipherPolicy<B>::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)\n{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n\t\tPanama_SSE2_Pull(iterationCount, this->m_state, (word32 *)output, (const word32 *)input);\n\telse\n#endif\n\t\tthis->Iterate(iterationCount, NULL, output, input, operation);\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  void PanamaCipherPolicy<B>::OperateKeystream(KeystreamOperation operation, byte *output, const byte *input, size_t iterationCount)\n  {\n  #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n  \tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n  \t\tPanama_SSE2_Pull(iterationCount, this->m_state, (word32 *)output, (const word32 *)input);\n  \telse\n  #endif\n  \t\tthis->Iterate(iterationCount, NULL, output, input, operation);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeystreamOperation",
          "args": [
            "(IsAlignedOn(inString, alignment) * 2) | (int)IsAlignedOn(outString, alignment)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsAlignedOn",
          "args": [
            "outString",
            "alignment"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "IsAlignedOn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "381-384",
          "snippet": "inline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline bool IsAlignedOn(const void *p, unsigned int alignment)\n{\n\treturn alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.GetAlignment",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "GetAlignment",
          "container": "PanamaCipherPolicy<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "476-484",
          "snippet": "unsigned int PanamaCipherPolicy<B>::GetAlignment() const\n{\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n\t\treturn 16;\n\telse\n#endif\n\t\treturn 1;\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  unsigned int PanamaCipherPolicy<B>::GetAlignment() const\n  {\n  #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n  \tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2())\n  \t\treturn 16;\n  \telse\n  #endif\n  \t\treturn 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.CanOperateKeystream",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_leftOver == 0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "m_leftOver",
            "length"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nAdditiveCipherTemplate<S> {\n  void AdditiveCipherTemplate<S>::ProcessData(byte *outString, const byte *inString, size_t length)\n  {\n  \tif (m_leftOver > 0)\n  \t{\n  \t\tsize_t len = STDMIN(m_leftOver, length);\n  \t\txorbuf(outString, inString, KeystreamBufferEnd()-m_leftOver, len);\n  \t\tlength -= len;\n  \t\tm_leftOver -= len;\n  \t\tinString += len;\n  \t\toutString += len;\n  \n  \t\tif (!length)\n  \t\t\treturn;\n  \t}\n  \tassert(m_leftOver == 0);\n  \n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n  \n  \tif (policy.CanOperateKeystream() && length >= bytesPerIteration)\n  \t{\n  \t\tsize_t iterations = length / bytesPerIteration;\n  \t\tunsigned int alignment = policy.GetAlignment();\n  \t\tKeystreamOperation operation = KeystreamOperation((IsAlignedOn(inString, alignment) * 2) | (int)IsAlignedOn(outString, alignment));\n  \n  \t\tpolicy.OperateKeystream(operation, outString, inString, iterations);\n  \n  \t\tinString += iterations * bytesPerIteration;\n  \t\toutString += iterations * bytesPerIteration;\n  \t\tlength -= iterations * bytesPerIteration;\n  \n  \t\tif (!length)\n  \t\t\treturn;\n  \t}\n  \n  \tsize_t bufferByteSize = m_buffer.size();\n  \tsize_t bufferIterations = bufferByteSize / bytesPerIteration;\n  \n  \twhile (length >= bufferByteSize)\n  \t{\n  \t\tpolicy.WriteKeystream(m_buffer, bufferIterations);\n  \t\txorbuf(outString, inString, KeystreamBufferBegin(), bufferByteSize);\n  \t\tlength -= bufferByteSize;\n  \t\tinString += bufferByteSize;\n  \t\toutString += bufferByteSize;\n  \t}\n  \n  \tif (length > 0)\n  \t{\n  \t\tbufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);\n  \t\tbufferIterations = bufferByteSize / bytesPerIteration;\n  \n  \t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);\n  \t\txorbuf(outString, inString, KeystreamBufferEnd()-bufferByteSize, length);\n  \t\tm_leftOver = bufferByteSize - length;\n  \t}\n  }\n}"
  },
  {
    "function_name": "GenerateBlock",
    "container": "AdditiveCipherTemplate<S>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "29-64",
    "snippet": "void AdditiveCipherTemplate<S>::GenerateBlock(byte *outString, size_t length)\n{\n\tif (m_leftOver > 0)\n\t{\n\t\tsize_t len = STDMIN(m_leftOver, length);\n\t\tmemcpy(outString, KeystreamBufferEnd()-m_leftOver, len);\n\t\tlength -= len;\n\t\tm_leftOver -= len;\n\t\toutString += len;\n\n\t\tif (!length)\n\t\t\treturn;\n\t}\n\tassert(m_leftOver == 0);\n\n\tPolicyInterface &policy = this->AccessPolicy();\n\tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n\n\tif (length >= bytesPerIteration)\n\t{\n\t\tsize_t iterations = length / bytesPerIteration;\n\t\tpolicy.WriteKeystream(outString, iterations);\n\t\toutString += iterations * bytesPerIteration;\n\t\tlength -= iterations * bytesPerIteration;\n\t}\n\n\tif (length > 0)\n\t{\n\t\tsize_t bufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);\n\t\tsize_t bufferIterations = bufferByteSize / bytesPerIteration;\n\n\t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);\n\t\tmemcpy(outString, KeystreamBufferEnd()-bufferByteSize, length);\n\t\tm_leftOver = bufferByteSize - length;\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "KeystreamBufferEnd()-bufferByteSize",
            "length"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.WriteKeystream",
          "args": [
            "KeystreamBufferEnd()-bufferByteSize",
            "bufferIterations"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "WriteKeystream",
          "container": "OFB_ModePolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/modes.cpp",
          "lines": "77-85",
          "snippet": "void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)\n{\n\tassert(m_cipher->IsForwardTransformation());\t// OFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n\tunsigned int s = BlockSize();\n\tm_cipher->ProcessBlock(m_register, keystreamBuffer);\n\tif (iterationCount > 1)\n\t\tm_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);\n\tmemcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);\n}",
          "includes": [
            "#include \"des.h\"",
            "#include \"modes.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"des.h\"\n#include \"modes.h\"\n#include \"pch.h\"\n\nOFB_ModePolicy {\n  void OFB_ModePolicy::WriteKeystream(byte *keystreamBuffer, size_t iterationCount)\n  {\n  \tassert(m_cipher->IsForwardTransformation());\t// OFB mode needs the \"encrypt\" direction of the underlying block cipher, even to decrypt\n  \tunsigned int s = BlockSize();\n  \tm_cipher->ProcessBlock(m_register, keystreamBuffer);\n  \tif (iterationCount > 1)\n  \t\tm_cipher->AdvancedProcessBlocks(keystreamBuffer, NULL, keystreamBuffer+s, s*(iterationCount-1), 0);\n  \tmemcpy(m_register, keystreamBuffer+s*(iterationCount-1), s);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "length",
            "bytesPerIteration"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy.GetBytesPerIteration",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "m_leftOver == 0"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "outString",
            "KeystreamBufferEnd()-m_leftOver",
            "len"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KeystreamBufferEnd",
          "args": [],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STDMIN",
          "args": [
            "m_leftOver",
            "length"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nAdditiveCipherTemplate<S> {\n  void AdditiveCipherTemplate<S>::GenerateBlock(byte *outString, size_t length)\n  {\n  \tif (m_leftOver > 0)\n  \t{\n  \t\tsize_t len = STDMIN(m_leftOver, length);\n  \t\tmemcpy(outString, KeystreamBufferEnd()-m_leftOver, len);\n  \t\tlength -= len;\n  \t\tm_leftOver -= len;\n  \t\toutString += len;\n  \n  \t\tif (!length)\n  \t\t\treturn;\n  \t}\n  \tassert(m_leftOver == 0);\n  \n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tunsigned int bytesPerIteration = policy.GetBytesPerIteration();\n  \n  \tif (length >= bytesPerIteration)\n  \t{\n  \t\tsize_t iterations = length / bytesPerIteration;\n  \t\tpolicy.WriteKeystream(outString, iterations);\n  \t\toutString += iterations * bytesPerIteration;\n  \t\tlength -= iterations * bytesPerIteration;\n  \t}\n  \n  \tif (length > 0)\n  \t{\n  \t\tsize_t bufferByteSize = RoundUpToMultipleOf(length, bytesPerIteration);\n  \t\tsize_t bufferIterations = bufferByteSize / bytesPerIteration;\n  \n  \t\tpolicy.WriteKeystream(KeystreamBufferEnd()-bufferByteSize, bufferIterations);\n  \t\tmemcpy(outString, KeystreamBufferEnd()-bufferByteSize, length);\n  \t\tm_leftOver = bufferByteSize - length;\n  \t}\n  }\n}"
  },
  {
    "function_name": "UncheckedSetKey",
    "container": "AdditiveCipherTemplate<S>",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.cpp",
    "lines": "12-26",
    "snippet": "void AdditiveCipherTemplate<S>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n{\n\tPolicyInterface &policy = this->AccessPolicy();\n\tpolicy.CipherSetKey(params, key, length);\n\tm_leftOver = 0;\n\tunsigned int bufferByteSize = policy.CanOperateKeystream() ? GetBufferByteSize(policy) : RoundUpToMultipleOf(1024U, GetBufferByteSize(policy));\n\tm_buffer.New(bufferByteSize);\n\n\tif (this->IsResynchronizable())\n\t{\n\t\tsize_t ivLength;\n\t\tconst byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);\n\t\tpolicy.CipherResynchronize(m_buffer, iv, ivLength);\n\t}\n}",
    "includes": [
      "#include \"strciphr.h\"",
      "#include \"pch.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy.CipherResynchronize",
          "args": [
            "m_buffer",
            "iv",
            "ivLength"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "CipherResynchronize",
          "container": "PanamaCipherPolicy<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "449-472",
          "snippet": "void PanamaCipherPolicy<B>::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n{\n\tassert(length==32);\n\tthis->Reset();\n\tthis->Iterate(1, m_key);\n\tif (iv && IsAligned<word32>(iv))\n\t\tthis->Iterate(1, (const word32 *)iv);\n\telse\n\t{\n\t\tFixedSizeSecBlock<word32, 8> buf;\n\t\tif (iv)\n\t\t\tmemcpy(buf, iv, 32);\n\t\telse\n\t\t\tmemset(buf, 0, 32);\n\t\tthis->Iterate(1, buf);\n\t}\n\n#if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n\tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2() && !IsP4())\t\t// SSE2 code is slower on P4 Prescott\n\t\tPanama_SSE2_Pull(32, this->m_state, NULL, NULL);\n\telse\n#endif\n\t\tthis->Iterate(32);\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  void PanamaCipherPolicy<B>::CipherResynchronize(byte *keystreamBuffer, const byte *iv, size_t length)\n  {\n  \tassert(length==32);\n  \tthis->Reset();\n  \tthis->Iterate(1, m_key);\n  \tif (iv && IsAligned<word32>(iv))\n  \t\tthis->Iterate(1, (const word32 *)iv);\n  \telse\n  \t{\n  \t\tFixedSizeSecBlock<word32, 8> buf;\n  \t\tif (iv)\n  \t\t\tmemcpy(buf, iv, 32);\n  \t\telse\n  \t\t\tmemset(buf, 0, 32);\n  \t\tthis->Iterate(1, buf);\n  \t}\n  \n  #if CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)\n  \tif (B::ToEnum() == LITTLE_ENDIAN_ORDER && HasSSE2() && !IsP4())\t\t// SSE2 code is slower on P4 Prescott\n  \t\tPanama_SSE2_Pull(32, this->m_state, NULL, NULL);\n  \telse\n  #endif\n  \t\tthis->Iterate(32);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->GetIVAndThrowIfInvalid",
          "args": [
            "params",
            "ivLength"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->IsResynchronizable",
          "args": [],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_buffer.New",
          "args": [
            "bufferByteSize"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "New",
          "container": "SecBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/secblock.h",
          "lines": "361-365",
          "snippet": "void New(size_type newSize)\n\t{\n\t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n\t\tm_size = newSize;\n\t}",
          "includes": [
            "#include <assert.h>",
            "#include \"misc.h\"",
            "#include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <assert.h>\n#include \"misc.h\"\n#include \"config.h\"\n\nSecBlock {\n  void New(size_type newSize)\n  \t{\n  \t\tm_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);\n  \t\tm_size = newSize;\n  \t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RoundUpToMultipleOf",
          "args": [
            "1024U",
            "GetBufferByteSize(policy)"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "RoundUpToMultipleOf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/misc.h",
          "lines": "355-360",
          "snippet": "inline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}",
          "includes": [
            "#include <byteswap.h>",
            "#include <mem.h>",
            "#include <intrin.h>",
            "#include <string.h>\t\t// for memcpy and memmove",
            "#include \"smartptr.h\"",
            "#include \"cryptlib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <byteswap.h>\n#include <mem.h>\n#include <intrin.h>\n#include <string.h>\t\t// for memcpy and memmove\n#include \"smartptr.h\"\n#include \"cryptlib.h\"\n\ninline T1 RoundUpToMultipleOf(const T1 &n, const T2 &m)\n{\n\tif (n+m-1 < n)\n\t\tthrow InvalidArgument(\"RoundUpToMultipleOf: integer overflow\");\n\treturn RoundDownToMultipleOf(n+m-1, m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBufferByteSize",
          "args": [
            "policy"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "GetBufferByteSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/strciphr.h",
          "lines": "153-153",
          "snippet": "unsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}",
          "includes": [
            "#include \"strciphr.cpp\"",
            "#include \"argnames.h\"",
            "#include \"secblock.h\"",
            "#include \"seckey.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"strciphr.cpp\"\n#include \"argnames.h\"\n#include \"secblock.h\"\n#include \"seckey.h\"\n\nunsigned int GetBufferByteSize(const PolicyInterface &policy) const {return policy.GetBytesPerIteration() * policy.GetIterationsToBuffer();}"
        }
      },
      {
        "call_info": {
          "callee": "policy.CanOperateKeystream",
          "args": [],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy.CipherSetKey",
          "args": [
            "params",
            "key",
            "length"
          ],
          "line": 15
        },
        "resolved": true,
        "details": {
          "function_name": "CipherSetKey",
          "container": "PanamaCipherPolicy<B>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/panama.cpp",
          "lines": "442-446",
          "snippet": "void PanamaCipherPolicy<B>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)\n{\n\tassert(length==32);\n\tmemcpy(m_key, key, 32);\n}",
          "includes": [
            "#include \"cpu.h\"",
            "#include \"misc.h\"",
            "#include \"panama.h\"",
            "#include \"pch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu.h\"\n#include \"misc.h\"\n#include \"panama.h\"\n#include \"pch.h\"\n\nPanamaCipherPolicy<B> {\n  void PanamaCipherPolicy<B>::CipherSetKey(const NameValuePairs &params, const byte *key, size_t length)\n  {\n  \tassert(length==32);\n  \tmemcpy(m_key, key, 32);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->AccessPolicy",
          "args": [],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"strciphr.h\"\n#include \"pch.h\"\n\nAdditiveCipherTemplate<S> {\n  void AdditiveCipherTemplate<S>::UncheckedSetKey(const byte *key, unsigned int length, const NameValuePairs &params)\n  {\n  \tPolicyInterface &policy = this->AccessPolicy();\n  \tpolicy.CipherSetKey(params, key, length);\n  \tm_leftOver = 0;\n  \tunsigned int bufferByteSize = policy.CanOperateKeystream() ? GetBufferByteSize(policy) : RoundUpToMultipleOf(1024U, GetBufferByteSize(policy));\n  \tm_buffer.New(bufferByteSize);\n  \n  \tif (this->IsResynchronizable())\n  \t{\n  \t\tsize_t ivLength;\n  \t\tconst byte *iv = this->GetIVAndThrowIfInvalid(params, ivLength);\n  \t\tpolicy.CipherResynchronize(m_buffer, iv, ivLength);\n  \t}\n  }\n}"
  }
]